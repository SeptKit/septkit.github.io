(function(){try{if(typeof document<`u`){var e=document.createElement(`style`);e.appendChild(document.createTextNode(`/*! tailwindcss v4.1.14 | MIT License | https://tailwindcss.com */
@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-font-weight:initial;--tw-outline-style:solid;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-stone-700:#44403b;--spacing:.25rem;--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--font-weight-medium:500;--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}@supports (color:lab(0% 0 0)){:root,:host{--color-stone-700:lab(27.3812% 1.32917 3.57789)}}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;-webkit-text-decoration:inherit;-webkit-text-decoration:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab, red, red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E");scrollbar-color:currentColor #0000}@supports (color:color-mix(in lab, red, red)){:root{scrollbar-color:color-mix(in oklch,currentColor 35%,#0000)#0000}}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab, red, red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),lab(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}@supports (width:if(else: 1px)) and (animation-timeline:scroll()){:root{animation:forwards set-page-has-scroll;animation-timeline:scroll()}@keyframes set-page-has-scroll{0%,to{--page-has-scroll:1}}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:if(style(--page-has-scroll: 1): stable; else: unset)}}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:where(:root),[data-theme=ocean-light]{--lightningcss-light:initial;--lightningcss-dark: ;color-scheme:light;--color-base-100:#f8f8f8;--color-base-200:#f5f5f5;--color-base-300:#e4e4e4;--color-base-content:#404040;--color-primary:#258998;--color-primary-content:#fff;--color-secondary:#4b9eaa;--color-secondary-content:#fff;--color-accent:#009588;--color-accent-content:#f8f8f8;--color-neutral:#78706a;--color-neutral-content:#f5fce5;--color-info:#50a0ff;--color-info-content:#f8f8f8;--color-success:#00c657;--color-success-content:#f8f8f8;--color-warning:#fdcf2b;--color-warning-content:#f8f8f8;--color-error:#f82834;--color-error-content:#f8f8f8;--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-300)}@supports (color:lab(0% 0 0)){:where(:root),[data-theme=ocean-light]{--color-base-100:lab(97.68% -.0000298023 .0000119209);--color-base-200:lab(96.52% -.0000298023 0);--color-base-300:lab(90.72% .0000298023 -.0000119209);--color-base-content:lab(26.92% 0 -.00000596046);--color-primary:lab(52.1182% -25.1013 -16.6644);--color-primary-content:lab(100% 0 0);--color-secondary:lab(60.3471% -23.6405 -14.4068);--color-secondary-content:lab(100% 0 0);--color-accent:lab(55.0223% -41.0774 -3.90277);--color-accent-content:lab(97.6886% -.0991523 .364268);--color-neutral:lab(47.7684% 2.35736 4.26879);--color-neutral-content:lab(98.0078% -5.32481 10.2158);--color-info:lab(64.2164% -1.27971 -56.9629);--color-info-content:lab(97.6886% -.0991523 .364268);--color-success:lab(70.2031% -66.5285 45.8378);--color-success-content:lab(97.6886% -.0991523 .364268);--color-warning:lab(85.3669% 6.20878 78.7667);--color-warning-content:lab(97.6886% -.0991523 .364268);--color-error:lab(54.6666% 75.0951 49.1053);--color-error-content:lab(97.6886% -.0991523 .364268)}}:root:has(input.theme-controller[value=ocean-light]:checked){--lightningcss-light:initial;--lightningcss-dark: ;color-scheme:light;--color-base-100:#f8f8f8;--color-base-200:#f5f5f5;--color-base-300:#e4e4e4;--color-base-content:#404040;--color-primary:#258998;--color-primary-content:#fff;--color-secondary:#4b9eaa;--color-secondary-content:#fff;--color-accent:#009588;--color-accent-content:#f8f8f8;--color-neutral:#78706a;--color-neutral-content:#f5fce5;--color-info:#50a0ff;--color-info-content:#f8f8f8;--color-success:#00c657;--color-success-content:#f8f8f8;--color-warning:#fdcf2b;--color-warning-content:#f8f8f8;--color-error:#f82834;--color-error-content:#f8f8f8;--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-300)}@supports (color:lab(0% 0 0)){:root:has(input.theme-controller[value=ocean-light]:checked){--color-base-100:lab(97.68% -.0000298023 .0000119209);--color-base-200:lab(96.52% -.0000298023 0);--color-base-300:lab(90.72% .0000298023 -.0000119209);--color-base-content:lab(26.92% 0 -.00000596046);--color-primary:lab(52.1182% -25.1013 -16.6644);--color-primary-content:lab(100% 0 0);--color-secondary:lab(60.3471% -23.6405 -14.4068);--color-secondary-content:lab(100% 0 0);--color-accent:lab(55.0223% -41.0774 -3.90277);--color-accent-content:lab(97.6886% -.0991523 .364268);--color-neutral:lab(47.7684% 2.35736 4.26879);--color-neutral-content:lab(98.0078% -5.32481 10.2158);--color-info:lab(64.2164% -1.27971 -56.9629);--color-info-content:lab(97.6886% -.0991523 .364268);--color-success:lab(70.2031% -66.5285 45.8378);--color-success-content:lab(97.6886% -.0991523 .364268);--color-warning:lab(85.3669% 6.20878 78.7667);--color-warning-content:lab(97.6886% -.0991523 .364268);--color-error:lab(54.6666% 75.0951 49.1053);--color-error-content:lab(97.6886% -.0991523 .364268)}}}@layer components;@layer utilities{.my-0\\.5{margin-block:calc(var(--spacing)*.5)}.flex{display:flex}.h-4{height:calc(var(--spacing)*4)}.h-full{height:100%}.w-4{width:calc(var(--spacing)*4)}.w-full{width:100%}.list-none{list-style-type:none}.items-center{align-items:center}.overflow-auto{overflow:auto}.rounded{border-radius:.25rem}.p-2{padding:calc(var(--spacing)*2)}.px-2{padding-inline:calc(var(--spacing)*2)}.py-1{padding-block:calc(var(--spacing)*1)}.pb-5{padding-bottom:calc(var(--spacing)*5)}.pl-2{padding-left:calc(var(--spacing)*2)}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.text-stone-700{color:var(--color-stone-700)}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.outline-none{--tw-outline-style:none;outline-style:none}.select-none{-webkit-user-select:none;user-select:none}.focus\\:ring-2:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}}:root{--color-ocean-gray-00:#fff;--color-ocean-gray-25:#fafbfb;--color-ocean-gray-50:#f5f6f7;--color-ocean-gray-75:#eaeeef;--color-ocean-gray-100:#e1e4e6;--color-ocean-gray-150:#c6ced1;--color-ocean-gray-200:#bac1c4;--color-ocean-gray-250:#9fadb2;--color-ocean-gray-300:#889499;--color-ocean-gray-350:#72858c;--color-ocean-gray-400:#617177;--color-ocean-gray-450:#3f555e;--color-ocean-gray-500:#394d55;--color-ocean-gray-550:#34464d;--color-ocean-gray-600:#2e3e44;--color-ocean-gray-650:#27353b;--color-ocean-gray-700:#222e33;--color-ocean-gray-750:#1f272b;--color-ocean-gray-800:#171f22;--color-ocean-gray-850:#11171a;--color-ocean-gray-900:#0b0f11;--color-chart-1:#f7931e;--color-chart-2:#40535b;--color-chart-3:#2798aa;--color-chart-4:#6da89c;--color-chart-5:#a4cadd;--color-chart-6:#97b42d;--color-chart-7:#ffcb05;--color-chart-8:#ee652e;--color-chart-9:#528694;--color-chart-10:#a10f3b}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes progress{50%{background-position-x:-115%}}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-outline-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}`)),document.head.appendChild(e)}}catch(e){console.error(`vite-plugin-css-injected-by-js`,e)}})();var __defProp = Object.defineProperty, __export = (E) => {
	let D = {};
	for (var O in E) __defProp(D, O, {
		get: E[O],
		enumerable: !0
	});
	return D;
};
/**
* @vue/shared v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/* @__NO_SIDE_EFFECTS__ */
function makeMap(u) {
	let E = /* @__PURE__ */ Object.create(null);
	for (let D of u.split(",")) E[D] = 1;
	return (u) => u in E;
}
var EMPTY_OBJ = {}, EMPTY_ARR = [], NOOP = () => {}, NO = () => !1, isOn = (u) => u.charCodeAt(0) === 111 && u.charCodeAt(1) === 110 && (u.charCodeAt(2) > 122 || u.charCodeAt(2) < 97), isModelListener = (u) => u.startsWith("onUpdate:"), extend = Object.assign, remove = (u, E) => {
	let D = u.indexOf(E);
	D > -1 && u.splice(D, 1);
}, hasOwnProperty$1 = Object.prototype.hasOwnProperty, hasOwn$2 = (u, E) => hasOwnProperty$1.call(u, E), isArray = Array.isArray, isMap = (u) => toTypeString(u) === "[object Map]", isSet = (u) => toTypeString(u) === "[object Set]", isDate = (u) => toTypeString(u) === "[object Date]", isRegExp = (u) => toTypeString(u) === "[object RegExp]", isFunction = (u) => typeof u == "function", isString = (u) => typeof u == "string", isSymbol = (u) => typeof u == "symbol", isObject$2 = (u) => typeof u == "object" && !!u, isPromise = (u) => (isObject$2(u) || isFunction(u)) && isFunction(u.then) && isFunction(u.catch), objectToString = Object.prototype.toString, toTypeString = (u) => objectToString.call(u), toRawType = (u) => toTypeString(u).slice(8, -1), isPlainObject$1 = (u) => toTypeString(u) === "[object Object]", isIntegerKey = (u) => isString(u) && u !== "NaN" && u[0] !== "-" && "" + parseInt(u, 10) === u, isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), cacheStringFunction$2 = (u) => {
	let E = /* @__PURE__ */ Object.create(null);
	return ((D) => E[D] || (E[D] = u(D)));
}, camelizeRE$2 = /-\w/g, camelize$2 = cacheStringFunction$2((u) => u.replace(camelizeRE$2, (u) => u.slice(1).toUpperCase())), hyphenateRE$2 = /\B([A-Z])/g, hyphenate$2 = cacheStringFunction$2((u) => u.replace(hyphenateRE$2, "-$1").toLowerCase()), capitalize = cacheStringFunction$2((u) => u.charAt(0).toUpperCase() + u.slice(1)), toHandlerKey = cacheStringFunction$2((u) => u ? `on${capitalize(u)}` : ""), hasChanged = (u, E) => !Object.is(u, E), invokeArrayFns = (u, ...E) => {
	for (let D = 0; D < u.length; D++) u[D](...E);
}, def = (u, E, D, O = !1) => {
	Object.defineProperty(u, E, {
		configurable: !0,
		enumerable: !1,
		writable: O,
		value: D
	});
}, looseToNumber = (u) => {
	let E = parseFloat(u);
	return isNaN(E) ? u : E;
}, toNumber = (u) => {
	let E = isString(u) ? Number(u) : NaN;
	return isNaN(E) ? u : E;
}, _globalThis, getGlobalThis = () => _globalThis ||= typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}, isGloballyAllowed = /* @__PURE__ */ makeMap("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol");
function normalizeStyle(u) {
	if (isArray(u)) {
		let E = {};
		for (let D = 0; D < u.length; D++) {
			let O = u[D], P = isString(O) ? parseStringStyle(O) : normalizeStyle(O);
			if (P) for (let u in P) E[u] = P[u];
		}
		return E;
	} else if (isString(u) || isObject$2(u)) return u;
}
var listDelimiterRE = /;(?![^(]*\))/g, propertyDelimiterRE = /:([^]+)/, styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(u) {
	let E = {};
	return u.replace(styleCommentRE, "").split(listDelimiterRE).forEach((u) => {
		if (u) {
			let D = u.split(propertyDelimiterRE);
			D.length > 1 && (E[D[0].trim()] = D[1].trim());
		}
	}), E;
}
function normalizeClass(u) {
	let E = "";
	if (isString(u)) E = u;
	else if (isArray(u)) for (let D = 0; D < u.length; D++) {
		let O = normalizeClass(u[D]);
		O && (E += O + " ");
	}
	else if (isObject$2(u)) for (let D in u) u[D] && (E += D + " ");
	return E.trim();
}
function normalizeProps(u) {
	if (!u) return null;
	let { class: E, style: D } = u;
	return E && !isString(E) && (u.class = normalizeClass(E)), D && (u.style = normalizeStyle(D)), u;
}
var specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
specialBooleanAttrs + "";
function includeBooleanAttr(u) {
	return !!u || u === "";
}
function looseCompareArrays(u, E) {
	if (u.length !== E.length) return !1;
	let D = !0;
	for (let O = 0; D && O < u.length; O++) D = looseEqual(u[O], E[O]);
	return D;
}
function looseEqual(u, E) {
	if (u === E) return !0;
	let D = isDate(u), O = isDate(E);
	if (D || O) return D && O ? u.getTime() === E.getTime() : !1;
	if (D = isSymbol(u), O = isSymbol(E), D || O) return u === E;
	if (D = isArray(u), O = isArray(E), D || O) return D && O ? looseCompareArrays(u, E) : !1;
	if (D = isObject$2(u), O = isObject$2(E), D || O) {
		if (!D || !O || Object.keys(u).length !== Object.keys(E).length) return !1;
		for (let D in u) {
			let O = u.hasOwnProperty(D), P = E.hasOwnProperty(D);
			if (O && !P || !O && P || !looseEqual(u[D], E[D])) return !1;
		}
	}
	return String(u) === String(E);
}
function looseIndexOf(u, E) {
	return u.findIndex((u) => looseEqual(u, E));
}
var isRef$1 = (u) => !!(u && u.__v_isRef === !0), toDisplayString = (u) => isString(u) ? u : u == null ? "" : isArray(u) || isObject$2(u) && (u.toString === objectToString || !isFunction(u.toString)) ? isRef$1(u) ? toDisplayString(u.value) : JSON.stringify(u, replacer, 2) : String(u), replacer = (u, E) => isRef$1(E) ? replacer(u, E.value) : isMap(E) ? { [`Map(${E.size})`]: [...E.entries()].reduce((u, [E, D], O) => (u[stringifySymbol(E, O) + " =>"] = D, u), {}) } : isSet(E) ? { [`Set(${E.size})`]: [...E.values()].map((u) => stringifySymbol(u)) } : isSymbol(E) ? stringifySymbol(E) : isObject$2(E) && !isArray(E) && !isPlainObject$1(E) ? String(E) : E, stringifySymbol = (u, E = "") => isSymbol(u) ? `Symbol(${u.description ?? E})` : u;
function normalizeCssVarValue(u) {
	return u == null ? "initial" : typeof u == "string" ? u === "" ? " " : u : String(u);
}
var activeEffectScope, EffectScope = class {
	constructor(u = !1) {
		this.detached = u, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = activeEffectScope, !u && activeEffectScope && (this.index = (activeEffectScope.scopes ||= []).push(this) - 1);
	}
	get active() {
		return this._active;
	}
	pause() {
		if (this._active) {
			this._isPaused = !0;
			let u, E;
			if (this.scopes) for (u = 0, E = this.scopes.length; u < E; u++) this.scopes[u].pause();
			for (u = 0, E = this.effects.length; u < E; u++) this.effects[u].pause();
		}
	}
	resume() {
		if (this._active && this._isPaused) {
			this._isPaused = !1;
			let u, E;
			if (this.scopes) for (u = 0, E = this.scopes.length; u < E; u++) this.scopes[u].resume();
			for (u = 0, E = this.effects.length; u < E; u++) this.effects[u].resume();
		}
	}
	run(u) {
		if (this._active) {
			let E = activeEffectScope;
			try {
				return activeEffectScope = this, u();
			} finally {
				activeEffectScope = E;
			}
		}
	}
	on() {
		++this._on === 1 && (this.prevScope = activeEffectScope, activeEffectScope = this);
	}
	off() {
		this._on > 0 && --this._on === 0 && (activeEffectScope = this.prevScope, this.prevScope = void 0);
	}
	stop(u) {
		if (this._active) {
			this._active = !1;
			let E, D;
			for (E = 0, D = this.effects.length; E < D; E++) this.effects[E].stop();
			for (this.effects.length = 0, E = 0, D = this.cleanups.length; E < D; E++) this.cleanups[E]();
			if (this.cleanups.length = 0, this.scopes) {
				for (E = 0, D = this.scopes.length; E < D; E++) this.scopes[E].stop(!0);
				this.scopes.length = 0;
			}
			if (!this.detached && this.parent && !u) {
				let u = this.parent.scopes.pop();
				u && u !== this && (this.parent.scopes[this.index] = u, u.index = this.index);
			}
			this.parent = void 0;
		}
	}
};
function effectScope(u) {
	return new EffectScope(u);
}
function getCurrentScope() {
	return activeEffectScope;
}
function onScopeDispose(u, E = !1) {
	activeEffectScope && activeEffectScope.cleanups.push(u);
}
var activeSub, pausedQueueEffects = /* @__PURE__ */ new WeakSet(), ReactiveEffect = class {
	constructor(u) {
		this.fn = u, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, activeEffectScope && activeEffectScope.active && activeEffectScope.effects.push(this);
	}
	pause() {
		this.flags |= 64;
	}
	resume() {
		this.flags & 64 && (this.flags &= -65, pausedQueueEffects.has(this) && (pausedQueueEffects.delete(this), this.trigger()));
	}
	notify() {
		this.flags & 2 && !(this.flags & 32) || this.flags & 8 || batch(this);
	}
	run() {
		if (!(this.flags & 1)) return this.fn();
		this.flags |= 2, cleanupEffect(this), prepareDeps(this);
		let u = activeSub, E = shouldTrack;
		activeSub = this, shouldTrack = !0;
		try {
			return this.fn();
		} finally {
			cleanupDeps(this), activeSub = u, shouldTrack = E, this.flags &= -3;
		}
	}
	stop() {
		if (this.flags & 1) {
			for (let u = this.deps; u; u = u.nextDep) removeSub(u);
			this.deps = this.depsTail = void 0, cleanupEffect(this), this.onStop && this.onStop(), this.flags &= -2;
		}
	}
	trigger() {
		this.flags & 64 ? pausedQueueEffects.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
	}
	runIfDirty() {
		isDirty(this) && this.run();
	}
	get dirty() {
		return isDirty(this);
	}
}, batchDepth = 0, batchedSub, batchedComputed;
function batch(u, E = !1) {
	if (u.flags |= 8, E) {
		u.next = batchedComputed, batchedComputed = u;
		return;
	}
	u.next = batchedSub, batchedSub = u;
}
function startBatch() {
	batchDepth++;
}
function endBatch() {
	if (--batchDepth > 0) return;
	if (batchedComputed) {
		let u = batchedComputed;
		for (batchedComputed = void 0; u;) {
			let E = u.next;
			u.next = void 0, u.flags &= -9, u = E;
		}
	}
	let u;
	for (; batchedSub;) {
		let E = batchedSub;
		for (batchedSub = void 0; E;) {
			let D = E.next;
			if (E.next = void 0, E.flags &= -9, E.flags & 1) try {
				E.trigger();
			} catch (E) {
				u ||= E;
			}
			E = D;
		}
	}
	if (u) throw u;
}
function prepareDeps(u) {
	for (let E = u.deps; E; E = E.nextDep) E.version = -1, E.prevActiveLink = E.dep.activeLink, E.dep.activeLink = E;
}
function cleanupDeps(u) {
	let E, D = u.depsTail, O = D;
	for (; O;) {
		let u = O.prevDep;
		O.version === -1 ? (O === D && (D = u), removeSub(O), removeDep(O)) : E = O, O.dep.activeLink = O.prevActiveLink, O.prevActiveLink = void 0, O = u;
	}
	u.deps = E, u.depsTail = D;
}
function isDirty(u) {
	for (let E = u.deps; E; E = E.nextDep) if (E.dep.version !== E.version || E.dep.computed && (refreshComputed(E.dep.computed) || E.dep.version !== E.version)) return !0;
	return !!u._dirty;
}
function refreshComputed(u) {
	if (u.flags & 4 && !(u.flags & 16) || (u.flags &= -17, u.globalVersion === globalVersion) || (u.globalVersion = globalVersion, !u.isSSR && u.flags & 128 && (!u.deps && !u._dirty || !isDirty(u)))) return;
	u.flags |= 2;
	let E = u.dep, D = activeSub, O = shouldTrack;
	activeSub = u, shouldTrack = !0;
	try {
		prepareDeps(u);
		let D = u.fn(u._value);
		(E.version === 0 || hasChanged(D, u._value)) && (u.flags |= 128, u._value = D, E.version++);
	} catch (u) {
		throw E.version++, u;
	} finally {
		activeSub = D, shouldTrack = O, cleanupDeps(u), u.flags &= -3;
	}
}
function removeSub(u, E = !1) {
	let { dep: D, prevSub: O, nextSub: P } = u;
	if (O && (O.nextSub = P, u.prevSub = void 0), P && (P.prevSub = O, u.nextSub = void 0), D.subs === u && (D.subs = O, !O && D.computed)) {
		D.computed.flags &= -5;
		for (let u = D.computed.deps; u; u = u.nextDep) removeSub(u, !0);
	}
	!E && !--D.sc && D.map && D.map.delete(D.key);
}
function removeDep(u) {
	let { prevDep: E, nextDep: D } = u;
	E && (E.nextDep = D, u.prevDep = void 0), D && (D.prevDep = E, u.nextDep = void 0);
}
function effect(u, E) {
	u.effect instanceof ReactiveEffect && (u = u.effect.fn);
	let D = new ReactiveEffect(u);
	E && extend(D, E);
	try {
		D.run();
	} catch (u) {
		throw D.stop(), u;
	}
	let O = D.run.bind(D);
	return O.effect = D, O;
}
function stop(u) {
	u.effect.stop();
}
var shouldTrack = !0, trackStack = [];
function pauseTracking() {
	trackStack.push(shouldTrack), shouldTrack = !1;
}
function resetTracking() {
	let u = trackStack.pop();
	shouldTrack = u === void 0 ? !0 : u;
}
function cleanupEffect(u) {
	let { cleanup: E } = u;
	if (u.cleanup = void 0, E) {
		let u = activeSub;
		activeSub = void 0;
		try {
			E();
		} finally {
			activeSub = u;
		}
	}
}
var globalVersion = 0, Link = class {
	constructor(u, E) {
		this.sub = u, this.dep = E, this.version = E.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
	}
}, Dep = class {
	constructor(u) {
		this.computed = u, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
	}
	track(u) {
		if (!activeSub || !shouldTrack || activeSub === this.computed) return;
		let E = this.activeLink;
		if (E === void 0 || E.sub !== activeSub) E = this.activeLink = new Link(activeSub, this), activeSub.deps ? (E.prevDep = activeSub.depsTail, activeSub.depsTail.nextDep = E, activeSub.depsTail = E) : activeSub.deps = activeSub.depsTail = E, addSub(E);
		else if (E.version === -1 && (E.version = this.version, E.nextDep)) {
			let u = E.nextDep;
			u.prevDep = E.prevDep, E.prevDep && (E.prevDep.nextDep = u), E.prevDep = activeSub.depsTail, E.nextDep = void 0, activeSub.depsTail.nextDep = E, activeSub.depsTail = E, activeSub.deps === E && (activeSub.deps = u);
		}
		return E;
	}
	trigger(u) {
		this.version++, globalVersion++, this.notify(u);
	}
	notify(u) {
		startBatch();
		try {
			for (let u = this.subs; u; u = u.prevSub) u.sub.notify() && u.sub.dep.notify();
		} finally {
			endBatch();
		}
	}
};
function addSub(u) {
	if (u.dep.sc++, u.sub.flags & 4) {
		let E = u.dep.computed;
		if (E && !u.dep.subs) {
			E.flags |= 20;
			for (let u = E.deps; u; u = u.nextDep) addSub(u);
		}
		let D = u.dep.subs;
		D !== u && (u.prevSub = D, D && (D.nextSub = u)), u.dep.subs = u;
	}
}
var targetMap = /* @__PURE__ */ new WeakMap(), ITERATE_KEY = Symbol(""), MAP_KEY_ITERATE_KEY = Symbol(""), ARRAY_ITERATE_KEY = Symbol("");
function track(u, E, D) {
	if (shouldTrack && activeSub) {
		let E = targetMap.get(u);
		E || targetMap.set(u, E = /* @__PURE__ */ new Map());
		let O = E.get(D);
		O || (E.set(D, O = new Dep()), O.map = E, O.key = D), O.track();
	}
}
function trigger(u, E, D, O, P, F) {
	let I = targetMap.get(u);
	if (!I) {
		globalVersion++;
		return;
	}
	let R = (u) => {
		u && u.trigger();
	};
	if (startBatch(), E === "clear") I.forEach(R);
	else {
		let P = isArray(u), F = P && isIntegerKey(D);
		if (P && D === "length") {
			let u = Number(O);
			I.forEach((E, D) => {
				(D === "length" || D === ARRAY_ITERATE_KEY || !isSymbol(D) && D >= u) && R(E);
			});
		} else switch ((D !== void 0 || I.has(void 0)) && R(I.get(D)), F && R(I.get(ARRAY_ITERATE_KEY)), E) {
			case "add":
				P ? F && R(I.get("length")) : (R(I.get(ITERATE_KEY)), isMap(u) && R(I.get(MAP_KEY_ITERATE_KEY)));
				break;
			case "delete":
				P || (R(I.get(ITERATE_KEY)), isMap(u) && R(I.get(MAP_KEY_ITERATE_KEY)));
				break;
			case "set":
				isMap(u) && R(I.get(ITERATE_KEY));
				break;
		}
	}
	endBatch();
}
function getDepFromReactive(u, E) {
	let D = targetMap.get(u);
	return D && D.get(E);
}
function reactiveReadArray(u) {
	let E = toRaw(u);
	return E === u ? E : (track(E, "iterate", ARRAY_ITERATE_KEY), isShallow(u) ? E : E.map(toReactive));
}
function shallowReadArray(u) {
	return track(u = toRaw(u), "iterate", ARRAY_ITERATE_KEY), u;
}
var arrayInstrumentations = {
	__proto__: null,
	[Symbol.iterator]() {
		return iterator(this, Symbol.iterator, toReactive);
	},
	concat(...u) {
		return reactiveReadArray(this).concat(...u.map((u) => isArray(u) ? reactiveReadArray(u) : u));
	},
	entries() {
		return iterator(this, "entries", (u) => (u[1] = toReactive(u[1]), u));
	},
	every(u, E) {
		return apply(this, "every", u, E, void 0, arguments);
	},
	filter(u, E) {
		return apply(this, "filter", u, E, (u) => u.map(toReactive), arguments);
	},
	find(u, E) {
		return apply(this, "find", u, E, toReactive, arguments);
	},
	findIndex(u, E) {
		return apply(this, "findIndex", u, E, void 0, arguments);
	},
	findLast(u, E) {
		return apply(this, "findLast", u, E, toReactive, arguments);
	},
	findLastIndex(u, E) {
		return apply(this, "findLastIndex", u, E, void 0, arguments);
	},
	forEach(u, E) {
		return apply(this, "forEach", u, E, void 0, arguments);
	},
	includes(...u) {
		return searchProxy(this, "includes", u);
	},
	indexOf(...u) {
		return searchProxy(this, "indexOf", u);
	},
	join(u) {
		return reactiveReadArray(this).join(u);
	},
	lastIndexOf(...u) {
		return searchProxy(this, "lastIndexOf", u);
	},
	map(u, E) {
		return apply(this, "map", u, E, void 0, arguments);
	},
	pop() {
		return noTracking(this, "pop");
	},
	push(...u) {
		return noTracking(this, "push", u);
	},
	reduce(u, ...E) {
		return reduce(this, "reduce", u, E);
	},
	reduceRight(u, ...E) {
		return reduce(this, "reduceRight", u, E);
	},
	shift() {
		return noTracking(this, "shift");
	},
	some(u, E) {
		return apply(this, "some", u, E, void 0, arguments);
	},
	splice(...u) {
		return noTracking(this, "splice", u);
	},
	toReversed() {
		return reactiveReadArray(this).toReversed();
	},
	toSorted(u) {
		return reactiveReadArray(this).toSorted(u);
	},
	toSpliced(...u) {
		return reactiveReadArray(this).toSpliced(...u);
	},
	unshift(...u) {
		return noTracking(this, "unshift", u);
	},
	values() {
		return iterator(this, "values", toReactive);
	}
};
function iterator(u, E, D) {
	let O = shallowReadArray(u), P = O[E]();
	return O !== u && !isShallow(u) && (P._next = P.next, P.next = () => {
		let u = P._next();
		return u.done || (u.value = D(u.value)), u;
	}), P;
}
var arrayProto = Array.prototype;
function apply(u, E, D, O, P, F) {
	let I = shallowReadArray(u), R = I !== u && !isShallow(u), U = I[E];
	if (U !== arrayProto[E]) {
		let E = U.apply(u, F);
		return R ? toReactive(E) : E;
	}
	let J = D;
	I !== u && (R ? J = function(E, O) {
		return D.call(this, toReactive(E), O, u);
	} : D.length > 2 && (J = function(E, O) {
		return D.call(this, E, O, u);
	}));
	let _p = U.call(I, J, O);
	return R && P ? P(_p) : _p;
}
function reduce(u, E, D, O) {
	let P = shallowReadArray(u), F = D;
	return P !== u && (isShallow(u) ? D.length > 3 && (F = function(E, O, P) {
		return D.call(this, E, O, P, u);
	}) : F = function(E, O, P) {
		return D.call(this, E, toReactive(O), P, u);
	}), P[E](F, ...O);
}
function searchProxy(u, E, D) {
	let O = toRaw(u);
	track(O, "iterate", ARRAY_ITERATE_KEY);
	let P = O[E](...D);
	return (P === -1 || P === !1) && isProxy(D[0]) ? (D[0] = toRaw(D[0]), O[E](...D)) : P;
}
function noTracking(u, E, D = []) {
	pauseTracking(), startBatch();
	let O = toRaw(u)[E].apply(u, D);
	return endBatch(), resetTracking(), O;
}
var isNonTrackableKeys = /* @__PURE__ */ makeMap("__proto__,__v_isRef,__isVue"), builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((u) => u !== "arguments" && u !== "caller").map((u) => Symbol[u]).filter(isSymbol));
function hasOwnProperty(u) {
	isSymbol(u) || (u = String(u));
	let E = toRaw(this);
	return track(E, "has", u), E.hasOwnProperty(u);
}
var BaseReactiveHandler = class {
	constructor(u = !1, E = !1) {
		this._isReadonly = u, this._isShallow = E;
	}
	get(u, E, D) {
		if (E === "__v_skip") return u.__v_skip;
		let O = this._isReadonly, P = this._isShallow;
		if (E === "__v_isReactive") return !O;
		if (E === "__v_isReadonly") return O;
		if (E === "__v_isShallow") return P;
		if (E === "__v_raw") return D === (O ? P ? shallowReadonlyMap : readonlyMap : P ? shallowReactiveMap : reactiveMap).get(u) || Object.getPrototypeOf(u) === Object.getPrototypeOf(D) ? u : void 0;
		let F = isArray(u);
		if (!O) {
			let u;
			if (F && (u = arrayInstrumentations[E])) return u;
			if (E === "hasOwnProperty") return hasOwnProperty;
		}
		let I = Reflect.get(u, E, isRef(u) ? u : D);
		if ((isSymbol(E) ? builtInSymbols.has(E) : isNonTrackableKeys(E)) || (O || track(u, "get", E), P)) return I;
		if (isRef(I)) {
			let u = F && isIntegerKey(E) ? I : I.value;
			return O && isObject$2(u) ? readonly(u) : u;
		}
		return isObject$2(I) ? O ? readonly(I) : reactive(I) : I;
	}
}, MutableReactiveHandler = class extends BaseReactiveHandler {
	constructor(u = !1) {
		super(!1, u);
	}
	set(u, E, D, O) {
		let P = u[E];
		if (!this._isShallow) {
			let E = isReadonly(P);
			if (!isShallow(D) && !isReadonly(D) && (P = toRaw(P), D = toRaw(D)), !isArray(u) && isRef(P) && !isRef(D)) return E || (P.value = D), !0;
		}
		let F = isArray(u) && isIntegerKey(E) ? Number(E) < u.length : hasOwn$2(u, E), I = Reflect.set(u, E, D, isRef(u) ? u : O);
		return u === toRaw(O) && (F ? hasChanged(D, P) && trigger(u, "set", E, D, P) : trigger(u, "add", E, D)), I;
	}
	deleteProperty(u, E) {
		let D = hasOwn$2(u, E), O = u[E], P = Reflect.deleteProperty(u, E);
		return P && D && trigger(u, "delete", E, void 0, O), P;
	}
	has(u, E) {
		let D = Reflect.has(u, E);
		return (!isSymbol(E) || !builtInSymbols.has(E)) && track(u, "has", E), D;
	}
	ownKeys(u) {
		return track(u, "iterate", isArray(u) ? "length" : ITERATE_KEY), Reflect.ownKeys(u);
	}
}, ReadonlyReactiveHandler = class extends BaseReactiveHandler {
	constructor(u = !1) {
		super(!0, u);
	}
	set(u, E) {
		return !0;
	}
	deleteProperty(u, E) {
		return !0;
	}
}, mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler(), readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(), shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(!0), shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(!0), toShallow = (u) => u, getProto = (u) => Reflect.getPrototypeOf(u);
function createIterableMethod(u, E, D) {
	return function(...O) {
		let P = this.__v_raw, F = toRaw(P), I = isMap(F), R = u === "entries" || u === Symbol.iterator && I, U = u === "keys" && I, J = P[u](...O), _p = D ? toShallow : E ? toReadonly : toReactive;
		return !E && track(F, "iterate", U ? MAP_KEY_ITERATE_KEY : ITERATE_KEY), {
			next() {
				let { value: u, done: E } = J.next();
				return E ? {
					value: u,
					done: E
				} : {
					value: R ? [_p(u[0]), _p(u[1])] : _p(u),
					done: E
				};
			},
			[Symbol.iterator]() {
				return this;
			}
		};
	};
}
function createReadonlyMethod(u) {
	return function(...E) {
		return u === "delete" ? !1 : u === "clear" ? void 0 : this;
	};
}
function createInstrumentations(u, E) {
	let D = {
		get(D) {
			let O = this.__v_raw, P = toRaw(O), F = toRaw(D);
			u || (hasChanged(D, F) && track(P, "get", D), track(P, "get", F));
			let { has: I } = getProto(P), R = E ? toShallow : u ? toReadonly : toReactive;
			if (I.call(P, D)) return R(O.get(D));
			if (I.call(P, F)) return R(O.get(F));
			O !== P && O.get(D);
		},
		get size() {
			let E = this.__v_raw;
			return !u && track(toRaw(E), "iterate", ITERATE_KEY), E.size;
		},
		has(E) {
			let D = this.__v_raw, O = toRaw(D), P = toRaw(E);
			return u || (hasChanged(E, P) && track(O, "has", E), track(O, "has", P)), E === P ? D.has(E) : D.has(E) || D.has(P);
		},
		forEach(D, O) {
			let P = this, F = P.__v_raw, I = toRaw(F), R = E ? toShallow : u ? toReadonly : toReactive;
			return !u && track(I, "iterate", ITERATE_KEY), F.forEach((u, E) => D.call(O, R(u), R(E), P));
		}
	};
	return extend(D, u ? {
		add: createReadonlyMethod("add"),
		set: createReadonlyMethod("set"),
		delete: createReadonlyMethod("delete"),
		clear: createReadonlyMethod("clear")
	} : {
		add(u) {
			!E && !isShallow(u) && !isReadonly(u) && (u = toRaw(u));
			let D = toRaw(this);
			return getProto(D).has.call(D, u) || (D.add(u), trigger(D, "add", u, u)), this;
		},
		set(u, D) {
			!E && !isShallow(D) && !isReadonly(D) && (D = toRaw(D));
			let O = toRaw(this), { has: P, get: F } = getProto(O), I = P.call(O, u);
			I ||= (u = toRaw(u), P.call(O, u));
			let R = F.call(O, u);
			return O.set(u, D), I ? hasChanged(D, R) && trigger(O, "set", u, D, R) : trigger(O, "add", u, D), this;
		},
		delete(u) {
			let E = toRaw(this), { has: D, get: O } = getProto(E), P = D.call(E, u);
			P ||= (u = toRaw(u), D.call(E, u));
			let F = O ? O.call(E, u) : void 0, I = E.delete(u);
			return P && trigger(E, "delete", u, void 0, F), I;
		},
		clear() {
			let u = toRaw(this), E = u.size !== 0, D = u.clear();
			return E && trigger(u, "clear", void 0, void 0, void 0), D;
		}
	}), [
		"keys",
		"values",
		"entries",
		Symbol.iterator
	].forEach((O) => {
		D[O] = createIterableMethod(O, u, E);
	}), D;
}
function createInstrumentationGetter(u, E) {
	let D = createInstrumentations(u, E);
	return (E, O, P) => O === "__v_isReactive" ? !u : O === "__v_isReadonly" ? u : O === "__v_raw" ? E : Reflect.get(hasOwn$2(D, O) && O in E ? D : E, O, P);
}
var mutableCollectionHandlers = { get: /* @__PURE__ */ createInstrumentationGetter(!1, !1) }, shallowCollectionHandlers = { get: /* @__PURE__ */ createInstrumentationGetter(!1, !0) }, readonlyCollectionHandlers = { get: /* @__PURE__ */ createInstrumentationGetter(!0, !1) }, shallowReadonlyCollectionHandlers = { get: /* @__PURE__ */ createInstrumentationGetter(!0, !0) }, reactiveMap = /* @__PURE__ */ new WeakMap(), shallowReactiveMap = /* @__PURE__ */ new WeakMap(), readonlyMap = /* @__PURE__ */ new WeakMap(), shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(u) {
	switch (u) {
		case "Object":
		case "Array": return 1;
		case "Map":
		case "Set":
		case "WeakMap":
		case "WeakSet": return 2;
		default: return 0;
	}
}
function getTargetType(u) {
	return u.__v_skip || !Object.isExtensible(u) ? 0 : targetTypeMap(toRawType(u));
}
function reactive(u) {
	return isReadonly(u) ? u : createReactiveObject(u, !1, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(u) {
	return createReactiveObject(u, !1, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(u) {
	return createReactiveObject(u, !0, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(u) {
	return createReactiveObject(u, !0, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(u, E, D, O, P) {
	if (!isObject$2(u) || u.__v_raw && !(E && u.__v_isReactive)) return u;
	let F = getTargetType(u);
	if (F === 0) return u;
	let I = P.get(u);
	if (I) return I;
	let R = new Proxy(u, F === 2 ? O : D);
	return P.set(u, R), R;
}
function isReactive(u) {
	return isReadonly(u) ? isReactive(u.__v_raw) : !!(u && u.__v_isReactive);
}
function isReadonly(u) {
	return !!(u && u.__v_isReadonly);
}
function isShallow(u) {
	return !!(u && u.__v_isShallow);
}
function isProxy(u) {
	return u ? !!u.__v_raw : !1;
}
function toRaw(u) {
	let E = u && u.__v_raw;
	return E ? toRaw(E) : u;
}
function markRaw(u) {
	return !hasOwn$2(u, "__v_skip") && Object.isExtensible(u) && def(u, "__v_skip", !0), u;
}
var toReactive = (u) => isObject$2(u) ? reactive(u) : u, toReadonly = (u) => isObject$2(u) ? readonly(u) : u;
function isRef(u) {
	return u ? u.__v_isRef === !0 : !1;
}
function ref(u) {
	return createRef$2(u, !1);
}
function shallowRef(u) {
	return createRef$2(u, !0);
}
function createRef$2(u, E) {
	return isRef(u) ? u : new RefImpl(u, E);
}
var RefImpl = class {
	constructor(u, E) {
		this.dep = new Dep(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = E ? u : toRaw(u), this._value = E ? u : toReactive(u), this.__v_isShallow = E;
	}
	get value() {
		return this.dep.track(), this._value;
	}
	set value(u) {
		let E = this._rawValue, D = this.__v_isShallow || isShallow(u) || isReadonly(u);
		u = D ? u : toRaw(u), hasChanged(u, E) && (this._rawValue = u, this._value = D ? u : toReactive(u), this.dep.trigger());
	}
};
function triggerRef(u) {
	u.dep && u.dep.trigger();
}
function unref(u) {
	return isRef(u) ? u.value : u;
}
function toValue(u) {
	return isFunction(u) ? u() : unref(u);
}
var shallowUnwrapHandlers = {
	get: (u, E, D) => E === "__v_raw" ? u : unref(Reflect.get(u, E, D)),
	set: (u, E, D, O) => {
		let P = u[E];
		return isRef(P) && !isRef(D) ? (P.value = D, !0) : Reflect.set(u, E, D, O);
	}
};
function proxyRefs(u) {
	return isReactive(u) ? u : new Proxy(u, shallowUnwrapHandlers);
}
var CustomRefImpl = class {
	constructor(u) {
		this.__v_isRef = !0, this._value = void 0;
		let E = this.dep = new Dep(), { get: D, set: O } = u(E.track.bind(E), E.trigger.bind(E));
		this._get = D, this._set = O;
	}
	get value() {
		return this._value = this._get();
	}
	set value(u) {
		this._set(u);
	}
};
function customRef(u) {
	return new CustomRefImpl(u);
}
function toRefs(u) {
	let E = isArray(u) ? Array(u.length) : {};
	for (let D in u) E[D] = propertyToRef(u, D);
	return E;
}
var ObjectRefImpl = class {
	constructor(u, E, D) {
		this._object = u, this._key = E, this._defaultValue = D, this.__v_isRef = !0, this._value = void 0;
	}
	get value() {
		let u = this._object[this._key];
		return this._value = u === void 0 ? this._defaultValue : u;
	}
	set value(u) {
		this._object[this._key] = u;
	}
	get dep() {
		return getDepFromReactive(toRaw(this._object), this._key);
	}
}, GetterRefImpl = class {
	constructor(u) {
		this._getter = u, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
	}
	get value() {
		return this._value = this._getter();
	}
};
function toRef(u, E, D) {
	return isRef(u) ? u : isFunction(u) ? new GetterRefImpl(u) : isObject$2(u) && arguments.length > 1 ? propertyToRef(u, E, D) : ref(u);
}
function propertyToRef(u, E, D) {
	let O = u[E];
	return isRef(O) ? O : new ObjectRefImpl(u, E, D);
}
var ComputedRefImpl = class {
	constructor(u, E, D) {
		this.fn = u, this.setter = E, this._value = void 0, this.dep = new Dep(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = globalVersion - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !E, this.isSSR = D;
	}
	notify() {
		if (this.flags |= 16, !(this.flags & 8) && activeSub !== this) return batch(this, !0), !0;
	}
	get value() {
		let u = this.dep.track();
		return refreshComputed(this), u && (u.version = this.dep.version), this._value;
	}
	set value(u) {
		this.setter && this.setter(u);
	}
};
function computed$1(u, E, D = !1) {
	let O, P;
	return isFunction(u) ? O = u : (O = u.get, P = u.set), new ComputedRefImpl(O, P, D);
}
var TrackOpTypes = {
	GET: "get",
	HAS: "has",
	ITERATE: "iterate"
}, TriggerOpTypes = {
	SET: "set",
	ADD: "add",
	DELETE: "delete",
	CLEAR: "clear"
}, INITIAL_WATCHER_VALUE = {}, cleanupMap = /* @__PURE__ */ new WeakMap(), activeWatcher = void 0;
function getCurrentWatcher() {
	return activeWatcher;
}
function onWatcherCleanup(u, E = !1, D = activeWatcher) {
	if (D) {
		let E = cleanupMap.get(D);
		E || cleanupMap.set(D, E = []), E.push(u);
	}
}
function watch$1(u, E, D = EMPTY_OBJ) {
	let { immediate: P, deep: I, once: R, scheduler: U, augmentJob: J, call: vp } = D, yp = (u) => I ? u : isShallow(u) || I === !1 || I === 0 ? traverse(u, 1) : traverse(u), xp, Sp, Cp, wp, Ep = !1, Dp = !1;
	if (isRef(u) ? (Sp = () => u.value, Ep = isShallow(u)) : isReactive(u) ? (Sp = () => yp(u), Ep = !0) : isArray(u) ? (Dp = !0, Ep = u.some((u) => isReactive(u) || isShallow(u)), Sp = () => u.map((u) => {
		if (isRef(u)) return u.value;
		if (isReactive(u)) return yp(u);
		if (isFunction(u)) return vp ? vp(u, 2) : u();
	})) : Sp = isFunction(u) ? E ? vp ? () => vp(u, 2) : u : () => {
		if (Cp) {
			pauseTracking();
			try {
				Cp();
			} finally {
				resetTracking();
			}
		}
		let E = activeWatcher;
		activeWatcher = xp;
		try {
			return vp ? vp(u, 3, [wp]) : u(wp);
		} finally {
			activeWatcher = E;
		}
	} : NOOP, E && I) {
		let u = Sp, E = I === !0 ? Infinity : I;
		Sp = () => traverse(u(), E);
	}
	let Op = getCurrentScope(), kp = () => {
		xp.stop(), Op && Op.active && remove(Op.effects, xp);
	};
	if (R && E) {
		let u = E;
		E = (...E) => {
			u(...E), kp();
		};
	}
	let Ap = Dp ? Array(u.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE, jp = (u) => {
		if (!(!(xp.flags & 1) || !xp.dirty && !u)) if (E) {
			let u = xp.run();
			if (I || Ep || (Dp ? u.some((u, E) => hasChanged(u, Ap[E])) : hasChanged(u, Ap))) {
				Cp && Cp();
				let D = activeWatcher;
				activeWatcher = xp;
				try {
					let D = [
						u,
						Ap === INITIAL_WATCHER_VALUE ? void 0 : Dp && Ap[0] === INITIAL_WATCHER_VALUE ? [] : Ap,
						wp
					];
					Ap = u, vp ? vp(E, 3, D) : E(...D);
				} finally {
					activeWatcher = D;
				}
			}
		} else xp.run();
	};
	return J && J(jp), xp = new ReactiveEffect(Sp), xp.scheduler = U ? () => U(jp, !1) : jp, wp = (u) => onWatcherCleanup(u, !1, xp), Cp = xp.onStop = () => {
		let u = cleanupMap.get(xp);
		if (u) {
			if (vp) vp(u, 4);
			else for (let E of u) E();
			cleanupMap.delete(xp);
		}
	}, E ? P ? jp(!0) : Ap = xp.run() : U ? U(jp.bind(null, !0), !0) : xp.run(), kp.pause = xp.pause.bind(xp), kp.resume = xp.resume.bind(xp), kp.stop = kp, kp;
}
function traverse(u, E = Infinity, D) {
	if (E <= 0 || !isObject$2(u) || u.__v_skip || (D ||= /* @__PURE__ */ new Map(), (D.get(u) || 0) >= E)) return u;
	if (D.set(u, E), E--, isRef(u)) traverse(u.value, E, D);
	else if (isArray(u)) for (let O = 0; O < u.length; O++) traverse(u[O], E, D);
	else if (isSet(u) || isMap(u)) u.forEach((u) => {
		traverse(u, E, D);
	});
	else if (isPlainObject$1(u)) {
		for (let O in u) traverse(u[O], E, D);
		for (let O of Object.getOwnPropertySymbols(u)) Object.prototype.propertyIsEnumerable.call(u, O) && traverse(u[O], E, D);
	}
	return u;
}
var stack = [];
function pushWarningContext(u) {
	stack.push(u);
}
function popWarningContext() {
	stack.pop();
}
function assertNumber(u, E) {}
var ErrorCodes = {
	SETUP_FUNCTION: 0,
	0: "SETUP_FUNCTION",
	RENDER_FUNCTION: 1,
	1: "RENDER_FUNCTION",
	NATIVE_EVENT_HANDLER: 5,
	5: "NATIVE_EVENT_HANDLER",
	COMPONENT_EVENT_HANDLER: 6,
	6: "COMPONENT_EVENT_HANDLER",
	VNODE_HOOK: 7,
	7: "VNODE_HOOK",
	DIRECTIVE_HOOK: 8,
	8: "DIRECTIVE_HOOK",
	TRANSITION_HOOK: 9,
	9: "TRANSITION_HOOK",
	APP_ERROR_HANDLER: 10,
	10: "APP_ERROR_HANDLER",
	APP_WARN_HANDLER: 11,
	11: "APP_WARN_HANDLER",
	FUNCTION_REF: 12,
	12: "FUNCTION_REF",
	ASYNC_COMPONENT_LOADER: 13,
	13: "ASYNC_COMPONENT_LOADER",
	SCHEDULER: 14,
	14: "SCHEDULER",
	COMPONENT_UPDATE: 15,
	15: "COMPONENT_UPDATE",
	APP_UNMOUNT_CLEANUP: 16,
	16: "APP_UNMOUNT_CLEANUP"
}, ErrorTypeStrings$1 = {
	sp: "serverPrefetch hook",
	bc: "beforeCreate hook",
	c: "created hook",
	bm: "beforeMount hook",
	m: "mounted hook",
	bu: "beforeUpdate hook",
	u: "updated",
	bum: "beforeUnmount hook",
	um: "unmounted hook",
	a: "activated hook",
	da: "deactivated hook",
	ec: "errorCaptured hook",
	rtc: "renderTracked hook",
	rtg: "renderTriggered hook",
	0: "setup function",
	1: "render function",
	2: "watcher getter",
	3: "watcher callback",
	4: "watcher cleanup function",
	5: "native event handler",
	6: "component event handler",
	7: "vnode hook",
	8: "directive hook",
	9: "transition hook",
	10: "app errorHandler",
	11: "app warnHandler",
	12: "ref function",
	13: "async component loader",
	14: "scheduler flush",
	15: "component update",
	16: "app unmount cleanup function"
};
function callWithErrorHandling(u, E, D, O) {
	try {
		return O ? u(...O) : u();
	} catch (u) {
		handleError(u, E, D);
	}
}
function callWithAsyncErrorHandling(u, E, D, O) {
	if (isFunction(u)) {
		let P = callWithErrorHandling(u, E, D, O);
		return P && isPromise(P) && P.catch((u) => {
			handleError(u, E, D);
		}), P;
	}
	if (isArray(u)) {
		let P = [];
		for (let F = 0; F < u.length; F++) P.push(callWithAsyncErrorHandling(u[F], E, D, O));
		return P;
	}
}
function handleError(u, E, D, P = !0) {
	let F = E ? E.vnode : null, { errorHandler: I, throwUnhandledErrorInProduction: R } = E && E.appContext.config || EMPTY_OBJ;
	if (E) {
		let O = E.parent, P = E.proxy, F = `https://vuejs.org/error-reference/#runtime-${D}`;
		for (; O;) {
			let E = O.ec;
			if (E) {
				for (let D = 0; D < E.length; D++) if (E[D](u, P, F) === !1) return;
			}
			O = O.parent;
		}
		if (I) {
			pauseTracking(), callWithErrorHandling(I, null, 10, [
				u,
				P,
				F
			]), resetTracking();
			return;
		}
	}
	logError(u, D, F, P, R);
}
function logError(u, E, D, O = !0, P = !1) {
	if (P) throw u;
	console.error(u);
}
var queue = [], flushIndex = -1, pendingPostFlushCbs = [], activePostFlushCbs = null, postFlushIndex = 0, resolvedPromise = /* @__PURE__ */ Promise.resolve(), currentFlushPromise = null;
function nextTick(u) {
	let E = currentFlushPromise || resolvedPromise;
	return u ? E.then(this ? u.bind(this) : u) : E;
}
function findInsertionIndex(u) {
	let E = flushIndex + 1, D = queue.length;
	for (; E < D;) {
		let O = E + D >>> 1, P = queue[O], F = getId(P);
		F < u || F === u && P.flags & 2 ? E = O + 1 : D = O;
	}
	return E;
}
function queueJob(u) {
	if (!(u.flags & 1)) {
		let E = getId(u), D = queue[queue.length - 1];
		!D || !(u.flags & 2) && E >= getId(D) ? queue.push(u) : queue.splice(findInsertionIndex(E), 0, u), u.flags |= 1, queueFlush();
	}
}
function queueFlush() {
	currentFlushPromise ||= resolvedPromise.then(flushJobs);
}
function queuePostFlushCb(u) {
	isArray(u) ? pendingPostFlushCbs.push(...u) : activePostFlushCbs && u.id === -1 ? activePostFlushCbs.splice(postFlushIndex + 1, 0, u) : u.flags & 1 || (pendingPostFlushCbs.push(u), u.flags |= 1), queueFlush();
}
function flushPreFlushCbs(u, E, D = flushIndex + 1) {
	for (; D < queue.length; D++) {
		let E = queue[D];
		if (E && E.flags & 2) {
			if (u && E.id !== u.uid) continue;
			queue.splice(D, 1), D--, E.flags & 4 && (E.flags &= -2), E(), E.flags & 4 || (E.flags &= -2);
		}
	}
}
function flushPostFlushCbs(u) {
	if (pendingPostFlushCbs.length) {
		let u = [...new Set(pendingPostFlushCbs)].sort((u, E) => getId(u) - getId(E));
		if (pendingPostFlushCbs.length = 0, activePostFlushCbs) {
			activePostFlushCbs.push(...u);
			return;
		}
		for (activePostFlushCbs = u, postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
			let u = activePostFlushCbs[postFlushIndex];
			u.flags & 4 && (u.flags &= -2), u.flags & 8 || u(), u.flags &= -2;
		}
		activePostFlushCbs = null, postFlushIndex = 0;
	}
}
var getId = (u) => u.id == null ? u.flags & 2 ? -1 : Infinity : u.id;
function flushJobs(u) {
	try {
		for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
			let u = queue[flushIndex];
			u && !(u.flags & 8) && (u.flags & 4 && (u.flags &= -2), callWithErrorHandling(u, u.i, u.i ? 15 : 14), u.flags & 4 || (u.flags &= -2));
		}
	} finally {
		for (; flushIndex < queue.length; flushIndex++) {
			let u = queue[flushIndex];
			u && (u.flags &= -2);
		}
		flushIndex = -1, queue.length = 0, flushPostFlushCbs(u), currentFlushPromise = null, (queue.length || pendingPostFlushCbs.length) && flushJobs(u);
	}
}
var devtools$1, buffer = [];
function setDevtoolsHook$1(u, E) {
	devtools$1 = u, devtools$1 ? (devtools$1.enabled = !0, buffer.forEach(({ event: u, args: E }) => devtools$1.emit(u, ...E)), buffer = []) : typeof window < "u" && window.HTMLElement && !(window.navigator?.userAgent)?.includes("jsdom") ? ((E.__VUE_DEVTOOLS_HOOK_REPLAY__ = E.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((u) => {
		setDevtoolsHook$1(u, E);
	}), setTimeout(() => {
		devtools$1 || (E.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, buffer = []);
	}, 3e3)) : buffer = [];
}
var currentRenderingInstance = null, currentScopeId = null;
function setCurrentRenderingInstance(u) {
	let E = currentRenderingInstance;
	return currentRenderingInstance = u, currentScopeId = u && u.type.__scopeId || null, E;
}
function pushScopeId(u) {
	currentScopeId = u;
}
function popScopeId() {
	currentScopeId = null;
}
var withScopeId = (u) => withCtx;
function withCtx(u, E = currentRenderingInstance, D) {
	if (!E || u._n) return u;
	let O = (...D) => {
		O._d && setBlockTracking(-1);
		let P = setCurrentRenderingInstance(E), F;
		try {
			F = u(...D);
		} finally {
			setCurrentRenderingInstance(P), O._d && setBlockTracking(1);
		}
		return F;
	};
	return O._n = !0, O._c = !0, O._d = !0, O;
}
function withDirectives(u, E) {
	if (currentRenderingInstance === null) return u;
	let D = getComponentPublicInstance(currentRenderingInstance), P = u.dirs ||= [];
	for (let u = 0; u < E.length; u++) {
		let [F, I, R, U = EMPTY_OBJ] = E[u];
		F && (isFunction(F) && (F = {
			mounted: F,
			updated: F
		}), F.deep && traverse(I), P.push({
			dir: F,
			instance: D,
			value: I,
			oldValue: void 0,
			arg: R,
			modifiers: U
		}));
	}
	return u;
}
function invokeDirectiveHook(u, E, D, O) {
	let P = u.dirs, F = E && E.dirs;
	for (let I = 0; I < P.length; I++) {
		let R = P[I];
		F && (R.oldValue = F[I].value);
		let U = R.dir[O];
		U && (pauseTracking(), callWithAsyncErrorHandling(U, D, 8, [
			u.el,
			R,
			u,
			E
		]), resetTracking());
	}
}
var TeleportEndKey = Symbol("_vte"), isTeleport = (u) => u.__isTeleport, isTeleportDisabled = (u) => u && (u.disabled || u.disabled === ""), isTeleportDeferred = (u) => u && (u.defer || u.defer === ""), isTargetSVG = (u) => typeof SVGElement < "u" && u instanceof SVGElement, isTargetMathML = (u) => typeof MathMLElement == "function" && u instanceof MathMLElement, resolveTarget = (u, E) => {
	let D = u && u.to;
	return isString(D) ? E ? E(D) : null : D;
}, TeleportImpl = {
	name: "Teleport",
	__isTeleport: !0,
	process(u, E, D, O, P, F, I, R, U, J) {
		let { mc: _p, pc: vp, pbc: yp, o: { insert: bp, querySelector: xp, createText: Sp, createComment: Cp } } = J, wp = isTeleportDisabled(E.props), { shapeFlag: Tp, children: Ep, dynamicChildren: Dp } = E;
		if (u == null) {
			let u = E.el = Sp(""), J = E.anchor = Sp("");
			bp(u, D, O), bp(J, D, O);
			let vp = (u, E) => {
				Tp & 16 && _p(Ep, u, E, P, F, I, R, U);
			}, yp = () => {
				let u = E.target = resolveTarget(E.props, xp), D = prepareAnchor(u, E, Sp, bp);
				u && (I !== "svg" && isTargetSVG(u) ? I = "svg" : I !== "mathml" && isTargetMathML(u) && (I = "mathml"), P && P.isCE && (P.ce._teleportTargets || (P.ce._teleportTargets = /* @__PURE__ */ new Set())).add(u), wp || (vp(u, D), updateCssVars(E, !1)));
			};
			wp && (vp(D, J), updateCssVars(E, !0)), isTeleportDeferred(E.props) ? (E.el.__isMounted = !1, queuePostRenderEffect(() => {
				yp(), delete E.el.__isMounted;
			}, F)) : yp();
		} else {
			if (isTeleportDeferred(E.props) && u.el.__isMounted === !1) {
				queuePostRenderEffect(() => {
					TeleportImpl.process(u, E, D, O, P, F, I, R, U, J);
				}, F);
				return;
			}
			E.el = u.el, E.targetStart = u.targetStart;
			let _p = E.anchor = u.anchor, bp = E.target = u.target, Sp = E.targetAnchor = u.targetAnchor, Cp = isTeleportDisabled(u.props), Tp = Cp ? D : bp, Ep = Cp ? _p : Sp;
			if (I === "svg" || isTargetSVG(bp) ? I = "svg" : (I === "mathml" || isTargetMathML(bp)) && (I = "mathml"), Dp ? (yp(u.dynamicChildren, Dp, Tp, P, F, I, R), traverseStaticChildren(u, E, !0)) : U || vp(u, E, Tp, Ep, P, F, I, R, !1), wp) Cp ? E.props && u.props && E.props.to !== u.props.to && (E.props.to = u.props.to) : moveTeleport(E, D, _p, J, 1);
			else if ((E.props && E.props.to) !== (u.props && u.props.to)) {
				let u = E.target = resolveTarget(E.props, xp);
				u && moveTeleport(E, u, null, J, 0);
			} else Cp && moveTeleport(E, bp, Sp, J, 1);
			updateCssVars(E, wp);
		}
	},
	remove(u, E, D, { um: O, o: { remove: P } }, F) {
		let { shapeFlag: I, children: R, anchor: U, targetStart: J, targetAnchor: _p, target: vp, props: yp } = u;
		if (vp && (P(J), P(_p)), F && P(U), I & 16) {
			let u = F || !isTeleportDisabled(yp);
			for (let P = 0; P < R.length; P++) {
				let F = R[P];
				O(F, E, D, u, !!F.dynamicChildren);
			}
		}
	},
	move: moveTeleport,
	hydrate: hydrateTeleport
};
function moveTeleport(u, E, D, { o: { insert: O }, m: P }, F = 2) {
	F === 0 && O(u.targetAnchor, E, D);
	let { el: I, anchor: R, shapeFlag: U, children: J, props: _p } = u, vp = F === 2;
	if (vp && O(I, E, D), (!vp || isTeleportDisabled(_p)) && U & 16) for (let u = 0; u < J.length; u++) P(J[u], E, D, 2);
	vp && O(R, E, D);
}
function hydrateTeleport(u, E, D, O, P, F, { o: { nextSibling: I, parentNode: R, querySelector: U, insert: J, createText: _p } }, vp) {
	function yp(u, E, U, J) {
		E.anchor = vp(I(u), E, R(u), D, O, P, F), E.targetStart = U, E.targetAnchor = J;
	}
	let bp = E.target = resolveTarget(E.props, U), xp = isTeleportDisabled(E.props);
	if (bp) {
		let R = bp._lpa || bp.firstChild;
		if (E.shapeFlag & 16) if (xp) yp(u, E, R, R && I(R));
		else {
			E.anchor = I(u);
			let U = R;
			for (; U;) {
				if (U && U.nodeType === 8) {
					if (U.data === "teleport start anchor") E.targetStart = U;
					else if (U.data === "teleport anchor") {
						E.targetAnchor = U, bp._lpa = E.targetAnchor && I(E.targetAnchor);
						break;
					}
				}
				U = I(U);
			}
			E.targetAnchor || prepareAnchor(bp, E, _p, J), vp(R && I(R), E, bp, D, O, P, F);
		}
		updateCssVars(E, xp);
	} else xp && E.shapeFlag & 16 && yp(u, E, u, I(u));
	return E.anchor && I(E.anchor);
}
var Teleport = TeleportImpl;
function updateCssVars(u, E) {
	let D = u.ctx;
	if (D && D.ut) {
		let O, P;
		for (E ? (O = u.el, P = u.anchor) : (O = u.targetStart, P = u.targetAnchor); O && O !== P;) O.nodeType === 1 && O.setAttribute("data-v-owner", D.uid), O = O.nextSibling;
		D.ut();
	}
}
function prepareAnchor(u, E, D, O) {
	let P = E.targetStart = D(""), F = E.targetAnchor = D("");
	return P[TeleportEndKey] = F, u && (O(P, u), O(F, u)), F;
}
var leaveCbKey = Symbol("_leaveCb"), enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
	let u = {
		isMounted: !1,
		isLeaving: !1,
		isUnmounting: !1,
		leavingVNodes: /* @__PURE__ */ new Map()
	};
	return onMounted(() => {
		u.isMounted = !0;
	}), onBeforeUnmount(() => {
		u.isUnmounting = !0;
	}), u;
}
var TransitionHookValidator = [Function, Array], BaseTransitionPropsValidators = {
	mode: String,
	appear: Boolean,
	persisted: Boolean,
	onBeforeEnter: TransitionHookValidator,
	onEnter: TransitionHookValidator,
	onAfterEnter: TransitionHookValidator,
	onEnterCancelled: TransitionHookValidator,
	onBeforeLeave: TransitionHookValidator,
	onLeave: TransitionHookValidator,
	onAfterLeave: TransitionHookValidator,
	onLeaveCancelled: TransitionHookValidator,
	onBeforeAppear: TransitionHookValidator,
	onAppear: TransitionHookValidator,
	onAfterAppear: TransitionHookValidator,
	onAppearCancelled: TransitionHookValidator
}, recursiveGetSubtree = (u) => {
	let E = u.subTree;
	return E.component ? recursiveGetSubtree(E.component) : E;
}, BaseTransitionImpl = {
	name: "BaseTransition",
	props: BaseTransitionPropsValidators,
	setup(u, { slots: E }) {
		let D = getCurrentInstance(), O = useTransitionState();
		return () => {
			let P = E.default && getTransitionRawChildren(E.default(), !0);
			if (!P || !P.length) return;
			let F = findNonCommentChild(P), I = toRaw(u), { mode: R } = I;
			if (O.isLeaving) return emptyPlaceholder(F);
			let U = getInnerChild$1(F);
			if (!U) return emptyPlaceholder(F);
			let J = resolveTransitionHooks(U, I, O, D, (u) => J = u);
			U.type !== Comment && setTransitionHooks(U, J);
			let _p = D.subTree && getInnerChild$1(D.subTree);
			if (_p && _p.type !== Comment && !isSameVNodeType(_p, U) && recursiveGetSubtree(D).type !== Comment) {
				let u = resolveTransitionHooks(_p, I, O, D);
				if (setTransitionHooks(_p, u), R === "out-in" && U.type !== Comment) return O.isLeaving = !0, u.afterLeave = () => {
					O.isLeaving = !1, D.job.flags & 8 || D.update(), delete u.afterLeave, _p = void 0;
				}, emptyPlaceholder(F);
				R === "in-out" && U.type !== Comment ? u.delayLeave = (u, E, D) => {
					let P = getLeavingNodesForType(O, _p);
					P[String(_p.key)] = _p, u[leaveCbKey] = () => {
						E(), u[leaveCbKey] = void 0, delete J.delayedLeave, _p = void 0;
					}, J.delayedLeave = () => {
						D(), delete J.delayedLeave, _p = void 0;
					};
				} : _p = void 0;
			} else _p &&= void 0;
			return F;
		};
	}
};
function findNonCommentChild(u) {
	let E = u[0];
	if (u.length > 1) {
		for (let D of u) if (D.type !== Comment) {
			E = D;
			break;
		}
	}
	return E;
}
var BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(u, E) {
	let { leavingVNodes: D } = u, O = D.get(E.type);
	return O || (O = /* @__PURE__ */ Object.create(null), D.set(E.type, O)), O;
}
function resolveTransitionHooks(u, E, D, O, P) {
	let { appear: F, mode: I, persisted: R = !1, onBeforeEnter: U, onEnter: J, onAfterEnter: _p, onEnterCancelled: vp, onBeforeLeave: yp, onLeave: xp, onAfterLeave: Sp, onLeaveCancelled: Cp, onBeforeAppear: wp, onAppear: Tp, onAfterAppear: Ep, onAppearCancelled: Dp } = E, Op = String(u.key), kp = getLeavingNodesForType(D, u), Ap = (u, E) => {
		u && callWithAsyncErrorHandling(u, O, 9, E);
	}, jp = (u, E) => {
		let D = E[1];
		Ap(u, E), isArray(u) ? u.every((u) => u.length <= 1) && D() : u.length <= 1 && D();
	}, Mp = {
		mode: I,
		persisted: R,
		beforeEnter(E) {
			let O = U;
			if (!D.isMounted) if (F) O = wp || U;
			else return;
			E[leaveCbKey] && E[leaveCbKey](!0);
			let P = kp[Op];
			P && isSameVNodeType(u, P) && P.el[leaveCbKey] && P.el[leaveCbKey](), Ap(O, [E]);
		},
		enter(u) {
			let E = J, O = _p, P = vp;
			if (!D.isMounted) if (F) E = Tp || J, O = Ep || _p, P = Dp || vp;
			else return;
			let I = !1, R = u[enterCbKey$1] = (E) => {
				I || (I = !0, Ap(E ? P : O, [u]), Mp.delayedLeave && Mp.delayedLeave(), u[enterCbKey$1] = void 0);
			};
			E ? jp(E, [u, R]) : R();
		},
		leave(E, O) {
			let P = String(u.key);
			if (E[enterCbKey$1] && E[enterCbKey$1](!0), D.isUnmounting) return O();
			Ap(yp, [E]);
			let F = !1, I = E[leaveCbKey] = (D) => {
				F || (F = !0, O(), Ap(D ? Cp : Sp, [E]), E[leaveCbKey] = void 0, kp[P] === u && delete kp[P]);
			};
			kp[P] = u, xp ? jp(xp, [E, I]) : I();
		},
		clone(u) {
			let F = resolveTransitionHooks(u, E, D, O, P);
			return P && P(F), F;
		}
	};
	return Mp;
}
function emptyPlaceholder(u) {
	if (isKeepAlive(u)) return u = cloneVNode(u), u.children = null, u;
}
function getInnerChild$1(u) {
	if (!isKeepAlive(u)) return isTeleport(u.type) && u.children ? findNonCommentChild(u.children) : u;
	if (u.component) return u.component.subTree;
	let { shapeFlag: E, children: D } = u;
	if (D) {
		if (E & 16) return D[0];
		if (E & 32 && isFunction(D.default)) return D.default();
	}
}
function setTransitionHooks(u, E) {
	u.shapeFlag & 6 && u.component ? (u.transition = E, setTransitionHooks(u.component.subTree, E)) : u.shapeFlag & 128 ? (u.ssContent.transition = E.clone(u.ssContent), u.ssFallback.transition = E.clone(u.ssFallback)) : u.transition = E;
}
function getTransitionRawChildren(u, E = !1, D) {
	let O = [], P = 0;
	for (let F = 0; F < u.length; F++) {
		let I = u[F], R = D == null ? I.key : String(D) + String(I.key == null ? F : I.key);
		I.type === Fragment ? (I.patchFlag & 128 && P++, O = O.concat(getTransitionRawChildren(I.children, E, R))) : (E || I.type !== Comment) && O.push(R == null ? I : cloneVNode(I, { key: R }));
	}
	if (P > 1) for (let u = 0; u < O.length; u++) O[u].patchFlag = -2;
	return O;
}
/* @__NO_SIDE_EFFECTS__ */
function defineComponent(u, E) {
	return isFunction(u) ? /* @__PURE__ */ (() => extend({ name: u.name }, E, { setup: u }))() : u;
}
function useId$1() {
	let u = getCurrentInstance();
	return u ? (u.appContext.config.idPrefix || "v") + "-" + u.ids[0] + u.ids[1]++ : "";
}
function markAsyncBoundary(u) {
	u.ids = [
		u.ids[0] + u.ids[2]++ + "-",
		0,
		0
	];
}
function useTemplateRef(u) {
	let E = getCurrentInstance(), D = shallowRef(null);
	if (E) {
		let P = E.refs === EMPTY_OBJ ? E.refs = {} : E.refs;
		Object.defineProperty(P, u, {
			enumerable: !0,
			get: () => D.value,
			set: (u) => D.value = u
		});
	}
	return D;
}
var pendingSetRefMap = /* @__PURE__ */ new WeakMap();
function setRef(u, E, D, P, F = !1) {
	if (isArray(u)) {
		u.forEach((u, O) => setRef(u, E && (isArray(E) ? E[O] : E), D, P, F));
		return;
	}
	if (isAsyncWrapper(P) && !F) {
		P.shapeFlag & 512 && P.type.__asyncResolved && P.component.subTree.component && setRef(u, E, D, P.component.subTree);
		return;
	}
	let R = P.shapeFlag & 4 ? getComponentPublicInstance(P.component) : P.el, U = F ? null : R, { i: J, r: vp } = u, xp = E && E.r, Sp = J.refs === EMPTY_OBJ ? J.refs = {} : J.refs, Cp = J.setupState, wp = toRaw(Cp), Dp = Cp === EMPTY_OBJ ? NO : (u) => hasOwn$2(wp, u), Op = (u) => !0;
	if (xp != null && xp !== vp) {
		if (invalidatePendingSetRef(E), isString(xp)) Sp[xp] = null, Dp(xp) && (Cp[xp] = null);
		else if (isRef(xp)) {
			Op(xp) && (xp.value = null);
			let u = E;
			u.k && (Sp[u.k] = null);
		}
	}
	if (isFunction(vp)) callWithErrorHandling(vp, J, 12, [U, Sp]);
	else {
		let E = isString(vp), O = isRef(vp);
		if (E || O) {
			let P = () => {
				if (u.f) {
					let D = E ? Dp(vp) ? Cp[vp] : Sp[vp] : Op(vp) || !u.k ? vp.value : Sp[u.k];
					if (F) isArray(D) && remove(D, R);
					else if (isArray(D)) D.includes(R) || D.push(R);
					else if (E) Sp[vp] = [R], Dp(vp) && (Cp[vp] = Sp[vp]);
					else {
						let E = [R];
						Op(vp) && (vp.value = E), u.k && (Sp[u.k] = E);
					}
				} else E ? (Sp[vp] = U, Dp(vp) && (Cp[vp] = U)) : O && (Op(vp) && (vp.value = U), u.k && (Sp[u.k] = U));
			};
			if (U) {
				let E = () => {
					P(), pendingSetRefMap.delete(u);
				};
				E.id = -1, pendingSetRefMap.set(u, E), queuePostRenderEffect(E, D);
			} else invalidatePendingSetRef(u), P();
		}
	}
}
function invalidatePendingSetRef(u) {
	let E = pendingSetRefMap.get(u);
	E && (E.flags |= 8, pendingSetRefMap.delete(u));
}
var hasLoggedMismatchError = !1, logMismatchError = () => {
	hasLoggedMismatchError ||= (console.error("Hydration completed but contains mismatches."), !0);
}, isSVGContainer = (u) => u.namespaceURI.includes("svg") && u.tagName !== "foreignObject", isMathMLContainer = (u) => u.namespaceURI.includes("MathML"), getContainerType = (u) => {
	if (u.nodeType === 1) {
		if (isSVGContainer(u)) return "svg";
		if (isMathMLContainer(u)) return "mathml";
	}
}, isComment = (u) => u.nodeType === 8;
function createHydrationFunctions(u) {
	let { mt: E, p: D, o: { patchProp: O, createText: P, nextSibling: F, parentNode: I, remove: U, insert: J, createComment: _p } } = u, vp = (u, E) => {
		if (!E.hasChildNodes()) {
			D(null, u, E), flushPostFlushCbs(), E._vnode = u;
			return;
		}
		yp(E.firstChild, u, null, null, null), flushPostFlushCbs(), E._vnode = u;
	}, yp = (D, O, R, U, _p, vp = !1) => {
		vp ||= !!O.dynamicChildren;
		let Dp = isComment(D) && D.data === "[", Op = () => Cp(D, O, R, U, _p, Dp), { type: kp, ref: Ap, shapeFlag: jp, patchFlag: Mp } = O, Np = D.nodeType;
		O.el = D, Mp === -2 && (vp = !1, O.dynamicChildren = null);
		let Pp = null;
		switch (kp) {
			case Text:
				Np === 3 ? (D.data !== O.children && (logMismatchError(), D.data = O.children), Pp = F(D)) : O.children === "" ? (J(O.el = P(""), I(D), D), Pp = D) : Pp = Op();
				break;
			case Comment:
				Ep(D) ? (Pp = F(D), Tp(O.el = D.content.firstChild, D, R)) : Pp = Np !== 8 || Dp ? Op() : F(D);
				break;
			case Static:
				if (Dp && (D = F(D), Np = D.nodeType), Np === 1 || Np === 3) {
					Pp = D;
					let u = !O.children.length;
					for (let E = 0; E < O.staticCount; E++) u && (O.children += Pp.nodeType === 1 ? Pp.outerHTML : Pp.data), E === O.staticCount - 1 && (O.anchor = Pp), Pp = F(Pp);
					return Dp ? F(Pp) : Pp;
				} else Op();
				break;
			case Fragment:
				Pp = Dp ? Sp(D, O, R, U, _p, vp) : Op();
				break;
			default: if (jp & 1) Pp = (Np !== 1 || O.type.toLowerCase() !== D.tagName.toLowerCase()) && !Ep(D) ? Op() : bp(D, O, R, U, _p, vp);
			else if (jp & 6) {
				O.slotScopeIds = _p;
				let u = I(D);
				if (Pp = Dp ? wp(D) : isComment(D) && D.data === "teleport start" ? wp(D, D.data, "teleport end") : F(D), E(O, u, null, R, U, getContainerType(u), vp), isAsyncWrapper(O) && !O.type.__asyncResolved) {
					let E;
					Dp ? (E = createVNode(Fragment), E.anchor = Pp ? Pp.previousSibling : u.lastChild) : E = D.nodeType === 3 ? createTextVNode("") : createVNode("div"), E.el = D, O.component.subTree = E;
				}
			} else jp & 64 ? Pp = Np === 8 ? O.type.hydrate(D, O, R, U, _p, vp, u, xp) : Op() : jp & 128 && (Pp = O.type.hydrate(D, O, R, U, getContainerType(I(D)), _p, vp, u, yp));
		}
		return Ap != null && setRef(Ap, null, U, O), Pp;
	}, bp = (u, E, D, P, F, I) => {
		I ||= !!E.dynamicChildren;
		let { type: J, props: _p, patchFlag: vp, shapeFlag: yp, dirs: bp, transition: Sp } = E, Cp = J === "input" || J === "option";
		if (Cp || vp !== -1) {
			bp && invokeDirectiveHook(E, null, D, "created");
			let J = !1;
			if (Ep(u)) {
				J = needTransition(null, Sp) && D && D.vnode.props && D.vnode.props.appear;
				let O = u.content.firstChild;
				if (J) {
					let u = O.getAttribute("class");
					u && (O.$cls = u), Sp.beforeEnter(O);
				}
				Tp(O, u, D), E.el = u = O;
			}
			if (yp & 16 && !(_p && (_p.innerHTML || _p.textContent))) {
				let O = xp(u.firstChild, E, u, D, P, F, I);
				for (; O;) {
					isMismatchAllowed(u, 1) || logMismatchError();
					let E = O;
					O = O.nextSibling, U(E);
				}
			} else if (yp & 8) {
				let D = E.children;
				D[0] === "\n" && (u.tagName === "PRE" || u.tagName === "TEXTAREA") && (D = D.slice(1)), u.textContent !== D && (isMismatchAllowed(u, 0) || logMismatchError(), u.textContent = E.children);
			}
			if (_p) {
				if (Cp || !I || vp & 48) {
					let E = u.tagName.includes("-");
					for (let P in _p) (Cp && (P.endsWith("value") || P === "indeterminate") || isOn(P) && !isReservedProp(P) || P[0] === "." || E) && O(u, P, null, _p[P], void 0, D);
				} else if (_p.onClick) O(u, "onClick", null, _p.onClick, void 0, D);
				else if (vp & 4 && isReactive(_p.style)) for (let u in _p.style) _p.style[u];
			}
			let wp;
			(wp = _p && _p.onVnodeBeforeMount) && invokeVNodeHook(wp, D, E), bp && invokeDirectiveHook(E, null, D, "beforeMount"), ((wp = _p && _p.onVnodeMounted) || bp || J) && queueEffectWithSuspense(() => {
				wp && invokeVNodeHook(wp, D, E), J && Sp.enter(u), bp && invokeDirectiveHook(E, null, D, "mounted");
			}, P);
		}
		return u.nextSibling;
	}, xp = (u, E, O, I, R, U, _p) => {
		_p ||= !!E.dynamicChildren;
		let vp = E.children, bp = vp.length;
		for (let E = 0; E < bp; E++) {
			let xp = _p ? vp[E] : vp[E] = normalizeVNode(vp[E]), Sp = xp.type === Text;
			u ? (Sp && !_p && E + 1 < bp && normalizeVNode(vp[E + 1]).type === Text && (J(P(u.data.slice(xp.children.length)), O, F(u)), u.data = xp.children), u = yp(u, xp, I, R, U, _p)) : Sp && !xp.children ? J(xp.el = P(""), O) : (isMismatchAllowed(O, 1) || logMismatchError(), D(null, xp, O, null, I, R, getContainerType(O), U));
		}
		return u;
	}, Sp = (u, E, D, O, P, R) => {
		let { slotScopeIds: U } = E;
		U && (P = P ? P.concat(U) : U);
		let vp = I(u), yp = xp(F(u), E, vp, D, O, P, R);
		return yp && isComment(yp) && yp.data === "]" ? F(E.anchor = yp) : (logMismatchError(), J(E.anchor = _p("]"), vp, yp), yp);
	}, Cp = (u, E, O, P, R, J) => {
		if (isMismatchAllowed(u.parentElement, 1) || logMismatchError(), E.el = null, J) {
			let E = wp(u);
			for (;;) {
				let D = F(u);
				if (D && D !== E) U(D);
				else break;
			}
		}
		let _p = F(u), vp = I(u);
		return U(u), D(null, E, vp, _p, O, P, getContainerType(vp), R), O && (O.vnode.el = E.el, updateHOCHostEl(O, E.el)), _p;
	}, wp = (u, E = "[", D = "]") => {
		let O = 0;
		for (; u;) if (u = F(u), u && isComment(u) && (u.data === E && O++, u.data === D)) {
			if (O === 0) return F(u);
			O--;
		}
		return u;
	}, Tp = (u, E, D) => {
		let O = E.parentNode;
		O && O.replaceChild(u, E);
		let P = D;
		for (; P;) P.vnode.el === E && (P.vnode.el = P.subTree.el = u), P = P.parent;
	}, Ep = (u) => u.nodeType === 1 && u.tagName === "TEMPLATE";
	return [vp, yp];
}
var allowMismatchAttr = "data-allow-mismatch", MismatchTypeString = {
	0: "text",
	1: "children",
	2: "class",
	3: "style",
	4: "attribute"
};
function isMismatchAllowed(u, E) {
	if (E === 0 || E === 1) for (; u && !u.hasAttribute(allowMismatchAttr);) u = u.parentElement;
	let D = u && u.getAttribute(allowMismatchAttr);
	if (D == null) return !1;
	if (D === "") return !0;
	{
		let u = D.split(",");
		return E === 0 && u.includes("children") ? !0 : u.includes(MismatchTypeString[E]);
	}
}
var requestIdleCallback = getGlobalThis().requestIdleCallback || ((u) => setTimeout(u, 1)), cancelIdleCallback = getGlobalThis().cancelIdleCallback || ((u) => clearTimeout(u)), hydrateOnIdle = (u = 1e4) => (E) => {
	let D = requestIdleCallback(E, { timeout: u });
	return () => cancelIdleCallback(D);
};
function elementIsVisibleInViewport(u) {
	let { top: E, left: D, bottom: O, right: P } = u.getBoundingClientRect(), { innerHeight: F, innerWidth: I } = window;
	return (E > 0 && E < F || O > 0 && O < F) && (D > 0 && D < I || P > 0 && P < I);
}
var hydrateOnVisible = (u) => (E, D) => {
	let O = new IntersectionObserver((u) => {
		for (let D of u) if (D.isIntersecting) {
			O.disconnect(), E();
			break;
		}
	}, u);
	return D((u) => {
		if (u instanceof Element) {
			if (elementIsVisibleInViewport(u)) return E(), O.disconnect(), !1;
			O.observe(u);
		}
	}), () => O.disconnect();
}, hydrateOnMediaQuery = (u) => (E) => {
	if (u) {
		let D = matchMedia(u);
		if (D.matches) E();
		else return D.addEventListener("change", E, { once: !0 }), () => D.removeEventListener("change", E);
	}
}, hydrateOnInteraction = (u = []) => (E, D) => {
	isString(u) && (u = [u]);
	let O = !1, P = (u) => {
		O || (O = !0, F(), E(), u.target.dispatchEvent(new u.constructor(u.type, u)));
	}, F = () => {
		D((E) => {
			for (let D of u) E.removeEventListener(D, P);
		});
	};
	return D((E) => {
		for (let D of u) E.addEventListener(D, P, { once: !0 });
	}), F;
};
function forEachElement(u, E) {
	if (isComment(u) && u.data === "[") {
		let D = 1, O = u.nextSibling;
		for (; O;) {
			if (O.nodeType === 1) {
				if (E(O) === !1) break;
			} else if (isComment(O)) if (O.data === "]") {
				if (--D === 0) break;
			} else O.data === "[" && D++;
			O = O.nextSibling;
		}
	} else E(u);
}
var isAsyncWrapper = (u) => !!u.type.__asyncLoader;
/* @__NO_SIDE_EFFECTS__ */
function defineAsyncComponent(u) {
	isFunction(u) && (u = { loader: u });
	let { loader: E, loadingComponent: D, errorComponent: O, delay: P = 200, hydrate: F, timeout: I, suspensible: R = !0, onError: U } = u, J = null, _p, vp = 0, yp = () => (vp++, J = null, bp()), bp = () => {
		let u;
		return J || (u = J = E().catch((u) => {
			if (u = u instanceof Error ? u : Error(String(u)), U) return new Promise((E, D) => {
				U(u, () => E(yp()), () => D(u), vp + 1);
			});
			throw u;
		}).then((E) => u !== J && J ? J : (E && (E.__esModule || E[Symbol.toStringTag] === "Module") && (E = E.default), _p = E, E)));
	};
	return /* @__PURE__ */ defineComponent({
		name: "AsyncComponentWrapper",
		__asyncLoader: bp,
		__asyncHydrate(u, E, D) {
			let O = !1;
			(E.bu ||= []).push(() => O = !0);
			let P = () => {
				O || D();
			}, I = F ? () => {
				let D = F(P, (E) => forEachElement(u, E));
				D && (E.bum ||= []).push(D);
			} : P;
			_p ? I() : bp().then(() => !E.isUnmounted && I());
		},
		get __asyncResolved() {
			return _p;
		},
		setup() {
			let u = currentInstance;
			if (markAsyncBoundary(u), _p) return () => createInnerComp(_p, u);
			let E = (E) => {
				J = null, handleError(E, u, 13, !O);
			};
			if (R && u.suspense || isInSSRComponentSetup) return bp().then((E) => () => createInnerComp(E, u)).catch((u) => (E(u), () => O ? createVNode(O, { error: u }) : null));
			let F = ref(!1), U = ref(), vp = ref(!!P);
			return P && setTimeout(() => {
				vp.value = !1;
			}, P), I != null && setTimeout(() => {
				if (!F.value && !U.value) {
					let u = /* @__PURE__ */ Error(`Async component timed out after ${I}ms.`);
					E(u), U.value = u;
				}
			}, I), bp().then(() => {
				F.value = !0, u.parent && isKeepAlive(u.parent.vnode) && u.parent.update();
			}).catch((u) => {
				E(u), U.value = u;
			}), () => {
				if (F.value && _p) return createInnerComp(_p, u);
				if (U.value && O) return createVNode(O, { error: U.value });
				if (D && !vp.value) return createVNode(D);
			};
		}
	});
}
function createInnerComp(u, E) {
	let { ref: D, props: O, children: P, ce: F } = E.vnode, I = createVNode(u, O, P);
	return I.ref = D, I.ce = F, delete E.vnode.ce, I;
}
var isKeepAlive = (u) => u.type.__isKeepAlive, KeepAlive = {
	name: "KeepAlive",
	__isKeepAlive: !0,
	props: {
		include: [
			String,
			RegExp,
			Array
		],
		exclude: [
			String,
			RegExp,
			Array
		],
		max: [String, Number]
	},
	setup(u, { slots: E }) {
		let D = getCurrentInstance(), O = D.ctx;
		if (!O.renderer) return () => {
			let u = E.default && E.default();
			return u && u.length === 1 ? u[0] : u;
		};
		let P = /* @__PURE__ */ new Map(), F = /* @__PURE__ */ new Set(), I = null, R = D.suspense, { renderer: { p: U, m: J, um: _p, o: { createElement: vp } } } = O, yp = vp("div");
		O.activate = (u, E, D, O, P) => {
			let F = u.component;
			J(u, E, D, 0, R), U(F.vnode, u, E, D, F, R, O, u.slotScopeIds, P), queuePostRenderEffect(() => {
				F.isDeactivated = !1, F.a && invokeArrayFns(F.a);
				let E = u.props && u.props.onVnodeMounted;
				E && invokeVNodeHook(E, F.parent, u);
			}, R);
		}, O.deactivate = (u) => {
			let E = u.component;
			invalidateMount(E.m), invalidateMount(E.a), J(u, yp, null, 1, R), queuePostRenderEffect(() => {
				E.da && invokeArrayFns(E.da);
				let D = u.props && u.props.onVnodeUnmounted;
				D && invokeVNodeHook(D, E.parent, u), E.isDeactivated = !0;
			}, R);
		};
		function bp(u) {
			resetShapeFlag(u), _p(u, D, R, !0);
		}
		function xp(u) {
			P.forEach((E, D) => {
				let O = getComponentName(E.type);
				O && !u(O) && Sp(D);
			});
		}
		function Sp(u) {
			let E = P.get(u);
			E && (!I || !isSameVNodeType(E, I)) ? bp(E) : I && resetShapeFlag(I), P.delete(u), F.delete(u);
		}
		watch(() => [u.include, u.exclude], ([u, E]) => {
			u && xp((E) => matches(u, E)), E && xp((u) => !matches(E, u));
		}, {
			flush: "post",
			deep: !0
		});
		let Cp = null, wp = () => {
			Cp != null && (isSuspense(D.subTree.type) ? queuePostRenderEffect(() => {
				P.set(Cp, getInnerChild(D.subTree));
			}, D.subTree.suspense) : P.set(Cp, getInnerChild(D.subTree)));
		};
		return onMounted(wp), onUpdated(wp), onBeforeUnmount(() => {
			P.forEach((u) => {
				let { subTree: E, suspense: O } = D, P = getInnerChild(E);
				if (u.type === P.type && u.key === P.key) {
					resetShapeFlag(P);
					let u = P.component.da;
					u && queuePostRenderEffect(u, O);
					return;
				}
				bp(u);
			});
		}), () => {
			if (Cp = null, !E.default) return I = null;
			let D = E.default(), O = D[0];
			if (D.length > 1) return I = null, D;
			if (!isVNode(O) || !(O.shapeFlag & 4) && !(O.shapeFlag & 128)) return I = null, O;
			let R = getInnerChild(O);
			if (R.type === Comment) return I = null, R;
			let U = R.type, J = getComponentName(isAsyncWrapper(R) ? R.type.__asyncResolved || {} : U), { include: _p, exclude: vp, max: yp } = u;
			if (_p && (!J || !matches(_p, J)) || vp && J && matches(vp, J)) return R.shapeFlag &= -257, I = R, O;
			let bp = R.key == null ? U : R.key, xp = P.get(bp);
			return R.el && (R = cloneVNode(R), O.shapeFlag & 128 && (O.ssContent = R)), Cp = bp, xp ? (R.el = xp.el, R.component = xp.component, R.transition && setTransitionHooks(R, R.transition), R.shapeFlag |= 512, F.delete(bp), F.add(bp)) : (F.add(bp), yp && F.size > parseInt(yp, 10) && Sp(F.values().next().value)), R.shapeFlag |= 256, I = R, isSuspense(O.type) ? O : R;
		};
	}
};
function matches(u, E) {
	return isArray(u) ? u.some((u) => matches(u, E)) : isString(u) ? u.split(",").includes(E) : isRegExp(u) ? (u.lastIndex = 0, u.test(E)) : !1;
}
function onActivated(u, E) {
	registerKeepAliveHook(u, "a", E);
}
function onDeactivated(u, E) {
	registerKeepAliveHook(u, "da", E);
}
function registerKeepAliveHook(u, E, D = currentInstance) {
	let O = u.__wdc ||= () => {
		let E = D;
		for (; E;) {
			if (E.isDeactivated) return;
			E = E.parent;
		}
		return u();
	};
	if (injectHook(E, O, D), D) {
		let u = D.parent;
		for (; u && u.parent;) isKeepAlive(u.parent.vnode) && injectToKeepAliveRoot(O, E, D, u), u = u.parent;
	}
}
function injectToKeepAliveRoot(u, E, D, O) {
	let P = injectHook(E, u, O, !0);
	onUnmounted(() => {
		remove(O[E], P);
	}, D);
}
function resetShapeFlag(u) {
	u.shapeFlag &= -257, u.shapeFlag &= -513;
}
function getInnerChild(u) {
	return u.shapeFlag & 128 ? u.ssContent : u;
}
function injectHook(u, E, D = currentInstance, O = !1) {
	if (D) {
		let P = D[u] || (D[u] = []), F = E.__weh ||= (...O) => {
			pauseTracking();
			let P = setCurrentInstance(D), F = callWithAsyncErrorHandling(E, D, u, O);
			return P(), resetTracking(), F;
		};
		return O ? P.unshift(F) : P.push(F), F;
	}
}
var createHook = (u) => (E, D = currentInstance) => {
	(!isInSSRComponentSetup || u === "sp") && injectHook(u, (...u) => E(...u), D);
}, onBeforeMount = createHook("bm"), onMounted = createHook("m"), onBeforeUpdate = createHook("bu"), onUpdated = createHook("u"), onBeforeUnmount = createHook("bum"), onUnmounted = createHook("um"), onServerPrefetch = createHook("sp"), onRenderTriggered = createHook("rtg"), onRenderTracked = createHook("rtc");
function onErrorCaptured(u, E = currentInstance) {
	injectHook("ec", u, E);
}
var COMPONENTS = "components", DIRECTIVES = "directives";
function resolveComponent(u, E) {
	return resolveAsset(COMPONENTS, u, !0, E) || u;
}
var NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(u) {
	return isString(u) ? resolveAsset(COMPONENTS, u, !1) || u : u || NULL_DYNAMIC_COMPONENT;
}
function resolveDirective(u) {
	return resolveAsset(DIRECTIVES, u);
}
function resolveAsset(u, E, D = !0, O = !1) {
	let P = currentRenderingInstance || currentInstance;
	if (P) {
		let D = P.type;
		if (u === COMPONENTS) {
			let u = getComponentName(D, !1);
			if (u && (u === E || u === camelize$2(E) || u === capitalize(camelize$2(E)))) return D;
		}
		let F = resolve(P[u] || D[u], E) || resolve(P.appContext[u], E);
		return !F && O ? D : F;
	}
}
function resolve(u, E) {
	return u && (u[E] || u[camelize$2(E)] || u[capitalize(camelize$2(E))]);
}
function renderList(u, E, D, O) {
	let P, F = D && D[O], I = isArray(u);
	if (I || isString(u)) {
		let D = I && isReactive(u), O = !1, R = !1;
		D && (O = !isShallow(u), R = isReadonly(u), u = shallowReadArray(u)), P = Array(u.length);
		for (let D = 0, I = u.length; D < I; D++) P[D] = E(O ? R ? toReadonly(toReactive(u[D])) : toReactive(u[D]) : u[D], D, void 0, F && F[D]);
	} else if (typeof u == "number") {
		P = Array(u);
		for (let D = 0; D < u; D++) P[D] = E(D + 1, D, void 0, F && F[D]);
	} else if (isObject$2(u)) if (u[Symbol.iterator]) P = Array.from(u, (u, D) => E(u, D, void 0, F && F[D]));
	else {
		let D = Object.keys(u);
		P = Array(D.length);
		for (let O = 0, I = D.length; O < I; O++) {
			let I = D[O];
			P[O] = E(u[I], I, O, F && F[O]);
		}
	}
	else P = [];
	return D && (D[O] = P), P;
}
function createSlots(u, E) {
	for (let D = 0; D < E.length; D++) {
		let O = E[D];
		if (isArray(O)) for (let E = 0; E < O.length; E++) u[O[E].name] = O[E].fn;
		else O && (u[O.name] = O.key ? (...u) => {
			let E = O.fn(...u);
			return E && (E.key = O.key), E;
		} : O.fn);
	}
	return u;
}
function renderSlot(u, E, D = {}, O, P) {
	if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
		let u = Object.keys(D).length > 0;
		return E !== "default" && (D.name = E), openBlock(), createBlock(Fragment, null, [createVNode("slot", D, O && O())], u ? -2 : 64);
	}
	let F = u[E];
	F && F._c && (F._d = !1), openBlock();
	let I = F && ensureValidVNode(F(D)), R = D.key || I && I.key, U = createBlock(Fragment, { key: (R && !isSymbol(R) ? R : `_${E}`) + (!I && O ? "_fb" : "") }, I || (O ? O() : []), I && u._ === 1 ? 64 : -2);
	return !P && U.scopeId && (U.slotScopeIds = [U.scopeId + "-s"]), F && F._c && (F._d = !0), U;
}
function ensureValidVNode(u) {
	return u.some((u) => isVNode(u) ? !(u.type === Comment || u.type === Fragment && !ensureValidVNode(u.children)) : !0) ? u : null;
}
function toHandlers(u, E) {
	let D = {};
	for (let O in u) D[E && /[A-Z]/.test(O) ? `on:${O}` : toHandlerKey(O)] = u[O];
	return D;
}
var getPublicInstance = (u) => u ? isStatefulComponent(u) ? getComponentPublicInstance(u) : getPublicInstance(u.parent) : null, publicPropertiesMap = /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
	$: (u) => u,
	$el: (u) => u.vnode.el,
	$data: (u) => u.data,
	$props: (u) => u.props,
	$attrs: (u) => u.attrs,
	$slots: (u) => u.slots,
	$refs: (u) => u.refs,
	$parent: (u) => getPublicInstance(u.parent),
	$root: (u) => getPublicInstance(u.root),
	$host: (u) => u.ce,
	$emit: (u) => u.emit,
	$options: (u) => resolveMergedOptions(u),
	$forceUpdate: (u) => u.f ||= () => {
		queueJob(u.update);
	},
	$nextTick: (u) => u.n ||= nextTick.bind(u.proxy),
	$watch: (u) => instanceWatch.bind(u)
}), hasSetupBinding = (u, E) => u !== EMPTY_OBJ && !u.__isScriptSetup && hasOwn$2(u, E), PublicInstanceProxyHandlers = {
	get({ _: u }, E) {
		if (E === "__v_skip") return !0;
		let { ctx: D, setupState: P, data: F, props: I, accessCache: R, type: U, appContext: J } = u, _p;
		if (E[0] !== "$") {
			let U = R[E];
			if (U !== void 0) switch (U) {
				case 1: return P[E];
				case 2: return F[E];
				case 4: return D[E];
				case 3: return I[E];
			}
			else if (hasSetupBinding(P, E)) return R[E] = 1, P[E];
			else if (F !== EMPTY_OBJ && hasOwn$2(F, E)) return R[E] = 2, F[E];
			else if ((_p = u.propsOptions[0]) && hasOwn$2(_p, E)) return R[E] = 3, I[E];
			else if (D !== EMPTY_OBJ && hasOwn$2(D, E)) return R[E] = 4, D[E];
			else shouldCacheAccess && (R[E] = 0);
		}
		let vp = publicPropertiesMap[E], bp, xp;
		if (vp) return E === "$attrs" && track(u.attrs, "get", ""), vp(u);
		if ((bp = U.__cssModules) && (bp = bp[E])) return bp;
		if (D !== EMPTY_OBJ && hasOwn$2(D, E)) return R[E] = 4, D[E];
		if (xp = J.config.globalProperties, hasOwn$2(xp, E)) return xp[E];
	},
	set({ _: u }, E, D) {
		let { data: P, setupState: F, ctx: I } = u;
		return hasSetupBinding(F, E) ? (F[E] = D, !0) : P !== EMPTY_OBJ && hasOwn$2(P, E) ? (P[E] = D, !0) : hasOwn$2(u.props, E) || E[0] === "$" && E.slice(1) in u ? !1 : (I[E] = D, !0);
	},
	has({ _: { data: u, setupState: E, accessCache: D, ctx: P, appContext: F, propsOptions: I, type: R } }, U) {
		let J, _p;
		return !!(D[U] || u !== EMPTY_OBJ && U[0] !== "$" && hasOwn$2(u, U) || hasSetupBinding(E, U) || (J = I[0]) && hasOwn$2(J, U) || hasOwn$2(P, U) || hasOwn$2(publicPropertiesMap, U) || hasOwn$2(F.config.globalProperties, U) || (_p = R.__cssModules) && _p[U]);
	},
	defineProperty(u, E, D) {
		return D.get == null ? hasOwn$2(D, "value") && this.set(u, E, D.value, null) : u._.accessCache[E] = 0, Reflect.defineProperty(u, E, D);
	}
}, RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend({}, PublicInstanceProxyHandlers, {
	get(u, E) {
		if (E !== Symbol.unscopables) return PublicInstanceProxyHandlers.get(u, E, u);
	},
	has(u, E) {
		return E[0] !== "_" && !isGloballyAllowed(E);
	}
});
function defineProps() {
	return null;
}
function defineEmits() {
	return null;
}
function defineExpose(u) {}
function defineOptions(u) {}
function defineSlots() {
	return null;
}
function defineModel() {}
function withDefaults(u, E) {
	return null;
}
function useSlots() {
	return getContext("useSlots").slots;
}
function useAttrs() {
	return getContext("useAttrs").attrs;
}
function getContext(u) {
	let E = getCurrentInstance();
	return E.setupContext ||= createSetupContext(E);
}
function normalizePropsOrEmits(u) {
	return isArray(u) ? u.reduce((u, E) => (u[E] = null, u), {}) : u;
}
function mergeDefaults(u, E) {
	let D = normalizePropsOrEmits(u);
	for (let u in E) {
		if (u.startsWith("__skip")) continue;
		let O = D[u];
		O ? isArray(O) || isFunction(O) ? O = D[u] = {
			type: O,
			default: E[u]
		} : O.default = E[u] : O === null && (O = D[u] = { default: E[u] }), O && E[`__skip_${u}`] && (O.skipFactory = !0);
	}
	return D;
}
function mergeModels(u, E) {
	return !u || !E ? u || E : isArray(u) && isArray(E) ? u.concat(E) : extend({}, normalizePropsOrEmits(u), normalizePropsOrEmits(E));
}
function createPropsRestProxy(u, E) {
	let D = {};
	for (let O in u) E.includes(O) || Object.defineProperty(D, O, {
		enumerable: !0,
		get: () => u[O]
	});
	return D;
}
function withAsyncContext(u) {
	let E = getCurrentInstance(), D = u();
	return unsetCurrentInstance(), isPromise(D) && (D = D.catch((u) => {
		throw setCurrentInstance(E), u;
	})), [D, () => setCurrentInstance(E)];
}
var shouldCacheAccess = !0;
function applyOptions(u) {
	let E = resolveMergedOptions(u), D = u.proxy, O = u.ctx;
	shouldCacheAccess = !1, E.beforeCreate && callHook$1(E.beforeCreate, u, "bc");
	let { data: P, computed: I, methods: R, watch: U, provide: J, inject: _p, created: vp, beforeMount: yp, mounted: xp, beforeUpdate: Sp, updated: Cp, activated: wp, deactivated: Ep, beforeDestroy: Dp, beforeUnmount: kp, destroyed: Ap, unmounted: jp, render: Mp, renderTracked: Np, renderTriggered: Pp, errorCaptured: Fp, serverPrefetch: Ip, expose: Lp, inheritAttrs: Rp, components: zp, directives: Bp, filters: Vp } = E;
	if (_p && resolveInjections(_p, O, null), R) for (let u in R) {
		let E = R[u];
		isFunction(E) && (O[u] = E.bind(D));
	}
	if (P) {
		let E = P.call(D, D);
		isObject$2(E) && (u.data = reactive(E));
	}
	if (shouldCacheAccess = !0, I) for (let u in I) {
		let E = I[u], P = computed({
			get: isFunction(E) ? E.bind(D, D) : isFunction(E.get) ? E.get.bind(D, D) : NOOP,
			set: !isFunction(E) && isFunction(E.set) ? E.set.bind(D) : NOOP
		});
		Object.defineProperty(O, u, {
			enumerable: !0,
			configurable: !0,
			get: () => P.value,
			set: (u) => P.value = u
		});
	}
	if (U) for (let u in U) createWatcher(U[u], O, D, u);
	if (J) {
		let u = isFunction(J) ? J.call(D) : J;
		Reflect.ownKeys(u).forEach((E) => {
			provide(E, u[E]);
		});
	}
	vp && callHook$1(vp, u, "c");
	function Hp(u, E) {
		isArray(E) ? E.forEach((E) => u(E.bind(D))) : E && u(E.bind(D));
	}
	if (Hp(onBeforeMount, yp), Hp(onMounted, xp), Hp(onBeforeUpdate, Sp), Hp(onUpdated, Cp), Hp(onActivated, wp), Hp(onDeactivated, Ep), Hp(onErrorCaptured, Fp), Hp(onRenderTracked, Np), Hp(onRenderTriggered, Pp), Hp(onBeforeUnmount, kp), Hp(onUnmounted, jp), Hp(onServerPrefetch, Ip), isArray(Lp)) if (Lp.length) {
		let E = u.exposed ||= {};
		Lp.forEach((u) => {
			Object.defineProperty(E, u, {
				get: () => D[u],
				set: (E) => D[u] = E,
				enumerable: !0
			});
		});
	} else u.exposed ||= {};
	Mp && u.render === NOOP && (u.render = Mp), Rp != null && (u.inheritAttrs = Rp), zp && (u.components = zp), Bp && (u.directives = Bp), Ip && markAsyncBoundary(u);
}
function resolveInjections(u, E, D = NOOP) {
	for (let D in isArray(u) && (u = normalizeInject(u)), u) {
		let O = u[D], P;
		P = isObject$2(O) ? "default" in O ? inject(O.from || D, O.default, !0) : inject(O.from || D) : inject(O), isRef(P) ? Object.defineProperty(E, D, {
			enumerable: !0,
			configurable: !0,
			get: () => P.value,
			set: (u) => P.value = u
		}) : E[D] = P;
	}
}
function callHook$1(u, E, D) {
	callWithAsyncErrorHandling(isArray(u) ? u.map((u) => u.bind(E.proxy)) : u.bind(E.proxy), E, D);
}
function createWatcher(u, E, D, O) {
	let P = O.includes(".") ? createPathGetter(D, O) : () => D[O];
	if (isString(u)) {
		let D = E[u];
		isFunction(D) && watch(P, D);
	} else if (isFunction(u)) watch(P, u.bind(D));
	else if (isObject$2(u)) if (isArray(u)) u.forEach((u) => createWatcher(u, E, D, O));
	else {
		let O = isFunction(u.handler) ? u.handler.bind(D) : E[u.handler];
		isFunction(O) && watch(P, O, u);
	}
}
function resolveMergedOptions(u) {
	let E = u.type, { mixins: D, extends: O } = E, { mixins: P, optionsCache: F, config: { optionMergeStrategies: I } } = u.appContext, R = F.get(E), U;
	return R ? U = R : !P.length && !D && !O ? U = E : (U = {}, P.length && P.forEach((u) => mergeOptions(U, u, I, !0)), mergeOptions(U, E, I)), isObject$2(E) && F.set(E, U), U;
}
function mergeOptions(u, E, D, O = !1) {
	let { mixins: P, extends: F } = E;
	for (let I in F && mergeOptions(u, F, D, !0), P && P.forEach((E) => mergeOptions(u, E, D, !0)), E) if (!(O && I === "expose")) {
		let O = internalOptionMergeStrats[I] || D && D[I];
		u[I] = O ? O(u[I], E[I]) : E[I];
	}
	return u;
}
var internalOptionMergeStrats = {
	data: mergeDataFn,
	props: mergeEmitsOrPropsOptions,
	emits: mergeEmitsOrPropsOptions,
	methods: mergeObjectOptions,
	computed: mergeObjectOptions,
	beforeCreate: mergeAsArray,
	created: mergeAsArray,
	beforeMount: mergeAsArray,
	mounted: mergeAsArray,
	beforeUpdate: mergeAsArray,
	updated: mergeAsArray,
	beforeDestroy: mergeAsArray,
	beforeUnmount: mergeAsArray,
	destroyed: mergeAsArray,
	unmounted: mergeAsArray,
	activated: mergeAsArray,
	deactivated: mergeAsArray,
	errorCaptured: mergeAsArray,
	serverPrefetch: mergeAsArray,
	components: mergeObjectOptions,
	directives: mergeObjectOptions,
	watch: mergeWatchOptions,
	provide: mergeDataFn,
	inject: mergeInject
};
function mergeDataFn(u, E) {
	return E ? u ? function() {
		return extend(isFunction(u) ? u.call(this, this) : u, isFunction(E) ? E.call(this, this) : E);
	} : E : u;
}
function mergeInject(u, E) {
	return mergeObjectOptions(normalizeInject(u), normalizeInject(E));
}
function normalizeInject(u) {
	if (isArray(u)) {
		let E = {};
		for (let D = 0; D < u.length; D++) E[u[D]] = u[D];
		return E;
	}
	return u;
}
function mergeAsArray(u, E) {
	return u ? [...new Set([].concat(u, E))] : E;
}
function mergeObjectOptions(u, E) {
	return u ? extend(/* @__PURE__ */ Object.create(null), u, E) : E;
}
function mergeEmitsOrPropsOptions(u, E) {
	return u ? isArray(u) && isArray(E) ? [.../* @__PURE__ */ new Set([...u, ...E])] : extend(/* @__PURE__ */ Object.create(null), normalizePropsOrEmits(u), normalizePropsOrEmits(E ?? {})) : E;
}
function mergeWatchOptions(u, E) {
	if (!u) return E;
	if (!E) return u;
	let D = extend(/* @__PURE__ */ Object.create(null), u);
	for (let O in E) D[O] = mergeAsArray(u[O], E[O]);
	return D;
}
function createAppContext() {
	return {
		app: null,
		config: {
			isNativeTag: NO,
			performance: !1,
			globalProperties: {},
			optionMergeStrategies: {},
			errorHandler: void 0,
			warnHandler: void 0,
			compilerOptions: {}
		},
		mixins: [],
		components: {},
		directives: {},
		provides: /* @__PURE__ */ Object.create(null),
		optionsCache: /* @__PURE__ */ new WeakMap(),
		propsCache: /* @__PURE__ */ new WeakMap(),
		emitsCache: /* @__PURE__ */ new WeakMap()
	};
}
var uid$1 = 0;
function createAppAPI(u, E) {
	return function(D, O = null) {
		isFunction(D) || (D = extend({}, D)), O != null && !isObject$2(O) && (O = null);
		let P = createAppContext(), F = /* @__PURE__ */ new WeakSet(), I = [], R = !1, U = P.app = {
			_uid: uid$1++,
			_component: D,
			_props: O,
			_container: null,
			_context: P,
			_instance: null,
			version,
			get config() {
				return P.config;
			},
			set config(u) {},
			use(u, ...E) {
				return F.has(u) || (u && isFunction(u.install) ? (F.add(u), u.install(U, ...E)) : isFunction(u) && (F.add(u), u(U, ...E))), U;
			},
			mixin(u) {
				return P.mixins.includes(u) || P.mixins.push(u), U;
			},
			component(u, E) {
				return E ? (P.components[u] = E, U) : P.components[u];
			},
			directive(u, E) {
				return E ? (P.directives[u] = E, U) : P.directives[u];
			},
			mount(F, I, J) {
				if (!R) {
					let _p = U._ceVNode || createVNode(D, O);
					return _p.appContext = P, J === !0 ? J = "svg" : J === !1 && (J = void 0), I && E ? E(_p, F) : u(_p, F, J), R = !0, U._container = F, F.__vue_app__ = U, getComponentPublicInstance(_p.component);
				}
			},
			onUnmount(u) {
				I.push(u);
			},
			unmount() {
				R && (callWithAsyncErrorHandling(I, U._instance, 16), u(null, U._container), delete U._container.__vue_app__);
			},
			provide(u, E) {
				return P.provides[u] = E, U;
			},
			runWithContext(u) {
				let E = currentApp;
				currentApp = U;
				try {
					return u();
				} finally {
					currentApp = E;
				}
			}
		};
		return U;
	};
}
var currentApp = null;
function provide(u, E) {
	if (currentInstance) {
		let D = currentInstance.provides, O = currentInstance.parent && currentInstance.parent.provides;
		O === D && (D = currentInstance.provides = Object.create(O)), D[u] = E;
	}
}
function inject(u, E, D = !1) {
	let O = getCurrentInstance();
	if (O || currentApp) {
		let P = currentApp ? currentApp._context.provides : O ? O.parent == null || O.ce ? O.vnode.appContext && O.vnode.appContext.provides : O.parent.provides : void 0;
		if (P && u in P) return P[u];
		if (arguments.length > 1) return D && isFunction(E) ? E.call(O && O.proxy) : E;
	}
}
function hasInjectionContext() {
	return !!(getCurrentInstance() || currentApp);
}
var internalObjectProto = {}, createInternalObject = () => Object.create(internalObjectProto), isInternalObject = (u) => Object.getPrototypeOf(u) === internalObjectProto;
function initProps(u, E, D, O = !1) {
	let P = {}, F = createInternalObject();
	for (let D in u.propsDefaults = /* @__PURE__ */ Object.create(null), setFullProps(u, E, P, F), u.propsOptions[0]) D in P || (P[D] = void 0);
	D ? u.props = O ? P : shallowReactive(P) : u.type.props ? u.props = P : u.props = F, u.attrs = F;
}
function updateProps(u, E, D, O) {
	let { props: P, attrs: F, vnode: { patchFlag: I } } = u, R = toRaw(P), [U] = u.propsOptions, J = !1;
	if ((O || I > 0) && !(I & 16)) {
		if (I & 8) {
			let D = u.vnode.dynamicProps;
			for (let O = 0; O < D.length; O++) {
				let I = D[O];
				if (isEmitListener(u.emitsOptions, I)) continue;
				let _p = E[I];
				if (U) if (hasOwn$2(F, I)) _p !== F[I] && (F[I] = _p, J = !0);
				else {
					let E = camelize$2(I);
					P[E] = resolvePropValue(U, R, E, _p, u, !1);
				}
				else _p !== F[I] && (F[I] = _p, J = !0);
			}
		}
	} else {
		setFullProps(u, E, P, F) && (J = !0);
		let O;
		for (let F in R) (!E || !hasOwn$2(E, F) && ((O = hyphenate$2(F)) === F || !hasOwn$2(E, O))) && (U ? D && (D[F] !== void 0 || D[O] !== void 0) && (P[F] = resolvePropValue(U, R, F, void 0, u, !0)) : delete P[F]);
		if (F !== R) for (let u in F) (!E || !hasOwn$2(E, u)) && (delete F[u], J = !0);
	}
	J && trigger(u.attrs, "set", "");
}
function setFullProps(u, E, D, P) {
	let [F, I] = u.propsOptions, R = !1, U;
	if (E) for (let O in E) {
		if (isReservedProp(O)) continue;
		let J = E[O], _p;
		F && hasOwn$2(F, _p = camelize$2(O)) ? !I || !I.includes(_p) ? D[_p] = J : (U ||= {})[_p] = J : isEmitListener(u.emitsOptions, O) || (!(O in P) || J !== P[O]) && (P[O] = J, R = !0);
	}
	if (I) {
		let E = toRaw(D), P = U || EMPTY_OBJ;
		for (let O = 0; O < I.length; O++) {
			let R = I[O];
			D[R] = resolvePropValue(F, E, R, P[R], u, !hasOwn$2(P, R));
		}
	}
	return R;
}
function resolvePropValue(u, E, D, O, P, F) {
	let I = u[D];
	if (I != null) {
		let u = hasOwn$2(I, "default");
		if (u && O === void 0) {
			let u = I.default;
			if (I.type !== Function && !I.skipFactory && isFunction(u)) {
				let { propsDefaults: F } = P;
				if (D in F) O = F[D];
				else {
					let I = setCurrentInstance(P);
					O = F[D] = u.call(null, E), I();
				}
			} else O = u;
			P.ce && P.ce._setProp(D, O);
		}
		I[0] && (F && !u ? O = !1 : I[1] && (O === "" || O === hyphenate$2(D)) && (O = !0));
	}
	return O;
}
var mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(u, E, D = !1) {
	let F = D ? mixinPropsCache : E.propsCache, I = F.get(u);
	if (I) return I;
	let R = u.props, U = {}, _p = [], vp = !1;
	if (!isFunction(u)) {
		let O = (u) => {
			vp = !0;
			let [D, O] = normalizePropsOptions(u, E, !0);
			extend(U, D), O && _p.push(...O);
		};
		!D && E.mixins.length && E.mixins.forEach(O), u.extends && O(u.extends), u.mixins && u.mixins.forEach(O);
	}
	if (!R && !vp) return isObject$2(u) && F.set(u, EMPTY_ARR), EMPTY_ARR;
	if (isArray(R)) for (let u = 0; u < R.length; u++) {
		let E = camelize$2(R[u]);
		validatePropName(E) && (U[E] = EMPTY_OBJ);
	}
	else if (R) for (let u in R) {
		let E = camelize$2(u);
		if (validatePropName(E)) {
			let D = R[u], O = U[E] = isArray(D) || isFunction(D) ? { type: D } : extend({}, D), P = O.type, F = !1, I = !0;
			if (isArray(P)) for (let u = 0; u < P.length; ++u) {
				let E = P[u], D = isFunction(E) && E.name;
				if (D === "Boolean") {
					F = !0;
					break;
				} else D === "String" && (I = !1);
			}
			else F = isFunction(P) && P.name === "Boolean";
			O[0] = F, O[1] = I, (F || hasOwn$2(O, "default")) && _p.push(E);
		}
	}
	let xp = [U, _p];
	return isObject$2(u) && F.set(u, xp), xp;
}
function validatePropName(u) {
	return u[0] !== "$" && !isReservedProp(u);
}
var isInternalKey = (u) => u === "_" || u === "_ctx" || u === "$stable", normalizeSlotValue = (u) => isArray(u) ? u.map(normalizeVNode) : [normalizeVNode(u)], normalizeSlot = (u, E, D) => {
	if (E._n) return E;
	let O = withCtx((...u) => normalizeSlotValue(E(...u)), D);
	return O._c = !1, O;
}, normalizeObjectSlots = (u, E, D) => {
	let O = u._ctx;
	for (let D in u) {
		if (isInternalKey(D)) continue;
		let P = u[D];
		if (isFunction(P)) E[D] = normalizeSlot(D, P, O);
		else if (P != null) {
			let u = normalizeSlotValue(P);
			E[D] = () => u;
		}
	}
}, normalizeVNodeSlots = (u, E) => {
	let D = normalizeSlotValue(E);
	u.slots.default = () => D;
}, assignSlots = (u, E, D) => {
	for (let O in E) (D || !isInternalKey(O)) && (u[O] = E[O]);
}, initSlots = (u, E, D) => {
	let O = u.slots = createInternalObject();
	if (u.vnode.shapeFlag & 32) {
		let u = E._;
		u ? (assignSlots(O, E, D), D && def(O, "_", u, !0)) : normalizeObjectSlots(E, O);
	} else E && normalizeVNodeSlots(u, E);
}, updateSlots = (u, E, D) => {
	let { vnode: P, slots: F } = u, I = !0, R = EMPTY_OBJ;
	if (P.shapeFlag & 32) {
		let u = E._;
		u ? D && u === 1 ? I = !1 : assignSlots(F, E, D) : (I = !E.$stable, normalizeObjectSlots(E, F)), R = E;
	} else E && (normalizeVNodeSlots(u, E), R = { default: 1 });
	if (I) for (let u in F) !isInternalKey(u) && R[u] == null && delete F[u];
}, queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(u) {
	return baseCreateRenderer(u);
}
function createHydrationRenderer(u) {
	return baseCreateRenderer(u, createHydrationFunctions);
}
function baseCreateRenderer(u, E) {
	let D = getGlobalThis();
	D.__VUE__ = !0;
	let { insert: I, remove: R, patchProp: U, createElement: J, createText: _p, createComment: vp, setText: yp, setElementText: bp, parentNode: xp, nextSibling: Sp, setScopeId: Cp = NOOP, insertStaticContent: wp } = u, Tp = (u, E, D, O = null, P = null, F = null, I = void 0, R = null, U = !!E.dynamicChildren) => {
		if (u === E) return;
		u && !isSameVNodeType(u, E) && (O = nm(u), Zp(u, P, F, !0), u = null), E.patchFlag === -2 && (U = !1, E.dynamicChildren = null);
		let { type: J, ref: _p, shapeFlag: vp } = E;
		switch (J) {
			case Text:
				Ep(u, E, D, O);
				break;
			case Comment:
				Dp(u, E, D, O);
				break;
			case Static:
				u ?? Op(E, D, O, I);
				break;
			case Fragment:
				zp(u, E, D, O, P, F, I, R, U);
				break;
			default: vp & 1 ? jp(u, E, D, O, P, F, I, R, U) : vp & 6 ? Bp(u, E, D, O, P, F, I, R, U) : (vp & 64 || vp & 128) && J.process(u, E, D, O, P, F, I, R, U, am);
		}
		_p != null && P ? setRef(_p, u && u.ref, F, E || u, !E) : _p == null && u && u.ref != null && setRef(u.ref, null, F, u, !0);
	}, Ep = (u, E, D, O) => {
		if (u == null) I(E.el = _p(E.children), D, O);
		else {
			let D = E.el = u.el;
			E.children !== u.children && yp(D, E.children);
		}
	}, Dp = (u, E, D, O) => {
		u == null ? I(E.el = vp(E.children || ""), D, O) : E.el = u.el;
	}, Op = (u, E, D, O) => {
		[u.el, u.anchor] = wp(u.children, E, D, O, u.el, u.anchor);
	}, kp = ({ el: u, anchor: E }, D, O) => {
		let P;
		for (; u && u !== E;) P = Sp(u), I(u, D, O), u = P;
		I(E, D, O);
	}, Ap = ({ el: u, anchor: E }) => {
		let D;
		for (; u && u !== E;) D = Sp(u), R(u), u = D;
		R(E);
	}, jp = (u, E, D, O, P, F, I, R, U) => {
		E.type === "svg" ? I = "svg" : E.type === "math" && (I = "mathml"), u == null ? Mp(E, D, O, P, F, I, R, U) : Ip(u, E, P, F, I, R, U);
	}, Mp = (u, E, D, O, P, F, R, _p) => {
		let vp, yp, { props: xp, shapeFlag: Sp, transition: Cp, dirs: wp } = u;
		if (vp = u.el = J(u.type, F, xp && xp.is, xp), Sp & 8 ? bp(vp, u.children) : Sp & 16 && Pp(u.children, vp, null, O, P, resolveChildrenNamespace(u, F), R, _p), wp && invokeDirectiveHook(u, null, O, "created"), Np(vp, u, u.scopeId, R, O), xp) {
			for (let u in xp) u !== "value" && !isReservedProp(u) && U(vp, u, null, xp[u], F, O);
			"value" in xp && U(vp, "value", null, xp.value, F), (yp = xp.onVnodeBeforeMount) && invokeVNodeHook(yp, O, u);
		}
		wp && invokeDirectiveHook(u, null, O, "beforeMount");
		let Tp = needTransition(P, Cp);
		Tp && Cp.beforeEnter(vp), I(vp, E, D), ((yp = xp && xp.onVnodeMounted) || Tp || wp) && queuePostRenderEffect(() => {
			yp && invokeVNodeHook(yp, O, u), Tp && Cp.enter(vp), wp && invokeDirectiveHook(u, null, O, "mounted");
		}, P);
	}, Np = (u, E, D, O, P) => {
		if (D && Cp(u, D), O) for (let E = 0; E < O.length; E++) Cp(u, O[E]);
		if (P) {
			let D = P.subTree;
			if (E === D || isSuspense(D.type) && (D.ssContent === E || D.ssFallback === E)) {
				let E = P.vnode;
				Np(u, E, E.scopeId, E.slotScopeIds, P.parent);
			}
		}
	}, Pp = (u, E, D, O, P, F, I, R, U = 0) => {
		for (let J = U; J < u.length; J++) Tp(null, u[J] = R ? cloneIfMounted(u[J]) : normalizeVNode(u[J]), E, D, O, P, F, I, R);
	}, Ip = (u, E, D, P, F, I, R) => {
		let J = E.el = u.el, { patchFlag: _p, dynamicChildren: vp, dirs: yp } = E;
		_p |= u.patchFlag & 16;
		let xp = u.props || EMPTY_OBJ, Sp = E.props || EMPTY_OBJ, Cp;
		if (D && toggleRecurse(D, !1), (Cp = Sp.onVnodeBeforeUpdate) && invokeVNodeHook(Cp, D, E, u), yp && invokeDirectiveHook(E, u, D, "beforeUpdate"), D && toggleRecurse(D, !0), (xp.innerHTML && Sp.innerHTML == null || xp.textContent && Sp.textContent == null) && bp(J, ""), vp ? Lp(u.dynamicChildren, vp, J, D, P, resolveChildrenNamespace(E, F), I) : R || Kp(u, E, J, null, D, P, resolveChildrenNamespace(E, F), I, !1), _p > 0) {
			if (_p & 16) Rp(J, xp, Sp, D, F);
			else if (_p & 2 && xp.class !== Sp.class && U(J, "class", null, Sp.class, F), _p & 4 && U(J, "style", xp.style, Sp.style, F), _p & 8) {
				let u = E.dynamicProps;
				for (let E = 0; E < u.length; E++) {
					let O = u[E], P = xp[O], I = Sp[O];
					(I !== P || O === "value") && U(J, O, P, I, F, D);
				}
			}
			_p & 1 && u.children !== E.children && bp(J, E.children);
		} else !R && vp == null && Rp(J, xp, Sp, D, F);
		((Cp = Sp.onVnodeUpdated) || yp) && queuePostRenderEffect(() => {
			Cp && invokeVNodeHook(Cp, D, E, u), yp && invokeDirectiveHook(E, u, D, "updated");
		}, P);
	}, Lp = (u, E, D, O, P, F, I) => {
		for (let R = 0; R < E.length; R++) {
			let U = u[R], J = E[R];
			Tp(U, J, U.el && (U.type === Fragment || !isSameVNodeType(U, J) || U.shapeFlag & 198) ? xp(U.el) : D, null, O, P, F, I, !0);
		}
	}, Rp = (u, E, D, P, F) => {
		if (E !== D) {
			if (E !== EMPTY_OBJ) for (let O in E) !isReservedProp(O) && !(O in D) && U(u, O, E[O], null, F, P);
			for (let O in D) {
				if (isReservedProp(O)) continue;
				let I = D[O], R = E[O];
				I !== R && O !== "value" && U(u, O, R, I, F, P);
			}
			"value" in D && U(u, "value", E.value, D.value, F);
		}
	}, zp = (u, E, D, O, P, F, R, U, J) => {
		let vp = E.el = u ? u.el : _p(""), yp = E.anchor = u ? u.anchor : _p(""), { patchFlag: bp, dynamicChildren: xp, slotScopeIds: Sp } = E;
		Sp && (U = U ? U.concat(Sp) : Sp), u == null ? (I(vp, D, O), I(yp, D, O), Pp(E.children || [], D, yp, P, F, R, U, J)) : bp > 0 && bp & 64 && xp && u.dynamicChildren ? (Lp(u.dynamicChildren, xp, D, P, F, R, U), (E.key != null || P && E === P.subTree) && traverseStaticChildren(u, E, !0)) : Kp(u, E, D, yp, P, F, R, U, J);
	}, Bp = (u, E, D, O, P, F, I, R, U) => {
		E.slotScopeIds = R, u == null ? E.shapeFlag & 512 ? P.ctx.activate(E, D, O, I, U) : Vp(E, D, O, P, F, I, U) : Hp(u, E, U);
	}, Vp = (u, E, D, O, P, F, I) => {
		let R = u.component = createComponentInstance(u, O, P);
		if (isKeepAlive(u) && (R.ctx.renderer = am), setupComponent(R, !1, I), R.asyncDep) {
			if (P && P.registerDep(R, Up, I), !u.el) {
				let O = R.subTree = createVNode(Comment);
				Dp(null, O, E, D), u.placeholder = O.el;
			}
		} else Up(R, u, E, D, P, F, I);
	}, Hp = (u, E, D) => {
		let O = E.component = u.component;
		if (shouldUpdateComponent(u, E, D)) if (O.asyncDep && !O.asyncResolved) {
			Gp(O, E, D);
			return;
		} else O.next = E, O.update();
		else E.el = u.el, O.vnode = E;
	}, Up = (u, E, D, O, P, F, I) => {
		let R = () => {
			if (u.isMounted) {
				let { next: E, bu: D, u: O, parent: U, vnode: J } = u;
				{
					let D = locateNonHydratedAsyncRoot(u);
					if (D) {
						E && (E.el = J.el, Gp(u, E, I)), D.asyncDep.then(() => {
							u.isUnmounted || R();
						});
						return;
					}
				}
				let _p = E, vp;
				toggleRecurse(u, !1), E ? (E.el = J.el, Gp(u, E, I)) : E = J, D && invokeArrayFns(D), (vp = E.props && E.props.onVnodeBeforeUpdate) && invokeVNodeHook(vp, U, E, J), toggleRecurse(u, !0);
				let yp = renderComponentRoot(u), bp = u.subTree;
				u.subTree = yp, Tp(bp, yp, xp(bp.el), nm(bp), u, P, F), E.el = yp.el, _p === null && updateHOCHostEl(u, yp.el), O && queuePostRenderEffect(O, P), (vp = E.props && E.props.onVnodeUpdated) && queuePostRenderEffect(() => invokeVNodeHook(vp, U, E, J), P);
			} else {
				let I, { el: R, props: U } = E, { bm: J, m: _p, parent: vp, root: yp, type: bp } = u, xp = isAsyncWrapper(E);
				if (toggleRecurse(u, !1), J && invokeArrayFns(J), !xp && (I = U && U.onVnodeBeforeMount) && invokeVNodeHook(I, vp, E), toggleRecurse(u, !0), R && sm) {
					let E = () => {
						u.subTree = renderComponentRoot(u), sm(R, u.subTree, u, P, null);
					};
					xp && bp.__asyncHydrate ? bp.__asyncHydrate(R, u, E) : E();
				} else {
					yp.ce && yp.ce._def.shadowRoot !== !1 && yp.ce._injectChildStyle(bp);
					let I = u.subTree = renderComponentRoot(u);
					Tp(null, I, D, O, u, P, F), E.el = I.el;
				}
				if (_p && queuePostRenderEffect(_p, P), !xp && (I = U && U.onVnodeMounted)) {
					let u = E;
					queuePostRenderEffect(() => invokeVNodeHook(I, vp, u), P);
				}
				(E.shapeFlag & 256 || vp && isAsyncWrapper(vp.vnode) && vp.vnode.shapeFlag & 256) && u.a && queuePostRenderEffect(u.a, P), u.isMounted = !0, E = D = O = null;
			}
		};
		u.scope.on();
		let U = u.effect = new ReactiveEffect(R);
		u.scope.off();
		let J = u.update = U.run.bind(U), _p = u.job = U.runIfDirty.bind(U);
		_p.i = u, _p.id = u.uid, U.scheduler = () => queueJob(_p), toggleRecurse(u, !0), J();
	}, Gp = (u, E, D) => {
		E.component = u;
		let O = u.vnode.props;
		u.vnode = E, u.next = null, updateProps(u, E.props, O, D), updateSlots(u, E.children, D), pauseTracking(), flushPreFlushCbs(u), resetTracking();
	}, Kp = (u, E, D, O, P, F, I, R, U = !1) => {
		let J = u && u.children, _p = u ? u.shapeFlag : 0, vp = E.children, { patchFlag: yp, shapeFlag: xp } = E;
		if (yp > 0) {
			if (yp & 128) {
				Jp(J, vp, D, O, P, F, I, R, U);
				return;
			} else if (yp & 256) {
				qp(J, vp, D, O, P, F, I, R, U);
				return;
			}
		}
		xp & 8 ? (_p & 16 && tm(J, P, F), vp !== J && bp(D, vp)) : _p & 16 ? xp & 16 ? Jp(J, vp, D, O, P, F, I, R, U) : tm(J, P, F, !0) : (_p & 8 && bp(D, ""), xp & 16 && Pp(vp, D, O, P, F, I, R, U));
	}, qp = (u, E, D, O, F, I, R, U, J) => {
		u ||= EMPTY_ARR, E ||= EMPTY_ARR;
		let _p = u.length, vp = E.length, yp = Math.min(_p, vp), bp;
		for (bp = 0; bp < yp; bp++) {
			let O = E[bp] = J ? cloneIfMounted(E[bp]) : normalizeVNode(E[bp]);
			Tp(u[bp], O, D, null, F, I, R, U, J);
		}
		_p > vp ? tm(u, F, I, !0, !1, yp) : Pp(E, D, O, F, I, R, U, J, yp);
	}, Jp = (u, E, D, O, F, I, R, U, J) => {
		let _p = 0, vp = E.length, yp = u.length - 1, bp = vp - 1;
		for (; _p <= yp && _p <= bp;) {
			let O = u[_p], P = E[_p] = J ? cloneIfMounted(E[_p]) : normalizeVNode(E[_p]);
			if (isSameVNodeType(O, P)) Tp(O, P, D, null, F, I, R, U, J);
			else break;
			_p++;
		}
		for (; _p <= yp && _p <= bp;) {
			let O = u[yp], P = E[bp] = J ? cloneIfMounted(E[bp]) : normalizeVNode(E[bp]);
			if (isSameVNodeType(O, P)) Tp(O, P, D, null, F, I, R, U, J);
			else break;
			yp--, bp--;
		}
		if (_p > yp) {
			if (_p <= bp) {
				let u = bp + 1, P = u < vp ? E[u].el : O;
				for (; _p <= bp;) Tp(null, E[_p] = J ? cloneIfMounted(E[_p]) : normalizeVNode(E[_p]), D, P, F, I, R, U, J), _p++;
			}
		} else if (_p > bp) for (; _p <= yp;) Zp(u[_p], F, I, !0), _p++;
		else {
			let xp = _p, Sp = _p, Cp = /* @__PURE__ */ new Map();
			for (_p = Sp; _p <= bp; _p++) {
				let u = E[_p] = J ? cloneIfMounted(E[_p]) : normalizeVNode(E[_p]);
				u.key != null && Cp.set(u.key, _p);
			}
			let wp, Ep = 0, Dp = bp - Sp + 1, Op = !1, kp = 0, Ap = Array(Dp);
			for (_p = 0; _p < Dp; _p++) Ap[_p] = 0;
			for (_p = xp; _p <= yp; _p++) {
				let O = u[_p];
				if (Ep >= Dp) {
					Zp(O, F, I, !0);
					continue;
				}
				let P;
				if (O.key != null) P = Cp.get(O.key);
				else for (wp = Sp; wp <= bp; wp++) if (Ap[wp - Sp] === 0 && isSameVNodeType(O, E[wp])) {
					P = wp;
					break;
				}
				P === void 0 ? Zp(O, F, I, !0) : (Ap[P - Sp] = _p + 1, P >= kp ? kp = P : Op = !0, Tp(O, E[P], D, null, F, I, R, U, J), Ep++);
			}
			let jp = Op ? getSequence(Ap) : EMPTY_ARR;
			for (wp = jp.length - 1, _p = Dp - 1; _p >= 0; _p--) {
				let u = Sp + _p, P = E[u], yp = E[u + 1], bp = u + 1 < vp ? yp.el || yp.placeholder : O;
				Ap[_p] === 0 ? Tp(null, P, D, bp, F, I, R, U, J) : Op && (wp < 0 || _p !== jp[wp] ? Xp(P, D, bp, 2) : wp--);
			}
		}
	}, Xp = (u, E, D, O, P = null) => {
		let { el: F, type: U, transition: J, children: _p, shapeFlag: vp } = u;
		if (vp & 6) {
			Xp(u.component.subTree, E, D, O);
			return;
		}
		if (vp & 128) {
			u.suspense.move(E, D, O);
			return;
		}
		if (vp & 64) {
			U.move(u, E, D, am);
			return;
		}
		if (U === Fragment) {
			I(F, E, D);
			for (let u = 0; u < _p.length; u++) Xp(_p[u], E, D, O);
			I(u.anchor, E, D);
			return;
		}
		if (U === Static) {
			kp(u, E, D);
			return;
		}
		if (O !== 2 && vp & 1 && J) if (O === 0) J.beforeEnter(F), I(F, E, D), queuePostRenderEffect(() => J.enter(F), P);
		else {
			let { leave: O, delayLeave: P, afterLeave: U } = J, _p = () => {
				u.ctx.isUnmounted ? R(F) : I(F, E, D);
			}, vp = () => {
				F._isLeaving && F[leaveCbKey](!0), O(F, () => {
					_p(), U && U();
				});
			};
			P ? P(F, _p, vp) : vp();
		}
		else I(F, E, D);
	}, Zp = (u, E, D, O = !1, P = !1) => {
		let { type: F, props: I, ref: R, children: U, dynamicChildren: J, shapeFlag: _p, patchFlag: vp, dirs: yp, cacheIndex: bp } = u;
		if (vp === -2 && (P = !1), R != null && (pauseTracking(), setRef(R, null, D, u, !0), resetTracking()), bp != null && (E.renderCache[bp] = void 0), _p & 256) {
			E.ctx.deactivate(u);
			return;
		}
		let xp = _p & 1 && yp, Sp = !isAsyncWrapper(u), Cp;
		if (Sp && (Cp = I && I.onVnodeBeforeUnmount) && invokeVNodeHook(Cp, E, u), _p & 6) em(u.component, D, O);
		else {
			if (_p & 128) {
				u.suspense.unmount(D, O);
				return;
			}
			xp && invokeDirectiveHook(u, null, E, "beforeUnmount"), _p & 64 ? u.type.remove(u, E, D, am, O) : J && !J.hasOnce && (F !== Fragment || vp > 0 && vp & 64) ? tm(J, E, D, !1, !0) : (F === Fragment && vp & 384 || !P && _p & 16) && tm(U, E, D), O && Qp(u);
		}
		(Sp && (Cp = I && I.onVnodeUnmounted) || xp) && queuePostRenderEffect(() => {
			Cp && invokeVNodeHook(Cp, E, u), xp && invokeDirectiveHook(u, null, E, "unmounted");
		}, D);
	}, Qp = (u) => {
		let { type: E, el: D, anchor: O, transition: P } = u;
		if (E === Fragment) {
			$p(D, O);
			return;
		}
		if (E === Static) {
			Ap(u);
			return;
		}
		let F = () => {
			R(D), P && !P.persisted && P.afterLeave && P.afterLeave();
		};
		if (u.shapeFlag & 1 && P && !P.persisted) {
			let { leave: E, delayLeave: O } = P, I = () => E(D, F);
			O ? O(u.el, F, I) : I();
		} else F();
	}, $p = (u, E) => {
		let D;
		for (; u !== E;) D = Sp(u), R(u), u = D;
		R(E);
	}, em = (u, E, D) => {
		let { bum: O, scope: P, job: F, subTree: I, um: R, m: U, a: J } = u;
		invalidateMount(U), invalidateMount(J), O && invokeArrayFns(O), P.stop(), F && (F.flags |= 8, Zp(I, u, E, D)), R && queuePostRenderEffect(R, E), queuePostRenderEffect(() => {
			u.isUnmounted = !0;
		}, E);
	}, tm = (u, E, D, O = !1, P = !1, F = 0) => {
		for (let I = F; I < u.length; I++) Zp(u[I], E, D, O, P);
	}, nm = (u) => {
		if (u.shapeFlag & 6) return nm(u.component.subTree);
		if (u.shapeFlag & 128) return u.suspense.next();
		let E = Sp(u.anchor || u.el), D = E && E[TeleportEndKey];
		return D ? Sp(D) : E;
	}, rm = !1, im = (u, E, D) => {
		u == null ? E._vnode && Zp(E._vnode, null, null, !0) : Tp(E._vnode || null, u, E, null, null, null, D), E._vnode = u, rm ||= (rm = !0, flushPreFlushCbs(), flushPostFlushCbs(), !1);
	}, am = {
		p: Tp,
		um: Zp,
		m: Xp,
		r: Qp,
		mt: Vp,
		mc: Pp,
		pc: Kp,
		pbc: Lp,
		n: nm,
		o: u
	}, om, sm;
	return E && ([om, sm] = E(am)), {
		render: im,
		hydrate: om,
		createApp: createAppAPI(im, om)
	};
}
function resolveChildrenNamespace({ type: u, props: E }, D) {
	return D === "svg" && u === "foreignObject" || D === "mathml" && u === "annotation-xml" && E && E.encoding && E.encoding.includes("html") ? void 0 : D;
}
function toggleRecurse({ effect: u, job: E }, D) {
	D ? (u.flags |= 32, E.flags |= 4) : (u.flags &= -33, E.flags &= -5);
}
function needTransition(u, E) {
	return (!u || u && !u.pendingBranch) && E && !E.persisted;
}
function traverseStaticChildren(u, E, D = !1) {
	let O = u.children, P = E.children;
	if (isArray(O) && isArray(P)) for (let u = 0; u < O.length; u++) {
		let E = O[u], F = P[u];
		F.shapeFlag & 1 && !F.dynamicChildren && ((F.patchFlag <= 0 || F.patchFlag === 32) && (F = P[u] = cloneIfMounted(P[u]), F.el = E.el), !D && F.patchFlag !== -2 && traverseStaticChildren(E, F)), F.type === Text && F.patchFlag !== -1 && (F.el = E.el), F.type === Comment && !F.el && (F.el = E.el);
	}
}
function getSequence(u) {
	let E = u.slice(), D = [0], O, P, F, I, R, U = u.length;
	for (O = 0; O < U; O++) {
		let U = u[O];
		if (U !== 0) {
			if (P = D[D.length - 1], u[P] < U) {
				E[O] = P, D.push(O);
				continue;
			}
			for (F = 0, I = D.length - 1; F < I;) R = F + I >> 1, u[D[R]] < U ? F = R + 1 : I = R;
			U < u[D[F]] && (F > 0 && (E[O] = D[F - 1]), D[F] = O);
		}
	}
	for (F = D.length, I = D[F - 1]; F-- > 0;) D[F] = I, I = E[I];
	return D;
}
function locateNonHydratedAsyncRoot(u) {
	let E = u.subTree.component;
	if (E) return E.asyncDep && !E.asyncResolved ? E : locateNonHydratedAsyncRoot(E);
}
function invalidateMount(u) {
	if (u) for (let E = 0; E < u.length; E++) u[E].flags |= 8;
}
var ssrContextKey = Symbol.for("v-scx"), useSSRContext = () => inject(ssrContextKey);
function watchEffect(u, E) {
	return doWatch(u, null, E);
}
function watchPostEffect(u, E) {
	return doWatch(u, null, { flush: "post" });
}
function watchSyncEffect(u, E) {
	return doWatch(u, null, { flush: "sync" });
}
function watch(u, E, D) {
	return doWatch(u, E, D);
}
function doWatch(u, E, D = EMPTY_OBJ) {
	let { immediate: P, deep: I, flush: R, once: U } = D, _p = extend({}, D), vp = E && P || !E && R !== "post", yp;
	if (isInSSRComponentSetup) {
		if (R === "sync") {
			let u = useSSRContext();
			yp = u.__watcherHandles ||= [];
		} else if (!vp) {
			let u = () => {};
			return u.stop = NOOP, u.resume = NOOP, u.pause = NOOP, u;
		}
	}
	let bp = currentInstance;
	_p.call = (u, E, D) => callWithAsyncErrorHandling(u, bp, E, D);
	let xp = !1;
	R === "post" ? _p.scheduler = (u) => {
		queuePostRenderEffect(u, bp && bp.suspense);
	} : R !== "sync" && (xp = !0, _p.scheduler = (u, E) => {
		E ? u() : queueJob(u);
	}), _p.augmentJob = (u) => {
		E && (u.flags |= 4), xp && (u.flags |= 2, bp && (u.id = bp.uid, u.i = bp));
	};
	let Sp = watch$1(u, E, _p);
	return isInSSRComponentSetup && (yp ? yp.push(Sp) : vp && Sp()), Sp;
}
function instanceWatch(u, E, D) {
	let O = this.proxy, P = isString(u) ? u.includes(".") ? createPathGetter(O, u) : () => O[u] : u.bind(O, O), F;
	isFunction(E) ? F = E : (F = E.handler, D = E);
	let I = setCurrentInstance(this), R = doWatch(P, F.bind(O), D);
	return I(), R;
}
function createPathGetter(u, E) {
	let D = E.split(".");
	return () => {
		let E = u;
		for (let u = 0; u < D.length && E; u++) E = E[D[u]];
		return E;
	};
}
function useModel(u, E, D = EMPTY_OBJ) {
	let P = getCurrentInstance(), F = camelize$2(E), I = hyphenate$2(E), R = getModelModifiers(u, F), U = customRef((R, U) => {
		let J, _p = EMPTY_OBJ, vp;
		return watchSyncEffect(() => {
			let E = u[F];
			hasChanged(J, E) && (J = E, U());
		}), {
			get() {
				return R(), D.get ? D.get(J) : J;
			},
			set(u) {
				let R = D.set ? D.set(u) : u;
				if (!hasChanged(R, J) && !(_p !== EMPTY_OBJ && hasChanged(u, _p))) return;
				let yp = P.vnode.props;
				yp && (E in yp || F in yp || I in yp) && (`onUpdate:${E}` in yp || `onUpdate:${F}` in yp || `onUpdate:${I}` in yp) || (J = u, U()), P.emit(`update:${E}`, R), hasChanged(u, R) && hasChanged(u, _p) && !hasChanged(R, vp) && U(), _p = u, vp = R;
			}
		};
	});
	return U[Symbol.iterator] = () => {
		let u = 0;
		return { next() {
			return u < 2 ? {
				value: u++ ? R || EMPTY_OBJ : U,
				done: !1
			} : { done: !0 };
		} };
	}, U;
}
var getModelModifiers = (u, E) => E === "modelValue" || E === "model-value" ? u.modelModifiers : u[`${E}Modifiers`] || u[`${camelize$2(E)}Modifiers`] || u[`${hyphenate$2(E)}Modifiers`];
function emit(u, E, ...D) {
	if (u.isUnmounted) return;
	let P = u.vnode.props || EMPTY_OBJ, F = D, I = E.startsWith("update:"), R = I && getModelModifiers(P, E.slice(7));
	R && (R.trim && (F = D.map((u) => isString(u) ? u.trim() : u)), R.number && (F = D.map(looseToNumber)));
	let U, J = P[U = toHandlerKey(E)] || P[U = toHandlerKey(camelize$2(E))];
	!J && I && (J = P[U = toHandlerKey(hyphenate$2(E))]), J && callWithAsyncErrorHandling(J, u, 6, F);
	let _p = P[U + "Once"];
	if (_p) {
		if (!u.emitted) u.emitted = {};
		else if (u.emitted[U]) return;
		u.emitted[U] = !0, callWithAsyncErrorHandling(_p, u, 6, F);
	}
}
var mixinEmitsCache = /* @__PURE__ */ new WeakMap();
function normalizeEmitsOptions(u, E, D = !1) {
	let O = D ? mixinEmitsCache : E.emitsCache, P = O.get(u);
	if (P !== void 0) return P;
	let F = u.emits, I = {}, R = !1;
	if (!isFunction(u)) {
		let O = (u) => {
			let D = normalizeEmitsOptions(u, E, !0);
			D && (R = !0, extend(I, D));
		};
		!D && E.mixins.length && E.mixins.forEach(O), u.extends && O(u.extends), u.mixins && u.mixins.forEach(O);
	}
	return !F && !R ? (isObject$2(u) && O.set(u, null), null) : (isArray(F) ? F.forEach((u) => I[u] = null) : extend(I, F), isObject$2(u) && O.set(u, I), I);
}
function isEmitListener(u, E) {
	return !u || !isOn(E) ? !1 : (E = E.slice(2).replace(/Once$/, ""), hasOwn$2(u, E[0].toLowerCase() + E.slice(1)) || hasOwn$2(u, hyphenate$2(E)) || hasOwn$2(u, E));
}
function renderComponentRoot(u) {
	let { type: E, vnode: D, proxy: O, withProxy: P, propsOptions: [F], slots: I, attrs: R, emit: J, render: _p, renderCache: vp, props: yp, data: bp, setupState: xp, ctx: Sp, inheritAttrs: Cp } = u, wp = setCurrentRenderingInstance(u), Tp, Ep;
	try {
		if (D.shapeFlag & 4) {
			let u = P || O, E = u;
			Tp = normalizeVNode(_p.call(E, u, vp, yp, xp, bp, Sp)), Ep = R;
		} else {
			let u = E;
			Tp = normalizeVNode(u.length > 1 ? u(yp, {
				attrs: R,
				slots: I,
				emit: J
			}) : u(yp, null)), Ep = E.props ? R : getFunctionalFallthrough(R);
		}
	} catch (E) {
		blockStack.length = 0, handleError(E, u, 1), Tp = createVNode(Comment);
	}
	let Dp = Tp;
	if (Ep && Cp !== !1) {
		let u = Object.keys(Ep), { shapeFlag: E } = Dp;
		u.length && E & 7 && (F && u.some(isModelListener) && (Ep = filterModelListeners(Ep, F)), Dp = cloneVNode(Dp, Ep, !1, !0));
	}
	return D.dirs && (Dp = cloneVNode(Dp, null, !1, !0), Dp.dirs = Dp.dirs ? Dp.dirs.concat(D.dirs) : D.dirs), D.transition && setTransitionHooks(Dp, D.transition), Tp = Dp, setCurrentRenderingInstance(wp), Tp;
}
function filterSingleRoot(u, E = !0) {
	let D;
	for (let E = 0; E < u.length; E++) {
		let O = u[E];
		if (isVNode(O)) {
			if (O.type !== Comment || O.children === "v-if") {
				if (D) return;
				D = O;
			}
		} else return;
	}
	return D;
}
var getFunctionalFallthrough = (u) => {
	let E;
	for (let D in u) (D === "class" || D === "style" || isOn(D)) && ((E ||= {})[D] = u[D]);
	return E;
}, filterModelListeners = (u, E) => {
	let D = {};
	for (let O in u) (!isModelListener(O) || !(O.slice(9) in E)) && (D[O] = u[O]);
	return D;
};
function shouldUpdateComponent(u, E, D) {
	let { props: O, children: P, component: F } = u, { props: I, children: R, patchFlag: U } = E, J = F.emitsOptions;
	if (E.dirs || E.transition) return !0;
	if (D && U >= 0) {
		if (U & 1024) return !0;
		if (U & 16) return O ? hasPropsChanged(O, I, J) : !!I;
		if (U & 8) {
			let u = E.dynamicProps;
			for (let E = 0; E < u.length; E++) {
				let D = u[E];
				if (I[D] !== O[D] && !isEmitListener(J, D)) return !0;
			}
		}
	} else return (P || R) && (!R || !R.$stable) ? !0 : O === I ? !1 : O ? I ? hasPropsChanged(O, I, J) : !0 : !!I;
	return !1;
}
function hasPropsChanged(u, E, D) {
	let O = Object.keys(E);
	if (O.length !== Object.keys(u).length) return !0;
	for (let P = 0; P < O.length; P++) {
		let F = O[P];
		if (E[F] !== u[F] && !isEmitListener(D, F)) return !0;
	}
	return !1;
}
function updateHOCHostEl({ vnode: u, parent: E }, D) {
	for (; E;) {
		let O = E.subTree;
		if (O.suspense && O.suspense.activeBranch === u && (O.el = u.el), O === u) (u = E.vnode).el = D, E = E.parent;
		else break;
	}
}
var isSuspense = (u) => u.__isSuspense, suspenseId = 0, Suspense = {
	name: "Suspense",
	__isSuspense: !0,
	process(u, E, D, O, P, F, I, R, U, J) {
		if (u == null) mountSuspense(E, D, O, P, F, I, R, U, J);
		else {
			if (F && F.deps > 0 && !u.suspense.isInFallback) {
				E.suspense = u.suspense, E.suspense.vnode = E, E.el = u.el;
				return;
			}
			patchSuspense(u, E, D, O, P, I, R, U, J);
		}
	},
	hydrate: hydrateSuspense,
	normalize: normalizeSuspenseChildren
};
function triggerEvent(u, E) {
	let D = u.props && u.props[E];
	isFunction(D) && D();
}
function mountSuspense(u, E, D, O, P, F, I, R, U) {
	let { p: J, o: { createElement: _p } } = U, vp = _p("div"), yp = u.suspense = createSuspenseBoundary(u, P, O, E, vp, D, F, I, R, U);
	J(null, yp.pendingBranch = u.ssContent, vp, null, O, yp, F, I), yp.deps > 0 ? (triggerEvent(u, "onPending"), triggerEvent(u, "onFallback"), J(null, u.ssFallback, E, D, O, null, F, I), setActiveBranch(yp, u.ssFallback)) : yp.resolve(!1, !0);
}
function patchSuspense(u, E, D, O, P, F, I, R, { p: U, um: J, o: { createElement: _p } }) {
	let vp = E.suspense = u.suspense;
	vp.vnode = E, E.el = u.el;
	let yp = E.ssContent, bp = E.ssFallback, { activeBranch: xp, pendingBranch: Sp, isInFallback: Cp, isHydrating: wp } = vp;
	if (Sp) vp.pendingBranch = yp, isSameVNodeType(Sp, yp) ? (U(Sp, yp, vp.hiddenContainer, null, P, vp, F, I, R), vp.deps <= 0 ? vp.resolve() : Cp && (wp || (U(xp, bp, D, O, P, null, F, I, R), setActiveBranch(vp, bp)))) : (vp.pendingId = suspenseId++, wp ? (vp.isHydrating = !1, vp.activeBranch = Sp) : J(Sp, P, vp), vp.deps = 0, vp.effects.length = 0, vp.hiddenContainer = _p("div"), Cp ? (U(null, yp, vp.hiddenContainer, null, P, vp, F, I, R), vp.deps <= 0 ? vp.resolve() : (U(xp, bp, D, O, P, null, F, I, R), setActiveBranch(vp, bp))) : xp && isSameVNodeType(xp, yp) ? (U(xp, yp, D, O, P, vp, F, I, R), vp.resolve(!0)) : (U(null, yp, vp.hiddenContainer, null, P, vp, F, I, R), vp.deps <= 0 && vp.resolve()));
	else if (xp && isSameVNodeType(xp, yp)) U(xp, yp, D, O, P, vp, F, I, R), setActiveBranch(vp, yp);
	else if (triggerEvent(E, "onPending"), vp.pendingBranch = yp, yp.shapeFlag & 512 ? vp.pendingId = yp.component.suspenseId : vp.pendingId = suspenseId++, U(null, yp, vp.hiddenContainer, null, P, vp, F, I, R), vp.deps <= 0) vp.resolve();
	else {
		let { timeout: u, pendingId: E } = vp;
		u > 0 ? setTimeout(() => {
			vp.pendingId === E && vp.fallback(bp);
		}, u) : u === 0 && vp.fallback(bp);
	}
}
function createSuspenseBoundary(u, E, D, O, P, F, I, R, U, J, _p = !1) {
	let { p: vp, m: yp, um: bp, n: xp, o: { parentNode: Sp, remove: Cp } } = J, wp, Tp = isVNodeSuspensible(u);
	Tp && E && E.pendingBranch && (wp = E.pendingId, E.deps++);
	let Ep = u.props ? toNumber(u.props.timeout) : void 0, Dp = F, Op = {
		vnode: u,
		parent: E,
		parentComponent: D,
		namespace: I,
		container: O,
		hiddenContainer: P,
		deps: 0,
		pendingId: suspenseId++,
		timeout: typeof Ep == "number" ? Ep : -1,
		activeBranch: null,
		pendingBranch: null,
		isInFallback: !_p,
		isHydrating: _p,
		isUnmounted: !1,
		effects: [],
		resolve(u = !1, D = !1) {
			let { vnode: O, activeBranch: P, pendingBranch: I, pendingId: R, effects: U, parentComponent: J, container: _p } = Op, vp = !1;
			Op.isHydrating ? Op.isHydrating = !1 : u || (vp = P && I.transition && I.transition.mode === "out-in", vp && (P.transition.afterLeave = () => {
				R === Op.pendingId && (yp(I, _p, F === Dp ? xp(P) : F, 0), queuePostFlushCb(U));
			}), P && (Sp(P.el) === _p && (F = xp(P)), bp(P, J, Op, !0)), vp || yp(I, _p, F, 0)), setActiveBranch(Op, I), Op.pendingBranch = null, Op.isInFallback = !1;
			let Cp = Op.parent, Ep = !1;
			for (; Cp;) {
				if (Cp.pendingBranch) {
					Cp.effects.push(...U), Ep = !0;
					break;
				}
				Cp = Cp.parent;
			}
			!Ep && !vp && queuePostFlushCb(U), Op.effects = [], Tp && E && E.pendingBranch && wp === E.pendingId && (E.deps--, E.deps === 0 && !D && E.resolve()), triggerEvent(O, "onResolve");
		},
		fallback(u) {
			if (!Op.pendingBranch) return;
			let { vnode: E, activeBranch: D, parentComponent: O, container: P, namespace: F } = Op;
			triggerEvent(E, "onFallback");
			let I = xp(D), J = () => {
				Op.isInFallback && (vp(null, u, P, I, O, null, F, R, U), setActiveBranch(Op, u));
			}, _p = u.transition && u.transition.mode === "out-in";
			_p && (D.transition.afterLeave = J), Op.isInFallback = !0, bp(D, O, null, !0), _p || J();
		},
		move(u, E, D) {
			Op.activeBranch && yp(Op.activeBranch, u, E, D), Op.container = u;
		},
		next() {
			return Op.activeBranch && xp(Op.activeBranch);
		},
		registerDep(u, E, D) {
			let O = !!Op.pendingBranch;
			O && Op.deps++;
			let P = u.vnode.el;
			u.asyncDep.catch((E) => {
				handleError(E, u, 0);
			}).then((F) => {
				if (u.isUnmounted || Op.isUnmounted || Op.pendingId !== u.suspenseId) return;
				u.asyncResolved = !0;
				let { vnode: R } = u;
				handleSetupResult(u, F, !1), P && (R.el = P);
				let U = !P && u.subTree.el;
				E(u, R, Sp(P || u.subTree.el), P ? null : xp(u.subTree), Op, I, D), U && Cp(U), updateHOCHostEl(u, R.el), O && --Op.deps === 0 && Op.resolve();
			});
		},
		unmount(u, E) {
			Op.isUnmounted = !0, Op.activeBranch && bp(Op.activeBranch, D, u, E), Op.pendingBranch && bp(Op.pendingBranch, D, u, E);
		}
	};
	return Op;
}
function hydrateSuspense(u, E, D, O, P, F, I, R, U) {
	let J = E.suspense = createSuspenseBoundary(E, O, D, u.parentNode, document.createElement("div"), null, P, F, I, R, !0), _p = U(u, J.pendingBranch = E.ssContent, D, J, F, I);
	return J.deps === 0 && J.resolve(!1, !0), _p;
}
function normalizeSuspenseChildren(u) {
	let { shapeFlag: E, children: D } = u, O = E & 32;
	u.ssContent = normalizeSuspenseSlot(O ? D.default : D), u.ssFallback = O ? normalizeSuspenseSlot(D.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(u) {
	let E;
	if (isFunction(u)) {
		let D = isBlockTreeEnabled && u._c;
		D && (u._d = !1, openBlock()), u = u(), D && (u._d = !0, E = currentBlock, closeBlock());
	}
	return isArray(u) && (u = filterSingleRoot(u)), u = normalizeVNode(u), E && !u.dynamicChildren && (u.dynamicChildren = E.filter((E) => E !== u)), u;
}
function queueEffectWithSuspense(u, E) {
	E && E.pendingBranch ? isArray(u) ? E.effects.push(...u) : E.effects.push(u) : queuePostFlushCb(u);
}
function setActiveBranch(u, E) {
	u.activeBranch = E;
	let { vnode: D, parentComponent: O } = u, P = E.el;
	for (; !P && E.component;) E = E.component.subTree, P = E.el;
	D.el = P, O && O.subTree === D && (O.vnode.el = P, updateHOCHostEl(O, P));
}
function isVNodeSuspensible(u) {
	let E = u.props && u.props.suspensible;
	return E != null && E !== !1;
}
var Fragment = Symbol.for("v-fgt"), Text = Symbol.for("v-txt"), Comment = Symbol.for("v-cmt"), Static = Symbol.for("v-stc"), blockStack = [], currentBlock = null;
function openBlock(u = !1) {
	blockStack.push(currentBlock = u ? null : []);
}
function closeBlock() {
	blockStack.pop(), currentBlock = blockStack[blockStack.length - 1] || null;
}
var isBlockTreeEnabled = 1;
function setBlockTracking(u, E = !1) {
	isBlockTreeEnabled += u, u < 0 && currentBlock && E && (currentBlock.hasOnce = !0);
}
function setupBlock(u) {
	return u.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null, closeBlock(), isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(u), u;
}
function createElementBlock(u, E, D, O, P, F) {
	return setupBlock(createBaseVNode(u, E, D, O, P, F, !0));
}
function createBlock(u, E, D, O, P) {
	return setupBlock(createVNode(u, E, D, O, P, !0));
}
function isVNode(u) {
	return u ? u.__v_isVNode === !0 : !1;
}
function isSameVNodeType(u, E) {
	return u.type === E.type && u.key === E.key;
}
function transformVNodeArgs(u) {}
var normalizeKey = ({ key: u }) => u ?? null, normalizeRef = ({ ref: u, ref_key: E, ref_for: D }) => (typeof u == "number" && (u = "" + u), u == null ? null : isString(u) || isRef(u) || isFunction(u) ? {
	i: currentRenderingInstance,
	r: u,
	k: E,
	f: !!D
} : u);
function createBaseVNode(u, E = null, D = null, O = 0, P = null, F = u === Fragment ? 0 : 1, I = !1, R = !1) {
	let U = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: u,
		props: E,
		key: E && normalizeKey(E),
		ref: E && normalizeRef(E),
		scopeId: currentScopeId,
		slotScopeIds: null,
		children: D,
		component: null,
		suspense: null,
		ssContent: null,
		ssFallback: null,
		dirs: null,
		transition: null,
		el: null,
		anchor: null,
		target: null,
		targetStart: null,
		targetAnchor: null,
		staticCount: 0,
		shapeFlag: F,
		patchFlag: O,
		dynamicProps: P,
		dynamicChildren: null,
		appContext: null,
		ctx: currentRenderingInstance
	};
	return R ? (normalizeChildren(U, D), F & 128 && u.normalize(U)) : D && (U.shapeFlag |= isString(D) ? 8 : 16), isBlockTreeEnabled > 0 && !I && currentBlock && (U.patchFlag > 0 || F & 6) && U.patchFlag !== 32 && currentBlock.push(U), U;
}
var createVNode = _createVNode;
function _createVNode(u, E = null, D = null, O = 0, P = null, F = !1) {
	if ((!u || u === NULL_DYNAMIC_COMPONENT) && (u = Comment), isVNode(u)) {
		let O = cloneVNode(u, E, !0);
		return D && normalizeChildren(O, D), isBlockTreeEnabled > 0 && !F && currentBlock && (O.shapeFlag & 6 ? currentBlock[currentBlock.indexOf(u)] = O : currentBlock.push(O)), O.patchFlag = -2, O;
	}
	if (isClassComponent(u) && (u = u.__vccOpts), E) {
		E = guardReactiveProps(E);
		let { class: u, style: D } = E;
		u && !isString(u) && (E.class = normalizeClass(u)), isObject$2(D) && (isProxy(D) && !isArray(D) && (D = extend({}, D)), E.style = normalizeStyle(D));
	}
	let I = isString(u) ? 1 : isSuspense(u) ? 128 : isTeleport(u) ? 64 : isObject$2(u) ? 4 : isFunction(u) ? 2 : 0;
	return createBaseVNode(u, E, D, O, P, I, F, !0);
}
function guardReactiveProps(u) {
	return u ? isProxy(u) || isInternalObject(u) ? extend({}, u) : u : null;
}
function cloneVNode(u, E, D = !1, O = !1) {
	let { props: P, ref: F, patchFlag: I, children: R, transition: U } = u, J = E ? mergeProps(P || {}, E) : P, _p = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: u.type,
		props: J,
		key: J && normalizeKey(J),
		ref: E && E.ref ? D && F ? isArray(F) ? F.concat(normalizeRef(E)) : [F, normalizeRef(E)] : normalizeRef(E) : F,
		scopeId: u.scopeId,
		slotScopeIds: u.slotScopeIds,
		children: R,
		target: u.target,
		targetStart: u.targetStart,
		targetAnchor: u.targetAnchor,
		staticCount: u.staticCount,
		shapeFlag: u.shapeFlag,
		patchFlag: E && u.type !== Fragment ? I === -1 ? 16 : I | 16 : I,
		dynamicProps: u.dynamicProps,
		dynamicChildren: u.dynamicChildren,
		appContext: u.appContext,
		dirs: u.dirs,
		transition: U,
		component: u.component,
		suspense: u.suspense,
		ssContent: u.ssContent && cloneVNode(u.ssContent),
		ssFallback: u.ssFallback && cloneVNode(u.ssFallback),
		placeholder: u.placeholder,
		el: u.el,
		anchor: u.anchor,
		ctx: u.ctx,
		ce: u.ce
	};
	return U && O && setTransitionHooks(_p, U.clone(_p)), _p;
}
function createTextVNode(u = " ", E = 0) {
	return createVNode(Text, null, u, E);
}
function createStaticVNode(u, E) {
	let D = createVNode(Static, null, u);
	return D.staticCount = E, D;
}
function createCommentVNode(u = "", E = !1) {
	return E ? (openBlock(), createBlock(Comment, null, u)) : createVNode(Comment, null, u);
}
function normalizeVNode(u) {
	return u == null || typeof u == "boolean" ? createVNode(Comment) : isArray(u) ? createVNode(Fragment, null, u.slice()) : isVNode(u) ? cloneIfMounted(u) : createVNode(Text, null, String(u));
}
function cloneIfMounted(u) {
	return u.el === null && u.patchFlag !== -1 || u.memo ? u : cloneVNode(u);
}
function normalizeChildren(u, E) {
	let D = 0, { shapeFlag: O } = u;
	if (E == null) E = null;
	else if (isArray(E)) D = 16;
	else if (typeof E == "object") if (O & 65) {
		let D = E.default;
		D && (D._c && (D._d = !1), normalizeChildren(u, D()), D._c && (D._d = !0));
		return;
	} else {
		D = 32;
		let O = E._;
		!O && !isInternalObject(E) ? E._ctx = currentRenderingInstance : O === 3 && currentRenderingInstance && (currentRenderingInstance.slots._ === 1 ? E._ = 1 : (E._ = 2, u.patchFlag |= 1024));
	}
	else isFunction(E) ? (E = {
		default: E,
		_ctx: currentRenderingInstance
	}, D = 32) : (E = String(E), O & 64 ? (D = 16, E = [createTextVNode(E)]) : D = 8);
	u.children = E, u.shapeFlag |= D;
}
function mergeProps(...u) {
	let E = {};
	for (let D = 0; D < u.length; D++) {
		let O = u[D];
		for (let u in O) if (u === "class") E.class !== O.class && (E.class = normalizeClass([E.class, O.class]));
		else if (u === "style") E.style = normalizeStyle([E.style, O.style]);
		else if (isOn(u)) {
			let D = E[u], P = O[u];
			P && D !== P && !(isArray(D) && D.includes(P)) && (E[u] = D ? [].concat(D, P) : P);
		} else u !== "" && (E[u] = O[u]);
	}
	return E;
}
function invokeVNodeHook(u, E, D, O = null) {
	callWithAsyncErrorHandling(u, E, 7, [D, O]);
}
var emptyAppContext = createAppContext(), uid = 0;
function createComponentInstance(u, E, D) {
	let P = u.type, F = (E ? E.appContext : u.appContext) || emptyAppContext, I = {
		uid: uid++,
		vnode: u,
		type: P,
		parent: E,
		appContext: F,
		root: null,
		next: null,
		subTree: null,
		effect: null,
		update: null,
		job: null,
		scope: new EffectScope(!0),
		render: null,
		proxy: null,
		exposed: null,
		exposeProxy: null,
		withProxy: null,
		provides: E ? E.provides : Object.create(F.provides),
		ids: E ? E.ids : [
			"",
			0,
			0
		],
		accessCache: null,
		renderCache: [],
		components: null,
		directives: null,
		propsOptions: normalizePropsOptions(P, F),
		emitsOptions: normalizeEmitsOptions(P, F),
		emit: null,
		emitted: null,
		propsDefaults: EMPTY_OBJ,
		inheritAttrs: P.inheritAttrs,
		ctx: EMPTY_OBJ,
		data: EMPTY_OBJ,
		props: EMPTY_OBJ,
		attrs: EMPTY_OBJ,
		slots: EMPTY_OBJ,
		refs: EMPTY_OBJ,
		setupState: EMPTY_OBJ,
		setupContext: null,
		suspense: D,
		suspenseId: D ? D.pendingId : 0,
		asyncDep: null,
		asyncResolved: !1,
		isMounted: !1,
		isUnmounted: !1,
		isDeactivated: !1,
		bc: null,
		c: null,
		bm: null,
		m: null,
		bu: null,
		u: null,
		um: null,
		bum: null,
		da: null,
		a: null,
		rtg: null,
		rtc: null,
		ec: null,
		sp: null
	};
	return I.ctx = { _: I }, I.root = E ? E.root : I, I.emit = emit.bind(null, I), u.ce && u.ce(I), I;
}
var currentInstance = null, getCurrentInstance = () => currentInstance || currentRenderingInstance, internalSetCurrentInstance, setInSSRSetupState;
{
	let u = getGlobalThis(), E = (E, D) => {
		let O;
		return (O = u[E]) || (O = u[E] = []), O.push(D), (u) => {
			O.length > 1 ? O.forEach((E) => E(u)) : O[0](u);
		};
	};
	internalSetCurrentInstance = E("__VUE_INSTANCE_SETTERS__", (u) => currentInstance = u), setInSSRSetupState = E("__VUE_SSR_SETTERS__", (u) => isInSSRComponentSetup = u);
}
var setCurrentInstance = (u) => {
	let E = currentInstance;
	return internalSetCurrentInstance(u), u.scope.on(), () => {
		u.scope.off(), internalSetCurrentInstance(E);
	};
}, unsetCurrentInstance = () => {
	currentInstance && currentInstance.scope.off(), internalSetCurrentInstance(null);
};
function isStatefulComponent(u) {
	return u.vnode.shapeFlag & 4;
}
var isInSSRComponentSetup = !1;
function setupComponent(u, E = !1, D = !1) {
	E && setInSSRSetupState(E);
	let { props: O, children: P } = u.vnode, F = isStatefulComponent(u);
	initProps(u, O, F, E), initSlots(u, P, D || E);
	let I = F ? setupStatefulComponent(u, E) : void 0;
	return E && setInSSRSetupState(!1), I;
}
function setupStatefulComponent(u, E) {
	let D = u.type;
	u.accessCache = /* @__PURE__ */ Object.create(null), u.proxy = new Proxy(u.ctx, PublicInstanceProxyHandlers);
	let { setup: O } = D;
	if (O) {
		pauseTracking();
		let D = u.setupContext = O.length > 1 ? createSetupContext(u) : null, P = setCurrentInstance(u), F = callWithErrorHandling(O, u, 0, [u.props, D]), I = isPromise(F);
		if (resetTracking(), P(), (I || u.sp) && !isAsyncWrapper(u) && markAsyncBoundary(u), I) {
			if (F.then(unsetCurrentInstance, unsetCurrentInstance), E) return F.then((D) => {
				handleSetupResult(u, D, E);
			}).catch((E) => {
				handleError(E, u, 0);
			});
			u.asyncDep = F;
		} else handleSetupResult(u, F, E);
	} else finishComponentSetup(u, E);
}
function handleSetupResult(u, E, D) {
	isFunction(E) ? u.type.__ssrInlineRender ? u.ssrRender = E : u.render = E : isObject$2(E) && (u.setupState = proxyRefs(E)), finishComponentSetup(u, D);
}
var compile$1, installWithProxy;
function registerRuntimeCompiler(u) {
	compile$1 = u, installWithProxy = (u) => {
		u.render._rc && (u.withProxy = new Proxy(u.ctx, RuntimeCompiledPublicInstanceProxyHandlers));
	};
}
var isRuntimeOnly = () => !compile$1;
function finishComponentSetup(u, E, D) {
	let O = u.type;
	if (!u.render) {
		if (!E && compile$1 && !O.render) {
			let E = O.template || resolveMergedOptions(u).template;
			if (E) {
				let { isCustomElement: D, compilerOptions: P } = u.appContext.config, { delimiters: F, compilerOptions: I } = O, R = extend(extend({
					isCustomElement: D,
					delimiters: F
				}, P), I);
				O.render = compile$1(E, R);
			}
		}
		u.render = O.render || NOOP, installWithProxy && installWithProxy(u);
	}
	{
		let E = setCurrentInstance(u);
		pauseTracking();
		try {
			applyOptions(u);
		} finally {
			resetTracking(), E();
		}
	}
}
var attrsProxyHandlers = { get(u, E) {
	return track(u, "get", ""), u[E];
} };
function createSetupContext(u) {
	return {
		attrs: new Proxy(u.attrs, attrsProxyHandlers),
		slots: u.slots,
		emit: u.emit,
		expose: (E) => {
			u.exposed = E || {};
		}
	};
}
function getComponentPublicInstance(u) {
	return u.exposed ? u.exposeProxy ||= new Proxy(proxyRefs(markRaw(u.exposed)), {
		get(E, D) {
			if (D in E) return E[D];
			if (D in publicPropertiesMap) return publicPropertiesMap[D](u);
		},
		has(u, E) {
			return E in u || E in publicPropertiesMap;
		}
	}) : u.proxy;
}
function getComponentName(u, E = !0) {
	return isFunction(u) ? u.displayName || u.name : u.name || E && u.__name;
}
function isClassComponent(u) {
	return isFunction(u) && "__vccOpts" in u;
}
var computed = (u, E) => computed$1(u, E, isInSSRComponentSetup);
function h$5(u, E, D) {
	try {
		setBlockTracking(-1);
		let O = arguments.length;
		return O === 2 ? isObject$2(E) && !isArray(E) ? isVNode(E) ? createVNode(u, null, [E]) : createVNode(u, E) : createVNode(u, null, E) : (O > 3 ? D = Array.prototype.slice.call(arguments, 2) : O === 3 && isVNode(D) && (D = [D]), createVNode(u, E, D));
	} finally {
		setBlockTracking(1);
	}
}
function initCustomFormatter() {
	return;
	function u(E, D, O) {
		let P = E[O];
		if (isArray(P) && P.includes(D) || isObject$2(P) && D in P || E.extends && u(E.extends, D, O) || E.mixins && E.mixins.some((E) => u(E, D, O))) return !0;
	}
}
function withMemo(u, E, D, O) {
	let P = D[O];
	if (P && isMemoSame(P, u)) return P;
	let F = E();
	return F.memo = u.slice(), F.cacheIndex = O, D[O] = F;
}
function isMemoSame(u, E) {
	let D = u.memo;
	if (D.length != E.length) return !1;
	for (let u = 0; u < D.length; u++) if (hasChanged(D[u], E[u])) return !1;
	return isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(u), !0;
}
var version = "3.5.22", warn = NOOP, ErrorTypeStrings = ErrorTypeStrings$1, devtools = devtools$1, setDevtoolsHook = setDevtoolsHook$1, ssrUtils = {
	createComponentInstance,
	setupComponent,
	renderComponentRoot,
	setCurrentRenderingInstance,
	isVNode,
	normalizeVNode,
	getComponentPublicInstance,
	ensureValidVNode,
	pushWarningContext,
	popWarningContext
}, policy = void 0, tt = typeof window < "u" && window.trustedTypes;
if (tt) try {
	policy = /* @__PURE__ */ tt.createPolicy("vue", { createHTML: (u) => u });
} catch {}
var unsafeToTrustedHTML = policy ? (u) => policy.createHTML(u) : (u) => u, svgNS = "http://www.w3.org/2000/svg", mathmlNS = "http://www.w3.org/1998/Math/MathML", doc = typeof document < "u" ? document : null, templateContainer = doc && /* @__PURE__ */ doc.createElement("template"), nodeOps = {
	insert: (u, E, D) => {
		E.insertBefore(u, D || null);
	},
	remove: (u) => {
		let E = u.parentNode;
		E && E.removeChild(u);
	},
	createElement: (u, E, D, O) => {
		let P = E === "svg" ? doc.createElementNS(svgNS, u) : E === "mathml" ? doc.createElementNS(mathmlNS, u) : D ? doc.createElement(u, { is: D }) : doc.createElement(u);
		return u === "select" && O && O.multiple != null && P.setAttribute("multiple", O.multiple), P;
	},
	createText: (u) => doc.createTextNode(u),
	createComment: (u) => doc.createComment(u),
	setText: (u, E) => {
		u.nodeValue = E;
	},
	setElementText: (u, E) => {
		u.textContent = E;
	},
	parentNode: (u) => u.parentNode,
	nextSibling: (u) => u.nextSibling,
	querySelector: (u) => doc.querySelector(u),
	setScopeId(u, E) {
		u.setAttribute(E, "");
	},
	insertStaticContent(u, E, D, O, P, F) {
		let I = D ? D.previousSibling : E.lastChild;
		if (P && (P === F || P.nextSibling)) for (; E.insertBefore(P.cloneNode(!0), D), !(P === F || !(P = P.nextSibling)););
		else {
			templateContainer.innerHTML = unsafeToTrustedHTML(O === "svg" ? `<svg>${u}</svg>` : O === "mathml" ? `<math>${u}</math>` : u);
			let P = templateContainer.content;
			if (O === "svg" || O === "mathml") {
				let u = P.firstChild;
				for (; u.firstChild;) P.appendChild(u.firstChild);
				P.removeChild(u);
			}
			E.insertBefore(P, D);
		}
		return [I ? I.nextSibling : E.firstChild, D ? D.previousSibling : E.lastChild];
	}
}, TRANSITION = "transition", ANIMATION = "animation", vtcKey = Symbol("_vtc"), DOMTransitionPropsValidators = {
	name: String,
	type: String,
	css: {
		type: Boolean,
		default: !0
	},
	duration: [
		String,
		Number,
		Object
	],
	enterFromClass: String,
	enterActiveClass: String,
	enterToClass: String,
	appearFromClass: String,
	appearActiveClass: String,
	appearToClass: String,
	leaveFromClass: String,
	leaveActiveClass: String,
	leaveToClass: String
}, TransitionPropsValidators = /* @__PURE__ */ extend({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators), Transition = /* @__PURE__ */ ((u) => (u.displayName = "Transition", u.props = TransitionPropsValidators, u))((u, { slots: E }) => h$5(BaseTransition, resolveTransitionProps(u), E)), callHook = (u, E = []) => {
	isArray(u) ? u.forEach((u) => u(...E)) : u && u(...E);
}, hasExplicitCallback = (u) => u ? isArray(u) ? u.some((u) => u.length > 1) : u.length > 1 : !1;
function resolveTransitionProps(u) {
	let E = {};
	for (let D in u) D in DOMTransitionPropsValidators || (E[D] = u[D]);
	if (u.css === !1) return E;
	let { name: D = "v", type: O, duration: P, enterFromClass: F = `${D}-enter-from`, enterActiveClass: I = `${D}-enter-active`, enterToClass: R = `${D}-enter-to`, appearFromClass: U = F, appearActiveClass: _p = I, appearToClass: vp = R, leaveFromClass: yp = `${D}-leave-from`, leaveActiveClass: bp = `${D}-leave-active`, leaveToClass: xp = `${D}-leave-to` } = u, Sp = normalizeDuration(P), Cp = Sp && Sp[0], wp = Sp && Sp[1], { onBeforeEnter: Tp, onEnter: Ep, onEnterCancelled: Dp, onLeave: Op, onLeaveCancelled: kp, onBeforeAppear: Ap = Tp, onAppear: jp = Ep, onAppearCancelled: Mp = Dp } = E, Np = (u, E, D, O) => {
		u._enterCancelled = O, removeTransitionClass(u, E ? vp : R), removeTransitionClass(u, E ? _p : I), D && D();
	}, Pp = (u, E) => {
		u._isLeaving = !1, removeTransitionClass(u, yp), removeTransitionClass(u, xp), removeTransitionClass(u, bp), E && E();
	}, Fp = (u) => (E, D) => {
		let P = u ? jp : Ep, I = () => Np(E, u, D);
		callHook(P, [E, I]), nextFrame(() => {
			removeTransitionClass(E, u ? U : F), addTransitionClass(E, u ? vp : R), hasExplicitCallback(P) || whenTransitionEnds(E, O, Cp, I);
		});
	};
	return extend(E, {
		onBeforeEnter(u) {
			callHook(Tp, [u]), addTransitionClass(u, F), addTransitionClass(u, I);
		},
		onBeforeAppear(u) {
			callHook(Ap, [u]), addTransitionClass(u, U), addTransitionClass(u, _p);
		},
		onEnter: Fp(!1),
		onAppear: Fp(!0),
		onLeave(u, E) {
			u._isLeaving = !0;
			let D = () => Pp(u, E);
			addTransitionClass(u, yp), u._enterCancelled ? (addTransitionClass(u, bp), forceReflow(u)) : (forceReflow(u), addTransitionClass(u, bp)), nextFrame(() => {
				u._isLeaving && (removeTransitionClass(u, yp), addTransitionClass(u, xp), hasExplicitCallback(Op) || whenTransitionEnds(u, O, wp, D));
			}), callHook(Op, [u, D]);
		},
		onEnterCancelled(u) {
			Np(u, !1, void 0, !0), callHook(Dp, [u]);
		},
		onAppearCancelled(u) {
			Np(u, !0, void 0, !0), callHook(Mp, [u]);
		},
		onLeaveCancelled(u) {
			Pp(u), callHook(kp, [u]);
		}
	});
}
function normalizeDuration(u) {
	if (u == null) return null;
	if (isObject$2(u)) return [NumberOf(u.enter), NumberOf(u.leave)];
	{
		let E = NumberOf(u);
		return [E, E];
	}
}
function NumberOf(u) {
	return toNumber(u);
}
function addTransitionClass(u, E) {
	E.split(/\s+/).forEach((E) => E && u.classList.add(E)), (u[vtcKey] || (u[vtcKey] = /* @__PURE__ */ new Set())).add(E);
}
function removeTransitionClass(u, E) {
	E.split(/\s+/).forEach((E) => E && u.classList.remove(E));
	let D = u[vtcKey];
	D && (D.delete(E), D.size || (u[vtcKey] = void 0));
}
function nextFrame(u) {
	requestAnimationFrame(() => {
		requestAnimationFrame(u);
	});
}
var endId = 0;
function whenTransitionEnds(u, E, D, O) {
	let P = u._endId = ++endId, F = () => {
		P === u._endId && O();
	};
	if (D != null) return setTimeout(F, D);
	let { type: I, timeout: R, propCount: U } = getTransitionInfo(u, E);
	if (!I) return O();
	let J = I + "end", _p = 0, vp = () => {
		u.removeEventListener(J, yp), F();
	}, yp = (E) => {
		E.target === u && ++_p >= U && vp();
	};
	setTimeout(() => {
		_p < U && vp();
	}, R + 1), u.addEventListener(J, yp);
}
function getTransitionInfo(u, E) {
	let D = window.getComputedStyle(u), O = (u) => (D[u] || "").split(", "), P = O(`${TRANSITION}Delay`), F = O(`${TRANSITION}Duration`), I = getTimeout(P, F), R = O(`${ANIMATION}Delay`), U = O(`${ANIMATION}Duration`), J = getTimeout(R, U), _p = null, vp = 0, yp = 0;
	E === TRANSITION ? I > 0 && (_p = TRANSITION, vp = I, yp = F.length) : E === ANIMATION ? J > 0 && (_p = ANIMATION, vp = J, yp = U.length) : (vp = Math.max(I, J), _p = vp > 0 ? I > J ? TRANSITION : ANIMATION : null, yp = _p ? _p === TRANSITION ? F.length : U.length : 0);
	let bp = _p === TRANSITION && /\b(?:transform|all)(?:,|$)/.test(O(`${TRANSITION}Property`).toString());
	return {
		type: _p,
		timeout: vp,
		propCount: yp,
		hasTransform: bp
	};
}
function getTimeout(u, E) {
	for (; u.length < E.length;) u = u.concat(u);
	return Math.max(...E.map((E, D) => toMs(E) + toMs(u[D])));
}
function toMs(u) {
	return u === "auto" ? 0 : Number(u.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow(u) {
	return (u ? u.ownerDocument : document).body.offsetHeight;
}
function patchClass(u, E, D) {
	let O = u[vtcKey];
	O && (E = (E ? [E, ...O] : [...O]).join(" ")), E == null ? u.removeAttribute("class") : D ? u.setAttribute("class", E) : u.className = E;
}
var vShowOriginalDisplay = Symbol("_vod"), vShowHidden = Symbol("_vsh"), vShow = {
	name: "show",
	beforeMount(u, { value: E }, { transition: D }) {
		u[vShowOriginalDisplay] = u.style.display === "none" ? "" : u.style.display, D && E ? D.beforeEnter(u) : setDisplay(u, E);
	},
	mounted(u, { value: E }, { transition: D }) {
		D && E && D.enter(u);
	},
	updated(u, { value: E, oldValue: D }, { transition: O }) {
		!E != !D && (O ? E ? (O.beforeEnter(u), setDisplay(u, !0), O.enter(u)) : O.leave(u, () => {
			setDisplay(u, !1);
		}) : setDisplay(u, E));
	},
	beforeUnmount(u, { value: E }) {
		setDisplay(u, E);
	}
};
function setDisplay(u, E) {
	u.style.display = E ? u[vShowOriginalDisplay] : "none", u[vShowHidden] = !E;
}
function initVShowForSSR() {
	vShow.getSSRProps = ({ value: u }) => {
		if (!u) return { style: { display: "none" } };
	};
}
var CSS_VAR_TEXT = Symbol("");
function useCssVars(u) {
	let E = getCurrentInstance();
	if (!E) return;
	let D = E.ut = (D = u(E.proxy)) => {
		Array.from(document.querySelectorAll(`[data-v-owner="${E.uid}"]`)).forEach((u) => setVarsOnNode(u, D));
	}, O = () => {
		let O = u(E.proxy);
		E.ce ? setVarsOnNode(E.ce, O) : setVarsOnVNode(E.subTree, O), D(O);
	};
	onBeforeUpdate(() => {
		queuePostFlushCb(O);
	}), onMounted(() => {
		watch(O, NOOP, { flush: "post" });
		let u = new MutationObserver(O);
		u.observe(E.subTree.el.parentNode, { childList: !0 }), onUnmounted(() => u.disconnect());
	});
}
function setVarsOnVNode(u, E) {
	if (u.shapeFlag & 128) {
		let D = u.suspense;
		u = D.activeBranch, D.pendingBranch && !D.isHydrating && D.effects.push(() => {
			setVarsOnVNode(D.activeBranch, E);
		});
	}
	for (; u.component;) u = u.component.subTree;
	if (u.shapeFlag & 1 && u.el) setVarsOnNode(u.el, E);
	else if (u.type === Fragment) u.children.forEach((u) => setVarsOnVNode(u, E));
	else if (u.type === Static) {
		let { el: D, anchor: O } = u;
		for (; D && (setVarsOnNode(D, E), D !== O);) D = D.nextSibling;
	}
}
function setVarsOnNode(u, E) {
	if (u.nodeType === 1) {
		let D = u.style, O = "";
		for (let u in E) {
			let P = normalizeCssVarValue(E[u]);
			D.setProperty(`--${u}`, P), O += `--${u}: ${P};`;
		}
		D[CSS_VAR_TEXT] = O;
	}
}
var displayRE = /(?:^|;)\s*display\s*:/;
function patchStyle(u, E, D) {
	let O = u.style, P = isString(D), F = !1;
	if (D && !P) {
		if (E) if (isString(E)) for (let u of E.split(";")) {
			let E = u.slice(0, u.indexOf(":")).trim();
			D[E] ?? setStyle(O, E, "");
		}
		else for (let u in E) D[u] ?? setStyle(O, u, "");
		for (let u in D) u === "display" && (F = !0), setStyle(O, u, D[u]);
	} else if (P) {
		if (E !== D) {
			let u = O[CSS_VAR_TEXT];
			u && (D += ";" + u), O.cssText = D, F = displayRE.test(D);
		}
	} else E && u.removeAttribute("style");
	vShowOriginalDisplay in u && (u[vShowOriginalDisplay] = F ? O.display : "", u[vShowHidden] && (O.display = "none"));
}
var importantRE = /\s*!important$/;
function setStyle(u, E, D) {
	if (isArray(D)) D.forEach((D) => setStyle(u, E, D));
	else if (D ??= "", E.startsWith("--")) u.setProperty(E, D);
	else {
		let O = autoPrefix(u, E);
		importantRE.test(D) ? u.setProperty(hyphenate$2(O), D.replace(importantRE, ""), "important") : u[O] = D;
	}
}
var prefixes = [
	"Webkit",
	"Moz",
	"ms"
], prefixCache = {};
function autoPrefix(u, E) {
	let D = prefixCache[E];
	if (D) return D;
	let O = camelize$2(E);
	if (O !== "filter" && O in u) return prefixCache[E] = O;
	O = capitalize(O);
	for (let D = 0; D < prefixes.length; D++) {
		let P = prefixes[D] + O;
		if (P in u) return prefixCache[E] = P;
	}
	return E;
}
var xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(u, E, D, O, P, F = isSpecialBooleanAttr(E)) {
	O && E.startsWith("xlink:") ? D == null ? u.removeAttributeNS(xlinkNS, E.slice(6, E.length)) : u.setAttributeNS(xlinkNS, E, D) : D == null || F && !includeBooleanAttr(D) ? u.removeAttribute(E) : u.setAttribute(E, F ? "" : isSymbol(D) ? String(D) : D);
}
function patchDOMProp(u, E, D, O, P) {
	if (E === "innerHTML" || E === "textContent") {
		D != null && (u[E] = E === "innerHTML" ? unsafeToTrustedHTML(D) : D);
		return;
	}
	let F = u.tagName;
	if (E === "value" && F !== "PROGRESS" && !F.includes("-")) {
		let O = F === "OPTION" ? u.getAttribute("value") || "" : u.value, P = D == null ? u.type === "checkbox" ? "on" : "" : String(D);
		(O !== P || !("_value" in u)) && (u.value = P), D ?? u.removeAttribute(E), u._value = D;
		return;
	}
	let I = !1;
	if (D === "" || D == null) {
		let O = typeof u[E];
		O === "boolean" ? D = includeBooleanAttr(D) : D == null && O === "string" ? (D = "", I = !0) : O === "number" && (D = 0, I = !0);
	}
	try {
		u[E] = D;
	} catch {}
	I && u.removeAttribute(P || E);
}
function addEventListener$1(u, E, D, O) {
	u.addEventListener(E, D, O);
}
function removeEventListener(u, E, D, O) {
	u.removeEventListener(E, D, O);
}
var veiKey = Symbol("_vei");
function patchEvent(u, E, D, O, P = null) {
	let F = u[veiKey] || (u[veiKey] = {}), I = F[E];
	if (O && I) I.value = O;
	else {
		let [D, R] = parseName(E);
		O ? addEventListener$1(u, D, F[E] = createInvoker(O, P), R) : I && (removeEventListener(u, D, I, R), F[E] = void 0);
	}
}
var optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(u) {
	let E;
	if (optionsModifierRE.test(u)) {
		E = {};
		let D;
		for (; D = u.match(optionsModifierRE);) u = u.slice(0, u.length - D[0].length), E[D[0].toLowerCase()] = !0;
	}
	return [u[2] === ":" ? u.slice(3) : hyphenate$2(u.slice(2)), E];
}
var cachedNow = 0, p$2 = /* @__PURE__ */ Promise.resolve(), getNow = () => cachedNow ||= (p$2.then(() => cachedNow = 0), Date.now());
function createInvoker(u, E) {
	let D = (u) => {
		if (!u._vts) u._vts = Date.now();
		else if (u._vts <= D.attached) return;
		callWithAsyncErrorHandling(patchStopImmediatePropagation(u, D.value), E, 5, [u]);
	};
	return D.value = u, D.attached = getNow(), D;
}
function patchStopImmediatePropagation(u, E) {
	if (isArray(E)) {
		let D = u.stopImmediatePropagation;
		return u.stopImmediatePropagation = () => {
			D.call(u), u._stopped = !0;
		}, E.map((u) => (E) => !E._stopped && u && u(E));
	} else return E;
}
var isNativeOn = (u) => u.charCodeAt(0) === 111 && u.charCodeAt(1) === 110 && u.charCodeAt(2) > 96 && u.charCodeAt(2) < 123, patchProp = (u, E, D, O, P, F) => {
	let I = P === "svg";
	E === "class" ? patchClass(u, O, I) : E === "style" ? patchStyle(u, D, O) : isOn(E) ? isModelListener(E) || patchEvent(u, E, D, O, F) : (E[0] === "." ? (E = E.slice(1), !0) : E[0] === "^" ? (E = E.slice(1), !1) : shouldSetAsProp(u, E, O, I)) ? (patchDOMProp(u, E, O), !u.tagName.includes("-") && (E === "value" || E === "checked" || E === "selected") && patchAttr(u, E, O, I, F, E !== "value")) : u._isVueCE && (/[A-Z]/.test(E) || !isString(O)) ? patchDOMProp(u, camelize$2(E), O, F, E) : (E === "true-value" ? u._trueValue = O : E === "false-value" && (u._falseValue = O), patchAttr(u, E, O, I));
};
function shouldSetAsProp(u, E, D, O) {
	if (O) return !!(E === "innerHTML" || E === "textContent" || E in u && isNativeOn(E) && isFunction(D));
	if (E === "spellcheck" || E === "draggable" || E === "translate" || E === "autocorrect" || E === "form" || E === "list" && u.tagName === "INPUT" || E === "type" && u.tagName === "TEXTAREA") return !1;
	if (E === "width" || E === "height") {
		let E = u.tagName;
		if (E === "IMG" || E === "VIDEO" || E === "CANVAS" || E === "SOURCE") return !1;
	}
	return isNativeOn(E) && isString(D) ? !1 : E in u;
}
var REMOVAL = {};
/* @__NO_SIDE_EFFECTS__ */
function defineCustomElement(u, E, D) {
	let O = /* @__PURE__ */ defineComponent(u, E);
	isPlainObject$1(O) && (O = extend({}, O, E));
	class P extends VueElement {
		constructor(u) {
			super(O, u, D);
		}
	}
	return P.def = O, P;
}
var defineSSRCustomElement = ((u, E) => /* @__PURE__ */ defineCustomElement(u, E, createSSRApp)), BaseClass = typeof HTMLElement < "u" ? HTMLElement : class {}, VueElement = class u extends BaseClass {
	constructor(u, E = {}, D = createApp) {
		super(), this._def = u, this._props = E, this._createApp = D, this._isVueCE = !0, this._instance = null, this._app = null, this._nonce = this._def.nonce, this._connected = !1, this._resolved = !1, this._numberProps = null, this._styleChildren = /* @__PURE__ */ new WeakSet(), this._ob = null, this.shadowRoot && D !== createApp ? this._root = this.shadowRoot : u.shadowRoot === !1 ? this._root = this : (this.attachShadow(extend({}, u.shadowRootOptions, { mode: "open" })), this._root = this.shadowRoot);
	}
	connectedCallback() {
		if (!this.isConnected) return;
		!this.shadowRoot && !this._resolved && this._parseSlots(), this._connected = !0;
		let E = this;
		for (; E &&= E.parentNode || E.host;) if (E instanceof u) {
			this._parent = E;
			break;
		}
		this._instance || (this._resolved ? this._mount(this._def) : E && E._pendingResolve ? this._pendingResolve = E._pendingResolve.then(() => {
			this._pendingResolve = void 0, this._resolveDef();
		}) : this._resolveDef());
	}
	_setParent(u = this._parent) {
		u && (this._instance.parent = u._instance, this._inheritParentContext(u));
	}
	_inheritParentContext(u = this._parent) {
		u && this._app && Object.setPrototypeOf(this._app._context.provides, u._instance.provides);
	}
	disconnectedCallback() {
		this._connected = !1, nextTick(() => {
			this._connected || (this._ob &&= (this._ob.disconnect(), null), this._app && this._app.unmount(), this._instance && (this._instance.ce = void 0), this._app = this._instance = null, this._teleportTargets &&= (this._teleportTargets.clear(), void 0));
		});
	}
	_processMutations(u) {
		for (let E of u) this._setAttr(E.attributeName);
	}
	_resolveDef() {
		if (this._pendingResolve) return;
		for (let u = 0; u < this.attributes.length; u++) this._setAttr(this.attributes[u].name);
		this._ob = new MutationObserver(this._processMutations.bind(this)), this._ob.observe(this, { attributes: !0 });
		let u = (u, E = !1) => {
			this._resolved = !0, this._pendingResolve = void 0;
			let { props: D, styles: O } = u, P;
			if (D && !isArray(D)) for (let u in D) {
				let E = D[u];
				(E === Number || E && E.type === Number) && (u in this._props && (this._props[u] = toNumber(this._props[u])), (P ||= /* @__PURE__ */ Object.create(null))[camelize$2(u)] = !0);
			}
			this._numberProps = P, this._resolveProps(u), this.shadowRoot && this._applyStyles(O), this._mount(u);
		}, E = this._def.__asyncLoader;
		E ? this._pendingResolve = E().then((E) => {
			E.configureApp = this._def.configureApp, u(this._def = E, !0);
		}) : u(this._def);
	}
	_mount(u) {
		this._app = this._createApp(u), this._inheritParentContext(), u.configureApp && u.configureApp(this._app), this._app._ceVNode = this._createVNode(), this._app.mount(this._root);
		let E = this._instance && this._instance.exposed;
		if (E) for (let u in E) hasOwn$2(this, u) || Object.defineProperty(this, u, { get: () => unref(E[u]) });
	}
	_resolveProps(u) {
		let { props: E } = u, D = isArray(E) ? E : Object.keys(E || {});
		for (let u of Object.keys(this)) u[0] !== "_" && D.includes(u) && this._setProp(u, this[u]);
		for (let u of D.map(camelize$2)) Object.defineProperty(this, u, {
			get() {
				return this._getProp(u);
			},
			set(E) {
				this._setProp(u, E, !0, !0);
			}
		});
	}
	_setAttr(u) {
		if (u.startsWith("data-v-")) return;
		let E = this.hasAttribute(u), D = E ? this.getAttribute(u) : REMOVAL, O = camelize$2(u);
		E && this._numberProps && this._numberProps[O] && (D = toNumber(D)), this._setProp(O, D, !1, !0);
	}
	_getProp(u) {
		return this._props[u];
	}
	_setProp(u, E, D = !0, O = !1) {
		if (E !== this._props[u] && (E === REMOVAL ? delete this._props[u] : (this._props[u] = E, u === "key" && this._app && (this._app._ceVNode.key = E)), O && this._instance && this._update(), D)) {
			let D = this._ob;
			D && (this._processMutations(D.takeRecords()), D.disconnect()), E === !0 ? this.setAttribute(hyphenate$2(u), "") : typeof E == "string" || typeof E == "number" ? this.setAttribute(hyphenate$2(u), E + "") : E || this.removeAttribute(hyphenate$2(u)), D && D.observe(this, { attributes: !0 });
		}
	}
	_update() {
		let u = this._createVNode();
		this._app && (u.appContext = this._app._context), render(u, this._root);
	}
	_createVNode() {
		let u = {};
		this.shadowRoot || (u.onVnodeMounted = u.onVnodeUpdated = this._renderSlots.bind(this));
		let E = createVNode(this._def, extend(u, this._props));
		return this._instance || (E.ce = (u) => {
			this._instance = u, u.ce = this, u.isCE = !0;
			let E = (u, E) => {
				this.dispatchEvent(new CustomEvent(u, isPlainObject$1(E[0]) ? extend({ detail: E }, E[0]) : { detail: E }));
			};
			u.emit = (u, ...D) => {
				E(u, D), hyphenate$2(u) !== u && E(hyphenate$2(u), D);
			}, this._setParent();
		}), E;
	}
	_applyStyles(u, E) {
		if (!u) return;
		if (E) {
			if (E === this._def || this._styleChildren.has(E)) return;
			this._styleChildren.add(E);
		}
		let D = this._nonce;
		for (let E = u.length - 1; E >= 0; E--) {
			let O = document.createElement("style");
			D && O.setAttribute("nonce", D), O.textContent = u[E], this.shadowRoot.prepend(O);
		}
	}
	_parseSlots() {
		let u = this._slots = {}, E;
		for (; E = this.firstChild;) {
			let D = E.nodeType === 1 && E.getAttribute("slot") || "default";
			(u[D] || (u[D] = [])).push(E), this.removeChild(E);
		}
	}
	_renderSlots() {
		let u = this._getSlots(), E = this._instance.type.__scopeId;
		for (let D = 0; D < u.length; D++) {
			let O = u[D], P = O.getAttribute("name") || "default", F = this._slots[P], I = O.parentNode;
			if (F) for (let u of F) {
				if (E && u.nodeType === 1) {
					let D = E + "-s", O = document.createTreeWalker(u, 1);
					u.setAttribute(D, "");
					let P;
					for (; P = O.nextNode();) P.setAttribute(D, "");
				}
				I.insertBefore(u, O);
			}
			else for (; O.firstChild;) I.insertBefore(O.firstChild, O);
			I.removeChild(O);
		}
	}
	_getSlots() {
		let u = [this];
		return this._teleportTargets && u.push(...this._teleportTargets), u.reduce((u, E) => (u.push(...Array.from(E.querySelectorAll("slot"))), u), []);
	}
	_injectChildStyle(u) {
		this._applyStyles(u.styles, u);
	}
	_removeChildStyle(u) {}
};
function useHost(u) {
	let E = getCurrentInstance();
	return E && E.ce || null;
}
function useShadowRoot() {
	let u = useHost();
	return u && u.shadowRoot;
}
function useCssModule(u = "$style") {
	{
		let E = getCurrentInstance();
		if (!E) return EMPTY_OBJ;
		let D = E.type.__cssModules;
		return D && D[u] || EMPTY_OBJ;
	}
}
var positionMap = /* @__PURE__ */ new WeakMap(), newPositionMap = /* @__PURE__ */ new WeakMap(), moveCbKey = Symbol("_moveCb"), enterCbKey = Symbol("_enterCb"), TransitionGroup = /* @__PURE__ */ ((u) => (delete u.props.mode, u))({
	name: "TransitionGroup",
	props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
		tag: String,
		moveClass: String
	}),
	setup(u, { slots: E }) {
		let D = getCurrentInstance(), O = useTransitionState(), P, F;
		return onUpdated(() => {
			if (!P.length) return;
			let E = u.moveClass || `${u.name || "v"}-move`;
			if (!hasCSSTransform(P[0].el, D.vnode.el, E)) {
				P = [];
				return;
			}
			P.forEach(callPendingCbs), P.forEach(recordPosition);
			let O = P.filter(applyTranslation);
			forceReflow(D.vnode.el), O.forEach((u) => {
				let D = u.el, O = D.style;
				addTransitionClass(D, E), O.transform = O.webkitTransform = O.transitionDuration = "";
				let P = D[moveCbKey] = (u) => {
					u && u.target !== D || (!u || u.propertyName.endsWith("transform")) && (D.removeEventListener("transitionend", P), D[moveCbKey] = null, removeTransitionClass(D, E));
				};
				D.addEventListener("transitionend", P);
			}), P = [];
		}), () => {
			let I = toRaw(u), R = resolveTransitionProps(I), U = I.tag || Fragment;
			if (P = [], F) for (let u = 0; u < F.length; u++) {
				let E = F[u];
				E.el && E.el instanceof Element && (P.push(E), setTransitionHooks(E, resolveTransitionHooks(E, R, O, D)), positionMap.set(E, E.el.getBoundingClientRect()));
			}
			F = E.default ? getTransitionRawChildren(E.default()) : [];
			for (let u = 0; u < F.length; u++) {
				let E = F[u];
				E.key != null && setTransitionHooks(E, resolveTransitionHooks(E, R, O, D));
			}
			return createVNode(U, null, F);
		};
	}
});
function callPendingCbs(u) {
	let E = u.el;
	E[moveCbKey] && E[moveCbKey](), E[enterCbKey] && E[enterCbKey]();
}
function recordPosition(u) {
	newPositionMap.set(u, u.el.getBoundingClientRect());
}
function applyTranslation(u) {
	let E = positionMap.get(u), D = newPositionMap.get(u), O = E.left - D.left, P = E.top - D.top;
	if (O || P) {
		let E = u.el.style;
		return E.transform = E.webkitTransform = `translate(${O}px,${P}px)`, E.transitionDuration = "0s", u;
	}
}
function hasCSSTransform(u, E, D) {
	let O = u.cloneNode(), P = u[vtcKey];
	P && P.forEach((u) => {
		u.split(/\s+/).forEach((u) => u && O.classList.remove(u));
	}), D.split(/\s+/).forEach((u) => u && O.classList.add(u)), O.style.display = "none";
	let F = E.nodeType === 1 ? E : E.parentNode;
	F.appendChild(O);
	let { hasTransform: I } = getTransitionInfo(O);
	return F.removeChild(O), I;
}
var getModelAssigner = (u) => {
	let E = u.props["onUpdate:modelValue"] || !1;
	return isArray(E) ? (u) => invokeArrayFns(E, u) : E;
};
function onCompositionStart(u) {
	u.target.composing = !0;
}
function onCompositionEnd(u) {
	let E = u.target;
	E.composing && (E.composing = !1, E.dispatchEvent(new Event("input")));
}
var assignKey = Symbol("_assign"), vModelText = {
	created(u, { modifiers: { lazy: E, trim: D, number: O } }, P) {
		u[assignKey] = getModelAssigner(P);
		let F = O || P.props && P.props.type === "number";
		addEventListener$1(u, E ? "change" : "input", (E) => {
			if (E.target.composing) return;
			let O = u.value;
			D && (O = O.trim()), F && (O = looseToNumber(O)), u[assignKey](O);
		}), D && addEventListener$1(u, "change", () => {
			u.value = u.value.trim();
		}), E || (addEventListener$1(u, "compositionstart", onCompositionStart), addEventListener$1(u, "compositionend", onCompositionEnd), addEventListener$1(u, "change", onCompositionEnd));
	},
	mounted(u, { value: E }) {
		u.value = E ?? "";
	},
	beforeUpdate(u, { value: E, oldValue: D, modifiers: { lazy: O, trim: P, number: F } }, I) {
		if (u[assignKey] = getModelAssigner(I), u.composing) return;
		let R = (F || u.type === "number") && !/^0\d/.test(u.value) ? looseToNumber(u.value) : u.value, U = E ?? "";
		R !== U && (document.activeElement === u && u.type !== "range" && (O && E === D || P && u.value.trim() === U) || (u.value = U));
	}
}, vModelCheckbox = {
	deep: !0,
	created(u, E, D) {
		u[assignKey] = getModelAssigner(D), addEventListener$1(u, "change", () => {
			let E = u._modelValue, D = getValue(u), O = u.checked, P = u[assignKey];
			if (isArray(E)) {
				let u = looseIndexOf(E, D), F = u !== -1;
				if (O && !F) P(E.concat(D));
				else if (!O && F) {
					let D = [...E];
					D.splice(u, 1), P(D);
				}
			} else if (isSet(E)) {
				let u = new Set(E);
				O ? u.add(D) : u.delete(D), P(u);
			} else P(getCheckboxValue(u, O));
		});
	},
	mounted: setChecked,
	beforeUpdate(u, E, D) {
		u[assignKey] = getModelAssigner(D), setChecked(u, E, D);
	}
};
function setChecked(u, { value: E, oldValue: D }, O) {
	u._modelValue = E;
	let P;
	if (isArray(E)) P = looseIndexOf(E, O.props.value) > -1;
	else if (isSet(E)) P = E.has(O.props.value);
	else {
		if (E === D) return;
		P = looseEqual(E, getCheckboxValue(u, !0));
	}
	u.checked !== P && (u.checked = P);
}
var vModelRadio = {
	created(u, { value: E }, D) {
		u.checked = looseEqual(E, D.props.value), u[assignKey] = getModelAssigner(D), addEventListener$1(u, "change", () => {
			u[assignKey](getValue(u));
		});
	},
	beforeUpdate(u, { value: E, oldValue: D }, O) {
		u[assignKey] = getModelAssigner(O), E !== D && (u.checked = looseEqual(E, O.props.value));
	}
}, vModelSelect = {
	deep: !0,
	created(u, { value: E, modifiers: { number: D } }, O) {
		let P = isSet(E);
		addEventListener$1(u, "change", () => {
			let E = Array.prototype.filter.call(u.options, (u) => u.selected).map((u) => D ? looseToNumber(getValue(u)) : getValue(u));
			u[assignKey](u.multiple ? P ? new Set(E) : E : E[0]), u._assigning = !0, nextTick(() => {
				u._assigning = !1;
			});
		}), u[assignKey] = getModelAssigner(O);
	},
	mounted(u, { value: E }) {
		setSelected(u, E);
	},
	beforeUpdate(u, E, D) {
		u[assignKey] = getModelAssigner(D);
	},
	updated(u, { value: E }) {
		u._assigning || setSelected(u, E);
	}
};
function setSelected(u, E) {
	let D = u.multiple, O = isArray(E);
	if (!(D && !O && !isSet(E))) {
		for (let P = 0, F = u.options.length; P < F; P++) {
			let F = u.options[P], I = getValue(F);
			if (D) if (O) {
				let u = typeof I;
				u === "string" || u === "number" ? F.selected = E.some((u) => String(u) === String(I)) : F.selected = looseIndexOf(E, I) > -1;
			} else F.selected = E.has(I);
			else if (looseEqual(getValue(F), E)) {
				u.selectedIndex !== P && (u.selectedIndex = P);
				return;
			}
		}
		!D && u.selectedIndex !== -1 && (u.selectedIndex = -1);
	}
}
function getValue(u) {
	return "_value" in u ? u._value : u.value;
}
function getCheckboxValue(u, E) {
	let D = E ? "_trueValue" : "_falseValue";
	return D in u ? u[D] : E;
}
var vModelDynamic = {
	created(u, E, D) {
		callModelHook(u, E, D, null, "created");
	},
	mounted(u, E, D) {
		callModelHook(u, E, D, null, "mounted");
	},
	beforeUpdate(u, E, D, O) {
		callModelHook(u, E, D, O, "beforeUpdate");
	},
	updated(u, E, D, O) {
		callModelHook(u, E, D, O, "updated");
	}
};
function resolveDynamicModel(u, E) {
	switch (u) {
		case "SELECT": return vModelSelect;
		case "TEXTAREA": return vModelText;
		default: switch (E) {
			case "checkbox": return vModelCheckbox;
			case "radio": return vModelRadio;
			default: return vModelText;
		}
	}
}
function callModelHook(u, E, D, O, P) {
	let F = resolveDynamicModel(u.tagName, D.props && D.props.type)[P];
	F && F(u, E, D, O);
}
function initVModelForSSR() {
	vModelText.getSSRProps = ({ value: u }) => ({ value: u }), vModelRadio.getSSRProps = ({ value: u }, E) => {
		if (E.props && looseEqual(E.props.value, u)) return { checked: !0 };
	}, vModelCheckbox.getSSRProps = ({ value: u }, E) => {
		if (isArray(u)) {
			if (E.props && looseIndexOf(u, E.props.value) > -1) return { checked: !0 };
		} else if (isSet(u)) {
			if (E.props && u.has(E.props.value)) return { checked: !0 };
		} else if (u) return { checked: !0 };
	}, vModelDynamic.getSSRProps = (u, E) => {
		if (typeof E.type != "string") return;
		let D = resolveDynamicModel(E.type.toUpperCase(), E.props && E.props.type);
		if (D.getSSRProps) return D.getSSRProps(u, E);
	};
}
var systemModifiers = [
	"ctrl",
	"shift",
	"alt",
	"meta"
], modifierGuards = {
	stop: (u) => u.stopPropagation(),
	prevent: (u) => u.preventDefault(),
	self: (u) => u.target !== u.currentTarget,
	ctrl: (u) => !u.ctrlKey,
	shift: (u) => !u.shiftKey,
	alt: (u) => !u.altKey,
	meta: (u) => !u.metaKey,
	left: (u) => "button" in u && u.button !== 0,
	middle: (u) => "button" in u && u.button !== 1,
	right: (u) => "button" in u && u.button !== 2,
	exact: (u, E) => systemModifiers.some((D) => u[`${D}Key`] && !E.includes(D))
}, withModifiers = (u, E) => {
	let D = u._withMods ||= {}, O = E.join(".");
	return D[O] || (D[O] = ((D, ...O) => {
		for (let u = 0; u < E.length; u++) {
			let O = modifierGuards[E[u]];
			if (O && O(D, E)) return;
		}
		return u(D, ...O);
	}));
}, keyNames = {
	esc: "escape",
	space: " ",
	up: "arrow-up",
	left: "arrow-left",
	right: "arrow-right",
	down: "arrow-down",
	delete: "backspace"
}, withKeys = (u, E) => {
	let D = u._withKeys ||= {}, O = E.join(".");
	return D[O] || (D[O] = ((D) => {
		if (!("key" in D)) return;
		let O = hyphenate$2(D.key);
		if (E.some((u) => u === O || keyNames[u] === O)) return u(D);
	}));
}, rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps), renderer, enabledHydration = !1;
function ensureRenderer() {
	return renderer ||= createRenderer(rendererOptions);
}
function ensureHydrationRenderer() {
	return renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions), enabledHydration = !0, renderer;
}
var render = ((...u) => {
	ensureRenderer().render(...u);
}), hydrate = ((...u) => {
	ensureHydrationRenderer().hydrate(...u);
}), createApp = ((...u) => {
	let E = ensureRenderer().createApp(...u), { mount: D } = E;
	return E.mount = (u) => {
		let O = normalizeContainer(u);
		if (!O) return;
		let P = E._component;
		!isFunction(P) && !P.render && !P.template && (P.template = O.innerHTML), O.nodeType === 1 && (O.textContent = "");
		let F = D(O, !1, resolveRootNamespace(O));
		return O instanceof Element && (O.removeAttribute("v-cloak"), O.setAttribute("data-v-app", "")), F;
	}, E;
}), createSSRApp = ((...u) => {
	let E = ensureHydrationRenderer().createApp(...u), { mount: D } = E;
	return E.mount = (u) => {
		let E = normalizeContainer(u);
		if (E) return D(E, !0, resolveRootNamespace(E));
	}, E;
});
function resolveRootNamespace(u) {
	if (u instanceof SVGElement) return "svg";
	if (typeof MathMLElement == "function" && u instanceof MathMLElement) return "mathml";
}
function normalizeContainer(u) {
	return isString(u) ? document.querySelector(u) : u;
}
var ssrDirectiveInitialized = !1, initDirectivesForSSR = () => {
	ssrDirectiveInitialized || (ssrDirectiveInitialized = !0, initVModelForSSR(), initVShowForSSR());
}, vue_runtime_esm_bundler_exports = /* @__PURE__ */ __export({
	BaseTransition: () => BaseTransition,
	BaseTransitionPropsValidators: () => BaseTransitionPropsValidators,
	Comment: () => Comment,
	DeprecationTypes: () => null,
	EffectScope: () => EffectScope,
	ErrorCodes: () => ErrorCodes,
	ErrorTypeStrings: () => ErrorTypeStrings,
	Fragment: () => Fragment,
	KeepAlive: () => KeepAlive,
	ReactiveEffect: () => ReactiveEffect,
	Static: () => Static,
	Suspense: () => Suspense,
	Teleport: () => Teleport,
	Text: () => Text,
	TrackOpTypes: () => TrackOpTypes,
	Transition: () => Transition,
	TransitionGroup: () => TransitionGroup,
	TriggerOpTypes: () => TriggerOpTypes,
	VueElement: () => VueElement,
	assertNumber: () => assertNumber,
	callWithAsyncErrorHandling: () => callWithAsyncErrorHandling,
	callWithErrorHandling: () => callWithErrorHandling,
	camelize: () => camelize$2,
	capitalize: () => capitalize,
	cloneVNode: () => cloneVNode,
	compatUtils: () => null,
	compile: () => compile,
	computed: () => computed,
	createApp: () => createApp,
	createBlock: () => createBlock,
	createCommentVNode: () => createCommentVNode,
	createElementBlock: () => createElementBlock,
	createElementVNode: () => createBaseVNode,
	createHydrationRenderer: () => createHydrationRenderer,
	createPropsRestProxy: () => createPropsRestProxy,
	createRenderer: () => createRenderer,
	createSSRApp: () => createSSRApp,
	createSlots: () => createSlots,
	createStaticVNode: () => createStaticVNode,
	createTextVNode: () => createTextVNode,
	createVNode: () => createVNode,
	customRef: () => customRef,
	defineAsyncComponent: () => defineAsyncComponent,
	defineComponent: () => defineComponent,
	defineCustomElement: () => defineCustomElement,
	defineEmits: () => defineEmits,
	defineExpose: () => defineExpose,
	defineModel: () => defineModel,
	defineOptions: () => defineOptions,
	defineProps: () => defineProps,
	defineSSRCustomElement: () => defineSSRCustomElement,
	defineSlots: () => defineSlots,
	devtools: () => devtools,
	effect: () => effect,
	effectScope: () => effectScope,
	getCurrentInstance: () => getCurrentInstance,
	getCurrentScope: () => getCurrentScope,
	getCurrentWatcher: () => getCurrentWatcher,
	getTransitionRawChildren: () => getTransitionRawChildren,
	guardReactiveProps: () => guardReactiveProps,
	h: () => h$5,
	handleError: () => handleError,
	hasInjectionContext: () => hasInjectionContext,
	hydrate: () => hydrate,
	hydrateOnIdle: () => hydrateOnIdle,
	hydrateOnInteraction: () => hydrateOnInteraction,
	hydrateOnMediaQuery: () => hydrateOnMediaQuery,
	hydrateOnVisible: () => hydrateOnVisible,
	initCustomFormatter: () => initCustomFormatter,
	initDirectivesForSSR: () => initDirectivesForSSR,
	inject: () => inject,
	isMemoSame: () => isMemoSame,
	isProxy: () => isProxy,
	isReactive: () => isReactive,
	isReadonly: () => isReadonly,
	isRef: () => isRef,
	isRuntimeOnly: () => isRuntimeOnly,
	isShallow: () => isShallow,
	isVNode: () => isVNode,
	markRaw: () => markRaw,
	mergeDefaults: () => mergeDefaults,
	mergeModels: () => mergeModels,
	mergeProps: () => mergeProps,
	nextTick: () => nextTick,
	normalizeClass: () => normalizeClass,
	normalizeProps: () => normalizeProps,
	normalizeStyle: () => normalizeStyle,
	onActivated: () => onActivated,
	onBeforeMount: () => onBeforeMount,
	onBeforeUnmount: () => onBeforeUnmount,
	onBeforeUpdate: () => onBeforeUpdate,
	onDeactivated: () => onDeactivated,
	onErrorCaptured: () => onErrorCaptured,
	onMounted: () => onMounted,
	onRenderTracked: () => onRenderTracked,
	onRenderTriggered: () => onRenderTriggered,
	onScopeDispose: () => onScopeDispose,
	onServerPrefetch: () => onServerPrefetch,
	onUnmounted: () => onUnmounted,
	onUpdated: () => onUpdated,
	onWatcherCleanup: () => onWatcherCleanup,
	openBlock: () => openBlock,
	popScopeId: () => popScopeId,
	provide: () => provide,
	proxyRefs: () => proxyRefs,
	pushScopeId: () => pushScopeId,
	queuePostFlushCb: () => queuePostFlushCb,
	reactive: () => reactive,
	readonly: () => readonly,
	ref: () => ref,
	registerRuntimeCompiler: () => registerRuntimeCompiler,
	render: () => render,
	renderList: () => renderList,
	renderSlot: () => renderSlot,
	resolveComponent: () => resolveComponent,
	resolveDirective: () => resolveDirective,
	resolveDynamicComponent: () => resolveDynamicComponent,
	resolveFilter: () => null,
	resolveTransitionHooks: () => resolveTransitionHooks,
	setBlockTracking: () => setBlockTracking,
	setDevtoolsHook: () => setDevtoolsHook,
	setTransitionHooks: () => setTransitionHooks,
	shallowReactive: () => shallowReactive,
	shallowReadonly: () => shallowReadonly,
	shallowRef: () => shallowRef,
	ssrContextKey: () => ssrContextKey,
	ssrUtils: () => ssrUtils,
	stop: () => stop,
	toDisplayString: () => toDisplayString,
	toHandlerKey: () => toHandlerKey,
	toHandlers: () => toHandlers,
	toRaw: () => toRaw,
	toRef: () => toRef,
	toRefs: () => toRefs,
	toValue: () => toValue,
	transformVNodeArgs: () => transformVNodeArgs,
	triggerRef: () => triggerRef,
	unref: () => unref,
	useAttrs: () => useAttrs,
	useCssModule: () => useCssModule,
	useCssVars: () => useCssVars,
	useHost: () => useHost,
	useId: () => useId$1,
	useModel: () => useModel,
	useSSRContext: () => useSSRContext,
	useShadowRoot: () => useShadowRoot,
	useSlots: () => useSlots,
	useTemplateRef: () => useTemplateRef,
	useTransitionState: () => useTransitionState,
	vModelCheckbox: () => vModelCheckbox,
	vModelDynamic: () => vModelDynamic,
	vModelRadio: () => vModelRadio,
	vModelSelect: () => vModelSelect,
	vModelText: () => vModelText,
	vShow: () => vShow,
	version: () => version,
	warn: () => warn,
	watch: () => watch,
	watchEffect: () => watchEffect,
	watchPostEffect: () => watchPostEffect,
	watchSyncEffect: () => watchSyncEffect,
	withAsyncContext: () => withAsyncContext,
	withCtx: () => withCtx,
	withDefaults: () => withDefaults,
	withDirectives: () => withDirectives,
	withKeys: () => withKeys,
	withMemo: () => withMemo,
	withModifiers: () => withModifiers,
	withScopeId: () => withScopeId
}), compile = () => {}, activePinia, setActivePinia = (u) => activePinia = u, piniaSymbol = Symbol();
function isPlainObject(u) {
	return u && typeof u == "object" && Object.prototype.toString.call(u) === "[object Object]" && typeof u.toJSON != "function";
}
var MutationType;
(function(u) {
	u.direct = "direct", u.patchObject = "patch object", u.patchFunction = "patch function";
})(MutationType ||= {});
var IS_CLIENT = typeof window < "u", _global = /* @__PURE__ */ (() => typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : { HTMLElement: null })();
function bom(u, { autoBom: E = !1 } = {}) {
	return E && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(u.type) ? new Blob(["", u], { type: u.type }) : u;
}
function download(u, E, D) {
	let O = new XMLHttpRequest();
	O.open("GET", u), O.responseType = "blob", O.onload = function() {
		saveAs(O.response, E, D);
	}, O.onerror = function() {
		console.error("could not download file");
	}, O.send();
}
function corsEnabled(u) {
	let E = new XMLHttpRequest();
	E.open("HEAD", u, !1);
	try {
		E.send();
	} catch {}
	return E.status >= 200 && E.status <= 299;
}
function click(u) {
	try {
		u.dispatchEvent(new MouseEvent("click"));
	} catch {
		let E = new MouseEvent("click", {
			bubbles: !0,
			cancelable: !0,
			view: window,
			detail: 0,
			screenX: 80,
			screenY: 20,
			clientX: 80,
			clientY: 20,
			ctrlKey: !1,
			altKey: !1,
			shiftKey: !1,
			metaKey: !1,
			button: 0,
			relatedTarget: null
		});
		u.dispatchEvent(E);
	}
}
var _navigator = typeof navigator == "object" ? navigator : { userAgent: "" }, isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))(), saveAs = IS_CLIENT ? typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : "msSaveOrOpenBlob" in _navigator ? msSaveAs : fileSaverSaveAs : () => {};
function downloadSaveAs(u, E = "download", D) {
	let O = document.createElement("a");
	O.download = E, O.rel = "noopener", typeof u == "string" ? (O.href = u, O.origin === location.origin ? click(O) : corsEnabled(O.href) ? download(u, E, D) : (O.target = "_blank", click(O))) : (O.href = URL.createObjectURL(u), setTimeout(function() {
		URL.revokeObjectURL(O.href);
	}, 4e4), setTimeout(function() {
		click(O);
	}, 0));
}
function msSaveAs(u, E = "download", D) {
	if (typeof u == "string") if (corsEnabled(u)) download(u, E, D);
	else {
		let E = document.createElement("a");
		E.href = u, E.target = "_blank", setTimeout(function() {
			click(E);
		});
	}
	else navigator.msSaveOrOpenBlob(bom(u, D), E);
}
function fileSaverSaveAs(u, E, D, O) {
	if (O ||= open("", "_blank"), O && (O.document.title = O.document.body.innerText = "downloading..."), typeof u == "string") return download(u, E, D);
	let P = u.type === "application/octet-stream", F = /constructor/i.test(String(_global.HTMLElement)) || "safari" in _global, I = /CriOS\/[\d]+/.test(navigator.userAgent);
	if ((I || P && F || isMacOSWebView) && typeof FileReader < "u") {
		let E = new FileReader();
		E.onloadend = function() {
			let u = E.result;
			if (typeof u != "string") throw O = null, Error("Wrong reader.result type");
			u = I ? u : u.replace(/^data:[^;]*;/, "data:attachment/file;"), O ? O.location.href = u : location.assign(u), O = null;
		}, E.readAsDataURL(u);
	} else {
		let E = URL.createObjectURL(u);
		O ? O.location.assign(E) : location.href = E, O = null, setTimeout(function() {
			URL.revokeObjectURL(E);
		}, 4e4);
	}
}
var { assign: assign$1 } = Object;
function createPinia() {
	let u = effectScope(!0), E = u.run(() => ref({})), D = [], O = [], P = markRaw({
		install(u) {
			setActivePinia(P), P._a = u, u.provide(piniaSymbol, P), u.config.globalProperties.$pinia = P, O.forEach((u) => D.push(u)), O = [];
		},
		use(u) {
			return this._a ? D.push(u) : O.push(u), this;
		},
		_p: D,
		_a: null,
		_e: u,
		_s: /* @__PURE__ */ new Map(),
		state: E
	});
	return P;
}
var noop$2 = () => {};
function addSubscription(u, E, D, O = noop$2) {
	u.push(E);
	let P = () => {
		let D = u.indexOf(E);
		D > -1 && (u.splice(D, 1), O());
	};
	return !D && getCurrentScope() && onScopeDispose(P), P;
}
function triggerSubscriptions(u, ...E) {
	u.slice().forEach((u) => {
		u(...E);
	});
}
var fallbackRunWithContext = (u) => u(), ACTION_MARKER = Symbol(), ACTION_NAME = Symbol();
function mergeReactiveObjects(u, E) {
	for (let D in u instanceof Map && E instanceof Map ? E.forEach((E, D) => u.set(D, E)) : u instanceof Set && E instanceof Set && E.forEach(u.add, u), E) {
		if (!E.hasOwnProperty(D)) continue;
		let O = E[D], P = u[D];
		isPlainObject(P) && isPlainObject(O) && u.hasOwnProperty(D) && !isRef(O) && !isReactive(O) ? u[D] = mergeReactiveObjects(P, O) : u[D] = O;
	}
	return u;
}
var skipHydrateSymbol = Symbol();
function shouldHydrate(u) {
	return !isPlainObject(u) || !Object.prototype.hasOwnProperty.call(u, skipHydrateSymbol);
}
var { assign } = Object;
function isComputed(u) {
	return !!(isRef(u) && u.effect);
}
function createOptionsStore(u, E, D, O) {
	let { state: P, actions: F, getters: I } = E, R = D.state.value[u], U;
	function J() {
		return R || (D.state.value[u] = P ? P() : {}), assign(toRefs(D.state.value[u]), F, Object.keys(I || {}).reduce((E, O) => (E[O] = markRaw(computed(() => {
			setActivePinia(D);
			let E = D._s.get(u);
			return I[O].call(E, E);
		})), E), {}));
	}
	return U = createSetupStore(u, J, E, D, O, !0), U;
}
function createSetupStore(u, E, D = {}, O, P, F) {
	let I, R = assign({ actions: {} }, D), U = { deep: !0 }, J, _p, vp = [], yp = [], bp = O.state.value[u];
	!F && !bp && (O.state.value[u] = {}), ref({});
	let xp;
	function Sp(E) {
		let D;
		J = _p = !1, typeof E == "function" ? (E(O.state.value[u]), D = {
			type: MutationType.patchFunction,
			storeId: u,
			events: void 0
		}) : (mergeReactiveObjects(O.state.value[u], E), D = {
			type: MutationType.patchObject,
			payload: E,
			storeId: u,
			events: void 0
		});
		let P = xp = Symbol();
		nextTick().then(() => {
			xp === P && (J = !0);
		}), _p = !0, triggerSubscriptions(vp, D, O.state.value[u]);
	}
	let Cp = F ? function() {
		let { state: u } = D, E = u ? u() : {};
		this.$patch((u) => {
			assign(u, E);
		});
	} : noop$2;
	function wp() {
		I.stop(), vp = [], yp = [], O._s.delete(u);
	}
	let Tp = (E, D = "") => {
		if (ACTION_MARKER in E) return E[ACTION_NAME] = D, E;
		let P = function() {
			setActivePinia(O);
			let D = Array.from(arguments), F = [], I = [];
			function R(u) {
				F.push(u);
			}
			function U(u) {
				I.push(u);
			}
			triggerSubscriptions(yp, {
				args: D,
				name: P[ACTION_NAME],
				store: Ep,
				after: R,
				onError: U
			});
			let J;
			try {
				J = E.apply(this && this.$id === u ? this : Ep, D);
			} catch (u) {
				throw triggerSubscriptions(I, u), u;
			}
			return J instanceof Promise ? J.then((u) => (triggerSubscriptions(F, u), u)).catch((u) => (triggerSubscriptions(I, u), Promise.reject(u))) : (triggerSubscriptions(F, J), J);
		};
		return P[ACTION_MARKER] = !0, P[ACTION_NAME] = D, P;
	}, Ep = reactive({
		_p: O,
		$id: u,
		$onAction: addSubscription.bind(null, yp),
		$patch: Sp,
		$reset: Cp,
		$subscribe(E, D = {}) {
			let P = addSubscription(vp, E, D.detached, () => F()), F = I.run(() => watch(() => O.state.value[u], (O) => {
				(D.flush === "sync" ? _p : J) && E({
					storeId: u,
					type: MutationType.direct,
					events: void 0
				}, O);
			}, assign({}, U, D)));
			return P;
		},
		$dispose: wp
	});
	O._s.set(u, Ep);
	let Dp = (O._a && O._a.runWithContext || fallbackRunWithContext)(() => O._e.run(() => (I = effectScope()).run(() => E({ action: Tp }))));
	for (let E in Dp) {
		let D = Dp[E];
		isRef(D) && !isComputed(D) || isReactive(D) ? F || (bp && shouldHydrate(D) && (isRef(D) ? D.value = bp[E] : mergeReactiveObjects(D, bp[E])), O.state.value[u][E] = D) : typeof D == "function" && (Dp[E] = Tp(D, E), R.actions[E] = D);
	}
	return assign(Ep, Dp), assign(toRaw(Ep), Dp), Object.defineProperty(Ep, "$state", {
		get: () => O.state.value[u],
		set: (u) => {
			Sp((E) => {
				assign(E, u);
			});
		}
	}), O._p.forEach((u) => {
		assign(Ep, I.run(() => u({
			store: Ep,
			app: O._a,
			pinia: O,
			options: R
		})));
	}), bp && F && D.hydrate && D.hydrate(Ep.$state, bp), J = !0, _p = !0, Ep;
}
/*! #__NO_SIDE_EFFECTS__ */
function defineStore(u, E, D) {
	let O, P = typeof E == "function";
	O = P ? D : E;
	function F(D, F) {
		let I = hasInjectionContext();
		return D ||= I ? inject(piniaSymbol, null) : null, D && setActivePinia(D), D = activePinia, D._s.has(u) || (P ? createSetupStore(u, E, O, D) : createOptionsStore(u, O, D)), D._s.get(u);
	}
	return F.$id = u, F;
}
function storeToRefs(u) {
	let E = toRaw(u), D = {};
	for (let O in E) {
		let P = E[O];
		P.effect ? D[O] = computed({
			get: () => u[O],
			set(E) {
				u[O] = E;
			}
		}) : (isRef(P) || isReactive(P)) && (D[O] = toRef(u, O));
	}
	return D;
}
var iu = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function au(u) {
	return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
}
var _l = { exports: {} }, ru = _l.exports, xt;
function su() {
	return xt || (xt = 1, function(u, E) {
		(function(E, D) {
			u.exports = D();
		})(ru, function() {
			var u = function(E, D) {
				return (u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(u, E) {
					u.__proto__ = E;
				} || function(u, E) {
					for (var D in E) Object.prototype.hasOwnProperty.call(E, D) && (u[D] = E[D]);
				})(E, D);
			}, E = function() {
				return (E = Object.assign || function(u) {
					for (var E, D = 1, O = arguments.length; D < O; D++) for (var P in E = arguments[D]) Object.prototype.hasOwnProperty.call(E, P) && (u[P] = E[P]);
					return u;
				}).apply(this, arguments);
			};
			function D(u, E, D) {
				for (var O, P = 0, F = E.length; P < F; P++) !O && P in E || ((O ||= Array.prototype.slice.call(E, 0, P))[P] = E[P]);
				return u.concat(O || Array.prototype.slice.call(E));
			}
			var O = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : iu, P = Object.keys, F = Array.isArray;
			function I(u, E) {
				return typeof E != "object" || P(E).forEach(function(D) {
					u[D] = E[D];
				}), u;
			}
			typeof Promise > "u" || O.Promise || (O.Promise = Promise);
			var R = Object.getPrototypeOf, U = {}.hasOwnProperty;
			function J(u, E) {
				return U.call(u, E);
			}
			function _p(u, E) {
				typeof E == "function" && (E = E(R(u))), (typeof Reflect > "u" ? P : Reflect.ownKeys)(E).forEach(function(D) {
					yp(u, D, E[D]);
				});
			}
			var vp = Object.defineProperty;
			function yp(u, E, D, O) {
				vp(u, E, I(D && J(D, "get") && typeof D.get == "function" ? {
					get: D.get,
					set: D.set,
					configurable: !0
				} : {
					value: D,
					configurable: !0,
					writable: !0
				}, O));
			}
			function bp(u) {
				return { from: function(E) {
					return u.prototype = Object.create(E.prototype), yp(u.prototype, "constructor", u), { extend: _p.bind(null, u.prototype) };
				} };
			}
			var xp = Object.getOwnPropertyDescriptor, Sp = [].slice;
			function Cp(u, E, D) {
				return Sp.call(u, E, D);
			}
			function wp(u, E) {
				return E(u);
			}
			function Tp(u) {
				if (!u) throw Error("Assertion Failed");
			}
			function Ep(u) {
				O.setImmediate ? setImmediate(u) : setTimeout(u, 0);
			}
			function Dp(u, E) {
				if (typeof E == "string" && J(u, E)) return u[E];
				if (!E) return u;
				if (typeof E != "string") {
					for (var D = [], O = 0, P = E.length; O < P; ++O) {
						var F = Dp(u, E[O]);
						D.push(F);
					}
					return D;
				}
				var I = E.indexOf(".");
				if (I !== -1) {
					var R = u[E.substr(0, I)];
					return R == null ? void 0 : Dp(R, E.substr(I + 1));
				}
			}
			function Op(u, E, D) {
				if (u && E !== void 0 && !("isFrozen" in Object && Object.isFrozen(u))) if (typeof E != "string" && "length" in E) {
					Tp(typeof D != "string" && "length" in D);
					for (var O = 0, P = E.length; O < P; ++O) Op(u, E[O], D[O]);
				} else {
					var I, R, U = E.indexOf(".");
					U === -1 ? D === void 0 ? F(u) && !isNaN(parseInt(E)) ? u.splice(E, 1) : delete u[E] : u[E] = D : (I = E.substr(0, U), (R = E.substr(U + 1)) === "" ? D === void 0 ? F(u) && !isNaN(parseInt(I)) ? u.splice(I, 1) : delete u[I] : u[I] = D : Op(U = !(U = u[I]) || !J(u, I) ? u[I] = {} : U, R, D));
				}
			}
			function kp(u) {
				var E, D = {};
				for (E in u) J(u, E) && (D[E] = u[E]);
				return D;
			}
			var Ap = [].concat;
			function jp(u) {
				return Ap.apply([], u);
			}
			var Mp = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(jp([
				8,
				16,
				32,
				64
			].map(function(u) {
				return [
					"Int",
					"Uint",
					"Float"
				].map(function(E) {
					return E + u + "Array";
				});
			}))).filter(function(u) {
				return O[u];
			}), Np = new Set(Mp.map(function(u) {
				return O[u];
			})), Pp = null;
			function Fp(u) {
				return Pp = /* @__PURE__ */ new WeakMap(), u = function u(E) {
					if (!E || typeof E != "object") return E;
					var D = Pp.get(E);
					if (D) return D;
					if (F(E)) {
						D = [], Pp.set(E, D);
						for (var O = 0, P = E.length; O < P; ++O) D.push(u(E[O]));
					} else if (Np.has(E.constructor)) D = E;
					else {
						var I, U = R(E);
						for (I in D = U === Object.prototype ? {} : Object.create(U), Pp.set(E, D), E) J(E, I) && (D[I] = u(E[I]));
					}
					return D;
				}(u), Pp = null, u;
			}
			var Ip = {}.toString;
			function Lp(u) {
				return Ip.call(u).slice(8, -1);
			}
			var Rp = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", zp = typeof Rp == "symbol" ? function(u) {
				var E;
				return u != null && (E = u[Rp]) && E.apply(u);
			} : function() {
				return null;
			};
			function Bp(u, E) {
				return E = u.indexOf(E), 0 <= E && u.splice(E, 1), 0 <= E;
			}
			var Vp = {};
			function Hp(u) {
				var E, D, O, P;
				if (arguments.length === 1) {
					if (F(u)) return u.slice();
					if (this === Vp && typeof u == "string") return [u];
					if (P = zp(u)) {
						for (D = []; !(O = P.next()).done;) D.push(O.value);
						return D;
					}
					if (u == null || typeof (E = u.length) != "number") return [u];
					for (D = Array(E); E--;) D[E] = u[E];
					return D;
				}
				for (E = arguments.length, D = Array(E); E--;) D[E] = arguments[E];
				return D;
			}
			var Up = typeof Symbol < "u" ? function(u) {
				return u[Symbol.toStringTag] === "AsyncFunction";
			} : function() {
				return !1;
			}, Wp = [
				"Unknown",
				"Constraint",
				"Data",
				"TransactionInactive",
				"ReadOnly",
				"Version",
				"NotFound",
				"InvalidState",
				"InvalidAccess",
				"Abort",
				"Timeout",
				"QuotaExceeded",
				"Syntax",
				"DataClone"
			], Gp = [
				"Modify",
				"Bulk",
				"OpenFailed",
				"VersionChange",
				"Schema",
				"Upgrade",
				"InvalidTable",
				"MissingAPI",
				"NoSuchDatabase",
				"InvalidArgument",
				"SubTransaction",
				"Unsupported",
				"Internal",
				"DatabaseClosed",
				"PrematureCommit",
				"ForeignAwait"
			].concat(Wp), Kp = {
				VersionChanged: "Database version changed by other database connection",
				DatabaseClosed: "Database has been closed",
				Abort: "Transaction aborted",
				TransactionInactive: "Transaction has already completed or failed",
				MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
			};
			function qp(u, E) {
				this.name = u, this.message = E;
			}
			function Jp(u, E) {
				return u + ". Errors: " + Object.keys(E).map(function(u) {
					return E[u].toString();
				}).filter(function(u, E, D) {
					return D.indexOf(u) === E;
				}).join("\n");
			}
			function Yp(u, E, D, O) {
				this.failures = E, this.failedKeys = O, this.successCount = D, this.message = Jp(u, E);
			}
			function Xp(u, E) {
				this.name = "BulkError", this.failures = Object.keys(E).map(function(u) {
					return E[u];
				}), this.failuresByPos = E, this.message = Jp(u, this.failures);
			}
			bp(qp).from(Error).extend({ toString: function() {
				return this.name + ": " + this.message;
			} }), bp(Yp).from(qp), bp(Xp).from(qp);
			var Zp = Gp.reduce(function(u, E) {
				return u[E] = E + "Error", u;
			}, {}), Qp = qp, $p = Gp.reduce(function(u, E) {
				var D = E + "Error";
				function O(u, O) {
					this.name = D, u ? typeof u == "string" ? (this.message = `${u}${O ? "\n " + O : ""}`, this.inner = O || null) : typeof u == "object" && (this.message = `${u.name} ${u.message}`, this.inner = u) : (this.message = Kp[E] || D, this.inner = null);
				}
				return bp(O).from(Qp), u[E] = O, u;
			}, {});
			$p.Syntax = SyntaxError, $p.Type = TypeError, $p.Range = RangeError;
			var em = Wp.reduce(function(u, E) {
				return u[E + "Error"] = $p[E], u;
			}, {}), tm = Gp.reduce(function(u, E) {
				return [
					"Syntax",
					"Type",
					"Range"
				].indexOf(E) === -1 && (u[E + "Error"] = $p[E]), u;
			}, {});
			function nm() {}
			function rm(u) {
				return u;
			}
			function im(u, E) {
				return u == null || u === rm ? E : function(D) {
					return E(u(D));
				};
			}
			function am(u, E) {
				return function() {
					u.apply(this, arguments), E.apply(this, arguments);
				};
			}
			function om(u, E) {
				return u === nm ? E : function() {
					var D = u.apply(this, arguments);
					D !== void 0 && (arguments[0] = D);
					var O = this.onsuccess, P = this.onerror;
					this.onsuccess = null, this.onerror = null;
					var F = E.apply(this, arguments);
					return O && (this.onsuccess = this.onsuccess ? am(O, this.onsuccess) : O), P && (this.onerror = this.onerror ? am(P, this.onerror) : P), F === void 0 ? D : F;
				};
			}
			function sm(u, E) {
				return u === nm ? E : function() {
					u.apply(this, arguments);
					var D = this.onsuccess, O = this.onerror;
					this.onsuccess = this.onerror = null, E.apply(this, arguments), D && (this.onsuccess = this.onsuccess ? am(D, this.onsuccess) : D), O && (this.onerror = this.onerror ? am(O, this.onerror) : O);
				};
			}
			function cm(u, E) {
				return u === nm ? E : function(D) {
					var O = u.apply(this, arguments);
					I(D, O);
					var P = this.onsuccess, F = this.onerror;
					return this.onsuccess = null, this.onerror = null, D = E.apply(this, arguments), P && (this.onsuccess = this.onsuccess ? am(P, this.onsuccess) : P), F && (this.onerror = this.onerror ? am(F, this.onerror) : F), O === void 0 ? D === void 0 ? void 0 : D : I(O, D);
				};
			}
			function lm(u, E) {
				return u === nm ? E : function() {
					return E.apply(this, arguments) !== !1 && u.apply(this, arguments);
				};
			}
			function um(u, E) {
				return u === nm ? E : function() {
					var D = u.apply(this, arguments);
					if (D && typeof D.then == "function") {
						for (var O = this, P = arguments.length, F = Array(P); P--;) F[P] = arguments[P];
						return D.then(function() {
							return E.apply(O, F);
						});
					}
					return E.apply(this, arguments);
				};
			}
			tm.ModifyError = Yp, tm.DexieError = qp, tm.BulkError = Xp;
			var dm = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
			function fm(u) {
				dm = u;
			}
			var pm = {}, mm = 100, Mp = typeof Promise > "u" ? [] : function() {
				var u = Promise.resolve();
				if (typeof crypto > "u" || !crypto.subtle) return [
					u,
					R(u),
					u
				];
				var E = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
				return [
					E,
					R(E),
					u
				];
			}(), Wp = Mp[0], Gp = Mp[1], Mp = Mp[2], Gp = Gp && Gp.then, hm = Wp && Wp.constructor, gm = !!Mp, _m = function(u, E) {
				Tm.push([u, E]), ym &&= (queueMicrotask(Fm), !1);
			}, vm = !0, ym = !0, bm = [], xm = [], Sm = rm, Cm = {
				id: "global",
				global: !0,
				ref: 0,
				unhandleds: [],
				onunhandled: nm,
				pgp: !1,
				env: {},
				finalize: nm
			}, wm = Cm, Tm = [], Em = 0, Dm = [];
			function Om(u) {
				if (typeof this != "object") throw TypeError("Promises must be constructed via new");
				this._listeners = [], this._lib = !1;
				var E = this._PSD = wm;
				if (typeof u != "function") {
					if (u !== pm) throw TypeError("Not a function");
					this._state = arguments[1], this._value = arguments[2], this._state === !1 && jm(this, this._value);
					return;
				}
				this._state = null, this._value = null, ++E.ref, function u(E, D) {
					try {
						D(function(D) {
							if (E._state === null) {
								if (D === E) throw TypeError("A promise cannot be resolved with itself.");
								var O = E._lib && Im();
								D && typeof D.then == "function" ? u(E, function(u, E) {
									D instanceof Om ? D._then(u, E) : D.then(u, E);
								}) : (E._state = !0, E._value = D, Mm(E)), O && Lm();
							}
						}, jm.bind(null, E));
					} catch (u) {
						jm(E, u);
					}
				}(this, u);
			}
			var km = {
				get: function() {
					var u = wm, E = Gm;
					function D(D, O) {
						var P = this, F = !u.global && (u !== wm || E !== Gm), I = F && !Ym(), R = new Om(function(E, R) {
							Nm(P, new Am(th(D, u, F, I), th(O, u, F, I), E, R, u));
						});
						return this._consoleTask && (R._consoleTask = this._consoleTask), R;
					}
					return D.prototype = pm, D;
				},
				set: function(u) {
					yp(this, "then", u && u.prototype === pm ? km : {
						get: function() {
							return u;
						},
						set: km.set
					});
				}
			};
			function Am(u, E, D, O, P) {
				this.onFulfilled = typeof u == "function" ? u : null, this.onRejected = typeof E == "function" ? E : null, this.resolve = D, this.reject = O, this.psd = P;
			}
			function jm(u, E) {
				var D, O;
				xm.push(E), u._state === null && (D = u._lib && Im(), E = Sm(E), u._state = !1, u._value = E, O = u, bm.some(function(u) {
					return u._value === O._value;
				}) || bm.push(O), Mm(u), D && Lm());
			}
			function Mm(u) {
				var E = u._listeners;
				u._listeners = [];
				for (var D = 0, O = E.length; D < O; ++D) Nm(u, E[D]);
				var P = u._PSD;
				--P.ref || P.finalize(), Em === 0 && (++Em, _m(function() {
					--Em == 0 && Rm();
				}, []));
			}
			function Nm(u, E) {
				if (u._state !== null) {
					var D = u._state ? E.onFulfilled : E.onRejected;
					if (D === null) return (u._state ? E.resolve : E.reject)(u._value);
					++E.psd.ref, ++Em, _m(Pm, [
						D,
						u,
						E
					]);
				} else u._listeners.push(E);
			}
			function Pm(u, E, D) {
				try {
					var O, P = E._value;
					!E._state && xm.length && (xm = []), O = dm && E._consoleTask ? E._consoleTask.run(function() {
						return u(P);
					}) : u(P), E._state || xm.indexOf(P) !== -1 || function(u) {
						for (var E = bm.length; E;) if (bm[--E]._value === u._value) return bm.splice(E, 1);
					}(E), D.resolve(O);
				} catch (u) {
					D.reject(u);
				} finally {
					--Em == 0 && Rm(), --D.psd.ref || D.psd.finalize();
				}
			}
			function Fm() {
				eh(Cm, function() {
					Im() && Lm();
				});
			}
			function Im() {
				var u = vm;
				return ym = vm = !1, u;
			}
			function Lm() {
				var u, E, D;
				do
					for (; 0 < Tm.length;) for (u = Tm, Tm = [], D = u.length, E = 0; E < D; ++E) {
						var O = u[E];
						O[0].apply(null, O[1]);
					}
				while (0 < Tm.length);
				ym = vm = !0;
			}
			function Rm() {
				var u = bm;
				bm = [], u.forEach(function(u) {
					u._PSD.onunhandled.call(null, u._value, u);
				});
				for (var E = Dm.slice(0), D = E.length; D;) E[--D]();
			}
			function zm(u) {
				return new Om(pm, !1, u);
			}
			function Bm(u, E) {
				var D = wm;
				return function() {
					var O = Im(), P = wm;
					try {
						return Qm(D, !0), u.apply(this, arguments);
					} catch (u) {
						E && E(u);
					} finally {
						Qm(P, !1), O && Lm();
					}
				};
			}
			_p(Om.prototype, {
				then: km,
				_then: function(u, E) {
					Nm(this, new Am(null, null, u, E, wm));
				},
				catch: function(u) {
					if (arguments.length === 1) return this.then(null, u);
					var E = u, D = arguments[1];
					return typeof E == "function" ? this.then(null, function(u) {
						return (u instanceof E ? D : zm)(u);
					}) : this.then(null, function(u) {
						return (u && u.name === E ? D : zm)(u);
					});
				},
				finally: function(u) {
					return this.then(function(E) {
						return Om.resolve(u()).then(function() {
							return E;
						});
					}, function(E) {
						return Om.resolve(u()).then(function() {
							return zm(E);
						});
					});
				},
				timeout: function(u, E) {
					var D = this;
					return u < Infinity ? new Om(function(O, P) {
						var F = setTimeout(function() {
							return P(new $p.Timeout(E));
						}, u);
						D.then(O, P).finally(clearTimeout.bind(null, F));
					}) : this;
				}
			}), typeof Symbol < "u" && Symbol.toStringTag && yp(Om.prototype, Symbol.toStringTag, "Dexie.Promise"), Cm.env = $m(), _p(Om, {
				all: function() {
					var u = Hp.apply(null, arguments).map(Xm);
					return new Om(function(E, D) {
						u.length === 0 && E([]);
						var O = u.length;
						u.forEach(function(P, F) {
							return Om.resolve(P).then(function(D) {
								u[F] = D, --O || E(u);
							}, D);
						});
					});
				},
				resolve: function(u) {
					return u instanceof Om ? u : u && typeof u.then == "function" ? new Om(function(E, D) {
						u.then(E, D);
					}) : new Om(pm, !0, u);
				},
				reject: zm,
				race: function() {
					var u = Hp.apply(null, arguments).map(Xm);
					return new Om(function(E, D) {
						u.map(function(u) {
							return Om.resolve(u).then(E, D);
						});
					});
				},
				PSD: {
					get: function() {
						return wm;
					},
					set: function(u) {
						return wm = u;
					}
				},
				totalEchoes: { get: function() {
					return Gm;
				} },
				newPSD: qm,
				usePSD: eh,
				scheduler: {
					get: function() {
						return _m;
					},
					set: function(u) {
						_m = u;
					}
				},
				rejectionMapper: {
					get: function() {
						return Sm;
					},
					set: function(u) {
						Sm = u;
					}
				},
				follow: function(u, E) {
					return new Om(function(D, O) {
						return qm(function(E, D) {
							var O = wm;
							O.unhandleds = [], O.onunhandled = D, O.finalize = am(function() {
								var u, O = this;
								u = function() {
									O.unhandleds.length === 0 ? E() : D(O.unhandleds[0]);
								}, Dm.push(function E() {
									u(), Dm.splice(Dm.indexOf(E), 1);
								}), ++Em, _m(function() {
									--Em == 0 && Rm();
								}, []);
							}, O.finalize), u();
						}, E, D, O);
					});
				}
			}), hm && (hm.allSettled && yp(Om, "allSettled", function() {
				var u = Hp.apply(null, arguments).map(Xm);
				return new Om(function(E) {
					u.length === 0 && E([]);
					var D = u.length, O = Array(D);
					u.forEach(function(u, P) {
						return Om.resolve(u).then(function(u) {
							return O[P] = {
								status: "fulfilled",
								value: u
							};
						}, function(u) {
							return O[P] = {
								status: "rejected",
								reason: u
							};
						}).then(function() {
							return --D || E(O);
						});
					});
				});
			}), hm.any && typeof AggregateError < "u" && yp(Om, "any", function() {
				var u = Hp.apply(null, arguments).map(Xm);
				return new Om(function(E, D) {
					u.length === 0 && D(/* @__PURE__ */ AggregateError([]));
					var O = u.length, P = Array(O);
					u.forEach(function(u, F) {
						return Om.resolve(u).then(function(u) {
							return E(u);
						}, function(u) {
							P[F] = u, --O || D(AggregateError(P));
						});
					});
				});
			}), hm.withResolvers && (Om.withResolvers = hm.withResolvers));
			var Vm = {
				awaits: 0,
				echoes: 0,
				id: 0
			}, Hm = 0, Um = [], Wm = 0, Gm = 0, Km = 0;
			function qm(u, E, D, O) {
				var P = wm, F = Object.create(P);
				return F.parent = P, F.ref = 0, F.global = !1, F.id = ++Km, Cm.env, F.env = gm ? {
					Promise: Om,
					PromiseProp: {
						value: Om,
						configurable: !0,
						writable: !0
					},
					all: Om.all,
					race: Om.race,
					allSettled: Om.allSettled,
					any: Om.any,
					resolve: Om.resolve,
					reject: Om.reject
				} : {}, E && I(F, E), ++P.ref, F.finalize = function() {
					--this.parent.ref || this.parent.finalize();
				}, O = eh(F, u, D, O), F.ref === 0 && F.finalize(), O;
			}
			function Jm() {
				return Vm.id ||= ++Hm, ++Vm.awaits, Vm.echoes += mm, Vm.id;
			}
			function Ym() {
				return !!Vm.awaits && (--Vm.awaits == 0 && (Vm.id = 0), Vm.echoes = Vm.awaits * mm, !0);
			}
			function Xm(u) {
				return Vm.echoes && u && u.constructor === hm ? (Jm(), u.then(function(u) {
					return Ym(), u;
				}, function(u) {
					return Ym(), rh(u);
				})) : u;
			}
			function Zm() {
				var u = Um[Um.length - 1];
				Um.pop(), Qm(u, !1);
			}
			function Qm(u, E) {
				var D, P = wm;
				(E ? !Vm.echoes || Wm++ && u === wm : !Wm || --Wm && u === wm) || queueMicrotask(E ? (function(u) {
					++Gm, Vm.echoes && --Vm.echoes != 0 || (Vm.echoes = Vm.awaits = Vm.id = 0), Um.push(wm), Qm(u, !0);
				}).bind(null, u) : Zm), u !== wm && (wm = u, P === Cm && (Cm.env = $m()), gm && (D = Cm.env.Promise, E = u.env, (P.global || u.global) && (Object.defineProperty(O, "Promise", E.PromiseProp), D.all = E.all, D.race = E.race, D.resolve = E.resolve, D.reject = E.reject, E.allSettled && (D.allSettled = E.allSettled), E.any && (D.any = E.any))));
			}
			function $m() {
				var u = O.Promise;
				return gm ? {
					Promise: u,
					PromiseProp: Object.getOwnPropertyDescriptor(O, "Promise"),
					all: u.all,
					race: u.race,
					allSettled: u.allSettled,
					any: u.any,
					resolve: u.resolve,
					reject: u.reject
				} : {};
			}
			function eh(u, E, D, O, P) {
				var F = wm;
				try {
					return Qm(u, !0), E(D, O, P);
				} finally {
					Qm(F, !1);
				}
			}
			function th(u, E, D, O) {
				return typeof u == "function" ? function() {
					var P = wm;
					D && Jm(), Qm(E, !0);
					try {
						return u.apply(this, arguments);
					} finally {
						Qm(P, !1), O && queueMicrotask(Ym);
					}
				} : u;
			}
			function nh(u) {
				Promise === hm && Vm.echoes === 0 ? Wm === 0 ? u() : enqueueNativeMicroTask(u) : setTimeout(u, 0);
			}
			("" + Gp).indexOf("[native code]") === -1 && (Jm = Ym = nm);
			var rh = Om.reject, ih = "", ah = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", oh = "String expected.", sh = [], ch = "__dbnames", lh = "readonly", uh = "readwrite";
			function dh(u, E) {
				return u ? E ? function() {
					return u.apply(this, arguments) && E.apply(this, arguments);
				} : u : E;
			}
			var fh = {
				type: 3,
				lower: -Infinity,
				lowerOpen: !1,
				upper: [[]],
				upperOpen: !1
			};
			function ph(u) {
				return typeof u != "string" || /\./.test(u) ? function(u) {
					return u;
				} : function(E) {
					return E[u] === void 0 && u in E && delete (E = Fp(E))[u], E;
				};
			}
			function mh() {
				throw $p.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
			}
			function hh(u, E) {
				try {
					var D = gh(u), O = gh(E);
					if (D !== O) return D === "Array" ? 1 : O === "Array" ? -1 : D === "binary" ? 1 : O === "binary" ? -1 : D === "string" ? 1 : O === "string" ? -1 : D === "Date" ? 1 : O === "Date" ? -1 : NaN;
					switch (D) {
						case "number":
						case "Date":
						case "string": return E < u ? 1 : u < E ? -1 : 0;
						case "binary": return function(u, E) {
							for (var D = u.length, O = E.length, P = D < O ? D : O, F = 0; F < P; ++F) if (u[F] !== E[F]) return u[F] < E[F] ? -1 : 1;
							return D === O ? 0 : D < O ? -1 : 1;
						}(_h(u), _h(E));
						case "Array": return function(u, E) {
							for (var D = u.length, O = E.length, P = D < O ? D : O, F = 0; F < P; ++F) {
								var I = hh(u[F], E[F]);
								if (I !== 0) return I;
							}
							return D === O ? 0 : D < O ? -1 : 1;
						}(u, E);
					}
				} catch {}
				return NaN;
			}
			function gh(u) {
				var E = typeof u;
				return E == "object" ? ArrayBuffer.isView(u) ? "binary" : (u = Lp(u), u === "ArrayBuffer" ? "binary" : u) : E;
			}
			function _h(u) {
				return u instanceof Uint8Array ? u : ArrayBuffer.isView(u) ? new Uint8Array(u.buffer, u.byteOffset, u.byteLength) : new Uint8Array(u);
			}
			function vh(u, E, D) {
				var O = u.schema.yProps;
				return O ? (E && 0 < D.numFailures && (E = E.filter(function(u, E) {
					return !D.failures[E];
				})), Promise.all(O.map(function(D) {
					return D = D.updatesTable, E ? u.db.table(D).where("k").anyOf(E).delete() : u.db.table(D).clear();
				})).then(function() {
					return D;
				})) : D;
			}
			var yh = (bh.prototype._trans = function(u, E, D) {
				var O = this._tx || wm.trans, P = this.name, F = dm && typeof console < "u" && console.createTask && console.createTask(`Dexie: ${u === "readonly" ? "read" : "write"} ${this.name}`);
				function I(u, D, O) {
					if (!O.schema[P]) throw new $p.NotFound("Table " + P + " not part of transaction");
					return E(O.idbtrans, O);
				}
				var R = Im();
				try {
					var U = O && O.db._novip === this.db._novip ? O === wm.trans ? O._promise(u, I, D) : qm(function() {
						return O._promise(u, I, D);
					}, {
						trans: O,
						transless: wm.transless || wm
					}) : function u(E, D, O, P) {
						if (E.idbdb && (E._state.openComplete || wm.letThrough || E._vip)) {
							var F = E._createTransaction(D, O, E._dbSchema);
							try {
								F.create(), E._state.PR1398_maxLoop = 3;
							} catch (F) {
								return F.name === Zp.InvalidState && E.isOpen() && 0 < --E._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), E.close({ disableAutoOpen: !1 }), E.open().then(function() {
									return u(E, D, O, P);
								})) : rh(F);
							}
							return F._promise(D, function(u, E) {
								return qm(function() {
									return wm.trans = F, P(u, E, F);
								});
							}).then(function(u) {
								if (D === "readwrite") try {
									F.idbtrans.commit();
								} catch {}
								return D === "readonly" ? u : F._completion.then(function() {
									return u;
								});
							});
						}
						if (E._state.openComplete) return rh(new $p.DatabaseClosed(E._state.dbOpenError));
						if (!E._state.isBeingOpened) {
							if (!E._state.autoOpen) return rh(new $p.DatabaseClosed());
							E.open().catch(nm);
						}
						return E._state.dbReadyPromise.then(function() {
							return u(E, D, O, P);
						});
					}(this.db, u, [this.name], I);
					return F && (U._consoleTask = F, U = U.catch(function(u) {
						return console.trace(u), rh(u);
					})), U;
				} finally {
					R && Lm();
				}
			}, bh.prototype.get = function(u, E) {
				var D = this;
				return u && u.constructor === Object ? this.where(u).first(E) : u == null ? rh(new $p.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(E) {
					return D.core.get({
						trans: E,
						key: u
					}).then(function(u) {
						return D.hook.reading.fire(u);
					});
				}).then(E);
			}, bh.prototype.where = function(u) {
				if (typeof u == "string") return new this.db.WhereClause(this, u);
				if (F(u)) return new this.db.WhereClause(this, `[${u.join("+")}]`);
				var E = P(u);
				if (E.length === 1) return this.where(E[0]).equals(u[E[0]]);
				var D = this.schema.indexes.concat(this.schema.primKey).filter(function(u) {
					if (u.compound && E.every(function(E) {
						return 0 <= u.keyPath.indexOf(E);
					})) {
						for (var D = 0; D < E.length; ++D) if (E.indexOf(u.keyPath[D]) === -1) return !1;
						return !0;
					}
					return !1;
				}).sort(function(u, E) {
					return u.keyPath.length - E.keyPath.length;
				})[0];
				if (D && this.db._maxKey !== ih) {
					var O = D.keyPath.slice(0, E.length);
					return this.where(O).equals(O.map(function(E) {
						return u[E];
					}));
				}
				!D && dm && console.warn(`The query ${JSON.stringify(u)} on ${this.name} would benefit from a compound index [${E.join("+")}]`);
				var I = this.schema.idxByName;
				function R(u, E) {
					return hh(u, E) === 0;
				}
				var U = E.reduce(function(E, D) {
					var O = E[0], P = E[1], E = I[D], U = u[D];
					return [O || E, O || !E ? dh(P, E && E.multi ? function(u) {
						return u = Dp(u, D), F(u) && u.some(function(u) {
							return R(U, u);
						});
					} : function(u) {
						return R(U, Dp(u, D));
					}) : P];
				}, [null, null]), O = U[0], U = U[1];
				return O ? this.where(O.name).equals(u[O.keyPath]).filter(U) : D ? this.filter(U) : this.where(E).equals("");
			}, bh.prototype.filter = function(u) {
				return this.toCollection().and(u);
			}, bh.prototype.count = function(u) {
				return this.toCollection().count(u);
			}, bh.prototype.offset = function(u) {
				return this.toCollection().offset(u);
			}, bh.prototype.limit = function(u) {
				return this.toCollection().limit(u);
			}, bh.prototype.each = function(u) {
				return this.toCollection().each(u);
			}, bh.prototype.toArray = function(u) {
				return this.toCollection().toArray(u);
			}, bh.prototype.toCollection = function() {
				return new this.db.Collection(new this.db.WhereClause(this));
			}, bh.prototype.orderBy = function(u) {
				return new this.db.Collection(new this.db.WhereClause(this, F(u) ? `[${u.join("+")}]` : u));
			}, bh.prototype.reverse = function() {
				return this.toCollection().reverse();
			}, bh.prototype.mapToClass = function(E) {
				var D, O = this.db, P = this.name;
				function F() {
					return D !== null && D.apply(this, arguments) || this;
				}
				(this.schema.mappedClass = E).prototype instanceof mh && (function(E, D) {
					if (typeof D != "function" && D !== null) throw TypeError("Class extends value " + String(D) + " is not a constructor or null");
					function O() {
						this.constructor = E;
					}
					u(E, D), E.prototype = D === null ? Object.create(D) : (O.prototype = D.prototype, new O());
				}(F, D = E), Object.defineProperty(F.prototype, "db", {
					get: function() {
						return O;
					},
					enumerable: !1,
					configurable: !0
				}), F.prototype.table = function() {
					return P;
				}, E = F);
				for (var I = /* @__PURE__ */ new Set(), U = E.prototype; U; U = R(U)) Object.getOwnPropertyNames(U).forEach(function(u) {
					return I.add(u);
				});
				function J(u) {
					if (!u) return u;
					var D, O = Object.create(E.prototype);
					for (D in u) if (!I.has(D)) try {
						O[D] = u[D];
					} catch {}
					return O;
				}
				return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = J, this.hook("reading", J), E;
			}, bh.prototype.defineClass = function() {
				return this.mapToClass(function(u) {
					I(this, u);
				});
			}, bh.prototype.add = function(u, E) {
				var D = this, O = this.schema.primKey, P = O.auto, F = O.keyPath, I = u;
				return F && P && (I = ph(F)(u)), this._trans("readwrite", function(u) {
					return D.core.mutate({
						trans: u,
						type: "add",
						keys: E == null ? null : [E],
						values: [I]
					});
				}).then(function(u) {
					return u.numFailures ? Om.reject(u.failures[0]) : u.lastResult;
				}).then(function(E) {
					if (F) try {
						Op(u, F, E);
					} catch {}
					return E;
				});
			}, bh.prototype.update = function(u, E) {
				return typeof u != "object" || F(u) ? this.where(":id").equals(u).modify(E) : (u = Dp(u, this.schema.primKey.keyPath), u === void 0 ? rh(new $p.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(u).modify(E));
			}, bh.prototype.put = function(u, E) {
				var D = this, O = this.schema.primKey, P = O.auto, F = O.keyPath, I = u;
				return F && P && (I = ph(F)(u)), this._trans("readwrite", function(u) {
					return D.core.mutate({
						trans: u,
						type: "put",
						values: [I],
						keys: E == null ? null : [E]
					});
				}).then(function(u) {
					return u.numFailures ? Om.reject(u.failures[0]) : u.lastResult;
				}).then(function(E) {
					if (F) try {
						Op(u, F, E);
					} catch {}
					return E;
				});
			}, bh.prototype.delete = function(u) {
				var E = this;
				return this._trans("readwrite", function(D) {
					return E.core.mutate({
						trans: D,
						type: "delete",
						keys: [u]
					}).then(function(D) {
						return vh(E, [u], D);
					}).then(function(u) {
						return u.numFailures ? Om.reject(u.failures[0]) : void 0;
					});
				});
			}, bh.prototype.clear = function() {
				var u = this;
				return this._trans("readwrite", function(E) {
					return u.core.mutate({
						trans: E,
						type: "deleteRange",
						range: fh
					}).then(function(E) {
						return vh(u, null, E);
					});
				}).then(function(u) {
					return u.numFailures ? Om.reject(u.failures[0]) : void 0;
				});
			}, bh.prototype.bulkGet = function(u) {
				var E = this;
				return this._trans("readonly", function(D) {
					return E.core.getMany({
						keys: u,
						trans: D
					}).then(function(u) {
						return u.map(function(u) {
							return E.hook.reading.fire(u);
						});
					});
				});
			}, bh.prototype.bulkAdd = function(u, E, D) {
				var O = this, P = Array.isArray(E) ? E : void 0, F = (D ||= P ? void 0 : E) ? D.allKeys : void 0;
				return this._trans("readwrite", function(E) {
					var D = O.schema.primKey, I = D.auto, D = D.keyPath;
					if (D && P) throw new $p.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
					if (P && P.length !== u.length) throw new $p.InvalidArgument("Arguments objects and keys must have the same length");
					var R = u.length, D = D && I ? u.map(ph(D)) : u;
					return O.core.mutate({
						trans: E,
						type: "add",
						keys: P,
						values: D,
						wantResults: F
					}).then(function(u) {
						var E = u.numFailures, D = u.results, P = u.lastResult, u = u.failures;
						if (E === 0) return F ? D : P;
						throw new Xp(`${O.name}.bulkAdd(): ${E} of ${R} operations failed`, u);
					});
				});
			}, bh.prototype.bulkPut = function(u, E, D) {
				var O = this, P = Array.isArray(E) ? E : void 0, F = (D ||= P ? void 0 : E) ? D.allKeys : void 0;
				return this._trans("readwrite", function(E) {
					var D = O.schema.primKey, I = D.auto, D = D.keyPath;
					if (D && P) throw new $p.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
					if (P && P.length !== u.length) throw new $p.InvalidArgument("Arguments objects and keys must have the same length");
					var R = u.length, D = D && I ? u.map(ph(D)) : u;
					return O.core.mutate({
						trans: E,
						type: "put",
						keys: P,
						values: D,
						wantResults: F
					}).then(function(u) {
						var E = u.numFailures, D = u.results, P = u.lastResult, u = u.failures;
						if (E === 0) return F ? D : P;
						throw new Xp(`${O.name}.bulkPut(): ${E} of ${R} operations failed`, u);
					});
				});
			}, bh.prototype.bulkUpdate = function(u) {
				var E = this, D = this.core, O = u.map(function(u) {
					return u.key;
				}), P = u.map(function(u) {
					return u.changes;
				}), F = [];
				return this._trans("readwrite", function(I) {
					return D.getMany({
						trans: I,
						keys: O,
						cache: "clone"
					}).then(function(R) {
						var U = [], J = [];
						u.forEach(function(u, D) {
							var O = u.key, P = u.changes, I = R[D];
							if (I) {
								for (var _p = 0, vp = Object.keys(P); _p < vp.length; _p++) {
									var yp = vp[_p], bp = P[yp];
									if (yp === E.schema.primKey.keyPath) {
										if (hh(bp, O) !== 0) throw new $p.Constraint("Cannot update primary key in bulkUpdate()");
									} else Op(I, yp, bp);
								}
								F.push(D), U.push(O), J.push(I);
							}
						});
						var _p = U.length;
						return D.mutate({
							trans: I,
							type: "put",
							keys: U,
							values: J,
							updates: {
								keys: O,
								changeSpecs: P
							}
						}).then(function(u) {
							var D = u.numFailures, O = u.failures;
							if (D === 0) return _p;
							for (var P = 0, I = Object.keys(O); P < I.length; P++) {
								var R, U = I[P], J = F[Number(U)];
								J != null && (R = O[U], delete O[U], O[J] = R);
							}
							throw new Xp(`${E.name}.bulkUpdate(): ${D} of ${_p} operations failed`, O);
						});
					});
				});
			}, bh.prototype.bulkDelete = function(u) {
				var E = this, D = u.length;
				return this._trans("readwrite", function(D) {
					return E.core.mutate({
						trans: D,
						type: "delete",
						keys: u
					}).then(function(D) {
						return vh(E, u, D);
					});
				}).then(function(u) {
					var O = u.numFailures, P = u.lastResult, u = u.failures;
					if (O === 0) return P;
					throw new Xp(`${E.name}.bulkDelete(): ${O} of ${D} operations failed`, u);
				});
			}, bh);
			function bh() {}
			function xh(u) {
				function E(E, O) {
					if (O) {
						for (var P = arguments.length, F = Array(P - 1); --P;) F[P - 1] = arguments[P];
						return D[E].subscribe.apply(null, F), u;
					}
					if (typeof E == "string") return D[E];
				}
				var D = {};
				E.addEventType = R;
				for (var O = 1, I = arguments.length; O < I; ++O) R(arguments[O]);
				return E;
				function R(u, O, I) {
					if (typeof u != "object") {
						var U;
						O ||= lm;
						var J = {
							subscribers: [],
							fire: I ||= nm,
							subscribe: function(u) {
								J.subscribers.indexOf(u) === -1 && (J.subscribers.push(u), J.fire = O(J.fire, u));
							},
							unsubscribe: function(u) {
								J.subscribers = J.subscribers.filter(function(E) {
									return E !== u;
								}), J.fire = J.subscribers.reduce(O, I);
							}
						};
						return D[u] = E[u] = J;
					}
					P(U = u).forEach(function(u) {
						var E = U[u];
						if (F(E)) R(u, U[u][0], U[u][1]);
						else {
							if (E !== "asap") throw new $p.InvalidArgument("Invalid event config");
							var D = R(u, rm, function() {
								for (var u = arguments.length, E = Array(u); u--;) E[u] = arguments[u];
								D.subscribers.forEach(function(u) {
									Ep(function() {
										u.apply(null, E);
									});
								});
							});
						}
					});
				}
			}
			function Sh(u, E) {
				return bp(E).from({ prototype: u }), E;
			}
			function Ch(u, E) {
				return !(u.filter || u.algorithm || u.or) && (E ? u.justLimit : !u.replayFilter);
			}
			function wh(u, E) {
				u.filter = dh(u.filter, E);
			}
			function Th(u, E, D) {
				var O = u.replayFilter;
				u.replayFilter = O ? function() {
					return dh(O(), E());
				} : E, u.justLimit = D && !O;
			}
			function Eh(u, E) {
				if (u.isPrimKey) return E.primaryKey;
				var D = E.getIndexByKeyPath(u.index);
				if (!D) throw new $p.Schema("KeyPath " + u.index + " on object store " + E.name + " is not indexed");
				return D;
			}
			function Dh(u, E, D) {
				var O = Eh(u, E.schema);
				return E.openCursor({
					trans: D,
					values: !u.keysOnly,
					reverse: u.dir === "prev",
					unique: !!u.unique,
					query: {
						index: O,
						range: u.range
					}
				});
			}
			function Oh(u, E, D, O) {
				var P = u.replayFilter ? dh(u.filter, u.replayFilter()) : u.filter;
				if (u.or) {
					var F = {}, I = function(u, D, O) {
						var I, R;
						P && !P(D, O, function(u) {
							return D.stop(u);
						}, function(u) {
							return D.fail(u);
						}) || ((R = "" + (I = D.primaryKey)) == "[object ArrayBuffer]" && (R = "" + new Uint8Array(I)), J(F, R) || (F[R] = !0, E(u, D, O)));
					};
					return Promise.all([u.or._iterate(I, D), kh(Dh(u, O, D), u.algorithm, I, !u.keysOnly && u.valueMapper)]);
				}
				return kh(Dh(u, O, D), dh(u.algorithm, P), E, !u.keysOnly && u.valueMapper);
			}
			function kh(u, E, D, O) {
				var P = Bm(O ? function(u, E, P) {
					return D(O(u), E, P);
				} : D);
				return u.then(function(u) {
					if (u) return u.start(function() {
						var D = function() {
							return u.continue();
						};
						E && !E(u, function(u) {
							return D = u;
						}, function(E) {
							u.stop(E), D = nm;
						}, function(E) {
							u.fail(E), D = nm;
						}) || P(u.value, u, function(u) {
							return D = u;
						}), D();
					});
				});
			}
			var Ah = (jh.prototype.execute = function(u) {
				var E = this["@@propmod"];
				if (E.add !== void 0) {
					var O = E.add;
					if (F(O)) return D(D([], F(u) ? u : [], !0), O).sort();
					if (typeof O == "number") return (Number(u) || 0) + O;
					if (typeof O == "bigint") try {
						return BigInt(u) + O;
					} catch {
						return BigInt(0) + O;
					}
					throw TypeError(`Invalid term ${O}`);
				}
				if (E.remove !== void 0) {
					var P = E.remove;
					if (F(P)) return F(u) ? u.filter(function(u) {
						return !P.includes(u);
					}).sort() : [];
					if (typeof P == "number") return Number(u) - P;
					if (typeof P == "bigint") try {
						return BigInt(u) - P;
					} catch {
						return BigInt(0) - P;
					}
					throw TypeError(`Invalid subtrahend ${P}`);
				}
				return O = (O = E.replacePrefix)?.[0], O && typeof u == "string" && u.startsWith(O) ? E.replacePrefix[1] + u.substring(O.length) : u;
			}, jh);
			function jh(u) {
				this["@@propmod"] = u;
			}
			var Mh = (Nh.prototype._read = function(u, E) {
				var D = this._ctx;
				return D.error ? D.table._trans(null, rh.bind(null, D.error)) : D.table._trans("readonly", u).then(E);
			}, Nh.prototype._write = function(u) {
				var E = this._ctx;
				return E.error ? E.table._trans(null, rh.bind(null, E.error)) : E.table._trans("readwrite", u, "locked");
			}, Nh.prototype._addAlgorithm = function(u) {
				var E = this._ctx;
				E.algorithm = dh(E.algorithm, u);
			}, Nh.prototype._iterate = function(u, E) {
				return Oh(this._ctx, u, E, this._ctx.table.core);
			}, Nh.prototype.clone = function(u) {
				var E = Object.create(this.constructor.prototype), D = Object.create(this._ctx);
				return u && I(D, u), E._ctx = D, E;
			}, Nh.prototype.raw = function() {
				return this._ctx.valueMapper = null, this;
			}, Nh.prototype.each = function(u) {
				var E = this._ctx;
				return this._read(function(D) {
					return Oh(E, u, D, E.table.core);
				});
			}, Nh.prototype.count = function(u) {
				var E = this;
				return this._read(function(u) {
					var D = E._ctx, O = D.table.core;
					if (Ch(D, !0)) return O.count({
						trans: u,
						query: {
							index: Eh(D, O.schema),
							range: D.range
						}
					}).then(function(u) {
						return Math.min(u, D.limit);
					});
					var P = 0;
					return Oh(D, function() {
						return ++P, !1;
					}, u, O).then(function() {
						return P;
					});
				}).then(u);
			}, Nh.prototype.sortBy = function(u, E) {
				var D = u.split(".").reverse(), O = D[0], P = D.length - 1;
				function F(u, E) {
					return E ? F(u[D[E]], E - 1) : u[O];
				}
				var I = this._ctx.dir === "next" ? 1 : -1;
				function R(u, E) {
					return hh(F(u, P), F(E, P)) * I;
				}
				return this.toArray(function(u) {
					return u.sort(R);
				}).then(E);
			}, Nh.prototype.toArray = function(u) {
				var E = this;
				return this._read(function(u) {
					var D = E._ctx;
					if (D.dir === "next" && Ch(D, !0) && 0 < D.limit) {
						var O = D.valueMapper, P = Eh(D, D.table.core.schema);
						return D.table.core.query({
							trans: u,
							limit: D.limit,
							values: !0,
							query: {
								index: P,
								range: D.range
							}
						}).then(function(u) {
							return u = u.result, O ? u.map(O) : u;
						});
					}
					var F = [];
					return Oh(D, function(u) {
						return F.push(u);
					}, u, D.table.core).then(function() {
						return F;
					});
				}, u);
			}, Nh.prototype.offset = function(u) {
				var E = this._ctx;
				return u <= 0 || (E.offset += u, Ch(E) ? Th(E, function() {
					var E = u;
					return function(u, D) {
						return E === 0 || (E === 1 ? --E : D(function() {
							u.advance(E), E = 0;
						}), !1);
					};
				}) : Th(E, function() {
					var E = u;
					return function() {
						return --E < 0;
					};
				})), this;
			}, Nh.prototype.limit = function(u) {
				return this._ctx.limit = Math.min(this._ctx.limit, u), Th(this._ctx, function() {
					var E = u;
					return function(u, D, O) {
						return --E <= 0 && D(O), 0 <= E;
					};
				}, !0), this;
			}, Nh.prototype.until = function(u, E) {
				return wh(this._ctx, function(D, O, P) {
					return !u(D.value) || (O(P), E);
				}), this;
			}, Nh.prototype.first = function(u) {
				return this.limit(1).toArray(function(u) {
					return u[0];
				}).then(u);
			}, Nh.prototype.last = function(u) {
				return this.reverse().first(u);
			}, Nh.prototype.filter = function(u) {
				var E;
				return wh(this._ctx, function(E) {
					return u(E.value);
				}), (E = this._ctx).isMatch = dh(E.isMatch, u), this;
			}, Nh.prototype.and = function(u) {
				return this.filter(u);
			}, Nh.prototype.or = function(u) {
				return new this.db.WhereClause(this._ctx.table, u, this);
			}, Nh.prototype.reverse = function() {
				return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
			}, Nh.prototype.desc = function() {
				return this.reverse();
			}, Nh.prototype.eachKey = function(u) {
				var E = this._ctx;
				return E.keysOnly = !E.isMatch, this.each(function(E, D) {
					u(D.key, D);
				});
			}, Nh.prototype.eachUniqueKey = function(u) {
				return this._ctx.unique = "unique", this.eachKey(u);
			}, Nh.prototype.eachPrimaryKey = function(u) {
				var E = this._ctx;
				return E.keysOnly = !E.isMatch, this.each(function(E, D) {
					u(D.primaryKey, D);
				});
			}, Nh.prototype.keys = function(u) {
				var E = this._ctx;
				E.keysOnly = !E.isMatch;
				var D = [];
				return this.each(function(u, E) {
					D.push(E.key);
				}).then(function() {
					return D;
				}).then(u);
			}, Nh.prototype.primaryKeys = function(u) {
				var E = this._ctx;
				if (E.dir === "next" && Ch(E, !0) && 0 < E.limit) return this._read(function(u) {
					var D = Eh(E, E.table.core.schema);
					return E.table.core.query({
						trans: u,
						values: !1,
						limit: E.limit,
						query: {
							index: D,
							range: E.range
						}
					});
				}).then(function(u) {
					return u.result;
				}).then(u);
				E.keysOnly = !E.isMatch;
				var D = [];
				return this.each(function(u, E) {
					D.push(E.primaryKey);
				}).then(function() {
					return D;
				}).then(u);
			}, Nh.prototype.uniqueKeys = function(u) {
				return this._ctx.unique = "unique", this.keys(u);
			}, Nh.prototype.firstKey = function(u) {
				return this.limit(1).keys(function(u) {
					return u[0];
				}).then(u);
			}, Nh.prototype.lastKey = function(u) {
				return this.reverse().firstKey(u);
			}, Nh.prototype.distinct = function() {
				var u = this._ctx, u = u.index && u.table.schema.idxByName[u.index];
				if (!u || !u.multi) return this;
				var E = {};
				return wh(this._ctx, function(u) {
					var D = u.primaryKey.toString(), u = J(E, D);
					return E[D] = !0, !u;
				}), this;
			}, Nh.prototype.modify = function(u) {
				var E = this, D = this._ctx;
				return this._write(function(O) {
					var F, I, R = typeof u == "function" ? u : (F = P(u), I = F.length, function(E) {
						for (var D = !1, O = 0; O < I; ++O) {
							var P = F[O], R = u[P], U = Dp(E, P);
							R instanceof Ah ? (Op(E, P, R.execute(U)), D = !0) : U !== R && (Op(E, P, R), D = !0);
						}
						return D;
					}), U = D.table.core, J = U.schema.primaryKey, _p = J.outbound, vp = J.extractKey, yp = 200, J = E.db._options.modifyChunkSize;
					J && (yp = typeof J == "object" ? J[U.name] || J["*"] || 200 : J);
					function bp(u, E) {
						var D = E.failures, E = E.numFailures;
						Sp += u - E;
						for (var O = 0, F = P(D); O < F.length; O++) {
							var I = F[O];
							xp.push(D[I]);
						}
					}
					var xp = [], Sp = 0, Cp = [], wp = u === Ph;
					return E.clone().primaryKeys().then(function(E) {
						function P(I) {
							var J = Math.min(yp, E.length - I), xp = E.slice(I, I + J);
							return (wp ? Promise.resolve([]) : U.getMany({
								trans: O,
								keys: xp,
								cache: "immutable"
							})).then(function(Sp) {
								var Cp = [], Tp = [], Ep = _p ? [] : null, Dp = wp ? xp : [];
								if (!wp) for (var Op = 0; Op < J; ++Op) {
									var kp = Sp[Op], Ap = {
										value: Fp(kp),
										primKey: E[I + Op]
									};
									R.call(Ap, Ap.value, Ap) !== !1 && (Ap.value == null ? Dp.push(E[I + Op]) : _p || hh(vp(kp), vp(Ap.value)) === 0 ? (Tp.push(Ap.value), _p && Ep.push(E[I + Op])) : (Dp.push(E[I + Op]), Cp.push(Ap.value)));
								}
								return Promise.resolve(0 < Cp.length && U.mutate({
									trans: O,
									type: "add",
									values: Cp
								}).then(function(u) {
									for (var E in u.failures) Dp.splice(parseInt(E), 1);
									bp(Cp.length, u);
								})).then(function() {
									return (0 < Tp.length || F && typeof u == "object") && U.mutate({
										trans: O,
										type: "put",
										keys: Ep,
										values: Tp,
										criteria: F,
										changeSpec: typeof u != "function" && u,
										isAdditionalChunk: 0 < I
									}).then(function(u) {
										return bp(Tp.length, u);
									});
								}).then(function() {
									return (0 < Dp.length || F && wp) && U.mutate({
										trans: O,
										type: "delete",
										keys: Dp,
										criteria: F,
										isAdditionalChunk: 0 < I
									}).then(function(u) {
										return vh(D.table, Dp, u);
									}).then(function(u) {
										return bp(Dp.length, u);
									});
								}).then(function() {
									return E.length > I + J && P(I + yp);
								});
							});
						}
						var F = Ch(D) && D.limit === Infinity && (typeof u != "function" || wp) && {
							index: D.index,
							range: D.range
						};
						return P(0).then(function() {
							if (0 < xp.length) throw new Yp("Error modifying one or more objects", xp, Sp, Cp);
							return E.length;
						});
					});
				});
			}, Nh.prototype.delete = function() {
				var u = this._ctx, E = u.range;
				return !Ch(u) || u.table.schema.yProps || !u.isPrimKey && E.type !== 3 ? this.modify(Ph) : this._write(function(D) {
					var O = u.table.core.schema.primaryKey, P = E;
					return u.table.core.count({
						trans: D,
						query: {
							index: O,
							range: P
						}
					}).then(function(E) {
						return u.table.core.mutate({
							trans: D,
							type: "deleteRange",
							range: P
						}).then(function(u) {
							var D = u.failures, u = u.numFailures;
							if (u) throw new Yp("Could not delete some values", Object.keys(D).map(function(u) {
								return D[u];
							}), E - u);
							return E - u;
						});
					});
				});
			}, Nh);
			function Nh() {}
			var Ph = function(u, E) {
				return E.value = null;
			};
			function Fh(u, E) {
				return u < E ? -1 : u === E ? 0 : 1;
			}
			function Ih(u, E) {
				return E < u ? -1 : u === E ? 0 : 1;
			}
			function Lh(u, E, D) {
				return u = u instanceof Hh ? new u.Collection(u) : u, u._ctx.error = new (D || TypeError)(E), u;
			}
			function Rh(u) {
				return new u.Collection(u, function() {
					return Vh("");
				}).limit(0);
			}
			function zh(u, E, D, O) {
				var P, F, I, R, U, J, _p, vp = D.length;
				if (!D.every(function(u) {
					return typeof u == "string";
				})) return Lh(u, oh);
				function yp(u) {
					P = u === "next" ? function(u) {
						return u.toUpperCase();
					} : function(u) {
						return u.toLowerCase();
					}, F = u === "next" ? function(u) {
						return u.toLowerCase();
					} : function(u) {
						return u.toUpperCase();
					}, I = u === "next" ? Fh : Ih;
					var E = D.map(function(u) {
						return {
							lower: F(u),
							upper: P(u)
						};
					}).sort(function(u, E) {
						return I(u.lower, E.lower);
					});
					R = E.map(function(u) {
						return u.upper;
					}), U = E.map(function(u) {
						return u.lower;
					}), _p = (J = u) === "next" ? "" : O;
				}
				yp("next"), u = new u.Collection(u, function() {
					return Bh(R[0], U[vp - 1] + O);
				}), u._ondirectionchange = function(u) {
					yp(u);
				};
				var bp = 0;
				return u._addAlgorithm(function(u, D, O) {
					var P = u.key;
					if (typeof P != "string") return !1;
					var yp = F(P);
					if (E(yp, U, bp)) return !0;
					for (var xp = null, Sp = bp; Sp < vp; ++Sp) {
						var Cp = function(u, E, D, O, P, F) {
							for (var I = Math.min(u.length, O.length), R = -1, U = 0; U < I; ++U) {
								var J = E[U];
								if (J !== O[U]) return P(u[U], D[U]) < 0 ? u.substr(0, U) + D[U] + D.substr(U + 1) : P(u[U], O[U]) < 0 ? u.substr(0, U) + O[U] + D.substr(U + 1) : 0 <= R ? u.substr(0, R) + E[R] + D.substr(R + 1) : null;
								P(u[U], J) < 0 && (R = U);
							}
							return I < O.length && F === "next" ? u + D.substr(u.length) : I < u.length && F === "prev" ? u.substr(0, D.length) : R < 0 ? null : u.substr(0, R) + O[R] + D.substr(R + 1);
						}(P, yp, R[Sp], U[Sp], I, J);
						Cp === null && xp === null ? bp = Sp + 1 : (xp === null || 0 < I(xp, Cp)) && (xp = Cp);
					}
					return D(xp === null ? O : function() {
						u.continue(xp + _p);
					}), !1;
				}), u;
			}
			function Bh(u, E, D, O) {
				return {
					type: 2,
					lower: u,
					upper: E,
					lowerOpen: D,
					upperOpen: O
				};
			}
			function Vh(u) {
				return {
					type: 1,
					lower: u,
					upper: u
				};
			}
			var Hh = (Object.defineProperty(Uh.prototype, "Collection", {
				get: function() {
					return this._ctx.table.db.Collection;
				},
				enumerable: !1,
				configurable: !0
			}), Uh.prototype.between = function(u, E, D, O) {
				D = D !== !1, O = O === !0;
				try {
					return 0 < this._cmp(u, E) || this._cmp(u, E) === 0 && (D || O) && (!D || !O) ? Rh(this) : new this.Collection(this, function() {
						return Bh(u, E, !D, !O);
					});
				} catch {
					return Lh(this, ah);
				}
			}, Uh.prototype.equals = function(u) {
				return u == null ? Lh(this, ah) : new this.Collection(this, function() {
					return Vh(u);
				});
			}, Uh.prototype.above = function(u) {
				return u == null ? Lh(this, ah) : new this.Collection(this, function() {
					return Bh(u, void 0, !0);
				});
			}, Uh.prototype.aboveOrEqual = function(u) {
				return u == null ? Lh(this, ah) : new this.Collection(this, function() {
					return Bh(u, void 0, !1);
				});
			}, Uh.prototype.below = function(u) {
				return u == null ? Lh(this, ah) : new this.Collection(this, function() {
					return Bh(void 0, u, !1, !0);
				});
			}, Uh.prototype.belowOrEqual = function(u) {
				return u == null ? Lh(this, ah) : new this.Collection(this, function() {
					return Bh(void 0, u);
				});
			}, Uh.prototype.startsWith = function(u) {
				return typeof u == "string" ? this.between(u, u + ih, !0, !0) : Lh(this, oh);
			}, Uh.prototype.startsWithIgnoreCase = function(u) {
				return u === "" ? this.startsWith(u) : zh(this, function(u, E) {
					return u.indexOf(E[0]) === 0;
				}, [u], ih);
			}, Uh.prototype.equalsIgnoreCase = function(u) {
				return zh(this, function(u, E) {
					return u === E[0];
				}, [u], "");
			}, Uh.prototype.anyOfIgnoreCase = function() {
				var u = Hp.apply(Vp, arguments);
				return u.length === 0 ? Rh(this) : zh(this, function(u, E) {
					return E.indexOf(u) !== -1;
				}, u, "");
			}, Uh.prototype.startsWithAnyOfIgnoreCase = function() {
				var u = Hp.apply(Vp, arguments);
				return u.length === 0 ? Rh(this) : zh(this, function(u, E) {
					return E.some(function(E) {
						return u.indexOf(E) === 0;
					});
				}, u, ih);
			}, Uh.prototype.anyOf = function() {
				var u = this, E = Hp.apply(Vp, arguments), D = this._cmp;
				try {
					E.sort(D);
				} catch {
					return Lh(this, ah);
				}
				if (E.length === 0) return Rh(this);
				var O = new this.Collection(this, function() {
					return Bh(E[0], E[E.length - 1]);
				});
				O._ondirectionchange = function(O) {
					D = O === "next" ? u._ascending : u._descending, E.sort(D);
				};
				var P = 0;
				return O._addAlgorithm(function(u, O, F) {
					for (var I = u.key; 0 < D(I, E[P]);) if (++P === E.length) return O(F), !1;
					return D(I, E[P]) === 0 || (O(function() {
						u.continue(E[P]);
					}), !1);
				}), O;
			}, Uh.prototype.notEqual = function(u) {
				return this.inAnyRange([[-Infinity, u], [u, this.db._maxKey]], {
					includeLowers: !1,
					includeUppers: !1
				});
			}, Uh.prototype.noneOf = function() {
				var u = Hp.apply(Vp, arguments);
				if (u.length === 0) return new this.Collection(this);
				try {
					u.sort(this._ascending);
				} catch {
					return Lh(this, ah);
				}
				var E = u.reduce(function(u, E) {
					return u ? u.concat([[u[u.length - 1][1], E]]) : [[-Infinity, E]];
				}, null);
				return E.push([u[u.length - 1], this.db._maxKey]), this.inAnyRange(E, {
					includeLowers: !1,
					includeUppers: !1
				});
			}, Uh.prototype.inAnyRange = function(u, E) {
				var D = this, O = this._cmp, P = this._ascending, F = this._descending, I = this._min, R = this._max;
				if (u.length === 0) return Rh(this);
				if (!u.every(function(u) {
					return u[0] !== void 0 && u[1] !== void 0 && P(u[0], u[1]) <= 0;
				})) return Lh(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", $p.InvalidArgument);
				var U = !E || E.includeLowers !== !1, J = E && E.includeUppers === !0, _p, vp = P;
				function yp(u, E) {
					return vp(u[0], E[0]);
				}
				try {
					(_p = u.reduce(function(u, E) {
						for (var D = 0, P = u.length; D < P; ++D) {
							var F = u[D];
							if (O(E[0], F[1]) < 0 && 0 < O(E[1], F[0])) {
								F[0] = I(F[0], E[0]), F[1] = R(F[1], E[1]);
								break;
							}
						}
						return D === P && u.push(E), u;
					}, [])).sort(yp);
				} catch {
					return Lh(this, ah);
				}
				var bp = 0, xp = J ? function(u) {
					return 0 < P(u, _p[bp][1]);
				} : function(u) {
					return 0 <= P(u, _p[bp][1]);
				}, Sp = U ? function(u) {
					return 0 < F(u, _p[bp][0]);
				} : function(u) {
					return 0 <= F(u, _p[bp][0]);
				}, Cp = xp, u = new this.Collection(this, function() {
					return Bh(_p[0][0], _p[_p.length - 1][1], !U, !J);
				});
				return u._ondirectionchange = function(u) {
					vp = u === "next" ? (Cp = xp, P) : (Cp = Sp, F), _p.sort(yp);
				}, u._addAlgorithm(function(u, E, O) {
					for (var F, I = u.key; Cp(I);) if (++bp === _p.length) return E(O), !1;
					return !xp(F = I) && !Sp(F) || (D._cmp(I, _p[bp][1]) === 0 || D._cmp(I, _p[bp][0]) === 0 || E(function() {
						vp === P ? u.continue(_p[bp][0]) : u.continue(_p[bp][1]);
					}), !1);
				}), u;
			}, Uh.prototype.startsWithAnyOf = function() {
				var u = Hp.apply(Vp, arguments);
				return u.every(function(u) {
					return typeof u == "string";
				}) ? u.length === 0 ? Rh(this) : this.inAnyRange(u.map(function(u) {
					return [u, u + ih];
				})) : Lh(this, "startsWithAnyOf() only works with strings");
			}, Uh);
			function Uh() {}
			function Wh(u) {
				return Bm(function(E) {
					return Gh(E), u(E.target.error), !1;
				});
			}
			function Gh(u) {
				u.stopPropagation && u.stopPropagation(), u.preventDefault && u.preventDefault();
			}
			var Kh = "storagemutated", qh = "x-storagemutated-1", Jh = xh(null, Kh), Yh = (Xh.prototype._lock = function() {
				return Tp(!wm.global), ++this._reculock, this._reculock !== 1 || wm.global || (wm.lockOwnerFor = this), this;
			}, Xh.prototype._unlock = function() {
				if (Tp(!wm.global), --this._reculock == 0) for (wm.global || (wm.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked();) {
					var u = this._blockedFuncs.shift();
					try {
						eh(u[1], u[0]);
					} catch {}
				}
				return this;
			}, Xh.prototype._locked = function() {
				return this._reculock && wm.lockOwnerFor !== this;
			}, Xh.prototype.create = function(u) {
				var E = this;
				if (!this.mode) return this;
				var D = this.db.idbdb, O = this.db._state.dbOpenError;
				if (Tp(!this.idbtrans), !u && !D) switch (O && O.name) {
					case "DatabaseClosedError": throw new $p.DatabaseClosed(O);
					case "MissingAPIError": throw new $p.MissingAPI(O.message, O);
					default: throw new $p.OpenFailed(O);
				}
				if (!this.active) throw new $p.TransactionInactive();
				return Tp(this._completion._state === null), (u = this.idbtrans = u || (this.db.core || D).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Bm(function(D) {
					Gh(D), E._reject(u.error);
				}), u.onabort = Bm(function(D) {
					Gh(D), E.active && E._reject(new $p.Abort(u.error)), E.active = !1, E.on("abort").fire(D);
				}), u.oncomplete = Bm(function() {
					E.active = !1, E._resolve(), "mutatedParts" in u && Jh.storagemutated.fire(u.mutatedParts);
				}), this;
			}, Xh.prototype._promise = function(u, E, D) {
				var O = this;
				if (u === "readwrite" && this.mode !== "readwrite") return rh(new $p.ReadOnly("Transaction is readonly"));
				if (!this.active) return rh(new $p.TransactionInactive());
				if (this._locked()) return new Om(function(P, F) {
					O._blockedFuncs.push([function() {
						O._promise(u, E, D).then(P, F);
					}, wm]);
				});
				if (D) return qm(function() {
					var u = new Om(function(u, D) {
						O._lock();
						var P = E(u, D, O);
						P && P.then && P.then(u, D);
					});
					return u.finally(function() {
						return O._unlock();
					}), u._lib = !0, u;
				});
				var P = new Om(function(u, D) {
					var P = E(u, D, O);
					P && P.then && P.then(u, D);
				});
				return P._lib = !0, P;
			}, Xh.prototype._root = function() {
				return this.parent ? this.parent._root() : this;
			}, Xh.prototype.waitFor = function(u) {
				var E, D = this._root(), O = Om.resolve(u);
				D._waitingFor ? D._waitingFor = D._waitingFor.then(function() {
					return O;
				}) : (D._waitingFor = O, D._waitingQueue = [], E = D.idbtrans.objectStore(D.storeNames[0]), function u() {
					for (++D._spinCount; D._waitingQueue.length;) D._waitingQueue.shift()();
					D._waitingFor && (E.get(-Infinity).onsuccess = u);
				}());
				var P = D._waitingFor;
				return new Om(function(u, E) {
					O.then(function(E) {
						return D._waitingQueue.push(Bm(u.bind(null, E)));
					}, function(u) {
						return D._waitingQueue.push(Bm(E.bind(null, u)));
					}).finally(function() {
						D._waitingFor === P && (D._waitingFor = null);
					});
				});
			}, Xh.prototype.abort = function() {
				this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new $p.Abort()));
			}, Xh.prototype.table = function(u) {
				var E = this._memoizedTables ||= {};
				if (J(E, u)) return E[u];
				var D = this.schema[u];
				if (!D) throw new $p.NotFound("Table " + u + " not part of transaction");
				return D = new this.db.Table(u, D, this), D.core = this.db.core.table(u), E[u] = D;
			}, Xh);
			function Xh() {}
			function Zh(u, E, D, O, P, F, I, R) {
				return {
					name: u,
					keyPath: E,
					unique: D,
					multi: O,
					auto: P,
					compound: F,
					src: (D && !I ? "&" : "") + (O ? "*" : "") + (P ? "++" : "") + Qh(E),
					type: R
				};
			}
			function Qh(u) {
				return typeof u == "string" ? u : u ? "[" + [].join.call(u, "+") + "]" : "";
			}
			function $h(u, E, D) {
				return {
					name: u,
					primKey: E,
					indexes: D,
					mappedClass: null,
					idxByName: (O = function(u) {
						return [u.name, u];
					}, D.reduce(function(u, E, D) {
						return D = O(E, D), D && (u[D[0]] = D[1]), u;
					}, {}))
				};
				var O;
			}
			var eg = function(u) {
				try {
					return u.only([[]]), eg = function() {
						return [[]];
					}, [[]];
				} catch {
					return eg = function() {
						return ih;
					}, ih;
				}
			};
			function tg(u) {
				return u == null ? function() {} : typeof u == "string" ? (E = u).split(".").length === 1 ? function(u) {
					return u[E];
				} : function(u) {
					return Dp(u, E);
				} : function(E) {
					return Dp(E, u);
				};
				var E;
			}
			function ng(u) {
				return [].slice.call(u);
			}
			var rg = 0;
			function ig(u) {
				return u == null ? ":id" : typeof u == "string" ? u : `[${u.join("+")}]`;
			}
			function ag(u, E, D) {
				function O(u) {
					if (u.type === 3) return null;
					if (u.type === 4) throw Error("Cannot convert never type to IDBKeyRange");
					var D = u.lower, O = u.upper, P = u.lowerOpen, u = u.upperOpen;
					return D === void 0 ? O === void 0 ? null : E.upperBound(O, !!u) : O === void 0 ? E.lowerBound(D, !!P) : E.bound(D, O, !!P, !!u);
				}
				function P(u) {
					var E, D = u.name;
					return {
						name: D,
						schema: u,
						mutate: function(u) {
							var E = u.trans, P = u.type, F = u.keys, I = u.values, R = u.range;
							return new Promise(function(u, U) {
								u = Bm(u);
								var J = E.objectStore(D), _p = J.keyPath == null, vp = P === "put" || P === "add";
								if (!vp && P !== "delete" && P !== "deleteRange") throw Error("Invalid operation type: " + P);
								var yp, bp = (F || I || { length: 1 }).length;
								if (F && I && F.length !== I.length) throw Error("Given keys array must have same length as given values array.");
								if (bp === 0) return u({
									numFailures: 0,
									failures: {},
									results: [],
									lastResult: void 0
								});
								function xp(u) {
									++wp, Gh(u);
								}
								var Sp = [], Cp = [], wp = 0;
								if (P === "deleteRange") {
									if (R.type === 4) return u({
										numFailures: wp,
										failures: Cp,
										results: [],
										lastResult: void 0
									});
									R.type === 3 ? Sp.push(yp = J.clear()) : Sp.push(yp = J.delete(O(R)));
								} else {
									var _p = vp ? _p ? [I, F] : [I, null] : [F, null], Tp = _p[0], Ep = _p[1];
									if (vp) for (var Dp = 0; Dp < bp; ++Dp) Sp.push(yp = Ep && Ep[Dp] !== void 0 ? J[P](Tp[Dp], Ep[Dp]) : J[P](Tp[Dp])), yp.onerror = xp;
									else for (Dp = 0; Dp < bp; ++Dp) Sp.push(yp = J[P](Tp[Dp])), yp.onerror = xp;
								}
								function Op(E) {
									E = E.target.result, Sp.forEach(function(u, E) {
										return u.error != null && (Cp[E] = u.error);
									}), u({
										numFailures: wp,
										failures: Cp,
										results: P === "delete" ? F : Sp.map(function(u) {
											return u.result;
										}),
										lastResult: E
									});
								}
								yp.onerror = function(u) {
									xp(u), Op(u);
								}, yp.onsuccess = Op;
							});
						},
						getMany: function(u) {
							var E = u.trans, O = u.keys;
							return new Promise(function(u, P) {
								u = Bm(u);
								for (var F, I = E.objectStore(D), R = O.length, U = Array(R), J = 0, _p = 0, vp = function(E) {
									E = E.target, U[E._pos] = E.result, ++_p === J && u(U);
								}, yp = Wh(P), bp = 0; bp < R; ++bp) O[bp] != null && ((F = I.get(O[bp]))._pos = bp, F.onsuccess = vp, F.onerror = yp, ++J);
								J === 0 && u(U);
							});
						},
						get: function(u) {
							var E = u.trans, O = u.key;
							return new Promise(function(u, P) {
								u = Bm(u);
								var F = E.objectStore(D).get(O);
								F.onsuccess = function(E) {
									return u(E.target.result);
								}, F.onerror = Wh(P);
							});
						},
						query: (E = _p, function(u) {
							return new Promise(function(P, F) {
								P = Bm(P);
								var I, R, U, J = u.trans, _p = u.values, vp = u.limit, yp = u.query, bp = vp === Infinity ? void 0 : vp, xp = yp.index, yp = yp.range, J = J.objectStore(D), xp = xp.isPrimaryKey ? J : J.index(xp.name), yp = O(yp);
								if (vp === 0) return P({ result: [] });
								E ? ((bp = _p ? xp.getAll(yp, bp) : xp.getAllKeys(yp, bp)).onsuccess = function(u) {
									return P({ result: u.target.result });
								}, bp.onerror = Wh(F)) : (I = 0, R = !_p && "openKeyCursor" in xp ? xp.openKeyCursor(yp) : xp.openCursor(yp), U = [], R.onsuccess = function(u) {
									var E = R.result;
									return E ? (U.push(_p ? E.value : E.primaryKey), ++I === vp ? P({ result: U }) : void E.continue()) : P({ result: U });
								}, R.onerror = Wh(F));
							});
						}),
						openCursor: function(u) {
							var E = u.trans, P = u.values, F = u.query, I = u.reverse, R = u.unique;
							return new Promise(function(u, U) {
								u = Bm(u);
								var J = F.index, _p = F.range, vp = E.objectStore(D), vp = J.isPrimaryKey ? vp : vp.index(J.name), J = I ? R ? "prevunique" : "prev" : R ? "nextunique" : "next", yp = !P && "openKeyCursor" in vp ? vp.openKeyCursor(O(_p), J) : vp.openCursor(O(_p), J);
								yp.onerror = Wh(U), yp.onsuccess = Bm(function(D) {
									var O, P, F, I, R = yp.result;
									R ? (R.___id = ++rg, R.done = !1, O = R.continue.bind(R), P = (P = R.continuePrimaryKey) && P.bind(R), F = R.advance.bind(R), I = function() {
										throw Error("Cursor not stopped");
									}, R.trans = E, R.stop = R.continue = R.continuePrimaryKey = R.advance = function() {
										throw Error("Cursor not started");
									}, R.fail = Bm(U), R.next = function() {
										var u = this, E = 1;
										return this.start(function() {
											return E-- ? u.continue() : u.stop();
										}).then(function() {
											return u;
										});
									}, R.start = function(u) {
										function E() {
											if (yp.result) try {
												u();
											} catch (u) {
												R.fail(u);
											}
											else R.done = !0, R.start = function() {
												throw Error("Cursor behind last entry");
											}, R.stop();
										}
										var D = new Promise(function(u, E) {
											u = Bm(u), yp.onerror = Wh(E), R.fail = E, R.stop = function(E) {
												R.stop = R.continue = R.continuePrimaryKey = R.advance = I, u(E);
											};
										});
										return yp.onsuccess = Bm(function(u) {
											yp.onsuccess = E, E();
										}), R.continue = O, R.continuePrimaryKey = P, R.advance = F, E(), D;
									}, u(R)) : u(null);
								}, U);
							});
						},
						count: function(u) {
							var E = u.query, P = u.trans, F = E.index, I = E.range;
							return new Promise(function(u, E) {
								var R = P.objectStore(D), U = F.isPrimaryKey ? R : R.index(F.name), R = O(I), U = R ? U.count(R) : U.count();
								U.onsuccess = Bm(function(E) {
									return u(E.target.result);
								}), U.onerror = Wh(E);
							});
						}
					};
				}
				var I, R, U, J = (R = D, U = ng((I = u).objectStoreNames), {
					schema: {
						name: I.name,
						tables: U.map(function(u) {
							return R.objectStore(u);
						}).map(function(u) {
							var E = u.keyPath, D = u.autoIncrement, O = F(E), P = {}, D = {
								name: u.name,
								primaryKey: {
									name: null,
									isPrimaryKey: !0,
									outbound: E == null,
									compound: O,
									keyPath: E,
									autoIncrement: D,
									unique: !0,
									extractKey: tg(E)
								},
								indexes: ng(u.indexNames).map(function(E) {
									return u.index(E);
								}).map(function(u) {
									var E = u.name, D = u.unique, O = u.multiEntry, u = u.keyPath, O = {
										name: E,
										compound: F(u),
										keyPath: u,
										unique: D,
										multiEntry: O,
										extractKey: tg(u)
									};
									return P[ig(u)] = O;
								}),
								getIndexByKeyPath: function(u) {
									return P[ig(u)];
								}
							};
							return P[":id"] = D.primaryKey, E != null && (P[ig(E)] = D.primaryKey), D;
						})
					},
					hasGetAll: 0 < U.length && "getAll" in R.objectStore(U[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
				}), D = J.schema, _p = J.hasGetAll, J = D.tables.map(P), vp = {};
				return J.forEach(function(u) {
					return vp[u.name] = u;
				}), {
					stack: "dbcore",
					transaction: u.transaction.bind(u),
					table: function(u) {
						if (!vp[u]) throw Error(`Table '${u}' not found`);
						return vp[u];
					},
					MIN_KEY: -Infinity,
					MAX_KEY: eg(E),
					schema: D
				};
			}
			function og(u, D, O, P) {
				var F = O.IDBKeyRange;
				return O.indexedDB, { dbcore: (P = ag(D, F, P), u.dbcore.reduce(function(u, D) {
					return D = D.create, E(E({}, u), D(u));
				}, P)) };
			}
			function sg(u, E) {
				var D = E.db, E = og(u._middlewares, D, u._deps, E);
				u.core = E.dbcore, u.tables.forEach(function(E) {
					var D = E.name;
					u.core.schema.tables.some(function(u) {
						return u.name === D;
					}) && (E.core = u.core.table(D), u[D] instanceof u.Table && (u[D].core = E.core));
				});
			}
			function cg(u, E, D, O) {
				D.forEach(function(D) {
					var P = O[D];
					E.forEach(function(E) {
						var O = function u(E, D) {
							return xp(E, D) || (E = R(E)) && u(E, D);
						}(E, D);
						(!O || "value" in O && O.value === void 0) && (E === u.Transaction.prototype || E instanceof u.Transaction ? yp(E, D, {
							get: function() {
								return this.table(D);
							},
							set: function(u) {
								vp(this, D, {
									value: u,
									writable: !0,
									configurable: !0,
									enumerable: !0
								});
							}
						}) : E[D] = new u.Table(D, P));
					});
				});
			}
			function lg(u, E) {
				E.forEach(function(E) {
					for (var D in E) E[D] instanceof u.Table && delete E[D];
				});
			}
			function ug(u, E) {
				return u._cfg.version - E._cfg.version;
			}
			function dg(u, E, D, O) {
				var F = u._dbSchema;
				D.objectStoreNames.contains("$meta") && !F.$meta && (F.$meta = $h("$meta", yg("")[0], []), u._storeNames.push("$meta"));
				var I = u._createTransaction("readwrite", u._storeNames, F);
				I.create(D), I._completion.catch(O);
				var R = I._reject.bind(I), U = wm.transless || wm;
				qm(function() {
					return wm.trans = I, wm.transless = U, E === 0 ? (P(F).forEach(function(u) {
						mg(D, u, F[u].primKey, F[u].indexes);
					}), sg(u, D), void Om.follow(function() {
						return u.on.populate.fire(I);
					}).catch(R)) : (sg(u, D), J = E, ((O = I).storeNames.includes("$meta") ? O.table("$meta").get("version").then(function(u) {
						return u ?? J;
					}) : Om.resolve(J)).then(function(E) {
						return F = E, R = I, U = D, J = [], E = (O = u)._versions, _p = O._dbSchema = _g(0, O.idbdb, U), (E = E.filter(function(u) {
							return u._cfg.version >= F;
						})).length === 0 ? Om.resolve() : (E.forEach(function(u) {
							J.push(function() {
								var E = _p, D = u._cfg.dbschema;
								vg(O, E, U), vg(O, D, U), _p = O._dbSchema = D;
								var I = pg(E, D);
								I.add.forEach(function(u) {
									mg(U, u[0], u[1].primKey, u[1].indexes);
								}), I.change.forEach(function(u) {
									if (u.recreate) throw new $p.Upgrade("Not yet support for changing primary key");
									var E = U.objectStore(u.name);
									u.add.forEach(function(u) {
										return gg(E, u);
									}), u.change.forEach(function(u) {
										E.deleteIndex(u.name), gg(E, u);
									}), u.del.forEach(function(u) {
										return E.deleteIndex(u);
									});
								});
								var J = u._cfg.contentUpgrade;
								if (J && u._cfg.version > F) {
									sg(O, U), R._memoizedTables = {};
									var vp = kp(D);
									I.del.forEach(function(u) {
										vp[u] = E[u];
									}), lg(O, [O.Transaction.prototype]), cg(O, [O.Transaction.prototype], P(vp), vp), R.schema = vp;
									var yp, bp = Up(J);
									return bp && Jm(), I = Om.follow(function() {
										var u;
										(yp = J(R)) && bp && (u = Ym.bind(null, null), yp.then(u, u));
									}), yp && typeof yp.then == "function" ? Om.resolve(yp) : I.then(function() {
										return yp;
									});
								}
							}), J.push(function(E) {
								var D = u._cfg.dbschema, P = E;
								[].slice.call(P.db.objectStoreNames).forEach(function(u) {
									return D[u] == null && P.db.deleteObjectStore(u);
								}), lg(O, [O.Transaction.prototype]), cg(O, [O.Transaction.prototype], O._storeNames, O._dbSchema), R.schema = O._dbSchema;
							}), J.push(function(E) {
								O.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(O.idbdb.version / 10) === u._cfg.version ? (O.idbdb.deleteObjectStore("$meta"), delete O._dbSchema.$meta, O._storeNames = O._storeNames.filter(function(u) {
									return u !== "$meta";
								})) : E.objectStore("$meta").put(u._cfg.version, "version"));
							});
						}), function u() {
							return J.length ? Om.resolve(J.shift()(R.idbtrans)).then(u) : Om.resolve();
						}().then(function() {
							hg(_p, U);
						}));
						var O, F, R, U, J, _p;
					}).catch(R));
					var O, J;
				});
			}
			function fg(u, E) {
				hg(u._dbSchema, E), E.db.version % 10 != 0 || E.objectStoreNames.contains("$meta") || E.db.createObjectStore("$meta").add(Math.ceil(E.db.version / 10 - 1), "version");
				var D = _g(0, u.idbdb, E);
				vg(u, u._dbSchema, E);
				for (var O = 0, P = pg(D, u._dbSchema).change; O < P.length; O++) {
					var F = function(u) {
						if (u.change.length || u.recreate) return console.warn(`Unable to patch indexes of table ${u.name} because it has changes on the type of index or primary key.`), { value: void 0 };
						var D = E.objectStore(u.name);
						u.add.forEach(function(E) {
							dm && console.debug(`Dexie upgrade patch: Creating missing index ${u.name}.${E.src}`), gg(D, E);
						});
					}(P[O]);
					if (typeof F == "object") return F.value;
				}
			}
			function pg(u, E) {
				var D, O = {
					del: [],
					add: [],
					change: []
				};
				for (D in u) E[D] || O.del.push(D);
				for (D in E) {
					var P = u[D], F = E[D];
					if (P) {
						var I = {
							name: D,
							def: F,
							recreate: !1,
							del: [],
							add: [],
							change: []
						};
						if ("" + (P.primKey.keyPath || "") != "" + (F.primKey.keyPath || "") || P.primKey.auto !== F.primKey.auto) I.recreate = !0, O.change.push(I);
						else {
							var R = P.idxByName, U = F.idxByName, J = void 0;
							for (J in R) U[J] || I.del.push(J);
							for (J in U) {
								var _p = R[J], vp = U[J];
								_p ? _p.src !== vp.src && I.change.push(vp) : I.add.push(vp);
							}
							(0 < I.del.length || 0 < I.add.length || 0 < I.change.length) && O.change.push(I);
						}
					} else O.add.push([D, F]);
				}
				return O;
			}
			function mg(u, E, D, O) {
				var P = u.db.createObjectStore(E, D.keyPath ? {
					keyPath: D.keyPath,
					autoIncrement: D.auto
				} : { autoIncrement: D.auto });
				return O.forEach(function(u) {
					return gg(P, u);
				}), P;
			}
			function hg(u, E) {
				P(u).forEach(function(D) {
					E.db.objectStoreNames.contains(D) || (dm && console.debug("Dexie: Creating missing table", D), mg(E, D, u[D].primKey, u[D].indexes));
				});
			}
			function gg(u, E) {
				u.createIndex(E.name, E.keyPath, {
					unique: E.unique,
					multiEntry: E.multi
				});
			}
			function _g(u, E, D) {
				var O = {};
				return Cp(E.objectStoreNames, 0).forEach(function(u) {
					for (var E = D.objectStore(u), P = Zh(Qh(U = E.keyPath), U || "", !0, !1, !!E.autoIncrement, U && typeof U != "string", !0), F = [], I = 0; I < E.indexNames.length; ++I) {
						var R = E.index(E.indexNames[I]), U = R.keyPath, R = Zh(R.name, U, !!R.unique, !!R.multiEntry, !1, U && typeof U != "string", !1);
						F.push(R);
					}
					O[u] = $h(u, P, F);
				}), O;
			}
			function vg(u, E, D) {
				for (var P = D.db.objectStoreNames, F = 0; F < P.length; ++F) {
					var I = P[F], R = D.objectStore(I);
					u._hasGetAll = "getAll" in R;
					for (var U = 0; U < R.indexNames.length; ++U) {
						var J = R.indexNames[U], _p = R.index(J).keyPath, vp = typeof _p == "string" ? _p : "[" + Cp(_p).join("+") + "]";
						!E[I] || (_p = E[I].idxByName[vp]) && (_p.name = J, delete E[I].idxByName[vp], E[I].idxByName[J] = _p);
					}
				}
				typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && O.WorkerGlobalScope && O instanceof O.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (u._hasGetAll = !1);
			}
			function yg(u) {
				return u.split(",").map(function(u, E) {
					var D = u.split(":"), O = (P = D[1])?.trim(), P = (u = D[0].trim()).replace(/([&*]|\+\+)/g, ""), D = /^\[/.test(P) ? P.match(/^\[(.*)\]$/)[1].split("+") : P;
					return Zh(P, D || null, /\&/.test(u), /\*/.test(u), /\+\+/.test(u), F(D), E === 0, O);
				});
			}
			var bg = (xg.prototype._createTableSchema = $h, xg.prototype._parseIndexSyntax = yg, xg.prototype._parseStoresSpec = function(u, E) {
				var D = this;
				P(u).forEach(function(O) {
					if (u[O] !== null) {
						var P = D._parseIndexSyntax(u[O]), F = P.shift();
						if (!F) throw new $p.Schema("Invalid schema for table " + O + ": " + u[O]);
						if (F.unique = !0, F.multi) throw new $p.Schema("Primary key cannot be multiEntry*");
						P.forEach(function(u) {
							if (u.auto) throw new $p.Schema("Only primary key can be marked as autoIncrement (++)");
							if (!u.keyPath) throw new $p.Schema("Index must have a name and cannot be an empty string");
						}), P = D._createTableSchema(O, F, P), E[O] = P;
					}
				});
			}, xg.prototype.stores = function(u) {
				var E = this.db;
				this._cfg.storesSource = this._cfg.storesSource ? I(this._cfg.storesSource, u) : u;
				var u = E._versions, D = {}, O = {};
				return u.forEach(function(u) {
					I(D, u._cfg.storesSource), O = u._cfg.dbschema = {}, u._parseStoresSpec(D, O);
				}), E._dbSchema = O, lg(E, [
					E._allTables,
					E,
					E.Transaction.prototype
				]), cg(E, [
					E._allTables,
					E,
					E.Transaction.prototype,
					this._cfg.tables
				], P(O), O), E._storeNames = P(O), this;
			}, xg.prototype.upgrade = function(u) {
				return this._cfg.contentUpgrade = um(this._cfg.contentUpgrade || nm, u), this;
			}, xg);
			function xg() {}
			function Sg(u, E) {
				var D = u._dbNamesDB;
				return D || (D = u._dbNamesDB = new s_(ch, {
					addons: [],
					indexedDB: u,
					IDBKeyRange: E
				})).version(1).stores({ dbnames: "name" }), D.table("dbnames");
			}
			function Cg(u) {
				return u && typeof u.databases == "function";
			}
			function wg(u) {
				return qm(function() {
					return wm.letThrough = !0, u();
				});
			}
			function Tg(u) {
				return !("from" in u);
			}
			var Eg = function(u, E) {
				if (!this) {
					var D = new Eg();
					return u && "d" in u && I(D, u), D;
				}
				I(this, arguments.length ? {
					d: 1,
					from: u,
					to: 1 < arguments.length ? E : u
				} : { d: 0 });
			};
			function Dg(u, E, D) {
				var O = hh(E, D);
				if (!isNaN(O)) {
					if (0 < O) throw RangeError();
					if (Tg(u)) return I(u, {
						from: E,
						to: D,
						d: 1
					});
					var P = u.l, O = u.r;
					if (hh(D, u.from) < 0) return P ? Dg(P, E, D) : u.l = {
						from: E,
						to: D,
						d: 1,
						l: null,
						r: null
					}, jg(u);
					if (0 < hh(E, u.to)) return O ? Dg(O, E, D) : u.r = {
						from: E,
						to: D,
						d: 1,
						l: null,
						r: null
					}, jg(u);
					hh(E, u.from) < 0 && (u.from = E, u.l = null, u.d = O ? O.d + 1 : 1), 0 < hh(D, u.to) && (u.to = D, u.r = null, u.d = u.l ? u.l.d + 1 : 1), D = !u.r, P && !u.l && Og(u, P), O && D && Og(u, O);
				}
			}
			function Og(u, E) {
				Tg(E) || function u(E, D) {
					var O = D.from, P = D.to, F = D.l, D = D.r;
					Dg(E, O, P), F && u(E, F), D && u(E, D);
				}(u, E);
			}
			function kg(u, E) {
				var D = Ag(E), O = D.next();
				if (O.done) return !1;
				for (var P = O.value, F = Ag(u), I = F.next(P.from), R = I.value; !O.done && !I.done;) {
					if (hh(R.from, P.to) <= 0 && 0 <= hh(R.to, P.from)) return !0;
					hh(P.from, R.from) < 0 ? P = (O = D.next(R.from)).value : R = (I = F.next(P.from)).value;
				}
				return !1;
			}
			function Ag(u) {
				var E = Tg(u) ? null : {
					s: 0,
					n: u
				};
				return { next: function(u) {
					for (var D = 0 < arguments.length; E;) switch (E.s) {
						case 0: if (E.s = 1, D) for (; E.n.l && hh(u, E.n.from) < 0;) E = {
							up: E,
							n: E.n.l,
							s: 1
						};
						else for (; E.n.l;) E = {
							up: E,
							n: E.n.l,
							s: 1
						};
						case 1: if (E.s = 2, !D || hh(u, E.n.to) <= 0) return {
							value: E.n,
							done: !1
						};
						case 2: if (E.n.r) {
							E.s = 3, E = {
								up: E,
								n: E.n.r,
								s: 0
							};
							continue;
						}
						case 3: E = E.up;
					}
					return { done: !0 };
				} };
			}
			function jg(u) {
				var D, O, P = ((D = u.r)?.d || 0) - ((O = u.l)?.d || 0), F = 1 < P ? "r" : P < -1 ? "l" : "";
				F && (D = F == "r" ? "l" : "r", O = E({}, u), P = u[F], u.from = P.from, u.to = P.to, u[F] = P[F], O[F] = P[D], (u[D] = O).d = Mg(O)), u.d = Mg(u);
			}
			function Mg(u) {
				var E = u.r, u = u.l;
				return (E ? u ? Math.max(E.d, u.d) : E.d : u ? u.d : 0) + 1;
			}
			function Ng(u, E) {
				return P(E).forEach(function(D) {
					u[D] ? Og(u[D], E[D]) : u[D] = function u(E) {
						var D, O, P = {};
						for (D in E) J(E, D) && (O = E[D], P[D] = !O || typeof O != "object" || Np.has(O.constructor) ? O : u(O));
						return P;
					}(E[D]);
				}), u;
			}
			function Pg(u, E) {
				return u.all || E.all || Object.keys(u).some(function(D) {
					return E[D] && kg(E[D], u[D]);
				});
			}
			_p(Eg.prototype, ((Gp = {
				add: function(u) {
					return Og(this, u), this;
				},
				addKey: function(u) {
					return Dg(this, u, u), this;
				},
				addKeys: function(u) {
					var E = this;
					return u.forEach(function(u) {
						return Dg(E, u, u);
					}), this;
				},
				hasKey: function(u) {
					var E = Ag(this).next(u).value;
					return E && hh(E.from, u) <= 0 && 0 <= hh(E.to, u);
				}
			})[Rp] = function() {
				return Ag(this);
			}, Gp));
			var Fg = {}, Ig = {}, Lg = !1;
			function Rg(u) {
				Ng(Ig, u), Lg || (Lg = !0, setTimeout(function() {
					Lg = !1, zg(Ig, !(Ig = {}));
				}, 0));
			}
			function zg(u, E) {
				E === void 0 && (E = !1);
				var D = /* @__PURE__ */ new Set();
				if (u.all) for (var O = 0, P = Object.values(Fg); O < P.length; O++) Bg(I = P[O], u, D, E);
				else for (var F in u) {
					var I, R = /^idb\:\/\/(.*)\/(.*)\//.exec(F);
					R && (F = R[1], R = R[2], (I = Fg[`idb://${F}/${R}`]) && Bg(I, u, D, E));
				}
				D.forEach(function(u) {
					return u();
				});
			}
			function Bg(u, E, D, O) {
				for (var P = [], F = 0, I = Object.entries(u.queries.query); F < I.length; F++) {
					for (var R = I[F], U = R[0], J = [], _p = 0, vp = R[1]; _p < vp.length; _p++) {
						var yp = vp[_p];
						Pg(E, yp.obsSet) ? yp.subscribers.forEach(function(u) {
							return D.add(u);
						}) : O && J.push(yp);
					}
					O && P.push([U, J]);
				}
				if (O) for (var bp = 0, xp = P; bp < xp.length; bp++) {
					var Sp = xp[bp], U = Sp[0], J = Sp[1];
					u.queries.query[U] = J;
				}
			}
			function Vg(u) {
				var E = u._state, D = u._deps.indexedDB;
				if (E.isBeingOpened || u.idbdb) return E.dbReadyPromise.then(function() {
					return E.dbOpenError ? rh(E.dbOpenError) : u;
				});
				E.isBeingOpened = !0, E.dbOpenError = null, E.openComplete = !1;
				var O = E.openCanceller, F = Math.round(10 * u.verno), I = !1;
				function R() {
					if (E.openCanceller !== O) throw new $p.DatabaseClosed("db.open() was cancelled");
				}
				function U() {
					return new Om(function(O, J) {
						if (R(), !D) throw new $p.MissingAPI();
						var _p = u.name, bp = E.autoSchema || !F ? D.open(_p) : D.open(_p, F);
						if (!bp) throw new $p.MissingAPI();
						bp.onerror = Wh(J), bp.onblocked = Bm(u._fireOnBlocked), bp.onupgradeneeded = Bm(function(O) {
							var P;
							vp = bp.transaction, E.autoSchema && !u._options.allowEmptyDB ? (bp.onerror = Gh, vp.abort(), bp.result.close(), (P = D.deleteDatabase(_p)).onsuccess = P.onerror = Bm(function() {
								J(new $p.NoSuchDatabase(`Database ${_p} doesnt exist`));
							})) : (vp.onerror = Wh(J), O = O.oldVersion > 2 ** 62 ? 0 : O.oldVersion, yp = O < 1, u.idbdb = bp.result, I && fg(u, vp), dg(u, O / 10, vp, J));
						}, J), bp.onsuccess = Bm(function() {
							vp = null;
							var D, R, J, xp, Sp, wp = u.idbdb = bp.result, Tp = Cp(wp.objectStoreNames);
							if (0 < Tp.length) try {
								var Ep = wp.transaction((xp = Tp).length === 1 ? xp[0] : xp, "readonly");
								if (E.autoSchema) R = wp, J = Ep, (D = u).verno = R.version / 10, J = D._dbSchema = _g(0, R, J), D._storeNames = Cp(R.objectStoreNames, 0), cg(D, [D._allTables], P(J), J);
								else if (vg(u, u._dbSchema, Ep), ((Sp = pg(_g(0, (Sp = u).idbdb, Ep), Sp._dbSchema)).add.length || Sp.change.some(function(u) {
									return u.add.length || u.change.length;
								})) && !I) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), wp.close(), F = wp.version + 1, I = !0, O(U());
								sg(u, Ep);
							} catch {}
							sh.push(u), wp.onversionchange = Bm(function(D) {
								E.vcFired = !0, u.on("versionchange").fire(D);
							}), wp.onclose = Bm(function(E) {
								u.on("close").fire(E);
							}), yp && (Sp = u._deps, Ep = _p, wp = Sp.indexedDB, Sp = Sp.IDBKeyRange, Cg(wp) || Ep === ch || Sg(wp, Sp).put({ name: Ep }).catch(nm)), O();
						}, J);
					}).catch(function(u) {
						switch (u?.name) {
							case "UnknownError":
								if (0 < E.PR1398_maxLoop) return E.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), U();
								break;
							case "VersionError": if (0 < F) return F = 0, U();
						}
						return Om.reject(u);
					});
				}
				var J, _p = E.dbReadyResolve, vp = null, yp = !1;
				return Om.race([O, (typeof navigator > "u" ? Om.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(u) {
					function E() {
						return indexedDB.databases().finally(u);
					}
					J = setInterval(E, 100), E();
				}).finally(function() {
					return clearInterval(J);
				}) : Promise.resolve()).then(U)]).then(function() {
					return R(), E.onReadyBeingFired = [], Om.resolve(wg(function() {
						return u.on.ready.fire(u.vip);
					})).then(function D() {
						if (0 < E.onReadyBeingFired.length) {
							var O = E.onReadyBeingFired.reduce(um, nm);
							return E.onReadyBeingFired = [], Om.resolve(wg(function() {
								return O(u.vip);
							})).then(D);
						}
					});
				}).finally(function() {
					E.openCanceller === O && (E.onReadyBeingFired = null, E.isBeingOpened = !1);
				}).catch(function(D) {
					E.dbOpenError = D;
					try {
						vp && vp.abort();
					} catch {}
					return O === E.openCanceller && u._close(), rh(D);
				}).finally(function() {
					E.openComplete = !0, _p();
				}).then(function() {
					var E;
					return yp && (E = {}, u.tables.forEach(function(D) {
						D.schema.indexes.forEach(function(O) {
							O.name && (E[`idb://${u.name}/${D.name}/${O.name}`] = new Eg(-Infinity, [[[]]]));
						}), E[`idb://${u.name}/${D.name}/`] = E[`idb://${u.name}/${D.name}/:dels`] = new Eg(-Infinity, [[[]]]);
					}), Jh(Kh).fire(E), zg(E, !0)), u;
				});
			}
			function Hg(u) {
				function E(E) {
					return u.next(E);
				}
				var D = P(E), O = P(function(E) {
					return u.throw(E);
				});
				function P(u) {
					return function(E) {
						var P = u(E), E = P.value;
						return P.done ? E : E && typeof E.then == "function" ? E.then(D, O) : F(E) ? Promise.all(E).then(D, O) : D(E);
					};
				}
				return P(E)();
			}
			function Ug(u, E, D) {
				for (var O = F(u) ? u.slice() : [u], P = 0; P < D; ++P) O.push(E);
				return O;
			}
			var Wg = {
				stack: "dbcore",
				name: "VirtualIndexMiddleware",
				level: 1,
				create: function(u) {
					return E(E({}, u), { table: function(D) {
						var O = u.table(D), P = O.schema, F = {}, I = [];
						function R(u, D, O) {
							var P = ig(u), U = F[P] = F[P] || [], J = u == null ? 0 : typeof u == "string" ? 1 : u.length, _p = 0 < D, _p = E(E({}, O), {
								name: _p ? `${P}(virtual-from:${O.name})` : O.name,
								lowLevelIndex: O,
								isVirtual: _p,
								keyTail: D,
								keyLength: J,
								extractKey: tg(u),
								unique: !_p && O.unique
							});
							return U.push(_p), _p.isPrimaryKey || I.push(_p), 1 < J && R(J === 2 ? u[0] : u.slice(0, J - 1), D + 1, O), U.sort(function(u, E) {
								return u.keyTail - E.keyTail;
							}), _p;
						}
						D = R(P.primaryKey.keyPath, 0, P.primaryKey), F[":id"] = [D];
						for (var U = 0, J = P.indexes; U < J.length; U++) {
							var _p = J[U];
							R(_p.keyPath, 0, _p);
						}
						function vp(D) {
							var O, P = D.query.index;
							return P.isVirtual ? E(E({}, D), { query: {
								index: P.lowLevelIndex,
								range: (O = D.query.range, P = P.keyTail, {
									type: O.type === 1 ? 2 : O.type,
									lower: Ug(O.lower, O.lowerOpen ? u.MAX_KEY : u.MIN_KEY, P),
									lowerOpen: !0,
									upper: Ug(O.upper, O.upperOpen ? u.MIN_KEY : u.MAX_KEY, P),
									upperOpen: !0
								})
							} }) : D;
						}
						return E(E({}, O), {
							schema: E(E({}, P), {
								primaryKey: D,
								indexes: I,
								getIndexByKeyPath: function(u) {
									return (u = F[ig(u)]) && u[0];
								}
							}),
							count: function(u) {
								return O.count(vp(u));
							},
							query: function(u) {
								return O.query(vp(u));
							},
							openCursor: function(E) {
								var D = E.query.index, P = D.keyTail, F = D.isVirtual, I = D.keyLength;
								return F ? O.openCursor(vp(E)).then(function(u) {
									return u && R(u);
								}) : O.openCursor(E);
								function R(D) {
									return Object.create(D, {
										continue: { value: function(O) {
											O == null ? E.unique ? D.continue(D.key.slice(0, I).concat(E.reverse ? u.MIN_KEY : u.MAX_KEY, P)) : D.continue() : D.continue(Ug(O, E.reverse ? u.MAX_KEY : u.MIN_KEY, P));
										} },
										continuePrimaryKey: { value: function(E, O) {
											D.continuePrimaryKey(Ug(E, u.MAX_KEY, P), O);
										} },
										primaryKey: { get: function() {
											return D.primaryKey;
										} },
										key: { get: function() {
											var u = D.key;
											return I === 1 ? u[0] : u.slice(0, I);
										} },
										value: { get: function() {
											return D.value;
										} }
									});
								}
							}
						});
					} });
				}
			};
			function Gg(u, E, D, O) {
				return D ||= {}, O ||= "", P(u).forEach(function(P) {
					var F, I, R;
					J(E, P) ? (F = u[P], I = E[P], typeof F == "object" && typeof I == "object" && F && I ? (R = Lp(F)) === Lp(I) ? R === "Object" ? Gg(F, I, D, O + P + ".") : F !== I && (D[O + P] = E[P]) : D[O + P] = E[P] : F !== I && (D[O + P] = E[P])) : D[O + P] = void 0;
				}), P(E).forEach(function(P) {
					J(u, P) || (D[O + P] = E[P]);
				}), D;
			}
			function Kg(u, E) {
				return E.type === "delete" ? E.keys : E.keys || E.values.map(u.extractKey);
			}
			var qg = {
				stack: "dbcore",
				name: "HooksMiddleware",
				level: 2,
				create: function(u) {
					return E(E({}, u), { table: function(O) {
						var P = u.table(O), F = P.schema.primaryKey;
						return E(E({}, P), { mutate: function(u) {
							var I = wm.trans, R = I.table(O).hook, U = R.deleting, _p = R.creating, vp = R.updating;
							switch (u.type) {
								case "add":
									if (_p.fire === nm) break;
									return I._promise("readwrite", function() {
										return yp(u);
									}, !0);
								case "put":
									if (_p.fire === nm && vp.fire === nm) break;
									return I._promise("readwrite", function() {
										return yp(u);
									}, !0);
								case "delete":
									if (U.fire === nm) break;
									return I._promise("readwrite", function() {
										return yp(u);
									}, !0);
								case "deleteRange":
									if (U.fire === nm) break;
									return I._promise("readwrite", function() {
										return function u(D, O, I) {
											return P.query({
												trans: D,
												values: !1,
												query: {
													index: F,
													range: O
												},
												limit: I
											}).then(function(P) {
												var F = P.result;
												return yp({
													type: "delete",
													keys: F,
													trans: D
												}).then(function(P) {
													return 0 < P.numFailures ? Promise.reject(P.failures[0]) : F.length < I ? {
														failures: [],
														numFailures: 0,
														lastResult: void 0
													} : u(D, E(E({}, O), {
														lower: F[F.length - 1],
														lowerOpen: !0
													}), I);
												});
											});
										}(u.trans, u.range, 1e4);
									}, !0);
							}
							return P.mutate(u);
							function yp(u) {
								var O, I, R, yp = wm.trans, bp = u.keys || Kg(F, u);
								if (!bp) throw Error("Keys missing");
								return (u = u.type === "add" || u.type === "put" ? E(E({}, u), { keys: bp }) : E({}, u)).type !== "delete" && (u.values = D([], u.values)), u.keys &&= D([], u.keys), O = P, R = bp, ((I = u).type === "add" ? Promise.resolve([]) : O.getMany({
									trans: I.trans,
									keys: R,
									cache: "immutable"
								})).then(function(E) {
									var D = bp.map(function(D, O) {
										var P, I, R, bp = E[O], xp = {
											onerror: null,
											onsuccess: null
										};
										return u.type === "delete" ? U.fire.call(xp, D, bp, yp) : u.type === "add" || bp === void 0 ? (P = _p.fire.call(xp, D, u.values[O], yp), D == null && P != null && (u.keys[O] = D = P, F.outbound || Op(u.values[O], F.keyPath, D))) : (P = Gg(bp, u.values[O]), (I = vp.fire.call(xp, P, D, bp, yp)) && (R = u.values[O], Object.keys(I).forEach(function(u) {
											J(R, u) ? R[u] = I[u] : Op(R, u, I[u]);
										}))), xp;
									});
									return P.mutate(u).then(function(O) {
										for (var P = O.failures, F = O.results, I = O.numFailures, O = O.lastResult, R = 0; R < bp.length; ++R) {
											var U = (F || bp)[R], J = D[R];
											U == null ? J.onerror && J.onerror(P[R]) : J.onsuccess && J.onsuccess(u.type === "put" && E[R] ? u.values[R] : U);
										}
										return {
											failures: P,
											results: F,
											numFailures: I,
											lastResult: O
										};
									}).catch(function(u) {
										return D.forEach(function(E) {
											return E.onerror && E.onerror(u);
										}), Promise.reject(u);
									});
								});
							}
						} });
					} });
				}
			};
			function Jg(u, E, D) {
				try {
					if (!E || E.keys.length < u.length) return null;
					for (var O = [], P = 0, F = 0; P < E.keys.length && F < u.length; ++P) hh(E.keys[P], u[F]) === 0 && (O.push(D ? Fp(E.values[P]) : E.values[P]), ++F);
					return O.length === u.length ? O : null;
				} catch {
					return null;
				}
			}
			var Yg = {
				stack: "dbcore",
				level: -1,
				create: function(u) {
					return { table: function(D) {
						var O = u.table(D);
						return E(E({}, O), {
							getMany: function(u) {
								if (!u.cache) return O.getMany(u);
								var E = Jg(u.keys, u.trans._cache, u.cache === "clone");
								return E ? Om.resolve(E) : O.getMany(u).then(function(E) {
									return u.trans._cache = {
										keys: u.keys,
										values: u.cache === "clone" ? Fp(E) : E
									}, E;
								});
							},
							mutate: function(u) {
								return u.type !== "add" && (u.trans._cache = null), O.mutate(u);
							}
						});
					} };
				}
			};
			function Xg(u, E) {
				return u.trans.mode === "readonly" && !!u.subscr && !u.trans.explicit && u.trans.db._options.cache !== "disabled" && !E.schema.primaryKey.outbound;
			}
			function Zg(u, E) {
				switch (u) {
					case "query": return E.values && !E.unique;
					case "get":
					case "getMany":
					case "count":
					case "openCursor": return !1;
				}
			}
			var Qg = {
				stack: "dbcore",
				level: 0,
				name: "Observability",
				create: function(u) {
					var D = u.schema.name, O = new Eg(u.MIN_KEY, u.MAX_KEY);
					return E(E({}, u), {
						transaction: function(E, D, O) {
							if (wm.subscr && D !== "readonly") throw new $p.ReadOnly(`Readwrite transaction in liveQuery context. Querier source: ${wm.querier}`);
							return u.transaction(E, D, O);
						},
						table: function(I) {
							var R = u.table(I), U = R.schema, J = U.primaryKey, _p = U.indexes, vp = J.extractKey, yp = J.outbound, bp = J.autoIncrement && _p.filter(function(u) {
								return u.compound && u.keyPath.includes(J.keyPath);
							}), xp = E(E({}, R), { mutate: function(E) {
								function P(u) {
									return u = `idb://${D}/${I}/${u}`, Sp[u] || (Sp[u] = new Eg());
								}
								var _p, vp, yp, xp = E.trans, Sp = E.mutatedParts ||= {}, Cp = P(""), wp = P(":dels"), Tp = E.type, Ep = E.type === "deleteRange" ? [E.range] : E.type === "delete" ? [E.keys] : E.values.length < 50 ? [Kg(J, E).filter(function(u) {
									return u;
								}), E.values] : [], Dp = Ep[0], Op = Ep[1], Ep = E.trans._cache;
								return F(Dp) ? (Cp.addKeys(Dp), (Ep = Tp === "delete" || Dp.length === Op.length ? Jg(Dp, Ep) : null) || wp.addKeys(Dp), (Ep || Op) && (_p = P, vp = Ep, yp = Op, U.indexes.forEach(function(u) {
									var E = _p(u.name || "");
									function D(E) {
										return E == null ? null : u.extractKey(E);
									}
									function O(D) {
										return u.multiEntry && F(D) ? D.forEach(function(u) {
											return E.addKey(u);
										}) : E.addKey(D);
									}
									(vp || yp).forEach(function(u, E) {
										var P = vp && D(vp[E]), E = yp && D(yp[E]);
										hh(P, E) !== 0 && (P != null && O(P), E != null && O(E));
									});
								}))) : Dp ? (Op = {
									from: (Op = Dp.lower) ?? u.MIN_KEY,
									to: (Op = Dp.upper) ?? u.MAX_KEY
								}, wp.add(Op), Cp.add(Op)) : (Cp.add(O), wp.add(O), U.indexes.forEach(function(u) {
									return P(u.name).add(O);
								})), R.mutate(E).then(function(u) {
									return !Dp || E.type !== "add" && E.type !== "put" || (Cp.addKeys(u.results), bp && bp.forEach(function(D) {
										for (var O = E.values.map(function(u) {
											return D.extractKey(u);
										}), F = D.keyPath.findIndex(function(u) {
											return u === J.keyPath;
										}), I = 0, R = u.results.length; I < R; ++I) O[I][F] = u.results[I];
										P(D.name).addKeys(O);
									})), xp.mutatedParts = Ng(xp.mutatedParts || {}, Sp), u;
								});
							} }), _p = function(E) {
								var D = E.query, E = D.index, D = D.range;
								return [E, new Eg((E = D.lower) ?? u.MIN_KEY, (D = D.upper) ?? u.MAX_KEY)];
							}, Sp = {
								get: function(u) {
									return [J, new Eg(u.key)];
								},
								getMany: function(u) {
									return [J, new Eg().addKeys(u.keys)];
								},
								count: _p,
								query: _p,
								openCursor: _p
							};
							return P(Sp).forEach(function(u) {
								xp[u] = function(P) {
									var F = wm.subscr, U = !!F, J = Xg(wm, R) && Zg(u, P) ? P.obsSet = {} : F;
									if (U) {
										var _p = function(u) {
											return u = `idb://${D}/${I}/${u}`, J[u] || (J[u] = new Eg());
										}, bp = _p(""), xp = _p(":dels"), F = Sp[u](P), U = F[0], F = F[1];
										if ((u === "query" && U.isPrimaryKey && !P.values ? xp : _p(U.name || "")).add(F), !U.isPrimaryKey) {
											if (u !== "count") {
												var Cp = u === "query" && yp && P.values && R.query(E(E({}, P), { values: !1 }));
												return R[u].apply(this, arguments).then(function(E) {
													if (u === "query") {
														if (yp && P.values) return Cp.then(function(u) {
															return u = u.result, bp.addKeys(u), E;
														});
														var D = P.values ? E.result.map(vp) : E.result;
														(P.values ? bp : xp).addKeys(D);
													} else if (u === "openCursor") {
														var O = E, F = P.values;
														return O && Object.create(O, {
															key: { get: function() {
																return xp.addKey(O.primaryKey), O.key;
															} },
															primaryKey: { get: function() {
																var u = O.primaryKey;
																return xp.addKey(u), u;
															} },
															value: { get: function() {
																return F && bp.addKey(O.primaryKey), O.value;
															} }
														});
													}
													return E;
												});
											}
											xp.add(O);
										}
									}
									return R[u].apply(this, arguments);
								};
							}), xp;
						}
					});
				}
			};
			function $g(u, D, O) {
				if (O.numFailures === 0) return D;
				if (D.type === "deleteRange") return null;
				var P = D.keys ? D.keys.length : "values" in D && D.values ? D.values.length : 1;
				return O.numFailures === P ? null : (D = E({}, D), F(D.keys) && (D.keys = D.keys.filter(function(u, E) {
					return !(E in O.failures);
				})), "values" in D && F(D.values) && (D.values = D.values.filter(function(u, E) {
					return !(E in O.failures);
				})), D);
			}
			function e_(u, E) {
				return D = u, ((O = E).lower === void 0 || (O.lowerOpen ? 0 < hh(D, O.lower) : 0 <= hh(D, O.lower))) && (u = u, (E = E).upper === void 0 || (E.upperOpen ? hh(u, E.upper) < 0 : hh(u, E.upper) <= 0));
				var D, O;
			}
			function t_(u, E, D, O, P, I) {
				if (!D || D.length === 0) return u;
				var R = E.query.index, U = R.multiEntry, J = E.query.range, _p = O.schema.primaryKey.extractKey, vp = R.extractKey, yp = (R.lowLevelIndex || R).extractKey, D = D.reduce(function(u, D) {
					var O = u, P = [];
					if (D.type === "add" || D.type === "put") for (var I = new Eg(), R = D.values.length - 1; 0 <= R; --R) {
						var yp, bp = D.values[R], xp = _p(bp);
						I.hasKey(xp) || (yp = vp(bp), (U && F(yp) ? yp.some(function(u) {
							return e_(u, J);
						}) : e_(yp, J)) && (I.addKey(xp), P.push(bp)));
					}
					switch (D.type) {
						case "add":
							var Sp = new Eg().addKeys(E.values ? u.map(function(u) {
								return _p(u);
							}) : u), O = u.concat(E.values ? P.filter(function(u) {
								return u = _p(u), !Sp.hasKey(u) && (Sp.addKey(u), !0);
							}) : P.map(function(u) {
								return _p(u);
							}).filter(function(u) {
								return !Sp.hasKey(u) && (Sp.addKey(u), !0);
							}));
							break;
						case "put":
							var Cp = new Eg().addKeys(D.values.map(function(u) {
								return _p(u);
							}));
							O = u.filter(function(u) {
								return !Cp.hasKey(E.values ? _p(u) : u);
							}).concat(E.values ? P : P.map(function(u) {
								return _p(u);
							}));
							break;
						case "delete":
							var wp = new Eg().addKeys(D.keys);
							O = u.filter(function(u) {
								return !wp.hasKey(E.values ? _p(u) : u);
							});
							break;
						case "deleteRange":
							var Tp = D.range;
							O = u.filter(function(u) {
								return !e_(_p(u), Tp);
							});
					}
					return O;
				}, u);
				return D === u ? u : (D.sort(function(u, E) {
					return hh(yp(u), yp(E)) || hh(_p(u), _p(E));
				}), E.limit && E.limit < Infinity && (D.length > E.limit ? D.length = E.limit : u.length === E.limit && D.length < E.limit && (P.dirty = !0)), I ? Object.freeze(D) : D);
			}
			function n_(u, E) {
				return hh(u.lower, E.lower) === 0 && hh(u.upper, E.upper) === 0 && !!u.lowerOpen == !!E.lowerOpen && !!u.upperOpen == !!E.upperOpen;
			}
			function r_(u, E) {
				return function(u, E, D, O) {
					if (u === void 0) return E === void 0 ? 0 : -1;
					if (E === void 0) return 1;
					if ((E = hh(u, E)) === 0) {
						if (D && O) return 0;
						if (D) return 1;
						if (O) return -1;
					}
					return E;
				}(u.lower, E.lower, u.lowerOpen, E.lowerOpen) <= 0 && 0 <= function(u, E, D, O) {
					if (u === void 0) return E === void 0 ? 0 : 1;
					if (E === void 0) return -1;
					if ((E = hh(u, E)) === 0) {
						if (D && O) return 0;
						if (D) return -1;
						if (O) return 1;
					}
					return E;
				}(u.upper, E.upper, u.upperOpen, E.upperOpen);
			}
			function i_(u, E, D, O) {
				u.subscribers.add(D), O.addEventListener("abort", function() {
					var O, P;
					u.subscribers.delete(D), u.subscribers.size === 0 && (O = u, P = E, setTimeout(function() {
						O.subscribers.size === 0 && Bp(P, O);
					}, 3e3));
				});
			}
			var a_ = {
				stack: "dbcore",
				level: 0,
				name: "Cache",
				create: function(u) {
					var D = u.schema.name;
					return E(E({}, u), {
						transaction: function(E, O, P) {
							var F, I, R = u.transaction(E, O, P);
							return O === "readwrite" && (I = (F = new AbortController()).signal, P = function(P) {
								return function() {
									if (F.abort(), O === "readwrite") {
										for (var I = /* @__PURE__ */ new Set(), U = 0, J = E; U < J.length; U++) {
											var _p = J[U], vp = Fg[`idb://${D}/${_p}`];
											if (vp) {
												var yp = u.table(_p), bp = vp.optimisticOps.filter(function(u) {
													return u.trans === R;
												});
												if (R._explicit && P && R.mutatedParts) for (var xp = 0, Sp = Object.values(vp.queries.query); xp < Sp.length; xp++) for (var Cp = 0, wp = (Dp = Sp[xp]).slice(); Cp < wp.length; Cp++) Pg((Op = wp[Cp]).obsSet, R.mutatedParts) && (Bp(Dp, Op), Op.subscribers.forEach(function(u) {
													return I.add(u);
												}));
												else if (0 < bp.length) {
													vp.optimisticOps = vp.optimisticOps.filter(function(u) {
														return u.trans !== R;
													});
													for (var Tp = 0, Ep = Object.values(vp.queries.query); Tp < Ep.length; Tp++) for (var Dp, Op, kp, Ap = 0, jp = (Dp = Ep[Tp]).slice(); Ap < jp.length; Ap++) (Op = jp[Ap]).res != null && R.mutatedParts && (P && !Op.dirty ? (kp = Object.isFrozen(Op.res), kp = t_(Op.res, Op.req, bp, yp, Op, kp), Op.dirty ? (Bp(Dp, Op), Op.subscribers.forEach(function(u) {
														return I.add(u);
													})) : kp !== Op.res && (Op.res = kp, Op.promise = Om.resolve({ result: kp }))) : (Op.dirty && Bp(Dp, Op), Op.subscribers.forEach(function(u) {
														return I.add(u);
													})));
												}
											}
										}
										I.forEach(function(u) {
											return u();
										});
									}
								};
							}, R.addEventListener("abort", P(!1), { signal: I }), R.addEventListener("error", P(!1), { signal: I }), R.addEventListener("complete", P(!0), { signal: I })), R;
						},
						table: function(O) {
							var P = u.table(O), F = P.schema.primaryKey;
							return E(E({}, P), {
								mutate: function(u) {
									var I = wm.trans;
									if (F.outbound || I.db._options.cache === "disabled" || I.explicit || I.idbtrans.mode !== "readwrite") return P.mutate(u);
									var R = Fg[`idb://${D}/${O}`];
									return R ? (I = P.mutate(u), u.type !== "add" && u.type !== "put" || !(50 <= u.values.length || Kg(F, u).some(function(u) {
										return u == null;
									})) ? (R.optimisticOps.push(u), u.mutatedParts && Rg(u.mutatedParts), I.then(function(E) {
										0 < E.numFailures && (Bp(R.optimisticOps, u), (E = $g(0, u, E)) && R.optimisticOps.push(E), u.mutatedParts && Rg(u.mutatedParts));
									}), I.catch(function() {
										Bp(R.optimisticOps, u), u.mutatedParts && Rg(u.mutatedParts);
									})) : I.then(function(D) {
										var O = $g(0, E(E({}, u), { values: u.values.map(function(u, O) {
											var P;
											return D.failures[O] ? u : (u = (P = F.keyPath) != null && P.includes(".") ? Fp(u) : E({}, u), Op(u, F.keyPath, D.results[O]), u);
										}) }), D);
										R.optimisticOps.push(O), queueMicrotask(function() {
											return u.mutatedParts && Rg(u.mutatedParts);
										});
									}), I) : P.mutate(u);
								},
								query: function(u) {
									if (!Xg(wm, P) || !Zg("query", u)) return P.query(u);
									var E = (U = wm.trans)?.db._options.cache === "immutable", F = wm, I = F.requery, R = F.signal, U = function(u, E, D, O) {
										var P = Fg[`idb://${u}/${E}`];
										if (!P) return [];
										if (!(E = P.queries[D])) return [
											null,
											!1,
											P,
											null
										];
										var F = E[(O.query ? O.query.index.name : null) || ""];
										if (!F) return [
											null,
											!1,
											P,
											null
										];
										switch (D) {
											case "query":
												var I = F.find(function(u) {
													return u.req.limit === O.limit && u.req.values === O.values && n_(u.req.query.range, O.query.range);
												});
												return I ? [
													I,
													!0,
													P,
													F
												] : [
													F.find(function(u) {
														return ("limit" in u.req ? u.req.limit : Infinity) >= O.limit && (!O.values || u.req.values) && r_(u.req.query.range, O.query.range);
													}),
													!1,
													P,
													F
												];
											case "count": return I = F.find(function(u) {
												return n_(u.req.query.range, O.query.range);
											}), [
												I,
												!!I,
												P,
												F
											];
										}
									}(D, O, "query", u), J = U[0], F = U[1], _p = U[2], vp = U[3];
									return J && F ? J.obsSet = u.obsSet : (F = P.query(u).then(function(u) {
										var D = u.result;
										if (J && (J.res = D), E) {
											for (var O = 0, P = D.length; O < P; ++O) Object.freeze(D[O]);
											Object.freeze(D);
										} else u.result = Fp(D);
										return u;
									}).catch(function(u) {
										return vp && J && Bp(vp, J), Promise.reject(u);
									}), J = {
										obsSet: u.obsSet,
										promise: F,
										subscribers: /* @__PURE__ */ new Set(),
										type: "query",
										req: u,
										dirty: !1
									}, vp ? vp.push(J) : (vp = [J], (_p ||= Fg[`idb://${D}/${O}`] = {
										queries: {
											query: {},
											count: {}
										},
										objs: /* @__PURE__ */ new Map(),
										optimisticOps: [],
										unsignaledParts: {}
									}).queries.query[u.query.index.name || ""] = vp)), i_(J, vp, I, R), J.promise.then(function(D) {
										return { result: t_(D.result, u, _p?.optimisticOps, P, J, E) };
									});
								}
							});
						}
					});
				}
			};
			function o_(u, E) {
				return new Proxy(u, { get: function(u, D, O) {
					return D === "db" ? E : Reflect.get(u, D, O);
				} });
			}
			var s_ = (c_.prototype.version = function(u) {
				if (isNaN(u) || u < .1) throw new $p.Type("Given version is not a positive number");
				if (u = Math.round(10 * u) / 10, this.idbdb || this._state.isBeingOpened) throw new $p.Schema("Cannot add version when database is open");
				this.verno = Math.max(this.verno, u);
				var E = this._versions, D = E.filter(function(E) {
					return E._cfg.version === u;
				})[0];
				return D || (D = new this.Version(u), E.push(D), E.sort(ug), D.stores({}), this._state.autoSchema = !1, D);
			}, c_.prototype._whenReady = function(u) {
				var E = this;
				return this.idbdb && (this._state.openComplete || wm.letThrough || this._vip) ? u() : new Om(function(u, D) {
					if (E._state.openComplete) return D(new $p.DatabaseClosed(E._state.dbOpenError));
					if (!E._state.isBeingOpened) {
						if (!E._state.autoOpen) return void D(new $p.DatabaseClosed());
						E.open().catch(nm);
					}
					E._state.dbReadyPromise.then(u, D);
				}).then(u);
			}, c_.prototype.use = function(u) {
				var E = u.stack, D = u.create, O = u.level, P = u.name;
				return P && this.unuse({
					stack: E,
					name: P
				}), u = this._middlewares[E] || (this._middlewares[E] = []), u.push({
					stack: E,
					create: D,
					level: O ?? 10,
					name: P
				}), u.sort(function(u, E) {
					return u.level - E.level;
				}), this;
			}, c_.prototype.unuse = function(u) {
				var E = u.stack, D = u.name, O = u.create;
				return E && this._middlewares[E] && (this._middlewares[E] = this._middlewares[E].filter(function(u) {
					return O ? u.create !== O : !!D && u.name !== D;
				})), this;
			}, c_.prototype.open = function() {
				var u = this;
				return eh(Cm, function() {
					return Vg(u);
				});
			}, c_.prototype._close = function() {
				this.on.close.fire(new CustomEvent("close"));
				var u = this._state, E = sh.indexOf(this);
				if (0 <= E && sh.splice(E, 1), this.idbdb) {
					try {
						this.idbdb.close();
					} catch {}
					this.idbdb = null;
				}
				u.isBeingOpened || (u.dbReadyPromise = new Om(function(E) {
					u.dbReadyResolve = E;
				}), u.openCanceller = new Om(function(E, D) {
					u.cancelOpen = D;
				}));
			}, c_.prototype.close = function(u) {
				var E = (u === void 0 ? { disableAutoOpen: !0 } : u).disableAutoOpen, u = this._state;
				E ? (u.isBeingOpened && u.cancelOpen(new $p.DatabaseClosed()), this._close(), u.autoOpen = !1, u.dbOpenError = new $p.DatabaseClosed()) : (this._close(), u.autoOpen = this._options.autoOpen || u.isBeingOpened, u.openComplete = !1, u.dbOpenError = null);
			}, c_.prototype.delete = function(u) {
				var E = this;
				u === void 0 && (u = { disableAutoOpen: !0 });
				var D = 0 < arguments.length && typeof arguments[0] != "object", O = this._state;
				return new Om(function(P, F) {
					function I() {
						E.close(u);
						var D = E._deps.indexedDB.deleteDatabase(E.name);
						D.onsuccess = Bm(function() {
							var u = E._deps, D = E.name, O = u.indexedDB;
							u = u.IDBKeyRange, Cg(O) || D === ch || Sg(O, u).delete(D).catch(nm), P();
						}), D.onerror = Wh(F), D.onblocked = E._fireOnBlocked;
					}
					if (D) throw new $p.InvalidArgument("Invalid closeOptions argument to db.delete()");
					O.isBeingOpened ? O.dbReadyPromise.then(I) : I();
				});
			}, c_.prototype.backendDB = function() {
				return this.idbdb;
			}, c_.prototype.isOpen = function() {
				return this.idbdb !== null;
			}, c_.prototype.hasBeenClosed = function() {
				var u = this._state.dbOpenError;
				return u && u.name === "DatabaseClosed";
			}, c_.prototype.hasFailed = function() {
				return this._state.dbOpenError !== null;
			}, c_.prototype.dynamicallyOpened = function() {
				return this._state.autoSchema;
			}, Object.defineProperty(c_.prototype, "tables", {
				get: function() {
					var u = this;
					return P(this._allTables).map(function(E) {
						return u._allTables[E];
					});
				},
				enumerable: !1,
				configurable: !0
			}), c_.prototype.transaction = function() {
				var u = (function(u, E, D) {
					var O = arguments.length;
					if (O < 2) throw new $p.InvalidArgument("Too few arguments");
					for (var P = Array(O - 1); --O;) P[O - 1] = arguments[O];
					return D = P.pop(), [
						u,
						jp(P),
						D
					];
				}).apply(this, arguments);
				return this._transaction.apply(this, u);
			}, c_.prototype._transaction = function(u, E, D) {
				var O = this, P = wm.trans;
				P && P.db === this && u.indexOf("!") === -1 || (P = null);
				var F, I, R = u.indexOf("?") !== -1;
				u = u.replace("!", "").replace("?", "");
				try {
					if (I = E.map(function(u) {
						if (u = u instanceof O.Table ? u.name : u, typeof u != "string") throw TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
						return u;
					}), u == "r" || u === lh) F = lh;
					else {
						if (u != "rw" && u != uh) throw new $p.InvalidArgument("Invalid transaction mode: " + u);
						F = uh;
					}
					if (P) {
						if (P.mode === lh && F === uh) {
							if (!R) throw new $p.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
							P = null;
						}
						P && I.forEach(function(u) {
							if (P && P.storeNames.indexOf(u) === -1) {
								if (!R) throw new $p.SubTransaction("Table " + u + " not included in parent transaction.");
								P = null;
							}
						}), R && P && !P.active && (P = null);
					}
				} catch (u) {
					return P ? P._promise(null, function(E, D) {
						D(u);
					}) : rh(u);
				}
				var U = (function u(E, D, O, P, F) {
					return Om.resolve().then(function() {
						var I = wm.transless || wm, R = E._createTransaction(D, O, E._dbSchema, P);
						if (R.explicit = !0, I = {
							trans: R,
							transless: I
						}, P) R.idbtrans = P.idbtrans;
						else try {
							R.create(), R.idbtrans._explicit = !0, E._state.PR1398_maxLoop = 3;
						} catch (P) {
							return P.name === Zp.InvalidState && E.isOpen() && 0 < --E._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), E.close({ disableAutoOpen: !1 }), E.open().then(function() {
								return u(E, D, O, null, F);
							})) : rh(P);
						}
						var U, J = Up(F);
						return J && Jm(), I = Om.follow(function() {
							var u;
							(U = F.call(R, R)) && (J ? (u = Ym.bind(null, null), U.then(u, u)) : typeof U.next == "function" && typeof U.throw == "function" && (U = Hg(U)));
						}, I), (U && typeof U.then == "function" ? Om.resolve(U).then(function(u) {
							return R.active ? u : rh(new $p.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
						}) : I.then(function() {
							return U;
						})).then(function(u) {
							return P && R._resolve(), R._completion.then(function() {
								return u;
							});
						}).catch(function(u) {
							return R._reject(u), rh(u);
						});
					});
				}).bind(null, this, F, I, P, D);
				return P ? P._promise(F, U, "lock") : wm.trans ? eh(wm.transless, function() {
					return O._whenReady(U);
				}) : this._whenReady(U);
			}, c_.prototype.table = function(u) {
				if (!J(this._allTables, u)) throw new $p.InvalidTable(`Table ${u} does not exist`);
				return this._allTables[u];
			}, c_);
			function c_(u, D) {
				var O = this;
				this._middlewares = {}, this.verno = 0;
				var P = c_.dependencies;
				this._options = D = E({
					addons: c_.addons,
					autoOpen: !0,
					indexedDB: P.indexedDB,
					IDBKeyRange: P.IDBKeyRange,
					cache: "cloned"
				}, D), this._deps = {
					indexedDB: D.indexedDB,
					IDBKeyRange: D.IDBKeyRange
				}, P = D.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
				var F, I, R, U, J, _p = {
					dbOpenError: null,
					isBeingOpened: !1,
					onReadyBeingFired: null,
					openComplete: !1,
					dbReadyResolve: nm,
					dbReadyPromise: null,
					cancelOpen: nm,
					openCanceller: null,
					autoSchema: !0,
					PR1398_maxLoop: 3,
					autoOpen: D.autoOpen
				};
				_p.dbReadyPromise = new Om(function(u) {
					_p.dbReadyResolve = u;
				}), _p.openCanceller = new Om(function(u, E) {
					_p.cancelOpen = E;
				}), this._state = _p, this.name = u, this.on = xh(this, "populate", "blocked", "versionchange", "close", { ready: [um, nm] }), this.once = function(u, E) {
					var D = function() {
						var P = [...arguments];
						O.on(u).unsubscribe(D), E.apply(O, P);
					};
					return O.on(u, D);
				}, this.on.ready.subscribe = wp(this.on.ready.subscribe, function(u) {
					return function(E, D) {
						c_.vip(function() {
							var P, F = O._state;
							F.openComplete ? (F.dbOpenError || Om.resolve().then(E), D && u(E)) : F.onReadyBeingFired ? (F.onReadyBeingFired.push(E), D && u(E)) : (u(E), P = O, D || u(function u() {
								P.on.ready.unsubscribe(E), P.on.ready.unsubscribe(u);
							}));
						});
					};
				}), this.Collection = (F = this, Sh(Mh.prototype, function(u, E) {
					this.db = F;
					var D = fh, O = null;
					if (E) try {
						D = E();
					} catch (u) {
						O = u;
					}
					var P = u._ctx, E = P.table, u = E.hook.reading.fire;
					this._ctx = {
						table: E,
						index: P.index,
						isPrimKey: !P.index || E.schema.primKey.keyPath && P.index === E.schema.primKey.name,
						range: D,
						keysOnly: !1,
						dir: "next",
						unique: "",
						algorithm: null,
						filter: null,
						replayFilter: null,
						justLimit: !0,
						isMatch: null,
						offset: 0,
						limit: Infinity,
						error: O,
						or: P.or,
						valueMapper: u === rm ? null : u
					};
				})), this.Table = (I = this, Sh(yh.prototype, function(u, E, D) {
					this.db = I, this._tx = D, this.name = u, this.schema = E, this.hook = I._allTables[u] ? I._allTables[u].hook : xh(null, {
						creating: [om, nm],
						reading: [im, rm],
						updating: [cm, nm],
						deleting: [sm, nm]
					});
				})), this.Transaction = (R = this, Sh(Yh.prototype, function(u, E, D, O, P) {
					var F = this;
					u !== "readonly" && E.forEach(function(u) {
						u = (u = D[u])?.yProps, u && (E = E.concat(u.map(function(u) {
							return u.updatesTable;
						})));
					}), this.db = R, this.mode = u, this.storeNames = E, this.schema = D, this.chromeTransactionDurability = O, this.idbtrans = null, this.on = xh(this, "complete", "error", "abort"), this.parent = P || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Om(function(u, E) {
						F._resolve = u, F._reject = E;
					}), this._completion.then(function() {
						F.active = !1, F.on.complete.fire();
					}, function(u) {
						var E = F.active;
						return F.active = !1, F.on.error.fire(u), F.parent ? F.parent._reject(u) : E && F.idbtrans && F.idbtrans.abort(), rh(u);
					});
				})), this.Version = (U = this, Sh(bg.prototype, function(u) {
					this.db = U, this._cfg = {
						version: u,
						storesSource: null,
						dbschema: {},
						tables: {},
						contentUpgrade: null
					};
				})), this.WhereClause = (J = this, Sh(Hh.prototype, function(u, E, D) {
					if (this.db = J, this._ctx = {
						table: u,
						index: E === ":id" ? null : E,
						or: D
					}, this._cmp = this._ascending = hh, this._descending = function(u, E) {
						return hh(E, u);
					}, this._max = function(u, E) {
						return 0 < hh(u, E) ? u : E;
					}, this._min = function(u, E) {
						return hh(u, E) < 0 ? u : E;
					}, this._IDBKeyRange = J._deps.IDBKeyRange, !this._IDBKeyRange) throw new $p.MissingAPI();
				})), this.on("versionchange", function(u) {
					0 < u.newVersion ? console.warn(`Another connection wants to upgrade database '${O.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${O.name}'. Closing db now to resume the delete request.`), O.close({ disableAutoOpen: !1 });
				}), this.on("blocked", function(u) {
					!u.newVersion || u.newVersion < u.oldVersion ? console.warn(`Dexie.delete('${O.name}') was blocked`) : console.warn(`Upgrade '${O.name}' blocked by other connection holding version ${u.oldVersion / 10}`);
				}), this._maxKey = eg(D.IDBKeyRange), this._createTransaction = function(u, E, D, P) {
					return new O.Transaction(u, E, D, O._options.chromeTransactionDurability, P);
				}, this._fireOnBlocked = function(u) {
					O.on("blocked").fire(u), sh.filter(function(u) {
						return u.name === O.name && u !== O && !u._state.vcFired;
					}).map(function(E) {
						return E.on("versionchange").fire(u);
					});
				}, this.use(Yg), this.use(a_), this.use(Qg), this.use(Wg), this.use(qg);
				var vp = new Proxy(this, { get: function(u, E, D) {
					if (E === "_vip") return !0;
					if (E === "table") return function(u) {
						return o_(O.table(u), vp);
					};
					var P = Reflect.get(u, E, D);
					return P instanceof yh ? o_(P, vp) : E === "tables" ? P.map(function(u) {
						return o_(u, vp);
					}) : E === "_createTransaction" ? function() {
						return o_(P.apply(this, arguments), vp);
					} : P;
				} });
				this.vip = vp, P.forEach(function(u) {
					return u(O);
				});
			}
			var l_, Gp = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", u_ = (d_.prototype.subscribe = function(u, E, D) {
				return this._subscribe(u && typeof u != "function" ? u : {
					next: u,
					error: E,
					complete: D
				});
			}, d_.prototype[Gp] = function() {
				return this;
			}, d_);
			function d_(u) {
				this._subscribe = u;
			}
			try {
				l_ = {
					indexedDB: O.indexedDB || O.mozIndexedDB || O.webkitIndexedDB || O.msIndexedDB,
					IDBKeyRange: O.IDBKeyRange || O.webkitIDBKeyRange
				};
			} catch {
				l_ = {
					indexedDB: null,
					IDBKeyRange: null
				};
			}
			function f_(u) {
				var E, D = !1, O = new u_(function(O) {
					var P = Up(u), F, I = !1, R = {}, U = {}, _p = {
						get closed() {
							return I;
						},
						unsubscribe: function() {
							I || (I = !0, F && F.abort(), vp && Jh.storagemutated.unsubscribe(bp));
						}
					};
					O.start && O.start(_p);
					var vp = !1, yp = function() {
						return nh(xp);
					}, bp = function(u) {
						Ng(R, u), Pg(U, R) && yp();
					}, xp = function() {
						var _p, xp, Sp;
						!I && l_.indexedDB && (R = {}, _p = {}, F && F.abort(), F = new AbortController(), Sp = function(E) {
							var D = Im();
							try {
								P && Jm();
								var O = qm(u, E);
								return O = P ? O.finally(Ym) : O;
							} finally {
								D && Lm();
							}
						}(xp = {
							subscr: _p,
							signal: F.signal,
							requery: yp,
							querier: u,
							trans: null
						}), Promise.resolve(Sp).then(function(u) {
							D = !0, E = u, I || xp.signal.aborted || (R = {}, function(u) {
								for (var E in u) if (J(u, E)) return;
								return 1;
							}(U = _p) || vp || (Jh(Kh, bp), vp = !0), nh(function() {
								return !I && O.next && O.next(u);
							}));
						}, function(u) {
							D = !1, ["DatabaseClosedError", "AbortError"].includes(u?.name) || I || nh(function() {
								I || O.error && O.error(u);
							});
						}));
					};
					return setTimeout(yp, 0), _p;
				});
				return O.hasValue = function() {
					return D;
				}, O.getValue = function() {
					return E;
				}, O;
			}
			var p_ = s_;
			function m_(u) {
				var E = g_;
				try {
					g_ = !0, Jh.storagemutated.fire(u), zg(u, !0);
				} finally {
					g_ = E;
				}
			}
			_p(p_, E(E({}, tm), {
				delete: function(u) {
					return new p_(u, { addons: [] }).delete();
				},
				exists: function(u) {
					return new p_(u, { addons: [] }).open().then(function(u) {
						return u.close(), !0;
					}).catch("NoSuchDatabaseError", function() {
						return !1;
					});
				},
				getDatabaseNames: function(u) {
					try {
						return E = p_.dependencies, D = E.indexedDB, E = E.IDBKeyRange, (Cg(D) ? Promise.resolve(D.databases()).then(function(u) {
							return u.map(function(u) {
								return u.name;
							}).filter(function(u) {
								return u !== ch;
							});
						}) : Sg(D, E).toCollection().primaryKeys()).then(u);
					} catch {
						return rh(new $p.MissingAPI());
					}
					var E, D;
				},
				defineClass: function() {
					return function(u) {
						I(this, u);
					};
				},
				ignoreTransaction: function(u) {
					return wm.trans ? eh(wm.transless, u) : u();
				},
				vip: wg,
				async: function(u) {
					return function() {
						try {
							var E = Hg(u.apply(this, arguments));
							return E && typeof E.then == "function" ? E : Om.resolve(E);
						} catch (u) {
							return rh(u);
						}
					};
				},
				spawn: function(u, E, D) {
					try {
						var O = Hg(u.apply(D, E || []));
						return O && typeof O.then == "function" ? O : Om.resolve(O);
					} catch (u) {
						return rh(u);
					}
				},
				currentTransaction: { get: function() {
					return wm.trans || null;
				} },
				waitFor: function(u, E) {
					return E = Om.resolve(typeof u == "function" ? p_.ignoreTransaction(u) : u).timeout(E || 6e4), wm.trans ? wm.trans.waitFor(E) : E;
				},
				Promise: Om,
				debug: {
					get: function() {
						return dm;
					},
					set: function(u) {
						fm(u);
					}
				},
				derive: bp,
				extend: I,
				props: _p,
				override: wp,
				Events: xh,
				on: Jh,
				liveQuery: f_,
				extendObservabilitySet: Ng,
				getByKeyPath: Dp,
				setByKeyPath: Op,
				delByKeyPath: function(u, E) {
					typeof E == "string" ? Op(u, E, void 0) : "length" in E && [].map.call(E, function(E) {
						Op(u, E, void 0);
					});
				},
				shallowClone: kp,
				deepClone: Fp,
				getObjectDiff: Gg,
				cmp: hh,
				asap: Ep,
				minKey: -Infinity,
				addons: [],
				connections: sh,
				errnames: Zp,
				dependencies: l_,
				cache: Fg,
				semVer: "4.2.0",
				version: "4.2.0".split(".").map(function(u) {
					return parseInt(u);
				}).reduce(function(u, E, D) {
					return u + E / 10 ** (2 * D);
				})
			})), p_.maxKey = eg(p_.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Jh(Kh, function(u) {
				g_ ||= (u = new CustomEvent(qh, { detail: u }), g_ = !0, dispatchEvent(u), !1);
			}), addEventListener(qh, function(u) {
				u = u.detail, g_ || m_(u);
			}));
			var h_, g_ = !1, __ = function() {};
			return typeof BroadcastChannel < "u" && ((__ = function() {
				(h_ = new BroadcastChannel(qh)).onmessage = function(u) {
					return u.data && m_(u.data);
				};
			})(), typeof h_.unref == "function" && h_.unref(), Jh(Kh, function(u) {
				g_ || h_.postMessage(u);
			})), typeof addEventListener < "u" && (addEventListener("pagehide", function(u) {
				if (!s_.disableBfCache && u.persisted) {
					dm && console.debug("Dexie: handling persisted pagehide"), h_?.close();
					for (var E = 0, D = sh; E < D.length; E++) D[E].close({ disableAutoOpen: !1 });
				}
			}), addEventListener("pageshow", function(u) {
				!s_.disableBfCache && u.persisted && (dm && console.debug("Dexie: handling persisted pageshow"), __(), m_({ all: new Eg(-Infinity, [[]]) }));
			})), Om.rejectionMapper = function(u, E) {
				return !u || u instanceof qp || u instanceof TypeError || u instanceof SyntaxError || !u.name || !em[u.name] ? u : (E = new em[u.name](E || u.message, u), "stack" in u && yp(E, "stack", { get: function() {
					return this.inner.stack;
				} }), E);
			}, fm(dm), E(s_, Object.freeze({
				__proto__: null,
				Dexie: s_,
				liveQuery: f_,
				Entity: mh,
				cmp: hh,
				PropModification: Ah,
				replacePrefix: function(u, E) {
					return new Ah({ replacePrefix: [u, E] });
				},
				add: function(u) {
					return new Ah({ add: u });
				},
				remove: function(u) {
					return new Ah({ remove: u });
				},
				default: s_,
				RangeSet: Eg,
				mergeRanges: Og,
				rangesOverlap: kg
			}), { default: s_ }), s_;
		});
	}(_l)), _l.exports;
}
var Pe$1 = /* @__PURE__ */ au(su()), Lt = Symbol.for("Dexie"), Bl = globalThis[Lt] || (globalThis[Lt] = Pe$1);
if (Pe$1.semVer !== Bl.semVer) throw Error(`Two different versions of Dexie loaded in the same app: ${Pe$1.semVer} and ${Bl.semVer}`);
var { liveQuery: Lu, mergeRanges: Iu, rangesOverlap: Du, RangeSet: Ou, cmp: Su, Entity: wu, PropModification: qu, replacePrefix: yu, add: bu, remove: Cu, DexieYProvider: Pu } = Bl, ou = "sclElements", mu = "id, tagName, [id+tagName], &attributes.uuid, &attributes.id, attributes.name, parent.id, parent.tagName, *children.id, *children.tagName";
function Tu(u) {
	let { databaseName: E } = u, D = new Bl(E);
	return D.version(1).stores({ [`${ou}`]: mu }), D;
}
var pu = {
	FunctionCategory: {
		tag: "FunctionCategory",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Category of functions. To be added to Process, Line, Substation, VoltageLevel and Bay SCL elements\n\nCategory of functions. To be added to Process, Line, Substation, VoltageLevel and Bay SCL elements",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"SubCategory",
				"FunctionCatRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SubCategory: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				FunctionCatRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ProcessResources: {
		tag: "ProcessResources",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "List of Process Resources related to a function. to be added to the SCL elements Function, SubFunction, EqFunction and EqSubFunction\n\nList of Process Resources related to a function. to be added to the SCL elements Function, SubFunction, EqFunction and EqSubFunction",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: ["Text", "ProcessResource"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ProcessResource: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueResource",
						kind: "unique",
						paths: [["Resource"]],
						deep: !1,
						attributes: ["resInst"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniquePR",
			kind: "unique",
			paths: [["ProcessResource"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	PowerSystemRelations: {
		tag: "PowerSystemRelations",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Functional relation from a Function/SubFunction to another element of the process\n\nFunctional relation from a Function/SubFunction to another element of the process",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: ["Text", "PowerSystemRelation"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				PowerSystemRelation: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniquePSR",
			kind: "unique",
			paths: [["PowerSystemRelation"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNodeInputs: {
		tag: "LNodeInputs",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "List of specification inputs of the given LNode. To be added at LNode level\n\nList of specification inputs of the given LNode. To be added at LNode level",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: ["Text", "SourceRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SourceRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueSourceRef",
			kind: "unique",
			paths: [["SourceRef"]],
			deep: !1,
			attributes: [
				"input",
				"inputInst",
				"pDA"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNodeOutputs: {
		tag: "LNodeOutputs",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "List of specification outputs of the given LNode. To be added at LNode level\n\nList of specification outputs of the given LNode. To be added at LNode level",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: ["Text", "ControlRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ControlRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueControlRef",
			kind: "unique",
			paths: [["ControlRef"]],
			deep: !1,
			attributes: ["output", "outputInst"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ProcessEcho: {
		tag: "ProcessEcho",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Definition of an echo LNode, mirroring the DO of another LNode\n\nDefinition of an echo LNode, mirroring the DO of another LNode",
		parents: [
			"DAS",
			"DOS",
			"SDS"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"source",
				"sourceDaName",
				"sourceDoName",
				"sourceLNodeUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				source: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceDaName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceDoName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceLNodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNodeSpecNaming: {
		tag: "LNodeSpecNaming",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "LNode user specification. To be added to LNode SCL element\n\nLNode user specification. To be added to LNode SCL element",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"sIedName",
				"sLdInst",
				"sLnClass",
				"sLnInst",
				"sPrefix"
			],
			details: {
				sIedName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"None",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sLdInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sLnClass: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sLnInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sPrefix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DOS: {
		tag: "DOS",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Data Object specification. To be added to LNode SCL element\n\nData Object specification. To be added to LNode SCL element",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"mappedDoName",
				"mappedLnUuid",
				"name"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				mappedDoName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				mappedLnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 12,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"SDS",
				"DAS",
				"SubscriberLNode",
				"ControllingLNode",
				"ProcessEcho",
				"LogParametersRef",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SDS: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueSDS_DASinSDS",
						kind: "unique",
						paths: [["DAS|.", "SDS"]],
						deep: !1,
						attributes: ["name", "ix"],
						refer: null,
						text: !1
					}]
				},
				DAS: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SubscriberLNode: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ControllingLNode: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ProcessEcho: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				LogParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInDOS",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: [
					"SDS",
					"DAS",
					"SubscriberLNode",
					"ControllingLNode",
					"ProcessEcho",
					"LogParametersRef"
				]
			}]
		},
		constraints: [{
			name: "uniqueSDS_DASinDOS",
			kind: "unique",
			paths: [["DAS|.", "SDS"]],
			deep: !1,
			attributes: ["name", "ix"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionSclRef: {
		tag: "FunctionSclRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to the FSD files used to create a Function. Could be added under Function/SubFunction/EqFunction/EqSubFunction\n\nReference to the FSD files used to create a Function. Could be added under Function/SubFunction/EqFunction/EqSubFunction",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "SclFileReference"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SclFileReference: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	CheckoutID: {
		tag: "CheckoutID",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Element used by an IED to indicates that a file has been imported to give engineering rights on this IED. This is opening a transaction between both projects to lock it on first project until the checkout is given back from current project, which then lock the IED locally\n\nElement used by an IED to indicates that a file has been imported to give engineering rights on this IED. This is opening a transaction between both projects to lock it on first project until the checkout is given back from current project, which then lock the IED locally",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"engRight",
				"fileName",
				"fileType",
				"fileUuid",
				"headerId",
				"revision",
				"version",
				"when"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				engRight: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"full",
							"fix",
							"dataflow"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"SED",
							"SCC",
							"ICD",
							"IID",
							"CID",
							"SSD",
							"SCD"
						],
						pattern: ["\\i\\c*", "[A-Z]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				headerId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				revision: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				version: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				when: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["SubCheckoutID"],
			details: { SubCheckoutID: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tSclFileUUIDCheckoutRestriction",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Variable: {
		tag: "Variable",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "A Variable is a way to define a global variable which can be modified by a user and applied to a list of SCL attributes\n\nA Variable is a way to define a global variable which can be modified by a user and applied to a list of SCL attributes",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"uuid",
				"value"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				value: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "VariableApplyTo"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				VariableApplyTo: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	CommunicationServiceSpecifications: {
		tag: "CommunicationServiceSpecifications",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "The CommunicationServiceSpecifications is containing parameters used to create control blocks during implementation\n\nThe CommunicationServiceSpecifications is containing parameters used to create control blocks during implementation",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"GooseParameters",
				"SMVParameters",
				"ReportParameters"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GooseParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SMVParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ReportParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: [
					"GooseParameters",
					"SMVParameters",
					"ReportParameters"
				]
			}]
		},
		constraints: [{
			name: "commServiceSpecKey",
			kind: "key",
			paths: [["*"]],
			deep: !1,
			attributes: ["id"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ServiceSpecifications: {
		tag: "ServiceSpecifications",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "The ServiceSpecification is containing parameters used to create control blocks or physical interface (LPDI/LPDO) during implementation\n\nThe ServiceSpecification is containing parameters used to create control blocks or physical interface (LPDI/LPDO) during implementation",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"GooseParameters",
				"SMVParameters",
				"ReportParameters",
				"BinaryWiringParameters",
				"AnalogueWiringParameters",
				"LogParameters"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GooseParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SMVParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ReportParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				BinaryWiringParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				AnalogueWiringParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				LogParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: [
					"GooseParameters",
					"SMVParameters",
					"ReportParameters",
					"BinaryWiringParameters",
					"AnalogueWiringParameters",
					"LogParameters"
				]
			}]
		},
		constraints: [{
			name: "serviceSpecKey",
			kind: "key",
			paths: [["*"]],
			deep: !1,
			attributes: ["id"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BayType: {
		tag: "BayType",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Bay type element is keeping value of the type. It's a free string\n\nBay type element is keeping value of the type. It's a free string",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBayType",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	AllocationRole: {
		tag: "AllocationRole",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Definition of an allocation role allowing definition of possible allocation to devices type without using virtual IED\n\nDefinition of an allocation role allowing definition of possible allocation to devices type without using virtual IED",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Application: {
		tag: "Application",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Application definition to be added at Process, Substation, Voltage Level or Bay level\n\nApplication definition to be added at Process, Substation, Voltage Level or Bay level",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionRole",
				"FunctionalVariant",
				"FunctionalVariantGroup",
				"AllocationRoleRef",
				"ApplicationSclRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionRole: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueRoleContent",
						kind: "unique",
						paths: [["FunctionRoleContent"]],
						deep: !1,
						attributes: ["roleInst"],
						refer: null,
						text: !1
					}]
				},
				FunctionalVariant: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				FunctionalVariantGroup: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				AllocationRoleRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				ApplicationSclRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BehaviorDescription: {
		tag: "BehaviorDescription",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Element allowing to describe the behavior its parent (Application, Bay, Function, LN...)\n\nElement allowing to describe the behavior its parent (Application, Bay, Function, LN...)",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"fileReference",
				"format",
				"isSimulation",
				"isSpecification",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileReference: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				format: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"IEC 61131",
							"Textual",
							"Graphic"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				isSimulation: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				isSpecification: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"InputVar",
				"OutputVar",
				"BehaviorReference"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				InputVar: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				OutputVar: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				BehaviorReference: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueChildNameInBehaviorDescription",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["varName"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Project: {
		tag: "Project",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Element allowing to define a project, to identify the project and the process elements defined by this project\n\nElement allowing to define a project, to identify the project and the process elements defined by this project",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "ProjectProcessReference"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ProjectProcessReference: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionTemplate: {
		tag: "FunctionTemplate",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Base element for FSD format, will be used as a template element for Function/SubFunction or EqFunction/EqSubFunction\n\nBase element for FSD format, will be used as a template element for Function/SubFunction or EqFunction/EqSubFunction",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"LNode",
				"SubFunctionTemplate",
				"GeneralEquipment",
				"ConductingEquipment"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SubFunctionTemplate: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubFunctionTemplate",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInSubFuncTemplate",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipmentOfFunctionTemplate",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGEFuncTemplate",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				ConductingEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInConductingEquipmentOfFunctionTemplate",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInCondEqTemplate",
						kind: "unique",
						paths: [["SubEquipment|.", "EqFunction"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "t6-100LNodeContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SCL: {
		tag: "SCL",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"release",
				"revision",
				"version"
			],
			details: {
				release: {
					required: !0,
					default: "5",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 255,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				revision: {
					required: !0,
					default: "C",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z]", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				version: {
					required: !0,
					default: "2007",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["2[0-2][0-9]{2}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Header",
				"Substation",
				"Communication",
				"IED",
				"DataTypeTemplates",
				"Line",
				"Process"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Header: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueHitem",
						kind: "unique",
						paths: [["History", "Hitem"]],
						deep: !1,
						attributes: ["version", "revision"],
						refer: null,
						text: !1
					}]
				},
				Substation: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Communication: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				IED: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				DataTypeTemplates: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Line: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Process: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [
			{
				name: "SubstationKey",
				kind: "key",
				paths: [[
					"Substation|.",
					"Process|.",
					"Line"
				]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "IEDKey",
				kind: "key",
				paths: [["IED"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "LNodeTypeKey",
				kind: "key",
				paths: [["DataTypeTemplates", "LNodeType"]],
				deep: !1,
				attributes: ["id", "lnClass"],
				refer: null,
				text: !1
			},
			{
				name: "ConnectivityNodeKey",
				kind: "key",
				paths: [["ConnectivityNode"]],
				deep: !0,
				attributes: ["pathName"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueHitem",
				kind: "unique",
				paths: [["History", "Hitem"]],
				deep: !1,
				attributes: ["version", "revision"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueUUID",
				kind: "unique",
				paths: [["*"]],
				deep: !0,
				attributes: ["uuid"],
				refer: null,
				text: !1
			},
			{
				name: "ref2LNodeTypeDomain1",
				kind: "keyref",
				paths: [[
					"IED",
					"AccessPoint",
					"LN"
				]],
				deep: !1,
				attributes: ["lnType", "lnClass"],
				refer: "LNodeTypeKey",
				text: !1
			},
			{
				name: "ref2LNodeTypeDomain2",
				kind: "keyref",
				paths: [[
					"IED",
					"AccessPoint",
					"Server",
					"LDevice",
					"LN"
				]],
				deep: !1,
				attributes: ["lnType", "lnClass"],
				refer: "LNodeTypeKey",
				text: !1
			},
			{
				name: "ref2LNodeTypeLLN0",
				kind: "keyref",
				paths: [[
					"IED",
					"AccessPoint",
					"Server",
					"LDevice",
					"LN0"
				]],
				deep: !1,
				attributes: ["lnType", "lnClass"],
				refer: "LNodeTypeKey",
				text: !1
			},
			{
				name: "refConnectedAP2IED",
				kind: "keyref",
				paths: [[
					"Communication",
					"SubNetwork",
					"ConnectedAP"
				]],
				deep: !1,
				attributes: ["iedName"],
				refer: "IEDKey",
				text: !1
			},
			{
				name: "ref2SubstationFromTerminal",
				kind: "keyref",
				paths: [["Terminal"]],
				deep: !0,
				attributes: ["substationName"],
				refer: "scl:SubstationKey",
				text: !1
			}
		],
		value: {
			type: "tBaseElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Substation: {
		tag: "Substation",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Process", "SCL"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"PowerTransformer",
				"GeneralEquipment",
				"VoltageLevel",
				"Function"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				PowerTransformer: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInPowerTransformer",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInPTR",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGE",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				VoltageLevel: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueChildNameInVoltageLevel",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}, {
						name: "uniqueLNodeInVoltageLevel",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}]
				},
				Function: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFunctionSS",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInSubstationFunc",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueChildNameInSubstation",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}, {
			name: "uniqueLNodeInSubstation",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tEquipmentContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Process: {
		tag: "Process",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Process", "SCL"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"GeneralEquipment",
				"Function",
				"ConductingEquipment",
				"Substation",
				"Line",
				"Process"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipment2",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGE2",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				Function: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFunction",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				ConductingEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Substation: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueChildNameInProcessSubstation",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}, {
						name: "uniqueLNodeInProcessSubstation",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}]
				},
				Line: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Process: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueChildNameInSubProcess",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}, {
						name: "uniqueLNodeInSubProcess",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueChildNameInProcess",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}, {
			name: "uniqueLNodeInProcess",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tGeneralEquipmentContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Line: {
		tag: "Line",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Process", "SCL"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"nomFreq",
				"numPhases",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				nomFreq: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: "0",
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				numPhases: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 255,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"GeneralEquipment",
				"Function",
				"Voltage",
				"ConductingEquipment",
				"ConnectivityNode"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipment2",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGE2",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				Function: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFunction",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				Voltage: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConductingEquipment: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				},
				ConnectivityNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueChildNameInLine",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}, {
			name: "uniqueLNodeInLine",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tGeneralEquipmentContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LN0: {
		tag: "LN0",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LDevice"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"inst",
				"lnClass",
				"lnType",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inst: {
					required: !0,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !0,
					default: "LLN0",
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"DataSet",
				"ReportControl",
				"LogControl",
				"DOI",
				"Inputs",
				"Outputs",
				"Log",
				"Labels",
				"GSEControl",
				"SampledValueControl",
				"SettingControl"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				DataSet: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				ReportControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				LogControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				DOI: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueSDI_DAIinDOI",
						kind: "unique",
						paths: [["DAI|.", "SDI"]],
						deep: !1,
						attributes: ["name", "ix"],
						refer: null,
						text: !1
					}]
				},
				Inputs: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Outputs: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Log: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInLN",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				GSEControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SampledValueControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SettingControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [
			{
				name: "DataSetKeyLN0",
				kind: "key",
				paths: [["DataSet"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueReportControlInLN0",
				kind: "unique",
				paths: [["ReportControl"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueLogControlInLN0",
				kind: "unique",
				paths: [["LogControl"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueGSEControlInLN0",
				kind: "unique",
				paths: [["GSEControl"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueSampledValueControlInLN0",
				kind: "unique",
				paths: [["SampledValueControl"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueDOIinLN0",
				kind: "unique",
				paths: [["DOI"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueLogInLN0",
				kind: "unique",
				paths: [["Log"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "ref2DataSetReportLN0",
				kind: "keyref",
				paths: [["ReportControl"]],
				deep: !1,
				attributes: ["datSet"],
				refer: "DataSetKeyLN0",
				text: !1
			},
			{
				name: "ref2DataSetLogLN0",
				kind: "keyref",
				paths: [["LogControl"]],
				deep: !1,
				attributes: ["datSet"],
				refer: "DataSetKeyLN0",
				text: !1
			},
			{
				name: "ref2DataSetGSELN0",
				kind: "keyref",
				paths: [["GSEControl"]],
				deep: !1,
				attributes: ["datSet"],
				refer: "DataSetKeyLN0",
				text: !1
			},
			{
				name: "ref2DataSetSVLN0",
				kind: "keyref",
				paths: [["SampledValueControl"]],
				deep: !1,
				attributes: ["datSet"],
				refer: "DataSetKeyLN0",
				text: !1
			}
		],
		value: {
			type: "tLN0",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LN: {
		tag: "LN",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["AccessPoint", "LDevice"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"inst",
				"lnClass",
				"lnType",
				"prefix",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"DataSet",
				"ReportControl",
				"LogControl",
				"DOI",
				"Inputs",
				"Outputs",
				"Log",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				DataSet: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				ReportControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				LogControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				DOI: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueSDI_DAIinDOI",
						kind: "unique",
						paths: [["DAI|.", "SDI"]],
						deep: !1,
						attributes: ["name", "ix"],
						refer: null,
						text: !1
					}]
				},
				Inputs: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Outputs: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Log: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInLN",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [
			{
				name: "DataSetKeyInLN",
				kind: "key",
				paths: [["DataSet"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueReportControlInLN",
				kind: "unique",
				paths: [["ReportControl"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueLogControlInLN",
				kind: "unique",
				paths: [["LogControl"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueDOIinLN",
				kind: "unique",
				paths: [["DOI"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueLogInLN",
				kind: "unique",
				paths: [["Log"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "ref2DataSetReport",
				kind: "keyref",
				paths: [["ReportControl"]],
				deep: !1,
				attributes: ["datSet"],
				refer: "DataSetKeyInLN",
				text: !1
			},
			{
				name: "ref2DataSetLog",
				kind: "keyref",
				paths: [["LogControl"]],
				deep: !1,
				attributes: ["datSet"],
				refer: "DataSetKeyInLN",
				text: !1
			}
		],
		value: {
			type: "tAnyLN",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	IED: {
		tag: "IED",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SCL"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"configVersion",
				"desc",
				"engRight",
				"manufacturer",
				"name",
				"originalSclRelease",
				"originalSclRevision",
				"originalSclVersion",
				"owner",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				configVersion: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				engRight: {
					required: !1,
					default: "full",
					namespace: null,
					validation: {
						enumeration: [
							"full",
							"fix",
							"dataflow"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				manufacturer: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originalSclRelease: {
					required: !1,
					default: "1",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 255,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originalSclRevision: {
					required: !1,
					default: "A",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z]", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originalSclVersion: {
					required: !1,
					default: "2003",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["2[0-2][0-9]{2}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				owner: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Services",
				"AccessPoint",
				"KDC",
				"IEDSourceFiles",
				"MinRequestedSCDFiles",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Services: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				AccessPoint: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNInAccessPoint",
						kind: "unique",
						paths: [["LN"]],
						deep: !1,
						attributes: [
							"inst",
							"lnClass",
							"prefix"
						],
						refer: null,
						text: !1
					}]
				},
				KDC: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				IEDSourceFiles: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				MinRequestedSCDFiles: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueProjectInReqSCD",
						kind: "unique",
						paths: [["MinRequestedSCDFile"]],
						deep: !1,
						attributes: ["fileUuid"],
						refer: null,
						text: !1
					}]
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInIED",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [
			{
				name: "LDeviceInIEDKey",
				kind: "key",
				paths: [[
					"AccessPoint",
					"Server",
					"LDevice"
				]],
				deep: !1,
				attributes: ["inst"],
				refer: null,
				text: !1
			},
			{
				name: "AccessPointInIEDKey",
				kind: "key",
				paths: [["AccessPoint"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "ref2LDeviceInDataSetForFCDAinLN",
				kind: "keyref",
				paths: [[
					"AccessPoint",
					"Server",
					"LDevice",
					"LN",
					"DataSet",
					"FCDA"
				]],
				deep: !1,
				attributes: ["ldInst"],
				refer: "LDeviceInIEDKey",
				text: !1
			},
			{
				name: "ref2LDeviceInDataSetForFCDAinLN0",
				kind: "keyref",
				paths: [[
					"AccessPoint",
					"Server",
					"LDevice",
					"LN0",
					"DataSet",
					"FCDA"
				]],
				deep: !1,
				attributes: ["ldInst"],
				refer: "LDeviceInIEDKey",
				text: !1
			},
			{
				name: "ServerAtRef2AccessPoint",
				kind: "keyref",
				paths: [["AccessPoint", "ServerAt"]],
				deep: !1,
				attributes: ["apName"],
				refer: "AccessPointInIEDKey",
				text: !1
			}
		],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Communication: {
		tag: "Communication",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SCL"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"SubNetwork"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SubNetwork: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueConnectedAP",
						kind: "unique",
						paths: [["ConnectedAP"]],
						deep: !1,
						attributes: ["iedName", "apName"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueSubNetwork",
			kind: "unique",
			paths: [["SubNetwork"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DataTypeTemplates: {
		tag: "DataTypeTemplates",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SCL"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [
				"LNodeType",
				"DOType",
				"DAType",
				"EnumType"
			],
			details: {
				LNodeType: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueDOInLNodeType",
						kind: "unique",
						paths: [["DO"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				DOType: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueDAorSDOInDOType",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				DAType: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueBDAInDAType",
						kind: "unique",
						paths: [["BDA"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}, {
						name: "uniqueProtNs",
						kind: "unique",
						paths: [["ProtNs"]],
						deep: !1,
						attributes: ["type"],
						refer: null,
						text: !1
					}]
				},
				EnumType: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueOrdInEnumType",
						kind: "unique",
						paths: [["EnumVal"]],
						deep: !1,
						attributes: ["ord"],
						refer: null,
						text: !1
					}, {
						name: "uniqueEnumValue",
						kind: "unique",
						paths: [["EnumVal"]],
						deep: !1,
						attributes: [],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [
			{
				name: "DOTypeKey",
				kind: "key",
				paths: [["DOType"]],
				deep: !1,
				attributes: ["id"],
				refer: null,
				text: !1
			},
			{
				name: "EnumTypeDATypeKey",
				kind: "key",
				paths: [["DAType | scl:EnumType"]],
				deep: !1,
				attributes: ["id"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueDTT_ID",
				kind: "unique",
				paths: [["*"]],
				deep: !1,
				attributes: ["id"],
				refer: null,
				text: !1
			},
			{
				name: "ref2DOType",
				kind: "keyref",
				paths: [["LNodeType", "DO"]],
				deep: !1,
				attributes: ["type"],
				refer: "DOTypeKey",
				text: !1
			},
			{
				name: "ref2DOTypeForSDO",
				kind: "keyref",
				paths: [["DOType", "SDO"]],
				deep: !1,
				attributes: ["type"],
				refer: "DOTypeKey",
				text: !1
			},
			{
				name: "ref2EnumTypeDAType",
				kind: "keyref",
				paths: [[
					"DOType",
					"DA | scl:DAType",
					"BDA"
				]],
				deep: !1,
				attributes: ["type"],
				refer: "scl:EnumTypeDATypeKey",
				text: !1
			}
		],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Text: {
		tag: "Text",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: /* @__PURE__ */ "AccessPoint.AllocationRole.AllocationRoleRef.AnalogueWiringParameters.AnalogueWiringParametersRef.Application.ApplicationSclRef.BDA.Bay.BehaviorDescription.BehaviorDescriptionRef.BehaviorReference.BinaryWiringParameters.BinaryWiringParametersRef.Communication.CommunicationServiceSpecifications.ConductingEquipment.ConnectedAP.ConnectivityNode.ControlRef.ControllingLNode.DA.DAI.DAS.DAType.DO.DOI.DOS.DOType.DataSet.EnumType.EqFunction.EqSubFunction.ExtCtrl.ExtRef.Function.FunctionCatRef.FunctionCategory.FunctionCategoryRef.FunctionRef.FunctionRole.FunctionRoleContent.FunctionSclRef.FunctionTemplate.FunctionalSubVariant.FunctionalVariant.FunctionalVariantGroup.FunctionalVariantRef.GOOSESecurity.GSE.GSEControl.GeneralEquipment.GooseParameters.GooseParametersRef.Header.IED.IEDSourceFiles.InputVar.InputVarRef.Inputs.L2CommParameters.L3IPv4CommParameters.L3IPv6CommParameters.LDevice.LN.LN0.LNode.LNodeDataRef.LNodeInputRef.LNodeInputs.LNodeOutputRef.LNodeOutputs.LNodeSpecNaming.LNodeType.Labels.Line.Log.LogControl.LogParameters.LogParametersRef.MinRequestedSCDFiles.NeutralPoint.OutputVar.OutputVarRef.Outputs.PhysConn.PowerSystemRelation.PowerSystemRelationRef.PowerSystemRelations.PowerTransformer.Process.ProcessEcho.ProcessResource.ProcessResourceRef.ProcessResources.Project.ProjectProcessReference.ReportControl.ReportParameters.ReportParametersRef.RptEnabled.SCL.SDI.SDO.SDS.SMV.SMVParameters.SMVParametersRef.SMVSecurity.SampledValueControl.SclFileReference.Server.ServerAt.ServiceSpecifications.SettingControl.SignalRole.SourceFiles.SourceRef.SubCategory.SubEquipment.SubFunction.SubFunctionTemplate.SubNetwork.SubscriberLNode.Substation.TapChanger.Terminal.TransformerWinding.Variable.VariableApplyTo.VariableRef.VoltageLevel".split("."),
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["source"],
			details: { source: {
				required: !1,
				default: null,
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tAnyContentFromOtherNamespace",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SubCategory: {
		tag: "SubCategory",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Recursive definition of function category\n\nRecursive definition of function category",
		parents: ["FunctionCategory", "SubCategory"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"SubCategory",
				"FunctionCatRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SubCategory: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				FunctionCatRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionCatRef: {
		tag: "FunctionCatRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a function which is part of the current category\n\nReference to a function which is part of the current category",
		parents: ["FunctionCategory", "SubCategory"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["function", "functionUuid"],
			details: {
				function: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				functionUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ProcessResource: {
		tag: "ProcessResource",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["ProcessResources"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"cardinality",
				"desc",
				"max",
				"name",
				"originUuid",
				"selector",
				"templateUuid",
				"uuid"
			],
			details: {
				cardinality: {
					required: !1,
					default: "1..1",
					namespace: null,
					validation: {
						enumeration: [
							"0..1",
							"1..1",
							"0..n",
							"1..n"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				max: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 2,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				selector: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Resource"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Resource: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueResource",
			kind: "unique",
			paths: [["Resource"]],
			deep: !1,
			attributes: ["resInst"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	PowerSystemRelation: {
		tag: "PowerSystemRelation",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["PowerSystemRelations"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"relation",
				"relationUuid",
				"selector",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				relation: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				relationUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				selector: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SourceRef: {
		tag: "SourceRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a data in the process\n\nReference to a data in the process",
		parents: ["LNodeInputs"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"extRefAddr",
				"extRefUuid",
				"input",
				"inputInst",
				"originUuid",
				"pDA",
				"pDO",
				"pLN",
				"resourceName",
				"resourceUuid",
				"service",
				"source",
				"sourceDaName",
				"sourceDoName",
				"sourceLNodeUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				extRefAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				extRefUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				input: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inputInst: {
					required: !1,
					default: "1",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 1,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pDA: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pDO: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pLN: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				service: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"Poll",
							"Report",
							"GOOSE",
							"SMV",
							"Wired",
							"Internal"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				source: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceDaName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceDoName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceLNodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"GooseParametersRef",
				"SMVParametersRef",
				"ReportParametersRef",
				"BinaryWiringParametersRef",
				"AnalogueWiringParametersRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GooseParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SMVParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ReportParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				BinaryWiringParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				AnalogueWiringParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: 1,
				options: [
					"GooseParametersRef",
					"SMVParametersRef",
					"ReportParametersRef",
					"BinaryWiringParametersRef",
					"AnalogueWiringParametersRef"
				]
			}]
		},
		constraints: [],
		value: {
			type: "tLinkFCDARef",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ControlRef: {
		tag: "ControlRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a control data in the process\n\nReference to a control data in the process",
		parents: ["LNodeOutputs"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"controlled",
				"controlledDoName",
				"controlledLNodeUuid",
				"desc",
				"extCtrlAddr",
				"extCtrlUuid",
				"originUuid",
				"output",
				"outputInst",
				"pDO",
				"pLN",
				"resourceName",
				"resourceUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				controlled: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				controlledDoName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				controlledLNodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				extCtrlAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				extCtrlUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				output: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outputInst: {
					required: !1,
					default: "1",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 1,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pDO: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pLN: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"BinaryWiringParametersRef",
				"AnalogueWiringParametersRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				BinaryWiringParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				AnalogueWiringParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: 1,
				options: ["BinaryWiringParametersRef", "AnalogueWiringParametersRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tLinkFCDRef",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SDS: {
		tag: "SDS",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of a sub-Data Object\n\nSpecification of a sub-Data Object",
		parents: ["DOS", "SDS"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"ix",
				"mappedDoName",
				"mappedLnUuid",
				"name"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				mappedDoName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				mappedLnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"SDS",
				"DAS",
				"SubscriberLNode",
				"ControllingLNode",
				"ProcessEcho",
				"LogParametersRef",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SDS: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				DAS: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SubscriberLNode: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ControllingLNode: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ProcessEcho: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				LogParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInSDS",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: [
					"SDS",
					"DAS",
					"SubscriberLNode",
					"ControllingLNode",
					"ProcessEcho",
					"LogParametersRef"
				]
			}]
		},
		constraints: [{
			name: "uniqueSDS_DASinSDS",
			kind: "unique",
			paths: [["DAS|.", "SDS"]],
			deep: !1,
			attributes: ["name", "ix"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DAS: {
		tag: "DAS",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of a Data attribute\n\nSpecification of a Data attribute",
		parents: ["DOS", "SDS"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"ix",
				"mappedDaName",
				"mappedLnUuid",
				"name",
				"valImport",
				"valKind"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				mappedDaName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)\\.([a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*)"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				mappedLnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valImport: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valKind: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"Spec",
							"Conf",
							"RO",
							"Set"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"SubscriberLNode",
				"ControllingLNode",
				"ProcessEcho",
				"LogParametersRef",
				"Val",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SubscriberLNode: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ControllingLNode: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ProcessEcho: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				LogParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Val: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInDAS",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: [
					"SubscriberLNode",
					"ControllingLNode",
					"ProcessEcho",
					"LogParametersRef",
					"Val",
					"Labels"
				]
			}]
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SubscriberLNode: {
		tag: "SubscriberLNode",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: [
			"DAS",
			"DOS",
			"SDS"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"inputName",
				"pLN",
				"resourceName",
				"resourceUuid",
				"service"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inputName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pLN: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				service: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"Poll",
							"Report",
							"GOOSE",
							"SMV",
							"Wired",
							"Internal"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"GooseParametersRef",
				"SMVParametersRef",
				"ReportParametersRef",
				"BinaryWiringParametersRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GooseParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SMVParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ReportParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				BinaryWiringParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: 1,
				options: [
					"GooseParametersRef",
					"SMVParametersRef",
					"ReportParametersRef",
					"BinaryWiringParametersRef"
				]
			}]
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ControllingLNode: {
		tag: "ControllingLNode",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: [
			"DAS",
			"DOS",
			"SDS"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"outputName",
				"pLN",
				"resourceName",
				"resourceUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outputName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pLN: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"BinaryWiringParametersRef",
				"AnalogueWiringParametersRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				BinaryWiringParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				AnalogueWiringParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: 1,
				options: ["BinaryWiringParametersRef", "AnalogueWiringParametersRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LogParametersRef: {
		tag: "LogParametersRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of the Log parameters expected for the current DOS when Log capability is required\n\nSpecification of the Log parameters expected for the current DOS when Log capability is required",
		parents: [
			"DAS",
			"DOS",
			"SDS"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc", "id"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Labels: {
		tag: "Labels",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: /* @__PURE__ */ "AccessPoint.BDA.Bay.ConductingEquipment.ConnectivityNode.DA.DAI.DAS.DAType.DO.DOI.DOS.DOType.EqFunction.EqSubFunction.Function.GOOSESecurity.GeneralEquipment.IED.LDevice.LN.LN0.LNode.LNodeType.Line.PowerTransformer.Process.SDI.SDO.SDS.SMVSecurity.SubEquipment.SubFunction.SubNetwork.Substation.TapChanger.TransformerWinding.VoltageLevel".split("."),
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Label"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Label: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLabel",
			kind: "unique",
			paths: [["Label"]],
			deep: !1,
			attributes: ["id", "lang"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SclFileReference: {
		tag: "SclFileReference",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"ApplicationSclRef",
			"FunctionSclRef",
			"IEDSourceFiles",
			"SourceFiles"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"fileName",
				"fileType",
				"fileUuid",
				"revision",
				"version",
				"when"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"ICD",
							"IID",
							"CID",
							"SSD",
							"SCD",
							"SED"
						],
						pattern: ["\\i\\c*", "[A-Z]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				revision: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				version: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				when: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SubCheckoutID: {
		tag: "SubCheckoutID",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "When an IED is checkedout for a collaborative work by an SCC, it may be required to give right to a subpart of the collaborative project. So a CheckoutID may have an additional SubCheckoutID giving IED to nother project\n\nWhen an IED is checkedout for a collaborative work by an SCC, it may be required to give right to a subpart of the collaborative project. So a CheckoutID may have an additional SubCheckoutID giving IED to nother project",
		parents: ["CheckoutID", "SubCheckoutID"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"engRight",
				"fileName",
				"fileType",
				"fileUuid",
				"headerId",
				"revision",
				"version",
				"when"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				engRight: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"full",
							"fix",
							"dataflow"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"SED",
							"SCC",
							"ICD",
							"IID",
							"CID",
							"SSD",
							"SCD"
						],
						pattern: ["\\i\\c*", "[A-Z]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				headerId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				revision: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				version: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				when: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["SubCheckoutID"],
			details: { SubCheckoutID: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tSclFileUUIDCheckoutRestriction",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	VariableApplyTo: {
		tag: "VariableApplyTo",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["Variable"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"attribute",
				"daName",
				"defaultValue",
				"desc",
				"doName",
				"element",
				"elementUuid",
				"format",
				"sGroup"
			],
			details: {
				attribute: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				daName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				defaultValue: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				doName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				element: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				elementUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				format: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sGroup: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GooseParameters: {
		tag: "GooseParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"cbName",
				"desc",
				"dsName",
				"goId",
				"id",
				"maxTime",
				"minTime",
				"securityEnabled"
			],
			details: {
				cbName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dsName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				goId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxTime: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				minTime: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				securityEnabled: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"L2CommParameters",
				"L3IPv4CommParameters",
				"L3IPv6CommParameters"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				L2CommParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				L3IPv4CommParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				L3IPv6CommParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: 1,
				options: [
					"L2CommParameters",
					"L3IPv4CommParameters",
					"L3IPv6CommParameters"
				]
			}]
		},
		constraints: [],
		value: {
			type: "tControlBlockParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SMVParameters: {
		tag: "SMVParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"cbName",
				"desc",
				"dsName",
				"id",
				"multicast",
				"nofASDU",
				"securityEnabled",
				"smpMod",
				"smpRate",
				"smvId"
			],
			details: {
				cbName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dsName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				multicast: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				nofASDU: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				securityEnabled: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				smpMod: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"SmpPerPeriod",
							"SmpPerSec",
							"SecPerSmp"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				smpRate: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				smvId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"L2CommParameters",
				"L3IPv4CommParameters",
				"L3IPv6CommParameters"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				L2CommParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				L3IPv4CommParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				L3IPv6CommParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: 1,
				options: [
					"L2CommParameters",
					"L3IPv4CommParameters",
					"L3IPv6CommParameters"
				]
			}]
		},
		constraints: [],
		value: {
			type: "tControlBlockParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ReportParameters: {
		tag: "ReportParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"bufTime",
				"buffered",
				"cbName",
				"desc",
				"dsName",
				"id",
				"intgPd"
			],
			details: {
				bufTime: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				buffered: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cbName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dsName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intgPd: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlBlockParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BinaryWiringParameters: {
		tag: "BinaryWiringParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["ServiceSpecifications"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"debTm",
				"desc",
				"fastOutput",
				"id",
				"inpNam",
				"inpRef",
				"outNam",
				"outOffDl",
				"outOnDl",
				"outRef",
				"outTyp",
				"vInOff",
				"vInOn"
			],
			details: {
				debTm: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fastOutput: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inpNam: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inpRef: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outNam: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outOffDl: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outOnDl: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outRef: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outTyp: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"Normally open",
							"Normally closed",
							"Change over"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vInOff: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vInOn: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tWiringParameters",
			validation: {
				enumeration: [
					"Normally open",
					"Normally closed",
					"Change over"
				],
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	AnalogueWiringParameters: {
		tag: "AnalogueWiringParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["ServiceSpecifications"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"dsgInp",
				"fctInp",
				"id",
				"inpNam",
				"inpRef"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dsgInp: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fctInp: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inpNam: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inpRef: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tWiringParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LogParameters: {
		tag: "LogParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["ServiceSpecifications"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"cbName",
				"desc",
				"dsName",
				"id",
				"intgPd",
				"logEna",
				"logLdInst",
				"logLnClass",
				"logLnInst",
				"logName",
				"logPrefix",
				"reasonCode"
			],
			details: {
				cbName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dsName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intgPd: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logEna: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logLdInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logLnClass: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logLnInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logPrefix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				reasonCode: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlBlockParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionRef: {
		tag: "FunctionRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a function definition attached to current allocation role\n\nReference to a function definition attached to current allocation role",
		parents: ["AllocationRole", "FunctionRoleContent"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"function",
				"functionUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				function: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				functionUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionalVariantRef",
				"SignalRole"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SignalRole: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionRole: {
		tag: "FunctionRole",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Role attached to the application type\n\nRole attached to the application type",
		parents: ["Application"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"cardinality",
				"desc",
				"max",
				"name",
				"originUuid",
				"selector",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				cardinality: {
					required: !1,
					default: "1..1",
					namespace: null,
					validation: {
						enumeration: [
							"0..1",
							"1..1",
							"0..n",
							"1..n"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				max: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 2,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				selector: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionalVariantRef",
				"FunctionRoleContent"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				FunctionRoleContent: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}, {
				minOccurrence: 1,
				maxOccurrence: null,
				options: ["FunctionRoleContent"]
			}]
		},
		constraints: [{
			name: "uniqueRoleContent",
			kind: "unique",
			paths: [["FunctionRoleContent"]],
			deep: !1,
			attributes: ["roleInst"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionalVariant: {
		tag: "FunctionalVariant",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Variant attached to the application type\n\nVariant attached to the application type",
		parents: ["Application", "FunctionalVariantGroup"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"isBaseline",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				isBaseline: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionalSubVariant",
				"VariableRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalSubVariant: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				VariableRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalSubVariant", "VariableRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tAbstractFunctionalVariant",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionalVariantGroup: {
		tag: "FunctionalVariantGroup",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Group of variants attached to the application type\n\nGroup of variants attached to the application type",
		parents: ["Application"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariant"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariant: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	AllocationRoleRef: {
		tag: "AllocationRoleRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Allocation role attached to the application type\n\nAllocation role attached to the application type",
		parents: ["Application"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"allocationRole",
				"allocationRoleUuid",
				"desc"
			],
			details: {
				allocationRole: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				allocationRoleUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ApplicationSclRef: {
		tag: "ApplicationSclRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to the ASD files used to create an Application\n\nReference to the ASD files used to create an Application",
		parents: ["Application"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "SclFileReference"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SclFileReference: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	InputVar: {
		tag: "InputVar",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Input variable used in the behavior description\n\nInput variable used in the behavior description",
		parents: ["BehaviorDescription"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"daName",
				"dataName",
				"desc",
				"doName",
				"inputName",
				"inputUuid",
				"lnodeUuid",
				"value",
				"varName"
			],
			details: {
				daName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dataName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				doName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inputName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inputUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				value: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				varName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tLogicVarRef",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	OutputVar: {
		tag: "OutputVar",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Output variable used in the behavior description\n\nOutput variable used in the behavior description",
		parents: ["BehaviorDescription"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"daName",
				"dataName",
				"desc",
				"doName",
				"lnodeUuid",
				"outputName",
				"outputUuid",
				"value",
				"varName"
			],
			details: {
				daName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dataName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				doName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outputName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outputUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				value: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				varName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tLogicVarRef",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BehaviorReference: {
		tag: "BehaviorReference",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a behavior description when for example a manufacturer wants to indicate its implementation of a user specification described by another behavior description\n\nReference to a behavior description when for example a manufacturer wants to indicate its implementation of a user specification described by another behavior description",
		parents: ["BehaviorDescription"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"behaviorReference",
				"behaviorUuid",
				"desc"
			],
			details: {
				behaviorReference: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				behaviorUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ProjectProcessReference: {
		tag: "ProjectProcessReference",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to the process elements belonging to the current project\n\nReference to the process elements belonging to the current project",
		parents: ["Project"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"processReference",
				"processUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				processReference: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				processUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNode: {
		tag: "LNode",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"Bay",
			"ConductingEquipment",
			"ConnectivityNode",
			"EqFunction",
			"EqSubFunction",
			"Function",
			"FunctionTemplate",
			"GeneralEquipment",
			"Line",
			"PowerTransformer",
			"Process",
			"SubEquipment",
			"SubFunction",
			"SubFunctionTemplate",
			"Substation",
			"TapChanger",
			"TransformerWinding",
			"VoltageLevel"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"iedName",
				"ldInst",
				"lnClass",
				"lnInst",
				"lnType",
				"lnUuid",
				"prefix",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedName: {
					required: !1,
					default: "None",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"None",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 0,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnType: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInLNode",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SubFunctionTemplate: {
		tag: "SubFunctionTemplate",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["FunctionTemplate", "SubFunctionTemplate"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"LNode",
				"GeneralEquipment",
				"ConductingEquipment",
				"SubFunctionTemplate"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipmentOfSubFunctionTemplate",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGESubFuncTemplate",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				ConductingEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInConductingEquipmentOfSubFunctionTemplate",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueSubEquipmentSubFuncTemplate",
						kind: "unique",
						paths: [["SubEquipment"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				SubFunctionTemplate: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubSubFunctionTemplate",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueSubSubFuncTemplate",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInSubFunctionTemplate",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInSubFuncTemplate",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "t6-100LNodeContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GeneralEquipment: {
		tag: "GeneralEquipment",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"Bay",
			"EqFunction",
			"EqSubFunction",
			"Function",
			"FunctionTemplate",
			"Line",
			"Process",
			"SubFunction",
			"SubFunctionTemplate",
			"Substation",
			"VoltageLevel"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid",
				"virtual"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"AXN",
							"BAT",
							"MOT",
							"FAN",
							"FIL",
							"PMP",
							"TNK",
							"VLV"
						],
						pattern: ["\\i\\c*", "E[A-Z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 3,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				virtual: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"EqFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				EqFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFuncForGE",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFuncForGE",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInGeneralEquipment",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInGE",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tEquipment",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConductingEquipment: {
		tag: "ConductingEquipment",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"Bay",
			"Function",
			"FunctionTemplate",
			"Line",
			"Process",
			"SubFunction",
			"SubFunctionTemplate"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid",
				"virtual"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "CBR.DIS.VTR.CTR.GEN.CAP.REA.CON.MOT.EFN.PSH.BAT.BSH.CAB.GIL.LIN.RES.RRC.SAR.TCF.TCR.IFL.FAN.SCR.SMC.PMP".split("."),
						pattern: ["\\i\\c*", "E[A-Z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 3,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				virtual: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"Terminal",
				"SubEquipment",
				"EqFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Terminal: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 2
					},
					constraints: null
				},
				SubEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInACESubEquipment",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				EqFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFuncForCE",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFuncForCE",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tAbstractConductingEquipment",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Private: {
		tag: "Private",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: /* @__PURE__ */ "AccessPoint.BDA.Bay.Communication.ConductingEquipment.ConnectedAP.ConnectivityNode.DA.DAI.DAType.DO.DOI.DOType.DataSet.EnumType.EqFunction.EqSubFunction.ExtCtrl.ExtRef.Function.GOOSESecurity.GSE.GSEControl.GeneralEquipment.IED.IEDSourceFiles.Inputs.LDevice.LN.LN0.LNode.LNodeType.Labels.Line.Log.LogControl.MinRequestedSCDFiles.NeutralPoint.Outputs.PhysConn.PowerTransformer.Process.ReportControl.RptEnabled.SCL.SDI.SDO.SMV.SMVSecurity.SampledValueControl.SclFileReference.Server.ServerAt.SettingControl.SourceFiles.SubEquipment.SubFunction.SubNetwork.Substation.TapChanger.Terminal.TransformerWinding.VoltageLevel".split("."),
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["source", "type"],
			details: {
				source: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tAnyContentFromOtherNamespace",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Header: {
		tag: "Header",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SCL"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"baseUuid",
				"fileType",
				"id",
				"nameStructure",
				"revision",
				"toolID",
				"uuid",
				"version"
			],
			details: {
				baseUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileType: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"ICD",
							"IID",
							"CID",
							"SSD",
							"SCD",
							"SED"
						],
						pattern: ["\\i\\c*", "[A-Z]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				nameStructure: {
					required: !1,
					default: "IEDName",
					namespace: null,
					validation: {
						enumeration: ["IEDName"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				revision: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				toolID: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				version: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [
				"Text",
				"History",
				"SourceFiles"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				History: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SourceFiles: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueHitem",
			kind: "unique",
			paths: [["History", "Hitem"]],
			deep: !1,
			attributes: ["version", "revision"],
			refer: null,
			text: !1
		}],
		value: {
			type: null,
			validation: {
				enumeration: ["IEDName"],
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	PowerTransformer: {
		tag: "PowerTransformer",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"Bay",
			"Substation",
			"VoltageLevel"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid",
				"virtual"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: "PTR",
					namespace: null,
					validation: {
						enumeration: ["PTR"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				virtual: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"TransformerWinding",
				"SubEquipment",
				"EqFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				TransformerWinding: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInTransformerWinding",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInPTW",
						kind: "unique",
						paths: [[
							"SubEquipment|.",
							"TapChanger|.",
							"EqFunction"
						]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				SubEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubEquipmentPTR",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInPTRSubEquipment",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				EqFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFuncForPTR",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFuncForPTR",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInPowerTransformer",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInPTR",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tEquipment",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	VoltageLevel: {
		tag: "VoltageLevel",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Substation"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"nomFreq",
				"numPhases",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				nomFreq: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: "0",
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				numPhases: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 255,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"PowerTransformer",
				"GeneralEquipment",
				"Voltage",
				"Bay",
				"Function"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				PowerTransformer: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInPowerTransformer",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInPTR",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGE",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				Voltage: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Bay: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueChildNameInBay",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}, {
						name: "uniqueLNodeInBay",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}]
				},
				Function: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFunctionVL",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInVoltageLevelFunc",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueChildNameInVoltageLevel",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}, {
			name: "uniqueLNodeInVoltageLevel",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tEquipmentContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Function: {
		tag: "Function",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"Bay",
			"Line",
			"Process",
			"Substation",
			"VoltageLevel"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"SubFunction",
				"GeneralEquipment",
				"ConductingEquipment"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SubFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInSubFunc",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipmentOfFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGEFunc",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				ConductingEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInConductingEquipmentOfFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInCondEq",
						kind: "unique",
						paths: [["SubEquipment|.", "EqFunction"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInFunctionSS",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInSubstationFunc",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tPowerSystemResource",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Voltage: {
		tag: "Voltage",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Line", "VoltageLevel"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["multiplier", "unit"],
			details: {
				multiplier: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: [
							"",
							"m",
							"k",
							"M",
							"mu",
							"y",
							"z",
							"a",
							"f",
							"p",
							"n",
							"c",
							"d",
							"da",
							"h",
							"G",
							"T",
							"P",
							"E",
							"Z",
							"Y"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				unit: {
					required: !0,
					default: "V",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConnectivityNode: {
		tag: "ConnectivityNode",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Bay", "Line"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"pathName",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pathName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+/.+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tLNodeContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DataSet: {
		tag: "DataSet",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN", "LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"FCDA"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				FCDA: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 1,
				maxOccurrence: null,
				options: ["FCDA"]
			}]
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ReportControl: {
		tag: "ReportControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN", "LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"bufTime",
				"buffered",
				"confRev",
				"datSet",
				"desc",
				"indexed",
				"intgPd",
				"name",
				"rptID",
				"templateUuid",
				"uuid"
			],
			details: {
				bufTime: {
					required: !1,
					default: "0",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				buffered: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				confRev: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				indexed: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intgPd: {
					required: !1,
					default: "0",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				rptID: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[ -~]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 129,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"TrgOps",
				"OptFields",
				"RptEnabled"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				TrgOps: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				OptFields: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				RptEnabled: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlWithTriggerOpt",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LogControl: {
		tag: "LogControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN", "LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"bufTime",
				"datSet",
				"desc",
				"intgPd",
				"ldInst",
				"lnClass",
				"lnInst",
				"logEna",
				"logName",
				"name",
				"prefix",
				"reasonCode",
				"templateUuid",
				"uuid"
			],
			details: {
				bufTime: {
					required: !1,
					default: "0",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intgPd: {
					required: !1,
					default: "0",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !1,
					default: "LLN0",
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logEna: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				reasonCode: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"TrgOps"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				TrgOps: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlWithTriggerOpt",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DOI: {
		tag: "DOI",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN", "LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"accessControl",
				"desc",
				"ix",
				"name"
			],
			details: {
				accessControl: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 12,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"SDI",
				"DAI",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SDI: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueSDI_DAIinSDI",
						kind: "unique",
						paths: [["DAI|.", "SDI"]],
						deep: !1,
						attributes: ["name", "ix"],
						refer: null,
						text: !1
					}]
				},
				DAI: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelinDOI",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["SDI", "DAI"]
			}]
		},
		constraints: [{
			name: "uniqueSDI_DAIinDOI",
			kind: "unique",
			paths: [["DAI|.", "SDI"]],
			deep: !1,
			attributes: ["name", "ix"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Inputs: {
		tag: "Inputs",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN", "LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"ExtRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				ExtRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Outputs: {
		tag: "Outputs",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN", "LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"ExtCtrl"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				ExtCtrl: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Log: {
		tag: "Log",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN", "LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc", "name"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GSEControl: {
		tag: "GSEControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"appID",
				"confRev",
				"datSet",
				"desc",
				"fixedOffs",
				"name",
				"securityEnable",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				appID: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[ -~]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 129,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				confRev: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fixedOffs: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				securityEnable: {
					required: !1,
					default: "None",
					namespace: null,
					validation: {
						enumeration: [
							"None",
							"Signature",
							"SignatureAndEncryption"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: "GOOSE",
					namespace: null,
					validation: {
						enumeration: ["GSSE", "GOOSE"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"IEDName",
				"Protocol"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				IEDName: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Protocol: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlWithIEDName",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SampledValueControl: {
		tag: "SampledValueControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"confRev",
				"datSet",
				"desc",
				"multicast",
				"name",
				"nofASDU",
				"securityEnable",
				"smpMod",
				"smpRate",
				"smvID",
				"templateUuid",
				"uuid"
			],
			details: {
				confRev: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				multicast: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				nofASDU: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				securityEnable: {
					required: !1,
					default: "None",
					namespace: null,
					validation: {
						enumeration: [
							"None",
							"Signature",
							"SignatureAndEncryption"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				smpMod: {
					required: !1,
					default: "SmpPerPeriod",
					namespace: null,
					validation: {
						enumeration: [
							"SmpPerPeriod",
							"SmpPerSec",
							"SecPerSmp"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				smpRate: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				smvID: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[ -~]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 129,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"IEDName",
				"SmvOpts",
				"Protocol"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				IEDName: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SmvOpts: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Protocol: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlWithIEDName",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SettingControl: {
		tag: "SettingControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"actSG",
				"desc",
				"numOfSGs",
				"resvTms"
			],
			details: {
				actSG: {
					required: !1,
					default: "1",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 1,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				numOfSGs: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 1,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resvTms: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 65535,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Services: {
		tag: "Services",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["AccessPoint", "IED"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["nameLength"],
			details: { nameLength: {
				required: !1,
				default: "32",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: [
						"32",
						"64",
						"6[5-9]",
						"[7-9]\\d",
						"[1-9]\\d\\d+"
					],
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: /* @__PURE__ */ "DynAssociation.SettingGroups.GetDirectory.GetDataObjectDefinition.DataObjectDirectory.GetDataSetValue.SetDataSetValue.DataSetDirectory.ConfDataSet.DynDataSet.ReadWrite.TimerActivatedControl.ConfReportControl.GetCBValues.ConfLogControl.ReportSettings.LogSettings.GSESettings.SMVSettings.GSEDir.GOOSE.GSSE.SMVsc.FileHandling.ConfLNs.ClientServices.ConfLdName.SupSubscription.ConfSigRef.ValueHandling.RedProt.TimeSyncProt.CommProt.SCSM.Security.MultiAPPerSubNet".split("."),
			details: {
				DynAssociation: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SettingGroups: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GetDirectory: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GetDataObjectDefinition: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				DataObjectDirectory: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GetDataSetValue: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SetDataSetValue: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				DataSetDirectory: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConfDataSet: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				DynDataSet: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ReadWrite: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				TimerActivatedControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConfReportControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GetCBValues: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConfLogControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ReportSettings: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				LogSettings: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GSESettings: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SMVSettings: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GSEDir: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GOOSE: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GSSE: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SMVsc: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FileHandling: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConfLNs: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ClientServices: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConfLdName: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SupSubscription: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConfSigRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ValueHandling: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				RedProt: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				TimeSyncProt: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				CommProt: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SCSM: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Security: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				MultiAPPerSubNet: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	AccessPoint: {
		tag: "AccessPoint",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["IED"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"clock",
				"desc",
				"kdc",
				"name",
				"router",
				"templateUuid",
				"uuid"
			],
			details: {
				clock: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				kdc: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				router: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Server",
				"LN",
				"ServerAt",
				"Services",
				"GOOSESecurity",
				"SMVSecurity",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Server: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueAssociationInServer",
						kind: "unique",
						paths: [["Association"]],
						deep: !1,
						attributes: ["associationID"],
						refer: null,
						text: !1
					}]
				},
				LN: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				},
				ServerAt: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Services: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GOOSESecurity: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 7
					},
					constraints: null
				},
				SMVSecurity: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 7
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInAP",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: 1,
				options: [
					"Server",
					"LN",
					"ServerAt"
				]
			}]
		},
		constraints: [{
			name: "uniqueLNInAccessPoint",
			kind: "unique",
			paths: [["LN"]],
			deep: !1,
			attributes: [
				"inst",
				"lnClass",
				"prefix"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	KDC: {
		tag: "KDC",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["IED"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"apName",
				"apUuid",
				"iedName"
			],
			details: {
				apName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				apUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	IEDSourceFiles: {
		tag: "IEDSourceFiles",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["IED"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"SclFileReference"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SclFileReference: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	MinRequestedSCDFiles: {
		tag: "MinRequestedSCDFiles",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["IED"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"MinRequestedSCDFile"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				MinRequestedSCDFile: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueProjectInReqSCD",
			kind: "unique",
			paths: [["MinRequestedSCDFile"]],
			deep: !1,
			attributes: ["fileUuid"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SubNetwork: {
		tag: "SubNetwork",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Communication"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: ["8-MMS", "8-XMPP"],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"BitRate",
				"ConnectedAP"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				BitRate: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConnectedAP: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueGSEinConnectedAP",
						kind: "unique",
						paths: [["GSE"]],
						deep: !1,
						attributes: ["cbName", "ldInst"],
						refer: null,
						text: !1
					}, {
						name: "uniqueSMVinConnectedAP",
						kind: "unique",
						paths: [["SMV"]],
						deep: !1,
						attributes: ["cbName", "ldInst"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueConnectedAP",
			kind: "unique",
			paths: [["ConnectedAP"]],
			deep: !1,
			attributes: ["iedName", "apName"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNodeType: {
		tag: "LNodeType",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DataTypeTemplates"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"id",
				"iedType",
				"lnClass"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedType: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"DO",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				DO: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInLNType",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueDOInLNodeType",
			kind: "unique",
			paths: [["DO"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tIDNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DOType: {
		tag: "DOType",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DataTypeTemplates"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"cdc",
				"desc",
				"id",
				"iedType"
			],
			details: {
				cdc: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "SPS.DPS.INS.ENS.ACT.ACD.SEC.BCR.HST.VSS.MV.CMV.SAV.WYE.DEL.SEQ.HMV.HWYE.HDEL.SPC.DPC.INC.ENC.BSC.ISC.APC.BAC.SPG.ING.ENG.ORG.TSG.CUG.VSG.ASG.CURVE.CSG.DPL.LPL.CSD.CST.BTS.UTS.LTS.GTS.MTS.NTS.STS.CTS.OTS.VSD.ORS.TCS".split("."),
						pattern: ["\\i\\c*", "[A-Za-z]+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 5,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedType: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"SDO",
				"DA",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SDO: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				DA: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueProtNsInDA",
						kind: "unique",
						paths: [["ProtNs"]],
						deep: !1,
						attributes: ["type"],
						refer: null,
						text: !1
					}]
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInDOType",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["SDO", "DA"]
			}]
		},
		constraints: [{
			name: "uniqueDAorSDOInDOType",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tIDNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DAType: {
		tag: "DAType",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DataTypeTemplates"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"id",
				"iedType"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedType: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"BDA",
				"ProtNs",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				BDA: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				},
				ProtNs: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInDAType",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueBDAInDAType",
			kind: "unique",
			paths: [["BDA"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}, {
			name: "uniqueProtNs",
			kind: "unique",
			paths: [["ProtNs"]],
			deep: !1,
			attributes: ["type"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tIDNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	EnumType: {
		tag: "EnumType",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DataTypeTemplates"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc", "id"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"EnumVal"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				EnumVal: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: ["[\\p{IsBasicLatin}\\p{IsLatin-1Supplement}]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 127,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueOrdInEnumType",
			kind: "unique",
			paths: [["EnumVal"]],
			deep: !1,
			attributes: ["ord"],
			refer: null,
			text: !1
		}, {
			name: "uniqueEnumValue",
			kind: "unique",
			paths: [["EnumVal"]],
			deep: !1,
			attributes: [],
			refer: null,
			text: !1
		}],
		value: {
			type: "tIDNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Resource: {
		tag: "Resource",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "resource bound to this element could be multi\n\nresource bound to this element could be multi",
		parents: ["ProcessResource"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"resInst",
				"source",
				"sourceUuid"
			],
			details: {
				resInst: {
					required: !1,
					default: "1",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 1,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				source: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "normalizedString",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GooseParametersRef: {
		tag: "GooseParametersRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of the communication parameters expected for the current SourceRef when ServiceType is GOOSE\n\nSpecification of the communication parameters expected for the current SourceRef when ServiceType is GOOSE",
		parents: ["SourceRef", "SubscriberLNode"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc", "id"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SMVParametersRef: {
		tag: "SMVParametersRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of the communication parameters expected for the current SourceRef when ServiceType is SMV\n\nSpecification of the communication parameters expected for the current SourceRef when ServiceType is SMV",
		parents: ["SourceRef", "SubscriberLNode"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc", "id"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ReportParametersRef: {
		tag: "ReportParametersRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of the communication parameters expected for the current SourceRef when ServiceType is Report\n\nSpecification of the communication parameters expected for the current SourceRef when ServiceType is Report",
		parents: ["SourceRef", "SubscriberLNode"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc", "id"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BinaryWiringParametersRef: {
		tag: "BinaryWiringParametersRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of the binary wiring parameters expected for the current SourceRef when ServiceType is Wired\n\nSpecification of the binary wiring parameters expected for the current SourceRef when ServiceType is Wired",
		parents: [
			"ControlRef",
			"ControllingLNode",
			"SourceRef",
			"SubscriberLNode"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc", "id"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	AnalogueWiringParametersRef: {
		tag: "AnalogueWiringParametersRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of the analogue wiring parameters expected for the current SourceRef when ServiceType is Wired\n\nSpecification of the analogue wiring parameters expected for the current SourceRef when ServiceType is Wired",
		parents: [
			"ControlRef",
			"ControllingLNode",
			"SourceRef"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc", "id"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Val: {
		tag: "Val",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"BDA",
			"DA",
			"DAI",
			"DAS"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["sGroup"],
			details: { sGroup: {
				required: !1,
				default: null,
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: 0,
					maxInclusive: 4294967295,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "normalizedString",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Label: {
		tag: "Label",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Labels"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["id", "lang"],
			details: {
				id: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lang: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "normalizedString",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	L2CommParameters: {
		tag: "L2CommParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["GooseParameters", "SMVParameters"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"appId",
				"desc",
				"macAddr",
				"vlanId",
				"vlanPriority"
			],
			details: {
				appId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-F]{4}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				macAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vlanId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-F]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vlanPriority: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-7]"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tCommParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	L3IPv4CommParameters: {
		tag: "L3IPv4CommParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["GooseParameters", "SMVParameters"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"IPv4",
				"IPv4-IGMPv3Src",
				"appId",
				"desc",
				"vlanId",
				"vlanPriority"
			],
			details: {
				IPv4: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				"IPv4-IGMPv3Src": {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				appId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-F]{4}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vlanId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-F]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vlanPriority: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-7]"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tCommParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	L3IPv6CommParameters: {
		tag: "L3IPv6CommParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["GooseParameters", "SMVParameters"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"IPv6",
				"IPv6-IGMPv3Src",
				"appId",
				"desc",
				"vlanId",
				"vlanPriority"
			],
			details: {
				IPv6: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["([0-9a-f]{1,4}:){7}[0-9a-f]{1,4}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				"IPv6-IGMPv3Src": {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["([0-9a-f]{1,4}:){7}[0-9a-f]{1,4}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				appId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-F]{4}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vlanId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-F]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vlanPriority: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-7]"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tCommParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionalVariantRef: {
		tag: "FunctionalVariantRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Ref to a functional variant of the Application\n\nRef to a functional variant of the Application",
		parents: [
			"AllocationRoleRef",
			"BehaviorDescriptionRef",
			"FunctionCategoryRef",
			"FunctionRef",
			"FunctionRole",
			"InputVarRef",
			"LNodeDataRef",
			"LNodeInputRef",
			"LNodeOutputRef",
			"OutputVarRef",
			"PowerSystemRelationRef",
			"ProcessResourceRef",
			"SignalRole",
			"VariableRef"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"functionalVariant",
				"functionalVariantUuid",
				"update"
			],
			details: {
				functionalVariant: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				functionalVariantUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				update: {
					required: !1,
					default: "add",
					namespace: null,
					validation: {
						enumeration: ["add", "remove"],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElement",
			validation: {
				enumeration: ["add", "remove"],
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SignalRole: {
		tag: "SignalRole",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Signal list attached to the referenced function in the context of the cureent Role definition\n\nSignal list attached to the referenced function in the context of the cureent Role definition",
		parents: ["FunctionRef"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionalVariantRef",
				"LNodeInputRef",
				"LNodeOutputRef",
				"LNodeDataRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				LNodeInputRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				LNodeOutputRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				LNodeDataRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionRoleContent: {
		tag: "FunctionRoleContent",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "an instance of the current role. In case of application type definition, instance 1 is the default instance\n\nan instance of the current role. In case of application type definition, instance 1 is the default instance",
		parents: ["FunctionRole"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["roleInst"],
			details: { roleInst: {
				required: !1,
				default: "1",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: 1,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionRef",
				"BehaviorDescriptionRef",
				"ProcessResourceRef",
				"VariableRef",
				"FunctionCategoryRef",
				"PowerSystemRelationRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				BehaviorDescriptionRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ProcessResourceRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				VariableRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionCategoryRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				PowerSystemRelationRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: [
					"FunctionRef",
					"BehaviorDescriptionRef",
					"ProcessResourceRef",
					"VariableRef",
					"FunctionCategoryRef",
					"PowerSystemRelationRef"
				]
			}]
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionalSubVariant: {
		tag: "FunctionalSubVariant",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Sub variant of the current variant\n\nSub variant of the current variant",
		parents: ["FunctionalSubVariant", "FunctionalVariant"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"isBaseline",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				isBaseline: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionalSubVariant",
				"VariableRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalSubVariant: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				VariableRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalSubVariant", "VariableRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tAbstractFunctionalVariant",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	VariableRef: {
		tag: "VariableRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a variable attached to current variant, to parameterize the instance with the value defined in the reference\n\nReference to a variable attached to current variant, to parameterize the instance with the value defined in the reference",
		parents: [
			"FunctionRoleContent",
			"FunctionalSubVariant",
			"FunctionalVariant"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"value",
				"variable",
				"variableUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				value: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				variable: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				variableUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tVariableRef",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	EqFunction: {
		tag: "EqFunction",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"ConductingEquipment",
			"GeneralEquipment",
			"PowerTransformer",
			"SubEquipment",
			"TapChanger",
			"TransformerWinding"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"GeneralEquipment",
				"EqSubFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipmentOfFuncForEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGEFuncForEquipment",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				EqSubFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubFuncForEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueSubFuncForEquipment",
						kind: "unique",
						paths: [["EqSubFunction"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInFuncForGE",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInFuncForGE",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tAbstractEqFuncSubFunc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Terminal: {
		tag: "Terminal",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ConductingEquipment", "TransformerWinding"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"bayName",
				"cNodeName",
				"cNodeUuid",
				"connectivityNode",
				"desc",
				"lineName",
				"name",
				"processName",
				"substationName",
				"voltageLevelName"
			],
			details: {
				bayName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cNodeName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cNodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				connectivityNode: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+/.+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lineName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				processName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				substationName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				voltageLevelName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SubEquipment: {
		tag: "SubEquipment",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"ConductingEquipment",
			"PowerTransformer",
			"TapChanger",
			"TransformerWinding"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"phase",
				"templateUuid",
				"uuid",
				"virtual"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				phase: {
					required: !1,
					default: "none",
					namespace: null,
					validation: {
						enumeration: [
							"A",
							"B",
							"C",
							"N",
							"all",
							"none",
							"AB",
							"BC",
							"CA"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				virtual: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"EqFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				EqFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFuncForSubEq",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFuncForSubEq",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInSubEquipment",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInACESubEquipment",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tPowerSystemResource",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	History: {
		tag: "History",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Header"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: ["Hitem"],
			details: { Hitem: {
				required: !0,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 1,
					maxOccurrence: null
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SourceFiles: {
		tag: "SourceFiles",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Header", "Hitem"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"SclFileReference"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SclFileReference: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	TransformerWinding: {
		tag: "TransformerWinding",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["PowerTransformer"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid",
				"virtual"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: "PTW",
					namespace: null,
					validation: {
						enumeration: ["PTW"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				virtual: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"Terminal",
				"SubEquipment",
				"TapChanger",
				"NeutralPoint",
				"EqFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Terminal: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 2
					},
					constraints: null
				},
				SubEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInACESubEquipment",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				TapChanger: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLNodeInTapChanger",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInLTC",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				NeutralPoint: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				EqFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFuncForPTW",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFuncForPTW",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInTransformerWinding",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInPTW",
			kind: "unique",
			paths: [[
				"SubEquipment|.",
				"TapChanger|.",
				"EqFunction"
			]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tAbstractConductingEquipment",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Bay: {
		tag: "Bay",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["VoltageLevel"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"PowerTransformer",
				"GeneralEquipment",
				"ConductingEquipment",
				"ConnectivityNode",
				"Function"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				PowerTransformer: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInPowerTransformer",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInPTR",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGE",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				ConductingEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInConductingEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInCE",
						kind: "unique",
						paths: [["SubEquipment|.", "EqFunction"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				ConnectivityNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInConnectivityNode",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}]
				},
				Function: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFunctionB",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInBayFunc",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueChildNameInBay",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}, {
			name: "uniqueLNodeInBay",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tEquipmentContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SubFunction: {
		tag: "SubFunction",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Function", "SubFunction"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"GeneralEquipment",
				"ConductingEquipment",
				"SubFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipmentOfSubFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGESubFunc",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				ConductingEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInConductingEquipmentOfSubFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueSubEquipmentSubFunc",
						kind: "unique",
						paths: [["SubEquipment"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				SubFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubSubFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueSubSubFunc",
						kind: "unique",
						paths: [["SubFunction"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInSubFunction",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInSubFunc",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tPowerSystemResource",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FCDA: {
		tag: "FCDA",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DataSet"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"daName",
				"doName",
				"fc",
				"ix",
				"ldInst",
				"lnClass",
				"lnInst",
				"lnUuid",
				"prefix"
			],
			details: {
				daName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				doName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fc: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"ST",
							"MX",
							"CO",
							"SP",
							"SG",
							"SE",
							"SV",
							"CF",
							"DC",
							"EX",
							"SR",
							"BL",
							"OR"
						],
						pattern: ["\\i\\c*", "[A-Z]+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 2,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	TrgOps: {
		tag: "TrgOps",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LogControl", "ReportControl"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"dchg",
				"dupd",
				"gi",
				"period",
				"qchg"
			],
			details: {
				dchg: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dupd: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				gi: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				period: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				qchg: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	OptFields: {
		tag: "OptFields",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ReportControl"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"bufOvfl",
				"configRef",
				"dataRef",
				"dataSet",
				"entryID",
				"reasonCode",
				"seqNum",
				"timeStamp"
			],
			details: {
				bufOvfl: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				configRef: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dataRef: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dataSet: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				entryID: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				reasonCode: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				seqNum: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				timeStamp: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	RptEnabled: {
		tag: "RptEnabled",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ReportControl"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc", "max"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				max: {
					required: !1,
					default: "1",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"ClientLN"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				ClientLN: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SDI: {
		tag: "SDI",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DOI", "SDI"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"ix",
				"name",
				"sAddr"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"SDI",
				"DAI",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SDI: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				DAI: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelinSDI",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["SDI", "DAI"]
			}]
		},
		constraints: [{
			name: "uniqueSDI_DAIinSDI",
			kind: "unique",
			paths: [["DAI|.", "SDI"]],
			deep: !1,
			attributes: ["name", "ix"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DAI: {
		tag: "DAI",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DOI", "SDI"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"ix",
				"name",
				"sAddr",
				"valImport",
				"valKind"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valImport: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valKind: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"Spec",
							"Conf",
							"RO",
							"Set"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Val",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Val: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelinDAI",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ExtRef: {
		tag: "ExtRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Inputs"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"daName",
				"desc",
				"doName",
				"iedName",
				"intAddr",
				"ldInst",
				"lnClass",
				"lnInst",
				"lnUuid",
				"pDA",
				"pDO",
				"pLN",
				"pServT",
				"prefix",
				"serviceType",
				"srcCBName",
				"srcCBUuid",
				"srcLDInst",
				"srcLNClass",
				"srcLNInst",
				"srcPrefix",
				"templateUuid",
				"uuid"
			],
			details: {
				daName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				doName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"@",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pDA: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pDO: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pLN: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pServT: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"Poll",
							"Report",
							"GOOSE",
							"SMV"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				serviceType: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"Poll",
							"Report",
							"GOOSE",
							"SMV"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				srcCBName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				srcCBUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				srcLDInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				srcLNClass: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				srcLNInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				srcPrefix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tDORef",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ExtCtrl: {
		tag: "ExtCtrl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Outputs"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"apRef",
				"checkInterlock",
				"checkSynchrocheck",
				"desc",
				"doName",
				"iedName",
				"intAddr",
				"ldInst",
				"lnClass",
				"lnInst",
				"lnUuid",
				"pDO",
				"pLN",
				"prefix",
				"templateUuid",
				"uuid"
			],
			details: {
				apRef: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				checkInterlock: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: [
							"true",
							"false",
							"conserve"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				checkSynchrocheck: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: [
							"true",
							"false",
							"conserve"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				doName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"@",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pDO: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pLN: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tDORef",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	IEDName: {
		tag: "IEDName",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["GSEControl", "SampledValueControl"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"apRef",
				"apUuid",
				"ldInst",
				"ldUuid",
				"lnClass",
				"lnInst",
				"lnUuid",
				"prefix"
			],
			details: {
				apRef: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				apUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tIEDName",
			validation: {
				enumeration: null,
				pattern: [
					"[A-Za-z][0-9A-Za-z_]{0,2}",
					"[A-Za-z][0-9A-Za-z_]{4,63}",
					"[A-MO-Za-z][0-9A-Za-z_]{3}",
					"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
					"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
					"Non[0-9A-Za-df-z_]",
					"[A-Za-z][0-9A-Za-z_]*",
					"\\i\\c*"
				],
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: 64,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Protocol: {
		tag: "Protocol",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["GSEControl", "SampledValueControl"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["mustUnderstand"],
			details: { mustUnderstand: {
				required: !0,
				default: "true",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "normalizedString",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SmvOpts: {
		tag: "SmvOpts",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SampledValueControl"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"dataSet",
				"refreshTime",
				"sampleMode",
				"sampleRate",
				"sampleSynchronized",
				"security",
				"synchSourceId",
				"timestamp"
			],
			details: {
				dataSet: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				refreshTime: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sampleMode: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sampleRate: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sampleSynchronized: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				security: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				synchSourceId: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				timestamp: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DynAssociation: {
		tag: "DynAssociation",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["max"],
			details: { max: {
				required: !1,
				default: null,
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: 0,
					maxInclusive: 4294967295,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SettingGroups: {
		tag: "SettingGroups",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: ["SGEdit", "ConfSG"],
			details: {
				SGEdit: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConfSG: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GetDirectory: {
		tag: "GetDirectory",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GetDataObjectDefinition: {
		tag: "GetDataObjectDefinition",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DataObjectDirectory: {
		tag: "DataObjectDirectory",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GetDataSetValue: {
		tag: "GetDataSetValue",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SetDataSetValue: {
		tag: "SetDataSetValue",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DataSetDirectory: {
		tag: "DataSetDirectory",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConfDataSet: {
		tag: "ConfDataSet",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"max",
				"maxAttributes",
				"modify"
			],
			details: {
				max: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxAttributes: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				modify: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceWithMaxAndMaxAttributes",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DynDataSet: {
		tag: "DynDataSet",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["max", "maxAttributes"],
			details: {
				max: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxAttributes: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceWithMax",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ReadWrite: {
		tag: "ReadWrite",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	TimerActivatedControl: {
		tag: "TimerActivatedControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConfReportControl: {
		tag: "ConfReportControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"bufConf",
				"bufMode",
				"max",
				"maxBuf"
			],
			details: {
				bufConf: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				bufMode: {
					required: !1,
					default: "both",
					namespace: null,
					validation: {
						enumeration: [
							"unbuffered",
							"buffered",
							"both"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				max: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxBuf: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceWithMax",
			validation: {
				enumeration: [
					"unbuffered",
					"buffered",
					"both"
				],
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GetCBValues: {
		tag: "GetCBValues",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConfLogControl: {
		tag: "ConfLogControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["max"],
			details: { max: {
				required: !0,
				default: null,
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: 0,
					maxInclusive: 4294967295,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ReportSettings: {
		tag: "ReportSettings",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"bufTime",
				"cbName",
				"datSet",
				"intgPd",
				"optFields",
				"owner",
				"resvTms",
				"rptID",
				"trgOps"
			],
			details: {
				bufTime: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cbName: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: ["Conf", "Fix"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intgPd: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				optFields: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				owner: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resvTms: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				rptID: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				trgOps: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceSettings",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LogSettings: {
		tag: "LogSettings",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"cbName",
				"datSet",
				"intgPd",
				"logEna",
				"trgOps"
			],
			details: {
				cbName: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: ["Conf", "Fix"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intgPd: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logEna: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				trgOps: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceSettings",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GSESettings: {
		tag: "GSESettings",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"appID",
				"cbName",
				"datSet",
				"dataLabel",
				"kdaParticipant"
			],
			details: {
				appID: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cbName: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: ["Conf", "Fix"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dataLabel: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				kdaParticipant: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: ["McSecurity"],
			details: { McSecurity: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceSettings",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SMVSettings: {
		tag: "SMVSettings",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"cbName",
				"datSet",
				"kdaParticipant",
				"nofASDU",
				"optFields",
				"pdcTimeStamp",
				"samplesPerSec",
				"smpRate",
				"svID",
				"synchSrcId"
			],
			details: {
				cbName: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: ["Conf", "Fix"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				kdaParticipant: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				nofASDU: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: ["Conf", "Fix"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				optFields: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pdcTimeStamp: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				samplesPerSec: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				smpRate: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				svID: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				synchSrcId: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [
				"SmpRate",
				"SamplesPerSec",
				"SecPerSamples",
				"McSecurity"
			],
			details: {
				SmpRate: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SamplesPerSec: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SecPerSamples: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				McSecurity: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 1,
				maxOccurrence: null,
				options: [
					"SmpRate",
					"SamplesPerSec",
					"SecPerSamples"
				]
			}]
		},
		constraints: [],
		value: {
			type: "tServiceSettings",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GSEDir: {
		tag: "GSEDir",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GOOSE: {
		tag: "GOOSE",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"fixedOffs",
				"goose",
				"max",
				"rGOOSE"
			],
			details: {
				fixedOffs: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				goose: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				max: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				rGOOSE: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceWithMax",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GSSE: {
		tag: "GSSE",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["max"],
			details: { max: {
				required: !0,
				default: null,
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: 0,
					maxInclusive: 4294967295,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SMVsc: {
		tag: "SMVsc",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"delivery",
				"deliveryConf",
				"max",
				"rSV",
				"sv"
			],
			details: {
				delivery: {
					required: !1,
					default: "multicast",
					namespace: null,
					validation: {
						enumeration: [
							"unicast",
							"multicast",
							"both"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				deliveryConf: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				max: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				rSV: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sv: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceWithMax",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FileHandling: {
		tag: "FileHandling",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"ftp",
				"ftps",
				"mms"
			],
			details: {
				ftp: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ftps: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				mms: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceYesNo",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConfLNs: {
		tag: "ConfLNs",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["fixLnInst", "fixPrefix"],
			details: {
				fixLnInst: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fixPrefix: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ClientServices: {
		tag: "ClientServices",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"acceptServerInitiatedAssociation",
				"bufReport",
				"goose",
				"gsse",
				"maxAttributes",
				"maxGOOSE",
				"maxReports",
				"maxSMV",
				"noIctBinding",
				"rGOOSE",
				"rSV",
				"readLog",
				"supportsLdName",
				"sv",
				"unbufReport"
			],
			details: {
				acceptServerInitiatedAssociation: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				bufReport: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				goose: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				gsse: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxAttributes: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxGOOSE: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxReports: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxSMV: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				noIctBinding: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				rGOOSE: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				rSV: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				readLog: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				supportsLdName: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sv: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				unbufReport: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [
				"TimeSyncProt",
				"GOOSEMcSecurity",
				"SVMcSecurity",
				"Security"
			],
			details: {
				TimeSyncProt: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GOOSEMcSecurity: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SVMcSecurity: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Security: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConfLdName: {
		tag: "ConfLdName",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SupSubscription: {
		tag: "SupSubscription",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["maxGo", "maxSv"],
			details: {
				maxGo: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxSv: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConfSigRef: {
		tag: "ConfSigRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["max"],
			details: { max: {
				required: !0,
				default: null,
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: 0,
					maxInclusive: 4294967295,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ValueHandling: {
		tag: "ValueHandling",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["setToRO"],
			details: { setToRO: {
				required: !1,
				default: "false",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	RedProt: {
		tag: "RedProt",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"hsr",
				"prp",
				"rstp"
			],
			details: {
				hsr: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prp: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				rstp: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	TimeSyncProt: {
		tag: "TimeSyncProt",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ClientServices", "Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"c37_238",
				"iec61850_9_3",
				"other",
				"sntp"
			],
			details: {
				c37_238: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iec61850_9_3: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				other: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sntp: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceYesNo",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	CommProt: {
		tag: "CommProt",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["ipv6"],
			details: { ipv6: {
				required: !1,
				default: "false",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceYesNo",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SCSM: {
		tag: "SCSM",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"iec61850_8_1",
				"iec61850_8_2",
				"serverAssociationInitiation"
			],
			details: {
				iec61850_8_1: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iec61850_8_2: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				serverAssociationInitiation: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceYesNo",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Security: {
		tag: "Security",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ClientServices", "Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["ACSEAuthentication", "E2ESecurity"],
			details: {
				ACSEAuthentication: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				E2ESecurity: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	MultiAPPerSubNet: {
		tag: "MultiAPPerSubNet",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Server: {
		tag: "Server",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["AccessPoint"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc", "timeout"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				timeout: {
					required: !1,
					default: "30",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Authentication",
				"LDevice",
				"Association"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Authentication: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				LDevice: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNInLDevice",
						kind: "unique",
						paths: [["LN"]],
						deep: !1,
						attributes: [
							"inst",
							"lnClass",
							"prefix"
						],
						refer: null,
						text: !1
					}]
				},
				Association: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueAssociationInServer",
			kind: "unique",
			paths: [["Association"]],
			deep: !1,
			attributes: ["associationID"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ServerAt: {
		tag: "ServerAt",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["AccessPoint"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"apName",
				"apUuid",
				"desc"
			],
			details: {
				apName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				apUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GOOSESecurity: {
		tag: "GOOSESecurity",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["AccessPoint"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"serialNumber",
				"templateUuid",
				"uuid",
				"xferNumber"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				serialNumber: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				xferNumber: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"Subject",
				"IssuerName"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				Subject: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				IssuerName: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SMVSecurity: {
		tag: "SMVSecurity",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["AccessPoint"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"serialNumber",
				"templateUuid",
				"uuid",
				"xferNumber"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				serialNumber: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				xferNumber: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"Subject",
				"IssuerName"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				Subject: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				IssuerName: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	MinRequestedSCDFile: {
		tag: "MinRequestedSCDFile",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["MinRequestedSCDFiles"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"fileName",
				"fileType",
				"fileUuid",
				"revision",
				"version",
				"when"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"SCD",
							"ICD",
							"IID",
							"CID",
							"SSD",
							"SED"
						],
						pattern: ["\\i\\c*", "[A-Z]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				revision: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				version: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				when: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tSclFileUUIDReference",
			validation: {
				enumeration: ["SCD"],
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BitRate: {
		tag: "BitRate",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SubNetwork"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["multiplier", "unit"],
			details: {
				multiplier: {
					required: !1,
					default: "M",
					namespace: null,
					validation: {
						enumeration: [
							"",
							"m",
							"k",
							"M",
							"mu",
							"y",
							"z",
							"a",
							"f",
							"p",
							"n",
							"c",
							"d",
							"da",
							"h",
							"G",
							"T",
							"P",
							"E",
							"Z",
							"Y"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				unit: {
					required: !1,
					default: "b/s",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "decimal",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConnectedAP: {
		tag: "ConnectedAP",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SubNetwork"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"apName",
				"apUuid",
				"desc",
				"iedName",
				"redProt"
			],
			details: {
				apName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				apUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				redProt: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"none",
							"hsr",
							"prp",
							"rstp"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Address",
				"GSE",
				"SMV",
				"PhysConn"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Address: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GSE: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SMV: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				PhysConn: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniquePTypeInPhysConn",
						kind: "unique",
						paths: [["P"]],
						deep: !1,
						attributes: ["type"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueGSEinConnectedAP",
			kind: "unique",
			paths: [["GSE"]],
			deep: !1,
			attributes: ["cbName", "ldInst"],
			refer: null,
			text: !1
		}, {
			name: "uniqueSMVinConnectedAP",
			kind: "unique",
			paths: [["SMV"]],
			deep: !1,
			attributes: ["cbName", "ldInst"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DO: {
		tag: "DO",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LNodeType"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"accessControl",
				"desc",
				"name",
				"transient",
				"type"
			],
			details: {
				accessControl: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 12,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				transient: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInDO",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SDO: {
		tag: "SDO",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DOType"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"count",
				"desc",
				"name",
				"type"
			],
			details: {
				count: {
					required: !1,
					default: "0",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-z][0-9A-Za-z]*", "\\i\\c*"],
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-z][0-9A-Za-z]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInSDO",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DA: {
		tag: "DA",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DOType"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"bType",
				"count",
				"dchg",
				"desc",
				"dupd",
				"fc",
				"name",
				"qchg",
				"sAddr",
				"type",
				"valImport",
				"valKind"
			],
			details: {
				bType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "BOOLEAN.INT8.INT16.INT24.INT32.INT64.INT128.INT8U.INT16U.INT24U.INT32U.FLOAT32.FLOAT64.Enum.Dbpos.Tcmd.Quality.Timestamp.VisString32.VisString64.VisString65.VisString129.VisString255.Octet64.Unicode255.Struct.EntryTime.Check.ObjRef.Currency.PhyComAddr.TrgOps.OptFlds.SvOptFlds.LogOptFlds.EntryID.Octet6.Octet16".split("."),
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				count: {
					required: !1,
					default: "0",
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dchg: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dupd: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fc: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"ST",
							"MX",
							"CO",
							"SP",
							"SG",
							"SE",
							"SV",
							"CF",
							"DC",
							"EX",
							"SR",
							"BL",
							"OR"
						],
						pattern: ["\\i\\c*", "[A-Z]+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 2,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				qchg: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valImport: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valKind: {
					required: !1,
					default: "Set",
					namespace: null,
					validation: {
						enumeration: [
							"Spec",
							"Conf",
							"RO",
							"Set"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Val",
				"Labels",
				"ProtNs"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Val: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInDA",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				ProtNs: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueProtNsInDA",
			kind: "unique",
			paths: [["ProtNs"]],
			deep: !1,
			attributes: ["type"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tAbstractDataAttribute",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BDA: {
		tag: "BDA",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DAType"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"bType",
				"count",
				"desc",
				"name",
				"sAddr",
				"type",
				"valImport",
				"valKind"
			],
			details: {
				bType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "BOOLEAN.INT8.INT16.INT24.INT32.INT64.INT128.INT8U.INT16U.INT24U.INT32U.FLOAT32.FLOAT64.Enum.Dbpos.Tcmd.Quality.Timestamp.VisString32.VisString64.VisString65.VisString129.VisString255.Octet64.Unicode255.Struct.EntryTime.Check.ObjRef.Currency.PhyComAddr.TrgOps.OptFlds.SvOptFlds.LogOptFlds.EntryID.Octet6.Octet16".split("."),
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				count: {
					required: !1,
					default: "0",
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valImport: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valKind: {
					required: !1,
					default: "Set",
					namespace: null,
					validation: {
						enumeration: [
							"Spec",
							"Conf",
							"RO",
							"Set"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Val",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Val: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInDA",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tAbstractDataAttribute",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ProtNs: {
		tag: "ProtNs",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DA", "DAType"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["type"],
			details: { type: {
				required: !1,
				default: "8-MMS",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: 1,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tNamespaceName",
			validation: {
				enumeration: null,
				pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	EnumVal: {
		tag: "EnumVal",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["EnumType"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc", "ord"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ord: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: -2147483648,
						maxInclusive: 2147483647,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tEnumStringValue",
			validation: {
				enumeration: null,
				pattern: ["[\\p{IsBasicLatin}\\p{IsLatin-1Supplement}]*"],
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: 127,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNodeInputRef: {
		tag: "LNodeInputRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to SourceRefs belonging to current role\n\nReference to SourceRefs belonging to current role",
		parents: ["SignalRole"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"sourceRef",
				"sourceRefUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceRef: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceRefUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNodeOutputRef: {
		tag: "LNodeOutputRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to ControlRefs belonging to current role\n\nReference to ControlRefs belonging to current role",
		parents: ["SignalRole"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"controlRef",
				"controlRefUuid",
				"desc"
			],
			details: {
				controlRef: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				controlRefUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNodeDataRef: {
		tag: "LNodeDataRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to Data belonging to current role\n\nReference to Data belonging to current role",
		parents: ["SignalRole"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"daName",
				"data",
				"desc",
				"doName",
				"lnodeUuid"
			],
			details: {
				daName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				data: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				doName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BehaviorDescriptionRef: {
		tag: "BehaviorDescriptionRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a behavior description attached to current role\n\nReference to a behavior description attached to current role",
		parents: ["FunctionRoleContent"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"behaviorDescription",
				"behaviorDescriptionUuid",
				"desc"
			],
			details: {
				behaviorDescription: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				behaviorDescriptionUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionalVariantRef",
				"InputVarRef",
				"OutputVarRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				InputVarRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				OutputVarRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}, {
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["InputVarRef", "OutputVarRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ProcessResourceRef: {
		tag: "ProcessResourceRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a process resource attached to current role\n\nReference to a process resource attached to current role",
		parents: ["FunctionRoleContent"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"processResource",
				"processResourceUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				processResource: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				processResourceUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionCategoryRef: {
		tag: "FunctionCategoryRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a function category attached to current role\n\nReference to a function category attached to current role",
		parents: ["FunctionRoleContent"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"functionCategory",
				"functionCategoryUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				functionCategory: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				functionCategoryUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	PowerSystemRelationRef: {
		tag: "PowerSystemRelationRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a power system relation attached to current role\n\nReference to a power system relation attached to current role",
		parents: ["FunctionRoleContent"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"powerSystemRelation",
				"powerSystemRelationUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				powerSystemRelation: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				powerSystemRelationUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	EqSubFunction: {
		tag: "EqSubFunction",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["EqFunction", "EqSubFunction"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"GeneralEquipment",
				"EqSubFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipmentOfFuncForEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGEFuncForEquipment",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				EqSubFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubFuncForEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueSubFuncForEquipment",
						kind: "unique",
						paths: [["EqSubFunction"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInSubFuncForEquipment",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueSubFuncForEquipment",
			kind: "unique",
			paths: [["EqSubFunction"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tAbstractEqFuncSubFunc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Hitem: {
		tag: "Hitem",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["History"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"revision",
				"version",
				"what",
				"when",
				"who",
				"why"
			],
			details: {
				revision: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				version: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				what: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				when: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				who: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				why: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["SourceFiles"],
			details: { SourceFiles: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tAnyContentFromOtherNamespace",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	TapChanger: {
		tag: "TapChanger",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["TransformerWinding"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid",
				"virtual"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: "LTC",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				virtual: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"SubEquipment",
				"EqFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SubEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubEquipmentLTC",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInLTCSubEquipment",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				EqFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFuncForLTC",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFuncForLTC",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInTapChanger",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInLTC",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tPowerSystemResource",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	NeutralPoint: {
		tag: "NeutralPoint",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["TransformerWinding"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"bayName",
				"cNodeName",
				"cNodeUuid",
				"connectivityNode",
				"desc",
				"lineName",
				"name",
				"processName",
				"substationName",
				"voltageLevelName"
			],
			details: {
				bayName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cNodeName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cNodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				connectivityNode: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+/.+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lineName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				processName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				substationName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				voltageLevelName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ClientLN: {
		tag: "ClientLN",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["RptEnabled"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"apRef",
				"desc",
				"iedName",
				"ldInst",
				"lnClass",
				"lnInst",
				"lnUuid",
				"prefix"
			],
			details: {
				apRef: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 0,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SGEdit: {
		tag: "SGEdit",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SettingGroups"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["resvTms"],
			details: { resvTms: {
				required: !1,
				default: "false",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceYesNo",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConfSG: {
		tag: "ConfSG",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SettingGroups"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["resvTms"],
			details: { resvTms: {
				required: !1,
				default: "false",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceYesNo",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	McSecurity: {
		tag: "McSecurity",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["GSESettings", "SMVSettings"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["encryption", "signature"],
			details: {
				encryption: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				signature: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SmpRate: {
		tag: "SmpRate",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SMVSettings"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: 0,
				maxInclusive: 4294967295,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SamplesPerSec: {
		tag: "SamplesPerSec",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SMVSettings"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: 0,
				maxInclusive: 4294967295,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SecPerSamples: {
		tag: "SecPerSamples",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SMVSettings"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: 0,
				maxInclusive: 4294967295,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GOOSEMcSecurity: {
		tag: "GOOSEMcSecurity",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ClientServices"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["encryption", "signature"],
			details: {
				encryption: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				signature: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SVMcSecurity: {
		tag: "SVMcSecurity",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ClientServices"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["encryption", "signature"],
			details: {
				encryption: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				signature: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Authentication: {
		tag: "Authentication",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Server"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"certificate",
				"none",
				"password",
				"strong",
				"weak"
			],
			details: {
				certificate: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				none: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				password: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				strong: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				weak: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LDevice: {
		tag: "LDevice",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Server"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"inst",
				"ldName",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"LN0",
				"LN",
				"AccessControl",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				LN0: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				LN: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				AccessControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInLD",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNInLDevice",
			kind: "unique",
			paths: [["LN"]],
			deep: !1,
			attributes: [
				"inst",
				"lnClass",
				"prefix"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Association: {
		tag: "Association",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Server"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"apRef",
				"associationID",
				"desc",
				"iedName",
				"initiator",
				"kind",
				"ldInst",
				"lnClass",
				"lnInst",
				"lnUuid",
				"prefix"
			],
			details: {
				apRef: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				associationID: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-Za-z]+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				initiator: {
					required: !1,
					default: "client",
					namespace: null,
					validation: {
						enumeration: ["client", "server"],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				kind: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: ["pre-established", "predefined"],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 0,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Subject: {
		tag: "Subject",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["GOOSESecurity", "SMVSecurity"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["commonName", "idHierarchy"],
			details: {
				commonName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["none", "CN=.+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 4,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				idHierarchy: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	IssuerName: {
		tag: "IssuerName",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["GOOSESecurity", "SMVSecurity"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["commonName", "idHierarchy"],
			details: {
				commonName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["none", "CN=.+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 4,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				idHierarchy: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Address: {
		tag: "Address",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"ConnectedAP",
			"GSE",
			"SMV"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: ["P"],
			details: { P: {
				required: !0,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: 1,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: 1,
					maxOccurrence: null
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GSE: {
		tag: "GSE",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ConnectedAP"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"cbName",
				"cbUuid",
				"desc",
				"ldInst"
			],
			details: {
				cbName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cbUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Address",
				"MinTime",
				"MaxTime"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Address: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				MinTime: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				MaxTime: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlBlock",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SMV: {
		tag: "SMV",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ConnectedAP"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"cbName",
				"cbUuid",
				"desc",
				"ldInst"
			],
			details: {
				cbName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cbUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Address"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Address: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlBlock",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	PhysConn: {
		tag: "PhysConn",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ConnectedAP"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc", "type"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: ["Connection", "RedConn"],
						pattern: ["[A-Z][0-9A-Za-z\\-]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"P"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				P: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniquePTypeInPhysConn",
			kind: "unique",
			paths: [["P"]],
			deep: !1,
			attributes: ["type"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	InputVarRef: {
		tag: "InputVarRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to InputVar belonging to current behavior description\n\nReference to InputVar belonging to current behavior description",
		parents: ["BehaviorDescriptionRef"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"value",
				"variable"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				value: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				variable: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	OutputVarRef: {
		tag: "OutputVarRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to OutputVar belonging to current behavior description\n\nReference to OutputVar belonging to current behavior description",
		parents: ["BehaviorDescriptionRef"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"value",
				"variable"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				value: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				variable: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	AccessControl: {
		tag: "AccessControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LDevice"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !0,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tAnyContentFromOtherNamespace",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	P: {
		tag: "P",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Address", "PhysConn"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["type"],
			details: { type: {
				required: !0,
				default: null,
				namespace: null,
				validation: {
					enumeration: /* @__PURE__ */ "IP.IP-SUBNET.IP-GATEWAY.OSI-NSAP.OSI-TSEL.OSI-SSEL.OSI-PSEL.OSI-AP-Title.OSI-AP-Invoke.OSI-AE-Qualifier.OSI-AE-Invoke.MAC-Address.APPID.VLAN-PRIORITY.VLAN-ID.SNTP-Port.MMS-Port.DNSName.IPv6FlowLabel.IPv6ClassOfTraffic.C37-118-IP-Port.IP-UDP-PORT.IP-TCP-PORT.IPv6.IPv6-SUBNET.IPv6-GATEWAY.IPv6-IGMPv3Src.IP-IGMPv3Src.IP-ClassOfTraffic".split("."),
					pattern: ["\\i\\c*", "[A-Z][0-9A-Za-z\\-]*"],
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tPAddr",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: 1,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	MinTime: {
		tag: "MinTime",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["GSE"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["multiplier", "unit"],
			details: {
				multiplier: {
					required: !1,
					default: "m",
					namespace: null,
					validation: {
						enumeration: [
							"",
							"m",
							"k",
							"M",
							"mu",
							"y",
							"z",
							"a",
							"f",
							"p",
							"n",
							"c",
							"d",
							"da",
							"h",
							"G",
							"T",
							"P",
							"E",
							"Z",
							"Y"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				unit: {
					required: !1,
					default: "s",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "decimal",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	MaxTime: {
		tag: "MaxTime",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["GSE"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["multiplier", "unit"],
			details: {
				multiplier: {
					required: !1,
					default: "m",
					namespace: null,
					validation: {
						enumeration: [
							"",
							"m",
							"k",
							"M",
							"mu",
							"y",
							"z",
							"a",
							"f",
							"p",
							"n",
							"c",
							"d",
							"da",
							"h",
							"G",
							"T",
							"P",
							"E",
							"Z",
							"Y"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				unit: {
					required: !1,
					default: "s",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "decimal",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	}
}, gu = /* @__PURE__ */ "AccessControl.AccessPoint.Address.AllocationRole.AllocationRoleRef.AnalogueWiringParameters.AnalogueWiringParametersRef.Application.ApplicationSclRef.Association.Authentication.BDA.Bay.BayType.BehaviorDescription.BehaviorDescriptionRef.BehaviorReference.BinaryWiringParameters.BinaryWiringParametersRef.BitRate.CheckoutID.ClientLN.ClientServices.CommProt.Communication.CommunicationServiceSpecifications.ConductingEquipment.ConfDataSet.ConfLNs.ConfLdName.ConfLogControl.ConfReportControl.ConfSG.ConfSigRef.ConnectedAP.ConnectivityNode.ControlRef.ControllingLNode.DA.DAI.DAS.DAType.DO.DOI.DOS.DOType.DataObjectDirectory.DataSet.DataSetDirectory.DataTypeTemplates.DynAssociation.DynDataSet.EnumType.EnumVal.EqFunction.EqSubFunction.ExtCtrl.ExtRef.FCDA.FileHandling.Function.FunctionCatRef.FunctionCategory.FunctionCategoryRef.FunctionRef.FunctionRole.FunctionRoleContent.FunctionSclRef.FunctionTemplate.FunctionalSubVariant.FunctionalVariant.FunctionalVariantGroup.FunctionalVariantRef.GOOSE.GOOSEMcSecurity.GOOSESecurity.GSE.GSEControl.GSEDir.GSESettings.GSSE.GeneralEquipment.GetCBValues.GetDataObjectDefinition.GetDataSetValue.GetDirectory.GooseParameters.GooseParametersRef.Header.History.Hitem.IED.IEDName.IEDSourceFiles.InputVar.InputVarRef.Inputs.IssuerName.KDC.L2CommParameters.L3IPv4CommParameters.L3IPv6CommParameters.LDevice.LN.LN0.LNode.LNodeDataRef.LNodeInputRef.LNodeInputs.LNodeOutputRef.LNodeOutputs.LNodeSpecNaming.LNodeType.Label.Labels.Line.Log.LogControl.LogParameters.LogParametersRef.LogSettings.MaxTime.McSecurity.MinRequestedSCDFile.MinRequestedSCDFiles.MinTime.MultiAPPerSubNet.NeutralPoint.OptFields.OutputVar.OutputVarRef.Outputs.P.PhysConn.PowerSystemRelation.PowerSystemRelationRef.PowerSystemRelations.PowerTransformer.Private.Process.ProcessEcho.ProcessResource.ProcessResourceRef.ProcessResources.Project.ProjectProcessReference.ProtNs.Protocol.ReadWrite.RedProt.ReportControl.ReportParameters.ReportParametersRef.ReportSettings.Resource.RptEnabled.SCL.SCSM.SDI.SDO.SDS.SGEdit.SMV.SMVParameters.SMVParametersRef.SMVSecurity.SMVSettings.SMVsc.SVMcSecurity.SampledValueControl.SamplesPerSec.SclFileReference.SecPerSamples.Security.Server.ServerAt.ServiceSpecifications.Services.SetDataSetValue.SettingControl.SettingGroups.SignalRole.SmpRate.SmvOpts.SourceFiles.SourceRef.SubCategory.SubCheckoutID.SubEquipment.SubFunction.SubFunctionTemplate.SubNetwork.Subject.SubscriberLNode.Substation.SupSubscription.TapChanger.Terminal.Text.TimeSyncProt.TimerActivatedControl.TransformerWinding.TrgOps.Val.ValueHandling.Variable.VariableApplyTo.VariableRef.Voltage.VoltageLevel".split("."), du = {
	AccessControl: [],
	AccessPoint: ["name"],
	Address: [],
	AllocationRole: ["name"],
	AllocationRoleRef: [],
	AnalogueWiringParameters: ["id"],
	AnalogueWiringParametersRef: ["id"],
	Application: ["name"],
	ApplicationSclRef: [],
	Association: [
		"apRef",
		"iedName",
		"kind",
		"ldInst",
		"lnClass",
		"lnInst"
	],
	Authentication: [],
	BDA: ["bType", "name"],
	Bay: ["name"],
	BayType: [],
	BehaviorDescription: ["name"],
	BehaviorDescriptionRef: [],
	BehaviorReference: [],
	BinaryWiringParameters: ["id"],
	BinaryWiringParametersRef: ["id"],
	BitRate: [],
	CheckoutID: [
		"fileType",
		"revision",
		"version"
	],
	ClientLN: [
		"apRef",
		"iedName",
		"ldInst",
		"lnClass",
		"lnInst"
	],
	ClientServices: [],
	CommProt: [],
	Communication: [],
	CommunicationServiceSpecifications: [],
	ConductingEquipment: ["name", "type"],
	ConfDataSet: ["max"],
	ConfLNs: [],
	ConfLdName: [],
	ConfLogControl: ["max"],
	ConfReportControl: ["max"],
	ConfSG: [],
	ConfSigRef: ["max"],
	ConnectedAP: ["apName", "iedName"],
	ConnectivityNode: ["name", "pathName"],
	ControlRef: ["output"],
	ControllingLNode: ["outputName"],
	DA: [
		"bType",
		"fc",
		"name"
	],
	DAI: ["name"],
	DAS: ["name"],
	DAType: ["id"],
	DO: ["name", "type"],
	DOI: ["name"],
	DOS: ["name"],
	DOType: ["cdc", "id"],
	DataObjectDirectory: [],
	DataSet: ["name"],
	DataSetDirectory: [],
	DataTypeTemplates: [],
	DynAssociation: [],
	DynDataSet: ["max"],
	EnumType: ["id"],
	EnumVal: ["ord"],
	EqFunction: ["name"],
	EqSubFunction: ["name"],
	ExtCtrl: [],
	ExtRef: [],
	FCDA: ["fc"],
	FileHandling: [],
	Function: ["name"],
	FunctionCatRef: [],
	FunctionCategory: ["name"],
	FunctionCategoryRef: [],
	FunctionRef: [],
	FunctionRole: ["name"],
	FunctionRoleContent: [],
	FunctionSclRef: [],
	FunctionTemplate: ["name"],
	FunctionalSubVariant: ["name"],
	FunctionalVariant: ["name"],
	FunctionalVariantGroup: ["name"],
	FunctionalVariantRef: [],
	GOOSE: ["max"],
	GOOSEMcSecurity: [],
	GOOSESecurity: ["name", "serialNumber"],
	GSE: ["cbName", "ldInst"],
	GSEControl: ["appID", "name"],
	GSEDir: [],
	GSESettings: [],
	GSSE: ["max"],
	GeneralEquipment: ["name", "type"],
	GetCBValues: [],
	GetDataObjectDefinition: [],
	GetDataSetValue: [],
	GetDirectory: [],
	GooseParameters: ["id"],
	GooseParametersRef: ["id"],
	Header: ["id", "uuid"],
	History: [],
	Hitem: [
		"revision",
		"version",
		"when"
	],
	IED: ["name"],
	IEDName: ["apRef"],
	IEDSourceFiles: [],
	InputVar: ["varName"],
	InputVarRef: [],
	Inputs: [],
	IssuerName: ["commonName", "idHierarchy"],
	KDC: ["apName", "iedName"],
	L2CommParameters: [],
	L3IPv4CommParameters: [],
	L3IPv6CommParameters: [],
	LDevice: ["inst"],
	LN: [
		"inst",
		"lnClass",
		"lnType"
	],
	LN0: [
		"inst",
		"lnClass",
		"lnType"
	],
	LNode: ["lnClass"],
	LNodeDataRef: [],
	LNodeInputRef: [],
	LNodeInputs: [],
	LNodeOutputRef: [],
	LNodeOutputs: [],
	LNodeSpecNaming: [],
	LNodeType: ["id", "lnClass"],
	Label: ["lang"],
	Labels: [],
	Line: ["name"],
	Log: [],
	LogControl: ["logName", "name"],
	LogParameters: ["id"],
	LogParametersRef: ["id"],
	LogSettings: [],
	MaxTime: [],
	McSecurity: [],
	MinRequestedSCDFile: [
		"fileType",
		"revision",
		"version"
	],
	MinRequestedSCDFiles: [],
	MinTime: [],
	MultiAPPerSubNet: [],
	NeutralPoint: ["cNodeName", "connectivityNode"],
	OptFields: [],
	OutputVar: ["varName"],
	OutputVarRef: [],
	Outputs: [],
	P: ["type"],
	PhysConn: ["type"],
	PowerSystemRelation: ["name"],
	PowerSystemRelationRef: [],
	PowerSystemRelations: [],
	PowerTransformer: ["name", "type"],
	Private: ["type"],
	Process: ["name"],
	ProcessEcho: [],
	ProcessResource: ["name"],
	ProcessResourceRef: [],
	ProcessResources: [],
	Project: ["name"],
	ProjectProcessReference: [],
	ProtNs: [],
	Protocol: ["mustUnderstand"],
	ReadWrite: [],
	RedProt: [],
	ReportControl: ["confRev", "name"],
	ReportParameters: ["id"],
	ReportParametersRef: ["id"],
	ReportSettings: [],
	Resource: [],
	RptEnabled: [],
	SCL: [
		"release",
		"revision",
		"version"
	],
	SCSM: [],
	SDI: ["name"],
	SDO: ["name", "type"],
	SDS: ["name"],
	SGEdit: [],
	SMV: ["cbName", "ldInst"],
	SMVParameters: ["id"],
	SMVParametersRef: ["id"],
	SMVSecurity: ["name", "serialNumber"],
	SMVSettings: [],
	SMVsc: ["max"],
	SVMcSecurity: [],
	SampledValueControl: [
		"name",
		"nofASDU",
		"smpRate",
		"smvID"
	],
	SamplesPerSec: [],
	SclFileReference: [
		"fileType",
		"revision",
		"version"
	],
	SecPerSamples: [],
	Security: [],
	Server: [],
	ServerAt: ["apName"],
	ServiceSpecifications: [],
	Services: [],
	SetDataSetValue: [],
	SettingControl: ["numOfSGs"],
	SettingGroups: [],
	SignalRole: ["name"],
	SmpRate: [],
	SmvOpts: [],
	SourceFiles: [],
	SourceRef: ["input"],
	SubCategory: ["name"],
	SubCheckoutID: [
		"fileType",
		"revision",
		"version"
	],
	SubEquipment: ["name"],
	SubFunction: ["name"],
	SubFunctionTemplate: ["name"],
	SubNetwork: ["name"],
	Subject: ["commonName", "idHierarchy"],
	SubscriberLNode: ["inputName"],
	Substation: ["name"],
	SupSubscription: ["maxGo", "maxSv"],
	TapChanger: ["name", "type"],
	Terminal: ["cNodeName", "connectivityNode"],
	Text: [],
	TimeSyncProt: [],
	TimerActivatedControl: [],
	TransformerWinding: ["name", "type"],
	TrgOps: [],
	Val: [],
	ValueHandling: [],
	Variable: ["name"],
	VariableApplyTo: [],
	VariableRef: [],
	Voltage: ["unit"],
	VoltageLevel: ["name"]
}, Ru = { v2019C1: /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
	__proto__: null,
	ATTRIBUTES: {
		AccessControl: {},
		AccessPoint: {
			clock: "",
			desc: "",
			kdc: "",
			name: "",
			router: "",
			templateUuid: "",
			uuid: ""
		},
		Address: {},
		AllocationRole: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		AllocationRoleRef: {
			allocationRole: "",
			allocationRoleUuid: "",
			desc: ""
		},
		AnalogueWiringParameters: {
			desc: "",
			dsgInp: "",
			fctInp: "",
			id: "",
			inpNam: "",
			inpRef: ""
		},
		AnalogueWiringParametersRef: {
			desc: "",
			id: ""
		},
		Application: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		ApplicationSclRef: {},
		Association: {
			apRef: "",
			associationID: "",
			desc: "",
			iedName: "",
			initiator: "",
			kind: "",
			ldInst: "",
			lnClass: "",
			lnInst: "",
			lnUuid: "",
			prefix: ""
		},
		Authentication: {
			certificate: "",
			none: "",
			password: "",
			strong: "",
			weak: ""
		},
		BDA: {
			bType: "",
			count: "",
			desc: "",
			name: "",
			sAddr: "",
			type: "",
			valImport: "",
			valKind: ""
		},
		Bay: {
			desc: "",
			name: "",
			templateUuid: "",
			uuid: ""
		},
		BayType: {},
		BehaviorDescription: {
			desc: "",
			fileReference: "",
			format: "",
			isSimulation: "",
			isSpecification: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		BehaviorDescriptionRef: {
			behaviorDescription: "",
			behaviorDescriptionUuid: "",
			desc: ""
		},
		BehaviorReference: {
			behaviorReference: "",
			behaviorUuid: "",
			desc: ""
		},
		BinaryWiringParameters: {
			debTm: "",
			desc: "",
			fastOutput: "",
			id: "",
			inpNam: "",
			inpRef: "",
			outNam: "",
			outOffDl: "",
			outOnDl: "",
			outRef: "",
			outTyp: "",
			vInOff: "",
			vInOn: ""
		},
		BinaryWiringParametersRef: {
			desc: "",
			id: ""
		},
		BitRate: {
			multiplier: "",
			unit: ""
		},
		CheckoutID: {
			desc: "",
			engRight: "",
			fileName: "",
			fileType: "",
			fileUuid: "",
			headerId: "",
			revision: "",
			version: "",
			when: ""
		},
		ClientLN: {
			apRef: "",
			desc: "",
			iedName: "",
			ldInst: "",
			lnClass: "",
			lnInst: "",
			lnUuid: "",
			prefix: ""
		},
		ClientServices: {
			acceptServerInitiatedAssociation: "",
			bufReport: "",
			goose: "",
			gsse: "",
			maxAttributes: "",
			maxGOOSE: "",
			maxReports: "",
			maxSMV: "",
			noIctBinding: "",
			rGOOSE: "",
			rSV: "",
			readLog: "",
			supportsLdName: "",
			sv: "",
			unbufReport: ""
		},
		CommProt: { ipv6: "" },
		Communication: { desc: "" },
		CommunicationServiceSpecifications: { desc: "" },
		ConductingEquipment: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: "",
			virtual: ""
		},
		ConfDataSet: {
			max: "",
			maxAttributes: "",
			modify: ""
		},
		ConfLNs: {
			fixLnInst: "",
			fixPrefix: ""
		},
		ConfLdName: {},
		ConfLogControl: { max: "" },
		ConfReportControl: {
			bufConf: "",
			bufMode: "",
			max: "",
			maxBuf: ""
		},
		ConfSG: { resvTms: "" },
		ConfSigRef: { max: "" },
		ConnectedAP: {
			apName: "",
			apUuid: "",
			desc: "",
			iedName: "",
			redProt: ""
		},
		ConnectivityNode: {
			desc: "",
			name: "",
			pathName: "",
			templateUuid: "",
			uuid: ""
		},
		ControlRef: {
			controlled: "",
			controlledDoName: "",
			controlledLNodeUuid: "",
			desc: "",
			extCtrlAddr: "",
			extCtrlUuid: "",
			originUuid: "",
			output: "",
			outputInst: "",
			pDO: "",
			pLN: "",
			resourceName: "",
			resourceUuid: "",
			templateUuid: "",
			uuid: ""
		},
		ControllingLNode: {
			desc: "",
			outputName: "",
			pLN: "",
			resourceName: "",
			resourceUuid: ""
		},
		DA: {
			bType: "",
			count: "",
			dchg: "",
			desc: "",
			dupd: "",
			fc: "",
			name: "",
			qchg: "",
			sAddr: "",
			type: "",
			valImport: "",
			valKind: ""
		},
		DAI: {
			desc: "",
			ix: "",
			name: "",
			sAddr: "",
			valImport: "",
			valKind: ""
		},
		DAS: {
			desc: "",
			ix: "",
			mappedDaName: "",
			mappedLnUuid: "",
			name: "",
			valImport: "",
			valKind: ""
		},
		DAType: {
			desc: "",
			id: "",
			iedType: ""
		},
		DO: {
			accessControl: "",
			desc: "",
			name: "",
			transient: "",
			type: ""
		},
		DOI: {
			accessControl: "",
			desc: "",
			ix: "",
			name: ""
		},
		DOS: {
			desc: "",
			mappedDoName: "",
			mappedLnUuid: "",
			name: ""
		},
		DOType: {
			cdc: "",
			desc: "",
			id: "",
			iedType: ""
		},
		DataObjectDirectory: {},
		DataSet: {
			desc: "",
			name: "",
			templateUuid: "",
			uuid: ""
		},
		DataSetDirectory: {},
		DataTypeTemplates: {},
		DynAssociation: { max: "" },
		DynDataSet: {
			max: "",
			maxAttributes: ""
		},
		EnumType: {
			desc: "",
			id: ""
		},
		EnumVal: {
			desc: "",
			ord: ""
		},
		EqFunction: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		EqSubFunction: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		ExtCtrl: {
			apRef: "",
			checkInterlock: "",
			checkSynchrocheck: "",
			desc: "",
			doName: "",
			iedName: "",
			intAddr: "",
			ldInst: "",
			lnClass: "",
			lnInst: "",
			lnUuid: "",
			pDO: "",
			pLN: "",
			prefix: "",
			templateUuid: "",
			uuid: ""
		},
		ExtRef: {
			daName: "",
			desc: "",
			doName: "",
			iedName: "",
			intAddr: "",
			ldInst: "",
			lnClass: "",
			lnInst: "",
			lnUuid: "",
			pDA: "",
			pDO: "",
			pLN: "",
			pServT: "",
			prefix: "",
			serviceType: "",
			srcCBName: "",
			srcCBUuid: "",
			srcLDInst: "",
			srcLNClass: "",
			srcLNInst: "",
			srcPrefix: "",
			templateUuid: "",
			uuid: ""
		},
		FCDA: {
			daName: "",
			doName: "",
			fc: "",
			ix: "",
			ldInst: "",
			lnClass: "",
			lnInst: "",
			lnUuid: "",
			prefix: ""
		},
		FileHandling: {
			ftp: "",
			ftps: "",
			mms: ""
		},
		Function: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		FunctionCatRef: {
			function: "",
			functionUuid: ""
		},
		FunctionCategory: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		FunctionCategoryRef: {
			desc: "",
			functionCategory: "",
			functionCategoryUuid: ""
		},
		FunctionRef: {
			desc: "",
			function: "",
			functionUuid: ""
		},
		FunctionRole: {
			cardinality: "",
			desc: "",
			max: "",
			name: "",
			originUuid: "",
			selector: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		FunctionRoleContent: { roleInst: "" },
		FunctionSclRef: {},
		FunctionTemplate: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		FunctionalSubVariant: {
			desc: "",
			isBaseline: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		FunctionalVariant: {
			desc: "",
			isBaseline: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		FunctionalVariantGroup: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		FunctionalVariantRef: {
			functionalVariant: "",
			functionalVariantUuid: "",
			update: ""
		},
		GOOSE: {
			fixedOffs: "",
			goose: "",
			max: "",
			rGOOSE: ""
		},
		GOOSEMcSecurity: {
			encryption: "",
			signature: ""
		},
		GOOSESecurity: {
			desc: "",
			name: "",
			serialNumber: "",
			templateUuid: "",
			uuid: "",
			xferNumber: ""
		},
		GSE: {
			cbName: "",
			cbUuid: "",
			desc: "",
			ldInst: ""
		},
		GSEControl: {
			appID: "",
			confRev: "",
			datSet: "",
			desc: "",
			fixedOffs: "",
			name: "",
			securityEnable: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		GSEDir: {},
		GSESettings: {
			appID: "",
			cbName: "",
			datSet: "",
			dataLabel: "",
			kdaParticipant: ""
		},
		GSSE: { max: "" },
		GeneralEquipment: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: "",
			virtual: ""
		},
		GetCBValues: {},
		GetDataObjectDefinition: {},
		GetDataSetValue: {},
		GetDirectory: {},
		GooseParameters: {
			cbName: "",
			desc: "",
			dsName: "",
			goId: "",
			id: "",
			maxTime: "",
			minTime: "",
			securityEnabled: ""
		},
		GooseParametersRef: {
			desc: "",
			id: ""
		},
		Header: {
			baseUuid: "",
			fileType: "",
			id: "",
			nameStructure: "",
			revision: "",
			toolID: "",
			uuid: "",
			version: ""
		},
		History: {},
		Hitem: {
			revision: "",
			version: "",
			what: "",
			when: "",
			who: "",
			why: ""
		},
		IED: {
			configVersion: "",
			desc: "",
			engRight: "",
			manufacturer: "",
			name: "",
			originalSclRelease: "",
			originalSclRevision: "",
			originalSclVersion: "",
			owner: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		IEDName: {
			apRef: "",
			apUuid: "",
			ldInst: "",
			ldUuid: "",
			lnClass: "",
			lnInst: "",
			lnUuid: "",
			prefix: ""
		},
		IEDSourceFiles: {},
		InputVar: {
			daName: "",
			dataName: "",
			desc: "",
			doName: "",
			inputName: "",
			inputUuid: "",
			lnodeUuid: "",
			value: "",
			varName: ""
		},
		InputVarRef: {
			desc: "",
			value: "",
			variable: ""
		},
		Inputs: { desc: "" },
		IssuerName: {
			commonName: "",
			idHierarchy: ""
		},
		KDC: {
			apName: "",
			apUuid: "",
			iedName: ""
		},
		L2CommParameters: {
			appId: "",
			desc: "",
			macAddr: "",
			vlanId: "",
			vlanPriority: ""
		},
		L3IPv4CommParameters: {
			IPv4: "",
			"IPv4-IGMPv3Src": "",
			appId: "",
			desc: "",
			vlanId: "",
			vlanPriority: ""
		},
		L3IPv6CommParameters: {
			IPv6: "",
			"IPv6-IGMPv3Src": "",
			appId: "",
			desc: "",
			vlanId: "",
			vlanPriority: ""
		},
		LDevice: {
			desc: "",
			inst: "",
			ldName: "",
			templateUuid: "",
			uuid: ""
		},
		LN: {
			desc: "",
			inst: "",
			lnClass: "",
			lnType: "",
			prefix: "",
			templateUuid: "",
			uuid: ""
		},
		LN0: {
			desc: "",
			inst: "",
			lnClass: "",
			lnType: "",
			templateUuid: "",
			uuid: ""
		},
		LNode: {
			desc: "",
			iedName: "",
			ldInst: "",
			lnClass: "",
			lnInst: "",
			lnType: "",
			lnUuid: "",
			prefix: "",
			templateUuid: "",
			uuid: ""
		},
		LNodeDataRef: {
			daName: "",
			data: "",
			desc: "",
			doName: "",
			lnodeUuid: ""
		},
		LNodeInputRef: {
			desc: "",
			sourceRef: "",
			sourceRefUuid: ""
		},
		LNodeInputs: { desc: "" },
		LNodeOutputRef: {
			controlRef: "",
			controlRefUuid: "",
			desc: ""
		},
		LNodeOutputs: { desc: "" },
		LNodeSpecNaming: {
			sIedName: "",
			sLdInst: "",
			sLnClass: "",
			sLnInst: "",
			sPrefix: ""
		},
		LNodeType: {
			desc: "",
			id: "",
			iedType: "",
			lnClass: ""
		},
		Label: {
			id: "",
			lang: ""
		},
		Labels: { desc: "" },
		Line: {
			desc: "",
			name: "",
			nomFreq: "",
			numPhases: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		Log: {
			desc: "",
			name: ""
		},
		LogControl: {
			bufTime: "",
			datSet: "",
			desc: "",
			intgPd: "",
			ldInst: "",
			lnClass: "",
			lnInst: "",
			logEna: "",
			logName: "",
			name: "",
			prefix: "",
			reasonCode: "",
			templateUuid: "",
			uuid: ""
		},
		LogParameters: {
			cbName: "",
			desc: "",
			dsName: "",
			id: "",
			intgPd: "",
			logEna: "",
			logLdInst: "",
			logLnClass: "",
			logLnInst: "",
			logName: "",
			logPrefix: "",
			reasonCode: ""
		},
		LogParametersRef: {
			desc: "",
			id: ""
		},
		LogSettings: {
			cbName: "",
			datSet: "",
			intgPd: "",
			logEna: "",
			trgOps: ""
		},
		MaxTime: {
			multiplier: "",
			unit: ""
		},
		McSecurity: {
			encryption: "",
			signature: ""
		},
		MinRequestedSCDFile: {
			desc: "",
			fileName: "",
			fileType: "",
			fileUuid: "",
			revision: "",
			version: "",
			when: ""
		},
		MinRequestedSCDFiles: {},
		MinTime: {
			multiplier: "",
			unit: ""
		},
		MultiAPPerSubNet: {},
		NeutralPoint: {
			bayName: "",
			cNodeName: "",
			cNodeUuid: "",
			connectivityNode: "",
			desc: "",
			lineName: "",
			name: "",
			processName: "",
			substationName: "",
			voltageLevelName: ""
		},
		OptFields: {
			bufOvfl: "",
			configRef: "",
			dataRef: "",
			dataSet: "",
			entryID: "",
			reasonCode: "",
			seqNum: "",
			timeStamp: ""
		},
		OutputVar: {
			daName: "",
			dataName: "",
			desc: "",
			doName: "",
			lnodeUuid: "",
			outputName: "",
			outputUuid: "",
			value: "",
			varName: ""
		},
		OutputVarRef: {
			desc: "",
			value: "",
			variable: ""
		},
		Outputs: { desc: "" },
		P: { type: "" },
		PhysConn: {
			desc: "",
			type: ""
		},
		PowerSystemRelation: {
			desc: "",
			name: "",
			originUuid: "",
			relation: "",
			relationUuid: "",
			selector: "",
			templateUuid: "",
			uuid: ""
		},
		PowerSystemRelationRef: {
			desc: "",
			powerSystemRelation: "",
			powerSystemRelationUuid: ""
		},
		PowerSystemRelations: { desc: "" },
		PowerTransformer: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: "",
			virtual: ""
		},
		Private: {
			source: "",
			type: ""
		},
		Process: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		ProcessEcho: {
			desc: "",
			source: "",
			sourceDaName: "",
			sourceDoName: "",
			sourceLNodeUuid: ""
		},
		ProcessResource: {
			cardinality: "",
			desc: "",
			max: "",
			name: "",
			originUuid: "",
			selector: "",
			templateUuid: "",
			uuid: ""
		},
		ProcessResourceRef: {
			desc: "",
			processResource: "",
			processResourceUuid: ""
		},
		ProcessResources: { desc: "" },
		Project: {
			desc: "",
			name: "",
			uuid: ""
		},
		ProjectProcessReference: {
			desc: "",
			processReference: "",
			processUuid: ""
		},
		ProtNs: { type: "" },
		Protocol: { mustUnderstand: "" },
		ReadWrite: {},
		RedProt: {
			hsr: "",
			prp: "",
			rstp: ""
		},
		ReportControl: {
			bufTime: "",
			buffered: "",
			confRev: "",
			datSet: "",
			desc: "",
			indexed: "",
			intgPd: "",
			name: "",
			rptID: "",
			templateUuid: "",
			uuid: ""
		},
		ReportParameters: {
			bufTime: "",
			buffered: "",
			cbName: "",
			desc: "",
			dsName: "",
			id: "",
			intgPd: ""
		},
		ReportParametersRef: {
			desc: "",
			id: ""
		},
		ReportSettings: {
			bufTime: "",
			cbName: "",
			datSet: "",
			intgPd: "",
			optFields: "",
			owner: "",
			resvTms: "",
			rptID: "",
			trgOps: ""
		},
		Resource: {
			resInst: "",
			source: "",
			sourceUuid: ""
		},
		RptEnabled: {
			desc: "",
			max: ""
		},
		SCL: {
			release: "",
			revision: "",
			version: ""
		},
		SCSM: {
			iec61850_8_1: "",
			iec61850_8_2: "",
			serverAssociationInitiation: ""
		},
		SDI: {
			desc: "",
			ix: "",
			name: "",
			sAddr: ""
		},
		SDO: {
			count: "",
			desc: "",
			name: "",
			type: ""
		},
		SDS: {
			desc: "",
			ix: "",
			mappedDoName: "",
			mappedLnUuid: "",
			name: ""
		},
		SGEdit: { resvTms: "" },
		SMV: {
			cbName: "",
			cbUuid: "",
			desc: "",
			ldInst: ""
		},
		SMVParameters: {
			cbName: "",
			desc: "",
			dsName: "",
			id: "",
			multicast: "",
			nofASDU: "",
			securityEnabled: "",
			smpMod: "",
			smpRate: "",
			smvId: ""
		},
		SMVParametersRef: {
			desc: "",
			id: ""
		},
		SMVSecurity: {
			desc: "",
			name: "",
			serialNumber: "",
			templateUuid: "",
			uuid: "",
			xferNumber: ""
		},
		SMVSettings: {
			cbName: "",
			datSet: "",
			kdaParticipant: "",
			nofASDU: "",
			optFields: "",
			pdcTimeStamp: "",
			samplesPerSec: "",
			smpRate: "",
			svID: "",
			synchSrcId: ""
		},
		SMVsc: {
			delivery: "",
			deliveryConf: "",
			max: "",
			rSV: "",
			sv: ""
		},
		SVMcSecurity: {
			encryption: "",
			signature: ""
		},
		SampledValueControl: {
			confRev: "",
			datSet: "",
			desc: "",
			multicast: "",
			name: "",
			nofASDU: "",
			securityEnable: "",
			smpMod: "",
			smpRate: "",
			smvID: "",
			templateUuid: "",
			uuid: ""
		},
		SamplesPerSec: {},
		SclFileReference: {
			desc: "",
			fileName: "",
			fileType: "",
			fileUuid: "",
			revision: "",
			version: "",
			when: ""
		},
		SecPerSamples: {},
		Security: {
			ACSEAuthentication: "",
			E2ESecurity: ""
		},
		Server: {
			desc: "",
			timeout: ""
		},
		ServerAt: {
			apName: "",
			apUuid: "",
			desc: ""
		},
		ServiceSpecifications: { desc: "" },
		Services: { nameLength: "" },
		SetDataSetValue: {},
		SettingControl: {
			actSG: "",
			desc: "",
			numOfSGs: "",
			resvTms: ""
		},
		SettingGroups: {},
		SignalRole: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		SmpRate: {},
		SmvOpts: {
			dataSet: "",
			refreshTime: "",
			sampleMode: "",
			sampleRate: "",
			sampleSynchronized: "",
			security: "",
			synchSourceId: "",
			timestamp: ""
		},
		SourceFiles: {},
		SourceRef: {
			desc: "",
			extRefAddr: "",
			extRefUuid: "",
			input: "",
			inputInst: "",
			originUuid: "",
			pDA: "",
			pDO: "",
			pLN: "",
			resourceName: "",
			resourceUuid: "",
			service: "",
			source: "",
			sourceDaName: "",
			sourceDoName: "",
			sourceLNodeUuid: "",
			templateUuid: "",
			uuid: ""
		},
		SubCategory: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		SubCheckoutID: {
			desc: "",
			engRight: "",
			fileName: "",
			fileType: "",
			fileUuid: "",
			headerId: "",
			revision: "",
			version: "",
			when: ""
		},
		SubEquipment: {
			desc: "",
			name: "",
			phase: "",
			templateUuid: "",
			uuid: "",
			virtual: ""
		},
		SubFunction: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		SubFunctionTemplate: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		SubNetwork: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		Subject: {
			commonName: "",
			idHierarchy: ""
		},
		SubscriberLNode: {
			desc: "",
			inputName: "",
			pLN: "",
			resourceName: "",
			resourceUuid: "",
			service: ""
		},
		Substation: {
			desc: "",
			name: "",
			templateUuid: "",
			uuid: ""
		},
		SupSubscription: {
			maxGo: "",
			maxSv: ""
		},
		TapChanger: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: "",
			virtual: ""
		},
		Terminal: {
			bayName: "",
			cNodeName: "",
			cNodeUuid: "",
			connectivityNode: "",
			desc: "",
			lineName: "",
			name: "",
			processName: "",
			substationName: "",
			voltageLevelName: ""
		},
		Text: { source: "" },
		TimeSyncProt: {
			c37_238: "",
			iec61850_9_3: "",
			other: "",
			sntp: ""
		},
		TimerActivatedControl: {},
		TransformerWinding: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: "",
			virtual: ""
		},
		TrgOps: {
			dchg: "",
			dupd: "",
			gi: "",
			period: "",
			qchg: ""
		},
		Val: { sGroup: "" },
		ValueHandling: { setToRO: "" },
		Variable: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: "",
			value: ""
		},
		VariableApplyTo: {
			attribute: "",
			daName: "",
			defaultValue: "",
			desc: "",
			doName: "",
			element: "",
			elementUuid: "",
			format: "",
			sGroup: ""
		},
		VariableRef: {
			desc: "",
			value: "",
			variable: "",
			variableUuid: ""
		},
		Voltage: {
			multiplier: "",
			unit: ""
		},
		VoltageLevel: {
			desc: "",
			name: "",
			nomFreq: "",
			numPhases: "",
			templateUuid: "",
			uuid: ""
		}
	},
	CHILDREN: {
		AccessControl: [],
		AccessPoint: [
			"Text",
			"Private",
			"Server",
			"LN",
			"ServerAt",
			"Services",
			"GOOSESecurity",
			"SMVSecurity",
			"Labels"
		],
		Address: ["P"],
		AllocationRole: ["Text", "FunctionRef"],
		AllocationRoleRef: ["Text", "FunctionalVariantRef"],
		AnalogueWiringParameters: ["Text"],
		AnalogueWiringParametersRef: ["Text"],
		Application: [
			"Text",
			"FunctionRole",
			"FunctionalVariant",
			"FunctionalVariantGroup",
			"AllocationRoleRef",
			"ApplicationSclRef"
		],
		ApplicationSclRef: ["Text", "SclFileReference"],
		Association: [],
		Authentication: [],
		BDA: [
			"Text",
			"Private",
			"Val",
			"Labels"
		],
		Bay: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"PowerTransformer",
			"GeneralEquipment",
			"ConductingEquipment",
			"ConnectivityNode",
			"Function"
		],
		BayType: [],
		BehaviorDescription: [
			"Text",
			"InputVar",
			"OutputVar",
			"BehaviorReference"
		],
		BehaviorDescriptionRef: [
			"Text",
			"FunctionalVariantRef",
			"InputVarRef",
			"OutputVarRef"
		],
		BehaviorReference: ["Text"],
		BinaryWiringParameters: ["Text"],
		BinaryWiringParametersRef: ["Text"],
		BitRate: [],
		CheckoutID: ["SubCheckoutID"],
		ClientLN: [],
		ClientServices: [
			"TimeSyncProt",
			"GOOSEMcSecurity",
			"SVMcSecurity",
			"Security"
		],
		CommProt: [],
		Communication: [
			"Text",
			"Private",
			"SubNetwork"
		],
		CommunicationServiceSpecifications: [
			"Text",
			"GooseParameters",
			"SMVParameters",
			"ReportParameters"
		],
		ConductingEquipment: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"Terminal",
			"SubEquipment",
			"EqFunction"
		],
		ConfDataSet: [],
		ConfLNs: [],
		ConfLdName: [],
		ConfLogControl: [],
		ConfReportControl: [],
		ConfSG: [],
		ConfSigRef: [],
		ConnectedAP: [
			"Text",
			"Private",
			"Address",
			"GSE",
			"SMV",
			"PhysConn"
		],
		ConnectivityNode: [
			"Text",
			"Private",
			"Labels",
			"LNode"
		],
		ControlRef: [
			"Text",
			"BinaryWiringParametersRef",
			"AnalogueWiringParametersRef"
		],
		ControllingLNode: [
			"Text",
			"BinaryWiringParametersRef",
			"AnalogueWiringParametersRef"
		],
		DA: [
			"Text",
			"Private",
			"Val",
			"Labels",
			"ProtNs"
		],
		DAI: [
			"Text",
			"Private",
			"Val",
			"Labels"
		],
		DAS: [
			"Text",
			"SubscriberLNode",
			"ControllingLNode",
			"ProcessEcho",
			"LogParametersRef",
			"Val",
			"Labels"
		],
		DAType: [
			"Text",
			"Private",
			"BDA",
			"ProtNs",
			"Labels"
		],
		DO: [
			"Text",
			"Private",
			"Labels"
		],
		DOI: [
			"Text",
			"Private",
			"SDI",
			"DAI",
			"Labels"
		],
		DOS: [
			"Text",
			"SDS",
			"DAS",
			"SubscriberLNode",
			"ControllingLNode",
			"ProcessEcho",
			"LogParametersRef",
			"Labels"
		],
		DOType: [
			"Text",
			"Private",
			"SDO",
			"DA",
			"Labels"
		],
		DataObjectDirectory: [],
		DataSet: [
			"Text",
			"Private",
			"FCDA"
		],
		DataSetDirectory: [],
		DataTypeTemplates: [
			"LNodeType",
			"DOType",
			"DAType",
			"EnumType"
		],
		DynAssociation: [],
		DynDataSet: [],
		EnumType: [
			"Text",
			"Private",
			"EnumVal"
		],
		EnumVal: [],
		EqFunction: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"GeneralEquipment",
			"EqSubFunction"
		],
		EqSubFunction: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"GeneralEquipment",
			"EqSubFunction"
		],
		ExtCtrl: ["Text", "Private"],
		ExtRef: ["Text", "Private"],
		FCDA: [],
		FileHandling: [],
		Function: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"SubFunction",
			"GeneralEquipment",
			"ConductingEquipment"
		],
		FunctionCatRef: ["Text"],
		FunctionCategory: [
			"Text",
			"SubCategory",
			"FunctionCatRef"
		],
		FunctionCategoryRef: ["Text", "FunctionalVariantRef"],
		FunctionRef: [
			"Text",
			"FunctionalVariantRef",
			"SignalRole"
		],
		FunctionRole: [
			"Text",
			"FunctionalVariantRef",
			"FunctionRoleContent"
		],
		FunctionRoleContent: [
			"Text",
			"FunctionRef",
			"BehaviorDescriptionRef",
			"ProcessResourceRef",
			"VariableRef",
			"FunctionCategoryRef",
			"PowerSystemRelationRef"
		],
		FunctionSclRef: ["Text", "SclFileReference"],
		FunctionTemplate: [
			"Text",
			"LNode",
			"SubFunctionTemplate",
			"GeneralEquipment",
			"ConductingEquipment"
		],
		FunctionalSubVariant: [
			"Text",
			"FunctionalSubVariant",
			"VariableRef"
		],
		FunctionalVariant: [
			"Text",
			"FunctionalSubVariant",
			"VariableRef"
		],
		FunctionalVariantGroup: ["Text", "FunctionalVariant"],
		FunctionalVariantRef: ["Text"],
		GOOSE: [],
		GOOSEMcSecurity: [],
		GOOSESecurity: [
			"Text",
			"Private",
			"Labels",
			"Subject",
			"IssuerName"
		],
		GSE: [
			"Text",
			"Private",
			"Address",
			"MinTime",
			"MaxTime"
		],
		GSEControl: [
			"Text",
			"Private",
			"IEDName",
			"Protocol"
		],
		GSEDir: [],
		GSESettings: ["McSecurity"],
		GSSE: [],
		GeneralEquipment: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"EqFunction"
		],
		GetCBValues: [],
		GetDataObjectDefinition: [],
		GetDataSetValue: [],
		GetDirectory: [],
		GooseParameters: [
			"Text",
			"L2CommParameters",
			"L3IPv4CommParameters",
			"L3IPv6CommParameters"
		],
		GooseParametersRef: ["Text"],
		Header: [
			"Text",
			"History",
			"SourceFiles"
		],
		History: ["Hitem"],
		Hitem: ["SourceFiles"],
		IED: [
			"Text",
			"Private",
			"Services",
			"AccessPoint",
			"KDC",
			"IEDSourceFiles",
			"MinRequestedSCDFiles",
			"Labels"
		],
		IEDName: [],
		IEDSourceFiles: [
			"Text",
			"Private",
			"SclFileReference"
		],
		InputVar: ["Text"],
		InputVarRef: ["Text", "FunctionalVariantRef"],
		Inputs: [
			"Text",
			"Private",
			"ExtRef"
		],
		IssuerName: [],
		KDC: [],
		L2CommParameters: ["Text"],
		L3IPv4CommParameters: ["Text"],
		L3IPv6CommParameters: ["Text"],
		LDevice: [
			"Text",
			"Private",
			"LN0",
			"LN",
			"AccessControl",
			"Labels"
		],
		LN: [
			"Text",
			"Private",
			"DataSet",
			"ReportControl",
			"LogControl",
			"DOI",
			"Inputs",
			"Outputs",
			"Log",
			"Labels"
		],
		LN0: [
			"Text",
			"Private",
			"DataSet",
			"ReportControl",
			"LogControl",
			"DOI",
			"Inputs",
			"Outputs",
			"Log",
			"Labels",
			"GSEControl",
			"SampledValueControl",
			"SettingControl"
		],
		LNode: [
			"Text",
			"Private",
			"Labels"
		],
		LNodeDataRef: ["Text", "FunctionalVariantRef"],
		LNodeInputRef: ["Text", "FunctionalVariantRef"],
		LNodeInputs: ["Text", "SourceRef"],
		LNodeOutputRef: ["Text", "FunctionalVariantRef"],
		LNodeOutputs: ["Text", "ControlRef"],
		LNodeSpecNaming: ["Text"],
		LNodeType: [
			"Text",
			"Private",
			"DO",
			"Labels"
		],
		Label: [],
		Labels: [
			"Text",
			"Private",
			"Label"
		],
		Line: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"GeneralEquipment",
			"Function",
			"Voltage",
			"ConductingEquipment",
			"ConnectivityNode"
		],
		Log: ["Text", "Private"],
		LogControl: [
			"Text",
			"Private",
			"TrgOps"
		],
		LogParameters: ["Text"],
		LogParametersRef: ["Text"],
		LogSettings: [],
		MaxTime: [],
		McSecurity: [],
		MinRequestedSCDFile: [],
		MinRequestedSCDFiles: [
			"Text",
			"Private",
			"MinRequestedSCDFile"
		],
		MinTime: [],
		MultiAPPerSubNet: [],
		NeutralPoint: ["Text", "Private"],
		OptFields: [],
		OutputVar: ["Text"],
		OutputVarRef: ["Text", "FunctionalVariantRef"],
		Outputs: [
			"Text",
			"Private",
			"ExtCtrl"
		],
		P: [],
		PhysConn: [
			"Text",
			"Private",
			"P"
		],
		PowerSystemRelation: ["Text"],
		PowerSystemRelationRef: ["Text", "FunctionalVariantRef"],
		PowerSystemRelations: ["Text", "PowerSystemRelation"],
		PowerTransformer: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"TransformerWinding",
			"SubEquipment",
			"EqFunction"
		],
		Private: [],
		Process: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"GeneralEquipment",
			"Function",
			"ConductingEquipment",
			"Substation",
			"Line",
			"Process"
		],
		ProcessEcho: ["Text"],
		ProcessResource: ["Text", "Resource"],
		ProcessResourceRef: ["Text", "FunctionalVariantRef"],
		ProcessResources: ["Text", "ProcessResource"],
		Project: ["Text", "ProjectProcessReference"],
		ProjectProcessReference: ["Text"],
		ProtNs: [],
		Protocol: [],
		ReadWrite: [],
		RedProt: [],
		ReportControl: [
			"Text",
			"Private",
			"TrgOps",
			"OptFields",
			"RptEnabled"
		],
		ReportParameters: ["Text"],
		ReportParametersRef: ["Text"],
		ReportSettings: [],
		Resource: [],
		RptEnabled: [
			"Text",
			"Private",
			"ClientLN"
		],
		SCL: [
			"Text",
			"Private",
			"Header",
			"Substation",
			"Communication",
			"IED",
			"DataTypeTemplates",
			"Line",
			"Process"
		],
		SCSM: [],
		SDI: [
			"Text",
			"Private",
			"SDI",
			"DAI",
			"Labels"
		],
		SDO: [
			"Text",
			"Private",
			"Labels"
		],
		SDS: [
			"Text",
			"SDS",
			"DAS",
			"SubscriberLNode",
			"ControllingLNode",
			"ProcessEcho",
			"LogParametersRef",
			"Labels"
		],
		SGEdit: [],
		SMV: [
			"Text",
			"Private",
			"Address"
		],
		SMVParameters: [
			"Text",
			"L2CommParameters",
			"L3IPv4CommParameters",
			"L3IPv6CommParameters"
		],
		SMVParametersRef: ["Text"],
		SMVSecurity: [
			"Text",
			"Private",
			"Labels",
			"Subject",
			"IssuerName"
		],
		SMVSettings: [
			"SmpRate",
			"SamplesPerSec",
			"SecPerSamples",
			"McSecurity"
		],
		SMVsc: [],
		SVMcSecurity: [],
		SampledValueControl: [
			"Text",
			"Private",
			"IEDName",
			"SmvOpts",
			"Protocol"
		],
		SamplesPerSec: [],
		SclFileReference: ["Text", "Private"],
		SecPerSamples: [],
		Security: [],
		Server: [
			"Text",
			"Private",
			"Authentication",
			"LDevice",
			"Association"
		],
		ServerAt: ["Text", "Private"],
		ServiceSpecifications: [
			"Text",
			"GooseParameters",
			"SMVParameters",
			"ReportParameters",
			"BinaryWiringParameters",
			"AnalogueWiringParameters",
			"LogParameters"
		],
		Services: /* @__PURE__ */ "DynAssociation.SettingGroups.GetDirectory.GetDataObjectDefinition.DataObjectDirectory.GetDataSetValue.SetDataSetValue.DataSetDirectory.ConfDataSet.DynDataSet.ReadWrite.TimerActivatedControl.ConfReportControl.GetCBValues.ConfLogControl.ReportSettings.LogSettings.GSESettings.SMVSettings.GSEDir.GOOSE.GSSE.SMVsc.FileHandling.ConfLNs.ClientServices.ConfLdName.SupSubscription.ConfSigRef.ValueHandling.RedProt.TimeSyncProt.CommProt.SCSM.Security.MultiAPPerSubNet".split("."),
		SetDataSetValue: [],
		SettingControl: ["Text", "Private"],
		SettingGroups: ["SGEdit", "ConfSG"],
		SignalRole: [
			"Text",
			"FunctionalVariantRef",
			"LNodeInputRef",
			"LNodeOutputRef",
			"LNodeDataRef"
		],
		SmpRate: [],
		SmvOpts: [],
		SourceFiles: [
			"Text",
			"Private",
			"SclFileReference"
		],
		SourceRef: [
			"Text",
			"GooseParametersRef",
			"SMVParametersRef",
			"ReportParametersRef",
			"BinaryWiringParametersRef",
			"AnalogueWiringParametersRef"
		],
		SubCategory: [
			"Text",
			"SubCategory",
			"FunctionCatRef"
		],
		SubCheckoutID: ["SubCheckoutID"],
		SubEquipment: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"EqFunction"
		],
		SubFunction: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"GeneralEquipment",
			"ConductingEquipment",
			"SubFunction"
		],
		SubFunctionTemplate: [
			"Text",
			"LNode",
			"GeneralEquipment",
			"ConductingEquipment",
			"SubFunctionTemplate"
		],
		SubNetwork: [
			"Text",
			"Private",
			"Labels",
			"BitRate",
			"ConnectedAP"
		],
		Subject: [],
		SubscriberLNode: [
			"Text",
			"GooseParametersRef",
			"SMVParametersRef",
			"ReportParametersRef",
			"BinaryWiringParametersRef"
		],
		Substation: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"PowerTransformer",
			"GeneralEquipment",
			"VoltageLevel",
			"Function"
		],
		SupSubscription: [],
		TapChanger: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"SubEquipment",
			"EqFunction"
		],
		Terminal: ["Text", "Private"],
		Text: [],
		TimeSyncProt: [],
		TimerActivatedControl: [],
		TransformerWinding: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"Terminal",
			"SubEquipment",
			"TapChanger",
			"NeutralPoint",
			"EqFunction"
		],
		TrgOps: [],
		Val: [],
		ValueHandling: [],
		Variable: ["Text", "VariableApplyTo"],
		VariableApplyTo: ["Text"],
		VariableRef: ["Text", "FunctionalVariantRef"],
		Voltage: [],
		VoltageLevel: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"PowerTransformer",
			"GeneralEquipment",
			"Voltage",
			"Bay",
			"Function"
		]
	},
	DEFINITION: pu,
	ELEMENT_NAMES: gu,
	PARENTS: {
		AccessControl: ["LDevice"],
		AccessPoint: ["IED"],
		Address: [
			"ConnectedAP",
			"GSE",
			"SMV"
		],
		AllocationRole: [],
		AllocationRoleRef: ["Application"],
		AnalogueWiringParameters: ["ServiceSpecifications"],
		AnalogueWiringParametersRef: [
			"ControlRef",
			"ControllingLNode",
			"SourceRef"
		],
		Application: [],
		ApplicationSclRef: ["Application"],
		Association: ["Server"],
		Authentication: ["Server"],
		BDA: ["DAType"],
		Bay: ["VoltageLevel"],
		BayType: [],
		BehaviorDescription: [],
		BehaviorDescriptionRef: ["FunctionRoleContent"],
		BehaviorReference: ["BehaviorDescription"],
		BinaryWiringParameters: ["ServiceSpecifications"],
		BinaryWiringParametersRef: [
			"ControlRef",
			"ControllingLNode",
			"SourceRef",
			"SubscriberLNode"
		],
		BitRate: ["SubNetwork"],
		CheckoutID: [],
		ClientLN: ["RptEnabled"],
		ClientServices: ["Services"],
		CommProt: ["Services"],
		Communication: ["SCL"],
		CommunicationServiceSpecifications: [],
		ConductingEquipment: [
			"Bay",
			"Function",
			"FunctionTemplate",
			"Line",
			"Process",
			"SubFunction",
			"SubFunctionTemplate"
		],
		ConfDataSet: ["Services"],
		ConfLNs: ["Services"],
		ConfLdName: ["Services"],
		ConfLogControl: ["Services"],
		ConfReportControl: ["Services"],
		ConfSG: ["SettingGroups"],
		ConfSigRef: ["Services"],
		ConnectedAP: ["SubNetwork"],
		ConnectivityNode: ["Bay", "Line"],
		ControlRef: ["LNodeOutputs"],
		ControllingLNode: [
			"DAS",
			"DOS",
			"SDS"
		],
		DA: ["DOType"],
		DAI: ["DOI", "SDI"],
		DAS: ["DOS", "SDS"],
		DAType: ["DataTypeTemplates"],
		DO: ["LNodeType"],
		DOI: ["LN", "LN0"],
		DOS: [],
		DOType: ["DataTypeTemplates"],
		DataObjectDirectory: ["Services"],
		DataSet: ["LN", "LN0"],
		DataSetDirectory: ["Services"],
		DataTypeTemplates: ["SCL"],
		DynAssociation: ["Services"],
		DynDataSet: ["Services"],
		EnumType: ["DataTypeTemplates"],
		EnumVal: ["EnumType"],
		EqFunction: [
			"ConductingEquipment",
			"GeneralEquipment",
			"PowerTransformer",
			"SubEquipment",
			"TapChanger",
			"TransformerWinding"
		],
		EqSubFunction: ["EqFunction", "EqSubFunction"],
		ExtCtrl: ["Outputs"],
		ExtRef: ["Inputs"],
		FCDA: ["DataSet"],
		FileHandling: ["Services"],
		Function: [
			"Bay",
			"Line",
			"Process",
			"Substation",
			"VoltageLevel"
		],
		FunctionCatRef: ["FunctionCategory", "SubCategory"],
		FunctionCategory: [],
		FunctionCategoryRef: ["FunctionRoleContent"],
		FunctionRef: ["AllocationRole", "FunctionRoleContent"],
		FunctionRole: ["Application"],
		FunctionRoleContent: ["FunctionRole"],
		FunctionSclRef: [],
		FunctionTemplate: [],
		FunctionalSubVariant: ["FunctionalSubVariant", "FunctionalVariant"],
		FunctionalVariant: ["Application", "FunctionalVariantGroup"],
		FunctionalVariantGroup: ["Application"],
		FunctionalVariantRef: [
			"AllocationRoleRef",
			"BehaviorDescriptionRef",
			"FunctionCategoryRef",
			"FunctionRef",
			"FunctionRole",
			"InputVarRef",
			"LNodeDataRef",
			"LNodeInputRef",
			"LNodeOutputRef",
			"OutputVarRef",
			"PowerSystemRelationRef",
			"ProcessResourceRef",
			"SignalRole",
			"VariableRef"
		],
		GOOSE: ["Services"],
		GOOSEMcSecurity: ["ClientServices"],
		GOOSESecurity: ["AccessPoint"],
		GSE: ["ConnectedAP"],
		GSEControl: ["LN0"],
		GSEDir: ["Services"],
		GSESettings: ["Services"],
		GSSE: ["Services"],
		GeneralEquipment: [
			"Bay",
			"EqFunction",
			"EqSubFunction",
			"Function",
			"FunctionTemplate",
			"Line",
			"Process",
			"SubFunction",
			"SubFunctionTemplate",
			"Substation",
			"VoltageLevel"
		],
		GetCBValues: ["Services"],
		GetDataObjectDefinition: ["Services"],
		GetDataSetValue: ["Services"],
		GetDirectory: ["Services"],
		GooseParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
		GooseParametersRef: ["SourceRef", "SubscriberLNode"],
		Header: ["SCL"],
		History: ["Header"],
		Hitem: ["History"],
		IED: ["SCL"],
		IEDName: ["GSEControl", "SampledValueControl"],
		IEDSourceFiles: ["IED"],
		InputVar: ["BehaviorDescription"],
		InputVarRef: ["BehaviorDescriptionRef"],
		Inputs: ["LN", "LN0"],
		IssuerName: ["GOOSESecurity", "SMVSecurity"],
		KDC: ["IED"],
		L2CommParameters: ["GooseParameters", "SMVParameters"],
		L3IPv4CommParameters: ["GooseParameters", "SMVParameters"],
		L3IPv6CommParameters: ["GooseParameters", "SMVParameters"],
		LDevice: ["Server"],
		LN: ["AccessPoint", "LDevice"],
		LN0: ["LDevice"],
		LNode: [
			"Bay",
			"ConductingEquipment",
			"ConnectivityNode",
			"EqFunction",
			"EqSubFunction",
			"Function",
			"FunctionTemplate",
			"GeneralEquipment",
			"Line",
			"PowerTransformer",
			"Process",
			"SubEquipment",
			"SubFunction",
			"SubFunctionTemplate",
			"Substation",
			"TapChanger",
			"TransformerWinding",
			"VoltageLevel"
		],
		LNodeDataRef: ["SignalRole"],
		LNodeInputRef: ["SignalRole"],
		LNodeInputs: [],
		LNodeOutputRef: ["SignalRole"],
		LNodeOutputs: [],
		LNodeSpecNaming: [],
		LNodeType: ["DataTypeTemplates"],
		Label: ["Labels"],
		Labels: /* @__PURE__ */ "AccessPoint.BDA.Bay.ConductingEquipment.ConnectivityNode.DA.DAI.DAS.DAType.DO.DOI.DOS.DOType.EqFunction.EqSubFunction.Function.GOOSESecurity.GeneralEquipment.IED.LDevice.LN.LN0.LNode.LNodeType.Line.PowerTransformer.Process.SDI.SDO.SDS.SMVSecurity.SubEquipment.SubFunction.SubNetwork.Substation.TapChanger.TransformerWinding.VoltageLevel".split("."),
		Line: ["Process", "SCL"],
		Log: ["LN", "LN0"],
		LogControl: ["LN", "LN0"],
		LogParameters: ["ServiceSpecifications"],
		LogParametersRef: [
			"DAS",
			"DOS",
			"SDS"
		],
		LogSettings: ["Services"],
		MaxTime: ["GSE"],
		McSecurity: ["GSESettings", "SMVSettings"],
		MinRequestedSCDFile: ["MinRequestedSCDFiles"],
		MinRequestedSCDFiles: ["IED"],
		MinTime: ["GSE"],
		MultiAPPerSubNet: ["Services"],
		NeutralPoint: ["TransformerWinding"],
		OptFields: ["ReportControl"],
		OutputVar: ["BehaviorDescription"],
		OutputVarRef: ["BehaviorDescriptionRef"],
		Outputs: ["LN", "LN0"],
		P: ["Address", "PhysConn"],
		PhysConn: ["ConnectedAP"],
		PowerSystemRelation: ["PowerSystemRelations"],
		PowerSystemRelationRef: ["FunctionRoleContent"],
		PowerSystemRelations: [],
		PowerTransformer: [
			"Bay",
			"Substation",
			"VoltageLevel"
		],
		Private: /* @__PURE__ */ "AccessPoint.BDA.Bay.Communication.ConductingEquipment.ConnectedAP.ConnectivityNode.DA.DAI.DAType.DO.DOI.DOType.DataSet.EnumType.EqFunction.EqSubFunction.ExtCtrl.ExtRef.Function.GOOSESecurity.GSE.GSEControl.GeneralEquipment.IED.IEDSourceFiles.Inputs.LDevice.LN.LN0.LNode.LNodeType.Labels.Line.Log.LogControl.MinRequestedSCDFiles.NeutralPoint.Outputs.PhysConn.PowerTransformer.Process.ReportControl.RptEnabled.SCL.SDI.SDO.SMV.SMVSecurity.SampledValueControl.SclFileReference.Server.ServerAt.SettingControl.SourceFiles.SubEquipment.SubFunction.SubNetwork.Substation.TapChanger.Terminal.TransformerWinding.VoltageLevel".split("."),
		Process: ["Process", "SCL"],
		ProcessEcho: [
			"DAS",
			"DOS",
			"SDS"
		],
		ProcessResource: ["ProcessResources"],
		ProcessResourceRef: ["FunctionRoleContent"],
		ProcessResources: [],
		Project: [],
		ProjectProcessReference: ["Project"],
		ProtNs: ["DA", "DAType"],
		Protocol: ["GSEControl", "SampledValueControl"],
		ReadWrite: ["Services"],
		RedProt: ["Services"],
		ReportControl: ["LN", "LN0"],
		ReportParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
		ReportParametersRef: ["SourceRef", "SubscriberLNode"],
		ReportSettings: ["Services"],
		Resource: ["ProcessResource"],
		RptEnabled: ["ReportControl"],
		SCL: [],
		SCSM: ["Services"],
		SDI: ["DOI", "SDI"],
		SDO: ["DOType"],
		SDS: ["DOS", "SDS"],
		SGEdit: ["SettingGroups"],
		SMV: ["ConnectedAP"],
		SMVParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
		SMVParametersRef: ["SourceRef", "SubscriberLNode"],
		SMVSecurity: ["AccessPoint"],
		SMVSettings: ["Services"],
		SMVsc: ["Services"],
		SVMcSecurity: ["ClientServices"],
		SampledValueControl: ["LN0"],
		SamplesPerSec: ["SMVSettings"],
		SclFileReference: [
			"ApplicationSclRef",
			"FunctionSclRef",
			"IEDSourceFiles",
			"SourceFiles"
		],
		SecPerSamples: ["SMVSettings"],
		Security: ["ClientServices", "Services"],
		Server: ["AccessPoint"],
		ServerAt: ["AccessPoint"],
		ServiceSpecifications: [],
		Services: ["AccessPoint", "IED"],
		SetDataSetValue: ["Services"],
		SettingControl: ["LN0"],
		SettingGroups: ["Services"],
		SignalRole: ["FunctionRef"],
		SmpRate: ["SMVSettings"],
		SmvOpts: ["SampledValueControl"],
		SourceFiles: ["Header", "Hitem"],
		SourceRef: ["LNodeInputs"],
		SubCategory: ["FunctionCategory", "SubCategory"],
		SubCheckoutID: ["CheckoutID", "SubCheckoutID"],
		SubEquipment: [
			"ConductingEquipment",
			"PowerTransformer",
			"TapChanger",
			"TransformerWinding"
		],
		SubFunction: ["Function", "SubFunction"],
		SubFunctionTemplate: ["FunctionTemplate", "SubFunctionTemplate"],
		SubNetwork: ["Communication"],
		Subject: ["GOOSESecurity", "SMVSecurity"],
		SubscriberLNode: [
			"DAS",
			"DOS",
			"SDS"
		],
		Substation: ["Process", "SCL"],
		SupSubscription: ["Services"],
		TapChanger: ["TransformerWinding"],
		Terminal: ["ConductingEquipment", "TransformerWinding"],
		Text: /* @__PURE__ */ "AccessPoint.AllocationRole.AllocationRoleRef.AnalogueWiringParameters.AnalogueWiringParametersRef.Application.ApplicationSclRef.BDA.Bay.BehaviorDescription.BehaviorDescriptionRef.BehaviorReference.BinaryWiringParameters.BinaryWiringParametersRef.Communication.CommunicationServiceSpecifications.ConductingEquipment.ConnectedAP.ConnectivityNode.ControlRef.ControllingLNode.DA.DAI.DAS.DAType.DO.DOI.DOS.DOType.DataSet.EnumType.EqFunction.EqSubFunction.ExtCtrl.ExtRef.Function.FunctionCatRef.FunctionCategory.FunctionCategoryRef.FunctionRef.FunctionRole.FunctionRoleContent.FunctionSclRef.FunctionTemplate.FunctionalSubVariant.FunctionalVariant.FunctionalVariantGroup.FunctionalVariantRef.GOOSESecurity.GSE.GSEControl.GeneralEquipment.GooseParameters.GooseParametersRef.Header.IED.IEDSourceFiles.InputVar.InputVarRef.Inputs.L2CommParameters.L3IPv4CommParameters.L3IPv6CommParameters.LDevice.LN.LN0.LNode.LNodeDataRef.LNodeInputRef.LNodeInputs.LNodeOutputRef.LNodeOutputs.LNodeSpecNaming.LNodeType.Labels.Line.Log.LogControl.LogParameters.LogParametersRef.MinRequestedSCDFiles.NeutralPoint.OutputVar.OutputVarRef.Outputs.PhysConn.PowerSystemRelation.PowerSystemRelationRef.PowerSystemRelations.PowerTransformer.Process.ProcessEcho.ProcessResource.ProcessResourceRef.ProcessResources.Project.ProjectProcessReference.ReportControl.ReportParameters.ReportParametersRef.RptEnabled.SCL.SDI.SDO.SDS.SMV.SMVParameters.SMVParametersRef.SMVSecurity.SampledValueControl.SclFileReference.Server.ServerAt.ServiceSpecifications.SettingControl.SignalRole.SourceFiles.SourceRef.SubCategory.SubEquipment.SubFunction.SubFunctionTemplate.SubNetwork.SubscriberLNode.Substation.TapChanger.Terminal.TransformerWinding.Variable.VariableApplyTo.VariableRef.VoltageLevel".split("."),
		TimeSyncProt: ["ClientServices", "Services"],
		TimerActivatedControl: ["Services"],
		TransformerWinding: ["PowerTransformer"],
		TrgOps: ["LogControl", "ReportControl"],
		Val: [
			"BDA",
			"DA",
			"DAI",
			"DAS"
		],
		ValueHandling: ["Services"],
		Variable: [],
		VariableApplyTo: ["Variable"],
		VariableRef: [
			"FunctionRoleContent",
			"FunctionalSubVariant",
			"FunctionalVariant"
		],
		Voltage: ["Line", "VoltageLevel"],
		VoltageLevel: ["Substation"]
	},
	REQUIRED: du
}, Symbol.toStringTag, { value: "Module" })) }, Au = { default: {
	prefix: "",
	uri: "http://www.iec.ch/61850/2003/SCL"
} };
function Nu(u) {
	return u.reduce((u, E) => {
		if (!E) return u;
		let D = E.tagName, O = u[D] ?? [];
		return O.push(E), u[D] = O, u;
	}, {});
}
function Eu(u) {
	return typeof u == "object" && !!u && "id" in u && "tagName" in u && "namespace" in u && "attributes" in u && "children" in u && !("treeChildren" in u) && !("status" in u);
}
function It(u) {
	return "treeChildren" in u && "status" in u;
}
function Fu(u) {
	return It(u) ? u : {
		...u,
		treeChildren: [],
		status: "unchanged"
	};
}
function Mu(u) {
	if (It(u)) {
		let { treeChildren: E, status: D,...O } = u;
		return O;
	}
	return u;
}
function Z(u) {
	let { childRecord: E, parentRecord: D, stagedOperations: O } = u;
	function P(u) {
		let E = [...O].reverse().find((E) => E.type === "create" ? E.record.id === u && E.record.tagName === "Private" : E.type === "update" ? E.new.id === u && E.new.tagName === "Private" : !1);
		if (E?.type === "create") return E.record;
		if (E?.type === "update") return E.new;
	}
	function F(u) {
		return {
			childRecord: {
				...E,
				parent: {
					id: u.id,
					tagName: "Private"
				}
			},
			privateRecord: {
				...u,
				children: [...u.children, {
					id: E.id,
					tagName: E.tagName
				}]
			}
		};
	}
	if (D.tagName === "Private") {
		let u = D, E = P(u.id) || u, { childRecord: O, privateRecord: I } = F(E);
		return {
			childRecord: O,
			privateRecord: I,
			oldPrivateRecord: E,
			updatedParentRecord: I,
			isNewPrivateElement: !1
		};
	}
	let I = D.children.find((u) => u.tagName === "Private");
	if (I) {
		let u = P(I.id);
		if (u && u.attributes.some((u) => u.name === "type" && u.value === E.namespace.prefix)) {
			let { childRecord: E, privateRecord: O } = F(u);
			return {
				childRecord: E,
				privateRecord: O,
				oldPrivateRecord: u,
				updatedParentRecord: D,
				isNewPrivateElement: !1
			};
		}
	}
	let R = {
		id: crypto.randomUUID(),
		tagName: "Private",
		namespace: {
			prefix: Au.default.prefix,
			uri: Au.default.uri
		},
		attributes: [{
			name: "type",
			value: E.namespace.prefix
		}],
		value: "",
		parent: {
			id: D.id,
			tagName: D.tagName
		},
		children: [{
			id: E.id,
			tagName: E.tagName
		}],
		status: "create",
		treeChildren: []
	};
	return {
		childRecord: {
			...E,
			parent: {
				id: R.id,
				tagName: "Private"
			}
		},
		privateRecord: R,
		updatedParentRecord: {
			...D,
			children: [...D.children, {
				id: R.id,
				tagName: "Private"
			}]
		},
		isNewPrivateElement: !0
	};
}
function A(u) {
	let { attributes: E, name: D } = u;
	return E.find((u) => u.name === D)?.value || "";
}
function j(u) {
	let { attributes: E } = u;
	return E.reduce((u, E) => {
		let D = E.value || "";
		return u[E.name] = D, u;
	}, {});
}
var M = [
	"DO",
	"SDO",
	"DA",
	"BDA",
	"EnumVal"
], V = {
	LNodeType: "id",
	DOType: "id",
	DAType: "id",
	EnumType: "id",
	DO: "name",
	SDO: "name",
	DA: "name",
	BDA: "name",
	EnumVal: "ord"
};
function B(u) {
	return V[u];
}
function _(u) {
	let { source: E, targets: D } = u, O;
	O = E.tagName === "LNode" || E.tagName === "LN" ? "lnType" : "type";
	let P = E.attributes, F = A({
		attributes: P,
		name: O
	});
	return D.find((u) => {
		let E = B(u.tagName), D = u.attributes;
		return A({
			attributes: D,
			name: E
		}) === F;
	});
}
function S$1(u) {
	let { sources: E, targets: D } = u, O = [];
	for (let u of E) {
		let E = _({
			source: u,
			targets: D
		});
		E && O.push(E);
	}
	return O;
}
function z(u) {
	let { version: E, records: D } = u;
	return D.length === 0 ? !0 : D.every((u) => {
		if (!It(u) || !Ru[E].CHILDREN.DataTypeTemplates.includes(u.tagName)) return !1;
		let D = Ru[E].CHILDREN[u.tagName];
		return u.treeChildren.every((u) => !!(M.includes(u.tagName) || D && D.includes(u.tagName)));
	});
}
function ee(u) {
	let { version: E, records: D } = u;
	if (!z({
		version: E,
		records: D
	})) throw Error("Some records are not valid data model records.");
	return D;
}
function te(u) {
	let { version: E, tagName: D, attributeName: O, value: P, elementId: F } = u, I = Ru[E].DEFINITION[D];
	if (!I || !I.attributes?.details) return;
	let R = I.attributes.details[O];
	if (!R?.validation?.enumeration) return;
	let U = R.validation.enumeration;
	if (!U.includes(P)) throw Error(`Invalid value '${P}' for attribute '${O}' on ${D}(element: ${F}). Expected one of: ${U.join(", ")}`);
}
var re$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
	__proto__: null,
	DATA_MODEL_CHILDREN_TAG_NAMES: M,
	DATA_MODEL_ROOT_ELEMENT_TO_ATTRIBUTE_KEY: V,
	areDataModelRecords: z,
	filterDataModelRootElements: S$1,
	getAttributeValueByName: A,
	getAttributesValuesByName: j,
	getDataModelRootElementKeyAttribute: B,
	groupRecordsByTagName: Nu,
	isDatabaseRecord: Eu,
	isTreeRecord: It,
	resolveDataModelRootElementReference: _,
	toDataModelRecords: ee,
	toDatabaseRecord: Mu,
	toTreeRecord: Fu,
	validateAttributeValue: te
}, Symbol.toStringTag, { value: "Module" }));
function ne(u) {
	let { genericApiBuilder: E, contextPromise: D, extensions: O } = u;
	return function(u) {
		let { tagName: P, attributes: F, namespace: I, value: R, setFocus: U = !1 } = u, J = crypto.randomUUID();
		return E({
			contextPromise: D.then((u) => {
				let E, D;
				if (Ru[u.version].DEFINITION.hasOwnProperty(P)) {
					D = Ru[u.version].DEFINITION[P].namespace;
					let O = Ru[u.version].DEFINITION[P].attributes.details;
					E = Array.isArray(F) ? F : Object.entries(F).map(([u, E]) => {
						let D = u;
						return {
							name: D,
							value: D === "uuid" ? crypto.randomUUID() : E,
							namespace: O[D]?.namespace
						};
					});
					let I = Object.keys(Ru[u.version].ATTRIBUTES[P]).includes("uuid"), R = E.some((u) => u.name === "uuid");
					if (I && !R) {
						let u = "uuid";
						E.push({
							name: u,
							value: crypto.randomUUID(),
							namespace: O[u]?.namespace
						});
					}
				} else D = I ?? {
					prefix: "",
					uri: ""
				}, E = Array.isArray(F) ? F : [];
				let O = {
					id: J,
					tagName: P,
					namespace: D,
					attributes: E,
					value: R ?? "",
					parent: {
						id: u.currentFocus.id,
						tagName: u.currentFocus.tagName
					},
					children: [],
					status: "created",
					treeChildren: []
				};
				if (O.namespace.prefix !== Au.default.prefix) {
					let { childRecord: E, privateRecord: D, oldPrivateRecord: P, updatedParentRecord: F, isNewPrivateElement: I } = Z({
						childRecord: O,
						parentRecord: u.currentFocus,
						stagedOperations: u.stagedOperations
					});
					if (I && b$1({
						context: u,
						type: "create",
						record: D
					}), b$1({
						context: u,
						type: "create",
						record: E
					}), !I && P && b$1({
						context: u,
						type: "update",
						old: P,
						new: D
					}), b$1({
						context: u,
						type: "update",
						old: Mu(u.currentFocus),
						new: F
					}), U) return {
						...u,
						currentFocus: E
					};
					{
						let E = {
							...u.currentFocus,
							...F
						};
						return {
							...u,
							currentFocus: E
						};
					}
				} else {
					b$1({
						context: u,
						type: "create",
						record: O
					});
					let E = {
						...u.currentFocus,
						children: [...u.currentFocus.children, {
							id: O.id,
							tagName: O.tagName
						}]
					};
					return b$1({
						context: u,
						type: "update",
						old: Mu(u.currentFocus),
						new: Mu(E)
					}), U ? {
						...u,
						currentFocus: O
					} : {
						...u,
						currentFocus: E
					};
				}
			}),
			extensions: O,
			tagName: P
		});
	};
}
function ae(u) {
	let { genericApiBuilder: E, contextPromise: D, extensions: O } = u;
	return function(u) {
		let { record: P, setFocus: F = !1 } = u;
		return E({
			contextPromise: D.then(async (u) => {
				function D(u) {
					return 1 + u.treeChildren.reduce((u, E) => u + D(E), 0);
				}
				let I = D(P), R = 0;
				function U(E, D) {
					let O = E.addChild({
						tagName: D.tagName,
						namespace: D.namespace,
						attributes: D.attributes,
						value: D.value,
						setFocus: !0
					});
					R++, u.onProgress && u.onProgress({
						current: R,
						total: I,
						message: `Cloning ${D.tagName}`,
						scope: "deepCloneChild"
					});
					let P = O;
					for (let u of D.treeChildren) P = U(P, u), P = P.goToParent();
					return P;
				}
				let J = E({
					contextPromise: Promise.resolve(u),
					extensions: O,
					tagName: u.currentFocus.tagName
				});
				return J = U(J, P), F || (J = J.goToParent()), await J.getContext();
			}),
			extensions: O,
			tagName: P.tagName
		});
	};
}
function oe(u) {
	let { genericApiBuilder: E, contextPromise: D, extensions: O, tagName: P } = u;
	return function(u) {
		let { attributes: F, value: I } = u;
		return E({
			contextPromise: D.then(async (u) => {
				let E = [...u.currentFocus.attributes];
				if (F) for (let u of F) {
					let D = E.findIndex((E) => E.name === u.name);
					if (u.value === "" || u.value === void 0 || u.value === null) {
						D >= 0 && E.splice(D, 1);
						continue;
					}
					let O = {
						name: u.name,
						value: String(u.value),
						...u.namespace && { namespace: u.namespace }
					};
					D >= 0 ? E[D] = O : E.push(O);
				}
				let D = Ru[u.version].DEFINITION[u.currentFocus.tagName].namespace, O = u.currentFocus.namespace?.prefix === D.prefix, P = {
					...u.currentFocus,
					namespace: D && !O ? D : u.currentFocus.namespace,
					attributes: F ? E : u.currentFocus.attributes,
					value: I ?? u.currentFocus.value
				};
				return b$1({
					context: u,
					type: "update",
					old: Mu(u.currentFocus),
					new: Mu(P)
				}), {
					...u,
					currentFocus: P
				};
			}),
			extensions: O,
			tagName: P
		});
	};
}
function se(u) {
	let { genericApiBuilder: E, contextPromise: D, extensions: O } = u;
	return function() {
		let u;
		return E({
			contextPromise: D.then(async (E) => {
				let D = E.currentFocus.id;
				b$1({
					context: E,
					type: "delete",
					record: Mu(E.currentFocus)
				});
				let O = E.currentFocus.parent;
				if (!O) throw Error("Cannot delete element without a parent");
				u = O.tagName, await P(E.currentFocus.children);
				async function P(u) {
					for (let D of u) {
						let u = [...E.stagedOperations].reverse().find((u) => u.type === "create" ? u.record.id === D.id : u.type === "update" ? u.new.id === D.id : !1), O;
						u ? u.type === "create" ? O = u.record : u.type === "update" && (O = u.new) : O = await E.databaseInstance.sclElements.get({
							id: D.id,
							tagName: D.tagName
						}), O && (O.children && O.children.length > 0 && await P(O.children), b$1({
							context: E,
							type: "delete",
							record: O
						}));
					}
				}
				let F = [...E.stagedOperations].reverse().find((u) => u.type === "create" ? u.record.id === O.id : u.type === "update" ? u.new.id === O.id : !1), I;
				if (F) if (F.type === "create") I = F.record;
				else if (F.type === "update") I = F.new;
				else throw Error("Unexpected operation type");
				else {
					let u = await E.databaseInstance.sclElements.get({
						id: O.id,
						tagName: O.tagName
					});
					if (!u) throw Error("Parent record not found in database");
					I = u;
				}
				let R = {
					...Fu(I),
					children: I.children.filter((u) => u.id !== D)
				};
				return b$1({
					context: E,
					type: "update",
					old: Mu(I),
					new: Mu(R)
				}), {
					...E,
					currentFocus: R
				};
			}),
			extensions: O,
			tagName: u
		});
	};
}
function b$1(u) {
	let { context: E, type: D, record: O, old: P, new: F } = u;
	if (D === "create") {
		if (!O) throw Error("record is required for create");
		E.stagedOperations.push({
			type: D,
			record: O
		});
	} else if (D === "update") {
		if (!P || !F) throw Error("old and new are required for update");
		E.stagedOperations.push({
			type: D,
			old: P,
			new: F
		});
	} else if (D === "delete") {
		if (!O) throw Error("record is required for delete");
		E.stagedOperations.push({
			type: D,
			record: O
		});
	}
}
function ie(u) {
	let { genericApiBuilder: E, contextPromise: D, extensions: O } = u;
	function P(u) {
		let { tagName: P, id: F } = u;
		return E({
			contextPromise: D.then(async (u) => {
				let E;
				if ((P === "SCL" || P === "Header" || P === "Communication" || P === "DataTypeTemplates") && !F) E = await u.databaseInstance[ou].where("tagName").equals(P).first();
				else if (F) E = await u.databaseInstance[ou].get({
					id: F,
					tagName: P
				});
				else throw Error(`Element ${P} requires an id parameter`);
				if (!E) {
					let u = F ? ` with id ${F}` : "";
					throw Error(`No element ${P}${u} found in database`);
				}
				if (E.tagName !== P) throw Error("Element tagName mismatch");
				let D = Fu(E);
				return {
					...u,
					entrypoint: D,
					currentFocus: D
				};
			}),
			extensions: O,
			tagName: P
		});
	}
	return P;
}
function ce(u) {
	let { genericApiBuilder: E, contextPromise: D, extensions: O } = u;
	return function() {
		let u;
		return E({
			contextPromise: D.then(async (E) => {
				let D = E.currentFocus.parent;
				if (!D) throw Error("No parent found");
				u = D.tagName;
				let O = [...E.stagedOperations].reverse().find((u) => u.type === "create" ? u.record.id === D.id : u.type === "update" ? u.new.id === D.id : !1), P;
				if (O && O.type !== "delete") P = O.type === "create" ? O.record : O.new;
				else {
					let u = await E.databaseInstance[ou].get({
						id: D.id,
						tagName: D.tagName
					});
					if (!u) throw Error("Parent record not found in database");
					P = u;
				}
				return {
					...E,
					currentFocus: Fu(P)
				};
			}),
			extensions: O,
			tagName: u
		});
	};
}
async function q$1(u) {
	let { context: E, options: D } = u, { depth: O, filter: P, withStagedOperations: F, withPrivate: I } = D || {}, R, U;
	F && (R = le(E.stagedOperations), U = [...E.stagedOperations].reverse().find((u) => u.type === "create" ? u.record.id === E.currentFocus.id : u.type === "update" ? u.new.id === E.currentFocus.id : !1));
	let J = E.currentFocus;
	U?.type === "update" && (J = U.new), U?.type === "create" && (J = U.record);
	let _p = de(P?.pick), vp = ue(P?.exclude);
	return await x$3({
		context: E,
		record: J,
		currentDepth: 0,
		stagedOperationsPerRecordId: R,
		pickMap: _p,
		excludeSet: vp,
		isDeepBranch: !1,
		options: {
			depth: O,
			withStagedOperations: F,
			withPrivate: !!I
		}
	});
}
function de(u) {
	let E = /* @__PURE__ */ new Map();
	if (!u) return E;
	for (let D of u) typeof D == "string" ? E.set(D, !1) : typeof D == "object" && "tagName" in D && E.set(D.tagName, !!D.deep);
	return E;
}
function ue(u) {
	return u ? new Set(u) : /* @__PURE__ */ new Set();
}
function le(u) {
	let E = /* @__PURE__ */ new Map();
	for (let D of u) D.type === "delete" || D.type === "create" ? E.has(D.record.id) || E.set(D.record.id, D) : D.type === "update" && (E.has(D.new.id) || E.set(D.new.id, D));
	return E;
}
function pe(u, E) {
	return E.get(u)?.type || "unchanged";
}
function G(u) {
	let { tagName: E, pickMap: D, excludeSet: O, isDeepBranch: P, withPrivate: F } = u;
	return E === "Private" && !F ? {
		shouldInclude: !1,
		nextDeepBranch: !1
	} : P ? {
		shouldInclude: !0,
		nextDeepBranch: !0
	} : O.has(E) ? {
		shouldInclude: !1,
		nextDeepBranch: !1
	} : D.size > 0 ? D.has(E) ? {
		shouldInclude: !0,
		nextDeepBranch: D.get(E) ?? !1
	} : {
		shouldInclude: !1,
		nextDeepBranch: !1
	} : {
		shouldInclude: !0,
		nextDeepBranch: !1
	};
}
function H(u) {
	let { childTree: E, pickMap: D, excludeSet: O, withPrivate: P } = u;
	if (!E.treeChildren || E.treeChildren.length === 0) return [];
	let F = [];
	for (let u of E.treeChildren) {
		let { shouldInclude: E } = G({
			tagName: u.tagName,
			pickMap: D,
			excludeSet: O,
			isDeepBranch: !1,
			withPrivate: P
		});
		E ? F.push(u) : F.push(...H({
			childTree: u,
			pickMap: D,
			excludeSet: O,
			withPrivate: P
		}));
	}
	return F;
}
function L(u) {
	let { tree: E, recordId: D, stagedOperationsPerRecordId: O } = u;
	return {
		...E,
		status: O ? pe(D, O) : "unchanged"
	};
}
async function x$3(u) {
	let { context: E, record: D, currentDepth: O, stagedOperationsPerRecordId: P, pickMap: F, excludeSet: I, isDeepBranch: R, options: U } = u, { depth: J, withStagedOperations: _p, withPrivate: vp } = U, yp = (await Promise.all(D.children.map(async (u) => {
		if (_p) {
			let D = [...E.stagedOperations].reverse().find((E) => E.type === "create" ? E.record.id === u.id : E.type === "update" ? E.new.id === u.id : !1);
			if (D && D.type !== "delete") return D.type === "create" ? D.record : D.new;
		}
		return E.databaseInstance[ou].get({
			id: u.id,
			tagName: u.tagName
		});
	}))).filter((u) => !!u);
	if (J !== void 0 && O >= J && D.tagName !== "Private" && !vp) return L({
		tree: {
			...D,
			treeChildren: []
		},
		recordId: D.id,
		stagedOperationsPerRecordId: P
	});
	let bp = [];
	for (let D of yp) {
		let U = D.tagName, { shouldInclude: J, nextDeepBranch: _p } = G({
			tagName: U,
			pickMap: F,
			excludeSet: I,
			isDeepBranch: R,
			withPrivate: vp
		});
		if (J) {
			let R = await x$3({
				context: E,
				record: D,
				currentDepth: O + 1,
				stagedOperationsPerRecordId: P,
				pickMap: F,
				excludeSet: I,
				isDeepBranch: _p,
				options: u.options
			});
			bp.push(R);
		} else if (U === "Private" || F.size > 0) {
			let R = H({
				childTree: await x$3({
					context: E,
					record: D,
					currentDepth: O + 1,
					stagedOperationsPerRecordId: P,
					pickMap: F,
					excludeSet: I,
					isDeepBranch: _p,
					options: u.options
				}),
				pickMap: F,
				excludeSet: I,
				withPrivate: vp
			});
			bp.push(...R);
		}
	}
	return L({
		tree: {
			...D,
			treeChildren: bp
		},
		recordId: D.id,
		stagedOperationsPerRecordId: P
	});
}
function me(u) {
	let { contextPromise: E } = u;
	return async function() {
		let u = await E;
		return Lu(() => u.databaseInstance[ou].get(u.currentFocus.id));
	};
}
function fe(u) {
	let { contextPromise: E } = u;
	return async function() {
		return await q$1({
			context: await E,
			options: { withStagedOperations: !0 }
		});
	};
}
function ge(u) {
	let { contextPromise: E } = u;
	return async function() {
		return await E;
	};
}
function he(u) {
	let { contextPromise: E } = u;
	return async function(u) {
		let { depth: D, filter: O, withStagedOperations: P, withPrivate: F } = u || {};
		return await q$1({
			context: await E,
			options: {
				depth: D,
				filter: O,
				withStagedOperations: P,
				withPrivate: F
			}
		});
	};
}
function Ne(u) {
	let { contextPromise: E } = u;
	return async function() {
		let u = await E, D = u.stagedOperations.length;
		try {
			await u.databaseInstance.transaction("rw", u.databaseInstance.tables, async () => {
				let E = u.stagedOperations.filter((u) => u.type === "create"), O = u.stagedOperations.filter((u) => u.type === "update"), P = u.stagedOperations.filter((u) => u.type === "delete"), F = 0;
				E.length > 0 && (u.onProgress?.({
					current: F,
					total: D,
					message: `Creating ${E.length} records`,
					scope: "commit"
				}), await u.databaseInstance.sclElements.bulkAdd(E.map((u) => u.record)), F += E.length, u.onProgress?.({
					current: F,
					total: D,
					message: `Created ${E.length} records`,
					scope: "commit"
				})), O.length > 0 && (u.onProgress?.({
					current: F,
					total: D,
					message: `Updating ${O.length} records`,
					scope: "commit"
				}), await u.databaseInstance.sclElements.bulkPut(O.map((u) => u.new)), F += O.length, u.onProgress?.({
					current: F,
					total: D,
					message: `Updated ${O.length} records`,
					scope: "commit"
				})), P.length > 0 && (u.onProgress?.({
					current: F,
					total: D,
					message: `Deleting ${P.length} records`,
					scope: "commit"
				}), await u.databaseInstance.sclElements.bulkDelete(P.map((u) => u.record.id)), F += P.length, u.onProgress?.({
					current: F,
					total: D,
					message: `Deleted ${P.length} records`,
					scope: "commit"
				}));
			});
		} catch (u) {
			throw Error("Transaction failed", { cause: u });
		}
	};
}
function T(u) {
	let { contextPromise: E, extensions: D, tagName: O } = u;
	return we({
		genericBuilder: {
			addChild: ne({
				genericApiBuilder: T,
				contextPromise: E,
				extensions: D
			}),
			deepCloneChild: ae({
				genericApiBuilder: T,
				contextPromise: E,
				extensions: D
			}),
			update: oe({
				genericApiBuilder: T,
				contextPromise: E,
				extensions: D,
				tagName: O
			}),
			delete: O === "SCL" ? void 0 : se({
				genericApiBuilder: T,
				contextPromise: E,
				extensions: D
			}),
			goToElement: ie({
				genericApiBuilder: T,
				contextPromise: E,
				extensions: D
			}),
			goToParent: ce({
				genericApiBuilder: T,
				contextPromise: E,
				extensions: D
			}),
			getObservable: me({ contextPromise: E }),
			getChildren: he({ contextPromise: E }),
			getSnapshot: fe({ contextPromise: E }),
			getContext: ge({ contextPromise: E }),
			commit: Ne({ contextPromise: E })
		},
		extensions: D,
		tagName: O,
		contextPromise: E
	});
}
function we(u) {
	let { genericBuilder: E, extensions: D, tagName: O, contextPromise: P } = u, F = E, I = D[O] || {};
	for (let [u, E] of Object.entries(I)) typeof E == "function" && (F[u] = E({
		genericApiBuilder: T,
		contextPromise: P,
		extensions: D
	}));
	return F;
}
function ye(u) {
	let { databaseInstance: E, tagName: D } = u;
	return Lu(() => E[ou].where({ tagName: D }).toArray());
}
function Pe(u) {
	let { version: E, databaseInstance: D, extensions: O, tagName: P, id: F, onProgress: I } = u;
	return T({
		contextPromise: Promise.resolve().then(async () => {
			let u = P === "SCL" || P === "Header" || P === "Communication" || P === "DataTypeTemplates", O;
			if (u && !F) O = await D[ou].where("tagName").equals(P).first();
			else if (F) O = await D[ou].get({
				id: F,
				tagName: P
			});
			else throw Error(`Element ${P} requires an id parameter`);
			if (!O) {
				let u = F ? ` with id ${F}` : "";
				throw Error(`No element ${P}${u} found in database`);
			}
			if (O.tagName !== P) throw Error("Element tagName mismatch");
			let R = Fu(O);
			return {
				version: E,
				databaseInstance: D,
				entrypoint: R,
				currentFocus: R,
				stagedOperations: [],
				onProgress: I
			};
		}),
		extensions: O,
		tagName: P
	});
}
function ve(u) {
	let { version: E, databaseInstance: D, extensions: O, onProgress: P } = u;
	return T({
		contextPromise: Promise.resolve().then(async () => {
			let u = await D[ou].where({ tagName: "SCL" }).count();
			if (u === 0) throw Error("No root SCL element found in database");
			if (u > 1) throw Error("Multiple root SCL elements found in database, database is corrupted");
			let O = await D[ou].get({ tagName: "SCL" });
			if (!O) throw Error("No root SCL element found in database");
			let F = Fu(O);
			return {
				version: E,
				databaseInstance: D,
				entrypoint: F,
				currentFocus: F,
				stagedOperations: [],
				onProgress: P
			};
		}),
		extensions: O,
		tagName: "SCL"
	});
}
async function K(u) {
	let { record: E, dataTypeTemplates: D } = u, { LNodeType: O = [], DOType: P = [], DAType: F = [], EnumType: I = [] } = Nu(D.treeChildren), R = _({
		source: E,
		targets: O
	});
	if (!R) throw Error(`LNodeType for ${E.tagName} ${E.attributes.find((u) => u.name === "lnType")?.value} not found`);
	let U = S$1({
		sources: R.treeChildren.filter((u) => u.tagName === "DO"),
		targets: P
	}), J = S$1({
		sources: U.flatMap((u) => u.treeChildren.filter((u) => u.tagName === "DA")),
		targets: F
	}), _p = S$1({
		sources: J.flatMap((u) => u.treeChildren.filter((u) => u.tagName === "BDA")),
		targets: I
	});
	return {
		...E,
		treeChildren: [
			R,
			...U,
			...J,
			..._p
		],
		status: "unchanged"
	};
}
function be(u) {
	let { genericApiBuilder: E, contextPromise: D, extensions: O } = u;
	return function() {
		return E({
			contextPromise: D.then(async (u) => {
				let D = u.currentFocus, P = await K({
					record: D,
					dataTypeTemplates: await E({
						contextPromise: Promise.resolve(u),
						extensions: O,
						tagName: u.currentFocus.tagName
					}).goToElement({ tagName: "DataTypeTemplates" }).getChildren()
				});
				return {
					...u,
					currentFocus: P
				};
			}),
			extensions: O,
			tagName: "LNode"
		});
	};
}
var Te = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
	__proto__: null,
	resolveDataModel: be
}, Symbol.toStringTag, { value: "Module" }));
function Ce(u) {
	let { genericApiBuilder: E, contextPromise: D, extensions: O } = u;
	return function(u) {
		let { subnetworkId: P } = u;
		return E({
			contextPromise: D.then(async (u) => {
				let D = E({
					contextPromise: Promise.resolve(u),
					extensions: O,
					tagName: "IED"
				}), F = A({
					attributes: u.currentFocus.attributes,
					name: "name"
				}), I = await D.getChildren({
					filter: { pick: ["AccessPoint"] },
					withStagedOperations: !0
				}), R = D.goToElement({
					tagName: "SubNetwork",
					id: P
				});
				for (let u of I.treeChildren) {
					let E = A({
						attributes: u.attributes,
						name: "name"
					});
					R = R.addChild({
						tagName: "ConnectedAP",
						attributes: {
							iedName: F,
							apName: E
						}
					});
				}
				let U = (await R.getContext()).stagedOperations;
				return {
					...u,
					stagedOperations: U
				};
			}),
			extensions: O,
			tagName: "IED"
		});
	};
}
var Ee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
	__proto__: null,
	attachAllAccessPointToSubNetwork: Ce
}, Symbol.toStringTag, { value: "Module" }));
function De(u) {
	let { genericApiBuilder: E, contextPromise: D, extensions: O } = u;
	return function() {
		return E({
			contextPromise: D.then(async (u) => {
				let D = u.currentFocus, P = await K({
					record: D,
					dataTypeTemplates: await E({
						contextPromise: Promise.resolve(u),
						extensions: O,
						tagName: u.currentFocus.tagName
					}).goToElement({ tagName: "DataTypeTemplates" }).getChildren()
				});
				return {
					...u,
					currentFocus: P
				};
			}),
			extensions: O,
			tagName: "LN"
		});
	};
}
var Re = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
	__proto__: null,
	resolveDataModel: De
}, Symbol.toStringTag, { value: "Module" }));
function Oe(u) {
	let { genericApiBuilder: E, contextPromise: D, extensions: O } = u;
	return function(u) {
		let { dataModel: P } = u;
		return E({
			contextPromise: D.then(async (u) => {
				let D = E({
					contextPromise: Promise.resolve(u),
					extensions: O,
					tagName: "DataTypeTemplates"
				});
				for (let u of P) {
					if (await Q(D, u)) continue;
					D = W$1(D, u);
					let E = u.treeChildren.filter((u) => M.includes(u.tagName));
					for (let u of E) D = await Ie(D, u);
					D = D.goToParent();
				}
				return await D.getContext();
			}),
			extensions: O,
			tagName: "DataTypeTemplates"
		});
	};
}
async function Ie(u, E) {
	return await Q(u, E) ? u : W$1(u, E).goToParent();
}
function W$1(u, E) {
	let D = j({ attributes: E.attributes });
	return u.addChild({
		tagName: E.tagName,
		attributes: D,
		setFocus: !0
	});
}
async function Q(u, E) {
	let D = B(E.tagName), O = E.attributes.find((u) => u.name === D)?.value;
	if (!O) throw Error(`Key attribute "${D}" is missing in element attributes.`);
	return (await u.getChildren({
		depth: 1,
		withStagedOperations: !0
	})).treeChildren.find((u) => u.tagName === E.tagName && u.attributes.find((u) => u.name === D)?.value === O);
}
var Fe = { v2019C1: {
	LNode: Te,
	IED: Ee,
	LN: Re,
	DataTypeTemplates: /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
		__proto__: null,
		addToDataModel: Oe
	}, Symbol.toStringTag, { value: "Module" }))
} };
function xe(u) {
	let { version: E, databaseInstance: D } = u, O = Fe[E];
	return {
		fromRoot: (u) => ve({
			version: E,
			databaseInstance: D,
			extensions: O,
			onProgress: u?.onProgress
		}),
		fromElement: (u) => Pe({
			version: E,
			databaseInstance: D,
			extensions: O,
			tagName: u.tagName,
			id: u.id,
			onProgress: u?.onProgress
		}),
		getObservable: (u) => ye({
			databaseInstance: D,
			...u
		}),
		getElement: async (u) => await D[ou].get({
			tagName: u.tagName,
			id: u.id
		})
	};
}
function Be(u) {
	let { databaseName: E, version: D } = u, O = Tu({ databaseName: E });
	return {
		api: xe({
			version: D,
			databaseInstance: O
		}),
		utils: re$1,
		database: O,
		standard: Ru[D]
	};
}
const useGlobalStore = defineStore("explorer/global", () => {
	let u = ref(""), E = computed(() => u.value ? Be({
		databaseName: u.value,
		version: "v2019C1"
	}) : null);
	async function D(E) {
		u.value = E;
	}
	return {
		activeFilename: u,
		sdkInstance: E,
		initApp: D
	};
});
var isClient$1 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
var noop$1 = () => {};
function computedAsync(u, E, D) {
	let O;
	O = isRef(D) ? { evaluating: D } : D || {};
	let { lazy: P = !1, flush: F = "pre", evaluating: I = void 0, shallow: R = !0, onError: U = globalThis.reportError ?? noop$1 } = O, J = shallowRef(!P), _p = R ? shallowRef(E) : ref(E), vp = 0;
	return watchEffect(async (E) => {
		if (!J.value) return;
		vp++;
		let D = vp, O = !1;
		I && Promise.resolve().then(() => {
			I.value = !0;
		});
		try {
			let P = await u((u) => {
				E(() => {
					I && (I.value = !1), O || u();
				});
			});
			D === vp && (_p.value = P);
		} catch (u) {
			U(u);
		} finally {
			I && D === vp && (I.value = !1), O = !0;
		}
	}, { flush: F }), P ? computed(() => (J.value = !0, _p.value)) : _p;
}
isClient$1 && window.document, isClient$1 && window.navigator, isClient$1 && window.location;
function serialize(u) {
	return typeof u == "string" ? `'${u}'` : new c$8().serialize(u);
}
var c$8 = /* @__PURE__ */ function() {
	class u {
		#t = /* @__PURE__ */ new Map();
		compare(u, E) {
			let D = typeof u, O = typeof E;
			return D === "string" && O === "string" ? u.localeCompare(E) : D === "number" && O === "number" ? u - E : String.prototype.localeCompare.call(this.serialize(u, !0), this.serialize(E, !0));
		}
		serialize(u, E) {
			if (u === null) return "null";
			switch (typeof u) {
				case "string": return E ? u : `'${u}'`;
				case "bigint": return `${u}n`;
				case "object": return this.$object(u);
				case "function": return this.$function(u);
			}
			return String(u);
		}
		serializeObject(u) {
			let E = Object.prototype.toString.call(u);
			if (E !== "[object Object]") return this.serializeBuiltInType(E.length < 10 ? `unknown:${E}` : E.slice(8, -1), u);
			let D = u.constructor, O = D === Object || D === void 0 ? "" : D.name;
			if (O !== "" && globalThis[O] === D) return this.serializeBuiltInType(O, u);
			if (typeof u.toJSON == "function") {
				let E = u.toJSON();
				return O + (typeof E == "object" && E ? this.$object(E) : `(${this.serialize(E)})`);
			}
			return this.serializeObjectEntries(O, Object.entries(u));
		}
		serializeBuiltInType(u, E) {
			let D = this["$" + u];
			if (D) return D.call(this, E);
			if (typeof E?.entries == "function") return this.serializeObjectEntries(u, E.entries());
			throw Error(`Cannot serialize ${u}`);
		}
		serializeObjectEntries(u, E) {
			let D = Array.from(E).sort((u, E) => this.compare(u[0], E[0])), O = `${u}{`;
			for (let u = 0; u < D.length; u++) {
				let [E, P] = D[u];
				O += `${this.serialize(E, !0)}:${this.serialize(P)}`, u < D.length - 1 && (O += ",");
			}
			return O + "}";
		}
		$object(u) {
			let E = this.#t.get(u);
			return E === void 0 && (this.#t.set(u, `#${this.#t.size}`), E = this.serializeObject(u), this.#t.set(u, E)), E;
		}
		$function(u) {
			let E = Function.prototype.toString.call(u);
			return E.slice(-15) === "[native code] }" ? `${u.name || ""}()[native]` : `${u.name}(${u.length})${E.replace(/\s*\n\s*/g, "")}`;
		}
		$Array(u) {
			let E = "[";
			for (let D = 0; D < u.length; D++) E += this.serialize(u[D]), D < u.length - 1 && (E += ",");
			return E + "]";
		}
		$Date(u) {
			try {
				return `Date(${u.toISOString()})`;
			} catch {
				return "Date(null)";
			}
		}
		$ArrayBuffer(u) {
			return `ArrayBuffer[${new Uint8Array(u).join(",")}]`;
		}
		$Set(u) {
			return `Set${this.$Array(Array.from(u).sort((u, E) => this.compare(u, E)))}`;
		}
		$Map(u) {
			return this.serializeObjectEntries("Map", u.entries());
		}
	}
	for (let E of [
		"Error",
		"RegExp",
		"URL"
	]) u.prototype["$" + E] = function(u) {
		return `${E}(${u})`;
	};
	for (let E of [
		"Int8Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"Int16Array",
		"Uint16Array",
		"Int32Array",
		"Uint32Array",
		"Float32Array",
		"Float64Array"
	]) u.prototype["$" + E] = function(u) {
		return `${E}[${u.join(",")}]`;
	};
	for (let E of ["BigInt64Array", "BigUint64Array"]) u.prototype["$" + E] = function(u) {
		return `${E}[${u.join("n,")}${u.length > 0 ? "n" : ""}]`;
	};
	return u;
}();
function isEqual(u, E) {
	return u === E || serialize(u) === serialize(E);
}
function findValuesBetween(u, E, D) {
	let O = u.findIndex((u) => isEqual(u, E)), P = u.findIndex((u) => isEqual(u, D));
	if (O === -1 || P === -1) return [];
	let [F, I] = [O, P].sort((u, E) => u - E);
	return u.slice(F, I + 1);
}
function createContext(u, E) {
	let D = typeof u == "string" && !E ? `${u}Context` : E, O = Symbol(D);
	return [(E) => {
		let D = inject(O, E);
		if (D || D === null) return D;
		throw Error(`Injection \`${O.toString()}\` not found. Component must be used within ${Array.isArray(u) ? `one of the following components: ${u.join(", ")}` : `\`${u}\``}`);
	}, (u) => (provide(O, u), u)];
}
function getActiveElement() {
	let u = document.activeElement;
	if (u == null) return null;
	for (; u != null && u.shadowRoot != null && u.shadowRoot.activeElement != null;) u = u.shadowRoot.activeElement;
	return u;
}
function handleAndDispatchCustomEvent(u, E, D) {
	let O = D.originalEvent.target, P = new CustomEvent(u, {
		bubbles: !1,
		cancelable: !0,
		detail: D
	});
	E && O.addEventListener(u, E, { once: !0 }), O.dispatchEvent(P);
}
function renderSlotFragments(u) {
	return u ? u.flatMap((u) => u.type === Fragment ? renderSlotFragments(u.children) : [u]) : [];
}
var [injectConfigProviderContext, provideConfigProviderContext] = createContext("ConfigProvider");
function tryOnScopeDispose(u) {
	return getCurrentScope() ? (onScopeDispose(u), !0) : !1;
}
function createEventHook() {
	let u = /* @__PURE__ */ new Set(), E = (E) => {
		u.delete(E);
	};
	return {
		on: (D) => {
			u.add(D);
			let O = () => E(D);
			return tryOnScopeDispose(O), { off: O };
		},
		off: E,
		trigger: (...E) => Promise.all(Array.from(u).map((u) => u(...E))),
		clear: () => {
			u.clear();
		}
	};
}
var isClient = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
var isDef = (u) => u !== void 0;
function refAutoReset(u, E = 1e4) {
	return customRef((D, O) => {
		let P = toValue(u), F, I = () => setTimeout(() => {
			P = toValue(u), O();
		}, toValue(E));
		return tryOnScopeDispose(() => {
			clearTimeout(F);
		}), {
			get() {
				return D(), P;
			},
			set(u) {
				P = u, O(), clearTimeout(F), F = I();
			}
		};
	});
}
isClient && window.document, isClient && window.navigator, isClient && window.location;
function unrefElement(u) {
	let E = toValue(u);
	return E?.$el ?? E;
}
function cloneFnJSON(u) {
	return JSON.parse(JSON.stringify(u));
}
function useVModel(u, E, D, O = {}) {
	let { clone: P = !1, passive: F = !1, eventName: I, deep: R = !1, defaultValue: U, shouldEmit: J } = O, _p = getCurrentInstance(), vp = D || _p?.emit || (_p?.$emit)?.bind(_p) || (_p?.proxy?.$emit)?.bind(_p?.proxy), yp = I;
	E ||= "modelValue", yp ||= `update:${E.toString()}`;
	let bp = (u) => P ? typeof P == "function" ? P(u) : cloneFnJSON(u) : u, xp = () => isDef(u[E]) ? bp(u[E]) : U, Sp = (u) => {
		J ? J(u) && vp(yp, u) : vp(yp, u);
	};
	if (F) {
		let D = ref(xp()), O = !1;
		return watch(() => u[E], (u) => {
			O || (O = !0, D.value = bp(u), nextTick(() => O = !1));
		}), watch(D, (D) => {
			!O && (D !== u[E] || R) && Sp(D);
		}, { deep: R }), D;
	} else return computed({
		get() {
			return xp();
		},
		set(u) {
			Sp(u);
		}
	});
}
function useDirection(u) {
	let E = injectConfigProviderContext({ dir: ref("ltr") });
	return computed(() => u?.value || E.dir?.value || "ltr");
}
var count = 0;
function useId(u, E = "reka") {
	if (u) return u;
	if ("useId" in vue_runtime_esm_bundler_exports) return `${E}-${useId$1?.()}`;
	let D = injectConfigProviderContext({ useId: void 0 });
	return D.useId ? `${E}-${D.useId()}` : `${E}-${++count}`;
}
function useSelectionBehavior(u, E) {
	let D = ref(), O = (O, P) => {
		if (E.multiple && Array.isArray(u.value)) if (E.selectionBehavior === "replace") u.value = [O], D.value = O;
		else {
			let E = u.value.findIndex((u) => P(u));
			E === -1 ? u.value = [...u.value, O] : u.value = u.value.filter((u, D) => D !== E);
		}
		else E.selectionBehavior === "replace" ? u.value = { ...O } : !Array.isArray(u.value) && P(u.value) ? u.value = void 0 : u.value = { ...O };
		return u.value;
	};
	function P(O, P, F, I) {
		if (!D?.value || !E.multiple || !Array.isArray(u.value)) return;
		let R = F().filter((u) => u.ref.dataset.disabled !== "").find((u) => u.ref === P)?.value;
		if (!R) return;
		let U = null;
		switch (O) {
			case "prev":
			case "next":
				U = findValuesBetween(I, D.value, R);
				break;
			case "first":
				U = findValuesBetween(I, D.value, I?.[0]);
				break;
			case "last":
				U = findValuesBetween(I, D.value, I?.[I.length - 1]);
				break;
		}
		u.value = U;
	}
	return {
		firstValue: D,
		onSelectItem: O,
		handleMultipleReplace: P
	};
}
function useTypeahead(u) {
	let E = refAutoReset("", 1e3);
	return {
		search: E,
		handleTypeaheadSearch: (D, O) => {
			if (E.value += D, u) u(D);
			else {
				let u = getActiveElement(), D = O.map((u) => ({
					...u,
					textValue: u.value?.textValue ?? u.ref.textContent?.trim() ?? ""
				})), P = D.find((E) => E.ref === u), F = getNextMatch(D.map((u) => u.textValue), E.value, P?.textValue), I = D.find((u) => u.textValue === F);
				return I && I.ref.focus(), I?.ref;
			}
		},
		resetTypeahead: () => {
			E.value = "";
		}
	};
}
function wrapArray$1(u, E) {
	return u.map((D, O) => u[(E + O) % u.length]);
}
function getNextMatch(u, E, D) {
	let O = E.length > 1 && Array.from(E).every((u) => u === E[0]) ? E[0] : E, P = D ? u.indexOf(D) : -1, F = wrapArray$1(u, Math.max(P, 0));
	O.length === 1 && (F = F.filter((u) => u !== D));
	let I = F.find((u) => u.toLowerCase().startsWith(O.toLowerCase()));
	return I === D ? void 0 : I;
}
var Slot = /* @__PURE__ */ defineComponent({
	name: "PrimitiveSlot",
	inheritAttrs: !1,
	setup(u, { attrs: E, slots: D }) {
		return () => {
			if (!D.default) return null;
			let u = renderSlotFragments(D.default()), O = u.findIndex((u) => u.type !== Comment);
			if (O === -1) return u;
			let P = u[O];
			delete P.props?.ref;
			let F = P.props ? mergeProps(E, P.props) : E, I = cloneVNode({
				...P,
				props: {}
			}, F);
			return u.length === 1 ? I : (u[O] = I, u);
		};
	}
}), SELF_CLOSING_TAGS = [
	"area",
	"img",
	"input"
], Primitive = /* @__PURE__ */ defineComponent({
	name: "Primitive",
	inheritAttrs: !1,
	props: {
		asChild: {
			type: Boolean,
			default: !1
		},
		as: {
			type: [String, Object],
			default: "div"
		}
	},
	setup(u, { attrs: E, slots: D }) {
		let O = u.asChild ? "template" : u.as;
		return typeof O == "string" && SELF_CLOSING_TAGS.includes(O) ? () => h$5(O, E) : O === "template" ? () => h$5(Slot, E, { default: D.default }) : () => h$5(u.as, E, { default: D.default });
	}
});
function usePrimitiveElement() {
	let u = ref();
	return {
		primitiveElement: u,
		currentElement: computed(() => ["#text", "#comment"].includes(u.value?.$el.nodeName) ? u.value?.$el.nextElementSibling : unrefElement(u))
	};
}
var ITEM_DATA_ATTR = "data-reka-collection-item";
function useCollection(u = {}) {
	let { key: E = "", isProvider: D = !1 } = u, O = `${E}CollectionProvider`, P;
	if (D) {
		let u = ref(/* @__PURE__ */ new Map());
		P = {
			collectionRef: ref(),
			itemMap: u
		}, provide(O, P);
	} else P = inject(O);
	let F = (u = !1) => {
		let E = P.collectionRef.value;
		if (!E) return [];
		let D = Array.from(E.querySelectorAll(`[${ITEM_DATA_ATTR}]`)), O = Array.from(P.itemMap.value.values()).sort((u, E) => D.indexOf(u.ref) - D.indexOf(E.ref));
		return u ? O : O.filter((u) => u.ref.dataset.disabled !== "");
	}, I = /* @__PURE__ */ defineComponent({
		name: "CollectionSlot",
		setup(u, { slots: E }) {
			let { primitiveElement: D, currentElement: O } = usePrimitiveElement();
			return watch(O, () => {
				P.collectionRef.value = O.value;
			}), () => h$5(Slot, { ref: D }, E);
		}
	}), R = /* @__PURE__ */ defineComponent({
		name: "CollectionItem",
		inheritAttrs: !1,
		props: { value: { validator: () => !0 } },
		setup(u, { slots: E, attrs: D }) {
			let { primitiveElement: O, currentElement: F } = usePrimitiveElement();
			return watchEffect((E) => {
				if (F.value) {
					let D = markRaw(F.value);
					P.itemMap.value.set(D, {
						ref: F.value,
						value: u.value
					}), E(() => P.itemMap.value.delete(D));
				}
			}), () => h$5(Slot, {
				...D,
				[ITEM_DATA_ATTR]: "",
				ref: O
			}, E);
		}
	});
	return {
		getItems: F,
		reactiveItems: computed(() => Array.from(P.itemMap.value.values())),
		itemMapSize: computed(() => P.itemMap.value.size),
		CollectionSlot: I,
		CollectionItem: R
	};
}
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus", EVENT_OPTIONS = {
	bubbles: !1,
	cancelable: !0
}, MAP_KEY_TO_FOCUS_INTENT = {
	ArrowLeft: "prev",
	ArrowUp: "prev",
	ArrowRight: "next",
	ArrowDown: "next",
	PageUp: "first",
	Home: "first",
	PageDown: "last",
	End: "last"
};
function getDirectionAwareKey(u, E) {
	return E === "rtl" ? u === "ArrowLeft" ? "ArrowRight" : u === "ArrowRight" ? "ArrowLeft" : u : u;
}
function getFocusIntent(u, E, D) {
	let O = getDirectionAwareKey(u.key, D);
	if (!(E === "vertical" && ["ArrowLeft", "ArrowRight"].includes(O)) && !(E === "horizontal" && ["ArrowUp", "ArrowDown"].includes(O))) return MAP_KEY_TO_FOCUS_INTENT[O];
}
function focusFirst(u, E = !1) {
	let D = getActiveElement();
	for (let O of u) if (O === D || (O.focus({ preventScroll: E }), getActiveElement() !== D)) return;
}
function wrapArray(u, E) {
	return u.map((D, O) => u[(E + O) % u.length]);
}
var [injectRovingFocusGroupContext, provideRovingFocusGroupContext] = createContext("RovingFocusGroup"), RovingFocusGroup_default = /* @__PURE__ */ defineComponent({
	__name: "RovingFocusGroup",
	props: {
		orientation: {
			type: String,
			required: !1,
			default: void 0
		},
		dir: {
			type: String,
			required: !1
		},
		loop: {
			type: Boolean,
			required: !1,
			default: !1
		},
		currentTabStopId: {
			type: [String, null],
			required: !1
		},
		defaultCurrentTabStopId: {
			type: String,
			required: !1
		},
		preventScrollOnEntryFocus: {
			type: Boolean,
			required: !1,
			default: !1
		},
		asChild: {
			type: Boolean,
			required: !1
		},
		as: {
			type: null,
			required: !1
		}
	},
	emits: ["entryFocus", "update:currentTabStopId"],
	setup(u, { expose: E, emit: D }) {
		let O = u, P = D, { loop: F, orientation: I, dir: R } = toRefs(O), U = useDirection(R), J = useVModel(O, "currentTabStopId", P, {
			defaultValue: O.defaultCurrentTabStopId,
			passive: O.currentTabStopId === void 0
		}), _p = ref(!1), vp = ref(!1), yp = ref(0), { getItems: bp, CollectionSlot: xp } = useCollection({ isProvider: !0 });
		function Sp(u) {
			let E = !vp.value;
			if (u.currentTarget && u.target === u.currentTarget && E && !_p.value) {
				let E = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
				if (u.currentTarget.dispatchEvent(E), P("entryFocus", E), !E.defaultPrevented) {
					let u = bp().map((u) => u.ref).filter((u) => u.dataset.disabled !== "");
					focusFirst([
						u.find((u) => u.getAttribute("data-active") === ""),
						u.find((u) => u.getAttribute("data-highlighted") === ""),
						u.find((u) => u.id === J.value),
						...u
					].filter(Boolean), O.preventScrollOnEntryFocus);
				}
			}
			vp.value = !1;
		}
		function Cp() {
			setTimeout(() => {
				vp.value = !1;
			}, 1);
		}
		return E({ getItems: bp }), provideRovingFocusGroupContext({
			loop: F,
			dir: U,
			orientation: I,
			currentTabStopId: J,
			onItemFocus: (u) => {
				J.value = u;
			},
			onItemShiftTab: () => {
				_p.value = !0;
			},
			onFocusableItemAdd: () => {
				yp.value++;
			},
			onFocusableItemRemove: () => {
				yp.value--;
			}
		}), (u, E) => (openBlock(), createBlock(unref(xp), null, {
			default: withCtx(() => [createVNode(unref(Primitive), {
				tabindex: _p.value || yp.value === 0 ? -1 : 0,
				"data-orientation": unref(I),
				as: u.as,
				"as-child": u.asChild,
				dir: unref(U),
				style: { outline: "none" },
				onMousedown: E[0] ||= (u) => vp.value = !0,
				onMouseup: Cp,
				onFocus: Sp,
				onBlur: E[1] ||= (u) => _p.value = !1
			}, {
				default: withCtx(() => [renderSlot(u.$slots, "default")]),
				_: 3
			}, 8, [
				"tabindex",
				"data-orientation",
				"as",
				"as-child",
				"dir"
			])]),
			_: 3
		}));
	}
}), RovingFocusItem_default = /* @__PURE__ */ defineComponent({
	__name: "RovingFocusItem",
	props: {
		tabStopId: {
			type: String,
			required: !1
		},
		focusable: {
			type: Boolean,
			required: !1,
			default: !0
		},
		active: {
			type: Boolean,
			required: !1
		},
		allowShiftKey: {
			type: Boolean,
			required: !1
		},
		asChild: {
			type: Boolean,
			required: !1
		},
		as: {
			type: null,
			required: !1,
			default: "span"
		}
	},
	setup(u) {
		let E = u, D = injectRovingFocusGroupContext(), O = useId(), P = computed(() => E.tabStopId || O), F = computed(() => D.currentTabStopId.value === P.value), { getItems: I, CollectionItem: R } = useCollection();
		onMounted(() => {
			E.focusable && D.onFocusableItemAdd();
		}), onUnmounted(() => {
			E.focusable && D.onFocusableItemRemove();
		});
		function U(u) {
			if (u.key === "Tab" && u.shiftKey) {
				D.onItemShiftTab();
				return;
			}
			if (u.target !== u.currentTarget) return;
			let O = getFocusIntent(u, D.orientation.value, D.dir.value);
			if (O !== void 0) {
				if (u.metaKey || u.ctrlKey || u.altKey || !E.allowShiftKey && u.shiftKey) return;
				u.preventDefault();
				let P = [...I().map((u) => u.ref).filter((u) => u.dataset.disabled !== "")];
				if (O === "last") P.reverse();
				else if (O === "prev" || O === "next") {
					O === "prev" && P.reverse();
					let E = P.indexOf(u.currentTarget);
					P = D.loop.value ? wrapArray(P, E + 1) : P.slice(E + 1);
				}
				nextTick(() => focusFirst(P));
			}
		}
		return (u, E) => (openBlock(), createBlock(unref(R), null, {
			default: withCtx(() => [createVNode(unref(Primitive), {
				tabindex: F.value ? 0 : -1,
				"data-orientation": unref(D).orientation.value,
				"data-active": u.active ? "" : void 0,
				"data-disabled": u.focusable ? void 0 : "",
				as: u.as,
				"as-child": u.asChild,
				onMousedown: E[0] ||= (E) => {
					u.focusable ? unref(D).onItemFocus(P.value) : E.preventDefault();
				},
				onFocus: E[1] ||= (u) => unref(D).onItemFocus(P.value),
				onKeydown: U
			}, {
				default: withCtx(() => [renderSlot(u.$slots, "default")]),
				_: 3
			}, 8, [
				"tabindex",
				"data-orientation",
				"data-active",
				"data-disabled",
				"as",
				"as-child"
			])]),
			_: 3
		}));
	}
});
function flatten(u) {
	return u.reduce((u, E) => (u.push(E), E.children && u.push(...flatten(E.children)), u), []);
}
var [injectTreeRootContext, provideTreeRootContext] = createContext("TreeRoot"), TreeRoot_default = /* @__PURE__ */ defineComponent({
	__name: "TreeRoot",
	props: {
		modelValue: {
			type: null,
			required: !1
		},
		defaultValue: {
			type: null,
			required: !1
		},
		items: {
			type: Array,
			required: !1
		},
		expanded: {
			type: Array,
			required: !1
		},
		defaultExpanded: {
			type: Array,
			required: !1
		},
		getKey: {
			type: Function,
			required: !0
		},
		getChildren: {
			type: Function,
			required: !1,
			default: (u) => u.children
		},
		selectionBehavior: {
			type: String,
			required: !1,
			default: "toggle"
		},
		multiple: {
			type: Boolean,
			required: !1,
			skipCheck: !0
		},
		dir: {
			type: String,
			required: !1
		},
		disabled: {
			type: Boolean,
			required: !1
		},
		propagateSelect: {
			type: Boolean,
			required: !1
		},
		bubbleSelect: {
			type: Boolean,
			required: !1
		},
		asChild: {
			type: Boolean,
			required: !1
		},
		as: {
			type: null,
			required: !1,
			default: "ul"
		}
	},
	emits: ["update:modelValue", "update:expanded"],
	setup(u, { emit: E }) {
		let D = u, O = E, { items: P, multiple: F, disabled: I, propagateSelect: R, dir: U, bubbleSelect: J } = toRefs(D), { handleTypeaheadSearch: _p } = useTypeahead(), vp = useDirection(U), yp = ref(), bp = ref(!1), xp = createEventHook(), Sp = useVModel(D, "modelValue", O, {
			defaultValue: D.defaultValue ?? (F.value ? [] : void 0),
			passive: !0,
			deep: !0
		}), Cp = useVModel(D, "expanded", O, {
			defaultValue: D.defaultExpanded ?? [],
			passive: D.expanded === void 0,
			deep: !0
		}), { onSelectItem: wp, handleMultipleReplace: Tp } = useSelectionBehavior(Sp, D), Ep = computed(() => F.value && Array.isArray(Sp.value) ? Sp.value.map((u) => D.getKey(u)) : [D.getKey(Sp.value ?? {})]);
		function Dp(u, E = 1, O) {
			return u.reduce((P, F, I) => {
				let R = D.getKey(F), U = D.getChildren(F), J = Cp.value.includes(R), _p = {
					_id: R,
					value: F,
					index: I,
					level: E,
					parentItem: O,
					hasChildren: !!U,
					bind: {
						value: F,
						level: E,
						"aria-setsize": u.length,
						"aria-posinset": I + 1
					}
				};
				return P.push(_p), U && J && P.push(...Dp(U, E + 1, F)), P;
			}, []);
		}
		let Op = computed(() => {
			let u = D.items;
			return Cp.value.map((u) => u), Dp(u ?? []);
		});
		function kp(u) {
			if (bp.value) xp.trigger(u);
			else {
				let E = yp.value?.getItems() ?? [];
				_p(u.key, E);
			}
		}
		function Ap(u) {
			if (bp.value) return;
			let E = MAP_KEY_TO_FOCUS_INTENT[u.key];
			nextTick(() => {
				Tp(E, getActiveElement(), yp.value?.getItems, Op.value.map((u) => u.value));
			});
		}
		function jp(u) {
			if (u.parentItem != null && Array.isArray(Sp.value) && D.multiple) {
				let E = Op.value.find((E) => u.parentItem != null && D.getKey(E.value) === D.getKey(u.parentItem));
				E != null && (D.getChildren(E.value)?.every((u) => Sp.value.find((E) => D.getKey(E) === D.getKey(u))) ? Sp.value = [...Sp.value, E.value] : Sp.value = Sp.value.filter((u) => D.getKey(u) !== D.getKey(E.value)), jp(E));
			}
		}
		return provideTreeRootContext({
			modelValue: Sp,
			selectedKeys: Ep,
			onSelect: (u) => {
				let E = (E) => D.getKey(E ?? {}) === D.getKey(u), O = D.multiple && Array.isArray(Sp.value) ? Sp.value?.findIndex(E) !== -1 : void 0;
				if (wp(u, E), D.bubbleSelect && D.multiple && Array.isArray(Sp.value)) {
					let E = Op.value.find((E) => D.getKey(E.value) === D.getKey(u));
					E != null && jp(E);
				}
				if (D.propagateSelect && D.multiple && Array.isArray(Sp.value)) {
					let E = flatten(D.getChildren(u) ?? []);
					O ? Sp.value = [...Sp.value].filter((u) => !E.some((E) => D.getKey(u ?? {}) === D.getKey(E))) : Sp.value = [...Sp.value, ...E];
				}
			},
			expanded: Cp,
			onToggle(u) {
				if (!(u && D.getChildren(u))) return;
				let E = D.getKey(u) ?? u;
				Cp.value.includes(E) ? Cp.value = Cp.value.filter((u) => u !== E) : Cp.value.push(E);
			},
			getKey: D.getKey,
			getChildren: D.getChildren,
			items: P,
			expandedItems: Op,
			disabled: I,
			multiple: F,
			dir: vp,
			propagateSelect: R,
			bubbleSelect: J,
			isVirtual: bp,
			virtualKeydownHook: xp,
			handleMultipleReplace: Tp
		}), (u, E) => (openBlock(), createBlock(unref(RovingFocusGroup_default), {
			ref_key: "rovingFocusGroupRef",
			ref: yp,
			"as-child": "",
			orientation: "vertical",
			dir: unref(vp)
		}, {
			default: withCtx(() => [createVNode(unref(Primitive), {
				role: "tree",
				as: u.as,
				"as-child": u.asChild,
				"aria-multiselectable": unref(F) ? !0 : void 0,
				onKeydown: [kp, withKeys(withModifiers(Ap, ["shift"]), ["up", "down"])]
			}, {
				default: withCtx(() => [renderSlot(u.$slots, "default", {
					flattenItems: Op.value,
					modelValue: unref(Sp),
					expanded: unref(Cp)
				})]),
				_: 3
			}, 8, [
				"as",
				"as-child",
				"aria-multiselectable",
				"onKeydown"
			])]),
			_: 3
		}, 8, ["dir"]));
	}
}), TREE_SELECT = "tree.select", TREE_TOGGLE = "tree.toggle", TreeItem_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: !1,
	__name: "TreeItem",
	props: {
		value: {
			type: null,
			required: !0
		},
		level: {
			type: Number,
			required: !0
		},
		asChild: {
			type: Boolean,
			required: !1
		},
		as: {
			type: null,
			required: !1,
			default: "li"
		}
	},
	emits: ["select", "toggle"],
	setup(u, { expose: E, emit: D }) {
		let O = u, P = D, F = injectTreeRootContext(), { getItems: I } = useCollection(), R = computed(() => !!F.getChildren(O.value)), U = computed(() => {
			let u = F.getKey(O.value);
			return F.expanded.value.includes(u);
		}), J = computed(() => {
			let u = F.getKey(O.value);
			return F.selectedKeys.value.includes(u);
		}), _p = computed(() => {
			if (F.bubbleSelect.value && R.value && Array.isArray(F.modelValue.value)) {
				let u = flatten(F.getChildren(O.value) || []);
				return u.some((u) => F.modelValue.value.find((E) => F.getKey(E) === F.getKey(u))) && !u.every((u) => F.modelValue.value.find((E) => F.getKey(E) === F.getKey(u)));
			} else if (F.propagateSelect.value && J.value && R.value && Array.isArray(F.modelValue.value)) return !flatten(F.getChildren(O.value) || []).every((u) => F.modelValue.value.find((E) => F.getKey(E) === F.getKey(u)));
			else return;
		});
		function vp(u) {
			if (R.value) if (U.value) {
				let u = I().map((u) => u.ref), E = getActiveElement(), D = u.indexOf(E), P = [...u].slice(D).find((u) => Number(u.getAttribute("data-indent")) === O.level + 1);
				P && P.focus();
			} else Cp(u);
		}
		function yp(u) {
			if (U.value) Cp(u);
			else {
				let u = I().map((u) => u.ref), E = getActiveElement(), D = u.indexOf(E), P = [...u].slice(0, D).reverse().find((u) => Number(u.getAttribute("data-indent")) === O.level - 1);
				P && P.focus();
			}
		}
		async function bp(u) {
			P("select", u), !u?.defaultPrevented && F.onSelect(O.value);
		}
		async function xp(u) {
			P("toggle", u), !u?.defaultPrevented && F.onToggle(O.value);
		}
		async function Sp(u) {
			u && handleAndDispatchCustomEvent(TREE_SELECT, bp, {
				originalEvent: u,
				value: O.value,
				isExpanded: U.value,
				isSelected: J.value
			});
		}
		async function Cp(u) {
			u && handleAndDispatchCustomEvent(TREE_TOGGLE, xp, {
				originalEvent: u,
				value: O.value,
				isExpanded: U.value,
				isSelected: J.value
			});
		}
		return E({
			isExpanded: U,
			isSelected: J,
			isIndeterminate: _p,
			handleToggle: () => F.onToggle(O.value),
			handleSelect: () => F.onSelect(O.value)
		}), (u, E) => (openBlock(), createBlock(unref(RovingFocusItem_default), {
			"as-child": "",
			value: u.value,
			"allow-shift-key": ""
		}, {
			default: withCtx(() => [createVNode(unref(Primitive), mergeProps(u.$attrs, {
				role: "treeitem",
				as: u.as,
				"as-child": u.asChild,
				"aria-selected": J.value,
				"aria-expanded": R.value ? U.value : void 0,
				"aria-level": u.level,
				"data-indent": u.level,
				"data-selected": J.value ? "" : void 0,
				"data-expanded": U.value ? "" : void 0,
				onKeydown: [
					withKeys(withModifiers(Sp, ["self", "prevent"]), ["enter", "space"]),
					E[0] ||= withKeys(withModifiers((u) => unref(F).dir.value === "ltr" ? vp(u) : yp(u), ["prevent"]), ["right"]),
					E[1] ||= withKeys(withModifiers((u) => unref(F).dir.value === "ltr" ? yp(u) : vp(u), ["prevent"]), ["left"])
				],
				onClick: E[2] ||= withModifiers((u) => {
					Sp(u), Cp(u);
				}, ["stop"])
			}), {
				default: withCtx(() => [renderSlot(u.$slots, "default", {
					isExpanded: U.value,
					isSelected: J.value,
					isIndeterminate: _p.value,
					handleSelect: () => unref(F).onSelect(u.value),
					handleToggle: () => unref(F).onToggle(u.value)
				})]),
				_: 3
			}, 16, [
				"as",
				"as-child",
				"aria-selected",
				"aria-expanded",
				"aria-level",
				"data-indent",
				"data-selected",
				"data-expanded",
				"onKeydown"
			])]),
			_: 3
		}, 8, ["value"]));
	}
});
function g(u) {
	return getCurrentScope() ? (onScopeDispose(u), !0) : !1;
}
var a$14 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
var f = Object.prototype.toString, y$2 = (u) => f.call(u) === "[object Object]", l$1 = () => {}, m = /* @__PURE__ */ w();
function w() {
	return a$14 && window?.navigator?.userAgent && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || window?.navigator?.maxTouchPoints > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function S(...u) {
	if (u.length !== 1) return toRef(...u);
	let E = u[0];
	return typeof E == "function" ? readonly(customRef(() => ({
		get: E,
		set: l$1
	}))) : ref(E);
}
function b(u) {
	return Array.isArray(u) ? u : [u];
}
function v(u, E, D) {
	return watch(u, E, {
		...D,
		immediate: !0
	});
}
var N = a$14 ? window : void 0;
function y$3(u) {
	let E = toValue(u);
	return E?.$el ?? E;
}
function k$1(...u) {
	let E = [], D = () => {
		E.forEach((u) => u()), E.length = 0;
	}, O = (u, E, D, O) => (u.addEventListener(E, D, O), () => u.removeEventListener(E, D, O)), P = computed(() => {
		let E = b(toValue(u[0])).filter((u) => u != null);
		return E.every((u) => typeof u != "string") ? E : void 0;
	}), F = v(() => [
		P.value?.map((u) => y$3(u)) ?? [N].filter((u) => u != null),
		b(toValue(P.value ? u[1] : u[0])),
		b(unref(P.value ? u[2] : u[1])),
		toValue(P.value ? u[3] : u[2])
	], ([u, P, F, I]) => {
		if (D(), !u?.length || !P?.length || !F?.length) return;
		let R = y$2(I) ? { ...I } : I;
		E.push(...u.flatMap((u) => P.flatMap((E) => F.map((D) => O(u, E, D, R)))));
	}, { flush: "post" });
	return g(D), () => {
		F(), D();
	};
}
function W(u) {
	return typeof Window < "u" && u instanceof Window ? u.document.documentElement : typeof Document < "u" && u instanceof Document ? u.documentElement : u;
}
function Y(u) {
	let E = window.getComputedStyle(u);
	if (E.overflowX === "scroll" || E.overflowY === "scroll" || E.overflowX === "auto" && u.clientWidth < u.scrollWidth || E.overflowY === "auto" && u.clientHeight < u.scrollHeight) return !0;
	{
		let E = u.parentNode;
		return !E || E.tagName === "BODY" ? !1 : Y(E);
	}
}
function X(u) {
	let E = u || window.event, D = E.target;
	return Y(D) ? !1 : E.touches.length > 1 ? !0 : (E.preventDefault && E.preventDefault(), !1);
}
var C$1 = /* @__PURE__ */ new WeakMap();
function q(u, E = !1) {
	let D = shallowRef(E), O = null, P = "";
	watch(S(u), (u) => {
		let E = W(toValue(u));
		if (E) {
			let u = E;
			if (C$1.get(u) || C$1.set(u, u.style.overflow), u.style.overflow !== "hidden" && (P = u.style.overflow), u.style.overflow === "hidden") return D.value = !0;
			if (D.value) return u.style.overflow = "hidden";
		}
	}, { immediate: !0 });
	let F = () => {
		let E = W(toValue(u));
		!E || D.value || (m && (O = k$1(E, "touchmove", (u) => {
			X(u);
		}, { passive: !1 })), E.style.overflow = "hidden", D.value = !0);
	}, I = () => {
		let E = W(toValue(u));
		!E || !D.value || (m && O?.(), E.style.overflow = P, C$1.delete(E), D.value = !1);
	};
	return g(I), computed({
		get() {
			return D.value;
		},
		set(u) {
			u ? F() : I();
		}
	});
}
function x$2() {
	let u = !1, E = shallowRef(!1);
	return (D, O) => {
		if (E.value = O.value, u) return;
		u = !0;
		let P = q(D, O.value);
		watch(E, (u) => P.value = u);
	};
}
x$2();
/**
* @license lucide-vue-next v0.545.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
var a$13 = (u) => u.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), s = (u) => u.replace(/^([A-Z])|[\s-_]+(\w)/g, (u, E, D) => D ? D.toUpperCase() : E.toLowerCase()), n = (u) => {
	let E = s(u);
	return E.charAt(0).toUpperCase() + E.slice(1);
}, c$7 = (...u) => u.filter((u, E, D) => !!u && u.trim() !== "" && D.indexOf(u) === E).join(" ").trim(), C = (u) => u === "", t$20 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: 24,
	height: 24,
	viewBox: "0 0 24 24",
	fill: "none",
	stroke: "currentColor",
	"stroke-width": 2,
	"stroke-linecap": "round",
	"stroke-linejoin": "round"
}, $ = ({ name: u, iconNode: E, absoluteStrokeWidth: D, "absolute-stroke-width": O, strokeWidth: P, "stroke-width": F, size: I = t$20.width, color: R = t$20.stroke,...U }, { slots: J }) => h$5("svg", {
	...t$20,
	...U,
	width: I,
	height: I,
	stroke: R,
	"stroke-width": C(D) || C(O) || D === !0 || O === !0 ? Number(P || F || t$20["stroke-width"]) * 24 / Number(I) : P || F || t$20["stroke-width"],
	class: c$7("lucide", U.class, ...u ? [`lucide-${a$13(n(u))}-icon`, `lucide-${a$13(u)}`] : ["lucide-icon"])
}, [...E.map((u) => h$5(...u)), ...J.default ? [J.default()] : []]), i$1 = (u, E) => (D, { slots: O, attrs: P }) => h$5($, {
	...P,
	...D,
	iconNode: E,
	name: u
}, O), e = i$1("activity", [["path", {
	d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",
	key: "169zse"
}]]), t = i$1("zap", [["path", {
	d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
	key: "1xq2db"
}]]), a = i$1("arrow-right", [["path", {
	d: "M5 12h14",
	key: "1ays0h"
}], ["path", {
	d: "m12 5 7 7-7 7",
	key: "xquz4c"
}]]), y = i$1("variable", [
	["path", {
		d: "M8 21s-4-3-4-9 4-9 4-9",
		key: "uto9ud"
	}],
	["path", {
		d: "M16 3s4 3 4 9-4 9-4 9",
		key: "4w2vsq"
	}],
	["line", {
		x1: "15",
		x2: "9",
		y1: "9",
		y2: "15",
		key: "f7djnv"
	}],
	["line", {
		x1: "9",
		x2: "15",
		y1: "9",
		y2: "15",
		key: "1shsy8"
	}]
]), r = i$1("square-pen", [["path", {
	d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7",
	key: "1m0v6g"
}], ["path", {
	d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",
	key: "ohrbg2"
}]]), x = i$1("hash", [
	["line", {
		x1: "4",
		x2: "20",
		y1: "9",
		y2: "9",
		key: "4lhtct"
	}],
	["line", {
		x1: "4",
		x2: "20",
		y1: "15",
		y2: "15",
		key: "vyu0kd"
	}],
	["line", {
		x1: "10",
		x2: "8",
		y1: "3",
		y2: "21",
		key: "1ggp8o"
	}],
	["line", {
		x1: "16",
		x2: "14",
		y1: "3",
		y2: "21",
		key: "weycgp"
	}]
]), a$1 = i$1("rotate-cw", [["path", {
	d: "M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8",
	key: "1p45f6"
}], ["path", {
	d: "M21 3v5h-5",
	key: "1q7to0"
}]]), i = i$1("timer", [
	["line", {
		x1: "10",
		x2: "14",
		y1: "2",
		y2: "2",
		key: "14vaq8"
	}],
	["line", {
		x1: "12",
		x2: "15",
		y1: "14",
		y2: "11",
		key: "17fdiu"
	}],
	["circle", {
		cx: "12",
		cy: "14",
		r: "8",
		key: "1e1u0o"
	}]
]), o = i$1("clock", [["path", {
	d: "M12 6v6l4 2",
	key: "mmk7yg"
}], ["circle", {
	cx: "12",
	cy: "12",
	r: "10",
	key: "1mglay"
}]]), t$1 = i$1("type", [
	["path", {
		d: "M12 4v16",
		key: "1654pz"
	}],
	["path", {
		d: "M4 7V5a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v2",
		key: "e0r10z"
	}],
	["path", {
		d: "M9 20h6",
		key: "s66wpe"
	}]
]), a$2 = i$1("terminal", [["path", {
	d: "M12 19h8",
	key: "baeox8"
}], ["path", {
	d: "m4 17 6-6-6-6",
	key: "1yngyt"
}]]), r$1 = i$1("toggle-right", [["circle", {
	cx: "15",
	cy: "12",
	r: "3",
	key: "1afu0r"
}], ["rect", {
	width: "20",
	height: "14",
	x: "2",
	y: "5",
	rx: "7",
	key: "g7kal2"
}]]), r$2 = i$1("users", [
	["path", {
		d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
		key: "1yyitq"
	}],
	["path", {
		d: "M16 3.128a4 4 0 0 1 0 7.744",
		key: "16gr8j"
	}],
	["path", {
		d: "M22 21v-2a4 4 0 0 0-3-3.87",
		key: "kshegd"
	}],
	["circle", {
		cx: "9",
		cy: "7",
		r: "4",
		key: "nufk8"
	}]
]), e$1 = i$1("building", [
	["path", {
		d: "M12 10h.01",
		key: "1nrarc"
	}],
	["path", {
		d: "M12 14h.01",
		key: "1etili"
	}],
	["path", {
		d: "M12 6h.01",
		key: "1vi96p"
	}],
	["path", {
		d: "M16 10h.01",
		key: "1m94wz"
	}],
	["path", {
		d: "M16 14h.01",
		key: "1gbofw"
	}],
	["path", {
		d: "M16 6h.01",
		key: "1x0f13"
	}],
	["path", {
		d: "M8 10h.01",
		key: "19clt8"
	}],
	["path", {
		d: "M8 14h.01",
		key: "6423bh"
	}],
	["path", {
		d: "M8 6h.01",
		key: "1dz90k"
	}],
	["path", {
		d: "M9 22v-3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3",
		key: "cabbwy"
	}],
	["rect", {
		x: "4",
		y: "2",
		width: "16",
		height: "20",
		rx: "2",
		key: "1uxh74"
	}]
]), r$3 = i$1("user-check", [
	["path", {
		d: "m16 11 2 2 4-4",
		key: "9rsbq5"
	}],
	["path", {
		d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
		key: "1yyitq"
	}],
	["circle", {
		cx: "9",
		cy: "7",
		r: "4",
		key: "nufk8"
	}]
]), r$4 = i$1("user", [["path", {
	d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",
	key: "975kel"
}], ["circle", {
	cx: "12",
	cy: "7",
	r: "4",
	key: "17ys0d"
}]]), h = i$1("network", [
	["rect", {
		x: "16",
		y: "16",
		width: "6",
		height: "6",
		rx: "1",
		key: "4q2zg0"
	}],
	["rect", {
		x: "2",
		y: "16",
		width: "6",
		height: "6",
		rx: "1",
		key: "8cvhb9"
	}],
	["rect", {
		x: "9",
		y: "2",
		width: "6",
		height: "6",
		rx: "1",
		key: "1egb70"
	}],
	["path", {
		d: "M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3",
		key: "1jsf9p"
	}],
	["path", {
		d: "M12 12V8",
		key: "2874zd"
	}]
]), a$3 = i$1("file-text", [
	["path", {
		d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",
		key: "1rqfz7"
	}],
	["path", {
		d: "M14 2v4a2 2 0 0 0 2 2h4",
		key: "tnqrlb"
	}],
	["path", {
		d: "M10 9H8",
		key: "b1mrlr"
	}],
	["path", {
		d: "M16 13H8",
		key: "t4e002"
	}],
	["path", {
		d: "M16 17H8",
		key: "z1uh3a"
	}]
]), r$5 = i$1("square", [["rect", {
	width: "18",
	height: "18",
	x: "3",
	y: "3",
	rx: "2",
	key: "afitv7"
}]]), e$2 = i$1("cpu", [
	["path", {
		d: "M12 20v2",
		key: "1lh1kg"
	}],
	["path", {
		d: "M12 2v2",
		key: "tus03m"
	}],
	["path", {
		d: "M17 20v2",
		key: "1rnc9c"
	}],
	["path", {
		d: "M17 2v2",
		key: "11trls"
	}],
	["path", {
		d: "M2 12h2",
		key: "1t8f8n"
	}],
	["path", {
		d: "M2 17h2",
		key: "7oei6x"
	}],
	["path", {
		d: "M2 7h2",
		key: "asdhe0"
	}],
	["path", {
		d: "M20 12h2",
		key: "1q8mjw"
	}],
	["path", {
		d: "M20 17h2",
		key: "1fpfkl"
	}],
	["path", {
		d: "M20 7h2",
		key: "1o8tra"
	}],
	["path", {
		d: "M7 20v2",
		key: "4gnj0m"
	}],
	["path", {
		d: "M7 2v2",
		key: "1i4yhu"
	}],
	["rect", {
		x: "4",
		y: "4",
		width: "16",
		height: "16",
		rx: "2",
		key: "1vbyd7"
	}],
	["rect", {
		x: "8",
		y: "8",
		width: "8",
		height: "8",
		rx: "1",
		key: "z9xiuo"
	}]
]), t$2 = i$1("circle-check-big", [["path", {
	d: "M21.801 10A10 10 0 1 1 17 3.335",
	key: "yps3ct"
}], ["path", {
	d: "m9 11 3 3L22 4",
	key: "1pflzl"
}]]), e$3 = i$1("tag", [["path", {
	d: "M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z",
	key: "vktsd0"
}], ["circle", {
	cx: "7.5",
	cy: "7.5",
	r: ".5",
	fill: "currentColor",
	key: "kqv944"
}]]), d = i$1("files", [
	["path", {
		d: "M15 2a2 2 0 0 1 1.414.586l4 4A2 2 0 0 1 21 8v7a2 2 0 0 1-2 2h-8a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z",
		key: "1vo8kb"
	}],
	["path", {
		d: "M15 2v4a2 2 0 0 0 2 2h4",
		key: "sud9ri"
	}],
	["path", {
		d: "M5 7a2 2 0 0 0-2 2v11a2 2 0 0 0 2 2h8a2 2 0 0 0 1.732-1",
		key: "l4dndm"
	}]
]), c = i$1("square-check-big", [["path", {
	d: "M21 10.656V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h12.344",
	key: "2acyp4"
}], ["path", {
	d: "m9 11 3 3L22 4",
	key: "1pflzl"
}]]), t$3 = i$1("gauge", [["path", {
	d: "m12 14 4-4",
	key: "9kzdfg"
}], ["path", {
	d: "M3.34 19a10 10 0 1 1 17.32 0",
	key: "19p75a"
}]]), c$1 = i$1("radio", [
	["path", {
		d: "M16.247 7.761a6 6 0 0 1 0 8.478",
		key: "1fwjs5"
	}],
	["path", {
		d: "M19.075 4.933a10 10 0 0 1 0 14.134",
		key: "ehdyv1"
	}],
	["path", {
		d: "M4.925 19.067a10 10 0 0 1 0-14.134",
		key: "1q22gi"
	}],
	["path", {
		d: "M7.753 16.239a6 6 0 0 1 0-8.478",
		key: "r2q7qm"
	}],
	["circle", {
		cx: "12",
		cy: "12",
		r: "2",
		key: "1c9p78"
	}]
]), h$1 = i$1("group", [
	["path", {
		d: "M3 7V5c0-1.1.9-2 2-2h2",
		key: "adw53z"
	}],
	["path", {
		d: "M17 3h2c1.1 0 2 .9 2 2v2",
		key: "an4l38"
	}],
	["path", {
		d: "M21 17v2c0 1.1-.9 2-2 2h-2",
		key: "144t0e"
	}],
	["path", {
		d: "M7 21H5c-1.1 0-2-.9-2-2v-2",
		key: "rtnfgi"
	}],
	["rect", {
		width: "7",
		height: "5",
		x: "7",
		y: "7",
		rx: "1",
		key: "1eyiv7"
	}],
	["rect", {
		width: "7",
		height: "5",
		x: "10",
		y: "12",
		rx: "1",
		key: "1qlmkx"
	}]
]), a$4 = i$1("gamepad-2", [
	["line", {
		x1: "6",
		x2: "10",
		y1: "11",
		y2: "11",
		key: "1gktln"
	}],
	["line", {
		x1: "8",
		x2: "8",
		y1: "9",
		y2: "13",
		key: "qnk9ow"
	}],
	["line", {
		x1: "15",
		x2: "15.01",
		y1: "12",
		y2: "12",
		key: "krot7o"
	}],
	["line", {
		x1: "18",
		x2: "18.01",
		y1: "10",
		y2: "10",
		key: "1lcuu1"
	}],
	["path", {
		d: "M17.32 5H6.68a4 4 0 0 0-3.978 3.59c-.006.052-.01.101-.017.152C2.604 9.416 2 14.456 2 16a3 3 0 0 0 3 3c1 0 1.5-.5 2-1l1.414-1.414A2 2 0 0 1 9.828 16h4.344a2 2 0 0 1 1.414.586L17 18c.5.5 1 1 2 1a3 3 0 0 0 3-3c0-1.545-.604-6.584-.685-7.258-.007-.05-.011-.1-.017-.151A4 4 0 0 0 17.32 5z",
		key: "mfqc10"
	}]
]), t$4 = i$1("upload", [
	["path", {
		d: "M12 3v12",
		key: "1x0j5s"
	}],
	["path", {
		d: "m17 8-5-5-5 5",
		key: "7q97r8"
	}],
	["path", {
		d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
		key: "ih7n3h"
	}]
]), t$5 = i$1("hand-platter", [
	["path", {
		d: "M12 3V2",
		key: "ar7q03"
	}],
	["path", {
		d: "m15.4 17.4 3.2-2.8a2 2 0 1 1 2.8 2.9l-3.6 3.3c-.7.8-1.7 1.2-2.8 1.2h-4c-1.1 0-2.1-.4-2.8-1.2l-1.302-1.464A1 1 0 0 0 6.151 19H5",
		key: "n2g93r"
	}],
	["path", {
		d: "M2 14h12a2 2 0 0 1 0 4h-2",
		key: "1o2jem"
	}],
	["path", {
		d: "M4 10h16",
		key: "img6z1"
	}],
	["path", {
		d: "M5 10a7 7 0 0 1 14 0",
		key: "1ega1o"
	}],
	["path", {
		d: "M5 14v6a1 1 0 0 1-1 1H2",
		key: "1hescx"
	}]
]), a$5 = i$1("list", [
	["path", {
		d: "M3 5h.01",
		key: "18ugdj"
	}],
	["path", {
		d: "M3 12h.01",
		key: "nlz23k"
	}],
	["path", {
		d: "M3 19h.01",
		key: "noohij"
	}],
	["path", {
		d: "M8 5h13",
		key: "1pao27"
	}],
	["path", {
		d: "M8 12h13",
		key: "1za7za"
	}],
	["path", {
		d: "M8 19h13",
		key: "m83p4d"
	}]
]), y$1 = i$1("server", [
	["rect", {
		width: "20",
		height: "8",
		x: "2",
		y: "2",
		rx: "2",
		ry: "2",
		key: "ngkwjq"
	}],
	["rect", {
		width: "20",
		height: "8",
		x: "2",
		y: "14",
		rx: "2",
		ry: "2",
		key: "iecqi9"
	}],
	["line", {
		x1: "6",
		x2: "6.01",
		y1: "6",
		y2: "6",
		key: "16zg32"
	}],
	["line", {
		x1: "6",
		x2: "6.01",
		y1: "18",
		y2: "18",
		key: "nzw8ys"
	}]
]), c$2 = i$1("shield", [["path", {
	d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
	key: "oel41y"
}]]), t$6 = i$1("external-link", [
	["path", {
		d: "M15 3h6v6",
		key: "1q9fwt"
	}],
	["path", {
		d: "M10 14 21 3",
		key: "gplh6r"
	}],
	["path", {
		d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
		key: "a6xqqp"
	}]
]), c$3 = i$1("shield-check", [["path", {
	d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
	key: "oel41y"
}], ["path", {
	d: "m9 12 2 2 4-4",
	key: "dzmm74"
}]]), t$7 = i$1("send", [["path", {
	d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
	key: "1ffxy3"
}], ["path", {
	d: "m21.854 2.147-10.94 10.939",
	key: "12cjpa"
}]]), c$4 = i$1("settings", [["path", {
	d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
	key: "1i5ecw"
}], ["circle", {
	cx: "12",
	cy: "12",
	r: "3",
	key: "1v7zrd"
}]]), t$8 = i$1("sliders-vertical", [
	["path", {
		d: "M10 8h4",
		key: "1sr2af"
	}],
	["path", {
		d: "M12 21v-9",
		key: "17s77i"
	}],
	["path", {
		d: "M12 8V3",
		key: "13r4qs"
	}],
	["path", {
		d: "M17 16h4",
		key: "h1uq16"
	}],
	["path", {
		d: "M19 12V3",
		key: "o1uvq1"
	}],
	["path", {
		d: "M19 21v-5",
		key: "qua636"
	}],
	["path", {
		d: "M3 14h4",
		key: "bcjad9"
	}],
	["path", {
		d: "M5 10V3",
		key: "cb8scm"
	}],
	["path", {
		d: "M5 21v-7",
		key: "1w1uti"
	}]
]), t$9 = i$1("database", [
	["ellipse", {
		cx: "12",
		cy: "5",
		rx: "9",
		ry: "3",
		key: "msslwz"
	}],
	["path", {
		d: "M3 5V19A9 3 0 0 0 21 19V5",
		key: "1wlel7"
	}],
	["path", {
		d: "M3 12A9 3 0 0 0 21 12",
		key: "mv7ke4"
	}]
]), e$4 = i$1("box", [
	["path", {
		d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",
		key: "hh9hay"
	}],
	["path", {
		d: "m3.3 7 8.7 5 8.7-5",
		key: "g66t2b"
	}],
	["path", {
		d: "M12 22V12",
		key: "d0xqtd"
	}]
]), t$10 = i$1("file-code", [
	["path", {
		d: "M10 12.5 8 15l2 2.5",
		key: "1tg20x"
	}],
	["path", {
		d: "m14 12.5 2 2.5-2 2.5",
		key: "yinavb"
	}],
	["path", {
		d: "M14 2v4a2 2 0 0 0 2 2h4",
		key: "tnqrlb"
	}],
	["path", {
		d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z",
		key: "1mlx9k"
	}]
]), t$11 = i$1("package", [
	["path", {
		d: "M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z",
		key: "1a0edw"
	}],
	["path", {
		d: "M12 22V12",
		key: "d0xqtd"
	}],
	["polyline", {
		points: "3.29 7 12 12 20.71 7",
		key: "ousv84"
	}],
	["path", {
		d: "m7.5 4.27 9 5.15",
		key: "1c824w"
	}]
]), t$12 = i$1("shield-alert", [
	["path", {
		d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
		key: "oel41y"
	}],
	["path", {
		d: "M12 8v4",
		key: "1got3b"
	}],
	["path", {
		d: "M12 16h.01",
		key: "1drbdi"
	}]
]), o$1 = i$1("folder-open", [["path", {
	d: "m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2",
	key: "usdka0"
}]]), l = i$1("layers", [
	["path", {
		d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",
		key: "zw3jo"
	}],
	["path", {
		d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",
		key: "1wduqc"
	}],
	["path", {
		d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",
		key: "kqbvx6"
	}]
]), a$6 = i$1("repeat", [
	["path", {
		d: "m17 2 4 4-4 4",
		key: "nntrym"
	}],
	["path", {
		d: "M3 11v-1a4 4 0 0 1 4-4h14",
		key: "84bu3i"
	}],
	["path", {
		d: "m7 22-4-4 4-4",
		key: "1wqhfi"
	}],
	["path", {
		d: "M21 13v1a4 4 0 0 1-4 4H3",
		key: "1rx37r"
	}]
]), t$13 = i$1("play", [["path", {
	d: "M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z",
	key: "10ikf1"
}]]), c$5 = i$1("lock", [["rect", {
	width: "18",
	height: "11",
	x: "3",
	y: "11",
	rx: "2",
	ry: "2",
	key: "1w4ew1"
}], ["path", {
	d: "M7 11V7a5 5 0 0 1 10 0v4",
	key: "fwvmzm"
}]]), e$5 = i$1("battery-charging", [
	["path", {
		d: "m11 7-3 5h4l-3 5",
		key: "b4a64w"
	}],
	["path", {
		d: "M14.856 6H16a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.935",
		key: "lre1cr"
	}],
	["path", {
		d: "M22 14v-4",
		key: "14q9d5"
	}],
	["path", {
		d: "M5.14 18H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h2.936",
		key: "13q5k0"
	}]
]), a$7 = i$1("link-2", [
	["path", {
		d: "M9 17H7A5 5 0 0 1 7 7h2",
		key: "8i5ue5"
	}],
	["path", {
		d: "M15 7h2a5 5 0 1 1 0 10h-2",
		key: "1b9ql8"
	}],
	["line", {
		x1: "8",
		x2: "16",
		y1: "12",
		y2: "12",
		key: "1jonct"
	}]
]), t$14 = i$1("link", [["path", {
	d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71",
	key: "1cjeqo"
}], ["path", {
	d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71",
	key: "19qd67"
}]]), e$6 = i$1("cable", [
	["path", {
		d: "M17 19a1 1 0 0 1-1-1v-2a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2a1 1 0 0 1-1 1z",
		key: "trhst0"
	}],
	["path", {
		d: "M17 21v-2",
		key: "ds4u3f"
	}],
	["path", {
		d: "M19 14V6.5a1 1 0 0 0-7 0v11a1 1 0 0 1-7 0V10",
		key: "1mo9zo"
	}],
	["path", {
		d: "M21 21v-2",
		key: "eo0ou"
	}],
	["path", {
		d: "M3 5V3",
		key: "1k5hjh"
	}],
	["path", {
		d: "M4 10a2 2 0 0 1-2-2V6a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2a2 2 0 0 1-2 2z",
		key: "1dd30t"
	}],
	["path", {
		d: "M7 5V3",
		key: "1t1388"
	}]
]), e$7 = i$1("arrow-up", [["path", {
	d: "m5 12 7-7 7 7",
	key: "hav0vg"
}], ["path", {
	d: "M12 19V5",
	key: "x0mq9r"
}]]), a$8 = i$1("arrow-up-right", [["path", {
	d: "M7 7h10v10",
	key: "1tivn9"
}], ["path", {
	d: "M7 17 17 7",
	key: "1vkiza"
}]]), t$15 = i$1("file", [["path", {
	d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",
	key: "1rqfz7"
}], ["path", {
	d: "M14 2v4a2 2 0 0 0 2 2h4",
	key: "tnqrlb"
}]]), a$9 = i$1("minus", [["path", {
	d: "M5 12h14",
	key: "1ays0h"
}]]), e$8 = i$1("tags", [
	["path", {
		d: "M13.172 2a2 2 0 0 1 1.414.586l6.71 6.71a2.4 2.4 0 0 1 0 3.408l-4.592 4.592a2.4 2.4 0 0 1-3.408 0l-6.71-6.71A2 2 0 0 1 6 9.172V3a1 1 0 0 1 1-1z",
		key: "16rjxf"
	}],
	["path", {
		d: "M2 7v6.172a2 2 0 0 0 .586 1.414l6.71 6.71a2.4 2.4 0 0 0 3.191.193",
		key: "178nd4"
	}],
	["circle", {
		cx: "10.5",
		cy: "6.5",
		r: ".5",
		fill: "currentColor",
		key: "12ikhr"
	}]
]), r$6 = i$1("arrow-down", [["path", {
	d: "M12 5v14",
	key: "s699le"
}], ["path", {
	d: "m19 12-7 7-7-7",
	key: "1idqje"
}]]), r$7 = i$1("git-branch", [
	["line", {
		x1: "6",
		x2: "6",
		y1: "3",
		y2: "15",
		key: "17qcm7"
	}],
	["circle", {
		cx: "18",
		cy: "6",
		r: "3",
		key: "1h7g24"
	}],
	["circle", {
		cx: "6",
		cy: "18",
		r: "3",
		key: "fqmcym"
	}],
	["path", {
		d: "M18 9a9 9 0 0 1-9 9",
		key: "n2h4wq"
	}]
]), a$10 = i$1("hard-drive", [
	["line", {
		x1: "22",
		x2: "2",
		y1: "12",
		y2: "12",
		key: "1y58io"
	}],
	["path", {
		d: "M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z",
		key: "oot6mr"
	}],
	["line", {
		x1: "6",
		x2: "6.01",
		y1: "16",
		y2: "16",
		key: "sgf278"
	}],
	["line", {
		x1: "10",
		x2: "10.01",
		y1: "16",
		y2: "16",
		key: "1l4acy"
	}]
]), o$2 = i$1("globe", [
	["circle", {
		cx: "12",
		cy: "12",
		r: "10",
		key: "1mglay"
	}],
	["path", {
		d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20",
		key: "13o1zl"
	}],
	["path", {
		d: "M2 12h20",
		key: "9i4pu4"
	}]
]), a$11 = i$1("key", [
	["path", {
		d: "m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4",
		key: "g0fldk"
	}],
	["path", {
		d: "m21 2-9.6 9.6",
		key: "1j0ho8"
	}],
	["circle", {
		cx: "7.5",
		cy: "15.5",
		r: "5.5",
		key: "yqb3hr"
	}]
]), a$12 = i$1("history", [
	["path", {
		d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",
		key: "1357e3"
	}],
	["path", {
		d: "M3 3v5h5",
		key: "1xhq8a"
	}],
	["path", {
		d: "M12 7v5l4 2",
		key: "1fdv2h"
	}]
]), t$16 = i$1("heading", [
	["path", {
		d: "M6 12h12",
		key: "8npq4p"
	}],
	["path", {
		d: "M6 20V4",
		key: "1w1bmo"
	}],
	["path", {
		d: "M18 20V4",
		key: "o2hl4u"
	}]
]), o$3 = i$1("folder", [["path", {
	d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z",
	key: "1kt360"
}]]), r$8 = i$1("git-fork", [
	["circle", {
		cx: "12",
		cy: "18",
		r: "3",
		key: "1mpf1b"
	}],
	["circle", {
		cx: "6",
		cy: "6",
		r: "3",
		key: "1lh9wr"
	}],
	["circle", {
		cx: "18",
		cy: "6",
		r: "3",
		key: "1h7g24"
	}],
	["path", {
		d: "M18 9v2c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V9",
		key: "1uq4wg"
	}],
	["path", {
		d: "M12 12v3",
		key: "158kv8"
	}]
]), k = i$1("user-cog", [
	["path", {
		d: "M10 15H6a4 4 0 0 0-4 4v2",
		key: "1nfge6"
	}],
	["path", {
		d: "m14.305 16.53.923-.382",
		key: "1itpsq"
	}],
	["path", {
		d: "m15.228 13.852-.923-.383",
		key: "eplpkm"
	}],
	["path", {
		d: "m16.852 12.228-.383-.923",
		key: "13v3q0"
	}],
	["path", {
		d: "m16.852 17.772-.383.924",
		key: "1i8mnm"
	}],
	["path", {
		d: "m19.148 12.228.383-.923",
		key: "1q8j1v"
	}],
	["path", {
		d: "m19.53 18.696-.382-.924",
		key: "vk1qj3"
	}],
	["path", {
		d: "m20.772 13.852.924-.383",
		key: "n880s0"
	}],
	["path", {
		d: "m20.772 16.148.924.383",
		key: "1g6xey"
	}],
	["circle", {
		cx: "18",
		cy: "15",
		r: "3",
		key: "gjjjvw"
	}],
	["circle", {
		cx: "9",
		cy: "7",
		r: "4",
		key: "nufk8"
	}]
]), c$6 = i$1("square-function", [
	["rect", {
		width: "18",
		height: "18",
		x: "3",
		y: "3",
		rx: "2",
		ry: "2",
		key: "1m3agn"
	}],
	["path", {
		d: "M9 17c2 0 2.8-1 2.8-2.8V10c0-2 1-3.3 3.2-3",
		key: "m1af9g"
	}],
	["path", {
		d: "M9 11.2h5.7",
		key: "3zgcl2"
	}]
]), d$1 = i$1("list-ordered", [
	["path", {
		d: "M11 5h10",
		key: "1cz7ny"
	}],
	["path", {
		d: "M11 12h10",
		key: "1438ji"
	}],
	["path", {
		d: "M11 19h10",
		key: "11t30w"
	}],
	["path", {
		d: "M4 4h1v5",
		key: "10yrso"
	}],
	["path", {
		d: "M4 9h2",
		key: "r1h2o0"
	}],
	["path", {
		d: "M6.5 20H3.4c0-1 2.6-1.925 2.6-3.5a1.5 1.5 0 0 0-2.6-1.02",
		key: "xtkcd5"
	}]
]), t$17 = i$1("table-2", [["path", {
	d: "M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18",
	key: "gugj83"
}]]), h$2 = i$1("layout-template", [
	["rect", {
		width: "18",
		height: "7",
		x: "3",
		y: "3",
		rx: "1",
		key: "f1a2em"
	}],
	["rect", {
		width: "9",
		height: "7",
		x: "3",
		y: "14",
		rx: "1",
		key: "jqznyg"
	}],
	["rect", {
		width: "5",
		height: "7",
		x: "16",
		y: "14",
		rx: "1",
		key: "q5h2i8"
	}]
]), h$3 = i$1("table", [
	["path", {
		d: "M12 3v18",
		key: "108xh3"
	}],
	["rect", {
		width: "18",
		height: "18",
		x: "3",
		y: "3",
		rx: "2",
		key: "afitv7"
	}],
	["path", {
		d: "M3 9h18",
		key: "1pudct"
	}],
	["path", {
		d: "M3 15h18",
		key: "5xshup"
	}]
]), x$1 = i$1("gamepad", [
	["line", {
		x1: "6",
		x2: "10",
		y1: "12",
		y2: "12",
		key: "161bw2"
	}],
	["line", {
		x1: "8",
		x2: "8",
		y1: "10",
		y2: "14",
		key: "1i6ji0"
	}],
	["line", {
		x1: "15",
		x2: "15.01",
		y1: "13",
		y2: "13",
		key: "dqpgro"
	}],
	["line", {
		x1: "18",
		x2: "18.01",
		y1: "11",
		y2: "11",
		key: "meh2c"
	}],
	["rect", {
		width: "20",
		height: "12",
		x: "2",
		y: "6",
		rx: "2",
		key: "9lu3g6"
	}]
]), p = i$1("plug-zap", [
	["path", {
		d: "M6.3 20.3a2.4 2.4 0 0 0 3.4 0L12 18l-6-6-2.3 2.3a2.4 2.4 0 0 0 0 3.4Z",
		key: "goz73y"
	}],
	["path", {
		d: "m2 22 3-3",
		key: "19mgm9"
	}],
	["path", {
		d: "M7.5 13.5 10 11",
		key: "7xgeeb"
	}],
	["path", {
		d: "M10.5 16.5 13 14",
		key: "10btkg"
	}],
	["path", {
		d: "m18 3-4 4h6l-4 4",
		key: "16psg9"
	}]
]), t$18 = i$1("wifi", [
	["path", {
		d: "M12 20h.01",
		key: "zekei9"
	}],
	["path", {
		d: "M2 8.82a15 15 0 0 1 20 0",
		key: "dnpr2z"
	}],
	["path", {
		d: "M5 12.859a10 10 0 0 1 14 0",
		key: "1x1e6c"
	}],
	["path", {
		d: "M8.5 16.429a5 5 0 0 1 7 0",
		key: "1bycff"
	}]
]), h$4 = i$1("binary", [
	["rect", {
		x: "14",
		y: "14",
		width: "4",
		height: "6",
		rx: "2",
		key: "p02svl"
	}],
	["rect", {
		x: "6",
		y: "4",
		width: "4",
		height: "6",
		rx: "2",
		key: "xm4xkj"
	}],
	["path", {
		d: "M6 20h4",
		key: "1i6q5t"
	}],
	["path", {
		d: "M14 10h4",
		key: "ru81e7"
	}],
	["path", {
		d: "M6 14h2v6",
		key: "16z9wg"
	}],
	["path", {
		d: "M14 4h2v6",
		key: "1idq9u"
	}]
]), r$9 = i$1("layout-grid", [
	["rect", {
		width: "7",
		height: "7",
		x: "3",
		y: "3",
		rx: "1",
		key: "1g98yp"
	}],
	["rect", {
		width: "7",
		height: "7",
		x: "14",
		y: "3",
		rx: "1",
		key: "6d4xhi"
	}],
	["rect", {
		width: "7",
		height: "7",
		x: "14",
		y: "14",
		rx: "1",
		key: "nxv5o0"
	}],
	["rect", {
		width: "7",
		height: "7",
		x: "3",
		y: "14",
		rx: "1",
		key: "1bb6yr"
	}]
]), o$4 = i$1("columns-2", [["rect", {
	width: "18",
	height: "18",
	x: "3",
	y: "3",
	rx: "2",
	key: "afitv7"
}], ["path", {
	d: "M12 3v18",
	key: "108xh3"
}]]), p$1 = i$1("app-window", [
	["rect", {
		x: "2",
		y: "4",
		width: "20",
		height: "16",
		rx: "2",
		key: "izxlao"
	}],
	["path", {
		d: "M10 4v4",
		key: "pp8u80"
	}],
	["path", {
		d: "M2 8h20",
		key: "d11cs7"
	}],
	["path", {
		d: "M6 4v4",
		key: "1svtjw"
	}]
]), e$9 = i$1("map-pin", [["path", {
	d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
	key: "1r0f0z"
}], ["circle", {
	cx: "12",
	cy: "10",
	r: "3",
	key: "ilqhr7"
}]]), re = {
	AccessControl: c$3,
	AccessPoint: i$1("plug", [
		["path", {
			d: "M12 22v-5",
			key: "1ega77"
		}],
		["path", {
			d: "M9 8V2",
			key: "14iosj"
		}],
		["path", {
			d: "M15 8V2",
			key: "18g5xt"
		}],
		["path", {
			d: "M18 8v5a4 4 0 0 1-4 4h-4a4 4 0 0 1-4-4V8Z",
			key: "osxo6l"
		}]
	]),
	Address: e$9,
	AllocationRole: k,
	AllocationRoleRef: r$3,
	AnalogueWiringParameters: e,
	AnalogueWiringParametersRef: e,
	Application: p$1,
	ApplicationSclRef: t$6,
	Association: t$14,
	Authentication: a$11,
	BDA: t$9,
	Bay: o$4,
	BayType: r$9,
	BehaviorDescription: a$3,
	BehaviorDescriptionRef: a$3,
	BehaviorReference: a,
	BinaryWiringParameters: h$4,
	BinaryWiringParametersRef: h$4,
	BitRate: t$3,
	CheckoutID: t$2,
	ClientLN: r$2,
	ClientServices: y$1,
	CommProt: c$2,
	Communication: t$18,
	CommunicationServiceSpecifications: h,
	ConductingEquipment: t,
	ConfDataSet: c$4,
	ConfLNs: c$4,
	ConfLdName: c$4,
	ConfLogControl: c$4,
	ConfReportControl: c$4,
	ConfSG: c$4,
	ConfSigRef: c$4,
	ConnectedAP: p,
	ConnectivityNode: r$7,
	ControlRef: a$4,
	ControllingLNode: x$1,
	DA: t$9,
	DAI: t$9,
	DAS: t$9,
	DAType: l,
	DO: e$4,
	DOI: e$4,
	DOS: e$4,
	DOType: l,
	DataObjectDirectory: o$3,
	DataSet: h$3,
	DataSetDirectory: o$1,
	DataTypeTemplates: h$2,
	DynAssociation: a$7,
	DynDataSet: t$17,
	EnumType: a$5,
	EnumVal: d$1,
	EqFunction: c$6,
	EqSubFunction: r$5,
	ExtCtrl: t$6,
	ExtRef: a$8,
	FCDA: t$9,
	FileHandling: t$15,
	Function: c$6,
	FunctionCatRef: e$3,
	FunctionCategory: e$3,
	FunctionCategoryRef: e$3,
	FunctionRef: a,
	FunctionRole: k,
	FunctionRoleContent: r$4,
	FunctionSclRef: t$6,
	FunctionTemplate: a$3,
	FunctionalSubVariant: r$7,
	FunctionalVariant: r$8,
	FunctionalVariantGroup: h$1,
	FunctionalVariantRef: a,
	GOOSE: t$7,
	GOOSEMcSecurity: c$3,
	GOOSESecurity: c$2,
	GSE: t$7,
	GSEControl: a$4,
	GSEDir: o$3,
	GSESettings: c$4,
	GSSE: t$7,
	GeneralEquipment: e$2,
	GetCBValues: t$4,
	GetDataObjectDefinition: t$4,
	GetDataSetValue: t$4,
	GetDirectory: o$1,
	GooseParameters: t$8,
	GooseParametersRef: t$8,
	Header: t$16,
	History: a$12,
	Hitem: o,
	IED: e$2,
	IEDName: e$3,
	IEDSourceFiles: d,
	InputVar: r$6,
	InputVarRef: a$8,
	Inputs: r$6,
	IssuerName: r$4,
	KDC: a$11,
	L2CommParameters: h,
	L3IPv4CommParameters: o$2,
	L3IPv6CommParameters: o$2,
	LDevice: a$10,
	LN: e$4,
	LN0: r$5,
	LNode: r$7,
	LNodeDataRef: a,
	LNodeInputRef: a$8,
	LNodeInputs: r$6,
	LNodeOutputRef: a$8,
	LNodeOutputs: e$7,
	LNodeSpecNaming: e$3,
	LNodeType: l,
	Label: e$3,
	Labels: e$8,
	Line: a$9,
	Log: a$3,
	LogControl: a$4,
	LogParameters: t$8,
	LogParametersRef: t$8,
	LogSettings: c$4,
	MaxTime: o,
	McSecurity: c$2,
	MinRequestedSCDFile: t$15,
	MinRequestedSCDFiles: d,
	MinTime: o,
	MultiAPPerSubNet: h,
	NeutralPoint: r$5,
	OptFields: c,
	OutputVar: e$7,
	OutputVarRef: a$8,
	Outputs: e$7,
	P: t$1,
	PhysConn: e$6,
	PowerSystemRelation: t$14,
	PowerSystemRelationRef: a,
	PowerSystemRelations: a$7,
	PowerTransformer: e$5,
	Private: c$5,
	Process: t$13,
	ProcessEcho: a$6,
	ProcessResource: e$2,
	ProcessResourceRef: a,
	ProcessResources: l,
	Project: o$1,
	ProjectProcessReference: a,
	ProtNs: c$2,
	Protocol: h,
	ReadWrite: r,
	RedProt: t$12,
	ReportControl: a$4,
	ReportParameters: t$8,
	ReportParametersRef: t$8,
	ReportSettings: c$4,
	Resource: t$11,
	RptEnabled: r$1,
	SCL: t$10,
	SCSM: c$2,
	SDI: t$9,
	SDO: e$4,
	SDS: t$9,
	SGEdit: r,
	SMV: t$7,
	SMVParameters: t$8,
	SMVParametersRef: t$8,
	SMVSecurity: c$2,
	SMVSettings: c$4,
	SMVsc: t$7,
	SVMcSecurity: c$3,
	SampledValueControl: a$4,
	SamplesPerSec: t$3,
	SclFileReference: t$6,
	SecPerSamples: o,
	Security: c$2,
	Server: y$1,
	ServerAt: y$1,
	ServiceSpecifications: a$5,
	Services: t$5,
	SetDataSetValue: t$4,
	SettingControl: a$4,
	SettingGroups: h$1,
	SignalRole: c$1,
	SmpRate: t$3,
	SmvOpts: c,
	SourceFiles: d,
	SourceRef: a,
	SubCategory: e$3,
	SubCheckoutID: t$2,
	SubEquipment: e$2,
	SubFunction: r$5,
	SubFunctionTemplate: a$3,
	SubNetwork: h,
	Subject: r$4,
	SubscriberLNode: r$3,
	Substation: e$1,
	SupSubscription: r$2,
	TapChanger: r$1,
	Terminal: a$2,
	Text: t$1,
	TimeSyncProt: o,
	TimerActivatedControl: i,
	TransformerWinding: a$1,
	TrgOps: t,
	Val: x,
	ValueHandling: r,
	Variable: y,
	VariableApplyTo: a,
	VariableRef: a,
	Voltage: t,
	VoltageLevel: e
}, _hoisted_1$1 = { class: "pl-2" }, element_tree_default = /* @__PURE__ */ defineComponent({
	__name: "element-tree",
	setup(u) {
		let { sdkInstance: E } = storeToRefs(useGlobalStore()), D = computedAsync(async () => {
			let u = await E.value?.api.fromRoot().getChildren();
			if (!u) return [];
			function D(u) {
				return {
					tag: u.tagName,
					id: u.id,
					...u.treeChildren.length && { children: u.treeChildren.map((u) => D(u)) }
				};
			}
			return [D(u)];
		}), O = computed(() => D.value?.find((u) => u.tag === "SCL")?.id);
		return (u, E) => O.value ? (openBlock(), createBlock(unref(TreeRoot_default), {
			key: 0,
			class: "list-none select-none w-full text-stone-700 p-2 text-sm font-medium",
			items: unref(D),
			"get-key": (u) => u.id,
			"default-expanded": [O.value]
		}, {
			default: withCtx(({ flattenItems: u }) => [(openBlock(!0), createElementBlock(Fragment, null, renderList(u, (u) => (openBlock(), createBlock(unref(TreeItem_default), mergeProps({
				key: u.value.id,
				style: { "padding-left": `${u.level - .5}rem` }
			}, { ref_for: !0 }, u.bind, { class: "flex items-center py-1 px-2 my-0.5 rounded outline-none focus:ring-grass8 focus:ring-2 data-[selected]:bg-grass4" }), {
				default: withCtx(() => [unref(re)[u.value.tag] ? (openBlock(), createBlock(resolveDynamicComponent(unref(re)[u.value.tag]), {
					key: 0,
					class: "h-4 w-4"
				})) : createCommentVNode("", !0), createBaseVNode("div", _hoisted_1$1, toDisplayString(u.value.tag), 1)]),
				_: 2
			}, 1040, ["style"]))), 128))]),
			_: 1
		}, 8, [
			"items",
			"get-key",
			"default-expanded"
		])) : createCommentVNode("", !0);
	}
}), _hoisted_1 = { class: "overflow-auto h-full" }, _hoisted_2 = { class: "pb-5" }, app_default = /* @__PURE__ */ defineComponent({
	__name: "app",
	props: { api: {} },
	setup(u) {
		let E = u, D = useGlobalStore(), O = ref();
		return onMounted(() => {
			O.value = E.api.activeFileName.subscribe((u) => {
				u && D.initApp(u);
			}), E.api.activeFileName.value && D.initApp(E.api.activeFileName.value);
		}), onUnmounted(() => {
			O.value?.();
		}), (u, E) => (openBlock(), createElementBlock("article", _hoisted_1, [createBaseVNode("div", _hoisted_2, [createVNode(element_tree_default)])]));
	}
});
function start(u, E) {
	if (!document.getElementById(u)) {
		console.error({
			msg: "could not found root element",
			rootId: u
		});
		return;
	}
	let D = createApp(app_default, { api: E });
	return D.use(createPinia()), D.mount(`#${u}`), D.unmount;
}
export { start as default };
