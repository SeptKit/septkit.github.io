(function(){try{if(typeof document<`u`){var e=document.createElement(`style`);e.appendChild(document.createTextNode(`/*! tailwindcss v4.1.14 | MIT License | https://tailwindcss.com */
@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-font-weight:initial;--tw-outline-style:solid;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-stone-700:#44403b;--spacing:.25rem;--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--font-weight-medium:500;--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}@supports (color:lab(0% 0 0)){:root,:host{--color-stone-700:lab(27.3812% 1.32917 3.57789)}}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;-webkit-text-decoration:inherit;-webkit-text-decoration:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab, red, red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E");scrollbar-color:currentColor #0000}@supports (color:color-mix(in lab, red, red)){:root{scrollbar-color:color-mix(in oklch,currentColor 35%,#0000)#0000}}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab, red, red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),lab(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}@supports (width:if(else: 1px)) and (animation-timeline:scroll()){:root{animation:forwards set-page-has-scroll;animation-timeline:scroll()}@keyframes set-page-has-scroll{0%,to{--page-has-scroll:1}}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:if(style(--page-has-scroll: 1): stable; else: unset)}}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:where(:root),[data-theme=ocean-light]{--lightningcss-light:initial;--lightningcss-dark: ;color-scheme:light;--color-base-100:#f8f8f8;--color-base-200:#f5f5f5;--color-base-300:#e4e4e4;--color-base-content:#404040;--color-primary:#258998;--color-primary-content:#fff;--color-secondary:#4b9eaa;--color-secondary-content:#fff;--color-accent:#009588;--color-accent-content:#f8f8f8;--color-neutral:#78706a;--color-neutral-content:#f5fce5;--color-info:#50a0ff;--color-info-content:#f8f8f8;--color-success:#00c657;--color-success-content:#f8f8f8;--color-warning:#fdcf2b;--color-warning-content:#f8f8f8;--color-error:#f82834;--color-error-content:#f8f8f8;--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-300)}@supports (color:lab(0% 0 0)){:where(:root),[data-theme=ocean-light]{--color-base-100:lab(97.68% -.0000298023 .0000119209);--color-base-200:lab(96.52% -.0000298023 0);--color-base-300:lab(90.72% .0000298023 -.0000119209);--color-base-content:lab(26.92% 0 -.00000596046);--color-primary:lab(52.1182% -25.1013 -16.6644);--color-primary-content:lab(100% 0 0);--color-secondary:lab(60.3471% -23.6405 -14.4068);--color-secondary-content:lab(100% 0 0);--color-accent:lab(55.0223% -41.0774 -3.90277);--color-accent-content:lab(97.6886% -.0991523 .364268);--color-neutral:lab(47.7684% 2.35736 4.26879);--color-neutral-content:lab(98.0078% -5.32481 10.2158);--color-info:lab(64.2164% -1.27971 -56.9629);--color-info-content:lab(97.6886% -.0991523 .364268);--color-success:lab(70.2031% -66.5285 45.8378);--color-success-content:lab(97.6886% -.0991523 .364268);--color-warning:lab(85.3669% 6.20878 78.7667);--color-warning-content:lab(97.6886% -.0991523 .364268);--color-error:lab(54.6666% 75.0951 49.1053);--color-error-content:lab(97.6886% -.0991523 .364268)}}:root:has(input.theme-controller[value=ocean-light]:checked){--lightningcss-light:initial;--lightningcss-dark: ;color-scheme:light;--color-base-100:#f8f8f8;--color-base-200:#f5f5f5;--color-base-300:#e4e4e4;--color-base-content:#404040;--color-primary:#258998;--color-primary-content:#fff;--color-secondary:#4b9eaa;--color-secondary-content:#fff;--color-accent:#009588;--color-accent-content:#f8f8f8;--color-neutral:#78706a;--color-neutral-content:#f5fce5;--color-info:#50a0ff;--color-info-content:#f8f8f8;--color-success:#00c657;--color-success-content:#f8f8f8;--color-warning:#fdcf2b;--color-warning-content:#f8f8f8;--color-error:#f82834;--color-error-content:#f8f8f8;--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-300)}@supports (color:lab(0% 0 0)){:root:has(input.theme-controller[value=ocean-light]:checked){--color-base-100:lab(97.68% -.0000298023 .0000119209);--color-base-200:lab(96.52% -.0000298023 0);--color-base-300:lab(90.72% .0000298023 -.0000119209);--color-base-content:lab(26.92% 0 -.00000596046);--color-primary:lab(52.1182% -25.1013 -16.6644);--color-primary-content:lab(100% 0 0);--color-secondary:lab(60.3471% -23.6405 -14.4068);--color-secondary-content:lab(100% 0 0);--color-accent:lab(55.0223% -41.0774 -3.90277);--color-accent-content:lab(97.6886% -.0991523 .364268);--color-neutral:lab(47.7684% 2.35736 4.26879);--color-neutral-content:lab(98.0078% -5.32481 10.2158);--color-info:lab(64.2164% -1.27971 -56.9629);--color-info-content:lab(97.6886% -.0991523 .364268);--color-success:lab(70.2031% -66.5285 45.8378);--color-success-content:lab(97.6886% -.0991523 .364268);--color-warning:lab(85.3669% 6.20878 78.7667);--color-warning-content:lab(97.6886% -.0991523 .364268);--color-error:lab(54.6666% 75.0951 49.1053);--color-error-content:lab(97.6886% -.0991523 .364268)}}}@layer components;@layer utilities{.my-0\\.5{margin-block:calc(var(--spacing)*.5)}.flex{display:flex}.h-4{height:calc(var(--spacing)*4)}.h-full{height:100%}.w-4{width:calc(var(--spacing)*4)}.w-full{width:100%}.list-none{list-style-type:none}.items-center{align-items:center}.overflow-auto{overflow:auto}.rounded{border-radius:.25rem}.p-2{padding:calc(var(--spacing)*2)}.px-2{padding-inline:calc(var(--spacing)*2)}.py-1{padding-block:calc(var(--spacing)*1)}.pb-5{padding-bottom:calc(var(--spacing)*5)}.pl-2{padding-left:calc(var(--spacing)*2)}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.text-stone-700{color:var(--color-stone-700)}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.outline-none{--tw-outline-style:none;outline-style:none}.select-none{-webkit-user-select:none;user-select:none}.focus\\:ring-2:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}}:root{--color-ocean-gray-00:#fff;--color-ocean-gray-25:#fafbfb;--color-ocean-gray-50:#f5f6f7;--color-ocean-gray-75:#eaeeef;--color-ocean-gray-100:#e1e4e6;--color-ocean-gray-150:#c6ced1;--color-ocean-gray-200:#bac1c4;--color-ocean-gray-250:#9fadb2;--color-ocean-gray-300:#889499;--color-ocean-gray-350:#72858c;--color-ocean-gray-400:#617177;--color-ocean-gray-450:#3f555e;--color-ocean-gray-500:#394d55;--color-ocean-gray-550:#34464d;--color-ocean-gray-600:#2e3e44;--color-ocean-gray-650:#27353b;--color-ocean-gray-700:#222e33;--color-ocean-gray-750:#1f272b;--color-ocean-gray-800:#171f22;--color-ocean-gray-850:#11171a;--color-ocean-gray-900:#0b0f11;--color-chart-1:#f7931e;--color-chart-2:#40535b;--color-chart-3:#2798aa;--color-chart-4:#6da89c;--color-chart-5:#a4cadd;--color-chart-6:#97b42d;--color-chart-7:#ffcb05;--color-chart-8:#ee652e;--color-chart-9:#528694;--color-chart-10:#a10f3b}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes progress{50%{background-position-x:-115%}}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-outline-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}`)),document.head.appendChild(e)}}catch(e){console.error(`vite-plugin-css-injected-by-js`,e)}})();var __defProp = Object.defineProperty, __export = (T) => {
	let E = {};
	for (var O in T) __defProp(E, O, {
		get: T[O],
		enumerable: !0
	});
	return E;
};
/**
* @vue/shared v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/* @__NO_SIDE_EFFECTS__ */
function makeMap(u) {
	let T = /* @__PURE__ */ Object.create(null);
	for (let E of u.split(",")) T[E] = 1;
	return (u) => u in T;
}
var EMPTY_OBJ = {}, EMPTY_ARR = [], NOOP = () => {}, NO = () => !1, isOn = (u) => u.charCodeAt(0) === 111 && u.charCodeAt(1) === 110 && (u.charCodeAt(2) > 122 || u.charCodeAt(2) < 97), isModelListener = (u) => u.startsWith("onUpdate:"), extend = Object.assign, remove = (u, T) => {
	let E = u.indexOf(T);
	E > -1 && u.splice(E, 1);
}, hasOwnProperty$1 = Object.prototype.hasOwnProperty, hasOwn$2 = (u, T) => hasOwnProperty$1.call(u, T), isArray = Array.isArray, isMap = (u) => toTypeString(u) === "[object Map]", isSet = (u) => toTypeString(u) === "[object Set]", isDate = (u) => toTypeString(u) === "[object Date]", isRegExp = (u) => toTypeString(u) === "[object RegExp]", isFunction = (u) => typeof u == "function", isString = (u) => typeof u == "string", isSymbol = (u) => typeof u == "symbol", isObject$2 = (u) => typeof u == "object" && !!u, isPromise = (u) => (isObject$2(u) || isFunction(u)) && isFunction(u.then) && isFunction(u.catch), objectToString = Object.prototype.toString, toTypeString = (u) => objectToString.call(u), toRawType = (u) => toTypeString(u).slice(8, -1), isPlainObject$1 = (u) => toTypeString(u) === "[object Object]", isIntegerKey = (u) => isString(u) && u !== "NaN" && u[0] !== "-" && "" + parseInt(u, 10) === u, isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), cacheStringFunction$2 = (u) => {
	let T = /* @__PURE__ */ Object.create(null);
	return ((E) => T[E] || (T[E] = u(E)));
}, camelizeRE$2 = /-\w/g, camelize$2 = cacheStringFunction$2((u) => u.replace(camelizeRE$2, (u) => u.slice(1).toUpperCase())), hyphenateRE$2 = /\B([A-Z])/g, hyphenate$2 = cacheStringFunction$2((u) => u.replace(hyphenateRE$2, "-$1").toLowerCase()), capitalize = cacheStringFunction$2((u) => u.charAt(0).toUpperCase() + u.slice(1)), toHandlerKey = cacheStringFunction$2((u) => u ? `on${capitalize(u)}` : ""), hasChanged = (u, T) => !Object.is(u, T), invokeArrayFns = (u, ...T) => {
	for (let E = 0; E < u.length; E++) u[E](...T);
}, def = (u, T, E, O = !1) => {
	Object.defineProperty(u, T, {
		configurable: !0,
		enumerable: !1,
		writable: O,
		value: E
	});
}, looseToNumber = (u) => {
	let T = parseFloat(u);
	return isNaN(T) ? u : T;
}, toNumber = (u) => {
	let T = isString(u) ? Number(u) : NaN;
	return isNaN(T) ? u : T;
}, _globalThis, getGlobalThis = () => _globalThis ||= typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}, isGloballyAllowed = /* @__PURE__ */ makeMap("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol");
function normalizeStyle(u) {
	if (isArray(u)) {
		let T = {};
		for (let E = 0; E < u.length; E++) {
			let O = u[E], M = isString(O) ? parseStringStyle(O) : normalizeStyle(O);
			if (M) for (let u in M) T[u] = M[u];
		}
		return T;
	} else if (isString(u) || isObject$2(u)) return u;
}
var listDelimiterRE = /;(?![^(]*\))/g, propertyDelimiterRE = /:([^]+)/, styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(u) {
	let T = {};
	return u.replace(styleCommentRE, "").split(listDelimiterRE).forEach((u) => {
		if (u) {
			let E = u.split(propertyDelimiterRE);
			E.length > 1 && (T[E[0].trim()] = E[1].trim());
		}
	}), T;
}
function normalizeClass(u) {
	let T = "";
	if (isString(u)) T = u;
	else if (isArray(u)) for (let E = 0; E < u.length; E++) {
		let O = normalizeClass(u[E]);
		O && (T += O + " ");
	}
	else if (isObject$2(u)) for (let E in u) u[E] && (T += E + " ");
	return T.trim();
}
function normalizeProps(u) {
	if (!u) return null;
	let { class: T, style: E } = u;
	return T && !isString(T) && (u.class = normalizeClass(T)), E && (u.style = normalizeStyle(E)), u;
}
var specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
specialBooleanAttrs + "";
function includeBooleanAttr(u) {
	return !!u || u === "";
}
function looseCompareArrays(u, T) {
	if (u.length !== T.length) return !1;
	let E = !0;
	for (let O = 0; E && O < u.length; O++) E = looseEqual(u[O], T[O]);
	return E;
}
function looseEqual(u, T) {
	if (u === T) return !0;
	let E = isDate(u), O = isDate(T);
	if (E || O) return E && O ? u.getTime() === T.getTime() : !1;
	if (E = isSymbol(u), O = isSymbol(T), E || O) return u === T;
	if (E = isArray(u), O = isArray(T), E || O) return E && O ? looseCompareArrays(u, T) : !1;
	if (E = isObject$2(u), O = isObject$2(T), E || O) {
		if (!E || !O || Object.keys(u).length !== Object.keys(T).length) return !1;
		for (let E in u) {
			let O = u.hasOwnProperty(E), M = T.hasOwnProperty(E);
			if (O && !M || !O && M || !looseEqual(u[E], T[E])) return !1;
		}
	}
	return String(u) === String(T);
}
function looseIndexOf(u, T) {
	return u.findIndex((u) => looseEqual(u, T));
}
var isRef$1 = (u) => !!(u && u.__v_isRef === !0), toDisplayString = (u) => isString(u) ? u : u == null ? "" : isArray(u) || isObject$2(u) && (u.toString === objectToString || !isFunction(u.toString)) ? isRef$1(u) ? toDisplayString(u.value) : JSON.stringify(u, replacer, 2) : String(u), replacer = (u, T) => isRef$1(T) ? replacer(u, T.value) : isMap(T) ? { [`Map(${T.size})`]: [...T.entries()].reduce((u, [T, E], O) => (u[stringifySymbol(T, O) + " =>"] = E, u), {}) } : isSet(T) ? { [`Set(${T.size})`]: [...T.values()].map((u) => stringifySymbol(u)) } : isSymbol(T) ? stringifySymbol(T) : isObject$2(T) && !isArray(T) && !isPlainObject$1(T) ? String(T) : T, stringifySymbol = (u, T = "") => isSymbol(u) ? `Symbol(${u.description ?? T})` : u;
function normalizeCssVarValue(u) {
	return u == null ? "initial" : typeof u == "string" ? u === "" ? " " : u : String(u);
}
var activeEffectScope, EffectScope = class {
	constructor(u = !1) {
		this.detached = u, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = activeEffectScope, !u && activeEffectScope && (this.index = (activeEffectScope.scopes ||= []).push(this) - 1);
	}
	get active() {
		return this._active;
	}
	pause() {
		if (this._active) {
			this._isPaused = !0;
			let u, T;
			if (this.scopes) for (u = 0, T = this.scopes.length; u < T; u++) this.scopes[u].pause();
			for (u = 0, T = this.effects.length; u < T; u++) this.effects[u].pause();
		}
	}
	resume() {
		if (this._active && this._isPaused) {
			this._isPaused = !1;
			let u, T;
			if (this.scopes) for (u = 0, T = this.scopes.length; u < T; u++) this.scopes[u].resume();
			for (u = 0, T = this.effects.length; u < T; u++) this.effects[u].resume();
		}
	}
	run(u) {
		if (this._active) {
			let T = activeEffectScope;
			try {
				return activeEffectScope = this, u();
			} finally {
				activeEffectScope = T;
			}
		}
	}
	on() {
		++this._on === 1 && (this.prevScope = activeEffectScope, activeEffectScope = this);
	}
	off() {
		this._on > 0 && --this._on === 0 && (activeEffectScope = this.prevScope, this.prevScope = void 0);
	}
	stop(u) {
		if (this._active) {
			this._active = !1;
			let T, E;
			for (T = 0, E = this.effects.length; T < E; T++) this.effects[T].stop();
			for (this.effects.length = 0, T = 0, E = this.cleanups.length; T < E; T++) this.cleanups[T]();
			if (this.cleanups.length = 0, this.scopes) {
				for (T = 0, E = this.scopes.length; T < E; T++) this.scopes[T].stop(!0);
				this.scopes.length = 0;
			}
			if (!this.detached && this.parent && !u) {
				let u = this.parent.scopes.pop();
				u && u !== this && (this.parent.scopes[this.index] = u, u.index = this.index);
			}
			this.parent = void 0;
		}
	}
};
function effectScope(u) {
	return new EffectScope(u);
}
function getCurrentScope() {
	return activeEffectScope;
}
function onScopeDispose(u, T = !1) {
	activeEffectScope && activeEffectScope.cleanups.push(u);
}
var activeSub, pausedQueueEffects = /* @__PURE__ */ new WeakSet(), ReactiveEffect = class {
	constructor(u) {
		this.fn = u, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, activeEffectScope && activeEffectScope.active && activeEffectScope.effects.push(this);
	}
	pause() {
		this.flags |= 64;
	}
	resume() {
		this.flags & 64 && (this.flags &= -65, pausedQueueEffects.has(this) && (pausedQueueEffects.delete(this), this.trigger()));
	}
	notify() {
		this.flags & 2 && !(this.flags & 32) || this.flags & 8 || batch(this);
	}
	run() {
		if (!(this.flags & 1)) return this.fn();
		this.flags |= 2, cleanupEffect(this), prepareDeps(this);
		let u = activeSub, T = shouldTrack;
		activeSub = this, shouldTrack = !0;
		try {
			return this.fn();
		} finally {
			cleanupDeps(this), activeSub = u, shouldTrack = T, this.flags &= -3;
		}
	}
	stop() {
		if (this.flags & 1) {
			for (let u = this.deps; u; u = u.nextDep) removeSub(u);
			this.deps = this.depsTail = void 0, cleanupEffect(this), this.onStop && this.onStop(), this.flags &= -2;
		}
	}
	trigger() {
		this.flags & 64 ? pausedQueueEffects.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
	}
	runIfDirty() {
		isDirty(this) && this.run();
	}
	get dirty() {
		return isDirty(this);
	}
}, batchDepth = 0, batchedSub, batchedComputed;
function batch(u, T = !1) {
	if (u.flags |= 8, T) {
		u.next = batchedComputed, batchedComputed = u;
		return;
	}
	u.next = batchedSub, batchedSub = u;
}
function startBatch() {
	batchDepth++;
}
function endBatch() {
	if (--batchDepth > 0) return;
	if (batchedComputed) {
		let u = batchedComputed;
		for (batchedComputed = void 0; u;) {
			let T = u.next;
			u.next = void 0, u.flags &= -9, u = T;
		}
	}
	let u;
	for (; batchedSub;) {
		let T = batchedSub;
		for (batchedSub = void 0; T;) {
			let E = T.next;
			if (T.next = void 0, T.flags &= -9, T.flags & 1) try {
				T.trigger();
			} catch (T) {
				u ||= T;
			}
			T = E;
		}
	}
	if (u) throw u;
}
function prepareDeps(u) {
	for (let T = u.deps; T; T = T.nextDep) T.version = -1, T.prevActiveLink = T.dep.activeLink, T.dep.activeLink = T;
}
function cleanupDeps(u) {
	let T, E = u.depsTail, O = E;
	for (; O;) {
		let u = O.prevDep;
		O.version === -1 ? (O === E && (E = u), removeSub(O), removeDep(O)) : T = O, O.dep.activeLink = O.prevActiveLink, O.prevActiveLink = void 0, O = u;
	}
	u.deps = T, u.depsTail = E;
}
function isDirty(u) {
	for (let T = u.deps; T; T = T.nextDep) if (T.dep.version !== T.version || T.dep.computed && (refreshComputed(T.dep.computed) || T.dep.version !== T.version)) return !0;
	return !!u._dirty;
}
function refreshComputed(u) {
	if (u.flags & 4 && !(u.flags & 16) || (u.flags &= -17, u.globalVersion === globalVersion) || (u.globalVersion = globalVersion, !u.isSSR && u.flags & 128 && (!u.deps && !u._dirty || !isDirty(u)))) return;
	u.flags |= 2;
	let T = u.dep, E = activeSub, O = shouldTrack;
	activeSub = u, shouldTrack = !0;
	try {
		prepareDeps(u);
		let E = u.fn(u._value);
		(T.version === 0 || hasChanged(E, u._value)) && (u.flags |= 128, u._value = E, T.version++);
	} catch (u) {
		throw T.version++, u;
	} finally {
		activeSub = E, shouldTrack = O, cleanupDeps(u), u.flags &= -3;
	}
}
function removeSub(u, T = !1) {
	let { dep: E, prevSub: O, nextSub: M } = u;
	if (O && (O.nextSub = M, u.prevSub = void 0), M && (M.prevSub = O, u.nextSub = void 0), E.subs === u && (E.subs = O, !O && E.computed)) {
		E.computed.flags &= -5;
		for (let u = E.computed.deps; u; u = u.nextDep) removeSub(u, !0);
	}
	!T && !--E.sc && E.map && E.map.delete(E.key);
}
function removeDep(u) {
	let { prevDep: T, nextDep: E } = u;
	T && (T.nextDep = E, u.prevDep = void 0), E && (E.prevDep = T, u.nextDep = void 0);
}
function effect(u, T) {
	u.effect instanceof ReactiveEffect && (u = u.effect.fn);
	let E = new ReactiveEffect(u);
	T && extend(E, T);
	try {
		E.run();
	} catch (u) {
		throw E.stop(), u;
	}
	let O = E.run.bind(E);
	return O.effect = E, O;
}
function stop(u) {
	u.effect.stop();
}
var shouldTrack = !0, trackStack = [];
function pauseTracking() {
	trackStack.push(shouldTrack), shouldTrack = !1;
}
function resetTracking() {
	let u = trackStack.pop();
	shouldTrack = u === void 0 ? !0 : u;
}
function cleanupEffect(u) {
	let { cleanup: T } = u;
	if (u.cleanup = void 0, T) {
		let u = activeSub;
		activeSub = void 0;
		try {
			T();
		} finally {
			activeSub = u;
		}
	}
}
var globalVersion = 0, Link = class {
	constructor(u, T) {
		this.sub = u, this.dep = T, this.version = T.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
	}
}, Dep = class {
	constructor(u) {
		this.computed = u, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
	}
	track(u) {
		if (!activeSub || !shouldTrack || activeSub === this.computed) return;
		let T = this.activeLink;
		if (T === void 0 || T.sub !== activeSub) T = this.activeLink = new Link(activeSub, this), activeSub.deps ? (T.prevDep = activeSub.depsTail, activeSub.depsTail.nextDep = T, activeSub.depsTail = T) : activeSub.deps = activeSub.depsTail = T, addSub(T);
		else if (T.version === -1 && (T.version = this.version, T.nextDep)) {
			let u = T.nextDep;
			u.prevDep = T.prevDep, T.prevDep && (T.prevDep.nextDep = u), T.prevDep = activeSub.depsTail, T.nextDep = void 0, activeSub.depsTail.nextDep = T, activeSub.depsTail = T, activeSub.deps === T && (activeSub.deps = u);
		}
		return T;
	}
	trigger(u) {
		this.version++, globalVersion++, this.notify(u);
	}
	notify(u) {
		startBatch();
		try {
			for (let u = this.subs; u; u = u.prevSub) u.sub.notify() && u.sub.dep.notify();
		} finally {
			endBatch();
		}
	}
};
function addSub(u) {
	if (u.dep.sc++, u.sub.flags & 4) {
		let T = u.dep.computed;
		if (T && !u.dep.subs) {
			T.flags |= 20;
			for (let u = T.deps; u; u = u.nextDep) addSub(u);
		}
		let E = u.dep.subs;
		E !== u && (u.prevSub = E, E && (E.nextSub = u)), u.dep.subs = u;
	}
}
var targetMap = /* @__PURE__ */ new WeakMap(), ITERATE_KEY = Symbol(""), MAP_KEY_ITERATE_KEY = Symbol(""), ARRAY_ITERATE_KEY = Symbol("");
function track(u, T, E) {
	if (shouldTrack && activeSub) {
		let T = targetMap.get(u);
		T || targetMap.set(u, T = /* @__PURE__ */ new Map());
		let O = T.get(E);
		O || (T.set(E, O = new Dep()), O.map = T, O.key = E), O.track();
	}
}
function trigger(u, T, E, O, M, P) {
	let F = targetMap.get(u);
	if (!F) {
		globalVersion++;
		return;
	}
	let I = (u) => {
		u && u.trigger();
	};
	if (startBatch(), T === "clear") F.forEach(I);
	else {
		let M = isArray(u), P = M && isIntegerKey(E);
		if (M && E === "length") {
			let u = Number(O);
			F.forEach((T, E) => {
				(E === "length" || E === ARRAY_ITERATE_KEY || !isSymbol(E) && E >= u) && I(T);
			});
		} else switch ((E !== void 0 || F.has(void 0)) && I(F.get(E)), P && I(F.get(ARRAY_ITERATE_KEY)), T) {
			case "add":
				M ? P && I(F.get("length")) : (I(F.get(ITERATE_KEY)), isMap(u) && I(F.get(MAP_KEY_ITERATE_KEY)));
				break;
			case "delete":
				M || (I(F.get(ITERATE_KEY)), isMap(u) && I(F.get(MAP_KEY_ITERATE_KEY)));
				break;
			case "set":
				isMap(u) && I(F.get(ITERATE_KEY));
				break;
		}
	}
	endBatch();
}
function getDepFromReactive(u, T) {
	let E = targetMap.get(u);
	return E && E.get(T);
}
function reactiveReadArray(u) {
	let T = toRaw(u);
	return T === u ? T : (track(T, "iterate", ARRAY_ITERATE_KEY), isShallow(u) ? T : T.map(toReactive));
}
function shallowReadArray(u) {
	return track(u = toRaw(u), "iterate", ARRAY_ITERATE_KEY), u;
}
var arrayInstrumentations = {
	__proto__: null,
	[Symbol.iterator]() {
		return iterator(this, Symbol.iterator, toReactive);
	},
	concat(...u) {
		return reactiveReadArray(this).concat(...u.map((u) => isArray(u) ? reactiveReadArray(u) : u));
	},
	entries() {
		return iterator(this, "entries", (u) => (u[1] = toReactive(u[1]), u));
	},
	every(u, T) {
		return apply(this, "every", u, T, void 0, arguments);
	},
	filter(u, T) {
		return apply(this, "filter", u, T, (u) => u.map(toReactive), arguments);
	},
	find(u, T) {
		return apply(this, "find", u, T, toReactive, arguments);
	},
	findIndex(u, T) {
		return apply(this, "findIndex", u, T, void 0, arguments);
	},
	findLast(u, T) {
		return apply(this, "findLast", u, T, toReactive, arguments);
	},
	findLastIndex(u, T) {
		return apply(this, "findLastIndex", u, T, void 0, arguments);
	},
	forEach(u, T) {
		return apply(this, "forEach", u, T, void 0, arguments);
	},
	includes(...u) {
		return searchProxy(this, "includes", u);
	},
	indexOf(...u) {
		return searchProxy(this, "indexOf", u);
	},
	join(u) {
		return reactiveReadArray(this).join(u);
	},
	lastIndexOf(...u) {
		return searchProxy(this, "lastIndexOf", u);
	},
	map(u, T) {
		return apply(this, "map", u, T, void 0, arguments);
	},
	pop() {
		return noTracking(this, "pop");
	},
	push(...u) {
		return noTracking(this, "push", u);
	},
	reduce(u, ...T) {
		return reduce(this, "reduce", u, T);
	},
	reduceRight(u, ...T) {
		return reduce(this, "reduceRight", u, T);
	},
	shift() {
		return noTracking(this, "shift");
	},
	some(u, T) {
		return apply(this, "some", u, T, void 0, arguments);
	},
	splice(...u) {
		return noTracking(this, "splice", u);
	},
	toReversed() {
		return reactiveReadArray(this).toReversed();
	},
	toSorted(u) {
		return reactiveReadArray(this).toSorted(u);
	},
	toSpliced(...u) {
		return reactiveReadArray(this).toSpliced(...u);
	},
	unshift(...u) {
		return noTracking(this, "unshift", u);
	},
	values() {
		return iterator(this, "values", toReactive);
	}
};
function iterator(u, T, E) {
	let O = shallowReadArray(u), M = O[T]();
	return O !== u && !isShallow(u) && (M._next = M.next, M.next = () => {
		let u = M._next();
		return u.done || (u.value = E(u.value)), u;
	}), M;
}
var arrayProto = Array.prototype;
function apply(u, T, E, O, M, P) {
	let F = shallowReadArray(u), I = F !== u && !isShallow(u), R = F[T];
	if (R !== arrayProto[T]) {
		let T = R.apply(u, P);
		return I ? toReactive(T) : T;
	}
	let V = E;
	F !== u && (I ? V = function(T, O) {
		return E.call(this, toReactive(T), O, u);
	} : E.length > 2 && (V = function(T, O) {
		return E.call(this, T, O, u);
	}));
	let U = R.call(F, V, O);
	return I && M ? M(U) : U;
}
function reduce(u, T, E, O) {
	let M = shallowReadArray(u), P = E;
	return M !== u && (isShallow(u) ? E.length > 3 && (P = function(T, O, M) {
		return E.call(this, T, O, M, u);
	}) : P = function(T, O, M) {
		return E.call(this, T, toReactive(O), M, u);
	}), M[T](P, ...O);
}
function searchProxy(u, T, E) {
	let O = toRaw(u);
	track(O, "iterate", ARRAY_ITERATE_KEY);
	let M = O[T](...E);
	return (M === -1 || M === !1) && isProxy(E[0]) ? (E[0] = toRaw(E[0]), O[T](...E)) : M;
}
function noTracking(u, T, E = []) {
	pauseTracking(), startBatch();
	let O = toRaw(u)[T].apply(u, E);
	return endBatch(), resetTracking(), O;
}
var isNonTrackableKeys = /* @__PURE__ */ makeMap("__proto__,__v_isRef,__isVue"), builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((u) => u !== "arguments" && u !== "caller").map((u) => Symbol[u]).filter(isSymbol));
function hasOwnProperty(u) {
	isSymbol(u) || (u = String(u));
	let T = toRaw(this);
	return track(T, "has", u), T.hasOwnProperty(u);
}
var BaseReactiveHandler = class {
	constructor(u = !1, T = !1) {
		this._isReadonly = u, this._isShallow = T;
	}
	get(u, T, E) {
		if (T === "__v_skip") return u.__v_skip;
		let O = this._isReadonly, M = this._isShallow;
		if (T === "__v_isReactive") return !O;
		if (T === "__v_isReadonly") return O;
		if (T === "__v_isShallow") return M;
		if (T === "__v_raw") return E === (O ? M ? shallowReadonlyMap : readonlyMap : M ? shallowReactiveMap : reactiveMap).get(u) || Object.getPrototypeOf(u) === Object.getPrototypeOf(E) ? u : void 0;
		let P = isArray(u);
		if (!O) {
			let u;
			if (P && (u = arrayInstrumentations[T])) return u;
			if (T === "hasOwnProperty") return hasOwnProperty;
		}
		let F = Reflect.get(u, T, isRef(u) ? u : E);
		if ((isSymbol(T) ? builtInSymbols.has(T) : isNonTrackableKeys(T)) || (O || track(u, "get", T), M)) return F;
		if (isRef(F)) {
			let u = P && isIntegerKey(T) ? F : F.value;
			return O && isObject$2(u) ? readonly(u) : u;
		}
		return isObject$2(F) ? O ? readonly(F) : reactive(F) : F;
	}
}, MutableReactiveHandler = class extends BaseReactiveHandler {
	constructor(u = !1) {
		super(!1, u);
	}
	set(u, T, E, O) {
		let M = u[T];
		if (!this._isShallow) {
			let T = isReadonly(M);
			if (!isShallow(E) && !isReadonly(E) && (M = toRaw(M), E = toRaw(E)), !isArray(u) && isRef(M) && !isRef(E)) return T || (M.value = E), !0;
		}
		let P = isArray(u) && isIntegerKey(T) ? Number(T) < u.length : hasOwn$2(u, T), F = Reflect.set(u, T, E, isRef(u) ? u : O);
		return u === toRaw(O) && (P ? hasChanged(E, M) && trigger(u, "set", T, E, M) : trigger(u, "add", T, E)), F;
	}
	deleteProperty(u, T) {
		let E = hasOwn$2(u, T), O = u[T], M = Reflect.deleteProperty(u, T);
		return M && E && trigger(u, "delete", T, void 0, O), M;
	}
	has(u, T) {
		let E = Reflect.has(u, T);
		return (!isSymbol(T) || !builtInSymbols.has(T)) && track(u, "has", T), E;
	}
	ownKeys(u) {
		return track(u, "iterate", isArray(u) ? "length" : ITERATE_KEY), Reflect.ownKeys(u);
	}
}, ReadonlyReactiveHandler = class extends BaseReactiveHandler {
	constructor(u = !1) {
		super(!0, u);
	}
	set(u, T) {
		return !0;
	}
	deleteProperty(u, T) {
		return !0;
	}
}, mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler(), readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(), shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(!0), shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(!0), toShallow = (u) => u, getProto = (u) => Reflect.getPrototypeOf(u);
function createIterableMethod(u, T, E) {
	return function(...O) {
		let M = this.__v_raw, P = toRaw(M), F = isMap(P), I = u === "entries" || u === Symbol.iterator && F, R = u === "keys" && F, V = M[u](...O), U = E ? toShallow : T ? toReadonly : toReactive;
		return !T && track(P, "iterate", R ? MAP_KEY_ITERATE_KEY : ITERATE_KEY), {
			next() {
				let { value: u, done: T } = V.next();
				return T ? {
					value: u,
					done: T
				} : {
					value: I ? [U(u[0]), U(u[1])] : U(u),
					done: T
				};
			},
			[Symbol.iterator]() {
				return this;
			}
		};
	};
}
function createReadonlyMethod(u) {
	return function(...T) {
		return u === "delete" ? !1 : u === "clear" ? void 0 : this;
	};
}
function createInstrumentations(u, T) {
	let E = {
		get(E) {
			let O = this.__v_raw, M = toRaw(O), P = toRaw(E);
			u || (hasChanged(E, P) && track(M, "get", E), track(M, "get", P));
			let { has: F } = getProto(M), I = T ? toShallow : u ? toReadonly : toReactive;
			if (F.call(M, E)) return I(O.get(E));
			if (F.call(M, P)) return I(O.get(P));
			O !== M && O.get(E);
		},
		get size() {
			let T = this.__v_raw;
			return !u && track(toRaw(T), "iterate", ITERATE_KEY), T.size;
		},
		has(T) {
			let E = this.__v_raw, O = toRaw(E), M = toRaw(T);
			return u || (hasChanged(T, M) && track(O, "has", T), track(O, "has", M)), T === M ? E.has(T) : E.has(T) || E.has(M);
		},
		forEach(E, O) {
			let M = this, P = M.__v_raw, F = toRaw(P), I = T ? toShallow : u ? toReadonly : toReactive;
			return !u && track(F, "iterate", ITERATE_KEY), P.forEach((u, T) => E.call(O, I(u), I(T), M));
		}
	};
	return extend(E, u ? {
		add: createReadonlyMethod("add"),
		set: createReadonlyMethod("set"),
		delete: createReadonlyMethod("delete"),
		clear: createReadonlyMethod("clear")
	} : {
		add(u) {
			!T && !isShallow(u) && !isReadonly(u) && (u = toRaw(u));
			let E = toRaw(this);
			return getProto(E).has.call(E, u) || (E.add(u), trigger(E, "add", u, u)), this;
		},
		set(u, E) {
			!T && !isShallow(E) && !isReadonly(E) && (E = toRaw(E));
			let O = toRaw(this), { has: M, get: P } = getProto(O), F = M.call(O, u);
			F ||= (u = toRaw(u), M.call(O, u));
			let I = P.call(O, u);
			return O.set(u, E), F ? hasChanged(E, I) && trigger(O, "set", u, E, I) : trigger(O, "add", u, E), this;
		},
		delete(u) {
			let T = toRaw(this), { has: E, get: O } = getProto(T), M = E.call(T, u);
			M ||= (u = toRaw(u), E.call(T, u));
			let P = O ? O.call(T, u) : void 0, F = T.delete(u);
			return M && trigger(T, "delete", u, void 0, P), F;
		},
		clear() {
			let u = toRaw(this), T = u.size !== 0, E = u.clear();
			return T && trigger(u, "clear", void 0, void 0, void 0), E;
		}
	}), [
		"keys",
		"values",
		"entries",
		Symbol.iterator
	].forEach((O) => {
		E[O] = createIterableMethod(O, u, T);
	}), E;
}
function createInstrumentationGetter(u, T) {
	let E = createInstrumentations(u, T);
	return (T, O, M) => O === "__v_isReactive" ? !u : O === "__v_isReadonly" ? u : O === "__v_raw" ? T : Reflect.get(hasOwn$2(E, O) && O in T ? E : T, O, M);
}
var mutableCollectionHandlers = { get: /* @__PURE__ */ createInstrumentationGetter(!1, !1) }, shallowCollectionHandlers = { get: /* @__PURE__ */ createInstrumentationGetter(!1, !0) }, readonlyCollectionHandlers = { get: /* @__PURE__ */ createInstrumentationGetter(!0, !1) }, shallowReadonlyCollectionHandlers = { get: /* @__PURE__ */ createInstrumentationGetter(!0, !0) }, reactiveMap = /* @__PURE__ */ new WeakMap(), shallowReactiveMap = /* @__PURE__ */ new WeakMap(), readonlyMap = /* @__PURE__ */ new WeakMap(), shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(u) {
	switch (u) {
		case "Object":
		case "Array": return 1;
		case "Map":
		case "Set":
		case "WeakMap":
		case "WeakSet": return 2;
		default: return 0;
	}
}
function getTargetType(u) {
	return u.__v_skip || !Object.isExtensible(u) ? 0 : targetTypeMap(toRawType(u));
}
function reactive(u) {
	return isReadonly(u) ? u : createReactiveObject(u, !1, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(u) {
	return createReactiveObject(u, !1, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(u) {
	return createReactiveObject(u, !0, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(u) {
	return createReactiveObject(u, !0, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(u, T, E, O, M) {
	if (!isObject$2(u) || u.__v_raw && !(T && u.__v_isReactive)) return u;
	let P = getTargetType(u);
	if (P === 0) return u;
	let F = M.get(u);
	if (F) return F;
	let I = new Proxy(u, P === 2 ? O : E);
	return M.set(u, I), I;
}
function isReactive(u) {
	return isReadonly(u) ? isReactive(u.__v_raw) : !!(u && u.__v_isReactive);
}
function isReadonly(u) {
	return !!(u && u.__v_isReadonly);
}
function isShallow(u) {
	return !!(u && u.__v_isShallow);
}
function isProxy(u) {
	return u ? !!u.__v_raw : !1;
}
function toRaw(u) {
	let T = u && u.__v_raw;
	return T ? toRaw(T) : u;
}
function markRaw(u) {
	return !hasOwn$2(u, "__v_skip") && Object.isExtensible(u) && def(u, "__v_skip", !0), u;
}
var toReactive = (u) => isObject$2(u) ? reactive(u) : u, toReadonly = (u) => isObject$2(u) ? readonly(u) : u;
function isRef(u) {
	return u ? u.__v_isRef === !0 : !1;
}
function ref(u) {
	return createRef$2(u, !1);
}
function shallowRef(u) {
	return createRef$2(u, !0);
}
function createRef$2(u, T) {
	return isRef(u) ? u : new RefImpl(u, T);
}
var RefImpl = class {
	constructor(u, T) {
		this.dep = new Dep(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = T ? u : toRaw(u), this._value = T ? u : toReactive(u), this.__v_isShallow = T;
	}
	get value() {
		return this.dep.track(), this._value;
	}
	set value(u) {
		let T = this._rawValue, E = this.__v_isShallow || isShallow(u) || isReadonly(u);
		u = E ? u : toRaw(u), hasChanged(u, T) && (this._rawValue = u, this._value = E ? u : toReactive(u), this.dep.trigger());
	}
};
function triggerRef(u) {
	u.dep && u.dep.trigger();
}
function unref(u) {
	return isRef(u) ? u.value : u;
}
function toValue(u) {
	return isFunction(u) ? u() : unref(u);
}
var shallowUnwrapHandlers = {
	get: (u, T, E) => T === "__v_raw" ? u : unref(Reflect.get(u, T, E)),
	set: (u, T, E, O) => {
		let M = u[T];
		return isRef(M) && !isRef(E) ? (M.value = E, !0) : Reflect.set(u, T, E, O);
	}
};
function proxyRefs(u) {
	return isReactive(u) ? u : new Proxy(u, shallowUnwrapHandlers);
}
var CustomRefImpl = class {
	constructor(u) {
		this.__v_isRef = !0, this._value = void 0;
		let T = this.dep = new Dep(), { get: E, set: O } = u(T.track.bind(T), T.trigger.bind(T));
		this._get = E, this._set = O;
	}
	get value() {
		return this._value = this._get();
	}
	set value(u) {
		this._set(u);
	}
};
function customRef(u) {
	return new CustomRefImpl(u);
}
function toRefs(u) {
	let T = isArray(u) ? Array(u.length) : {};
	for (let E in u) T[E] = propertyToRef(u, E);
	return T;
}
var ObjectRefImpl = class {
	constructor(u, T, E) {
		this._object = u, this._key = T, this._defaultValue = E, this.__v_isRef = !0, this._value = void 0;
	}
	get value() {
		let u = this._object[this._key];
		return this._value = u === void 0 ? this._defaultValue : u;
	}
	set value(u) {
		this._object[this._key] = u;
	}
	get dep() {
		return getDepFromReactive(toRaw(this._object), this._key);
	}
}, GetterRefImpl = class {
	constructor(u) {
		this._getter = u, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
	}
	get value() {
		return this._value = this._getter();
	}
};
function toRef(u, T, E) {
	return isRef(u) ? u : isFunction(u) ? new GetterRefImpl(u) : isObject$2(u) && arguments.length > 1 ? propertyToRef(u, T, E) : ref(u);
}
function propertyToRef(u, T, E) {
	let O = u[T];
	return isRef(O) ? O : new ObjectRefImpl(u, T, E);
}
var ComputedRefImpl = class {
	constructor(u, T, E) {
		this.fn = u, this.setter = T, this._value = void 0, this.dep = new Dep(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = globalVersion - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !T, this.isSSR = E;
	}
	notify() {
		if (this.flags |= 16, !(this.flags & 8) && activeSub !== this) return batch(this, !0), !0;
	}
	get value() {
		let u = this.dep.track();
		return refreshComputed(this), u && (u.version = this.dep.version), this._value;
	}
	set value(u) {
		this.setter && this.setter(u);
	}
};
function computed$1(u, T, E = !1) {
	let O, M;
	return isFunction(u) ? O = u : (O = u.get, M = u.set), new ComputedRefImpl(O, M, E);
}
var TrackOpTypes = {
	GET: "get",
	HAS: "has",
	ITERATE: "iterate"
}, TriggerOpTypes = {
	SET: "set",
	ADD: "add",
	DELETE: "delete",
	CLEAR: "clear"
}, INITIAL_WATCHER_VALUE = {}, cleanupMap = /* @__PURE__ */ new WeakMap(), activeWatcher = void 0;
function getCurrentWatcher() {
	return activeWatcher;
}
function onWatcherCleanup(u, T = !1, E = activeWatcher) {
	if (E) {
		let T = cleanupMap.get(E);
		T || cleanupMap.set(E, T = []), T.push(u);
	}
}
function watch$1(u, T, E = EMPTY_OBJ) {
	let { immediate: M, deep: F, once: I, scheduler: R, augmentJob: V, call: Dp } = E, Op = (u) => F ? u : isShallow(u) || F === !1 || F === 0 ? traverse(u, 1) : traverse(u), Ap, jp, Mp, Np, Fp = !1, Ip = !1;
	if (isRef(u) ? (jp = () => u.value, Fp = isShallow(u)) : isReactive(u) ? (jp = () => Op(u), Fp = !0) : isArray(u) ? (Ip = !0, Fp = u.some((u) => isReactive(u) || isShallow(u)), jp = () => u.map((u) => {
		if (isRef(u)) return u.value;
		if (isReactive(u)) return Op(u);
		if (isFunction(u)) return Dp ? Dp(u, 2) : u();
	})) : jp = isFunction(u) ? T ? Dp ? () => Dp(u, 2) : u : () => {
		if (Mp) {
			pauseTracking();
			try {
				Mp();
			} finally {
				resetTracking();
			}
		}
		let T = activeWatcher;
		activeWatcher = Ap;
		try {
			return Dp ? Dp(u, 3, [Np]) : u(Np);
		} finally {
			activeWatcher = T;
		}
	} : NOOP, T && F) {
		let u = jp, T = F === !0 ? Infinity : F;
		jp = () => traverse(u(), T);
	}
	let Lp = getCurrentScope(), Rp = () => {
		Ap.stop(), Lp && Lp.active && remove(Lp.effects, Ap);
	};
	if (I && T) {
		let u = T;
		T = (...T) => {
			u(...T), Rp();
		};
	}
	let zp = Ip ? Array(u.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE, Bp = (u) => {
		if (!(!(Ap.flags & 1) || !Ap.dirty && !u)) if (T) {
			let u = Ap.run();
			if (F || Fp || (Ip ? u.some((u, T) => hasChanged(u, zp[T])) : hasChanged(u, zp))) {
				Mp && Mp();
				let E = activeWatcher;
				activeWatcher = Ap;
				try {
					let E = [
						u,
						zp === INITIAL_WATCHER_VALUE ? void 0 : Ip && zp[0] === INITIAL_WATCHER_VALUE ? [] : zp,
						Np
					];
					zp = u, Dp ? Dp(T, 3, E) : T(...E);
				} finally {
					activeWatcher = E;
				}
			}
		} else Ap.run();
	};
	return V && V(Bp), Ap = new ReactiveEffect(jp), Ap.scheduler = R ? () => R(Bp, !1) : Bp, Np = (u) => onWatcherCleanup(u, !1, Ap), Mp = Ap.onStop = () => {
		let u = cleanupMap.get(Ap);
		if (u) {
			if (Dp) Dp(u, 4);
			else for (let T of u) T();
			cleanupMap.delete(Ap);
		}
	}, T ? M ? Bp(!0) : zp = Ap.run() : R ? R(Bp.bind(null, !0), !0) : Ap.run(), Rp.pause = Ap.pause.bind(Ap), Rp.resume = Ap.resume.bind(Ap), Rp.stop = Rp, Rp;
}
function traverse(u, T = Infinity, E) {
	if (T <= 0 || !isObject$2(u) || u.__v_skip || (E ||= /* @__PURE__ */ new Map(), (E.get(u) || 0) >= T)) return u;
	if (E.set(u, T), T--, isRef(u)) traverse(u.value, T, E);
	else if (isArray(u)) for (let O = 0; O < u.length; O++) traverse(u[O], T, E);
	else if (isSet(u) || isMap(u)) u.forEach((u) => {
		traverse(u, T, E);
	});
	else if (isPlainObject$1(u)) {
		for (let O in u) traverse(u[O], T, E);
		for (let O of Object.getOwnPropertySymbols(u)) Object.prototype.propertyIsEnumerable.call(u, O) && traverse(u[O], T, E);
	}
	return u;
}
var stack = [];
function pushWarningContext(u) {
	stack.push(u);
}
function popWarningContext() {
	stack.pop();
}
function assertNumber(u, T) {}
var ErrorCodes = {
	SETUP_FUNCTION: 0,
	0: "SETUP_FUNCTION",
	RENDER_FUNCTION: 1,
	1: "RENDER_FUNCTION",
	NATIVE_EVENT_HANDLER: 5,
	5: "NATIVE_EVENT_HANDLER",
	COMPONENT_EVENT_HANDLER: 6,
	6: "COMPONENT_EVENT_HANDLER",
	VNODE_HOOK: 7,
	7: "VNODE_HOOK",
	DIRECTIVE_HOOK: 8,
	8: "DIRECTIVE_HOOK",
	TRANSITION_HOOK: 9,
	9: "TRANSITION_HOOK",
	APP_ERROR_HANDLER: 10,
	10: "APP_ERROR_HANDLER",
	APP_WARN_HANDLER: 11,
	11: "APP_WARN_HANDLER",
	FUNCTION_REF: 12,
	12: "FUNCTION_REF",
	ASYNC_COMPONENT_LOADER: 13,
	13: "ASYNC_COMPONENT_LOADER",
	SCHEDULER: 14,
	14: "SCHEDULER",
	COMPONENT_UPDATE: 15,
	15: "COMPONENT_UPDATE",
	APP_UNMOUNT_CLEANUP: 16,
	16: "APP_UNMOUNT_CLEANUP"
}, ErrorTypeStrings$1 = {
	sp: "serverPrefetch hook",
	bc: "beforeCreate hook",
	c: "created hook",
	bm: "beforeMount hook",
	m: "mounted hook",
	bu: "beforeUpdate hook",
	u: "updated",
	bum: "beforeUnmount hook",
	um: "unmounted hook",
	a: "activated hook",
	da: "deactivated hook",
	ec: "errorCaptured hook",
	rtc: "renderTracked hook",
	rtg: "renderTriggered hook",
	0: "setup function",
	1: "render function",
	2: "watcher getter",
	3: "watcher callback",
	4: "watcher cleanup function",
	5: "native event handler",
	6: "component event handler",
	7: "vnode hook",
	8: "directive hook",
	9: "transition hook",
	10: "app errorHandler",
	11: "app warnHandler",
	12: "ref function",
	13: "async component loader",
	14: "scheduler flush",
	15: "component update",
	16: "app unmount cleanup function"
};
function callWithErrorHandling(u, T, E, O) {
	try {
		return O ? u(...O) : u();
	} catch (u) {
		handleError(u, T, E);
	}
}
function callWithAsyncErrorHandling(u, T, E, O) {
	if (isFunction(u)) {
		let M = callWithErrorHandling(u, T, E, O);
		return M && isPromise(M) && M.catch((u) => {
			handleError(u, T, E);
		}), M;
	}
	if (isArray(u)) {
		let M = [];
		for (let P = 0; P < u.length; P++) M.push(callWithAsyncErrorHandling(u[P], T, E, O));
		return M;
	}
}
function handleError(u, T, E, M = !0) {
	let P = T ? T.vnode : null, { errorHandler: F, throwUnhandledErrorInProduction: I } = T && T.appContext.config || EMPTY_OBJ;
	if (T) {
		let O = T.parent, M = T.proxy, P = `https://vuejs.org/error-reference/#runtime-${E}`;
		for (; O;) {
			let T = O.ec;
			if (T) {
				for (let E = 0; E < T.length; E++) if (T[E](u, M, P) === !1) return;
			}
			O = O.parent;
		}
		if (F) {
			pauseTracking(), callWithErrorHandling(F, null, 10, [
				u,
				M,
				P
			]), resetTracking();
			return;
		}
	}
	logError(u, E, P, M, I);
}
function logError(u, T, E, O = !0, M = !1) {
	if (M) throw u;
	console.error(u);
}
var queue = [], flushIndex = -1, pendingPostFlushCbs = [], activePostFlushCbs = null, postFlushIndex = 0, resolvedPromise = /* @__PURE__ */ Promise.resolve(), currentFlushPromise = null;
function nextTick(u) {
	let T = currentFlushPromise || resolvedPromise;
	return u ? T.then(this ? u.bind(this) : u) : T;
}
function findInsertionIndex(u) {
	let T = flushIndex + 1, E = queue.length;
	for (; T < E;) {
		let O = T + E >>> 1, M = queue[O], P = getId(M);
		P < u || P === u && M.flags & 2 ? T = O + 1 : E = O;
	}
	return T;
}
function queueJob(u) {
	if (!(u.flags & 1)) {
		let T = getId(u), E = queue[queue.length - 1];
		!E || !(u.flags & 2) && T >= getId(E) ? queue.push(u) : queue.splice(findInsertionIndex(T), 0, u), u.flags |= 1, queueFlush();
	}
}
function queueFlush() {
	currentFlushPromise ||= resolvedPromise.then(flushJobs);
}
function queuePostFlushCb(u) {
	isArray(u) ? pendingPostFlushCbs.push(...u) : activePostFlushCbs && u.id === -1 ? activePostFlushCbs.splice(postFlushIndex + 1, 0, u) : u.flags & 1 || (pendingPostFlushCbs.push(u), u.flags |= 1), queueFlush();
}
function flushPreFlushCbs(u, T, E = flushIndex + 1) {
	for (; E < queue.length; E++) {
		let T = queue[E];
		if (T && T.flags & 2) {
			if (u && T.id !== u.uid) continue;
			queue.splice(E, 1), E--, T.flags & 4 && (T.flags &= -2), T(), T.flags & 4 || (T.flags &= -2);
		}
	}
}
function flushPostFlushCbs(u) {
	if (pendingPostFlushCbs.length) {
		let u = [...new Set(pendingPostFlushCbs)].sort((u, T) => getId(u) - getId(T));
		if (pendingPostFlushCbs.length = 0, activePostFlushCbs) {
			activePostFlushCbs.push(...u);
			return;
		}
		for (activePostFlushCbs = u, postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
			let u = activePostFlushCbs[postFlushIndex];
			u.flags & 4 && (u.flags &= -2), u.flags & 8 || u(), u.flags &= -2;
		}
		activePostFlushCbs = null, postFlushIndex = 0;
	}
}
var getId = (u) => u.id == null ? u.flags & 2 ? -1 : Infinity : u.id;
function flushJobs(u) {
	try {
		for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
			let u = queue[flushIndex];
			u && !(u.flags & 8) && (u.flags & 4 && (u.flags &= -2), callWithErrorHandling(u, u.i, u.i ? 15 : 14), u.flags & 4 || (u.flags &= -2));
		}
	} finally {
		for (; flushIndex < queue.length; flushIndex++) {
			let u = queue[flushIndex];
			u && (u.flags &= -2);
		}
		flushIndex = -1, queue.length = 0, flushPostFlushCbs(u), currentFlushPromise = null, (queue.length || pendingPostFlushCbs.length) && flushJobs(u);
	}
}
var devtools$1, buffer = [];
function setDevtoolsHook$1(u, T) {
	devtools$1 = u, devtools$1 ? (devtools$1.enabled = !0, buffer.forEach(({ event: u, args: T }) => devtools$1.emit(u, ...T)), buffer = []) : typeof window < "u" && window.HTMLElement && !(window.navigator?.userAgent)?.includes("jsdom") ? ((T.__VUE_DEVTOOLS_HOOK_REPLAY__ = T.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((u) => {
		setDevtoolsHook$1(u, T);
	}), setTimeout(() => {
		devtools$1 || (T.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, buffer = []);
	}, 3e3)) : buffer = [];
}
var currentRenderingInstance = null, currentScopeId = null;
function setCurrentRenderingInstance(u) {
	let T = currentRenderingInstance;
	return currentRenderingInstance = u, currentScopeId = u && u.type.__scopeId || null, T;
}
function pushScopeId(u) {
	currentScopeId = u;
}
function popScopeId() {
	currentScopeId = null;
}
var withScopeId = (u) => withCtx;
function withCtx(u, T = currentRenderingInstance, E) {
	if (!T || u._n) return u;
	let O = (...E) => {
		O._d && setBlockTracking(-1);
		let M = setCurrentRenderingInstance(T), P;
		try {
			P = u(...E);
		} finally {
			setCurrentRenderingInstance(M), O._d && setBlockTracking(1);
		}
		return P;
	};
	return O._n = !0, O._c = !0, O._d = !0, O;
}
function withDirectives(u, T) {
	if (currentRenderingInstance === null) return u;
	let E = getComponentPublicInstance(currentRenderingInstance), M = u.dirs ||= [];
	for (let u = 0; u < T.length; u++) {
		let [P, F, I, R = EMPTY_OBJ] = T[u];
		P && (isFunction(P) && (P = {
			mounted: P,
			updated: P
		}), P.deep && traverse(F), M.push({
			dir: P,
			instance: E,
			value: F,
			oldValue: void 0,
			arg: I,
			modifiers: R
		}));
	}
	return u;
}
function invokeDirectiveHook(u, T, E, O) {
	let M = u.dirs, P = T && T.dirs;
	for (let F = 0; F < M.length; F++) {
		let I = M[F];
		P && (I.oldValue = P[F].value);
		let R = I.dir[O];
		R && (pauseTracking(), callWithAsyncErrorHandling(R, E, 8, [
			u.el,
			I,
			u,
			T
		]), resetTracking());
	}
}
var TeleportEndKey = Symbol("_vte"), isTeleport = (u) => u.__isTeleport, isTeleportDisabled = (u) => u && (u.disabled || u.disabled === ""), isTeleportDeferred = (u) => u && (u.defer || u.defer === ""), isTargetSVG = (u) => typeof SVGElement < "u" && u instanceof SVGElement, isTargetMathML = (u) => typeof MathMLElement == "function" && u instanceof MathMLElement, resolveTarget = (u, T) => {
	let E = u && u.to;
	return isString(E) ? T ? T(E) : null : E;
}, TeleportImpl = {
	name: "Teleport",
	__isTeleport: !0,
	process(u, T, E, O, M, P, F, I, R, V) {
		let { mc: U, pc: Dp, pbc: Op, o: { insert: kp, querySelector: Ap, createText: jp, createComment: Mp } } = V, Np = isTeleportDisabled(T.props), { shapeFlag: Pp, children: Fp, dynamicChildren: Ip } = T;
		if (u == null) {
			let u = T.el = jp(""), V = T.anchor = jp("");
			kp(u, E, O), kp(V, E, O);
			let Dp = (u, T) => {
				Pp & 16 && U(Fp, u, T, M, P, F, I, R);
			}, Op = () => {
				let u = T.target = resolveTarget(T.props, Ap), E = prepareAnchor(u, T, jp, kp);
				u && (F !== "svg" && isTargetSVG(u) ? F = "svg" : F !== "mathml" && isTargetMathML(u) && (F = "mathml"), M && M.isCE && (M.ce._teleportTargets || (M.ce._teleportTargets = /* @__PURE__ */ new Set())).add(u), Np || (Dp(u, E), updateCssVars(T, !1)));
			};
			Np && (Dp(E, V), updateCssVars(T, !0)), isTeleportDeferred(T.props) ? (T.el.__isMounted = !1, queuePostRenderEffect(() => {
				Op(), delete T.el.__isMounted;
			}, P)) : Op();
		} else {
			if (isTeleportDeferred(T.props) && u.el.__isMounted === !1) {
				queuePostRenderEffect(() => {
					TeleportImpl.process(u, T, E, O, M, P, F, I, R, V);
				}, P);
				return;
			}
			T.el = u.el, T.targetStart = u.targetStart;
			let U = T.anchor = u.anchor, kp = T.target = u.target, jp = T.targetAnchor = u.targetAnchor, Mp = isTeleportDisabled(u.props), Pp = Mp ? E : kp, Fp = Mp ? U : jp;
			if (F === "svg" || isTargetSVG(kp) ? F = "svg" : (F === "mathml" || isTargetMathML(kp)) && (F = "mathml"), Ip ? (Op(u.dynamicChildren, Ip, Pp, M, P, F, I), traverseStaticChildren(u, T, !0)) : R || Dp(u, T, Pp, Fp, M, P, F, I, !1), Np) Mp ? T.props && u.props && T.props.to !== u.props.to && (T.props.to = u.props.to) : moveTeleport(T, E, U, V, 1);
			else if ((T.props && T.props.to) !== (u.props && u.props.to)) {
				let u = T.target = resolveTarget(T.props, Ap);
				u && moveTeleport(T, u, null, V, 0);
			} else Mp && moveTeleport(T, kp, jp, V, 1);
			updateCssVars(T, Np);
		}
	},
	remove(u, T, E, { um: O, o: { remove: M } }, P) {
		let { shapeFlag: F, children: I, anchor: R, targetStart: V, targetAnchor: U, target: Dp, props: Op } = u;
		if (Dp && (M(V), M(U)), P && M(R), F & 16) {
			let u = P || !isTeleportDisabled(Op);
			for (let M = 0; M < I.length; M++) {
				let P = I[M];
				O(P, T, E, u, !!P.dynamicChildren);
			}
		}
	},
	move: moveTeleport,
	hydrate: hydrateTeleport
};
function moveTeleport(u, T, E, { o: { insert: O }, m: M }, P = 2) {
	P === 0 && O(u.targetAnchor, T, E);
	let { el: F, anchor: I, shapeFlag: R, children: V, props: U } = u, Dp = P === 2;
	if (Dp && O(F, T, E), (!Dp || isTeleportDisabled(U)) && R & 16) for (let u = 0; u < V.length; u++) M(V[u], T, E, 2);
	Dp && O(I, T, E);
}
function hydrateTeleport(u, T, E, O, M, P, { o: { nextSibling: F, parentNode: I, querySelector: R, insert: V, createText: U } }, Dp) {
	function Op(u, T, R, V) {
		T.anchor = Dp(F(u), T, I(u), E, O, M, P), T.targetStart = R, T.targetAnchor = V;
	}
	let kp = T.target = resolveTarget(T.props, R), Ap = isTeleportDisabled(T.props);
	if (kp) {
		let I = kp._lpa || kp.firstChild;
		if (T.shapeFlag & 16) if (Ap) Op(u, T, I, I && F(I));
		else {
			T.anchor = F(u);
			let R = I;
			for (; R;) {
				if (R && R.nodeType === 8) {
					if (R.data === "teleport start anchor") T.targetStart = R;
					else if (R.data === "teleport anchor") {
						T.targetAnchor = R, kp._lpa = T.targetAnchor && F(T.targetAnchor);
						break;
					}
				}
				R = F(R);
			}
			T.targetAnchor || prepareAnchor(kp, T, U, V), Dp(I && F(I), T, kp, E, O, M, P);
		}
		updateCssVars(T, Ap);
	} else Ap && T.shapeFlag & 16 && Op(u, T, u, F(u));
	return T.anchor && F(T.anchor);
}
var Teleport = TeleportImpl;
function updateCssVars(u, T) {
	let E = u.ctx;
	if (E && E.ut) {
		let O, M;
		for (T ? (O = u.el, M = u.anchor) : (O = u.targetStart, M = u.targetAnchor); O && O !== M;) O.nodeType === 1 && O.setAttribute("data-v-owner", E.uid), O = O.nextSibling;
		E.ut();
	}
}
function prepareAnchor(u, T, E, O) {
	let M = T.targetStart = E(""), P = T.targetAnchor = E("");
	return M[TeleportEndKey] = P, u && (O(M, u), O(P, u)), P;
}
var leaveCbKey = Symbol("_leaveCb"), enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
	let u = {
		isMounted: !1,
		isLeaving: !1,
		isUnmounting: !1,
		leavingVNodes: /* @__PURE__ */ new Map()
	};
	return onMounted(() => {
		u.isMounted = !0;
	}), onBeforeUnmount(() => {
		u.isUnmounting = !0;
	}), u;
}
var TransitionHookValidator = [Function, Array], BaseTransitionPropsValidators = {
	mode: String,
	appear: Boolean,
	persisted: Boolean,
	onBeforeEnter: TransitionHookValidator,
	onEnter: TransitionHookValidator,
	onAfterEnter: TransitionHookValidator,
	onEnterCancelled: TransitionHookValidator,
	onBeforeLeave: TransitionHookValidator,
	onLeave: TransitionHookValidator,
	onAfterLeave: TransitionHookValidator,
	onLeaveCancelled: TransitionHookValidator,
	onBeforeAppear: TransitionHookValidator,
	onAppear: TransitionHookValidator,
	onAfterAppear: TransitionHookValidator,
	onAppearCancelled: TransitionHookValidator
}, recursiveGetSubtree = (u) => {
	let T = u.subTree;
	return T.component ? recursiveGetSubtree(T.component) : T;
}, BaseTransitionImpl = {
	name: "BaseTransition",
	props: BaseTransitionPropsValidators,
	setup(u, { slots: T }) {
		let E = getCurrentInstance(), O = useTransitionState();
		return () => {
			let M = T.default && getTransitionRawChildren(T.default(), !0);
			if (!M || !M.length) return;
			let P = findNonCommentChild(M), F = toRaw(u), { mode: I } = F;
			if (O.isLeaving) return emptyPlaceholder(P);
			let R = getInnerChild$1(P);
			if (!R) return emptyPlaceholder(P);
			let V = resolveTransitionHooks(R, F, O, E, (u) => V = u);
			R.type !== Comment && setTransitionHooks(R, V);
			let U = E.subTree && getInnerChild$1(E.subTree);
			if (U && U.type !== Comment && !isSameVNodeType(U, R) && recursiveGetSubtree(E).type !== Comment) {
				let u = resolveTransitionHooks(U, F, O, E);
				if (setTransitionHooks(U, u), I === "out-in" && R.type !== Comment) return O.isLeaving = !0, u.afterLeave = () => {
					O.isLeaving = !1, E.job.flags & 8 || E.update(), delete u.afterLeave, U = void 0;
				}, emptyPlaceholder(P);
				I === "in-out" && R.type !== Comment ? u.delayLeave = (u, T, E) => {
					let M = getLeavingNodesForType(O, U);
					M[String(U.key)] = U, u[leaveCbKey] = () => {
						T(), u[leaveCbKey] = void 0, delete V.delayedLeave, U = void 0;
					}, V.delayedLeave = () => {
						E(), delete V.delayedLeave, U = void 0;
					};
				} : U = void 0;
			} else U &&= void 0;
			return P;
		};
	}
};
function findNonCommentChild(u) {
	let T = u[0];
	if (u.length > 1) {
		for (let E of u) if (E.type !== Comment) {
			T = E;
			break;
		}
	}
	return T;
}
var BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(u, T) {
	let { leavingVNodes: E } = u, O = E.get(T.type);
	return O || (O = /* @__PURE__ */ Object.create(null), E.set(T.type, O)), O;
}
function resolveTransitionHooks(u, T, E, O, M) {
	let { appear: P, mode: F, persisted: I = !1, onBeforeEnter: R, onEnter: V, onAfterEnter: U, onEnterCancelled: Dp, onBeforeLeave: Op, onLeave: Ap, onAfterLeave: jp, onLeaveCancelled: Mp, onBeforeAppear: Np, onAppear: Pp, onAfterAppear: Fp, onAppearCancelled: Ip } = T, Lp = String(u.key), Rp = getLeavingNodesForType(E, u), zp = (u, T) => {
		u && callWithAsyncErrorHandling(u, O, 9, T);
	}, Bp = (u, T) => {
		let E = T[1];
		zp(u, T), isArray(u) ? u.every((u) => u.length <= 1) && E() : u.length <= 1 && E();
	}, Vp = {
		mode: F,
		persisted: I,
		beforeEnter(T) {
			let O = R;
			if (!E.isMounted) if (P) O = Np || R;
			else return;
			T[leaveCbKey] && T[leaveCbKey](!0);
			let M = Rp[Lp];
			M && isSameVNodeType(u, M) && M.el[leaveCbKey] && M.el[leaveCbKey](), zp(O, [T]);
		},
		enter(u) {
			let T = V, O = U, M = Dp;
			if (!E.isMounted) if (P) T = Pp || V, O = Fp || U, M = Ip || Dp;
			else return;
			let F = !1, I = u[enterCbKey$1] = (T) => {
				F || (F = !0, zp(T ? M : O, [u]), Vp.delayedLeave && Vp.delayedLeave(), u[enterCbKey$1] = void 0);
			};
			T ? Bp(T, [u, I]) : I();
		},
		leave(T, O) {
			let M = String(u.key);
			if (T[enterCbKey$1] && T[enterCbKey$1](!0), E.isUnmounting) return O();
			zp(Op, [T]);
			let P = !1, F = T[leaveCbKey] = (E) => {
				P || (P = !0, O(), zp(E ? Mp : jp, [T]), T[leaveCbKey] = void 0, Rp[M] === u && delete Rp[M]);
			};
			Rp[M] = u, Ap ? Bp(Ap, [T, F]) : F();
		},
		clone(u) {
			let P = resolveTransitionHooks(u, T, E, O, M);
			return M && M(P), P;
		}
	};
	return Vp;
}
function emptyPlaceholder(u) {
	if (isKeepAlive(u)) return u = cloneVNode(u), u.children = null, u;
}
function getInnerChild$1(u) {
	if (!isKeepAlive(u)) return isTeleport(u.type) && u.children ? findNonCommentChild(u.children) : u;
	if (u.component) return u.component.subTree;
	let { shapeFlag: T, children: E } = u;
	if (E) {
		if (T & 16) return E[0];
		if (T & 32 && isFunction(E.default)) return E.default();
	}
}
function setTransitionHooks(u, T) {
	u.shapeFlag & 6 && u.component ? (u.transition = T, setTransitionHooks(u.component.subTree, T)) : u.shapeFlag & 128 ? (u.ssContent.transition = T.clone(u.ssContent), u.ssFallback.transition = T.clone(u.ssFallback)) : u.transition = T;
}
function getTransitionRawChildren(u, T = !1, E) {
	let O = [], M = 0;
	for (let P = 0; P < u.length; P++) {
		let F = u[P], I = E == null ? F.key : String(E) + String(F.key == null ? P : F.key);
		F.type === Fragment ? (F.patchFlag & 128 && M++, O = O.concat(getTransitionRawChildren(F.children, T, I))) : (T || F.type !== Comment) && O.push(I == null ? F : cloneVNode(F, { key: I }));
	}
	if (M > 1) for (let u = 0; u < O.length; u++) O[u].patchFlag = -2;
	return O;
}
/* @__NO_SIDE_EFFECTS__ */
function defineComponent(u, T) {
	return isFunction(u) ? /* @__PURE__ */ (() => extend({ name: u.name }, T, { setup: u }))() : u;
}
function useId$1() {
	let u = getCurrentInstance();
	return u ? (u.appContext.config.idPrefix || "v") + "-" + u.ids[0] + u.ids[1]++ : "";
}
function markAsyncBoundary(u) {
	u.ids = [
		u.ids[0] + u.ids[2]++ + "-",
		0,
		0
	];
}
function useTemplateRef(u) {
	let T = getCurrentInstance(), E = shallowRef(null);
	if (T) {
		let M = T.refs === EMPTY_OBJ ? T.refs = {} : T.refs;
		Object.defineProperty(M, u, {
			enumerable: !0,
			get: () => E.value,
			set: (u) => E.value = u
		});
	}
	return E;
}
var pendingSetRefMap = /* @__PURE__ */ new WeakMap();
function setRef(u, T, E, M, P = !1) {
	if (isArray(u)) {
		u.forEach((u, O) => setRef(u, T && (isArray(T) ? T[O] : T), E, M, P));
		return;
	}
	if (isAsyncWrapper(M) && !P) {
		M.shapeFlag & 512 && M.type.__asyncResolved && M.component.subTree.component && setRef(u, T, E, M.component.subTree);
		return;
	}
	let I = M.shapeFlag & 4 ? getComponentPublicInstance(M.component) : M.el, R = P ? null : I, { i: V, r: Dp } = u, Ap = T && T.r, jp = V.refs === EMPTY_OBJ ? V.refs = {} : V.refs, Mp = V.setupState, Np = toRaw(Mp), Ip = Mp === EMPTY_OBJ ? NO : (u) => hasOwn$2(Np, u), Lp = (u) => !0;
	if (Ap != null && Ap !== Dp) {
		if (invalidatePendingSetRef(T), isString(Ap)) jp[Ap] = null, Ip(Ap) && (Mp[Ap] = null);
		else if (isRef(Ap)) {
			Lp(Ap) && (Ap.value = null);
			let u = T;
			u.k && (jp[u.k] = null);
		}
	}
	if (isFunction(Dp)) callWithErrorHandling(Dp, V, 12, [R, jp]);
	else {
		let T = isString(Dp), O = isRef(Dp);
		if (T || O) {
			let M = () => {
				if (u.f) {
					let E = T ? Ip(Dp) ? Mp[Dp] : jp[Dp] : Lp(Dp) || !u.k ? Dp.value : jp[u.k];
					if (P) isArray(E) && remove(E, I);
					else if (isArray(E)) E.includes(I) || E.push(I);
					else if (T) jp[Dp] = [I], Ip(Dp) && (Mp[Dp] = jp[Dp]);
					else {
						let T = [I];
						Lp(Dp) && (Dp.value = T), u.k && (jp[u.k] = T);
					}
				} else T ? (jp[Dp] = R, Ip(Dp) && (Mp[Dp] = R)) : O && (Lp(Dp) && (Dp.value = R), u.k && (jp[u.k] = R));
			};
			if (R) {
				let T = () => {
					M(), pendingSetRefMap.delete(u);
				};
				T.id = -1, pendingSetRefMap.set(u, T), queuePostRenderEffect(T, E);
			} else invalidatePendingSetRef(u), M();
		}
	}
}
function invalidatePendingSetRef(u) {
	let T = pendingSetRefMap.get(u);
	T && (T.flags |= 8, pendingSetRefMap.delete(u));
}
var hasLoggedMismatchError = !1, logMismatchError = () => {
	hasLoggedMismatchError ||= (console.error("Hydration completed but contains mismatches."), !0);
}, isSVGContainer = (u) => u.namespaceURI.includes("svg") && u.tagName !== "foreignObject", isMathMLContainer = (u) => u.namespaceURI.includes("MathML"), getContainerType = (u) => {
	if (u.nodeType === 1) {
		if (isSVGContainer(u)) return "svg";
		if (isMathMLContainer(u)) return "mathml";
	}
}, isComment = (u) => u.nodeType === 8;
function createHydrationFunctions(u) {
	let { mt: T, p: E, o: { patchProp: O, createText: M, nextSibling: P, parentNode: F, remove: R, insert: V, createComment: U } } = u, Dp = (u, T) => {
		if (!T.hasChildNodes()) {
			E(null, u, T), flushPostFlushCbs(), T._vnode = u;
			return;
		}
		Op(T.firstChild, u, null, null, null), flushPostFlushCbs(), T._vnode = u;
	}, Op = (E, O, I, R, U, Dp = !1) => {
		Dp ||= !!O.dynamicChildren;
		let Ip = isComment(E) && E.data === "[", Lp = () => Mp(E, O, I, R, U, Ip), { type: Rp, ref: zp, shapeFlag: Bp, patchFlag: Vp } = O, Hp = E.nodeType;
		O.el = E, Vp === -2 && (Dp = !1, O.dynamicChildren = null);
		let Up = null;
		switch (Rp) {
			case Text:
				Hp === 3 ? (E.data !== O.children && (logMismatchError(), E.data = O.children), Up = P(E)) : O.children === "" ? (V(O.el = M(""), F(E), E), Up = E) : Up = Lp();
				break;
			case Comment:
				Fp(E) ? (Up = P(E), Pp(O.el = E.content.firstChild, E, I)) : Up = Hp !== 8 || Ip ? Lp() : P(E);
				break;
			case Static:
				if (Ip && (E = P(E), Hp = E.nodeType), Hp === 1 || Hp === 3) {
					Up = E;
					let u = !O.children.length;
					for (let T = 0; T < O.staticCount; T++) u && (O.children += Up.nodeType === 1 ? Up.outerHTML : Up.data), T === O.staticCount - 1 && (O.anchor = Up), Up = P(Up);
					return Ip ? P(Up) : Up;
				} else Lp();
				break;
			case Fragment:
				Up = Ip ? jp(E, O, I, R, U, Dp) : Lp();
				break;
			default: if (Bp & 1) Up = (Hp !== 1 || O.type.toLowerCase() !== E.tagName.toLowerCase()) && !Fp(E) ? Lp() : kp(E, O, I, R, U, Dp);
			else if (Bp & 6) {
				O.slotScopeIds = U;
				let u = F(E);
				if (Up = Ip ? Np(E) : isComment(E) && E.data === "teleport start" ? Np(E, E.data, "teleport end") : P(E), T(O, u, null, I, R, getContainerType(u), Dp), isAsyncWrapper(O) && !O.type.__asyncResolved) {
					let T;
					Ip ? (T = createVNode(Fragment), T.anchor = Up ? Up.previousSibling : u.lastChild) : T = E.nodeType === 3 ? createTextVNode("") : createVNode("div"), T.el = E, O.component.subTree = T;
				}
			} else Bp & 64 ? Up = Hp === 8 ? O.type.hydrate(E, O, I, R, U, Dp, u, Ap) : Lp() : Bp & 128 && (Up = O.type.hydrate(E, O, I, R, getContainerType(F(E)), U, Dp, u, Op));
		}
		return zp != null && setRef(zp, null, R, O), Up;
	}, kp = (u, T, E, M, P, F) => {
		F ||= !!T.dynamicChildren;
		let { type: V, props: U, patchFlag: Dp, shapeFlag: Op, dirs: kp, transition: jp } = T, Mp = V === "input" || V === "option";
		if (Mp || Dp !== -1) {
			kp && invokeDirectiveHook(T, null, E, "created");
			let V = !1;
			if (Fp(u)) {
				V = needTransition(null, jp) && E && E.vnode.props && E.vnode.props.appear;
				let O = u.content.firstChild;
				if (V) {
					let u = O.getAttribute("class");
					u && (O.$cls = u), jp.beforeEnter(O);
				}
				Pp(O, u, E), T.el = u = O;
			}
			if (Op & 16 && !(U && (U.innerHTML || U.textContent))) {
				let O = Ap(u.firstChild, T, u, E, M, P, F);
				for (; O;) {
					isMismatchAllowed(u, 1) || logMismatchError();
					let T = O;
					O = O.nextSibling, R(T);
				}
			} else if (Op & 8) {
				let E = T.children;
				E[0] === "\n" && (u.tagName === "PRE" || u.tagName === "TEXTAREA") && (E = E.slice(1)), u.textContent !== E && (isMismatchAllowed(u, 0) || logMismatchError(), u.textContent = T.children);
			}
			if (U) {
				if (Mp || !F || Dp & 48) {
					let T = u.tagName.includes("-");
					for (let M in U) (Mp && (M.endsWith("value") || M === "indeterminate") || isOn(M) && !isReservedProp(M) || M[0] === "." || T) && O(u, M, null, U[M], void 0, E);
				} else if (U.onClick) O(u, "onClick", null, U.onClick, void 0, E);
				else if (Dp & 4 && isReactive(U.style)) for (let u in U.style) U.style[u];
			}
			let Np;
			(Np = U && U.onVnodeBeforeMount) && invokeVNodeHook(Np, E, T), kp && invokeDirectiveHook(T, null, E, "beforeMount"), ((Np = U && U.onVnodeMounted) || kp || V) && queueEffectWithSuspense(() => {
				Np && invokeVNodeHook(Np, E, T), V && jp.enter(u), kp && invokeDirectiveHook(T, null, E, "mounted");
			}, M);
		}
		return u.nextSibling;
	}, Ap = (u, T, O, F, I, R, U) => {
		U ||= !!T.dynamicChildren;
		let Dp = T.children, kp = Dp.length;
		for (let T = 0; T < kp; T++) {
			let Ap = U ? Dp[T] : Dp[T] = normalizeVNode(Dp[T]), jp = Ap.type === Text;
			u ? (jp && !U && T + 1 < kp && normalizeVNode(Dp[T + 1]).type === Text && (V(M(u.data.slice(Ap.children.length)), O, P(u)), u.data = Ap.children), u = Op(u, Ap, F, I, R, U)) : jp && !Ap.children ? V(Ap.el = M(""), O) : (isMismatchAllowed(O, 1) || logMismatchError(), E(null, Ap, O, null, F, I, getContainerType(O), R));
		}
		return u;
	}, jp = (u, T, E, O, M, I) => {
		let { slotScopeIds: R } = T;
		R && (M = M ? M.concat(R) : R);
		let Dp = F(u), Op = Ap(P(u), T, Dp, E, O, M, I);
		return Op && isComment(Op) && Op.data === "]" ? P(T.anchor = Op) : (logMismatchError(), V(T.anchor = U("]"), Dp, Op), Op);
	}, Mp = (u, T, O, M, I, V) => {
		if (isMismatchAllowed(u.parentElement, 1) || logMismatchError(), T.el = null, V) {
			let T = Np(u);
			for (;;) {
				let E = P(u);
				if (E && E !== T) R(E);
				else break;
			}
		}
		let U = P(u), Dp = F(u);
		return R(u), E(null, T, Dp, U, O, M, getContainerType(Dp), I), O && (O.vnode.el = T.el, updateHOCHostEl(O, T.el)), U;
	}, Np = (u, T = "[", E = "]") => {
		let O = 0;
		for (; u;) if (u = P(u), u && isComment(u) && (u.data === T && O++, u.data === E)) {
			if (O === 0) return P(u);
			O--;
		}
		return u;
	}, Pp = (u, T, E) => {
		let O = T.parentNode;
		O && O.replaceChild(u, T);
		let M = E;
		for (; M;) M.vnode.el === T && (M.vnode.el = M.subTree.el = u), M = M.parent;
	}, Fp = (u) => u.nodeType === 1 && u.tagName === "TEMPLATE";
	return [Dp, Op];
}
var allowMismatchAttr = "data-allow-mismatch", MismatchTypeString = {
	0: "text",
	1: "children",
	2: "class",
	3: "style",
	4: "attribute"
};
function isMismatchAllowed(u, T) {
	if (T === 0 || T === 1) for (; u && !u.hasAttribute(allowMismatchAttr);) u = u.parentElement;
	let E = u && u.getAttribute(allowMismatchAttr);
	if (E == null) return !1;
	if (E === "") return !0;
	{
		let u = E.split(",");
		return T === 0 && u.includes("children") ? !0 : u.includes(MismatchTypeString[T]);
	}
}
var requestIdleCallback = getGlobalThis().requestIdleCallback || ((u) => setTimeout(u, 1)), cancelIdleCallback = getGlobalThis().cancelIdleCallback || ((u) => clearTimeout(u)), hydrateOnIdle = (u = 1e4) => (T) => {
	let E = requestIdleCallback(T, { timeout: u });
	return () => cancelIdleCallback(E);
};
function elementIsVisibleInViewport(u) {
	let { top: T, left: E, bottom: O, right: M } = u.getBoundingClientRect(), { innerHeight: P, innerWidth: F } = window;
	return (T > 0 && T < P || O > 0 && O < P) && (E > 0 && E < F || M > 0 && M < F);
}
var hydrateOnVisible = (u) => (T, E) => {
	let O = new IntersectionObserver((u) => {
		for (let E of u) if (E.isIntersecting) {
			O.disconnect(), T();
			break;
		}
	}, u);
	return E((u) => {
		if (u instanceof Element) {
			if (elementIsVisibleInViewport(u)) return T(), O.disconnect(), !1;
			O.observe(u);
		}
	}), () => O.disconnect();
}, hydrateOnMediaQuery = (u) => (T) => {
	if (u) {
		let E = matchMedia(u);
		if (E.matches) T();
		else return E.addEventListener("change", T, { once: !0 }), () => E.removeEventListener("change", T);
	}
}, hydrateOnInteraction = (u = []) => (T, E) => {
	isString(u) && (u = [u]);
	let O = !1, M = (u) => {
		O || (O = !0, P(), T(), u.target.dispatchEvent(new u.constructor(u.type, u)));
	}, P = () => {
		E((T) => {
			for (let E of u) T.removeEventListener(E, M);
		});
	};
	return E((T) => {
		for (let E of u) T.addEventListener(E, M, { once: !0 });
	}), P;
};
function forEachElement(u, T) {
	if (isComment(u) && u.data === "[") {
		let E = 1, O = u.nextSibling;
		for (; O;) {
			if (O.nodeType === 1) {
				if (T(O) === !1) break;
			} else if (isComment(O)) if (O.data === "]") {
				if (--E === 0) break;
			} else O.data === "[" && E++;
			O = O.nextSibling;
		}
	} else T(u);
}
var isAsyncWrapper = (u) => !!u.type.__asyncLoader;
/* @__NO_SIDE_EFFECTS__ */
function defineAsyncComponent(u) {
	isFunction(u) && (u = { loader: u });
	let { loader: T, loadingComponent: E, errorComponent: O, delay: M = 200, hydrate: P, timeout: F, suspensible: I = !0, onError: R } = u, V = null, U, Dp = 0, Op = () => (Dp++, V = null, kp()), kp = () => {
		let u;
		return V || (u = V = T().catch((u) => {
			if (u = u instanceof Error ? u : Error(String(u)), R) return new Promise((T, E) => {
				R(u, () => T(Op()), () => E(u), Dp + 1);
			});
			throw u;
		}).then((T) => u !== V && V ? V : (T && (T.__esModule || T[Symbol.toStringTag] === "Module") && (T = T.default), U = T, T)));
	};
	return /* @__PURE__ */ defineComponent({
		name: "AsyncComponentWrapper",
		__asyncLoader: kp,
		__asyncHydrate(u, T, E) {
			let O = !1;
			(T.bu ||= []).push(() => O = !0);
			let M = () => {
				O || E();
			}, F = P ? () => {
				let E = P(M, (T) => forEachElement(u, T));
				E && (T.bum ||= []).push(E);
			} : M;
			U ? F() : kp().then(() => !T.isUnmounted && F());
		},
		get __asyncResolved() {
			return U;
		},
		setup() {
			let u = currentInstance;
			if (markAsyncBoundary(u), U) return () => createInnerComp(U, u);
			let T = (T) => {
				V = null, handleError(T, u, 13, !O);
			};
			if (I && u.suspense || isInSSRComponentSetup) return kp().then((T) => () => createInnerComp(T, u)).catch((u) => (T(u), () => O ? createVNode(O, { error: u }) : null));
			let P = ref(!1), R = ref(), Dp = ref(!!M);
			return M && setTimeout(() => {
				Dp.value = !1;
			}, M), F != null && setTimeout(() => {
				if (!P.value && !R.value) {
					let u = /* @__PURE__ */ Error(`Async component timed out after ${F}ms.`);
					T(u), R.value = u;
				}
			}, F), kp().then(() => {
				P.value = !0, u.parent && isKeepAlive(u.parent.vnode) && u.parent.update();
			}).catch((u) => {
				T(u), R.value = u;
			}), () => {
				if (P.value && U) return createInnerComp(U, u);
				if (R.value && O) return createVNode(O, { error: R.value });
				if (E && !Dp.value) return createVNode(E);
			};
		}
	});
}
function createInnerComp(u, T) {
	let { ref: E, props: O, children: M, ce: P } = T.vnode, F = createVNode(u, O, M);
	return F.ref = E, F.ce = P, delete T.vnode.ce, F;
}
var isKeepAlive = (u) => u.type.__isKeepAlive, KeepAlive = {
	name: "KeepAlive",
	__isKeepAlive: !0,
	props: {
		include: [
			String,
			RegExp,
			Array
		],
		exclude: [
			String,
			RegExp,
			Array
		],
		max: [String, Number]
	},
	setup(u, { slots: T }) {
		let E = getCurrentInstance(), O = E.ctx;
		if (!O.renderer) return () => {
			let u = T.default && T.default();
			return u && u.length === 1 ? u[0] : u;
		};
		let M = /* @__PURE__ */ new Map(), P = /* @__PURE__ */ new Set(), F = null, I = E.suspense, { renderer: { p: R, m: V, um: U, o: { createElement: Dp } } } = O, Op = Dp("div");
		O.activate = (u, T, E, O, M) => {
			let P = u.component;
			V(u, T, E, 0, I), R(P.vnode, u, T, E, P, I, O, u.slotScopeIds, M), queuePostRenderEffect(() => {
				P.isDeactivated = !1, P.a && invokeArrayFns(P.a);
				let T = u.props && u.props.onVnodeMounted;
				T && invokeVNodeHook(T, P.parent, u);
			}, I);
		}, O.deactivate = (u) => {
			let T = u.component;
			invalidateMount(T.m), invalidateMount(T.a), V(u, Op, null, 1, I), queuePostRenderEffect(() => {
				T.da && invokeArrayFns(T.da);
				let E = u.props && u.props.onVnodeUnmounted;
				E && invokeVNodeHook(E, T.parent, u), T.isDeactivated = !0;
			}, I);
		};
		function kp(u) {
			resetShapeFlag(u), U(u, E, I, !0);
		}
		function Ap(u) {
			M.forEach((T, E) => {
				let O = getComponentName(T.type);
				O && !u(O) && jp(E);
			});
		}
		function jp(u) {
			let T = M.get(u);
			T && (!F || !isSameVNodeType(T, F)) ? kp(T) : F && resetShapeFlag(F), M.delete(u), P.delete(u);
		}
		watch(() => [u.include, u.exclude], ([u, T]) => {
			u && Ap((T) => matches(u, T)), T && Ap((u) => !matches(T, u));
		}, {
			flush: "post",
			deep: !0
		});
		let Mp = null, Np = () => {
			Mp != null && (isSuspense(E.subTree.type) ? queuePostRenderEffect(() => {
				M.set(Mp, getInnerChild(E.subTree));
			}, E.subTree.suspense) : M.set(Mp, getInnerChild(E.subTree)));
		};
		return onMounted(Np), onUpdated(Np), onBeforeUnmount(() => {
			M.forEach((u) => {
				let { subTree: T, suspense: O } = E, M = getInnerChild(T);
				if (u.type === M.type && u.key === M.key) {
					resetShapeFlag(M);
					let u = M.component.da;
					u && queuePostRenderEffect(u, O);
					return;
				}
				kp(u);
			});
		}), () => {
			if (Mp = null, !T.default) return F = null;
			let E = T.default(), O = E[0];
			if (E.length > 1) return F = null, E;
			if (!isVNode(O) || !(O.shapeFlag & 4) && !(O.shapeFlag & 128)) return F = null, O;
			let I = getInnerChild(O);
			if (I.type === Comment) return F = null, I;
			let R = I.type, V = getComponentName(isAsyncWrapper(I) ? I.type.__asyncResolved || {} : R), { include: U, exclude: Dp, max: Op } = u;
			if (U && (!V || !matches(U, V)) || Dp && V && matches(Dp, V)) return I.shapeFlag &= -257, F = I, O;
			let kp = I.key == null ? R : I.key, Ap = M.get(kp);
			return I.el && (I = cloneVNode(I), O.shapeFlag & 128 && (O.ssContent = I)), Mp = kp, Ap ? (I.el = Ap.el, I.component = Ap.component, I.transition && setTransitionHooks(I, I.transition), I.shapeFlag |= 512, P.delete(kp), P.add(kp)) : (P.add(kp), Op && P.size > parseInt(Op, 10) && jp(P.values().next().value)), I.shapeFlag |= 256, F = I, isSuspense(O.type) ? O : I;
		};
	}
};
function matches(u, T) {
	return isArray(u) ? u.some((u) => matches(u, T)) : isString(u) ? u.split(",").includes(T) : isRegExp(u) ? (u.lastIndex = 0, u.test(T)) : !1;
}
function onActivated(u, T) {
	registerKeepAliveHook(u, "a", T);
}
function onDeactivated(u, T) {
	registerKeepAliveHook(u, "da", T);
}
function registerKeepAliveHook(u, T, E = currentInstance) {
	let O = u.__wdc ||= () => {
		let T = E;
		for (; T;) {
			if (T.isDeactivated) return;
			T = T.parent;
		}
		return u();
	};
	if (injectHook(T, O, E), E) {
		let u = E.parent;
		for (; u && u.parent;) isKeepAlive(u.parent.vnode) && injectToKeepAliveRoot(O, T, E, u), u = u.parent;
	}
}
function injectToKeepAliveRoot(u, T, E, O) {
	let M = injectHook(T, u, O, !0);
	onUnmounted(() => {
		remove(O[T], M);
	}, E);
}
function resetShapeFlag(u) {
	u.shapeFlag &= -257, u.shapeFlag &= -513;
}
function getInnerChild(u) {
	return u.shapeFlag & 128 ? u.ssContent : u;
}
function injectHook(u, T, E = currentInstance, O = !1) {
	if (E) {
		let M = E[u] || (E[u] = []), P = T.__weh ||= (...O) => {
			pauseTracking();
			let M = setCurrentInstance(E), P = callWithAsyncErrorHandling(T, E, u, O);
			return M(), resetTracking(), P;
		};
		return O ? M.unshift(P) : M.push(P), P;
	}
}
var createHook = (u) => (T, E = currentInstance) => {
	(!isInSSRComponentSetup || u === "sp") && injectHook(u, (...u) => T(...u), E);
}, onBeforeMount = createHook("bm"), onMounted = createHook("m"), onBeforeUpdate = createHook("bu"), onUpdated = createHook("u"), onBeforeUnmount = createHook("bum"), onUnmounted = createHook("um"), onServerPrefetch = createHook("sp"), onRenderTriggered = createHook("rtg"), onRenderTracked = createHook("rtc");
function onErrorCaptured(u, T = currentInstance) {
	injectHook("ec", u, T);
}
var COMPONENTS = "components", DIRECTIVES = "directives";
function resolveComponent(u, T) {
	return resolveAsset(COMPONENTS, u, !0, T) || u;
}
var NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(u) {
	return isString(u) ? resolveAsset(COMPONENTS, u, !1) || u : u || NULL_DYNAMIC_COMPONENT;
}
function resolveDirective(u) {
	return resolveAsset(DIRECTIVES, u);
}
function resolveAsset(u, T, E = !0, O = !1) {
	let M = currentRenderingInstance || currentInstance;
	if (M) {
		let E = M.type;
		if (u === COMPONENTS) {
			let u = getComponentName(E, !1);
			if (u && (u === T || u === camelize$2(T) || u === capitalize(camelize$2(T)))) return E;
		}
		let P = resolve(M[u] || E[u], T) || resolve(M.appContext[u], T);
		return !P && O ? E : P;
	}
}
function resolve(u, T) {
	return u && (u[T] || u[camelize$2(T)] || u[capitalize(camelize$2(T))]);
}
function renderList(u, T, E, O) {
	let M, P = E && E[O], F = isArray(u);
	if (F || isString(u)) {
		let E = F && isReactive(u), O = !1, I = !1;
		E && (O = !isShallow(u), I = isReadonly(u), u = shallowReadArray(u)), M = Array(u.length);
		for (let E = 0, F = u.length; E < F; E++) M[E] = T(O ? I ? toReadonly(toReactive(u[E])) : toReactive(u[E]) : u[E], E, void 0, P && P[E]);
	} else if (typeof u == "number") {
		M = Array(u);
		for (let E = 0; E < u; E++) M[E] = T(E + 1, E, void 0, P && P[E]);
	} else if (isObject$2(u)) if (u[Symbol.iterator]) M = Array.from(u, (u, E) => T(u, E, void 0, P && P[E]));
	else {
		let E = Object.keys(u);
		M = Array(E.length);
		for (let O = 0, F = E.length; O < F; O++) {
			let F = E[O];
			M[O] = T(u[F], F, O, P && P[O]);
		}
	}
	else M = [];
	return E && (E[O] = M), M;
}
function createSlots(u, T) {
	for (let E = 0; E < T.length; E++) {
		let O = T[E];
		if (isArray(O)) for (let T = 0; T < O.length; T++) u[O[T].name] = O[T].fn;
		else O && (u[O.name] = O.key ? (...u) => {
			let T = O.fn(...u);
			return T && (T.key = O.key), T;
		} : O.fn);
	}
	return u;
}
function renderSlot(u, T, E = {}, O, M) {
	if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
		let u = Object.keys(E).length > 0;
		return T !== "default" && (E.name = T), openBlock(), createBlock(Fragment, null, [createVNode("slot", E, O && O())], u ? -2 : 64);
	}
	let P = u[T];
	P && P._c && (P._d = !1), openBlock();
	let F = P && ensureValidVNode(P(E)), I = E.key || F && F.key, R = createBlock(Fragment, { key: (I && !isSymbol(I) ? I : `_${T}`) + (!F && O ? "_fb" : "") }, F || (O ? O() : []), F && u._ === 1 ? 64 : -2);
	return !M && R.scopeId && (R.slotScopeIds = [R.scopeId + "-s"]), P && P._c && (P._d = !0), R;
}
function ensureValidVNode(u) {
	return u.some((u) => isVNode(u) ? !(u.type === Comment || u.type === Fragment && !ensureValidVNode(u.children)) : !0) ? u : null;
}
function toHandlers(u, T) {
	let E = {};
	for (let O in u) E[T && /[A-Z]/.test(O) ? `on:${O}` : toHandlerKey(O)] = u[O];
	return E;
}
var getPublicInstance = (u) => u ? isStatefulComponent(u) ? getComponentPublicInstance(u) : getPublicInstance(u.parent) : null, publicPropertiesMap = /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
	$: (u) => u,
	$el: (u) => u.vnode.el,
	$data: (u) => u.data,
	$props: (u) => u.props,
	$attrs: (u) => u.attrs,
	$slots: (u) => u.slots,
	$refs: (u) => u.refs,
	$parent: (u) => getPublicInstance(u.parent),
	$root: (u) => getPublicInstance(u.root),
	$host: (u) => u.ce,
	$emit: (u) => u.emit,
	$options: (u) => resolveMergedOptions(u),
	$forceUpdate: (u) => u.f ||= () => {
		queueJob(u.update);
	},
	$nextTick: (u) => u.n ||= nextTick.bind(u.proxy),
	$watch: (u) => instanceWatch.bind(u)
}), hasSetupBinding = (u, T) => u !== EMPTY_OBJ && !u.__isScriptSetup && hasOwn$2(u, T), PublicInstanceProxyHandlers = {
	get({ _: u }, T) {
		if (T === "__v_skip") return !0;
		let { ctx: E, setupState: M, data: P, props: F, accessCache: I, type: R, appContext: V } = u, U;
		if (T[0] !== "$") {
			let R = I[T];
			if (R !== void 0) switch (R) {
				case 1: return M[T];
				case 2: return P[T];
				case 4: return E[T];
				case 3: return F[T];
			}
			else if (hasSetupBinding(M, T)) return I[T] = 1, M[T];
			else if (P !== EMPTY_OBJ && hasOwn$2(P, T)) return I[T] = 2, P[T];
			else if ((U = u.propsOptions[0]) && hasOwn$2(U, T)) return I[T] = 3, F[T];
			else if (E !== EMPTY_OBJ && hasOwn$2(E, T)) return I[T] = 4, E[T];
			else shouldCacheAccess && (I[T] = 0);
		}
		let Dp = publicPropertiesMap[T], kp, Ap;
		if (Dp) return T === "$attrs" && track(u.attrs, "get", ""), Dp(u);
		if ((kp = R.__cssModules) && (kp = kp[T])) return kp;
		if (E !== EMPTY_OBJ && hasOwn$2(E, T)) return I[T] = 4, E[T];
		if (Ap = V.config.globalProperties, hasOwn$2(Ap, T)) return Ap[T];
	},
	set({ _: u }, T, E) {
		let { data: M, setupState: P, ctx: F } = u;
		return hasSetupBinding(P, T) ? (P[T] = E, !0) : M !== EMPTY_OBJ && hasOwn$2(M, T) ? (M[T] = E, !0) : hasOwn$2(u.props, T) || T[0] === "$" && T.slice(1) in u ? !1 : (F[T] = E, !0);
	},
	has({ _: { data: u, setupState: T, accessCache: E, ctx: M, appContext: P, propsOptions: F, type: I } }, R) {
		let V, U;
		return !!(E[R] || u !== EMPTY_OBJ && R[0] !== "$" && hasOwn$2(u, R) || hasSetupBinding(T, R) || (V = F[0]) && hasOwn$2(V, R) || hasOwn$2(M, R) || hasOwn$2(publicPropertiesMap, R) || hasOwn$2(P.config.globalProperties, R) || (U = I.__cssModules) && U[R]);
	},
	defineProperty(u, T, E) {
		return E.get == null ? hasOwn$2(E, "value") && this.set(u, T, E.value, null) : u._.accessCache[T] = 0, Reflect.defineProperty(u, T, E);
	}
}, RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend({}, PublicInstanceProxyHandlers, {
	get(u, T) {
		if (T !== Symbol.unscopables) return PublicInstanceProxyHandlers.get(u, T, u);
	},
	has(u, T) {
		return T[0] !== "_" && !isGloballyAllowed(T);
	}
});
function defineProps() {
	return null;
}
function defineEmits() {
	return null;
}
function defineExpose(u) {}
function defineOptions(u) {}
function defineSlots() {
	return null;
}
function defineModel() {}
function withDefaults(u, T) {
	return null;
}
function useSlots() {
	return getContext("useSlots").slots;
}
function useAttrs() {
	return getContext("useAttrs").attrs;
}
function getContext(u) {
	let T = getCurrentInstance();
	return T.setupContext ||= createSetupContext(T);
}
function normalizePropsOrEmits(u) {
	return isArray(u) ? u.reduce((u, T) => (u[T] = null, u), {}) : u;
}
function mergeDefaults(u, T) {
	let E = normalizePropsOrEmits(u);
	for (let u in T) {
		if (u.startsWith("__skip")) continue;
		let O = E[u];
		O ? isArray(O) || isFunction(O) ? O = E[u] = {
			type: O,
			default: T[u]
		} : O.default = T[u] : O === null && (O = E[u] = { default: T[u] }), O && T[`__skip_${u}`] && (O.skipFactory = !0);
	}
	return E;
}
function mergeModels(u, T) {
	return !u || !T ? u || T : isArray(u) && isArray(T) ? u.concat(T) : extend({}, normalizePropsOrEmits(u), normalizePropsOrEmits(T));
}
function createPropsRestProxy(u, T) {
	let E = {};
	for (let O in u) T.includes(O) || Object.defineProperty(E, O, {
		enumerable: !0,
		get: () => u[O]
	});
	return E;
}
function withAsyncContext(u) {
	let T = getCurrentInstance(), E = u();
	return unsetCurrentInstance(), isPromise(E) && (E = E.catch((u) => {
		throw setCurrentInstance(T), u;
	})), [E, () => setCurrentInstance(T)];
}
var shouldCacheAccess = !0;
function applyOptions(u) {
	let T = resolveMergedOptions(u), E = u.proxy, O = u.ctx;
	shouldCacheAccess = !1, T.beforeCreate && callHook$1(T.beforeCreate, u, "bc");
	let { data: M, computed: F, methods: I, watch: R, provide: V, inject: U, created: Dp, beforeMount: Op, mounted: Ap, beforeUpdate: jp, updated: Mp, activated: Np, deactivated: Fp, beforeDestroy: Ip, beforeUnmount: Rp, destroyed: zp, unmounted: Bp, render: Vp, renderTracked: Hp, renderTriggered: Up, errorCaptured: Wp, serverPrefetch: Gp, expose: Kp, inheritAttrs: qp, components: Jp, directives: Yp, filters: Xp } = T;
	if (U && resolveInjections(U, O, null), I) for (let u in I) {
		let T = I[u];
		isFunction(T) && (O[u] = T.bind(E));
	}
	if (M) {
		let T = M.call(E, E);
		isObject$2(T) && (u.data = reactive(T));
	}
	if (shouldCacheAccess = !0, F) for (let u in F) {
		let T = F[u], M = computed({
			get: isFunction(T) ? T.bind(E, E) : isFunction(T.get) ? T.get.bind(E, E) : NOOP,
			set: !isFunction(T) && isFunction(T.set) ? T.set.bind(E) : NOOP
		});
		Object.defineProperty(O, u, {
			enumerable: !0,
			configurable: !0,
			get: () => M.value,
			set: (u) => M.value = u
		});
	}
	if (R) for (let u in R) createWatcher(R[u], O, E, u);
	if (V) {
		let u = isFunction(V) ? V.call(E) : V;
		Reflect.ownKeys(u).forEach((T) => {
			provide(T, u[T]);
		});
	}
	Dp && callHook$1(Dp, u, "c");
	function Zp(u, T) {
		isArray(T) ? T.forEach((T) => u(T.bind(E))) : T && u(T.bind(E));
	}
	if (Zp(onBeforeMount, Op), Zp(onMounted, Ap), Zp(onBeforeUpdate, jp), Zp(onUpdated, Mp), Zp(onActivated, Np), Zp(onDeactivated, Fp), Zp(onErrorCaptured, Wp), Zp(onRenderTracked, Hp), Zp(onRenderTriggered, Up), Zp(onBeforeUnmount, Rp), Zp(onUnmounted, Bp), Zp(onServerPrefetch, Gp), isArray(Kp)) if (Kp.length) {
		let T = u.exposed ||= {};
		Kp.forEach((u) => {
			Object.defineProperty(T, u, {
				get: () => E[u],
				set: (T) => E[u] = T,
				enumerable: !0
			});
		});
	} else u.exposed ||= {};
	Vp && u.render === NOOP && (u.render = Vp), qp != null && (u.inheritAttrs = qp), Jp && (u.components = Jp), Yp && (u.directives = Yp), Gp && markAsyncBoundary(u);
}
function resolveInjections(u, T, E = NOOP) {
	for (let E in isArray(u) && (u = normalizeInject(u)), u) {
		let O = u[E], M;
		M = isObject$2(O) ? "default" in O ? inject(O.from || E, O.default, !0) : inject(O.from || E) : inject(O), isRef(M) ? Object.defineProperty(T, E, {
			enumerable: !0,
			configurable: !0,
			get: () => M.value,
			set: (u) => M.value = u
		}) : T[E] = M;
	}
}
function callHook$1(u, T, E) {
	callWithAsyncErrorHandling(isArray(u) ? u.map((u) => u.bind(T.proxy)) : u.bind(T.proxy), T, E);
}
function createWatcher(u, T, E, O) {
	let M = O.includes(".") ? createPathGetter(E, O) : () => E[O];
	if (isString(u)) {
		let E = T[u];
		isFunction(E) && watch(M, E);
	} else if (isFunction(u)) watch(M, u.bind(E));
	else if (isObject$2(u)) if (isArray(u)) u.forEach((u) => createWatcher(u, T, E, O));
	else {
		let O = isFunction(u.handler) ? u.handler.bind(E) : T[u.handler];
		isFunction(O) && watch(M, O, u);
	}
}
function resolveMergedOptions(u) {
	let T = u.type, { mixins: E, extends: O } = T, { mixins: M, optionsCache: P, config: { optionMergeStrategies: F } } = u.appContext, I = P.get(T), R;
	return I ? R = I : !M.length && !E && !O ? R = T : (R = {}, M.length && M.forEach((u) => mergeOptions(R, u, F, !0)), mergeOptions(R, T, F)), isObject$2(T) && P.set(T, R), R;
}
function mergeOptions(u, T, E, O = !1) {
	let { mixins: M, extends: P } = T;
	for (let F in P && mergeOptions(u, P, E, !0), M && M.forEach((T) => mergeOptions(u, T, E, !0)), T) if (!(O && F === "expose")) {
		let O = internalOptionMergeStrats[F] || E && E[F];
		u[F] = O ? O(u[F], T[F]) : T[F];
	}
	return u;
}
var internalOptionMergeStrats = {
	data: mergeDataFn,
	props: mergeEmitsOrPropsOptions,
	emits: mergeEmitsOrPropsOptions,
	methods: mergeObjectOptions,
	computed: mergeObjectOptions,
	beforeCreate: mergeAsArray,
	created: mergeAsArray,
	beforeMount: mergeAsArray,
	mounted: mergeAsArray,
	beforeUpdate: mergeAsArray,
	updated: mergeAsArray,
	beforeDestroy: mergeAsArray,
	beforeUnmount: mergeAsArray,
	destroyed: mergeAsArray,
	unmounted: mergeAsArray,
	activated: mergeAsArray,
	deactivated: mergeAsArray,
	errorCaptured: mergeAsArray,
	serverPrefetch: mergeAsArray,
	components: mergeObjectOptions,
	directives: mergeObjectOptions,
	watch: mergeWatchOptions,
	provide: mergeDataFn,
	inject: mergeInject
};
function mergeDataFn(u, T) {
	return T ? u ? function() {
		return extend(isFunction(u) ? u.call(this, this) : u, isFunction(T) ? T.call(this, this) : T);
	} : T : u;
}
function mergeInject(u, T) {
	return mergeObjectOptions(normalizeInject(u), normalizeInject(T));
}
function normalizeInject(u) {
	if (isArray(u)) {
		let T = {};
		for (let E = 0; E < u.length; E++) T[u[E]] = u[E];
		return T;
	}
	return u;
}
function mergeAsArray(u, T) {
	return u ? [...new Set([].concat(u, T))] : T;
}
function mergeObjectOptions(u, T) {
	return u ? extend(/* @__PURE__ */ Object.create(null), u, T) : T;
}
function mergeEmitsOrPropsOptions(u, T) {
	return u ? isArray(u) && isArray(T) ? [.../* @__PURE__ */ new Set([...u, ...T])] : extend(/* @__PURE__ */ Object.create(null), normalizePropsOrEmits(u), normalizePropsOrEmits(T ?? {})) : T;
}
function mergeWatchOptions(u, T) {
	if (!u) return T;
	if (!T) return u;
	let E = extend(/* @__PURE__ */ Object.create(null), u);
	for (let O in T) E[O] = mergeAsArray(u[O], T[O]);
	return E;
}
function createAppContext() {
	return {
		app: null,
		config: {
			isNativeTag: NO,
			performance: !1,
			globalProperties: {},
			optionMergeStrategies: {},
			errorHandler: void 0,
			warnHandler: void 0,
			compilerOptions: {}
		},
		mixins: [],
		components: {},
		directives: {},
		provides: /* @__PURE__ */ Object.create(null),
		optionsCache: /* @__PURE__ */ new WeakMap(),
		propsCache: /* @__PURE__ */ new WeakMap(),
		emitsCache: /* @__PURE__ */ new WeakMap()
	};
}
var uid$1 = 0;
function createAppAPI(u, T) {
	return function(E, O = null) {
		isFunction(E) || (E = extend({}, E)), O != null && !isObject$2(O) && (O = null);
		let M = createAppContext(), P = /* @__PURE__ */ new WeakSet(), F = [], I = !1, R = M.app = {
			_uid: uid$1++,
			_component: E,
			_props: O,
			_container: null,
			_context: M,
			_instance: null,
			version,
			get config() {
				return M.config;
			},
			set config(u) {},
			use(u, ...T) {
				return P.has(u) || (u && isFunction(u.install) ? (P.add(u), u.install(R, ...T)) : isFunction(u) && (P.add(u), u(R, ...T))), R;
			},
			mixin(u) {
				return M.mixins.includes(u) || M.mixins.push(u), R;
			},
			component(u, T) {
				return T ? (M.components[u] = T, R) : M.components[u];
			},
			directive(u, T) {
				return T ? (M.directives[u] = T, R) : M.directives[u];
			},
			mount(P, F, V) {
				if (!I) {
					let U = R._ceVNode || createVNode(E, O);
					return U.appContext = M, V === !0 ? V = "svg" : V === !1 && (V = void 0), F && T ? T(U, P) : u(U, P, V), I = !0, R._container = P, P.__vue_app__ = R, getComponentPublicInstance(U.component);
				}
			},
			onUnmount(u) {
				F.push(u);
			},
			unmount() {
				I && (callWithAsyncErrorHandling(F, R._instance, 16), u(null, R._container), delete R._container.__vue_app__);
			},
			provide(u, T) {
				return M.provides[u] = T, R;
			},
			runWithContext(u) {
				let T = currentApp;
				currentApp = R;
				try {
					return u();
				} finally {
					currentApp = T;
				}
			}
		};
		return R;
	};
}
var currentApp = null;
function provide(u, T) {
	if (currentInstance) {
		let E = currentInstance.provides, O = currentInstance.parent && currentInstance.parent.provides;
		O === E && (E = currentInstance.provides = Object.create(O)), E[u] = T;
	}
}
function inject(u, T, E = !1) {
	let O = getCurrentInstance();
	if (O || currentApp) {
		let M = currentApp ? currentApp._context.provides : O ? O.parent == null || O.ce ? O.vnode.appContext && O.vnode.appContext.provides : O.parent.provides : void 0;
		if (M && u in M) return M[u];
		if (arguments.length > 1) return E && isFunction(T) ? T.call(O && O.proxy) : T;
	}
}
function hasInjectionContext() {
	return !!(getCurrentInstance() || currentApp);
}
var internalObjectProto = {}, createInternalObject = () => Object.create(internalObjectProto), isInternalObject = (u) => Object.getPrototypeOf(u) === internalObjectProto;
function initProps(u, T, E, O = !1) {
	let M = {}, P = createInternalObject();
	for (let E in u.propsDefaults = /* @__PURE__ */ Object.create(null), setFullProps(u, T, M, P), u.propsOptions[0]) E in M || (M[E] = void 0);
	E ? u.props = O ? M : shallowReactive(M) : u.type.props ? u.props = M : u.props = P, u.attrs = P;
}
function updateProps(u, T, E, O) {
	let { props: M, attrs: P, vnode: { patchFlag: F } } = u, I = toRaw(M), [R] = u.propsOptions, V = !1;
	if ((O || F > 0) && !(F & 16)) {
		if (F & 8) {
			let E = u.vnode.dynamicProps;
			for (let O = 0; O < E.length; O++) {
				let F = E[O];
				if (isEmitListener(u.emitsOptions, F)) continue;
				let U = T[F];
				if (R) if (hasOwn$2(P, F)) U !== P[F] && (P[F] = U, V = !0);
				else {
					let T = camelize$2(F);
					M[T] = resolvePropValue(R, I, T, U, u, !1);
				}
				else U !== P[F] && (P[F] = U, V = !0);
			}
		}
	} else {
		setFullProps(u, T, M, P) && (V = !0);
		let O;
		for (let P in I) (!T || !hasOwn$2(T, P) && ((O = hyphenate$2(P)) === P || !hasOwn$2(T, O))) && (R ? E && (E[P] !== void 0 || E[O] !== void 0) && (M[P] = resolvePropValue(R, I, P, void 0, u, !0)) : delete M[P]);
		if (P !== I) for (let u in P) (!T || !hasOwn$2(T, u)) && (delete P[u], V = !0);
	}
	V && trigger(u.attrs, "set", "");
}
function setFullProps(u, T, E, M) {
	let [P, F] = u.propsOptions, I = !1, R;
	if (T) for (let O in T) {
		if (isReservedProp(O)) continue;
		let V = T[O], U;
		P && hasOwn$2(P, U = camelize$2(O)) ? !F || !F.includes(U) ? E[U] = V : (R ||= {})[U] = V : isEmitListener(u.emitsOptions, O) || (!(O in M) || V !== M[O]) && (M[O] = V, I = !0);
	}
	if (F) {
		let T = toRaw(E), M = R || EMPTY_OBJ;
		for (let O = 0; O < F.length; O++) {
			let I = F[O];
			E[I] = resolvePropValue(P, T, I, M[I], u, !hasOwn$2(M, I));
		}
	}
	return I;
}
function resolvePropValue(u, T, E, O, M, P) {
	let F = u[E];
	if (F != null) {
		let u = hasOwn$2(F, "default");
		if (u && O === void 0) {
			let u = F.default;
			if (F.type !== Function && !F.skipFactory && isFunction(u)) {
				let { propsDefaults: P } = M;
				if (E in P) O = P[E];
				else {
					let F = setCurrentInstance(M);
					O = P[E] = u.call(null, T), F();
				}
			} else O = u;
			M.ce && M.ce._setProp(E, O);
		}
		F[0] && (P && !u ? O = !1 : F[1] && (O === "" || O === hyphenate$2(E)) && (O = !0));
	}
	return O;
}
var mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(u, T, E = !1) {
	let P = E ? mixinPropsCache : T.propsCache, F = P.get(u);
	if (F) return F;
	let I = u.props, R = {}, U = [], Dp = !1;
	if (!isFunction(u)) {
		let O = (u) => {
			Dp = !0;
			let [E, O] = normalizePropsOptions(u, T, !0);
			extend(R, E), O && U.push(...O);
		};
		!E && T.mixins.length && T.mixins.forEach(O), u.extends && O(u.extends), u.mixins && u.mixins.forEach(O);
	}
	if (!I && !Dp) return isObject$2(u) && P.set(u, EMPTY_ARR), EMPTY_ARR;
	if (isArray(I)) for (let u = 0; u < I.length; u++) {
		let T = camelize$2(I[u]);
		validatePropName(T) && (R[T] = EMPTY_OBJ);
	}
	else if (I) for (let u in I) {
		let T = camelize$2(u);
		if (validatePropName(T)) {
			let E = I[u], O = R[T] = isArray(E) || isFunction(E) ? { type: E } : extend({}, E), M = O.type, P = !1, F = !0;
			if (isArray(M)) for (let u = 0; u < M.length; ++u) {
				let T = M[u], E = isFunction(T) && T.name;
				if (E === "Boolean") {
					P = !0;
					break;
				} else E === "String" && (F = !1);
			}
			else P = isFunction(M) && M.name === "Boolean";
			O[0] = P, O[1] = F, (P || hasOwn$2(O, "default")) && U.push(T);
		}
	}
	let Ap = [R, U];
	return isObject$2(u) && P.set(u, Ap), Ap;
}
function validatePropName(u) {
	return u[0] !== "$" && !isReservedProp(u);
}
var isInternalKey = (u) => u === "_" || u === "_ctx" || u === "$stable", normalizeSlotValue = (u) => isArray(u) ? u.map(normalizeVNode) : [normalizeVNode(u)], normalizeSlot = (u, T, E) => {
	if (T._n) return T;
	let O = withCtx((...u) => normalizeSlotValue(T(...u)), E);
	return O._c = !1, O;
}, normalizeObjectSlots = (u, T, E) => {
	let O = u._ctx;
	for (let E in u) {
		if (isInternalKey(E)) continue;
		let M = u[E];
		if (isFunction(M)) T[E] = normalizeSlot(E, M, O);
		else if (M != null) {
			let u = normalizeSlotValue(M);
			T[E] = () => u;
		}
	}
}, normalizeVNodeSlots = (u, T) => {
	let E = normalizeSlotValue(T);
	u.slots.default = () => E;
}, assignSlots = (u, T, E) => {
	for (let O in T) (E || !isInternalKey(O)) && (u[O] = T[O]);
}, initSlots = (u, T, E) => {
	let O = u.slots = createInternalObject();
	if (u.vnode.shapeFlag & 32) {
		let u = T._;
		u ? (assignSlots(O, T, E), E && def(O, "_", u, !0)) : normalizeObjectSlots(T, O);
	} else T && normalizeVNodeSlots(u, T);
}, updateSlots = (u, T, E) => {
	let { vnode: M, slots: P } = u, F = !0, I = EMPTY_OBJ;
	if (M.shapeFlag & 32) {
		let u = T._;
		u ? E && u === 1 ? F = !1 : assignSlots(P, T, E) : (F = !T.$stable, normalizeObjectSlots(T, P)), I = T;
	} else T && (normalizeVNodeSlots(u, T), I = { default: 1 });
	if (F) for (let u in P) !isInternalKey(u) && I[u] == null && delete P[u];
}, queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(u) {
	return baseCreateRenderer(u);
}
function createHydrationRenderer(u) {
	return baseCreateRenderer(u, createHydrationFunctions);
}
function baseCreateRenderer(u, T) {
	let E = getGlobalThis();
	E.__VUE__ = !0;
	let { insert: F, remove: I, patchProp: R, createElement: V, createText: U, createComment: Dp, setText: Op, setElementText: kp, parentNode: Ap, nextSibling: jp, setScopeId: Mp = NOOP, insertStaticContent: Np } = u, Pp = (u, T, E, O = null, M = null, P = null, F = void 0, I = null, R = !!T.dynamicChildren) => {
		if (u === T) return;
		u && !isSameVNodeType(u, T) && (O = dm(u), om(u, M, P, !0), u = null), T.patchFlag === -2 && (R = !1, T.dynamicChildren = null);
		let { type: V, ref: U, shapeFlag: Dp } = T;
		switch (V) {
			case Text:
				Fp(u, T, E, O);
				break;
			case Comment:
				Ip(u, T, E, O);
				break;
			case Static:
				u ?? Lp(T, E, O, F);
				break;
			case Fragment:
				Jp(u, T, E, O, M, P, F, I, R);
				break;
			default: Dp & 1 ? Bp(u, T, E, O, M, P, F, I, R) : Dp & 6 ? Yp(u, T, E, O, M, P, F, I, R) : (Dp & 64 || Dp & 128) && V.process(u, T, E, O, M, P, F, I, R, mm);
		}
		U != null && M ? setRef(U, u && u.ref, P, T || u, !T) : U == null && u && u.ref != null && setRef(u.ref, null, P, u, !0);
	}, Fp = (u, T, E, O) => {
		if (u == null) F(T.el = U(T.children), E, O);
		else {
			let E = T.el = u.el;
			T.children !== u.children && Op(E, T.children);
		}
	}, Ip = (u, T, E, O) => {
		u == null ? F(T.el = Dp(T.children || ""), E, O) : T.el = u.el;
	}, Lp = (u, T, E, O) => {
		[u.el, u.anchor] = Np(u.children, T, E, O, u.el, u.anchor);
	}, Rp = ({ el: u, anchor: T }, E, O) => {
		let M;
		for (; u && u !== T;) M = jp(u), F(u, E, O), u = M;
		F(T, E, O);
	}, zp = ({ el: u, anchor: T }) => {
		let E;
		for (; u && u !== T;) E = jp(u), I(u), u = E;
		I(T);
	}, Bp = (u, T, E, O, M, P, F, I, R) => {
		T.type === "svg" ? F = "svg" : T.type === "math" && (F = "mathml"), u == null ? Vp(T, E, O, M, P, F, I, R) : Gp(u, T, M, P, F, I, R);
	}, Vp = (u, T, E, O, M, P, I, U) => {
		let Dp, Op, { props: Ap, shapeFlag: jp, transition: Mp, dirs: Np } = u;
		if (Dp = u.el = V(u.type, P, Ap && Ap.is, Ap), jp & 8 ? kp(Dp, u.children) : jp & 16 && Up(u.children, Dp, null, O, M, resolveChildrenNamespace(u, P), I, U), Np && invokeDirectiveHook(u, null, O, "created"), Hp(Dp, u, u.scopeId, I, O), Ap) {
			for (let u in Ap) u !== "value" && !isReservedProp(u) && R(Dp, u, null, Ap[u], P, O);
			"value" in Ap && R(Dp, "value", null, Ap.value, P), (Op = Ap.onVnodeBeforeMount) && invokeVNodeHook(Op, O, u);
		}
		Np && invokeDirectiveHook(u, null, O, "beforeMount");
		let Pp = needTransition(M, Mp);
		Pp && Mp.beforeEnter(Dp), F(Dp, T, E), ((Op = Ap && Ap.onVnodeMounted) || Pp || Np) && queuePostRenderEffect(() => {
			Op && invokeVNodeHook(Op, O, u), Pp && Mp.enter(Dp), Np && invokeDirectiveHook(u, null, O, "mounted");
		}, M);
	}, Hp = (u, T, E, O, M) => {
		if (E && Mp(u, E), O) for (let T = 0; T < O.length; T++) Mp(u, O[T]);
		if (M) {
			let E = M.subTree;
			if (T === E || isSuspense(E.type) && (E.ssContent === T || E.ssFallback === T)) {
				let T = M.vnode;
				Hp(u, T, T.scopeId, T.slotScopeIds, M.parent);
			}
		}
	}, Up = (u, T, E, O, M, P, F, I, R = 0) => {
		for (let V = R; V < u.length; V++) Pp(null, u[V] = I ? cloneIfMounted(u[V]) : normalizeVNode(u[V]), T, E, O, M, P, F, I);
	}, Gp = (u, T, E, M, P, F, I) => {
		let V = T.el = u.el, { patchFlag: U, dynamicChildren: Dp, dirs: Op } = T;
		U |= u.patchFlag & 16;
		let Ap = u.props || EMPTY_OBJ, jp = T.props || EMPTY_OBJ, Mp;
		if (E && toggleRecurse(E, !1), (Mp = jp.onVnodeBeforeUpdate) && invokeVNodeHook(Mp, E, T, u), Op && invokeDirectiveHook(T, u, E, "beforeUpdate"), E && toggleRecurse(E, !0), (Ap.innerHTML && jp.innerHTML == null || Ap.textContent && jp.textContent == null) && kp(V, ""), Dp ? Kp(u.dynamicChildren, Dp, V, E, M, resolveChildrenNamespace(T, P), F) : I || tm(u, T, V, null, E, M, resolveChildrenNamespace(T, P), F, !1), U > 0) {
			if (U & 16) qp(V, Ap, jp, E, P);
			else if (U & 2 && Ap.class !== jp.class && R(V, "class", null, jp.class, P), U & 4 && R(V, "style", Ap.style, jp.style, P), U & 8) {
				let u = T.dynamicProps;
				for (let T = 0; T < u.length; T++) {
					let O = u[T], M = Ap[O], F = jp[O];
					(F !== M || O === "value") && R(V, O, M, F, P, E);
				}
			}
			U & 1 && u.children !== T.children && kp(V, T.children);
		} else !I && Dp == null && qp(V, Ap, jp, E, P);
		((Mp = jp.onVnodeUpdated) || Op) && queuePostRenderEffect(() => {
			Mp && invokeVNodeHook(Mp, E, T, u), Op && invokeDirectiveHook(T, u, E, "updated");
		}, M);
	}, Kp = (u, T, E, O, M, P, F) => {
		for (let I = 0; I < T.length; I++) {
			let R = u[I], V = T[I];
			Pp(R, V, R.el && (R.type === Fragment || !isSameVNodeType(R, V) || R.shapeFlag & 198) ? Ap(R.el) : E, null, O, M, P, F, !0);
		}
	}, qp = (u, T, E, M, P) => {
		if (T !== E) {
			if (T !== EMPTY_OBJ) for (let O in T) !isReservedProp(O) && !(O in E) && R(u, O, T[O], null, P, M);
			for (let O in E) {
				if (isReservedProp(O)) continue;
				let F = E[O], I = T[O];
				F !== I && O !== "value" && R(u, O, I, F, P, M);
			}
			"value" in E && R(u, "value", T.value, E.value, P);
		}
	}, Jp = (u, T, E, O, M, P, I, R, V) => {
		let Dp = T.el = u ? u.el : U(""), Op = T.anchor = u ? u.anchor : U(""), { patchFlag: kp, dynamicChildren: Ap, slotScopeIds: jp } = T;
		jp && (R = R ? R.concat(jp) : jp), u == null ? (F(Dp, E, O), F(Op, E, O), Up(T.children || [], E, Op, M, P, I, R, V)) : kp > 0 && kp & 64 && Ap && u.dynamicChildren ? (Kp(u.dynamicChildren, Ap, E, M, P, I, R), (T.key != null || M && T === M.subTree) && traverseStaticChildren(u, T, !0)) : tm(u, T, E, Op, M, P, I, R, V);
	}, Yp = (u, T, E, O, M, P, F, I, R) => {
		T.slotScopeIds = I, u == null ? T.shapeFlag & 512 ? M.ctx.activate(T, E, O, F, R) : Xp(T, E, O, M, P, F, R) : Zp(u, T, R);
	}, Xp = (u, T, E, O, M, P, F) => {
		let I = u.component = createComponentInstance(u, O, M);
		if (isKeepAlive(u) && (I.ctx.renderer = mm), setupComponent(I, !1, F), I.asyncDep) {
			if (M && M.registerDep(I, Qp, F), !u.el) {
				let O = I.subTree = createVNode(Comment);
				Ip(null, O, T, E), u.placeholder = O.el;
			}
		} else Qp(I, u, T, E, M, P, F);
	}, Zp = (u, T, E) => {
		let O = T.component = u.component;
		if (shouldUpdateComponent(u, T, E)) if (O.asyncDep && !O.asyncResolved) {
			em(O, T, E);
			return;
		} else O.next = T, O.update();
		else T.el = u.el, O.vnode = T;
	}, Qp = (u, T, E, O, M, P, F) => {
		let I = () => {
			if (u.isMounted) {
				let { next: T, bu: E, u: O, parent: R, vnode: V } = u;
				{
					let E = locateNonHydratedAsyncRoot(u);
					if (E) {
						T && (T.el = V.el, em(u, T, F)), E.asyncDep.then(() => {
							u.isUnmounted || I();
						});
						return;
					}
				}
				let U = T, Dp;
				toggleRecurse(u, !1), T ? (T.el = V.el, em(u, T, F)) : T = V, E && invokeArrayFns(E), (Dp = T.props && T.props.onVnodeBeforeUpdate) && invokeVNodeHook(Dp, R, T, V), toggleRecurse(u, !0);
				let Op = renderComponentRoot(u), kp = u.subTree;
				u.subTree = Op, Pp(kp, Op, Ap(kp.el), dm(kp), u, M, P), T.el = Op.el, U === null && updateHOCHostEl(u, Op.el), O && queuePostRenderEffect(O, M), (Dp = T.props && T.props.onVnodeUpdated) && queuePostRenderEffect(() => invokeVNodeHook(Dp, R, T, V), M);
			} else {
				let F, { el: I, props: R } = T, { bm: V, m: U, parent: Dp, root: Op, type: kp } = u, Ap = isAsyncWrapper(T);
				if (toggleRecurse(u, !1), V && invokeArrayFns(V), !Ap && (F = R && R.onVnodeBeforeMount) && invokeVNodeHook(F, Dp, T), toggleRecurse(u, !0), I && gm) {
					let T = () => {
						u.subTree = renderComponentRoot(u), gm(I, u.subTree, u, M, null);
					};
					Ap && kp.__asyncHydrate ? kp.__asyncHydrate(I, u, T) : T();
				} else {
					Op.ce && Op.ce._def.shadowRoot !== !1 && Op.ce._injectChildStyle(kp);
					let F = u.subTree = renderComponentRoot(u);
					Pp(null, F, E, O, u, M, P), T.el = F.el;
				}
				if (U && queuePostRenderEffect(U, M), !Ap && (F = R && R.onVnodeMounted)) {
					let u = T;
					queuePostRenderEffect(() => invokeVNodeHook(F, Dp, u), M);
				}
				(T.shapeFlag & 256 || Dp && isAsyncWrapper(Dp.vnode) && Dp.vnode.shapeFlag & 256) && u.a && queuePostRenderEffect(u.a, M), u.isMounted = !0, T = E = O = null;
			}
		};
		u.scope.on();
		let R = u.effect = new ReactiveEffect(I);
		u.scope.off();
		let V = u.update = R.run.bind(R), U = u.job = R.runIfDirty.bind(R);
		U.i = u, U.id = u.uid, R.scheduler = () => queueJob(U), toggleRecurse(u, !0), V();
	}, em = (u, T, E) => {
		T.component = u;
		let O = u.vnode.props;
		u.vnode = T, u.next = null, updateProps(u, T.props, O, E), updateSlots(u, T.children, E), pauseTracking(), flushPreFlushCbs(u), resetTracking();
	}, tm = (u, T, E, O, M, P, F, I, R = !1) => {
		let V = u && u.children, U = u ? u.shapeFlag : 0, Dp = T.children, { patchFlag: Op, shapeFlag: Ap } = T;
		if (Op > 0) {
			if (Op & 128) {
				rm(V, Dp, E, O, M, P, F, I, R);
				return;
			} else if (Op & 256) {
				nm(V, Dp, E, O, M, P, F, I, R);
				return;
			}
		}
		Ap & 8 ? (U & 16 && um(V, M, P), Dp !== V && kp(E, Dp)) : U & 16 ? Ap & 16 ? rm(V, Dp, E, O, M, P, F, I, R) : um(V, M, P, !0) : (U & 8 && kp(E, ""), Ap & 16 && Up(Dp, E, O, M, P, F, I, R));
	}, nm = (u, T, E, O, P, F, I, R, V) => {
		u ||= EMPTY_ARR, T ||= EMPTY_ARR;
		let U = u.length, Dp = T.length, Op = Math.min(U, Dp), kp;
		for (kp = 0; kp < Op; kp++) {
			let O = T[kp] = V ? cloneIfMounted(T[kp]) : normalizeVNode(T[kp]);
			Pp(u[kp], O, E, null, P, F, I, R, V);
		}
		U > Dp ? um(u, P, F, !0, !1, Op) : Up(T, E, O, P, F, I, R, V, Op);
	}, rm = (u, T, E, O, P, F, I, R, V) => {
		let U = 0, Dp = T.length, Op = u.length - 1, kp = Dp - 1;
		for (; U <= Op && U <= kp;) {
			let O = u[U], M = T[U] = V ? cloneIfMounted(T[U]) : normalizeVNode(T[U]);
			if (isSameVNodeType(O, M)) Pp(O, M, E, null, P, F, I, R, V);
			else break;
			U++;
		}
		for (; U <= Op && U <= kp;) {
			let O = u[Op], M = T[kp] = V ? cloneIfMounted(T[kp]) : normalizeVNode(T[kp]);
			if (isSameVNodeType(O, M)) Pp(O, M, E, null, P, F, I, R, V);
			else break;
			Op--, kp--;
		}
		if (U > Op) {
			if (U <= kp) {
				let u = kp + 1, M = u < Dp ? T[u].el : O;
				for (; U <= kp;) Pp(null, T[U] = V ? cloneIfMounted(T[U]) : normalizeVNode(T[U]), E, M, P, F, I, R, V), U++;
			}
		} else if (U > kp) for (; U <= Op;) om(u[U], P, F, !0), U++;
		else {
			let Ap = U, jp = U, Mp = /* @__PURE__ */ new Map();
			for (U = jp; U <= kp; U++) {
				let u = T[U] = V ? cloneIfMounted(T[U]) : normalizeVNode(T[U]);
				u.key != null && Mp.set(u.key, U);
			}
			let Np, Fp = 0, Ip = kp - jp + 1, Lp = !1, Rp = 0, zp = Array(Ip);
			for (U = 0; U < Ip; U++) zp[U] = 0;
			for (U = Ap; U <= Op; U++) {
				let O = u[U];
				if (Fp >= Ip) {
					om(O, P, F, !0);
					continue;
				}
				let M;
				if (O.key != null) M = Mp.get(O.key);
				else for (Np = jp; Np <= kp; Np++) if (zp[Np - jp] === 0 && isSameVNodeType(O, T[Np])) {
					M = Np;
					break;
				}
				M === void 0 ? om(O, P, F, !0) : (zp[M - jp] = U + 1, M >= Rp ? Rp = M : Lp = !0, Pp(O, T[M], E, null, P, F, I, R, V), Fp++);
			}
			let Bp = Lp ? getSequence(zp) : EMPTY_ARR;
			for (Np = Bp.length - 1, U = Ip - 1; U >= 0; U--) {
				let u = jp + U, M = T[u], Op = T[u + 1], kp = u + 1 < Dp ? Op.el || Op.placeholder : O;
				zp[U] === 0 ? Pp(null, M, E, kp, P, F, I, R, V) : Lp && (Np < 0 || U !== Bp[Np] ? am(M, E, kp, 2) : Np--);
			}
		}
	}, am = (u, T, E, O, M = null) => {
		let { el: P, type: R, transition: V, children: U, shapeFlag: Dp } = u;
		if (Dp & 6) {
			am(u.component.subTree, T, E, O);
			return;
		}
		if (Dp & 128) {
			u.suspense.move(T, E, O);
			return;
		}
		if (Dp & 64) {
			R.move(u, T, E, mm);
			return;
		}
		if (R === Fragment) {
			F(P, T, E);
			for (let u = 0; u < U.length; u++) am(U[u], T, E, O);
			F(u.anchor, T, E);
			return;
		}
		if (R === Static) {
			Rp(u, T, E);
			return;
		}
		if (O !== 2 && Dp & 1 && V) if (O === 0) V.beforeEnter(P), F(P, T, E), queuePostRenderEffect(() => V.enter(P), M);
		else {
			let { leave: O, delayLeave: M, afterLeave: R } = V, U = () => {
				u.ctx.isUnmounted ? I(P) : F(P, T, E);
			}, Dp = () => {
				P._isLeaving && P[leaveCbKey](!0), O(P, () => {
					U(), R && R();
				});
			};
			M ? M(P, U, Dp) : Dp();
		}
		else F(P, T, E);
	}, om = (u, T, E, O = !1, M = !1) => {
		let { type: P, props: F, ref: I, children: R, dynamicChildren: V, shapeFlag: U, patchFlag: Dp, dirs: Op, cacheIndex: kp } = u;
		if (Dp === -2 && (M = !1), I != null && (pauseTracking(), setRef(I, null, E, u, !0), resetTracking()), kp != null && (T.renderCache[kp] = void 0), U & 256) {
			T.ctx.deactivate(u);
			return;
		}
		let Ap = U & 1 && Op, jp = !isAsyncWrapper(u), Mp;
		if (jp && (Mp = F && F.onVnodeBeforeUnmount) && invokeVNodeHook(Mp, T, u), U & 6) lm(u.component, E, O);
		else {
			if (U & 128) {
				u.suspense.unmount(E, O);
				return;
			}
			Ap && invokeDirectiveHook(u, null, T, "beforeUnmount"), U & 64 ? u.type.remove(u, T, E, mm, O) : V && !V.hasOnce && (P !== Fragment || Dp > 0 && Dp & 64) ? um(V, T, E, !1, !0) : (P === Fragment && Dp & 384 || !M && U & 16) && um(R, T, E), O && sm(u);
		}
		(jp && (Mp = F && F.onVnodeUnmounted) || Ap) && queuePostRenderEffect(() => {
			Mp && invokeVNodeHook(Mp, T, u), Ap && invokeDirectiveHook(u, null, T, "unmounted");
		}, E);
	}, sm = (u) => {
		let { type: T, el: E, anchor: O, transition: M } = u;
		if (T === Fragment) {
			cm(E, O);
			return;
		}
		if (T === Static) {
			zp(u);
			return;
		}
		let P = () => {
			I(E), M && !M.persisted && M.afterLeave && M.afterLeave();
		};
		if (u.shapeFlag & 1 && M && !M.persisted) {
			let { leave: T, delayLeave: O } = M, F = () => T(E, P);
			O ? O(u.el, P, F) : F();
		} else P();
	}, cm = (u, T) => {
		let E;
		for (; u !== T;) E = jp(u), I(u), u = E;
		I(T);
	}, lm = (u, T, E) => {
		let { bum: O, scope: M, job: P, subTree: F, um: I, m: R, a: V } = u;
		invalidateMount(R), invalidateMount(V), O && invokeArrayFns(O), M.stop(), P && (P.flags |= 8, om(F, u, T, E)), I && queuePostRenderEffect(I, T), queuePostRenderEffect(() => {
			u.isUnmounted = !0;
		}, T);
	}, um = (u, T, E, O = !1, M = !1, P = 0) => {
		for (let F = P; F < u.length; F++) om(u[F], T, E, O, M);
	}, dm = (u) => {
		if (u.shapeFlag & 6) return dm(u.component.subTree);
		if (u.shapeFlag & 128) return u.suspense.next();
		let T = jp(u.anchor || u.el), E = T && T[TeleportEndKey];
		return E ? jp(E) : T;
	}, fm = !1, pm = (u, T, E) => {
		u == null ? T._vnode && om(T._vnode, null, null, !0) : Pp(T._vnode || null, u, T, null, null, null, E), T._vnode = u, fm ||= (fm = !0, flushPreFlushCbs(), flushPostFlushCbs(), !1);
	}, mm = {
		p: Pp,
		um: om,
		m: am,
		r: sm,
		mt: Xp,
		mc: Up,
		pc: tm,
		pbc: Kp,
		n: dm,
		o: u
	}, hm, gm;
	return T && ([hm, gm] = T(mm)), {
		render: pm,
		hydrate: hm,
		createApp: createAppAPI(pm, hm)
	};
}
function resolveChildrenNamespace({ type: u, props: T }, E) {
	return E === "svg" && u === "foreignObject" || E === "mathml" && u === "annotation-xml" && T && T.encoding && T.encoding.includes("html") ? void 0 : E;
}
function toggleRecurse({ effect: u, job: T }, E) {
	E ? (u.flags |= 32, T.flags |= 4) : (u.flags &= -33, T.flags &= -5);
}
function needTransition(u, T) {
	return (!u || u && !u.pendingBranch) && T && !T.persisted;
}
function traverseStaticChildren(u, T, E = !1) {
	let O = u.children, M = T.children;
	if (isArray(O) && isArray(M)) for (let u = 0; u < O.length; u++) {
		let T = O[u], P = M[u];
		P.shapeFlag & 1 && !P.dynamicChildren && ((P.patchFlag <= 0 || P.patchFlag === 32) && (P = M[u] = cloneIfMounted(M[u]), P.el = T.el), !E && P.patchFlag !== -2 && traverseStaticChildren(T, P)), P.type === Text && P.patchFlag !== -1 && (P.el = T.el), P.type === Comment && !P.el && (P.el = T.el);
	}
}
function getSequence(u) {
	let T = u.slice(), E = [0], O, M, P, F, I, R = u.length;
	for (O = 0; O < R; O++) {
		let R = u[O];
		if (R !== 0) {
			if (M = E[E.length - 1], u[M] < R) {
				T[O] = M, E.push(O);
				continue;
			}
			for (P = 0, F = E.length - 1; P < F;) I = P + F >> 1, u[E[I]] < R ? P = I + 1 : F = I;
			R < u[E[P]] && (P > 0 && (T[O] = E[P - 1]), E[P] = O);
		}
	}
	for (P = E.length, F = E[P - 1]; P-- > 0;) E[P] = F, F = T[F];
	return E;
}
function locateNonHydratedAsyncRoot(u) {
	let T = u.subTree.component;
	if (T) return T.asyncDep && !T.asyncResolved ? T : locateNonHydratedAsyncRoot(T);
}
function invalidateMount(u) {
	if (u) for (let T = 0; T < u.length; T++) u[T].flags |= 8;
}
var ssrContextKey = Symbol.for("v-scx"), useSSRContext = () => inject(ssrContextKey);
function watchEffect(u, T) {
	return doWatch(u, null, T);
}
function watchPostEffect(u, T) {
	return doWatch(u, null, { flush: "post" });
}
function watchSyncEffect(u, T) {
	return doWatch(u, null, { flush: "sync" });
}
function watch(u, T, E) {
	return doWatch(u, T, E);
}
function doWatch(u, T, E = EMPTY_OBJ) {
	let { immediate: M, deep: F, flush: I, once: R } = E, U = extend({}, E), Dp = T && M || !T && I !== "post", Op;
	if (isInSSRComponentSetup) {
		if (I === "sync") {
			let u = useSSRContext();
			Op = u.__watcherHandles ||= [];
		} else if (!Dp) {
			let u = () => {};
			return u.stop = NOOP, u.resume = NOOP, u.pause = NOOP, u;
		}
	}
	let kp = currentInstance;
	U.call = (u, T, E) => callWithAsyncErrorHandling(u, kp, T, E);
	let Ap = !1;
	I === "post" ? U.scheduler = (u) => {
		queuePostRenderEffect(u, kp && kp.suspense);
	} : I !== "sync" && (Ap = !0, U.scheduler = (u, T) => {
		T ? u() : queueJob(u);
	}), U.augmentJob = (u) => {
		T && (u.flags |= 4), Ap && (u.flags |= 2, kp && (u.id = kp.uid, u.i = kp));
	};
	let jp = watch$1(u, T, U);
	return isInSSRComponentSetup && (Op ? Op.push(jp) : Dp && jp()), jp;
}
function instanceWatch(u, T, E) {
	let O = this.proxy, M = isString(u) ? u.includes(".") ? createPathGetter(O, u) : () => O[u] : u.bind(O, O), P;
	isFunction(T) ? P = T : (P = T.handler, E = T);
	let F = setCurrentInstance(this), I = doWatch(M, P.bind(O), E);
	return F(), I;
}
function createPathGetter(u, T) {
	let E = T.split(".");
	return () => {
		let T = u;
		for (let u = 0; u < E.length && T; u++) T = T[E[u]];
		return T;
	};
}
function useModel(u, T, E = EMPTY_OBJ) {
	let M = getCurrentInstance(), P = camelize$2(T), F = hyphenate$2(T), I = getModelModifiers(u, P), R = customRef((I, R) => {
		let V, U = EMPTY_OBJ, Dp;
		return watchSyncEffect(() => {
			let T = u[P];
			hasChanged(V, T) && (V = T, R());
		}), {
			get() {
				return I(), E.get ? E.get(V) : V;
			},
			set(u) {
				let I = E.set ? E.set(u) : u;
				if (!hasChanged(I, V) && !(U !== EMPTY_OBJ && hasChanged(u, U))) return;
				let Op = M.vnode.props;
				Op && (T in Op || P in Op || F in Op) && (`onUpdate:${T}` in Op || `onUpdate:${P}` in Op || `onUpdate:${F}` in Op) || (V = u, R()), M.emit(`update:${T}`, I), hasChanged(u, I) && hasChanged(u, U) && !hasChanged(I, Dp) && R(), U = u, Dp = I;
			}
		};
	});
	return R[Symbol.iterator] = () => {
		let u = 0;
		return { next() {
			return u < 2 ? {
				value: u++ ? I || EMPTY_OBJ : R,
				done: !1
			} : { done: !0 };
		} };
	}, R;
}
var getModelModifiers = (u, T) => T === "modelValue" || T === "model-value" ? u.modelModifiers : u[`${T}Modifiers`] || u[`${camelize$2(T)}Modifiers`] || u[`${hyphenate$2(T)}Modifiers`];
function emit(u, T, ...E) {
	if (u.isUnmounted) return;
	let M = u.vnode.props || EMPTY_OBJ, P = E, F = T.startsWith("update:"), I = F && getModelModifiers(M, T.slice(7));
	I && (I.trim && (P = E.map((u) => isString(u) ? u.trim() : u)), I.number && (P = E.map(looseToNumber)));
	let R, V = M[R = toHandlerKey(T)] || M[R = toHandlerKey(camelize$2(T))];
	!V && F && (V = M[R = toHandlerKey(hyphenate$2(T))]), V && callWithAsyncErrorHandling(V, u, 6, P);
	let U = M[R + "Once"];
	if (U) {
		if (!u.emitted) u.emitted = {};
		else if (u.emitted[R]) return;
		u.emitted[R] = !0, callWithAsyncErrorHandling(U, u, 6, P);
	}
}
var mixinEmitsCache = /* @__PURE__ */ new WeakMap();
function normalizeEmitsOptions(u, T, E = !1) {
	let O = E ? mixinEmitsCache : T.emitsCache, M = O.get(u);
	if (M !== void 0) return M;
	let P = u.emits, F = {}, I = !1;
	if (!isFunction(u)) {
		let O = (u) => {
			let E = normalizeEmitsOptions(u, T, !0);
			E && (I = !0, extend(F, E));
		};
		!E && T.mixins.length && T.mixins.forEach(O), u.extends && O(u.extends), u.mixins && u.mixins.forEach(O);
	}
	return !P && !I ? (isObject$2(u) && O.set(u, null), null) : (isArray(P) ? P.forEach((u) => F[u] = null) : extend(F, P), isObject$2(u) && O.set(u, F), F);
}
function isEmitListener(u, T) {
	return !u || !isOn(T) ? !1 : (T = T.slice(2).replace(/Once$/, ""), hasOwn$2(u, T[0].toLowerCase() + T.slice(1)) || hasOwn$2(u, hyphenate$2(T)) || hasOwn$2(u, T));
}
function renderComponentRoot(u) {
	let { type: T, vnode: E, proxy: O, withProxy: M, propsOptions: [P], slots: F, attrs: I, emit: V, render: U, renderCache: Dp, props: Op, data: kp, setupState: Ap, ctx: jp, inheritAttrs: Mp } = u, Np = setCurrentRenderingInstance(u), Pp, Fp;
	try {
		if (E.shapeFlag & 4) {
			let u = M || O, T = u;
			Pp = normalizeVNode(U.call(T, u, Dp, Op, Ap, kp, jp)), Fp = I;
		} else {
			let u = T;
			Pp = normalizeVNode(u.length > 1 ? u(Op, {
				attrs: I,
				slots: F,
				emit: V
			}) : u(Op, null)), Fp = T.props ? I : getFunctionalFallthrough(I);
		}
	} catch (T) {
		blockStack.length = 0, handleError(T, u, 1), Pp = createVNode(Comment);
	}
	let Ip = Pp;
	if (Fp && Mp !== !1) {
		let u = Object.keys(Fp), { shapeFlag: T } = Ip;
		u.length && T & 7 && (P && u.some(isModelListener) && (Fp = filterModelListeners(Fp, P)), Ip = cloneVNode(Ip, Fp, !1, !0));
	}
	return E.dirs && (Ip = cloneVNode(Ip, null, !1, !0), Ip.dirs = Ip.dirs ? Ip.dirs.concat(E.dirs) : E.dirs), E.transition && setTransitionHooks(Ip, E.transition), Pp = Ip, setCurrentRenderingInstance(Np), Pp;
}
function filterSingleRoot(u, T = !0) {
	let E;
	for (let T = 0; T < u.length; T++) {
		let O = u[T];
		if (isVNode(O)) {
			if (O.type !== Comment || O.children === "v-if") {
				if (E) return;
				E = O;
			}
		} else return;
	}
	return E;
}
var getFunctionalFallthrough = (u) => {
	let T;
	for (let E in u) (E === "class" || E === "style" || isOn(E)) && ((T ||= {})[E] = u[E]);
	return T;
}, filterModelListeners = (u, T) => {
	let E = {};
	for (let O in u) (!isModelListener(O) || !(O.slice(9) in T)) && (E[O] = u[O]);
	return E;
};
function shouldUpdateComponent(u, T, E) {
	let { props: O, children: M, component: P } = u, { props: F, children: I, patchFlag: R } = T, V = P.emitsOptions;
	if (T.dirs || T.transition) return !0;
	if (E && R >= 0) {
		if (R & 1024) return !0;
		if (R & 16) return O ? hasPropsChanged(O, F, V) : !!F;
		if (R & 8) {
			let u = T.dynamicProps;
			for (let T = 0; T < u.length; T++) {
				let E = u[T];
				if (F[E] !== O[E] && !isEmitListener(V, E)) return !0;
			}
		}
	} else return (M || I) && (!I || !I.$stable) ? !0 : O === F ? !1 : O ? F ? hasPropsChanged(O, F, V) : !0 : !!F;
	return !1;
}
function hasPropsChanged(u, T, E) {
	let O = Object.keys(T);
	if (O.length !== Object.keys(u).length) return !0;
	for (let M = 0; M < O.length; M++) {
		let P = O[M];
		if (T[P] !== u[P] && !isEmitListener(E, P)) return !0;
	}
	return !1;
}
function updateHOCHostEl({ vnode: u, parent: T }, E) {
	for (; T;) {
		let O = T.subTree;
		if (O.suspense && O.suspense.activeBranch === u && (O.el = u.el), O === u) (u = T.vnode).el = E, T = T.parent;
		else break;
	}
}
var isSuspense = (u) => u.__isSuspense, suspenseId = 0, Suspense = {
	name: "Suspense",
	__isSuspense: !0,
	process(u, T, E, O, M, P, F, I, R, V) {
		if (u == null) mountSuspense(T, E, O, M, P, F, I, R, V);
		else {
			if (P && P.deps > 0 && !u.suspense.isInFallback) {
				T.suspense = u.suspense, T.suspense.vnode = T, T.el = u.el;
				return;
			}
			patchSuspense(u, T, E, O, M, F, I, R, V);
		}
	},
	hydrate: hydrateSuspense,
	normalize: normalizeSuspenseChildren
};
function triggerEvent(u, T) {
	let E = u.props && u.props[T];
	isFunction(E) && E();
}
function mountSuspense(u, T, E, O, M, P, F, I, R) {
	let { p: V, o: { createElement: U } } = R, Dp = U("div"), Op = u.suspense = createSuspenseBoundary(u, M, O, T, Dp, E, P, F, I, R);
	V(null, Op.pendingBranch = u.ssContent, Dp, null, O, Op, P, F), Op.deps > 0 ? (triggerEvent(u, "onPending"), triggerEvent(u, "onFallback"), V(null, u.ssFallback, T, E, O, null, P, F), setActiveBranch(Op, u.ssFallback)) : Op.resolve(!1, !0);
}
function patchSuspense(u, T, E, O, M, P, F, I, { p: R, um: V, o: { createElement: U } }) {
	let Dp = T.suspense = u.suspense;
	Dp.vnode = T, T.el = u.el;
	let Op = T.ssContent, kp = T.ssFallback, { activeBranch: Ap, pendingBranch: jp, isInFallback: Mp, isHydrating: Np } = Dp;
	if (jp) Dp.pendingBranch = Op, isSameVNodeType(jp, Op) ? (R(jp, Op, Dp.hiddenContainer, null, M, Dp, P, F, I), Dp.deps <= 0 ? Dp.resolve() : Mp && (Np || (R(Ap, kp, E, O, M, null, P, F, I), setActiveBranch(Dp, kp)))) : (Dp.pendingId = suspenseId++, Np ? (Dp.isHydrating = !1, Dp.activeBranch = jp) : V(jp, M, Dp), Dp.deps = 0, Dp.effects.length = 0, Dp.hiddenContainer = U("div"), Mp ? (R(null, Op, Dp.hiddenContainer, null, M, Dp, P, F, I), Dp.deps <= 0 ? Dp.resolve() : (R(Ap, kp, E, O, M, null, P, F, I), setActiveBranch(Dp, kp))) : Ap && isSameVNodeType(Ap, Op) ? (R(Ap, Op, E, O, M, Dp, P, F, I), Dp.resolve(!0)) : (R(null, Op, Dp.hiddenContainer, null, M, Dp, P, F, I), Dp.deps <= 0 && Dp.resolve()));
	else if (Ap && isSameVNodeType(Ap, Op)) R(Ap, Op, E, O, M, Dp, P, F, I), setActiveBranch(Dp, Op);
	else if (triggerEvent(T, "onPending"), Dp.pendingBranch = Op, Op.shapeFlag & 512 ? Dp.pendingId = Op.component.suspenseId : Dp.pendingId = suspenseId++, R(null, Op, Dp.hiddenContainer, null, M, Dp, P, F, I), Dp.deps <= 0) Dp.resolve();
	else {
		let { timeout: u, pendingId: T } = Dp;
		u > 0 ? setTimeout(() => {
			Dp.pendingId === T && Dp.fallback(kp);
		}, u) : u === 0 && Dp.fallback(kp);
	}
}
function createSuspenseBoundary(u, T, E, O, M, P, F, I, R, V, U = !1) {
	let { p: Dp, m: Op, um: kp, n: Ap, o: { parentNode: jp, remove: Mp } } = V, Np, Pp = isVNodeSuspensible(u);
	Pp && T && T.pendingBranch && (Np = T.pendingId, T.deps++);
	let Fp = u.props ? toNumber(u.props.timeout) : void 0, Ip = P, Lp = {
		vnode: u,
		parent: T,
		parentComponent: E,
		namespace: F,
		container: O,
		hiddenContainer: M,
		deps: 0,
		pendingId: suspenseId++,
		timeout: typeof Fp == "number" ? Fp : -1,
		activeBranch: null,
		pendingBranch: null,
		isInFallback: !U,
		isHydrating: U,
		isUnmounted: !1,
		effects: [],
		resolve(u = !1, E = !1) {
			let { vnode: O, activeBranch: M, pendingBranch: F, pendingId: I, effects: R, parentComponent: V, container: U } = Lp, Dp = !1;
			Lp.isHydrating ? Lp.isHydrating = !1 : u || (Dp = M && F.transition && F.transition.mode === "out-in", Dp && (M.transition.afterLeave = () => {
				I === Lp.pendingId && (Op(F, U, P === Ip ? Ap(M) : P, 0), queuePostFlushCb(R));
			}), M && (jp(M.el) === U && (P = Ap(M)), kp(M, V, Lp, !0)), Dp || Op(F, U, P, 0)), setActiveBranch(Lp, F), Lp.pendingBranch = null, Lp.isInFallback = !1;
			let Mp = Lp.parent, Fp = !1;
			for (; Mp;) {
				if (Mp.pendingBranch) {
					Mp.effects.push(...R), Fp = !0;
					break;
				}
				Mp = Mp.parent;
			}
			!Fp && !Dp && queuePostFlushCb(R), Lp.effects = [], Pp && T && T.pendingBranch && Np === T.pendingId && (T.deps--, T.deps === 0 && !E && T.resolve()), triggerEvent(O, "onResolve");
		},
		fallback(u) {
			if (!Lp.pendingBranch) return;
			let { vnode: T, activeBranch: E, parentComponent: O, container: M, namespace: P } = Lp;
			triggerEvent(T, "onFallback");
			let F = Ap(E), V = () => {
				Lp.isInFallback && (Dp(null, u, M, F, O, null, P, I, R), setActiveBranch(Lp, u));
			}, U = u.transition && u.transition.mode === "out-in";
			U && (E.transition.afterLeave = V), Lp.isInFallback = !0, kp(E, O, null, !0), U || V();
		},
		move(u, T, E) {
			Lp.activeBranch && Op(Lp.activeBranch, u, T, E), Lp.container = u;
		},
		next() {
			return Lp.activeBranch && Ap(Lp.activeBranch);
		},
		registerDep(u, T, E) {
			let O = !!Lp.pendingBranch;
			O && Lp.deps++;
			let M = u.vnode.el;
			u.asyncDep.catch((T) => {
				handleError(T, u, 0);
			}).then((P) => {
				if (u.isUnmounted || Lp.isUnmounted || Lp.pendingId !== u.suspenseId) return;
				u.asyncResolved = !0;
				let { vnode: I } = u;
				handleSetupResult(u, P, !1), M && (I.el = M);
				let R = !M && u.subTree.el;
				T(u, I, jp(M || u.subTree.el), M ? null : Ap(u.subTree), Lp, F, E), R && Mp(R), updateHOCHostEl(u, I.el), O && --Lp.deps === 0 && Lp.resolve();
			});
		},
		unmount(u, T) {
			Lp.isUnmounted = !0, Lp.activeBranch && kp(Lp.activeBranch, E, u, T), Lp.pendingBranch && kp(Lp.pendingBranch, E, u, T);
		}
	};
	return Lp;
}
function hydrateSuspense(u, T, E, O, M, P, F, I, R) {
	let V = T.suspense = createSuspenseBoundary(T, O, E, u.parentNode, document.createElement("div"), null, M, P, F, I, !0), U = R(u, V.pendingBranch = T.ssContent, E, V, P, F);
	return V.deps === 0 && V.resolve(!1, !0), U;
}
function normalizeSuspenseChildren(u) {
	let { shapeFlag: T, children: E } = u, O = T & 32;
	u.ssContent = normalizeSuspenseSlot(O ? E.default : E), u.ssFallback = O ? normalizeSuspenseSlot(E.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(u) {
	let T;
	if (isFunction(u)) {
		let E = isBlockTreeEnabled && u._c;
		E && (u._d = !1, openBlock()), u = u(), E && (u._d = !0, T = currentBlock, closeBlock());
	}
	return isArray(u) && (u = filterSingleRoot(u)), u = normalizeVNode(u), T && !u.dynamicChildren && (u.dynamicChildren = T.filter((T) => T !== u)), u;
}
function queueEffectWithSuspense(u, T) {
	T && T.pendingBranch ? isArray(u) ? T.effects.push(...u) : T.effects.push(u) : queuePostFlushCb(u);
}
function setActiveBranch(u, T) {
	u.activeBranch = T;
	let { vnode: E, parentComponent: O } = u, M = T.el;
	for (; !M && T.component;) T = T.component.subTree, M = T.el;
	E.el = M, O && O.subTree === E && (O.vnode.el = M, updateHOCHostEl(O, M));
}
function isVNodeSuspensible(u) {
	let T = u.props && u.props.suspensible;
	return T != null && T !== !1;
}
var Fragment = Symbol.for("v-fgt"), Text = Symbol.for("v-txt"), Comment = Symbol.for("v-cmt"), Static = Symbol.for("v-stc"), blockStack = [], currentBlock = null;
function openBlock(u = !1) {
	blockStack.push(currentBlock = u ? null : []);
}
function closeBlock() {
	blockStack.pop(), currentBlock = blockStack[blockStack.length - 1] || null;
}
var isBlockTreeEnabled = 1;
function setBlockTracking(u, T = !1) {
	isBlockTreeEnabled += u, u < 0 && currentBlock && T && (currentBlock.hasOnce = !0);
}
function setupBlock(u) {
	return u.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null, closeBlock(), isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(u), u;
}
function createElementBlock(u, T, E, O, M, P) {
	return setupBlock(createBaseVNode(u, T, E, O, M, P, !0));
}
function createBlock(u, T, E, O, M) {
	return setupBlock(createVNode(u, T, E, O, M, !0));
}
function isVNode(u) {
	return u ? u.__v_isVNode === !0 : !1;
}
function isSameVNodeType(u, T) {
	return u.type === T.type && u.key === T.key;
}
function transformVNodeArgs(u) {}
var normalizeKey = ({ key: u }) => u ?? null, normalizeRef = ({ ref: u, ref_key: T, ref_for: E }) => (typeof u == "number" && (u = "" + u), u == null ? null : isString(u) || isRef(u) || isFunction(u) ? {
	i: currentRenderingInstance,
	r: u,
	k: T,
	f: !!E
} : u);
function createBaseVNode(u, T = null, E = null, O = 0, M = null, P = u === Fragment ? 0 : 1, F = !1, I = !1) {
	let R = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: u,
		props: T,
		key: T && normalizeKey(T),
		ref: T && normalizeRef(T),
		scopeId: currentScopeId,
		slotScopeIds: null,
		children: E,
		component: null,
		suspense: null,
		ssContent: null,
		ssFallback: null,
		dirs: null,
		transition: null,
		el: null,
		anchor: null,
		target: null,
		targetStart: null,
		targetAnchor: null,
		staticCount: 0,
		shapeFlag: P,
		patchFlag: O,
		dynamicProps: M,
		dynamicChildren: null,
		appContext: null,
		ctx: currentRenderingInstance
	};
	return I ? (normalizeChildren(R, E), P & 128 && u.normalize(R)) : E && (R.shapeFlag |= isString(E) ? 8 : 16), isBlockTreeEnabled > 0 && !F && currentBlock && (R.patchFlag > 0 || P & 6) && R.patchFlag !== 32 && currentBlock.push(R), R;
}
var createVNode = _createVNode;
function _createVNode(u, T = null, E = null, O = 0, M = null, P = !1) {
	if ((!u || u === NULL_DYNAMIC_COMPONENT) && (u = Comment), isVNode(u)) {
		let O = cloneVNode(u, T, !0);
		return E && normalizeChildren(O, E), isBlockTreeEnabled > 0 && !P && currentBlock && (O.shapeFlag & 6 ? currentBlock[currentBlock.indexOf(u)] = O : currentBlock.push(O)), O.patchFlag = -2, O;
	}
	if (isClassComponent(u) && (u = u.__vccOpts), T) {
		T = guardReactiveProps(T);
		let { class: u, style: E } = T;
		u && !isString(u) && (T.class = normalizeClass(u)), isObject$2(E) && (isProxy(E) && !isArray(E) && (E = extend({}, E)), T.style = normalizeStyle(E));
	}
	let F = isString(u) ? 1 : isSuspense(u) ? 128 : isTeleport(u) ? 64 : isObject$2(u) ? 4 : isFunction(u) ? 2 : 0;
	return createBaseVNode(u, T, E, O, M, F, P, !0);
}
function guardReactiveProps(u) {
	return u ? isProxy(u) || isInternalObject(u) ? extend({}, u) : u : null;
}
function cloneVNode(u, T, E = !1, O = !1) {
	let { props: M, ref: P, patchFlag: F, children: I, transition: R } = u, V = T ? mergeProps(M || {}, T) : M, U = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: u.type,
		props: V,
		key: V && normalizeKey(V),
		ref: T && T.ref ? E && P ? isArray(P) ? P.concat(normalizeRef(T)) : [P, normalizeRef(T)] : normalizeRef(T) : P,
		scopeId: u.scopeId,
		slotScopeIds: u.slotScopeIds,
		children: I,
		target: u.target,
		targetStart: u.targetStart,
		targetAnchor: u.targetAnchor,
		staticCount: u.staticCount,
		shapeFlag: u.shapeFlag,
		patchFlag: T && u.type !== Fragment ? F === -1 ? 16 : F | 16 : F,
		dynamicProps: u.dynamicProps,
		dynamicChildren: u.dynamicChildren,
		appContext: u.appContext,
		dirs: u.dirs,
		transition: R,
		component: u.component,
		suspense: u.suspense,
		ssContent: u.ssContent && cloneVNode(u.ssContent),
		ssFallback: u.ssFallback && cloneVNode(u.ssFallback),
		placeholder: u.placeholder,
		el: u.el,
		anchor: u.anchor,
		ctx: u.ctx,
		ce: u.ce
	};
	return R && O && setTransitionHooks(U, R.clone(U)), U;
}
function createTextVNode(u = " ", T = 0) {
	return createVNode(Text, null, u, T);
}
function createStaticVNode(u, T) {
	let E = createVNode(Static, null, u);
	return E.staticCount = T, E;
}
function createCommentVNode(u = "", T = !1) {
	return T ? (openBlock(), createBlock(Comment, null, u)) : createVNode(Comment, null, u);
}
function normalizeVNode(u) {
	return u == null || typeof u == "boolean" ? createVNode(Comment) : isArray(u) ? createVNode(Fragment, null, u.slice()) : isVNode(u) ? cloneIfMounted(u) : createVNode(Text, null, String(u));
}
function cloneIfMounted(u) {
	return u.el === null && u.patchFlag !== -1 || u.memo ? u : cloneVNode(u);
}
function normalizeChildren(u, T) {
	let E = 0, { shapeFlag: O } = u;
	if (T == null) T = null;
	else if (isArray(T)) E = 16;
	else if (typeof T == "object") if (O & 65) {
		let E = T.default;
		E && (E._c && (E._d = !1), normalizeChildren(u, E()), E._c && (E._d = !0));
		return;
	} else {
		E = 32;
		let O = T._;
		!O && !isInternalObject(T) ? T._ctx = currentRenderingInstance : O === 3 && currentRenderingInstance && (currentRenderingInstance.slots._ === 1 ? T._ = 1 : (T._ = 2, u.patchFlag |= 1024));
	}
	else isFunction(T) ? (T = {
		default: T,
		_ctx: currentRenderingInstance
	}, E = 32) : (T = String(T), O & 64 ? (E = 16, T = [createTextVNode(T)]) : E = 8);
	u.children = T, u.shapeFlag |= E;
}
function mergeProps(...u) {
	let T = {};
	for (let E = 0; E < u.length; E++) {
		let O = u[E];
		for (let u in O) if (u === "class") T.class !== O.class && (T.class = normalizeClass([T.class, O.class]));
		else if (u === "style") T.style = normalizeStyle([T.style, O.style]);
		else if (isOn(u)) {
			let E = T[u], M = O[u];
			M && E !== M && !(isArray(E) && E.includes(M)) && (T[u] = E ? [].concat(E, M) : M);
		} else u !== "" && (T[u] = O[u]);
	}
	return T;
}
function invokeVNodeHook(u, T, E, O = null) {
	callWithAsyncErrorHandling(u, T, 7, [E, O]);
}
var emptyAppContext = createAppContext(), uid = 0;
function createComponentInstance(u, T, E) {
	let M = u.type, P = (T ? T.appContext : u.appContext) || emptyAppContext, F = {
		uid: uid++,
		vnode: u,
		type: M,
		parent: T,
		appContext: P,
		root: null,
		next: null,
		subTree: null,
		effect: null,
		update: null,
		job: null,
		scope: new EffectScope(!0),
		render: null,
		proxy: null,
		exposed: null,
		exposeProxy: null,
		withProxy: null,
		provides: T ? T.provides : Object.create(P.provides),
		ids: T ? T.ids : [
			"",
			0,
			0
		],
		accessCache: null,
		renderCache: [],
		components: null,
		directives: null,
		propsOptions: normalizePropsOptions(M, P),
		emitsOptions: normalizeEmitsOptions(M, P),
		emit: null,
		emitted: null,
		propsDefaults: EMPTY_OBJ,
		inheritAttrs: M.inheritAttrs,
		ctx: EMPTY_OBJ,
		data: EMPTY_OBJ,
		props: EMPTY_OBJ,
		attrs: EMPTY_OBJ,
		slots: EMPTY_OBJ,
		refs: EMPTY_OBJ,
		setupState: EMPTY_OBJ,
		setupContext: null,
		suspense: E,
		suspenseId: E ? E.pendingId : 0,
		asyncDep: null,
		asyncResolved: !1,
		isMounted: !1,
		isUnmounted: !1,
		isDeactivated: !1,
		bc: null,
		c: null,
		bm: null,
		m: null,
		bu: null,
		u: null,
		um: null,
		bum: null,
		da: null,
		a: null,
		rtg: null,
		rtc: null,
		ec: null,
		sp: null
	};
	return F.ctx = { _: F }, F.root = T ? T.root : F, F.emit = emit.bind(null, F), u.ce && u.ce(F), F;
}
var currentInstance = null, getCurrentInstance = () => currentInstance || currentRenderingInstance, internalSetCurrentInstance, setInSSRSetupState;
{
	let u = getGlobalThis(), T = (T, E) => {
		let O;
		return (O = u[T]) || (O = u[T] = []), O.push(E), (u) => {
			O.length > 1 ? O.forEach((T) => T(u)) : O[0](u);
		};
	};
	internalSetCurrentInstance = T("__VUE_INSTANCE_SETTERS__", (u) => currentInstance = u), setInSSRSetupState = T("__VUE_SSR_SETTERS__", (u) => isInSSRComponentSetup = u);
}
var setCurrentInstance = (u) => {
	let T = currentInstance;
	return internalSetCurrentInstance(u), u.scope.on(), () => {
		u.scope.off(), internalSetCurrentInstance(T);
	};
}, unsetCurrentInstance = () => {
	currentInstance && currentInstance.scope.off(), internalSetCurrentInstance(null);
};
function isStatefulComponent(u) {
	return u.vnode.shapeFlag & 4;
}
var isInSSRComponentSetup = !1;
function setupComponent(u, T = !1, E = !1) {
	T && setInSSRSetupState(T);
	let { props: O, children: M } = u.vnode, P = isStatefulComponent(u);
	initProps(u, O, P, T), initSlots(u, M, E || T);
	let F = P ? setupStatefulComponent(u, T) : void 0;
	return T && setInSSRSetupState(!1), F;
}
function setupStatefulComponent(u, T) {
	let E = u.type;
	u.accessCache = /* @__PURE__ */ Object.create(null), u.proxy = new Proxy(u.ctx, PublicInstanceProxyHandlers);
	let { setup: O } = E;
	if (O) {
		pauseTracking();
		let E = u.setupContext = O.length > 1 ? createSetupContext(u) : null, M = setCurrentInstance(u), P = callWithErrorHandling(O, u, 0, [u.props, E]), F = isPromise(P);
		if (resetTracking(), M(), (F || u.sp) && !isAsyncWrapper(u) && markAsyncBoundary(u), F) {
			if (P.then(unsetCurrentInstance, unsetCurrentInstance), T) return P.then((E) => {
				handleSetupResult(u, E, T);
			}).catch((T) => {
				handleError(T, u, 0);
			});
			u.asyncDep = P;
		} else handleSetupResult(u, P, T);
	} else finishComponentSetup(u, T);
}
function handleSetupResult(u, T, E) {
	isFunction(T) ? u.type.__ssrInlineRender ? u.ssrRender = T : u.render = T : isObject$2(T) && (u.setupState = proxyRefs(T)), finishComponentSetup(u, E);
}
var compile$1, installWithProxy;
function registerRuntimeCompiler(u) {
	compile$1 = u, installWithProxy = (u) => {
		u.render._rc && (u.withProxy = new Proxy(u.ctx, RuntimeCompiledPublicInstanceProxyHandlers));
	};
}
var isRuntimeOnly = () => !compile$1;
function finishComponentSetup(u, T, E) {
	let O = u.type;
	if (!u.render) {
		if (!T && compile$1 && !O.render) {
			let T = O.template || resolveMergedOptions(u).template;
			if (T) {
				let { isCustomElement: E, compilerOptions: M } = u.appContext.config, { delimiters: P, compilerOptions: F } = O, I = extend(extend({
					isCustomElement: E,
					delimiters: P
				}, M), F);
				O.render = compile$1(T, I);
			}
		}
		u.render = O.render || NOOP, installWithProxy && installWithProxy(u);
	}
	{
		let T = setCurrentInstance(u);
		pauseTracking();
		try {
			applyOptions(u);
		} finally {
			resetTracking(), T();
		}
	}
}
var attrsProxyHandlers = { get(u, T) {
	return track(u, "get", ""), u[T];
} };
function createSetupContext(u) {
	return {
		attrs: new Proxy(u.attrs, attrsProxyHandlers),
		slots: u.slots,
		emit: u.emit,
		expose: (T) => {
			u.exposed = T || {};
		}
	};
}
function getComponentPublicInstance(u) {
	return u.exposed ? u.exposeProxy ||= new Proxy(proxyRefs(markRaw(u.exposed)), {
		get(T, E) {
			if (E in T) return T[E];
			if (E in publicPropertiesMap) return publicPropertiesMap[E](u);
		},
		has(u, T) {
			return T in u || T in publicPropertiesMap;
		}
	}) : u.proxy;
}
function getComponentName(u, T = !0) {
	return isFunction(u) ? u.displayName || u.name : u.name || T && u.__name;
}
function isClassComponent(u) {
	return isFunction(u) && "__vccOpts" in u;
}
var computed = (u, T) => computed$1(u, T, isInSSRComponentSetup);
function h$5(u, T, E) {
	try {
		setBlockTracking(-1);
		let O = arguments.length;
		return O === 2 ? isObject$2(T) && !isArray(T) ? isVNode(T) ? createVNode(u, null, [T]) : createVNode(u, T) : createVNode(u, null, T) : (O > 3 ? E = Array.prototype.slice.call(arguments, 2) : O === 3 && isVNode(E) && (E = [E]), createVNode(u, T, E));
	} finally {
		setBlockTracking(1);
	}
}
function initCustomFormatter() {
	return;
	function u(T, E, O) {
		let M = T[O];
		if (isArray(M) && M.includes(E) || isObject$2(M) && E in M || T.extends && u(T.extends, E, O) || T.mixins && T.mixins.some((T) => u(T, E, O))) return !0;
	}
}
function withMemo(u, T, E, O) {
	let M = E[O];
	if (M && isMemoSame(M, u)) return M;
	let P = T();
	return P.memo = u.slice(), P.cacheIndex = O, E[O] = P;
}
function isMemoSame(u, T) {
	let E = u.memo;
	if (E.length != T.length) return !1;
	for (let u = 0; u < E.length; u++) if (hasChanged(E[u], T[u])) return !1;
	return isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(u), !0;
}
var version = "3.5.22", warn = NOOP, ErrorTypeStrings = ErrorTypeStrings$1, devtools = devtools$1, setDevtoolsHook = setDevtoolsHook$1, ssrUtils = {
	createComponentInstance,
	setupComponent,
	renderComponentRoot,
	setCurrentRenderingInstance,
	isVNode,
	normalizeVNode,
	getComponentPublicInstance,
	ensureValidVNode,
	pushWarningContext,
	popWarningContext
}, policy = void 0, tt = typeof window < "u" && window.trustedTypes;
if (tt) try {
	policy = /* @__PURE__ */ tt.createPolicy("vue", { createHTML: (u) => u });
} catch {}
var unsafeToTrustedHTML = policy ? (u) => policy.createHTML(u) : (u) => u, svgNS = "http://www.w3.org/2000/svg", mathmlNS = "http://www.w3.org/1998/Math/MathML", doc = typeof document < "u" ? document : null, templateContainer = doc && /* @__PURE__ */ doc.createElement("template"), nodeOps = {
	insert: (u, T, E) => {
		T.insertBefore(u, E || null);
	},
	remove: (u) => {
		let T = u.parentNode;
		T && T.removeChild(u);
	},
	createElement: (u, T, E, O) => {
		let M = T === "svg" ? doc.createElementNS(svgNS, u) : T === "mathml" ? doc.createElementNS(mathmlNS, u) : E ? doc.createElement(u, { is: E }) : doc.createElement(u);
		return u === "select" && O && O.multiple != null && M.setAttribute("multiple", O.multiple), M;
	},
	createText: (u) => doc.createTextNode(u),
	createComment: (u) => doc.createComment(u),
	setText: (u, T) => {
		u.nodeValue = T;
	},
	setElementText: (u, T) => {
		u.textContent = T;
	},
	parentNode: (u) => u.parentNode,
	nextSibling: (u) => u.nextSibling,
	querySelector: (u) => doc.querySelector(u),
	setScopeId(u, T) {
		u.setAttribute(T, "");
	},
	insertStaticContent(u, T, E, O, M, P) {
		let F = E ? E.previousSibling : T.lastChild;
		if (M && (M === P || M.nextSibling)) for (; T.insertBefore(M.cloneNode(!0), E), !(M === P || !(M = M.nextSibling)););
		else {
			templateContainer.innerHTML = unsafeToTrustedHTML(O === "svg" ? `<svg>${u}</svg>` : O === "mathml" ? `<math>${u}</math>` : u);
			let M = templateContainer.content;
			if (O === "svg" || O === "mathml") {
				let u = M.firstChild;
				for (; u.firstChild;) M.appendChild(u.firstChild);
				M.removeChild(u);
			}
			T.insertBefore(M, E);
		}
		return [F ? F.nextSibling : T.firstChild, E ? E.previousSibling : T.lastChild];
	}
}, TRANSITION = "transition", ANIMATION = "animation", vtcKey = Symbol("_vtc"), DOMTransitionPropsValidators = {
	name: String,
	type: String,
	css: {
		type: Boolean,
		default: !0
	},
	duration: [
		String,
		Number,
		Object
	],
	enterFromClass: String,
	enterActiveClass: String,
	enterToClass: String,
	appearFromClass: String,
	appearActiveClass: String,
	appearToClass: String,
	leaveFromClass: String,
	leaveActiveClass: String,
	leaveToClass: String
}, TransitionPropsValidators = /* @__PURE__ */ extend({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators), Transition = /* @__PURE__ */ ((u) => (u.displayName = "Transition", u.props = TransitionPropsValidators, u))((u, { slots: T }) => h$5(BaseTransition, resolveTransitionProps(u), T)), callHook = (u, T = []) => {
	isArray(u) ? u.forEach((u) => u(...T)) : u && u(...T);
}, hasExplicitCallback = (u) => u ? isArray(u) ? u.some((u) => u.length > 1) : u.length > 1 : !1;
function resolveTransitionProps(u) {
	let T = {};
	for (let E in u) E in DOMTransitionPropsValidators || (T[E] = u[E]);
	if (u.css === !1) return T;
	let { name: E = "v", type: O, duration: M, enterFromClass: P = `${E}-enter-from`, enterActiveClass: F = `${E}-enter-active`, enterToClass: I = `${E}-enter-to`, appearFromClass: R = P, appearActiveClass: U = F, appearToClass: Dp = I, leaveFromClass: Op = `${E}-leave-from`, leaveActiveClass: kp = `${E}-leave-active`, leaveToClass: Ap = `${E}-leave-to` } = u, jp = normalizeDuration(M), Mp = jp && jp[0], Np = jp && jp[1], { onBeforeEnter: Pp, onEnter: Fp, onEnterCancelled: Ip, onLeave: Lp, onLeaveCancelled: Rp, onBeforeAppear: zp = Pp, onAppear: Bp = Fp, onAppearCancelled: Vp = Ip } = T, Hp = (u, T, E, O) => {
		u._enterCancelled = O, removeTransitionClass(u, T ? Dp : I), removeTransitionClass(u, T ? U : F), E && E();
	}, Up = (u, T) => {
		u._isLeaving = !1, removeTransitionClass(u, Op), removeTransitionClass(u, Ap), removeTransitionClass(u, kp), T && T();
	}, Wp = (u) => (T, E) => {
		let M = u ? Bp : Fp, F = () => Hp(T, u, E);
		callHook(M, [T, F]), nextFrame(() => {
			removeTransitionClass(T, u ? R : P), addTransitionClass(T, u ? Dp : I), hasExplicitCallback(M) || whenTransitionEnds(T, O, Mp, F);
		});
	};
	return extend(T, {
		onBeforeEnter(u) {
			callHook(Pp, [u]), addTransitionClass(u, P), addTransitionClass(u, F);
		},
		onBeforeAppear(u) {
			callHook(zp, [u]), addTransitionClass(u, R), addTransitionClass(u, U);
		},
		onEnter: Wp(!1),
		onAppear: Wp(!0),
		onLeave(u, T) {
			u._isLeaving = !0;
			let E = () => Up(u, T);
			addTransitionClass(u, Op), u._enterCancelled ? (addTransitionClass(u, kp), forceReflow(u)) : (forceReflow(u), addTransitionClass(u, kp)), nextFrame(() => {
				u._isLeaving && (removeTransitionClass(u, Op), addTransitionClass(u, Ap), hasExplicitCallback(Lp) || whenTransitionEnds(u, O, Np, E));
			}), callHook(Lp, [u, E]);
		},
		onEnterCancelled(u) {
			Hp(u, !1, void 0, !0), callHook(Ip, [u]);
		},
		onAppearCancelled(u) {
			Hp(u, !0, void 0, !0), callHook(Vp, [u]);
		},
		onLeaveCancelled(u) {
			Up(u), callHook(Rp, [u]);
		}
	});
}
function normalizeDuration(u) {
	if (u == null) return null;
	if (isObject$2(u)) return [NumberOf(u.enter), NumberOf(u.leave)];
	{
		let T = NumberOf(u);
		return [T, T];
	}
}
function NumberOf(u) {
	return toNumber(u);
}
function addTransitionClass(u, T) {
	T.split(/\s+/).forEach((T) => T && u.classList.add(T)), (u[vtcKey] || (u[vtcKey] = /* @__PURE__ */ new Set())).add(T);
}
function removeTransitionClass(u, T) {
	T.split(/\s+/).forEach((T) => T && u.classList.remove(T));
	let E = u[vtcKey];
	E && (E.delete(T), E.size || (u[vtcKey] = void 0));
}
function nextFrame(u) {
	requestAnimationFrame(() => {
		requestAnimationFrame(u);
	});
}
var endId = 0;
function whenTransitionEnds(u, T, E, O) {
	let M = u._endId = ++endId, P = () => {
		M === u._endId && O();
	};
	if (E != null) return setTimeout(P, E);
	let { type: F, timeout: I, propCount: R } = getTransitionInfo(u, T);
	if (!F) return O();
	let V = F + "end", U = 0, Dp = () => {
		u.removeEventListener(V, Op), P();
	}, Op = (T) => {
		T.target === u && ++U >= R && Dp();
	};
	setTimeout(() => {
		U < R && Dp();
	}, I + 1), u.addEventListener(V, Op);
}
function getTransitionInfo(u, T) {
	let E = window.getComputedStyle(u), O = (u) => (E[u] || "").split(", "), M = O(`${TRANSITION}Delay`), P = O(`${TRANSITION}Duration`), F = getTimeout(M, P), I = O(`${ANIMATION}Delay`), R = O(`${ANIMATION}Duration`), V = getTimeout(I, R), U = null, Dp = 0, Op = 0;
	T === TRANSITION ? F > 0 && (U = TRANSITION, Dp = F, Op = P.length) : T === ANIMATION ? V > 0 && (U = ANIMATION, Dp = V, Op = R.length) : (Dp = Math.max(F, V), U = Dp > 0 ? F > V ? TRANSITION : ANIMATION : null, Op = U ? U === TRANSITION ? P.length : R.length : 0);
	let kp = U === TRANSITION && /\b(?:transform|all)(?:,|$)/.test(O(`${TRANSITION}Property`).toString());
	return {
		type: U,
		timeout: Dp,
		propCount: Op,
		hasTransform: kp
	};
}
function getTimeout(u, T) {
	for (; u.length < T.length;) u = u.concat(u);
	return Math.max(...T.map((T, E) => toMs(T) + toMs(u[E])));
}
function toMs(u) {
	return u === "auto" ? 0 : Number(u.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow(u) {
	return (u ? u.ownerDocument : document).body.offsetHeight;
}
function patchClass(u, T, E) {
	let O = u[vtcKey];
	O && (T = (T ? [T, ...O] : [...O]).join(" ")), T == null ? u.removeAttribute("class") : E ? u.setAttribute("class", T) : u.className = T;
}
var vShowOriginalDisplay = Symbol("_vod"), vShowHidden = Symbol("_vsh"), vShow = {
	name: "show",
	beforeMount(u, { value: T }, { transition: E }) {
		u[vShowOriginalDisplay] = u.style.display === "none" ? "" : u.style.display, E && T ? E.beforeEnter(u) : setDisplay(u, T);
	},
	mounted(u, { value: T }, { transition: E }) {
		E && T && E.enter(u);
	},
	updated(u, { value: T, oldValue: E }, { transition: O }) {
		!T != !E && (O ? T ? (O.beforeEnter(u), setDisplay(u, !0), O.enter(u)) : O.leave(u, () => {
			setDisplay(u, !1);
		}) : setDisplay(u, T));
	},
	beforeUnmount(u, { value: T }) {
		setDisplay(u, T);
	}
};
function setDisplay(u, T) {
	u.style.display = T ? u[vShowOriginalDisplay] : "none", u[vShowHidden] = !T;
}
function initVShowForSSR() {
	vShow.getSSRProps = ({ value: u }) => {
		if (!u) return { style: { display: "none" } };
	};
}
var CSS_VAR_TEXT = Symbol("");
function useCssVars(u) {
	let T = getCurrentInstance();
	if (!T) return;
	let E = T.ut = (E = u(T.proxy)) => {
		Array.from(document.querySelectorAll(`[data-v-owner="${T.uid}"]`)).forEach((u) => setVarsOnNode(u, E));
	}, O = () => {
		let O = u(T.proxy);
		T.ce ? setVarsOnNode(T.ce, O) : setVarsOnVNode(T.subTree, O), E(O);
	};
	onBeforeUpdate(() => {
		queuePostFlushCb(O);
	}), onMounted(() => {
		watch(O, NOOP, { flush: "post" });
		let u = new MutationObserver(O);
		u.observe(T.subTree.el.parentNode, { childList: !0 }), onUnmounted(() => u.disconnect());
	});
}
function setVarsOnVNode(u, T) {
	if (u.shapeFlag & 128) {
		let E = u.suspense;
		u = E.activeBranch, E.pendingBranch && !E.isHydrating && E.effects.push(() => {
			setVarsOnVNode(E.activeBranch, T);
		});
	}
	for (; u.component;) u = u.component.subTree;
	if (u.shapeFlag & 1 && u.el) setVarsOnNode(u.el, T);
	else if (u.type === Fragment) u.children.forEach((u) => setVarsOnVNode(u, T));
	else if (u.type === Static) {
		let { el: E, anchor: O } = u;
		for (; E && (setVarsOnNode(E, T), E !== O);) E = E.nextSibling;
	}
}
function setVarsOnNode(u, T) {
	if (u.nodeType === 1) {
		let E = u.style, O = "";
		for (let u in T) {
			let M = normalizeCssVarValue(T[u]);
			E.setProperty(`--${u}`, M), O += `--${u}: ${M};`;
		}
		E[CSS_VAR_TEXT] = O;
	}
}
var displayRE = /(?:^|;)\s*display\s*:/;
function patchStyle(u, T, E) {
	let O = u.style, M = isString(E), P = !1;
	if (E && !M) {
		if (T) if (isString(T)) for (let u of T.split(";")) {
			let T = u.slice(0, u.indexOf(":")).trim();
			E[T] ?? setStyle(O, T, "");
		}
		else for (let u in T) E[u] ?? setStyle(O, u, "");
		for (let u in E) u === "display" && (P = !0), setStyle(O, u, E[u]);
	} else if (M) {
		if (T !== E) {
			let u = O[CSS_VAR_TEXT];
			u && (E += ";" + u), O.cssText = E, P = displayRE.test(E);
		}
	} else T && u.removeAttribute("style");
	vShowOriginalDisplay in u && (u[vShowOriginalDisplay] = P ? O.display : "", u[vShowHidden] && (O.display = "none"));
}
var importantRE = /\s*!important$/;
function setStyle(u, T, E) {
	if (isArray(E)) E.forEach((E) => setStyle(u, T, E));
	else if (E ??= "", T.startsWith("--")) u.setProperty(T, E);
	else {
		let O = autoPrefix(u, T);
		importantRE.test(E) ? u.setProperty(hyphenate$2(O), E.replace(importantRE, ""), "important") : u[O] = E;
	}
}
var prefixes = [
	"Webkit",
	"Moz",
	"ms"
], prefixCache = {};
function autoPrefix(u, T) {
	let E = prefixCache[T];
	if (E) return E;
	let O = camelize$2(T);
	if (O !== "filter" && O in u) return prefixCache[T] = O;
	O = capitalize(O);
	for (let E = 0; E < prefixes.length; E++) {
		let M = prefixes[E] + O;
		if (M in u) return prefixCache[T] = M;
	}
	return T;
}
var xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(u, T, E, O, M, P = isSpecialBooleanAttr(T)) {
	O && T.startsWith("xlink:") ? E == null ? u.removeAttributeNS(xlinkNS, T.slice(6, T.length)) : u.setAttributeNS(xlinkNS, T, E) : E == null || P && !includeBooleanAttr(E) ? u.removeAttribute(T) : u.setAttribute(T, P ? "" : isSymbol(E) ? String(E) : E);
}
function patchDOMProp(u, T, E, O, M) {
	if (T === "innerHTML" || T === "textContent") {
		E != null && (u[T] = T === "innerHTML" ? unsafeToTrustedHTML(E) : E);
		return;
	}
	let P = u.tagName;
	if (T === "value" && P !== "PROGRESS" && !P.includes("-")) {
		let O = P === "OPTION" ? u.getAttribute("value") || "" : u.value, M = E == null ? u.type === "checkbox" ? "on" : "" : String(E);
		(O !== M || !("_value" in u)) && (u.value = M), E ?? u.removeAttribute(T), u._value = E;
		return;
	}
	let F = !1;
	if (E === "" || E == null) {
		let O = typeof u[T];
		O === "boolean" ? E = includeBooleanAttr(E) : E == null && O === "string" ? (E = "", F = !0) : O === "number" && (E = 0, F = !0);
	}
	try {
		u[T] = E;
	} catch {}
	F && u.removeAttribute(M || T);
}
function addEventListener$1(u, T, E, O) {
	u.addEventListener(T, E, O);
}
function removeEventListener(u, T, E, O) {
	u.removeEventListener(T, E, O);
}
var veiKey = Symbol("_vei");
function patchEvent(u, T, E, O, M = null) {
	let P = u[veiKey] || (u[veiKey] = {}), F = P[T];
	if (O && F) F.value = O;
	else {
		let [E, I] = parseName(T);
		O ? addEventListener$1(u, E, P[T] = createInvoker(O, M), I) : F && (removeEventListener(u, E, F, I), P[T] = void 0);
	}
}
var optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(u) {
	let T;
	if (optionsModifierRE.test(u)) {
		T = {};
		let E;
		for (; E = u.match(optionsModifierRE);) u = u.slice(0, u.length - E[0].length), T[E[0].toLowerCase()] = !0;
	}
	return [u[2] === ":" ? u.slice(3) : hyphenate$2(u.slice(2)), T];
}
var cachedNow = 0, p$2 = /* @__PURE__ */ Promise.resolve(), getNow = () => cachedNow ||= (p$2.then(() => cachedNow = 0), Date.now());
function createInvoker(u, T) {
	let E = (u) => {
		if (!u._vts) u._vts = Date.now();
		else if (u._vts <= E.attached) return;
		callWithAsyncErrorHandling(patchStopImmediatePropagation(u, E.value), T, 5, [u]);
	};
	return E.value = u, E.attached = getNow(), E;
}
function patchStopImmediatePropagation(u, T) {
	if (isArray(T)) {
		let E = u.stopImmediatePropagation;
		return u.stopImmediatePropagation = () => {
			E.call(u), u._stopped = !0;
		}, T.map((u) => (T) => !T._stopped && u && u(T));
	} else return T;
}
var isNativeOn = (u) => u.charCodeAt(0) === 111 && u.charCodeAt(1) === 110 && u.charCodeAt(2) > 96 && u.charCodeAt(2) < 123, patchProp = (u, T, E, O, M, P) => {
	let F = M === "svg";
	T === "class" ? patchClass(u, O, F) : T === "style" ? patchStyle(u, E, O) : isOn(T) ? isModelListener(T) || patchEvent(u, T, E, O, P) : (T[0] === "." ? (T = T.slice(1), !0) : T[0] === "^" ? (T = T.slice(1), !1) : shouldSetAsProp(u, T, O, F)) ? (patchDOMProp(u, T, O), !u.tagName.includes("-") && (T === "value" || T === "checked" || T === "selected") && patchAttr(u, T, O, F, P, T !== "value")) : u._isVueCE && (/[A-Z]/.test(T) || !isString(O)) ? patchDOMProp(u, camelize$2(T), O, P, T) : (T === "true-value" ? u._trueValue = O : T === "false-value" && (u._falseValue = O), patchAttr(u, T, O, F));
};
function shouldSetAsProp(u, T, E, O) {
	if (O) return !!(T === "innerHTML" || T === "textContent" || T in u && isNativeOn(T) && isFunction(E));
	if (T === "spellcheck" || T === "draggable" || T === "translate" || T === "autocorrect" || T === "form" || T === "list" && u.tagName === "INPUT" || T === "type" && u.tagName === "TEXTAREA") return !1;
	if (T === "width" || T === "height") {
		let T = u.tagName;
		if (T === "IMG" || T === "VIDEO" || T === "CANVAS" || T === "SOURCE") return !1;
	}
	return isNativeOn(T) && isString(E) ? !1 : T in u;
}
var REMOVAL = {};
/* @__NO_SIDE_EFFECTS__ */
function defineCustomElement(u, T, E) {
	let O = /* @__PURE__ */ defineComponent(u, T);
	isPlainObject$1(O) && (O = extend({}, O, T));
	class M extends VueElement {
		constructor(u) {
			super(O, u, E);
		}
	}
	return M.def = O, M;
}
var defineSSRCustomElement = ((u, T) => /* @__PURE__ */ defineCustomElement(u, T, createSSRApp)), BaseClass = typeof HTMLElement < "u" ? HTMLElement : class {}, VueElement = class u extends BaseClass {
	constructor(u, T = {}, E = createApp) {
		super(), this._def = u, this._props = T, this._createApp = E, this._isVueCE = !0, this._instance = null, this._app = null, this._nonce = this._def.nonce, this._connected = !1, this._resolved = !1, this._numberProps = null, this._styleChildren = /* @__PURE__ */ new WeakSet(), this._ob = null, this.shadowRoot && E !== createApp ? this._root = this.shadowRoot : u.shadowRoot === !1 ? this._root = this : (this.attachShadow(extend({}, u.shadowRootOptions, { mode: "open" })), this._root = this.shadowRoot);
	}
	connectedCallback() {
		if (!this.isConnected) return;
		!this.shadowRoot && !this._resolved && this._parseSlots(), this._connected = !0;
		let T = this;
		for (; T &&= T.parentNode || T.host;) if (T instanceof u) {
			this._parent = T;
			break;
		}
		this._instance || (this._resolved ? this._mount(this._def) : T && T._pendingResolve ? this._pendingResolve = T._pendingResolve.then(() => {
			this._pendingResolve = void 0, this._resolveDef();
		}) : this._resolveDef());
	}
	_setParent(u = this._parent) {
		u && (this._instance.parent = u._instance, this._inheritParentContext(u));
	}
	_inheritParentContext(u = this._parent) {
		u && this._app && Object.setPrototypeOf(this._app._context.provides, u._instance.provides);
	}
	disconnectedCallback() {
		this._connected = !1, nextTick(() => {
			this._connected || (this._ob &&= (this._ob.disconnect(), null), this._app && this._app.unmount(), this._instance && (this._instance.ce = void 0), this._app = this._instance = null, this._teleportTargets &&= (this._teleportTargets.clear(), void 0));
		});
	}
	_processMutations(u) {
		for (let T of u) this._setAttr(T.attributeName);
	}
	_resolveDef() {
		if (this._pendingResolve) return;
		for (let u = 0; u < this.attributes.length; u++) this._setAttr(this.attributes[u].name);
		this._ob = new MutationObserver(this._processMutations.bind(this)), this._ob.observe(this, { attributes: !0 });
		let u = (u, T = !1) => {
			this._resolved = !0, this._pendingResolve = void 0;
			let { props: E, styles: O } = u, M;
			if (E && !isArray(E)) for (let u in E) {
				let T = E[u];
				(T === Number || T && T.type === Number) && (u in this._props && (this._props[u] = toNumber(this._props[u])), (M ||= /* @__PURE__ */ Object.create(null))[camelize$2(u)] = !0);
			}
			this._numberProps = M, this._resolveProps(u), this.shadowRoot && this._applyStyles(O), this._mount(u);
		}, T = this._def.__asyncLoader;
		T ? this._pendingResolve = T().then((T) => {
			T.configureApp = this._def.configureApp, u(this._def = T, !0);
		}) : u(this._def);
	}
	_mount(u) {
		this._app = this._createApp(u), this._inheritParentContext(), u.configureApp && u.configureApp(this._app), this._app._ceVNode = this._createVNode(), this._app.mount(this._root);
		let T = this._instance && this._instance.exposed;
		if (T) for (let u in T) hasOwn$2(this, u) || Object.defineProperty(this, u, { get: () => unref(T[u]) });
	}
	_resolveProps(u) {
		let { props: T } = u, E = isArray(T) ? T : Object.keys(T || {});
		for (let u of Object.keys(this)) u[0] !== "_" && E.includes(u) && this._setProp(u, this[u]);
		for (let u of E.map(camelize$2)) Object.defineProperty(this, u, {
			get() {
				return this._getProp(u);
			},
			set(T) {
				this._setProp(u, T, !0, !0);
			}
		});
	}
	_setAttr(u) {
		if (u.startsWith("data-v-")) return;
		let T = this.hasAttribute(u), E = T ? this.getAttribute(u) : REMOVAL, O = camelize$2(u);
		T && this._numberProps && this._numberProps[O] && (E = toNumber(E)), this._setProp(O, E, !1, !0);
	}
	_getProp(u) {
		return this._props[u];
	}
	_setProp(u, T, E = !0, O = !1) {
		if (T !== this._props[u] && (T === REMOVAL ? delete this._props[u] : (this._props[u] = T, u === "key" && this._app && (this._app._ceVNode.key = T)), O && this._instance && this._update(), E)) {
			let E = this._ob;
			E && (this._processMutations(E.takeRecords()), E.disconnect()), T === !0 ? this.setAttribute(hyphenate$2(u), "") : typeof T == "string" || typeof T == "number" ? this.setAttribute(hyphenate$2(u), T + "") : T || this.removeAttribute(hyphenate$2(u)), E && E.observe(this, { attributes: !0 });
		}
	}
	_update() {
		let u = this._createVNode();
		this._app && (u.appContext = this._app._context), render(u, this._root);
	}
	_createVNode() {
		let u = {};
		this.shadowRoot || (u.onVnodeMounted = u.onVnodeUpdated = this._renderSlots.bind(this));
		let T = createVNode(this._def, extend(u, this._props));
		return this._instance || (T.ce = (u) => {
			this._instance = u, u.ce = this, u.isCE = !0;
			let T = (u, T) => {
				this.dispatchEvent(new CustomEvent(u, isPlainObject$1(T[0]) ? extend({ detail: T }, T[0]) : { detail: T }));
			};
			u.emit = (u, ...E) => {
				T(u, E), hyphenate$2(u) !== u && T(hyphenate$2(u), E);
			}, this._setParent();
		}), T;
	}
	_applyStyles(u, T) {
		if (!u) return;
		if (T) {
			if (T === this._def || this._styleChildren.has(T)) return;
			this._styleChildren.add(T);
		}
		let E = this._nonce;
		for (let T = u.length - 1; T >= 0; T--) {
			let O = document.createElement("style");
			E && O.setAttribute("nonce", E), O.textContent = u[T], this.shadowRoot.prepend(O);
		}
	}
	_parseSlots() {
		let u = this._slots = {}, T;
		for (; T = this.firstChild;) {
			let E = T.nodeType === 1 && T.getAttribute("slot") || "default";
			(u[E] || (u[E] = [])).push(T), this.removeChild(T);
		}
	}
	_renderSlots() {
		let u = this._getSlots(), T = this._instance.type.__scopeId;
		for (let E = 0; E < u.length; E++) {
			let O = u[E], M = O.getAttribute("name") || "default", P = this._slots[M], F = O.parentNode;
			if (P) for (let u of P) {
				if (T && u.nodeType === 1) {
					let E = T + "-s", O = document.createTreeWalker(u, 1);
					u.setAttribute(E, "");
					let M;
					for (; M = O.nextNode();) M.setAttribute(E, "");
				}
				F.insertBefore(u, O);
			}
			else for (; O.firstChild;) F.insertBefore(O.firstChild, O);
			F.removeChild(O);
		}
	}
	_getSlots() {
		let u = [this];
		return this._teleportTargets && u.push(...this._teleportTargets), u.reduce((u, T) => (u.push(...Array.from(T.querySelectorAll("slot"))), u), []);
	}
	_injectChildStyle(u) {
		this._applyStyles(u.styles, u);
	}
	_removeChildStyle(u) {}
};
function useHost(u) {
	let T = getCurrentInstance();
	return T && T.ce || null;
}
function useShadowRoot() {
	let u = useHost();
	return u && u.shadowRoot;
}
function useCssModule(u = "$style") {
	{
		let T = getCurrentInstance();
		if (!T) return EMPTY_OBJ;
		let E = T.type.__cssModules;
		return E && E[u] || EMPTY_OBJ;
	}
}
var positionMap = /* @__PURE__ */ new WeakMap(), newPositionMap = /* @__PURE__ */ new WeakMap(), moveCbKey = Symbol("_moveCb"), enterCbKey = Symbol("_enterCb"), TransitionGroup = /* @__PURE__ */ ((u) => (delete u.props.mode, u))({
	name: "TransitionGroup",
	props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
		tag: String,
		moveClass: String
	}),
	setup(u, { slots: T }) {
		let E = getCurrentInstance(), O = useTransitionState(), M, P;
		return onUpdated(() => {
			if (!M.length) return;
			let T = u.moveClass || `${u.name || "v"}-move`;
			if (!hasCSSTransform(M[0].el, E.vnode.el, T)) {
				M = [];
				return;
			}
			M.forEach(callPendingCbs), M.forEach(recordPosition);
			let O = M.filter(applyTranslation);
			forceReflow(E.vnode.el), O.forEach((u) => {
				let E = u.el, O = E.style;
				addTransitionClass(E, T), O.transform = O.webkitTransform = O.transitionDuration = "";
				let M = E[moveCbKey] = (u) => {
					u && u.target !== E || (!u || u.propertyName.endsWith("transform")) && (E.removeEventListener("transitionend", M), E[moveCbKey] = null, removeTransitionClass(E, T));
				};
				E.addEventListener("transitionend", M);
			}), M = [];
		}), () => {
			let F = toRaw(u), I = resolveTransitionProps(F), R = F.tag || Fragment;
			if (M = [], P) for (let u = 0; u < P.length; u++) {
				let T = P[u];
				T.el && T.el instanceof Element && (M.push(T), setTransitionHooks(T, resolveTransitionHooks(T, I, O, E)), positionMap.set(T, T.el.getBoundingClientRect()));
			}
			P = T.default ? getTransitionRawChildren(T.default()) : [];
			for (let u = 0; u < P.length; u++) {
				let T = P[u];
				T.key != null && setTransitionHooks(T, resolveTransitionHooks(T, I, O, E));
			}
			return createVNode(R, null, P);
		};
	}
});
function callPendingCbs(u) {
	let T = u.el;
	T[moveCbKey] && T[moveCbKey](), T[enterCbKey] && T[enterCbKey]();
}
function recordPosition(u) {
	newPositionMap.set(u, u.el.getBoundingClientRect());
}
function applyTranslation(u) {
	let T = positionMap.get(u), E = newPositionMap.get(u), O = T.left - E.left, M = T.top - E.top;
	if (O || M) {
		let T = u.el.style;
		return T.transform = T.webkitTransform = `translate(${O}px,${M}px)`, T.transitionDuration = "0s", u;
	}
}
function hasCSSTransform(u, T, E) {
	let O = u.cloneNode(), M = u[vtcKey];
	M && M.forEach((u) => {
		u.split(/\s+/).forEach((u) => u && O.classList.remove(u));
	}), E.split(/\s+/).forEach((u) => u && O.classList.add(u)), O.style.display = "none";
	let P = T.nodeType === 1 ? T : T.parentNode;
	P.appendChild(O);
	let { hasTransform: F } = getTransitionInfo(O);
	return P.removeChild(O), F;
}
var getModelAssigner = (u) => {
	let T = u.props["onUpdate:modelValue"] || !1;
	return isArray(T) ? (u) => invokeArrayFns(T, u) : T;
};
function onCompositionStart(u) {
	u.target.composing = !0;
}
function onCompositionEnd(u) {
	let T = u.target;
	T.composing && (T.composing = !1, T.dispatchEvent(new Event("input")));
}
var assignKey = Symbol("_assign"), vModelText = {
	created(u, { modifiers: { lazy: T, trim: E, number: O } }, M) {
		u[assignKey] = getModelAssigner(M);
		let P = O || M.props && M.props.type === "number";
		addEventListener$1(u, T ? "change" : "input", (T) => {
			if (T.target.composing) return;
			let O = u.value;
			E && (O = O.trim()), P && (O = looseToNumber(O)), u[assignKey](O);
		}), E && addEventListener$1(u, "change", () => {
			u.value = u.value.trim();
		}), T || (addEventListener$1(u, "compositionstart", onCompositionStart), addEventListener$1(u, "compositionend", onCompositionEnd), addEventListener$1(u, "change", onCompositionEnd));
	},
	mounted(u, { value: T }) {
		u.value = T ?? "";
	},
	beforeUpdate(u, { value: T, oldValue: E, modifiers: { lazy: O, trim: M, number: P } }, F) {
		if (u[assignKey] = getModelAssigner(F), u.composing) return;
		let I = (P || u.type === "number") && !/^0\d/.test(u.value) ? looseToNumber(u.value) : u.value, R = T ?? "";
		I !== R && (document.activeElement === u && u.type !== "range" && (O && T === E || M && u.value.trim() === R) || (u.value = R));
	}
}, vModelCheckbox = {
	deep: !0,
	created(u, T, E) {
		u[assignKey] = getModelAssigner(E), addEventListener$1(u, "change", () => {
			let T = u._modelValue, E = getValue(u), O = u.checked, M = u[assignKey];
			if (isArray(T)) {
				let u = looseIndexOf(T, E), P = u !== -1;
				if (O && !P) M(T.concat(E));
				else if (!O && P) {
					let E = [...T];
					E.splice(u, 1), M(E);
				}
			} else if (isSet(T)) {
				let u = new Set(T);
				O ? u.add(E) : u.delete(E), M(u);
			} else M(getCheckboxValue(u, O));
		});
	},
	mounted: setChecked,
	beforeUpdate(u, T, E) {
		u[assignKey] = getModelAssigner(E), setChecked(u, T, E);
	}
};
function setChecked(u, { value: T, oldValue: E }, O) {
	u._modelValue = T;
	let M;
	if (isArray(T)) M = looseIndexOf(T, O.props.value) > -1;
	else if (isSet(T)) M = T.has(O.props.value);
	else {
		if (T === E) return;
		M = looseEqual(T, getCheckboxValue(u, !0));
	}
	u.checked !== M && (u.checked = M);
}
var vModelRadio = {
	created(u, { value: T }, E) {
		u.checked = looseEqual(T, E.props.value), u[assignKey] = getModelAssigner(E), addEventListener$1(u, "change", () => {
			u[assignKey](getValue(u));
		});
	},
	beforeUpdate(u, { value: T, oldValue: E }, O) {
		u[assignKey] = getModelAssigner(O), T !== E && (u.checked = looseEqual(T, O.props.value));
	}
}, vModelSelect = {
	deep: !0,
	created(u, { value: T, modifiers: { number: E } }, O) {
		let M = isSet(T);
		addEventListener$1(u, "change", () => {
			let T = Array.prototype.filter.call(u.options, (u) => u.selected).map((u) => E ? looseToNumber(getValue(u)) : getValue(u));
			u[assignKey](u.multiple ? M ? new Set(T) : T : T[0]), u._assigning = !0, nextTick(() => {
				u._assigning = !1;
			});
		}), u[assignKey] = getModelAssigner(O);
	},
	mounted(u, { value: T }) {
		setSelected(u, T);
	},
	beforeUpdate(u, T, E) {
		u[assignKey] = getModelAssigner(E);
	},
	updated(u, { value: T }) {
		u._assigning || setSelected(u, T);
	}
};
function setSelected(u, T) {
	let E = u.multiple, O = isArray(T);
	if (!(E && !O && !isSet(T))) {
		for (let M = 0, P = u.options.length; M < P; M++) {
			let P = u.options[M], F = getValue(P);
			if (E) if (O) {
				let u = typeof F;
				u === "string" || u === "number" ? P.selected = T.some((u) => String(u) === String(F)) : P.selected = looseIndexOf(T, F) > -1;
			} else P.selected = T.has(F);
			else if (looseEqual(getValue(P), T)) {
				u.selectedIndex !== M && (u.selectedIndex = M);
				return;
			}
		}
		!E && u.selectedIndex !== -1 && (u.selectedIndex = -1);
	}
}
function getValue(u) {
	return "_value" in u ? u._value : u.value;
}
function getCheckboxValue(u, T) {
	let E = T ? "_trueValue" : "_falseValue";
	return E in u ? u[E] : T;
}
var vModelDynamic = {
	created(u, T, E) {
		callModelHook(u, T, E, null, "created");
	},
	mounted(u, T, E) {
		callModelHook(u, T, E, null, "mounted");
	},
	beforeUpdate(u, T, E, O) {
		callModelHook(u, T, E, O, "beforeUpdate");
	},
	updated(u, T, E, O) {
		callModelHook(u, T, E, O, "updated");
	}
};
function resolveDynamicModel(u, T) {
	switch (u) {
		case "SELECT": return vModelSelect;
		case "TEXTAREA": return vModelText;
		default: switch (T) {
			case "checkbox": return vModelCheckbox;
			case "radio": return vModelRadio;
			default: return vModelText;
		}
	}
}
function callModelHook(u, T, E, O, M) {
	let P = resolveDynamicModel(u.tagName, E.props && E.props.type)[M];
	P && P(u, T, E, O);
}
function initVModelForSSR() {
	vModelText.getSSRProps = ({ value: u }) => ({ value: u }), vModelRadio.getSSRProps = ({ value: u }, T) => {
		if (T.props && looseEqual(T.props.value, u)) return { checked: !0 };
	}, vModelCheckbox.getSSRProps = ({ value: u }, T) => {
		if (isArray(u)) {
			if (T.props && looseIndexOf(u, T.props.value) > -1) return { checked: !0 };
		} else if (isSet(u)) {
			if (T.props && u.has(T.props.value)) return { checked: !0 };
		} else if (u) return { checked: !0 };
	}, vModelDynamic.getSSRProps = (u, T) => {
		if (typeof T.type != "string") return;
		let E = resolveDynamicModel(T.type.toUpperCase(), T.props && T.props.type);
		if (E.getSSRProps) return E.getSSRProps(u, T);
	};
}
var systemModifiers = [
	"ctrl",
	"shift",
	"alt",
	"meta"
], modifierGuards = {
	stop: (u) => u.stopPropagation(),
	prevent: (u) => u.preventDefault(),
	self: (u) => u.target !== u.currentTarget,
	ctrl: (u) => !u.ctrlKey,
	shift: (u) => !u.shiftKey,
	alt: (u) => !u.altKey,
	meta: (u) => !u.metaKey,
	left: (u) => "button" in u && u.button !== 0,
	middle: (u) => "button" in u && u.button !== 1,
	right: (u) => "button" in u && u.button !== 2,
	exact: (u, T) => systemModifiers.some((E) => u[`${E}Key`] && !T.includes(E))
}, withModifiers = (u, T) => {
	let E = u._withMods ||= {}, O = T.join(".");
	return E[O] || (E[O] = ((E, ...O) => {
		for (let u = 0; u < T.length; u++) {
			let O = modifierGuards[T[u]];
			if (O && O(E, T)) return;
		}
		return u(E, ...O);
	}));
}, keyNames = {
	esc: "escape",
	space: " ",
	up: "arrow-up",
	left: "arrow-left",
	right: "arrow-right",
	down: "arrow-down",
	delete: "backspace"
}, withKeys = (u, T) => {
	let E = u._withKeys ||= {}, O = T.join(".");
	return E[O] || (E[O] = ((E) => {
		if (!("key" in E)) return;
		let O = hyphenate$2(E.key);
		if (T.some((u) => u === O || keyNames[u] === O)) return u(E);
	}));
}, rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps), renderer, enabledHydration = !1;
function ensureRenderer() {
	return renderer ||= createRenderer(rendererOptions);
}
function ensureHydrationRenderer() {
	return renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions), enabledHydration = !0, renderer;
}
var render = ((...u) => {
	ensureRenderer().render(...u);
}), hydrate = ((...u) => {
	ensureHydrationRenderer().hydrate(...u);
}), createApp = ((...u) => {
	let T = ensureRenderer().createApp(...u), { mount: E } = T;
	return T.mount = (u) => {
		let O = normalizeContainer(u);
		if (!O) return;
		let M = T._component;
		!isFunction(M) && !M.render && !M.template && (M.template = O.innerHTML), O.nodeType === 1 && (O.textContent = "");
		let P = E(O, !1, resolveRootNamespace(O));
		return O instanceof Element && (O.removeAttribute("v-cloak"), O.setAttribute("data-v-app", "")), P;
	}, T;
}), createSSRApp = ((...u) => {
	let T = ensureHydrationRenderer().createApp(...u), { mount: E } = T;
	return T.mount = (u) => {
		let T = normalizeContainer(u);
		if (T) return E(T, !0, resolveRootNamespace(T));
	}, T;
});
function resolveRootNamespace(u) {
	if (u instanceof SVGElement) return "svg";
	if (typeof MathMLElement == "function" && u instanceof MathMLElement) return "mathml";
}
function normalizeContainer(u) {
	return isString(u) ? document.querySelector(u) : u;
}
var ssrDirectiveInitialized = !1, initDirectivesForSSR = () => {
	ssrDirectiveInitialized || (ssrDirectiveInitialized = !0, initVModelForSSR(), initVShowForSSR());
}, vue_runtime_esm_bundler_exports = /* @__PURE__ */ __export({
	BaseTransition: () => BaseTransition,
	BaseTransitionPropsValidators: () => BaseTransitionPropsValidators,
	Comment: () => Comment,
	DeprecationTypes: () => null,
	EffectScope: () => EffectScope,
	ErrorCodes: () => ErrorCodes,
	ErrorTypeStrings: () => ErrorTypeStrings,
	Fragment: () => Fragment,
	KeepAlive: () => KeepAlive,
	ReactiveEffect: () => ReactiveEffect,
	Static: () => Static,
	Suspense: () => Suspense,
	Teleport: () => Teleport,
	Text: () => Text,
	TrackOpTypes: () => TrackOpTypes,
	Transition: () => Transition,
	TransitionGroup: () => TransitionGroup,
	TriggerOpTypes: () => TriggerOpTypes,
	VueElement: () => VueElement,
	assertNumber: () => assertNumber,
	callWithAsyncErrorHandling: () => callWithAsyncErrorHandling,
	callWithErrorHandling: () => callWithErrorHandling,
	camelize: () => camelize$2,
	capitalize: () => capitalize,
	cloneVNode: () => cloneVNode,
	compatUtils: () => null,
	compile: () => compile,
	computed: () => computed,
	createApp: () => createApp,
	createBlock: () => createBlock,
	createCommentVNode: () => createCommentVNode,
	createElementBlock: () => createElementBlock,
	createElementVNode: () => createBaseVNode,
	createHydrationRenderer: () => createHydrationRenderer,
	createPropsRestProxy: () => createPropsRestProxy,
	createRenderer: () => createRenderer,
	createSSRApp: () => createSSRApp,
	createSlots: () => createSlots,
	createStaticVNode: () => createStaticVNode,
	createTextVNode: () => createTextVNode,
	createVNode: () => createVNode,
	customRef: () => customRef,
	defineAsyncComponent: () => defineAsyncComponent,
	defineComponent: () => defineComponent,
	defineCustomElement: () => defineCustomElement,
	defineEmits: () => defineEmits,
	defineExpose: () => defineExpose,
	defineModel: () => defineModel,
	defineOptions: () => defineOptions,
	defineProps: () => defineProps,
	defineSSRCustomElement: () => defineSSRCustomElement,
	defineSlots: () => defineSlots,
	devtools: () => devtools,
	effect: () => effect,
	effectScope: () => effectScope,
	getCurrentInstance: () => getCurrentInstance,
	getCurrentScope: () => getCurrentScope,
	getCurrentWatcher: () => getCurrentWatcher,
	getTransitionRawChildren: () => getTransitionRawChildren,
	guardReactiveProps: () => guardReactiveProps,
	h: () => h$5,
	handleError: () => handleError,
	hasInjectionContext: () => hasInjectionContext,
	hydrate: () => hydrate,
	hydrateOnIdle: () => hydrateOnIdle,
	hydrateOnInteraction: () => hydrateOnInteraction,
	hydrateOnMediaQuery: () => hydrateOnMediaQuery,
	hydrateOnVisible: () => hydrateOnVisible,
	initCustomFormatter: () => initCustomFormatter,
	initDirectivesForSSR: () => initDirectivesForSSR,
	inject: () => inject,
	isMemoSame: () => isMemoSame,
	isProxy: () => isProxy,
	isReactive: () => isReactive,
	isReadonly: () => isReadonly,
	isRef: () => isRef,
	isRuntimeOnly: () => isRuntimeOnly,
	isShallow: () => isShallow,
	isVNode: () => isVNode,
	markRaw: () => markRaw,
	mergeDefaults: () => mergeDefaults,
	mergeModels: () => mergeModels,
	mergeProps: () => mergeProps,
	nextTick: () => nextTick,
	normalizeClass: () => normalizeClass,
	normalizeProps: () => normalizeProps,
	normalizeStyle: () => normalizeStyle,
	onActivated: () => onActivated,
	onBeforeMount: () => onBeforeMount,
	onBeforeUnmount: () => onBeforeUnmount,
	onBeforeUpdate: () => onBeforeUpdate,
	onDeactivated: () => onDeactivated,
	onErrorCaptured: () => onErrorCaptured,
	onMounted: () => onMounted,
	onRenderTracked: () => onRenderTracked,
	onRenderTriggered: () => onRenderTriggered,
	onScopeDispose: () => onScopeDispose,
	onServerPrefetch: () => onServerPrefetch,
	onUnmounted: () => onUnmounted,
	onUpdated: () => onUpdated,
	onWatcherCleanup: () => onWatcherCleanup,
	openBlock: () => openBlock,
	popScopeId: () => popScopeId,
	provide: () => provide,
	proxyRefs: () => proxyRefs,
	pushScopeId: () => pushScopeId,
	queuePostFlushCb: () => queuePostFlushCb,
	reactive: () => reactive,
	readonly: () => readonly,
	ref: () => ref,
	registerRuntimeCompiler: () => registerRuntimeCompiler,
	render: () => render,
	renderList: () => renderList,
	renderSlot: () => renderSlot,
	resolveComponent: () => resolveComponent,
	resolveDirective: () => resolveDirective,
	resolveDynamicComponent: () => resolveDynamicComponent,
	resolveFilter: () => null,
	resolveTransitionHooks: () => resolveTransitionHooks,
	setBlockTracking: () => setBlockTracking,
	setDevtoolsHook: () => setDevtoolsHook,
	setTransitionHooks: () => setTransitionHooks,
	shallowReactive: () => shallowReactive,
	shallowReadonly: () => shallowReadonly,
	shallowRef: () => shallowRef,
	ssrContextKey: () => ssrContextKey,
	ssrUtils: () => ssrUtils,
	stop: () => stop,
	toDisplayString: () => toDisplayString,
	toHandlerKey: () => toHandlerKey,
	toHandlers: () => toHandlers,
	toRaw: () => toRaw,
	toRef: () => toRef,
	toRefs: () => toRefs,
	toValue: () => toValue,
	transformVNodeArgs: () => transformVNodeArgs,
	triggerRef: () => triggerRef,
	unref: () => unref,
	useAttrs: () => useAttrs,
	useCssModule: () => useCssModule,
	useCssVars: () => useCssVars,
	useHost: () => useHost,
	useId: () => useId$1,
	useModel: () => useModel,
	useSSRContext: () => useSSRContext,
	useShadowRoot: () => useShadowRoot,
	useSlots: () => useSlots,
	useTemplateRef: () => useTemplateRef,
	useTransitionState: () => useTransitionState,
	vModelCheckbox: () => vModelCheckbox,
	vModelDynamic: () => vModelDynamic,
	vModelRadio: () => vModelRadio,
	vModelSelect: () => vModelSelect,
	vModelText: () => vModelText,
	vShow: () => vShow,
	version: () => version,
	warn: () => warn,
	watch: () => watch,
	watchEffect: () => watchEffect,
	watchPostEffect: () => watchPostEffect,
	watchSyncEffect: () => watchSyncEffect,
	withAsyncContext: () => withAsyncContext,
	withCtx: () => withCtx,
	withDefaults: () => withDefaults,
	withDirectives: () => withDirectives,
	withKeys: () => withKeys,
	withMemo: () => withMemo,
	withModifiers: () => withModifiers,
	withScopeId: () => withScopeId
}), compile = () => {}, activePinia, setActivePinia = (u) => activePinia = u, piniaSymbol = Symbol();
function isPlainObject(u) {
	return u && typeof u == "object" && Object.prototype.toString.call(u) === "[object Object]" && typeof u.toJSON != "function";
}
var MutationType;
(function(u) {
	u.direct = "direct", u.patchObject = "patch object", u.patchFunction = "patch function";
})(MutationType ||= {});
var IS_CLIENT = typeof window < "u", _global = /* @__PURE__ */ (() => typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : { HTMLElement: null })();
function bom(u, { autoBom: T = !1 } = {}) {
	return T && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(u.type) ? new Blob(["", u], { type: u.type }) : u;
}
function download(u, T, E) {
	let O = new XMLHttpRequest();
	O.open("GET", u), O.responseType = "blob", O.onload = function() {
		saveAs(O.response, T, E);
	}, O.onerror = function() {
		console.error("could not download file");
	}, O.send();
}
function corsEnabled(u) {
	let T = new XMLHttpRequest();
	T.open("HEAD", u, !1);
	try {
		T.send();
	} catch {}
	return T.status >= 200 && T.status <= 299;
}
function click(u) {
	try {
		u.dispatchEvent(new MouseEvent("click"));
	} catch {
		let T = new MouseEvent("click", {
			bubbles: !0,
			cancelable: !0,
			view: window,
			detail: 0,
			screenX: 80,
			screenY: 20,
			clientX: 80,
			clientY: 20,
			ctrlKey: !1,
			altKey: !1,
			shiftKey: !1,
			metaKey: !1,
			button: 0,
			relatedTarget: null
		});
		u.dispatchEvent(T);
	}
}
var _navigator = typeof navigator == "object" ? navigator : { userAgent: "" }, isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))(), saveAs = IS_CLIENT ? typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : "msSaveOrOpenBlob" in _navigator ? msSaveAs : fileSaverSaveAs : () => {};
function downloadSaveAs(u, T = "download", E) {
	let O = document.createElement("a");
	O.download = T, O.rel = "noopener", typeof u == "string" ? (O.href = u, O.origin === location.origin ? click(O) : corsEnabled(O.href) ? download(u, T, E) : (O.target = "_blank", click(O))) : (O.href = URL.createObjectURL(u), setTimeout(function() {
		URL.revokeObjectURL(O.href);
	}, 4e4), setTimeout(function() {
		click(O);
	}, 0));
}
function msSaveAs(u, T = "download", E) {
	if (typeof u == "string") if (corsEnabled(u)) download(u, T, E);
	else {
		let T = document.createElement("a");
		T.href = u, T.target = "_blank", setTimeout(function() {
			click(T);
		});
	}
	else navigator.msSaveOrOpenBlob(bom(u, E), T);
}
function fileSaverSaveAs(u, T, E, O) {
	if (O ||= open("", "_blank"), O && (O.document.title = O.document.body.innerText = "downloading..."), typeof u == "string") return download(u, T, E);
	let M = u.type === "application/octet-stream", P = /constructor/i.test(String(_global.HTMLElement)) || "safari" in _global, F = /CriOS\/[\d]+/.test(navigator.userAgent);
	if ((F || M && P || isMacOSWebView) && typeof FileReader < "u") {
		let T = new FileReader();
		T.onloadend = function() {
			let u = T.result;
			if (typeof u != "string") throw O = null, Error("Wrong reader.result type");
			u = F ? u : u.replace(/^data:[^;]*;/, "data:attachment/file;"), O ? O.location.href = u : location.assign(u), O = null;
		}, T.readAsDataURL(u);
	} else {
		let T = URL.createObjectURL(u);
		O ? O.location.assign(T) : location.href = T, O = null, setTimeout(function() {
			URL.revokeObjectURL(T);
		}, 4e4);
	}
}
var { assign: assign$1 } = Object;
function createPinia() {
	let u = effectScope(!0), T = u.run(() => ref({})), E = [], O = [], M = markRaw({
		install(u) {
			setActivePinia(M), M._a = u, u.provide(piniaSymbol, M), u.config.globalProperties.$pinia = M, O.forEach((u) => E.push(u)), O = [];
		},
		use(u) {
			return this._a ? E.push(u) : O.push(u), this;
		},
		_p: E,
		_a: null,
		_e: u,
		_s: /* @__PURE__ */ new Map(),
		state: T
	});
	return M;
}
var noop$2 = () => {};
function addSubscription(u, T, E, O = noop$2) {
	u.push(T);
	let M = () => {
		let E = u.indexOf(T);
		E > -1 && (u.splice(E, 1), O());
	};
	return !E && getCurrentScope() && onScopeDispose(M), M;
}
function triggerSubscriptions(u, ...T) {
	u.slice().forEach((u) => {
		u(...T);
	});
}
var fallbackRunWithContext = (u) => u(), ACTION_MARKER = Symbol(), ACTION_NAME = Symbol();
function mergeReactiveObjects(u, T) {
	for (let E in u instanceof Map && T instanceof Map ? T.forEach((T, E) => u.set(E, T)) : u instanceof Set && T instanceof Set && T.forEach(u.add, u), T) {
		if (!T.hasOwnProperty(E)) continue;
		let O = T[E], M = u[E];
		isPlainObject(M) && isPlainObject(O) && u.hasOwnProperty(E) && !isRef(O) && !isReactive(O) ? u[E] = mergeReactiveObjects(M, O) : u[E] = O;
	}
	return u;
}
var skipHydrateSymbol = Symbol();
function shouldHydrate(u) {
	return !isPlainObject(u) || !Object.prototype.hasOwnProperty.call(u, skipHydrateSymbol);
}
var { assign } = Object;
function isComputed(u) {
	return !!(isRef(u) && u.effect);
}
function createOptionsStore(u, T, E, O) {
	let { state: M, actions: P, getters: F } = T, I = E.state.value[u], R;
	function V() {
		return I || (E.state.value[u] = M ? M() : {}), assign(toRefs(E.state.value[u]), P, Object.keys(F || {}).reduce((T, O) => (T[O] = markRaw(computed(() => {
			setActivePinia(E);
			let T = E._s.get(u);
			return F[O].call(T, T);
		})), T), {}));
	}
	return R = createSetupStore(u, V, T, E, O, !0), R;
}
function createSetupStore(u, T, E = {}, O, M, P) {
	let F, I = assign({ actions: {} }, E), R = { deep: !0 }, V, U, Dp = [], Op = [], kp = O.state.value[u];
	!P && !kp && (O.state.value[u] = {}), ref({});
	let Ap;
	function jp(T) {
		let E;
		V = U = !1, typeof T == "function" ? (T(O.state.value[u]), E = {
			type: MutationType.patchFunction,
			storeId: u,
			events: void 0
		}) : (mergeReactiveObjects(O.state.value[u], T), E = {
			type: MutationType.patchObject,
			payload: T,
			storeId: u,
			events: void 0
		});
		let M = Ap = Symbol();
		nextTick().then(() => {
			Ap === M && (V = !0);
		}), U = !0, triggerSubscriptions(Dp, E, O.state.value[u]);
	}
	let Mp = P ? function() {
		let { state: u } = E, T = u ? u() : {};
		this.$patch((u) => {
			assign(u, T);
		});
	} : noop$2;
	function Np() {
		F.stop(), Dp = [], Op = [], O._s.delete(u);
	}
	let Pp = (T, E = "") => {
		if (ACTION_MARKER in T) return T[ACTION_NAME] = E, T;
		let M = function() {
			setActivePinia(O);
			let E = Array.from(arguments), P = [], F = [];
			function I(u) {
				P.push(u);
			}
			function R(u) {
				F.push(u);
			}
			triggerSubscriptions(Op, {
				args: E,
				name: M[ACTION_NAME],
				store: Fp,
				after: I,
				onError: R
			});
			let V;
			try {
				V = T.apply(this && this.$id === u ? this : Fp, E);
			} catch (u) {
				throw triggerSubscriptions(F, u), u;
			}
			return V instanceof Promise ? V.then((u) => (triggerSubscriptions(P, u), u)).catch((u) => (triggerSubscriptions(F, u), Promise.reject(u))) : (triggerSubscriptions(P, V), V);
		};
		return M[ACTION_MARKER] = !0, M[ACTION_NAME] = E, M;
	}, Fp = reactive({
		_p: O,
		$id: u,
		$onAction: addSubscription.bind(null, Op),
		$patch: jp,
		$reset: Mp,
		$subscribe(T, E = {}) {
			let M = addSubscription(Dp, T, E.detached, () => P()), P = F.run(() => watch(() => O.state.value[u], (O) => {
				(E.flush === "sync" ? U : V) && T({
					storeId: u,
					type: MutationType.direct,
					events: void 0
				}, O);
			}, assign({}, R, E)));
			return M;
		},
		$dispose: Np
	});
	O._s.set(u, Fp);
	let Ip = (O._a && O._a.runWithContext || fallbackRunWithContext)(() => O._e.run(() => (F = effectScope()).run(() => T({ action: Pp }))));
	for (let T in Ip) {
		let E = Ip[T];
		isRef(E) && !isComputed(E) || isReactive(E) ? P || (kp && shouldHydrate(E) && (isRef(E) ? E.value = kp[T] : mergeReactiveObjects(E, kp[T])), O.state.value[u][T] = E) : typeof E == "function" && (Ip[T] = Pp(E, T), I.actions[T] = E);
	}
	return assign(Fp, Ip), assign(toRaw(Fp), Ip), Object.defineProperty(Fp, "$state", {
		get: () => O.state.value[u],
		set: (u) => {
			jp((T) => {
				assign(T, u);
			});
		}
	}), O._p.forEach((u) => {
		assign(Fp, F.run(() => u({
			store: Fp,
			app: O._a,
			pinia: O,
			options: I
		})));
	}), kp && P && E.hydrate && E.hydrate(Fp.$state, kp), V = !0, U = !0, Fp;
}
/*! #__NO_SIDE_EFFECTS__ */
function defineStore(u, T, E) {
	let O, M = typeof T == "function";
	O = M ? E : T;
	function P(E, P) {
		let F = hasInjectionContext();
		return E ||= F ? inject(piniaSymbol, null) : null, E && setActivePinia(E), E = activePinia, E._s.has(u) || (M ? createSetupStore(u, T, O, E) : createOptionsStore(u, O, E)), E._s.get(u);
	}
	return P.$id = u, P;
}
function storeToRefs(u) {
	let T = toRaw(u), E = {};
	for (let O in T) {
		let M = T[O];
		M.effect ? E[O] = computed({
			get: () => u[O],
			set(T) {
				u[O] = T;
			}
		}) : (isRef(M) || isReactive(M)) && (E[O] = toRef(u, O));
	}
	return E;
}
var iu = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function au(u) {
	return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
}
var _l = { exports: {} }, ru = _l.exports, xt;
function su() {
	return xt || (xt = 1, function(u, T) {
		(function(T, E) {
			u.exports = E();
		})(ru, function() {
			var u = function(T, E) {
				return (u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(u, T) {
					u.__proto__ = T;
				} || function(u, T) {
					for (var E in T) Object.prototype.hasOwnProperty.call(T, E) && (u[E] = T[E]);
				})(T, E);
			}, T = function() {
				return (T = Object.assign || function(u) {
					for (var T, E = 1, O = arguments.length; E < O; E++) for (var M in T = arguments[E]) Object.prototype.hasOwnProperty.call(T, M) && (u[M] = T[M]);
					return u;
				}).apply(this, arguments);
			};
			function E(u, T, E) {
				for (var O, M = 0, P = T.length; M < P; M++) !O && M in T || ((O ||= Array.prototype.slice.call(T, 0, M))[M] = T[M]);
				return u.concat(O || Array.prototype.slice.call(T));
			}
			var O = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : iu, M = Object.keys, P = Array.isArray;
			function F(u, T) {
				return typeof T != "object" || M(T).forEach(function(E) {
					u[E] = T[E];
				}), u;
			}
			typeof Promise > "u" || O.Promise || (O.Promise = Promise);
			var I = Object.getPrototypeOf, R = {}.hasOwnProperty;
			function V(u, T) {
				return R.call(u, T);
			}
			function U(u, T) {
				typeof T == "function" && (T = T(I(u))), (typeof Reflect > "u" ? M : Reflect.ownKeys)(T).forEach(function(E) {
					Op(u, E, T[E]);
				});
			}
			var Dp = Object.defineProperty;
			function Op(u, T, E, O) {
				Dp(u, T, F(E && V(E, "get") && typeof E.get == "function" ? {
					get: E.get,
					set: E.set,
					configurable: !0
				} : {
					value: E,
					configurable: !0,
					writable: !0
				}, O));
			}
			function kp(u) {
				return { from: function(T) {
					return u.prototype = Object.create(T.prototype), Op(u.prototype, "constructor", u), { extend: U.bind(null, u.prototype) };
				} };
			}
			var Ap = Object.getOwnPropertyDescriptor, jp = [].slice;
			function Mp(u, T, E) {
				return jp.call(u, T, E);
			}
			function Np(u, T) {
				return T(u);
			}
			function Pp(u) {
				if (!u) throw Error("Assertion Failed");
			}
			function Fp(u) {
				O.setImmediate ? setImmediate(u) : setTimeout(u, 0);
			}
			function Ip(u, T) {
				if (typeof T == "string" && V(u, T)) return u[T];
				if (!T) return u;
				if (typeof T != "string") {
					for (var E = [], O = 0, M = T.length; O < M; ++O) {
						var P = Ip(u, T[O]);
						E.push(P);
					}
					return E;
				}
				var F = T.indexOf(".");
				if (F !== -1) {
					var I = u[T.substr(0, F)];
					return I == null ? void 0 : Ip(I, T.substr(F + 1));
				}
			}
			function Lp(u, T, E) {
				if (u && T !== void 0 && !("isFrozen" in Object && Object.isFrozen(u))) if (typeof T != "string" && "length" in T) {
					Pp(typeof E != "string" && "length" in E);
					for (var O = 0, M = T.length; O < M; ++O) Lp(u, T[O], E[O]);
				} else {
					var F, I, R = T.indexOf(".");
					R === -1 ? E === void 0 ? P(u) && !isNaN(parseInt(T)) ? u.splice(T, 1) : delete u[T] : u[T] = E : (F = T.substr(0, R), (I = T.substr(R + 1)) === "" ? E === void 0 ? P(u) && !isNaN(parseInt(F)) ? u.splice(F, 1) : delete u[F] : u[F] = E : Lp(R = !(R = u[F]) || !V(u, F) ? u[F] = {} : R, I, E));
				}
			}
			function Rp(u) {
				var T, E = {};
				for (T in u) V(u, T) && (E[T] = u[T]);
				return E;
			}
			var zp = [].concat;
			function Bp(u) {
				return zp.apply([], u);
			}
			var Vp = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Bp([
				8,
				16,
				32,
				64
			].map(function(u) {
				return [
					"Int",
					"Uint",
					"Float"
				].map(function(T) {
					return T + u + "Array";
				});
			}))).filter(function(u) {
				return O[u];
			}), Hp = new Set(Vp.map(function(u) {
				return O[u];
			})), Up = null;
			function Wp(u) {
				return Up = /* @__PURE__ */ new WeakMap(), u = function u(T) {
					if (!T || typeof T != "object") return T;
					var E = Up.get(T);
					if (E) return E;
					if (P(T)) {
						E = [], Up.set(T, E);
						for (var O = 0, M = T.length; O < M; ++O) E.push(u(T[O]));
					} else if (Hp.has(T.constructor)) E = T;
					else {
						var F, R = I(T);
						for (F in E = R === Object.prototype ? {} : Object.create(R), Up.set(T, E), T) V(T, F) && (E[F] = u(T[F]));
					}
					return E;
				}(u), Up = null, u;
			}
			var Gp = {}.toString;
			function Kp(u) {
				return Gp.call(u).slice(8, -1);
			}
			var qp = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Jp = typeof qp == "symbol" ? function(u) {
				var T;
				return u != null && (T = u[qp]) && T.apply(u);
			} : function() {
				return null;
			};
			function Yp(u, T) {
				return T = u.indexOf(T), 0 <= T && u.splice(T, 1), 0 <= T;
			}
			var Xp = {};
			function Zp(u) {
				var T, E, O, M;
				if (arguments.length === 1) {
					if (P(u)) return u.slice();
					if (this === Xp && typeof u == "string") return [u];
					if (M = Jp(u)) {
						for (E = []; !(O = M.next()).done;) E.push(O.value);
						return E;
					}
					if (u == null || typeof (T = u.length) != "number") return [u];
					for (E = Array(T); T--;) E[T] = u[T];
					return E;
				}
				for (T = arguments.length, E = Array(T); T--;) E[T] = arguments[T];
				return E;
			}
			var Qp = typeof Symbol < "u" ? function(u) {
				return u[Symbol.toStringTag] === "AsyncFunction";
			} : function() {
				return !1;
			}, $p = [
				"Unknown",
				"Constraint",
				"Data",
				"TransactionInactive",
				"ReadOnly",
				"Version",
				"NotFound",
				"InvalidState",
				"InvalidAccess",
				"Abort",
				"Timeout",
				"QuotaExceeded",
				"Syntax",
				"DataClone"
			], em = [
				"Modify",
				"Bulk",
				"OpenFailed",
				"VersionChange",
				"Schema",
				"Upgrade",
				"InvalidTable",
				"MissingAPI",
				"NoSuchDatabase",
				"InvalidArgument",
				"SubTransaction",
				"Unsupported",
				"Internal",
				"DatabaseClosed",
				"PrematureCommit",
				"ForeignAwait"
			].concat($p), tm = {
				VersionChanged: "Database version changed by other database connection",
				DatabaseClosed: "Database has been closed",
				Abort: "Transaction aborted",
				TransactionInactive: "Transaction has already completed or failed",
				MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
			};
			function nm(u, T) {
				this.name = u, this.message = T;
			}
			function rm(u, T) {
				return u + ". Errors: " + Object.keys(T).map(function(u) {
					return T[u].toString();
				}).filter(function(u, T, E) {
					return E.indexOf(u) === T;
				}).join("\n");
			}
			function im(u, T, E, O) {
				this.failures = T, this.failedKeys = O, this.successCount = E, this.message = rm(u, T);
			}
			function am(u, T) {
				this.name = "BulkError", this.failures = Object.keys(T).map(function(u) {
					return T[u];
				}), this.failuresByPos = T, this.message = rm(u, this.failures);
			}
			kp(nm).from(Error).extend({ toString: function() {
				return this.name + ": " + this.message;
			} }), kp(im).from(nm), kp(am).from(nm);
			var om = em.reduce(function(u, T) {
				return u[T] = T + "Error", u;
			}, {}), sm = nm, cm = em.reduce(function(u, T) {
				var E = T + "Error";
				function O(u, O) {
					this.name = E, u ? typeof u == "string" ? (this.message = `${u}${O ? "\n " + O : ""}`, this.inner = O || null) : typeof u == "object" && (this.message = `${u.name} ${u.message}`, this.inner = u) : (this.message = tm[T] || E, this.inner = null);
				}
				return kp(O).from(sm), u[T] = O, u;
			}, {});
			cm.Syntax = SyntaxError, cm.Type = TypeError, cm.Range = RangeError;
			var lm = $p.reduce(function(u, T) {
				return u[T + "Error"] = cm[T], u;
			}, {}), um = em.reduce(function(u, T) {
				return [
					"Syntax",
					"Type",
					"Range"
				].indexOf(T) === -1 && (u[T + "Error"] = cm[T]), u;
			}, {});
			function dm() {}
			function fm(u) {
				return u;
			}
			function pm(u, T) {
				return u == null || u === fm ? T : function(E) {
					return T(u(E));
				};
			}
			function mm(u, T) {
				return function() {
					u.apply(this, arguments), T.apply(this, arguments);
				};
			}
			function hm(u, T) {
				return u === dm ? T : function() {
					var E = u.apply(this, arguments);
					E !== void 0 && (arguments[0] = E);
					var O = this.onsuccess, M = this.onerror;
					this.onsuccess = null, this.onerror = null;
					var P = T.apply(this, arguments);
					return O && (this.onsuccess = this.onsuccess ? mm(O, this.onsuccess) : O), M && (this.onerror = this.onerror ? mm(M, this.onerror) : M), P === void 0 ? E : P;
				};
			}
			function gm(u, T) {
				return u === dm ? T : function() {
					u.apply(this, arguments);
					var E = this.onsuccess, O = this.onerror;
					this.onsuccess = this.onerror = null, T.apply(this, arguments), E && (this.onsuccess = this.onsuccess ? mm(E, this.onsuccess) : E), O && (this.onerror = this.onerror ? mm(O, this.onerror) : O);
				};
			}
			function _m(u, T) {
				return u === dm ? T : function(E) {
					var O = u.apply(this, arguments);
					F(E, O);
					var M = this.onsuccess, P = this.onerror;
					return this.onsuccess = null, this.onerror = null, E = T.apply(this, arguments), M && (this.onsuccess = this.onsuccess ? mm(M, this.onsuccess) : M), P && (this.onerror = this.onerror ? mm(P, this.onerror) : P), O === void 0 ? E === void 0 ? void 0 : E : F(O, E);
				};
			}
			function vm(u, T) {
				return u === dm ? T : function() {
					return T.apply(this, arguments) !== !1 && u.apply(this, arguments);
				};
			}
			function ym(u, T) {
				return u === dm ? T : function() {
					var E = u.apply(this, arguments);
					if (E && typeof E.then == "function") {
						for (var O = this, M = arguments.length, P = Array(M); M--;) P[M] = arguments[M];
						return E.then(function() {
							return T.apply(O, P);
						});
					}
					return T.apply(this, arguments);
				};
			}
			um.ModifyError = im, um.DexieError = nm, um.BulkError = am;
			var bm = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
			function xm(u) {
				bm = u;
			}
			var Sm = {}, Cm = 100, Vp = typeof Promise > "u" ? [] : function() {
				var u = Promise.resolve();
				if (typeof crypto > "u" || !crypto.subtle) return [
					u,
					I(u),
					u
				];
				var T = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
				return [
					T,
					I(T),
					u
				];
			}(), $p = Vp[0], em = Vp[1], Vp = Vp[2], em = em && em.then, wm = $p && $p.constructor, Tm = !!Vp, Em = function(u, T) {
				Pm.push([u, T]), Om &&= (queueMicrotask(Wm), !1);
			}, Dm = !0, Om = !0, km = [], Am = [], jm = fm, Mm = {
				id: "global",
				global: !0,
				ref: 0,
				unhandleds: [],
				onunhandled: dm,
				pgp: !1,
				env: {},
				finalize: dm
			}, Nm = Mm, Pm = [], Fm = 0, Im = [];
			function Lm(u) {
				if (typeof this != "object") throw TypeError("Promises must be constructed via new");
				this._listeners = [], this._lib = !1;
				var T = this._PSD = Nm;
				if (typeof u != "function") {
					if (u !== Sm) throw TypeError("Not a function");
					this._state = arguments[1], this._value = arguments[2], this._state === !1 && Bm(this, this._value);
					return;
				}
				this._state = null, this._value = null, ++T.ref, function u(T, E) {
					try {
						E(function(E) {
							if (T._state === null) {
								if (E === T) throw TypeError("A promise cannot be resolved with itself.");
								var O = T._lib && Gm();
								E && typeof E.then == "function" ? u(T, function(u, T) {
									E instanceof Lm ? E._then(u, T) : E.then(u, T);
								}) : (T._state = !0, T._value = E, Vm(T)), O && Km();
							}
						}, Bm.bind(null, T));
					} catch (u) {
						Bm(T, u);
					}
				}(this, u);
			}
			var Rm = {
				get: function() {
					var u = Nm, T = eh;
					function E(E, O) {
						var M = this, P = !u.global && (u !== Nm || T !== eh), F = P && !ih(), I = new Lm(function(T, I) {
							Hm(M, new zm(uh(E, u, P, F), uh(O, u, P, F), T, I, u));
						});
						return this._consoleTask && (I._consoleTask = this._consoleTask), I;
					}
					return E.prototype = Sm, E;
				},
				set: function(u) {
					Op(this, "then", u && u.prototype === Sm ? Rm : {
						get: function() {
							return u;
						},
						set: Rm.set
					});
				}
			};
			function zm(u, T, E, O, M) {
				this.onFulfilled = typeof u == "function" ? u : null, this.onRejected = typeof T == "function" ? T : null, this.resolve = E, this.reject = O, this.psd = M;
			}
			function Bm(u, T) {
				var E, O;
				Am.push(T), u._state === null && (E = u._lib && Gm(), T = jm(T), u._state = !1, u._value = T, O = u, km.some(function(u) {
					return u._value === O._value;
				}) || km.push(O), Vm(u), E && Km());
			}
			function Vm(u) {
				var T = u._listeners;
				u._listeners = [];
				for (var E = 0, O = T.length; E < O; ++E) Hm(u, T[E]);
				var M = u._PSD;
				--M.ref || M.finalize(), Fm === 0 && (++Fm, Em(function() {
					--Fm == 0 && qm();
				}, []));
			}
			function Hm(u, T) {
				if (u._state !== null) {
					var E = u._state ? T.onFulfilled : T.onRejected;
					if (E === null) return (u._state ? T.resolve : T.reject)(u._value);
					++T.psd.ref, ++Fm, Em(Um, [
						E,
						u,
						T
					]);
				} else u._listeners.push(T);
			}
			function Um(u, T, E) {
				try {
					var O, M = T._value;
					!T._state && Am.length && (Am = []), O = bm && T._consoleTask ? T._consoleTask.run(function() {
						return u(M);
					}) : u(M), T._state || Am.indexOf(M) !== -1 || function(u) {
						for (var T = km.length; T;) if (km[--T]._value === u._value) return km.splice(T, 1);
					}(T), E.resolve(O);
				} catch (u) {
					E.reject(u);
				} finally {
					--Fm == 0 && qm(), --E.psd.ref || E.psd.finalize();
				}
			}
			function Wm() {
				lh(Mm, function() {
					Gm() && Km();
				});
			}
			function Gm() {
				var u = Dm;
				return Om = Dm = !1, u;
			}
			function Km() {
				var u, T, E;
				do
					for (; 0 < Pm.length;) for (u = Pm, Pm = [], E = u.length, T = 0; T < E; ++T) {
						var O = u[T];
						O[0].apply(null, O[1]);
					}
				while (0 < Pm.length);
				Om = Dm = !0;
			}
			function qm() {
				var u = km;
				km = [], u.forEach(function(u) {
					u._PSD.onunhandled.call(null, u._value, u);
				});
				for (var T = Im.slice(0), E = T.length; E;) T[--E]();
			}
			function Jm(u) {
				return new Lm(Sm, !1, u);
			}
			function Ym(u, T) {
				var E = Nm;
				return function() {
					var O = Gm(), M = Nm;
					try {
						return sh(E, !0), u.apply(this, arguments);
					} catch (u) {
						T && T(u);
					} finally {
						sh(M, !1), O && Km();
					}
				};
			}
			U(Lm.prototype, {
				then: Rm,
				_then: function(u, T) {
					Hm(this, new zm(null, null, u, T, Nm));
				},
				catch: function(u) {
					if (arguments.length === 1) return this.then(null, u);
					var T = u, E = arguments[1];
					return typeof T == "function" ? this.then(null, function(u) {
						return (u instanceof T ? E : Jm)(u);
					}) : this.then(null, function(u) {
						return (u && u.name === T ? E : Jm)(u);
					});
				},
				finally: function(u) {
					return this.then(function(T) {
						return Lm.resolve(u()).then(function() {
							return T;
						});
					}, function(T) {
						return Lm.resolve(u()).then(function() {
							return Jm(T);
						});
					});
				},
				timeout: function(u, T) {
					var E = this;
					return u < Infinity ? new Lm(function(O, M) {
						var P = setTimeout(function() {
							return M(new cm.Timeout(T));
						}, u);
						E.then(O, M).finally(clearTimeout.bind(null, P));
					}) : this;
				}
			}), typeof Symbol < "u" && Symbol.toStringTag && Op(Lm.prototype, Symbol.toStringTag, "Dexie.Promise"), Mm.env = ch(), U(Lm, {
				all: function() {
					var u = Zp.apply(null, arguments).map(ah);
					return new Lm(function(T, E) {
						u.length === 0 && T([]);
						var O = u.length;
						u.forEach(function(M, P) {
							return Lm.resolve(M).then(function(E) {
								u[P] = E, --O || T(u);
							}, E);
						});
					});
				},
				resolve: function(u) {
					return u instanceof Lm ? u : u && typeof u.then == "function" ? new Lm(function(T, E) {
						u.then(T, E);
					}) : new Lm(Sm, !0, u);
				},
				reject: Jm,
				race: function() {
					var u = Zp.apply(null, arguments).map(ah);
					return new Lm(function(T, E) {
						u.map(function(u) {
							return Lm.resolve(u).then(T, E);
						});
					});
				},
				PSD: {
					get: function() {
						return Nm;
					},
					set: function(u) {
						return Nm = u;
					}
				},
				totalEchoes: { get: function() {
					return eh;
				} },
				newPSD: nh,
				usePSD: lh,
				scheduler: {
					get: function() {
						return Em;
					},
					set: function(u) {
						Em = u;
					}
				},
				rejectionMapper: {
					get: function() {
						return jm;
					},
					set: function(u) {
						jm = u;
					}
				},
				follow: function(u, T) {
					return new Lm(function(E, O) {
						return nh(function(T, E) {
							var O = Nm;
							O.unhandleds = [], O.onunhandled = E, O.finalize = mm(function() {
								var u, O = this;
								u = function() {
									O.unhandleds.length === 0 ? T() : E(O.unhandleds[0]);
								}, Im.push(function T() {
									u(), Im.splice(Im.indexOf(T), 1);
								}), ++Fm, Em(function() {
									--Fm == 0 && qm();
								}, []);
							}, O.finalize), u();
						}, T, E, O);
					});
				}
			}), wm && (wm.allSettled && Op(Lm, "allSettled", function() {
				var u = Zp.apply(null, arguments).map(ah);
				return new Lm(function(T) {
					u.length === 0 && T([]);
					var E = u.length, O = Array(E);
					u.forEach(function(u, M) {
						return Lm.resolve(u).then(function(u) {
							return O[M] = {
								status: "fulfilled",
								value: u
							};
						}, function(u) {
							return O[M] = {
								status: "rejected",
								reason: u
							};
						}).then(function() {
							return --E || T(O);
						});
					});
				});
			}), wm.any && typeof AggregateError < "u" && Op(Lm, "any", function() {
				var u = Zp.apply(null, arguments).map(ah);
				return new Lm(function(T, E) {
					u.length === 0 && E(/* @__PURE__ */ AggregateError([]));
					var O = u.length, M = Array(O);
					u.forEach(function(u, P) {
						return Lm.resolve(u).then(function(u) {
							return T(u);
						}, function(u) {
							M[P] = u, --O || E(AggregateError(M));
						});
					});
				});
			}), wm.withResolvers && (Lm.withResolvers = wm.withResolvers));
			var Xm = {
				awaits: 0,
				echoes: 0,
				id: 0
			}, Zm = 0, Qm = [], $m = 0, eh = 0, th = 0;
			function nh(u, T, E, O) {
				var M = Nm, P = Object.create(M);
				return P.parent = M, P.ref = 0, P.global = !1, P.id = ++th, Mm.env, P.env = Tm ? {
					Promise: Lm,
					PromiseProp: {
						value: Lm,
						configurable: !0,
						writable: !0
					},
					all: Lm.all,
					race: Lm.race,
					allSettled: Lm.allSettled,
					any: Lm.any,
					resolve: Lm.resolve,
					reject: Lm.reject
				} : {}, T && F(P, T), ++M.ref, P.finalize = function() {
					--this.parent.ref || this.parent.finalize();
				}, O = lh(P, u, E, O), P.ref === 0 && P.finalize(), O;
			}
			function rh() {
				return Xm.id ||= ++Zm, ++Xm.awaits, Xm.echoes += Cm, Xm.id;
			}
			function ih() {
				return !!Xm.awaits && (--Xm.awaits == 0 && (Xm.id = 0), Xm.echoes = Xm.awaits * Cm, !0);
			}
			function ah(u) {
				return Xm.echoes && u && u.constructor === wm ? (rh(), u.then(function(u) {
					return ih(), u;
				}, function(u) {
					return ih(), fh(u);
				})) : u;
			}
			function oh() {
				var u = Qm[Qm.length - 1];
				Qm.pop(), sh(u, !1);
			}
			function sh(u, T) {
				var E, M = Nm;
				(T ? !Xm.echoes || $m++ && u === Nm : !$m || --$m && u === Nm) || queueMicrotask(T ? (function(u) {
					++eh, Xm.echoes && --Xm.echoes != 0 || (Xm.echoes = Xm.awaits = Xm.id = 0), Qm.push(Nm), sh(u, !0);
				}).bind(null, u) : oh), u !== Nm && (Nm = u, M === Mm && (Mm.env = ch()), Tm && (E = Mm.env.Promise, T = u.env, (M.global || u.global) && (Object.defineProperty(O, "Promise", T.PromiseProp), E.all = T.all, E.race = T.race, E.resolve = T.resolve, E.reject = T.reject, T.allSettled && (E.allSettled = T.allSettled), T.any && (E.any = T.any))));
			}
			function ch() {
				var u = O.Promise;
				return Tm ? {
					Promise: u,
					PromiseProp: Object.getOwnPropertyDescriptor(O, "Promise"),
					all: u.all,
					race: u.race,
					allSettled: u.allSettled,
					any: u.any,
					resolve: u.resolve,
					reject: u.reject
				} : {};
			}
			function lh(u, T, E, O, M) {
				var P = Nm;
				try {
					return sh(u, !0), T(E, O, M);
				} finally {
					sh(P, !1);
				}
			}
			function uh(u, T, E, O) {
				return typeof u == "function" ? function() {
					var M = Nm;
					E && rh(), sh(T, !0);
					try {
						return u.apply(this, arguments);
					} finally {
						sh(M, !1), O && queueMicrotask(ih);
					}
				} : u;
			}
			function dh(u) {
				Promise === wm && Xm.echoes === 0 ? $m === 0 ? u() : enqueueNativeMicroTask(u) : setTimeout(u, 0);
			}
			("" + em).indexOf("[native code]") === -1 && (rh = ih = dm);
			var fh = Lm.reject, ph = "", mh = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", hh = "String expected.", gh = [], _h = "__dbnames", vh = "readonly", yh = "readwrite";
			function bh(u, T) {
				return u ? T ? function() {
					return u.apply(this, arguments) && T.apply(this, arguments);
				} : u : T;
			}
			var xh = {
				type: 3,
				lower: -Infinity,
				lowerOpen: !1,
				upper: [[]],
				upperOpen: !1
			};
			function Sh(u) {
				return typeof u != "string" || /\./.test(u) ? function(u) {
					return u;
				} : function(T) {
					return T[u] === void 0 && u in T && delete (T = Wp(T))[u], T;
				};
			}
			function Ch() {
				throw cm.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
			}
			function wh(u, T) {
				try {
					var E = Th(u), O = Th(T);
					if (E !== O) return E === "Array" ? 1 : O === "Array" ? -1 : E === "binary" ? 1 : O === "binary" ? -1 : E === "string" ? 1 : O === "string" ? -1 : E === "Date" ? 1 : O === "Date" ? -1 : NaN;
					switch (E) {
						case "number":
						case "Date":
						case "string": return T < u ? 1 : u < T ? -1 : 0;
						case "binary": return function(u, T) {
							for (var E = u.length, O = T.length, M = E < O ? E : O, P = 0; P < M; ++P) if (u[P] !== T[P]) return u[P] < T[P] ? -1 : 1;
							return E === O ? 0 : E < O ? -1 : 1;
						}(Eh(u), Eh(T));
						case "Array": return function(u, T) {
							for (var E = u.length, O = T.length, M = E < O ? E : O, P = 0; P < M; ++P) {
								var F = wh(u[P], T[P]);
								if (F !== 0) return F;
							}
							return E === O ? 0 : E < O ? -1 : 1;
						}(u, T);
					}
				} catch {}
				return NaN;
			}
			function Th(u) {
				var T = typeof u;
				return T == "object" ? ArrayBuffer.isView(u) ? "binary" : (u = Kp(u), u === "ArrayBuffer" ? "binary" : u) : T;
			}
			function Eh(u) {
				return u instanceof Uint8Array ? u : ArrayBuffer.isView(u) ? new Uint8Array(u.buffer, u.byteOffset, u.byteLength) : new Uint8Array(u);
			}
			function Dh(u, T, E) {
				var O = u.schema.yProps;
				return O ? (T && 0 < E.numFailures && (T = T.filter(function(u, T) {
					return !E.failures[T];
				})), Promise.all(O.map(function(E) {
					return E = E.updatesTable, T ? u.db.table(E).where("k").anyOf(T).delete() : u.db.table(E).clear();
				})).then(function() {
					return E;
				})) : E;
			}
			var Oh = (kh.prototype._trans = function(u, T, E) {
				var O = this._tx || Nm.trans, M = this.name, P = bm && typeof console < "u" && console.createTask && console.createTask(`Dexie: ${u === "readonly" ? "read" : "write"} ${this.name}`);
				function F(u, E, O) {
					if (!O.schema[M]) throw new cm.NotFound("Table " + M + " not part of transaction");
					return T(O.idbtrans, O);
				}
				var I = Gm();
				try {
					var R = O && O.db._novip === this.db._novip ? O === Nm.trans ? O._promise(u, F, E) : nh(function() {
						return O._promise(u, F, E);
					}, {
						trans: O,
						transless: Nm.transless || Nm
					}) : function u(T, E, O, M) {
						if (T.idbdb && (T._state.openComplete || Nm.letThrough || T._vip)) {
							var P = T._createTransaction(E, O, T._dbSchema);
							try {
								P.create(), T._state.PR1398_maxLoop = 3;
							} catch (P) {
								return P.name === om.InvalidState && T.isOpen() && 0 < --T._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), T.close({ disableAutoOpen: !1 }), T.open().then(function() {
									return u(T, E, O, M);
								})) : fh(P);
							}
							return P._promise(E, function(u, T) {
								return nh(function() {
									return Nm.trans = P, M(u, T, P);
								});
							}).then(function(u) {
								if (E === "readwrite") try {
									P.idbtrans.commit();
								} catch {}
								return E === "readonly" ? u : P._completion.then(function() {
									return u;
								});
							});
						}
						if (T._state.openComplete) return fh(new cm.DatabaseClosed(T._state.dbOpenError));
						if (!T._state.isBeingOpened) {
							if (!T._state.autoOpen) return fh(new cm.DatabaseClosed());
							T.open().catch(dm);
						}
						return T._state.dbReadyPromise.then(function() {
							return u(T, E, O, M);
						});
					}(this.db, u, [this.name], F);
					return P && (R._consoleTask = P, R = R.catch(function(u) {
						return console.trace(u), fh(u);
					})), R;
				} finally {
					I && Km();
				}
			}, kh.prototype.get = function(u, T) {
				var E = this;
				return u && u.constructor === Object ? this.where(u).first(T) : u == null ? fh(new cm.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(T) {
					return E.core.get({
						trans: T,
						key: u
					}).then(function(u) {
						return E.hook.reading.fire(u);
					});
				}).then(T);
			}, kh.prototype.where = function(u) {
				if (typeof u == "string") return new this.db.WhereClause(this, u);
				if (P(u)) return new this.db.WhereClause(this, `[${u.join("+")}]`);
				var T = M(u);
				if (T.length === 1) return this.where(T[0]).equals(u[T[0]]);
				var E = this.schema.indexes.concat(this.schema.primKey).filter(function(u) {
					if (u.compound && T.every(function(T) {
						return 0 <= u.keyPath.indexOf(T);
					})) {
						for (var E = 0; E < T.length; ++E) if (T.indexOf(u.keyPath[E]) === -1) return !1;
						return !0;
					}
					return !1;
				}).sort(function(u, T) {
					return u.keyPath.length - T.keyPath.length;
				})[0];
				if (E && this.db._maxKey !== ph) {
					var O = E.keyPath.slice(0, T.length);
					return this.where(O).equals(O.map(function(T) {
						return u[T];
					}));
				}
				!E && bm && console.warn(`The query ${JSON.stringify(u)} on ${this.name} would benefit from a compound index [${T.join("+")}]`);
				var F = this.schema.idxByName;
				function I(u, T) {
					return wh(u, T) === 0;
				}
				var R = T.reduce(function(T, E) {
					var O = T[0], M = T[1], T = F[E], R = u[E];
					return [O || T, O || !T ? bh(M, T && T.multi ? function(u) {
						return u = Ip(u, E), P(u) && u.some(function(u) {
							return I(R, u);
						});
					} : function(u) {
						return I(R, Ip(u, E));
					}) : M];
				}, [null, null]), O = R[0], R = R[1];
				return O ? this.where(O.name).equals(u[O.keyPath]).filter(R) : E ? this.filter(R) : this.where(T).equals("");
			}, kh.prototype.filter = function(u) {
				return this.toCollection().and(u);
			}, kh.prototype.count = function(u) {
				return this.toCollection().count(u);
			}, kh.prototype.offset = function(u) {
				return this.toCollection().offset(u);
			}, kh.prototype.limit = function(u) {
				return this.toCollection().limit(u);
			}, kh.prototype.each = function(u) {
				return this.toCollection().each(u);
			}, kh.prototype.toArray = function(u) {
				return this.toCollection().toArray(u);
			}, kh.prototype.toCollection = function() {
				return new this.db.Collection(new this.db.WhereClause(this));
			}, kh.prototype.orderBy = function(u) {
				return new this.db.Collection(new this.db.WhereClause(this, P(u) ? `[${u.join("+")}]` : u));
			}, kh.prototype.reverse = function() {
				return this.toCollection().reverse();
			}, kh.prototype.mapToClass = function(T) {
				var E, O = this.db, M = this.name;
				function P() {
					return E !== null && E.apply(this, arguments) || this;
				}
				(this.schema.mappedClass = T).prototype instanceof Ch && (function(T, E) {
					if (typeof E != "function" && E !== null) throw TypeError("Class extends value " + String(E) + " is not a constructor or null");
					function O() {
						this.constructor = T;
					}
					u(T, E), T.prototype = E === null ? Object.create(E) : (O.prototype = E.prototype, new O());
				}(P, E = T), Object.defineProperty(P.prototype, "db", {
					get: function() {
						return O;
					},
					enumerable: !1,
					configurable: !0
				}), P.prototype.table = function() {
					return M;
				}, T = P);
				for (var F = /* @__PURE__ */ new Set(), R = T.prototype; R; R = I(R)) Object.getOwnPropertyNames(R).forEach(function(u) {
					return F.add(u);
				});
				function V(u) {
					if (!u) return u;
					var E, O = Object.create(T.prototype);
					for (E in u) if (!F.has(E)) try {
						O[E] = u[E];
					} catch {}
					return O;
				}
				return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = V, this.hook("reading", V), T;
			}, kh.prototype.defineClass = function() {
				return this.mapToClass(function(u) {
					F(this, u);
				});
			}, kh.prototype.add = function(u, T) {
				var E = this, O = this.schema.primKey, M = O.auto, P = O.keyPath, F = u;
				return P && M && (F = Sh(P)(u)), this._trans("readwrite", function(u) {
					return E.core.mutate({
						trans: u,
						type: "add",
						keys: T == null ? null : [T],
						values: [F]
					});
				}).then(function(u) {
					return u.numFailures ? Lm.reject(u.failures[0]) : u.lastResult;
				}).then(function(T) {
					if (P) try {
						Lp(u, P, T);
					} catch {}
					return T;
				});
			}, kh.prototype.update = function(u, T) {
				return typeof u != "object" || P(u) ? this.where(":id").equals(u).modify(T) : (u = Ip(u, this.schema.primKey.keyPath), u === void 0 ? fh(new cm.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(u).modify(T));
			}, kh.prototype.put = function(u, T) {
				var E = this, O = this.schema.primKey, M = O.auto, P = O.keyPath, F = u;
				return P && M && (F = Sh(P)(u)), this._trans("readwrite", function(u) {
					return E.core.mutate({
						trans: u,
						type: "put",
						values: [F],
						keys: T == null ? null : [T]
					});
				}).then(function(u) {
					return u.numFailures ? Lm.reject(u.failures[0]) : u.lastResult;
				}).then(function(T) {
					if (P) try {
						Lp(u, P, T);
					} catch {}
					return T;
				});
			}, kh.prototype.delete = function(u) {
				var T = this;
				return this._trans("readwrite", function(E) {
					return T.core.mutate({
						trans: E,
						type: "delete",
						keys: [u]
					}).then(function(E) {
						return Dh(T, [u], E);
					}).then(function(u) {
						return u.numFailures ? Lm.reject(u.failures[0]) : void 0;
					});
				});
			}, kh.prototype.clear = function() {
				var u = this;
				return this._trans("readwrite", function(T) {
					return u.core.mutate({
						trans: T,
						type: "deleteRange",
						range: xh
					}).then(function(T) {
						return Dh(u, null, T);
					});
				}).then(function(u) {
					return u.numFailures ? Lm.reject(u.failures[0]) : void 0;
				});
			}, kh.prototype.bulkGet = function(u) {
				var T = this;
				return this._trans("readonly", function(E) {
					return T.core.getMany({
						keys: u,
						trans: E
					}).then(function(u) {
						return u.map(function(u) {
							return T.hook.reading.fire(u);
						});
					});
				});
			}, kh.prototype.bulkAdd = function(u, T, E) {
				var O = this, M = Array.isArray(T) ? T : void 0, P = (E ||= M ? void 0 : T) ? E.allKeys : void 0;
				return this._trans("readwrite", function(T) {
					var E = O.schema.primKey, F = E.auto, E = E.keyPath;
					if (E && M) throw new cm.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
					if (M && M.length !== u.length) throw new cm.InvalidArgument("Arguments objects and keys must have the same length");
					var I = u.length, E = E && F ? u.map(Sh(E)) : u;
					return O.core.mutate({
						trans: T,
						type: "add",
						keys: M,
						values: E,
						wantResults: P
					}).then(function(u) {
						var T = u.numFailures, E = u.results, M = u.lastResult, u = u.failures;
						if (T === 0) return P ? E : M;
						throw new am(`${O.name}.bulkAdd(): ${T} of ${I} operations failed`, u);
					});
				});
			}, kh.prototype.bulkPut = function(u, T, E) {
				var O = this, M = Array.isArray(T) ? T : void 0, P = (E ||= M ? void 0 : T) ? E.allKeys : void 0;
				return this._trans("readwrite", function(T) {
					var E = O.schema.primKey, F = E.auto, E = E.keyPath;
					if (E && M) throw new cm.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
					if (M && M.length !== u.length) throw new cm.InvalidArgument("Arguments objects and keys must have the same length");
					var I = u.length, E = E && F ? u.map(Sh(E)) : u;
					return O.core.mutate({
						trans: T,
						type: "put",
						keys: M,
						values: E,
						wantResults: P
					}).then(function(u) {
						var T = u.numFailures, E = u.results, M = u.lastResult, u = u.failures;
						if (T === 0) return P ? E : M;
						throw new am(`${O.name}.bulkPut(): ${T} of ${I} operations failed`, u);
					});
				});
			}, kh.prototype.bulkUpdate = function(u) {
				var T = this, E = this.core, O = u.map(function(u) {
					return u.key;
				}), M = u.map(function(u) {
					return u.changes;
				}), P = [];
				return this._trans("readwrite", function(F) {
					return E.getMany({
						trans: F,
						keys: O,
						cache: "clone"
					}).then(function(I) {
						var R = [], V = [];
						u.forEach(function(u, E) {
							var O = u.key, M = u.changes, F = I[E];
							if (F) {
								for (var U = 0, Dp = Object.keys(M); U < Dp.length; U++) {
									var Op = Dp[U], kp = M[Op];
									if (Op === T.schema.primKey.keyPath) {
										if (wh(kp, O) !== 0) throw new cm.Constraint("Cannot update primary key in bulkUpdate()");
									} else Lp(F, Op, kp);
								}
								P.push(E), R.push(O), V.push(F);
							}
						});
						var U = R.length;
						return E.mutate({
							trans: F,
							type: "put",
							keys: R,
							values: V,
							updates: {
								keys: O,
								changeSpecs: M
							}
						}).then(function(u) {
							var E = u.numFailures, O = u.failures;
							if (E === 0) return U;
							for (var M = 0, F = Object.keys(O); M < F.length; M++) {
								var I, R = F[M], V = P[Number(R)];
								V != null && (I = O[R], delete O[R], O[V] = I);
							}
							throw new am(`${T.name}.bulkUpdate(): ${E} of ${U} operations failed`, O);
						});
					});
				});
			}, kh.prototype.bulkDelete = function(u) {
				var T = this, E = u.length;
				return this._trans("readwrite", function(E) {
					return T.core.mutate({
						trans: E,
						type: "delete",
						keys: u
					}).then(function(E) {
						return Dh(T, u, E);
					});
				}).then(function(u) {
					var O = u.numFailures, M = u.lastResult, u = u.failures;
					if (O === 0) return M;
					throw new am(`${T.name}.bulkDelete(): ${O} of ${E} operations failed`, u);
				});
			}, kh);
			function kh() {}
			function Ah(u) {
				function T(T, O) {
					if (O) {
						for (var M = arguments.length, P = Array(M - 1); --M;) P[M - 1] = arguments[M];
						return E[T].subscribe.apply(null, P), u;
					}
					if (typeof T == "string") return E[T];
				}
				var E = {};
				T.addEventType = I;
				for (var O = 1, F = arguments.length; O < F; ++O) I(arguments[O]);
				return T;
				function I(u, O, F) {
					if (typeof u != "object") {
						var R;
						O ||= vm;
						var V = {
							subscribers: [],
							fire: F ||= dm,
							subscribe: function(u) {
								V.subscribers.indexOf(u) === -1 && (V.subscribers.push(u), V.fire = O(V.fire, u));
							},
							unsubscribe: function(u) {
								V.subscribers = V.subscribers.filter(function(T) {
									return T !== u;
								}), V.fire = V.subscribers.reduce(O, F);
							}
						};
						return E[u] = T[u] = V;
					}
					M(R = u).forEach(function(u) {
						var T = R[u];
						if (P(T)) I(u, R[u][0], R[u][1]);
						else {
							if (T !== "asap") throw new cm.InvalidArgument("Invalid event config");
							var E = I(u, fm, function() {
								for (var u = arguments.length, T = Array(u); u--;) T[u] = arguments[u];
								E.subscribers.forEach(function(u) {
									Fp(function() {
										u.apply(null, T);
									});
								});
							});
						}
					});
				}
			}
			function jh(u, T) {
				return kp(T).from({ prototype: u }), T;
			}
			function Mh(u, T) {
				return !(u.filter || u.algorithm || u.or) && (T ? u.justLimit : !u.replayFilter);
			}
			function Nh(u, T) {
				u.filter = bh(u.filter, T);
			}
			function Ph(u, T, E) {
				var O = u.replayFilter;
				u.replayFilter = O ? function() {
					return bh(O(), T());
				} : T, u.justLimit = E && !O;
			}
			function Fh(u, T) {
				if (u.isPrimKey) return T.primaryKey;
				var E = T.getIndexByKeyPath(u.index);
				if (!E) throw new cm.Schema("KeyPath " + u.index + " on object store " + T.name + " is not indexed");
				return E;
			}
			function Ih(u, T, E) {
				var O = Fh(u, T.schema);
				return T.openCursor({
					trans: E,
					values: !u.keysOnly,
					reverse: u.dir === "prev",
					unique: !!u.unique,
					query: {
						index: O,
						range: u.range
					}
				});
			}
			function Lh(u, T, E, O) {
				var M = u.replayFilter ? bh(u.filter, u.replayFilter()) : u.filter;
				if (u.or) {
					var P = {}, F = function(u, E, O) {
						var F, I;
						M && !M(E, O, function(u) {
							return E.stop(u);
						}, function(u) {
							return E.fail(u);
						}) || ((I = "" + (F = E.primaryKey)) == "[object ArrayBuffer]" && (I = "" + new Uint8Array(F)), V(P, I) || (P[I] = !0, T(u, E, O)));
					};
					return Promise.all([u.or._iterate(F, E), Rh(Ih(u, O, E), u.algorithm, F, !u.keysOnly && u.valueMapper)]);
				}
				return Rh(Ih(u, O, E), bh(u.algorithm, M), T, !u.keysOnly && u.valueMapper);
			}
			function Rh(u, T, E, O) {
				var M = Ym(O ? function(u, T, M) {
					return E(O(u), T, M);
				} : E);
				return u.then(function(u) {
					if (u) return u.start(function() {
						var E = function() {
							return u.continue();
						};
						T && !T(u, function(u) {
							return E = u;
						}, function(T) {
							u.stop(T), E = dm;
						}, function(T) {
							u.fail(T), E = dm;
						}) || M(u.value, u, function(u) {
							return E = u;
						}), E();
					});
				});
			}
			var zh = (Bh.prototype.execute = function(u) {
				var T = this["@@propmod"];
				if (T.add !== void 0) {
					var O = T.add;
					if (P(O)) return E(E([], P(u) ? u : [], !0), O).sort();
					if (typeof O == "number") return (Number(u) || 0) + O;
					if (typeof O == "bigint") try {
						return BigInt(u) + O;
					} catch {
						return BigInt(0) + O;
					}
					throw TypeError(`Invalid term ${O}`);
				}
				if (T.remove !== void 0) {
					var M = T.remove;
					if (P(M)) return P(u) ? u.filter(function(u) {
						return !M.includes(u);
					}).sort() : [];
					if (typeof M == "number") return Number(u) - M;
					if (typeof M == "bigint") try {
						return BigInt(u) - M;
					} catch {
						return BigInt(0) - M;
					}
					throw TypeError(`Invalid subtrahend ${M}`);
				}
				return O = (O = T.replacePrefix)?.[0], O && typeof u == "string" && u.startsWith(O) ? T.replacePrefix[1] + u.substring(O.length) : u;
			}, Bh);
			function Bh(u) {
				this["@@propmod"] = u;
			}
			var Vh = (Hh.prototype._read = function(u, T) {
				var E = this._ctx;
				return E.error ? E.table._trans(null, fh.bind(null, E.error)) : E.table._trans("readonly", u).then(T);
			}, Hh.prototype._write = function(u) {
				var T = this._ctx;
				return T.error ? T.table._trans(null, fh.bind(null, T.error)) : T.table._trans("readwrite", u, "locked");
			}, Hh.prototype._addAlgorithm = function(u) {
				var T = this._ctx;
				T.algorithm = bh(T.algorithm, u);
			}, Hh.prototype._iterate = function(u, T) {
				return Lh(this._ctx, u, T, this._ctx.table.core);
			}, Hh.prototype.clone = function(u) {
				var T = Object.create(this.constructor.prototype), E = Object.create(this._ctx);
				return u && F(E, u), T._ctx = E, T;
			}, Hh.prototype.raw = function() {
				return this._ctx.valueMapper = null, this;
			}, Hh.prototype.each = function(u) {
				var T = this._ctx;
				return this._read(function(E) {
					return Lh(T, u, E, T.table.core);
				});
			}, Hh.prototype.count = function(u) {
				var T = this;
				return this._read(function(u) {
					var E = T._ctx, O = E.table.core;
					if (Mh(E, !0)) return O.count({
						trans: u,
						query: {
							index: Fh(E, O.schema),
							range: E.range
						}
					}).then(function(u) {
						return Math.min(u, E.limit);
					});
					var M = 0;
					return Lh(E, function() {
						return ++M, !1;
					}, u, O).then(function() {
						return M;
					});
				}).then(u);
			}, Hh.prototype.sortBy = function(u, T) {
				var E = u.split(".").reverse(), O = E[0], M = E.length - 1;
				function P(u, T) {
					return T ? P(u[E[T]], T - 1) : u[O];
				}
				var F = this._ctx.dir === "next" ? 1 : -1;
				function I(u, T) {
					return wh(P(u, M), P(T, M)) * F;
				}
				return this.toArray(function(u) {
					return u.sort(I);
				}).then(T);
			}, Hh.prototype.toArray = function(u) {
				var T = this;
				return this._read(function(u) {
					var E = T._ctx;
					if (E.dir === "next" && Mh(E, !0) && 0 < E.limit) {
						var O = E.valueMapper, M = Fh(E, E.table.core.schema);
						return E.table.core.query({
							trans: u,
							limit: E.limit,
							values: !0,
							query: {
								index: M,
								range: E.range
							}
						}).then(function(u) {
							return u = u.result, O ? u.map(O) : u;
						});
					}
					var P = [];
					return Lh(E, function(u) {
						return P.push(u);
					}, u, E.table.core).then(function() {
						return P;
					});
				}, u);
			}, Hh.prototype.offset = function(u) {
				var T = this._ctx;
				return u <= 0 || (T.offset += u, Mh(T) ? Ph(T, function() {
					var T = u;
					return function(u, E) {
						return T === 0 || (T === 1 ? --T : E(function() {
							u.advance(T), T = 0;
						}), !1);
					};
				}) : Ph(T, function() {
					var T = u;
					return function() {
						return --T < 0;
					};
				})), this;
			}, Hh.prototype.limit = function(u) {
				return this._ctx.limit = Math.min(this._ctx.limit, u), Ph(this._ctx, function() {
					var T = u;
					return function(u, E, O) {
						return --T <= 0 && E(O), 0 <= T;
					};
				}, !0), this;
			}, Hh.prototype.until = function(u, T) {
				return Nh(this._ctx, function(E, O, M) {
					return !u(E.value) || (O(M), T);
				}), this;
			}, Hh.prototype.first = function(u) {
				return this.limit(1).toArray(function(u) {
					return u[0];
				}).then(u);
			}, Hh.prototype.last = function(u) {
				return this.reverse().first(u);
			}, Hh.prototype.filter = function(u) {
				var T;
				return Nh(this._ctx, function(T) {
					return u(T.value);
				}), (T = this._ctx).isMatch = bh(T.isMatch, u), this;
			}, Hh.prototype.and = function(u) {
				return this.filter(u);
			}, Hh.prototype.or = function(u) {
				return new this.db.WhereClause(this._ctx.table, u, this);
			}, Hh.prototype.reverse = function() {
				return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
			}, Hh.prototype.desc = function() {
				return this.reverse();
			}, Hh.prototype.eachKey = function(u) {
				var T = this._ctx;
				return T.keysOnly = !T.isMatch, this.each(function(T, E) {
					u(E.key, E);
				});
			}, Hh.prototype.eachUniqueKey = function(u) {
				return this._ctx.unique = "unique", this.eachKey(u);
			}, Hh.prototype.eachPrimaryKey = function(u) {
				var T = this._ctx;
				return T.keysOnly = !T.isMatch, this.each(function(T, E) {
					u(E.primaryKey, E);
				});
			}, Hh.prototype.keys = function(u) {
				var T = this._ctx;
				T.keysOnly = !T.isMatch;
				var E = [];
				return this.each(function(u, T) {
					E.push(T.key);
				}).then(function() {
					return E;
				}).then(u);
			}, Hh.prototype.primaryKeys = function(u) {
				var T = this._ctx;
				if (T.dir === "next" && Mh(T, !0) && 0 < T.limit) return this._read(function(u) {
					var E = Fh(T, T.table.core.schema);
					return T.table.core.query({
						trans: u,
						values: !1,
						limit: T.limit,
						query: {
							index: E,
							range: T.range
						}
					});
				}).then(function(u) {
					return u.result;
				}).then(u);
				T.keysOnly = !T.isMatch;
				var E = [];
				return this.each(function(u, T) {
					E.push(T.primaryKey);
				}).then(function() {
					return E;
				}).then(u);
			}, Hh.prototype.uniqueKeys = function(u) {
				return this._ctx.unique = "unique", this.keys(u);
			}, Hh.prototype.firstKey = function(u) {
				return this.limit(1).keys(function(u) {
					return u[0];
				}).then(u);
			}, Hh.prototype.lastKey = function(u) {
				return this.reverse().firstKey(u);
			}, Hh.prototype.distinct = function() {
				var u = this._ctx, u = u.index && u.table.schema.idxByName[u.index];
				if (!u || !u.multi) return this;
				var T = {};
				return Nh(this._ctx, function(u) {
					var E = u.primaryKey.toString(), u = V(T, E);
					return T[E] = !0, !u;
				}), this;
			}, Hh.prototype.modify = function(u) {
				var T = this, E = this._ctx;
				return this._write(function(O) {
					var P, F, I = typeof u == "function" ? u : (P = M(u), F = P.length, function(T) {
						for (var E = !1, O = 0; O < F; ++O) {
							var M = P[O], I = u[M], R = Ip(T, M);
							I instanceof zh ? (Lp(T, M, I.execute(R)), E = !0) : R !== I && (Lp(T, M, I), E = !0);
						}
						return E;
					}), R = E.table.core, V = R.schema.primaryKey, U = V.outbound, Dp = V.extractKey, Op = 200, V = T.db._options.modifyChunkSize;
					V && (Op = typeof V == "object" ? V[R.name] || V["*"] || 200 : V);
					function kp(u, T) {
						var E = T.failures, T = T.numFailures;
						jp += u - T;
						for (var O = 0, P = M(E); O < P.length; O++) {
							var F = P[O];
							Ap.push(E[F]);
						}
					}
					var Ap = [], jp = 0, Mp = [], Np = u === Uh;
					return T.clone().primaryKeys().then(function(T) {
						function M(F) {
							var V = Math.min(Op, T.length - F), Ap = T.slice(F, F + V);
							return (Np ? Promise.resolve([]) : R.getMany({
								trans: O,
								keys: Ap,
								cache: "immutable"
							})).then(function(jp) {
								var Mp = [], Pp = [], Fp = U ? [] : null, Ip = Np ? Ap : [];
								if (!Np) for (var Lp = 0; Lp < V; ++Lp) {
									var Rp = jp[Lp], zp = {
										value: Wp(Rp),
										primKey: T[F + Lp]
									};
									I.call(zp, zp.value, zp) !== !1 && (zp.value == null ? Ip.push(T[F + Lp]) : U || wh(Dp(Rp), Dp(zp.value)) === 0 ? (Pp.push(zp.value), U && Fp.push(T[F + Lp])) : (Ip.push(T[F + Lp]), Mp.push(zp.value)));
								}
								return Promise.resolve(0 < Mp.length && R.mutate({
									trans: O,
									type: "add",
									values: Mp
								}).then(function(u) {
									for (var T in u.failures) Ip.splice(parseInt(T), 1);
									kp(Mp.length, u);
								})).then(function() {
									return (0 < Pp.length || P && typeof u == "object") && R.mutate({
										trans: O,
										type: "put",
										keys: Fp,
										values: Pp,
										criteria: P,
										changeSpec: typeof u != "function" && u,
										isAdditionalChunk: 0 < F
									}).then(function(u) {
										return kp(Pp.length, u);
									});
								}).then(function() {
									return (0 < Ip.length || P && Np) && R.mutate({
										trans: O,
										type: "delete",
										keys: Ip,
										criteria: P,
										isAdditionalChunk: 0 < F
									}).then(function(u) {
										return Dh(E.table, Ip, u);
									}).then(function(u) {
										return kp(Ip.length, u);
									});
								}).then(function() {
									return T.length > F + V && M(F + Op);
								});
							});
						}
						var P = Mh(E) && E.limit === Infinity && (typeof u != "function" || Np) && {
							index: E.index,
							range: E.range
						};
						return M(0).then(function() {
							if (0 < Ap.length) throw new im("Error modifying one or more objects", Ap, jp, Mp);
							return T.length;
						});
					});
				});
			}, Hh.prototype.delete = function() {
				var u = this._ctx, T = u.range;
				return !Mh(u) || u.table.schema.yProps || !u.isPrimKey && T.type !== 3 ? this.modify(Uh) : this._write(function(E) {
					var O = u.table.core.schema.primaryKey, M = T;
					return u.table.core.count({
						trans: E,
						query: {
							index: O,
							range: M
						}
					}).then(function(T) {
						return u.table.core.mutate({
							trans: E,
							type: "deleteRange",
							range: M
						}).then(function(u) {
							var E = u.failures, u = u.numFailures;
							if (u) throw new im("Could not delete some values", Object.keys(E).map(function(u) {
								return E[u];
							}), T - u);
							return T - u;
						});
					});
				});
			}, Hh);
			function Hh() {}
			var Uh = function(u, T) {
				return T.value = null;
			};
			function Wh(u, T) {
				return u < T ? -1 : u === T ? 0 : 1;
			}
			function Gh(u, T) {
				return T < u ? -1 : u === T ? 0 : 1;
			}
			function Kh(u, T, E) {
				return u = u instanceof Zh ? new u.Collection(u) : u, u._ctx.error = new (E || TypeError)(T), u;
			}
			function qh(u) {
				return new u.Collection(u, function() {
					return Xh("");
				}).limit(0);
			}
			function Jh(u, T, E, O) {
				var M, P, F, I, R, V, U, Dp = E.length;
				if (!E.every(function(u) {
					return typeof u == "string";
				})) return Kh(u, hh);
				function Op(u) {
					M = u === "next" ? function(u) {
						return u.toUpperCase();
					} : function(u) {
						return u.toLowerCase();
					}, P = u === "next" ? function(u) {
						return u.toLowerCase();
					} : function(u) {
						return u.toUpperCase();
					}, F = u === "next" ? Wh : Gh;
					var T = E.map(function(u) {
						return {
							lower: P(u),
							upper: M(u)
						};
					}).sort(function(u, T) {
						return F(u.lower, T.lower);
					});
					I = T.map(function(u) {
						return u.upper;
					}), R = T.map(function(u) {
						return u.lower;
					}), U = (V = u) === "next" ? "" : O;
				}
				Op("next"), u = new u.Collection(u, function() {
					return Yh(I[0], R[Dp - 1] + O);
				}), u._ondirectionchange = function(u) {
					Op(u);
				};
				var kp = 0;
				return u._addAlgorithm(function(u, E, O) {
					var M = u.key;
					if (typeof M != "string") return !1;
					var Op = P(M);
					if (T(Op, R, kp)) return !0;
					for (var Ap = null, jp = kp; jp < Dp; ++jp) {
						var Mp = function(u, T, E, O, M, P) {
							for (var F = Math.min(u.length, O.length), I = -1, R = 0; R < F; ++R) {
								var V = T[R];
								if (V !== O[R]) return M(u[R], E[R]) < 0 ? u.substr(0, R) + E[R] + E.substr(R + 1) : M(u[R], O[R]) < 0 ? u.substr(0, R) + O[R] + E.substr(R + 1) : 0 <= I ? u.substr(0, I) + T[I] + E.substr(I + 1) : null;
								M(u[R], V) < 0 && (I = R);
							}
							return F < O.length && P === "next" ? u + E.substr(u.length) : F < u.length && P === "prev" ? u.substr(0, E.length) : I < 0 ? null : u.substr(0, I) + O[I] + E.substr(I + 1);
						}(M, Op, I[jp], R[jp], F, V);
						Mp === null && Ap === null ? kp = jp + 1 : (Ap === null || 0 < F(Ap, Mp)) && (Ap = Mp);
					}
					return E(Ap === null ? O : function() {
						u.continue(Ap + U);
					}), !1;
				}), u;
			}
			function Yh(u, T, E, O) {
				return {
					type: 2,
					lower: u,
					upper: T,
					lowerOpen: E,
					upperOpen: O
				};
			}
			function Xh(u) {
				return {
					type: 1,
					lower: u,
					upper: u
				};
			}
			var Zh = (Object.defineProperty(Qh.prototype, "Collection", {
				get: function() {
					return this._ctx.table.db.Collection;
				},
				enumerable: !1,
				configurable: !0
			}), Qh.prototype.between = function(u, T, E, O) {
				E = E !== !1, O = O === !0;
				try {
					return 0 < this._cmp(u, T) || this._cmp(u, T) === 0 && (E || O) && (!E || !O) ? qh(this) : new this.Collection(this, function() {
						return Yh(u, T, !E, !O);
					});
				} catch {
					return Kh(this, mh);
				}
			}, Qh.prototype.equals = function(u) {
				return u == null ? Kh(this, mh) : new this.Collection(this, function() {
					return Xh(u);
				});
			}, Qh.prototype.above = function(u) {
				return u == null ? Kh(this, mh) : new this.Collection(this, function() {
					return Yh(u, void 0, !0);
				});
			}, Qh.prototype.aboveOrEqual = function(u) {
				return u == null ? Kh(this, mh) : new this.Collection(this, function() {
					return Yh(u, void 0, !1);
				});
			}, Qh.prototype.below = function(u) {
				return u == null ? Kh(this, mh) : new this.Collection(this, function() {
					return Yh(void 0, u, !1, !0);
				});
			}, Qh.prototype.belowOrEqual = function(u) {
				return u == null ? Kh(this, mh) : new this.Collection(this, function() {
					return Yh(void 0, u);
				});
			}, Qh.prototype.startsWith = function(u) {
				return typeof u == "string" ? this.between(u, u + ph, !0, !0) : Kh(this, hh);
			}, Qh.prototype.startsWithIgnoreCase = function(u) {
				return u === "" ? this.startsWith(u) : Jh(this, function(u, T) {
					return u.indexOf(T[0]) === 0;
				}, [u], ph);
			}, Qh.prototype.equalsIgnoreCase = function(u) {
				return Jh(this, function(u, T) {
					return u === T[0];
				}, [u], "");
			}, Qh.prototype.anyOfIgnoreCase = function() {
				var u = Zp.apply(Xp, arguments);
				return u.length === 0 ? qh(this) : Jh(this, function(u, T) {
					return T.indexOf(u) !== -1;
				}, u, "");
			}, Qh.prototype.startsWithAnyOfIgnoreCase = function() {
				var u = Zp.apply(Xp, arguments);
				return u.length === 0 ? qh(this) : Jh(this, function(u, T) {
					return T.some(function(T) {
						return u.indexOf(T) === 0;
					});
				}, u, ph);
			}, Qh.prototype.anyOf = function() {
				var u = this, T = Zp.apply(Xp, arguments), E = this._cmp;
				try {
					T.sort(E);
				} catch {
					return Kh(this, mh);
				}
				if (T.length === 0) return qh(this);
				var O = new this.Collection(this, function() {
					return Yh(T[0], T[T.length - 1]);
				});
				O._ondirectionchange = function(O) {
					E = O === "next" ? u._ascending : u._descending, T.sort(E);
				};
				var M = 0;
				return O._addAlgorithm(function(u, O, P) {
					for (var F = u.key; 0 < E(F, T[M]);) if (++M === T.length) return O(P), !1;
					return E(F, T[M]) === 0 || (O(function() {
						u.continue(T[M]);
					}), !1);
				}), O;
			}, Qh.prototype.notEqual = function(u) {
				return this.inAnyRange([[-Infinity, u], [u, this.db._maxKey]], {
					includeLowers: !1,
					includeUppers: !1
				});
			}, Qh.prototype.noneOf = function() {
				var u = Zp.apply(Xp, arguments);
				if (u.length === 0) return new this.Collection(this);
				try {
					u.sort(this._ascending);
				} catch {
					return Kh(this, mh);
				}
				var T = u.reduce(function(u, T) {
					return u ? u.concat([[u[u.length - 1][1], T]]) : [[-Infinity, T]];
				}, null);
				return T.push([u[u.length - 1], this.db._maxKey]), this.inAnyRange(T, {
					includeLowers: !1,
					includeUppers: !1
				});
			}, Qh.prototype.inAnyRange = function(u, T) {
				var E = this, O = this._cmp, M = this._ascending, P = this._descending, F = this._min, I = this._max;
				if (u.length === 0) return qh(this);
				if (!u.every(function(u) {
					return u[0] !== void 0 && u[1] !== void 0 && M(u[0], u[1]) <= 0;
				})) return Kh(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", cm.InvalidArgument);
				var R = !T || T.includeLowers !== !1, V = T && T.includeUppers === !0, U, Dp = M;
				function Op(u, T) {
					return Dp(u[0], T[0]);
				}
				try {
					(U = u.reduce(function(u, T) {
						for (var E = 0, M = u.length; E < M; ++E) {
							var P = u[E];
							if (O(T[0], P[1]) < 0 && 0 < O(T[1], P[0])) {
								P[0] = F(P[0], T[0]), P[1] = I(P[1], T[1]);
								break;
							}
						}
						return E === M && u.push(T), u;
					}, [])).sort(Op);
				} catch {
					return Kh(this, mh);
				}
				var kp = 0, Ap = V ? function(u) {
					return 0 < M(u, U[kp][1]);
				} : function(u) {
					return 0 <= M(u, U[kp][1]);
				}, jp = R ? function(u) {
					return 0 < P(u, U[kp][0]);
				} : function(u) {
					return 0 <= P(u, U[kp][0]);
				}, Mp = Ap, u = new this.Collection(this, function() {
					return Yh(U[0][0], U[U.length - 1][1], !R, !V);
				});
				return u._ondirectionchange = function(u) {
					Dp = u === "next" ? (Mp = Ap, M) : (Mp = jp, P), U.sort(Op);
				}, u._addAlgorithm(function(u, T, O) {
					for (var P, F = u.key; Mp(F);) if (++kp === U.length) return T(O), !1;
					return !Ap(P = F) && !jp(P) || (E._cmp(F, U[kp][1]) === 0 || E._cmp(F, U[kp][0]) === 0 || T(function() {
						Dp === M ? u.continue(U[kp][0]) : u.continue(U[kp][1]);
					}), !1);
				}), u;
			}, Qh.prototype.startsWithAnyOf = function() {
				var u = Zp.apply(Xp, arguments);
				return u.every(function(u) {
					return typeof u == "string";
				}) ? u.length === 0 ? qh(this) : this.inAnyRange(u.map(function(u) {
					return [u, u + ph];
				})) : Kh(this, "startsWithAnyOf() only works with strings");
			}, Qh);
			function Qh() {}
			function $h(u) {
				return Ym(function(T) {
					return eg(T), u(T.target.error), !1;
				});
			}
			function eg(u) {
				u.stopPropagation && u.stopPropagation(), u.preventDefault && u.preventDefault();
			}
			var tg = "storagemutated", ng = "x-storagemutated-1", rg = Ah(null, tg), ig = (ag.prototype._lock = function() {
				return Pp(!Nm.global), ++this._reculock, this._reculock !== 1 || Nm.global || (Nm.lockOwnerFor = this), this;
			}, ag.prototype._unlock = function() {
				if (Pp(!Nm.global), --this._reculock == 0) for (Nm.global || (Nm.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked();) {
					var u = this._blockedFuncs.shift();
					try {
						lh(u[1], u[0]);
					} catch {}
				}
				return this;
			}, ag.prototype._locked = function() {
				return this._reculock && Nm.lockOwnerFor !== this;
			}, ag.prototype.create = function(u) {
				var T = this;
				if (!this.mode) return this;
				var E = this.db.idbdb, O = this.db._state.dbOpenError;
				if (Pp(!this.idbtrans), !u && !E) switch (O && O.name) {
					case "DatabaseClosedError": throw new cm.DatabaseClosed(O);
					case "MissingAPIError": throw new cm.MissingAPI(O.message, O);
					default: throw new cm.OpenFailed(O);
				}
				if (!this.active) throw new cm.TransactionInactive();
				return Pp(this._completion._state === null), (u = this.idbtrans = u || (this.db.core || E).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Ym(function(E) {
					eg(E), T._reject(u.error);
				}), u.onabort = Ym(function(E) {
					eg(E), T.active && T._reject(new cm.Abort(u.error)), T.active = !1, T.on("abort").fire(E);
				}), u.oncomplete = Ym(function() {
					T.active = !1, T._resolve(), "mutatedParts" in u && rg.storagemutated.fire(u.mutatedParts);
				}), this;
			}, ag.prototype._promise = function(u, T, E) {
				var O = this;
				if (u === "readwrite" && this.mode !== "readwrite") return fh(new cm.ReadOnly("Transaction is readonly"));
				if (!this.active) return fh(new cm.TransactionInactive());
				if (this._locked()) return new Lm(function(M, P) {
					O._blockedFuncs.push([function() {
						O._promise(u, T, E).then(M, P);
					}, Nm]);
				});
				if (E) return nh(function() {
					var u = new Lm(function(u, E) {
						O._lock();
						var M = T(u, E, O);
						M && M.then && M.then(u, E);
					});
					return u.finally(function() {
						return O._unlock();
					}), u._lib = !0, u;
				});
				var M = new Lm(function(u, E) {
					var M = T(u, E, O);
					M && M.then && M.then(u, E);
				});
				return M._lib = !0, M;
			}, ag.prototype._root = function() {
				return this.parent ? this.parent._root() : this;
			}, ag.prototype.waitFor = function(u) {
				var T, E = this._root(), O = Lm.resolve(u);
				E._waitingFor ? E._waitingFor = E._waitingFor.then(function() {
					return O;
				}) : (E._waitingFor = O, E._waitingQueue = [], T = E.idbtrans.objectStore(E.storeNames[0]), function u() {
					for (++E._spinCount; E._waitingQueue.length;) E._waitingQueue.shift()();
					E._waitingFor && (T.get(-Infinity).onsuccess = u);
				}());
				var M = E._waitingFor;
				return new Lm(function(u, T) {
					O.then(function(T) {
						return E._waitingQueue.push(Ym(u.bind(null, T)));
					}, function(u) {
						return E._waitingQueue.push(Ym(T.bind(null, u)));
					}).finally(function() {
						E._waitingFor === M && (E._waitingFor = null);
					});
				});
			}, ag.prototype.abort = function() {
				this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new cm.Abort()));
			}, ag.prototype.table = function(u) {
				var T = this._memoizedTables ||= {};
				if (V(T, u)) return T[u];
				var E = this.schema[u];
				if (!E) throw new cm.NotFound("Table " + u + " not part of transaction");
				return E = new this.db.Table(u, E, this), E.core = this.db.core.table(u), T[u] = E;
			}, ag);
			function ag() {}
			function og(u, T, E, O, M, P, F, I) {
				return {
					name: u,
					keyPath: T,
					unique: E,
					multi: O,
					auto: M,
					compound: P,
					src: (E && !F ? "&" : "") + (O ? "*" : "") + (M ? "++" : "") + sg(T),
					type: I
				};
			}
			function sg(u) {
				return typeof u == "string" ? u : u ? "[" + [].join.call(u, "+") + "]" : "";
			}
			function cg(u, T, E) {
				return {
					name: u,
					primKey: T,
					indexes: E,
					mappedClass: null,
					idxByName: (O = function(u) {
						return [u.name, u];
					}, E.reduce(function(u, T, E) {
						return E = O(T, E), E && (u[E[0]] = E[1]), u;
					}, {}))
				};
				var O;
			}
			var lg = function(u) {
				try {
					return u.only([[]]), lg = function() {
						return [[]];
					}, [[]];
				} catch {
					return lg = function() {
						return ph;
					}, ph;
				}
			};
			function ug(u) {
				return u == null ? function() {} : typeof u == "string" ? (T = u).split(".").length === 1 ? function(u) {
					return u[T];
				} : function(u) {
					return Ip(u, T);
				} : function(T) {
					return Ip(T, u);
				};
				var T;
			}
			function dg(u) {
				return [].slice.call(u);
			}
			var fg = 0;
			function pg(u) {
				return u == null ? ":id" : typeof u == "string" ? u : `[${u.join("+")}]`;
			}
			function mg(u, T, E) {
				function O(u) {
					if (u.type === 3) return null;
					if (u.type === 4) throw Error("Cannot convert never type to IDBKeyRange");
					var E = u.lower, O = u.upper, M = u.lowerOpen, u = u.upperOpen;
					return E === void 0 ? O === void 0 ? null : T.upperBound(O, !!u) : O === void 0 ? T.lowerBound(E, !!M) : T.bound(E, O, !!M, !!u);
				}
				function M(u) {
					var T, E = u.name;
					return {
						name: E,
						schema: u,
						mutate: function(u) {
							var T = u.trans, M = u.type, P = u.keys, F = u.values, I = u.range;
							return new Promise(function(u, R) {
								u = Ym(u);
								var V = T.objectStore(E), U = V.keyPath == null, Dp = M === "put" || M === "add";
								if (!Dp && M !== "delete" && M !== "deleteRange") throw Error("Invalid operation type: " + M);
								var Op, kp = (P || F || { length: 1 }).length;
								if (P && F && P.length !== F.length) throw Error("Given keys array must have same length as given values array.");
								if (kp === 0) return u({
									numFailures: 0,
									failures: {},
									results: [],
									lastResult: void 0
								});
								function Ap(u) {
									++Np, eg(u);
								}
								var jp = [], Mp = [], Np = 0;
								if (M === "deleteRange") {
									if (I.type === 4) return u({
										numFailures: Np,
										failures: Mp,
										results: [],
										lastResult: void 0
									});
									I.type === 3 ? jp.push(Op = V.clear()) : jp.push(Op = V.delete(O(I)));
								} else {
									var U = Dp ? U ? [F, P] : [F, null] : [P, null], Pp = U[0], Fp = U[1];
									if (Dp) for (var Ip = 0; Ip < kp; ++Ip) jp.push(Op = Fp && Fp[Ip] !== void 0 ? V[M](Pp[Ip], Fp[Ip]) : V[M](Pp[Ip])), Op.onerror = Ap;
									else for (Ip = 0; Ip < kp; ++Ip) jp.push(Op = V[M](Pp[Ip])), Op.onerror = Ap;
								}
								function Lp(T) {
									T = T.target.result, jp.forEach(function(u, T) {
										return u.error != null && (Mp[T] = u.error);
									}), u({
										numFailures: Np,
										failures: Mp,
										results: M === "delete" ? P : jp.map(function(u) {
											return u.result;
										}),
										lastResult: T
									});
								}
								Op.onerror = function(u) {
									Ap(u), Lp(u);
								}, Op.onsuccess = Lp;
							});
						},
						getMany: function(u) {
							var T = u.trans, O = u.keys;
							return new Promise(function(u, M) {
								u = Ym(u);
								for (var P, F = T.objectStore(E), I = O.length, R = Array(I), V = 0, U = 0, Dp = function(T) {
									T = T.target, R[T._pos] = T.result, ++U === V && u(R);
								}, Op = $h(M), kp = 0; kp < I; ++kp) O[kp] != null && ((P = F.get(O[kp]))._pos = kp, P.onsuccess = Dp, P.onerror = Op, ++V);
								V === 0 && u(R);
							});
						},
						get: function(u) {
							var T = u.trans, O = u.key;
							return new Promise(function(u, M) {
								u = Ym(u);
								var P = T.objectStore(E).get(O);
								P.onsuccess = function(T) {
									return u(T.target.result);
								}, P.onerror = $h(M);
							});
						},
						query: (T = U, function(u) {
							return new Promise(function(M, P) {
								M = Ym(M);
								var F, I, R, V = u.trans, U = u.values, Dp = u.limit, Op = u.query, kp = Dp === Infinity ? void 0 : Dp, Ap = Op.index, Op = Op.range, V = V.objectStore(E), Ap = Ap.isPrimaryKey ? V : V.index(Ap.name), Op = O(Op);
								if (Dp === 0) return M({ result: [] });
								T ? ((kp = U ? Ap.getAll(Op, kp) : Ap.getAllKeys(Op, kp)).onsuccess = function(u) {
									return M({ result: u.target.result });
								}, kp.onerror = $h(P)) : (F = 0, I = !U && "openKeyCursor" in Ap ? Ap.openKeyCursor(Op) : Ap.openCursor(Op), R = [], I.onsuccess = function(u) {
									var T = I.result;
									return T ? (R.push(U ? T.value : T.primaryKey), ++F === Dp ? M({ result: R }) : void T.continue()) : M({ result: R });
								}, I.onerror = $h(P));
							});
						}),
						openCursor: function(u) {
							var T = u.trans, M = u.values, P = u.query, F = u.reverse, I = u.unique;
							return new Promise(function(u, R) {
								u = Ym(u);
								var V = P.index, U = P.range, Dp = T.objectStore(E), Dp = V.isPrimaryKey ? Dp : Dp.index(V.name), V = F ? I ? "prevunique" : "prev" : I ? "nextunique" : "next", Op = !M && "openKeyCursor" in Dp ? Dp.openKeyCursor(O(U), V) : Dp.openCursor(O(U), V);
								Op.onerror = $h(R), Op.onsuccess = Ym(function(E) {
									var O, M, P, F, I = Op.result;
									I ? (I.___id = ++fg, I.done = !1, O = I.continue.bind(I), M = (M = I.continuePrimaryKey) && M.bind(I), P = I.advance.bind(I), F = function() {
										throw Error("Cursor not stopped");
									}, I.trans = T, I.stop = I.continue = I.continuePrimaryKey = I.advance = function() {
										throw Error("Cursor not started");
									}, I.fail = Ym(R), I.next = function() {
										var u = this, T = 1;
										return this.start(function() {
											return T-- ? u.continue() : u.stop();
										}).then(function() {
											return u;
										});
									}, I.start = function(u) {
										function T() {
											if (Op.result) try {
												u();
											} catch (u) {
												I.fail(u);
											}
											else I.done = !0, I.start = function() {
												throw Error("Cursor behind last entry");
											}, I.stop();
										}
										var E = new Promise(function(u, T) {
											u = Ym(u), Op.onerror = $h(T), I.fail = T, I.stop = function(T) {
												I.stop = I.continue = I.continuePrimaryKey = I.advance = F, u(T);
											};
										});
										return Op.onsuccess = Ym(function(u) {
											Op.onsuccess = T, T();
										}), I.continue = O, I.continuePrimaryKey = M, I.advance = P, T(), E;
									}, u(I)) : u(null);
								}, R);
							});
						},
						count: function(u) {
							var T = u.query, M = u.trans, P = T.index, F = T.range;
							return new Promise(function(u, T) {
								var I = M.objectStore(E), R = P.isPrimaryKey ? I : I.index(P.name), I = O(F), R = I ? R.count(I) : R.count();
								R.onsuccess = Ym(function(T) {
									return u(T.target.result);
								}), R.onerror = $h(T);
							});
						}
					};
				}
				var F, I, R, V = (I = E, R = dg((F = u).objectStoreNames), {
					schema: {
						name: F.name,
						tables: R.map(function(u) {
							return I.objectStore(u);
						}).map(function(u) {
							var T = u.keyPath, E = u.autoIncrement, O = P(T), M = {}, E = {
								name: u.name,
								primaryKey: {
									name: null,
									isPrimaryKey: !0,
									outbound: T == null,
									compound: O,
									keyPath: T,
									autoIncrement: E,
									unique: !0,
									extractKey: ug(T)
								},
								indexes: dg(u.indexNames).map(function(T) {
									return u.index(T);
								}).map(function(u) {
									var T = u.name, E = u.unique, O = u.multiEntry, u = u.keyPath, O = {
										name: T,
										compound: P(u),
										keyPath: u,
										unique: E,
										multiEntry: O,
										extractKey: ug(u)
									};
									return M[pg(u)] = O;
								}),
								getIndexByKeyPath: function(u) {
									return M[pg(u)];
								}
							};
							return M[":id"] = E.primaryKey, T != null && (M[pg(T)] = E.primaryKey), E;
						})
					},
					hasGetAll: 0 < R.length && "getAll" in I.objectStore(R[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
				}), E = V.schema, U = V.hasGetAll, V = E.tables.map(M), Dp = {};
				return V.forEach(function(u) {
					return Dp[u.name] = u;
				}), {
					stack: "dbcore",
					transaction: u.transaction.bind(u),
					table: function(u) {
						if (!Dp[u]) throw Error(`Table '${u}' not found`);
						return Dp[u];
					},
					MIN_KEY: -Infinity,
					MAX_KEY: lg(T),
					schema: E
				};
			}
			function hg(u, E, O, M) {
				var P = O.IDBKeyRange;
				return O.indexedDB, { dbcore: (M = mg(E, P, M), u.dbcore.reduce(function(u, E) {
					return E = E.create, T(T({}, u), E(u));
				}, M)) };
			}
			function gg(u, T) {
				var E = T.db, T = hg(u._middlewares, E, u._deps, T);
				u.core = T.dbcore, u.tables.forEach(function(T) {
					var E = T.name;
					u.core.schema.tables.some(function(u) {
						return u.name === E;
					}) && (T.core = u.core.table(E), u[E] instanceof u.Table && (u[E].core = T.core));
				});
			}
			function _g(u, T, E, O) {
				E.forEach(function(E) {
					var M = O[E];
					T.forEach(function(T) {
						var O = function u(T, E) {
							return Ap(T, E) || (T = I(T)) && u(T, E);
						}(T, E);
						(!O || "value" in O && O.value === void 0) && (T === u.Transaction.prototype || T instanceof u.Transaction ? Op(T, E, {
							get: function() {
								return this.table(E);
							},
							set: function(u) {
								Dp(this, E, {
									value: u,
									writable: !0,
									configurable: !0,
									enumerable: !0
								});
							}
						}) : T[E] = new u.Table(E, M));
					});
				});
			}
			function vg(u, T) {
				T.forEach(function(T) {
					for (var E in T) T[E] instanceof u.Table && delete T[E];
				});
			}
			function yg(u, T) {
				return u._cfg.version - T._cfg.version;
			}
			function bg(u, T, E, O) {
				var P = u._dbSchema;
				E.objectStoreNames.contains("$meta") && !P.$meta && (P.$meta = cg("$meta", Og("")[0], []), u._storeNames.push("$meta"));
				var F = u._createTransaction("readwrite", u._storeNames, P);
				F.create(E), F._completion.catch(O);
				var I = F._reject.bind(F), R = Nm.transless || Nm;
				nh(function() {
					return Nm.trans = F, Nm.transless = R, T === 0 ? (M(P).forEach(function(u) {
						Cg(E, u, P[u].primKey, P[u].indexes);
					}), gg(u, E), void Lm.follow(function() {
						return u.on.populate.fire(F);
					}).catch(I)) : (gg(u, E), V = T, ((O = F).storeNames.includes("$meta") ? O.table("$meta").get("version").then(function(u) {
						return u ?? V;
					}) : Lm.resolve(V)).then(function(T) {
						return P = T, I = F, R = E, V = [], T = (O = u)._versions, U = O._dbSchema = Eg(0, O.idbdb, R), (T = T.filter(function(u) {
							return u._cfg.version >= P;
						})).length === 0 ? Lm.resolve() : (T.forEach(function(u) {
							V.push(function() {
								var T = U, E = u._cfg.dbschema;
								Dg(O, T, R), Dg(O, E, R), U = O._dbSchema = E;
								var F = Sg(T, E);
								F.add.forEach(function(u) {
									Cg(R, u[0], u[1].primKey, u[1].indexes);
								}), F.change.forEach(function(u) {
									if (u.recreate) throw new cm.Upgrade("Not yet support for changing primary key");
									var T = R.objectStore(u.name);
									u.add.forEach(function(u) {
										return Tg(T, u);
									}), u.change.forEach(function(u) {
										T.deleteIndex(u.name), Tg(T, u);
									}), u.del.forEach(function(u) {
										return T.deleteIndex(u);
									});
								});
								var V = u._cfg.contentUpgrade;
								if (V && u._cfg.version > P) {
									gg(O, R), I._memoizedTables = {};
									var Dp = Rp(E);
									F.del.forEach(function(u) {
										Dp[u] = T[u];
									}), vg(O, [O.Transaction.prototype]), _g(O, [O.Transaction.prototype], M(Dp), Dp), I.schema = Dp;
									var Op, kp = Qp(V);
									return kp && rh(), F = Lm.follow(function() {
										var u;
										(Op = V(I)) && kp && (u = ih.bind(null, null), Op.then(u, u));
									}), Op && typeof Op.then == "function" ? Lm.resolve(Op) : F.then(function() {
										return Op;
									});
								}
							}), V.push(function(T) {
								var E = u._cfg.dbschema, M = T;
								[].slice.call(M.db.objectStoreNames).forEach(function(u) {
									return E[u] == null && M.db.deleteObjectStore(u);
								}), vg(O, [O.Transaction.prototype]), _g(O, [O.Transaction.prototype], O._storeNames, O._dbSchema), I.schema = O._dbSchema;
							}), V.push(function(T) {
								O.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(O.idbdb.version / 10) === u._cfg.version ? (O.idbdb.deleteObjectStore("$meta"), delete O._dbSchema.$meta, O._storeNames = O._storeNames.filter(function(u) {
									return u !== "$meta";
								})) : T.objectStore("$meta").put(u._cfg.version, "version"));
							});
						}), function u() {
							return V.length ? Lm.resolve(V.shift()(I.idbtrans)).then(u) : Lm.resolve();
						}().then(function() {
							wg(U, R);
						}));
						var O, P, I, R, V, U;
					}).catch(I));
					var O, V;
				});
			}
			function xg(u, T) {
				wg(u._dbSchema, T), T.db.version % 10 != 0 || T.objectStoreNames.contains("$meta") || T.db.createObjectStore("$meta").add(Math.ceil(T.db.version / 10 - 1), "version");
				var E = Eg(0, u.idbdb, T);
				Dg(u, u._dbSchema, T);
				for (var O = 0, M = Sg(E, u._dbSchema).change; O < M.length; O++) {
					var P = function(u) {
						if (u.change.length || u.recreate) return console.warn(`Unable to patch indexes of table ${u.name} because it has changes on the type of index or primary key.`), { value: void 0 };
						var E = T.objectStore(u.name);
						u.add.forEach(function(T) {
							bm && console.debug(`Dexie upgrade patch: Creating missing index ${u.name}.${T.src}`), Tg(E, T);
						});
					}(M[O]);
					if (typeof P == "object") return P.value;
				}
			}
			function Sg(u, T) {
				var E, O = {
					del: [],
					add: [],
					change: []
				};
				for (E in u) T[E] || O.del.push(E);
				for (E in T) {
					var M = u[E], P = T[E];
					if (M) {
						var F = {
							name: E,
							def: P,
							recreate: !1,
							del: [],
							add: [],
							change: []
						};
						if ("" + (M.primKey.keyPath || "") != "" + (P.primKey.keyPath || "") || M.primKey.auto !== P.primKey.auto) F.recreate = !0, O.change.push(F);
						else {
							var I = M.idxByName, R = P.idxByName, V = void 0;
							for (V in I) R[V] || F.del.push(V);
							for (V in R) {
								var U = I[V], Dp = R[V];
								U ? U.src !== Dp.src && F.change.push(Dp) : F.add.push(Dp);
							}
							(0 < F.del.length || 0 < F.add.length || 0 < F.change.length) && O.change.push(F);
						}
					} else O.add.push([E, P]);
				}
				return O;
			}
			function Cg(u, T, E, O) {
				var M = u.db.createObjectStore(T, E.keyPath ? {
					keyPath: E.keyPath,
					autoIncrement: E.auto
				} : { autoIncrement: E.auto });
				return O.forEach(function(u) {
					return Tg(M, u);
				}), M;
			}
			function wg(u, T) {
				M(u).forEach(function(E) {
					T.db.objectStoreNames.contains(E) || (bm && console.debug("Dexie: Creating missing table", E), Cg(T, E, u[E].primKey, u[E].indexes));
				});
			}
			function Tg(u, T) {
				u.createIndex(T.name, T.keyPath, {
					unique: T.unique,
					multiEntry: T.multi
				});
			}
			function Eg(u, T, E) {
				var O = {};
				return Mp(T.objectStoreNames, 0).forEach(function(u) {
					for (var T = E.objectStore(u), M = og(sg(R = T.keyPath), R || "", !0, !1, !!T.autoIncrement, R && typeof R != "string", !0), P = [], F = 0; F < T.indexNames.length; ++F) {
						var I = T.index(T.indexNames[F]), R = I.keyPath, I = og(I.name, R, !!I.unique, !!I.multiEntry, !1, R && typeof R != "string", !1);
						P.push(I);
					}
					O[u] = cg(u, M, P);
				}), O;
			}
			function Dg(u, T, E) {
				for (var M = E.db.objectStoreNames, P = 0; P < M.length; ++P) {
					var F = M[P], I = E.objectStore(F);
					u._hasGetAll = "getAll" in I;
					for (var R = 0; R < I.indexNames.length; ++R) {
						var V = I.indexNames[R], U = I.index(V).keyPath, Dp = typeof U == "string" ? U : "[" + Mp(U).join("+") + "]";
						!T[F] || (U = T[F].idxByName[Dp]) && (U.name = V, delete T[F].idxByName[Dp], T[F].idxByName[V] = U);
					}
				}
				typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && O.WorkerGlobalScope && O instanceof O.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (u._hasGetAll = !1);
			}
			function Og(u) {
				return u.split(",").map(function(u, T) {
					var E = u.split(":"), O = (M = E[1])?.trim(), M = (u = E[0].trim()).replace(/([&*]|\+\+)/g, ""), E = /^\[/.test(M) ? M.match(/^\[(.*)\]$/)[1].split("+") : M;
					return og(M, E || null, /\&/.test(u), /\*/.test(u), /\+\+/.test(u), P(E), T === 0, O);
				});
			}
			var kg = (Ag.prototype._createTableSchema = cg, Ag.prototype._parseIndexSyntax = Og, Ag.prototype._parseStoresSpec = function(u, T) {
				var E = this;
				M(u).forEach(function(O) {
					if (u[O] !== null) {
						var M = E._parseIndexSyntax(u[O]), P = M.shift();
						if (!P) throw new cm.Schema("Invalid schema for table " + O + ": " + u[O]);
						if (P.unique = !0, P.multi) throw new cm.Schema("Primary key cannot be multiEntry*");
						M.forEach(function(u) {
							if (u.auto) throw new cm.Schema("Only primary key can be marked as autoIncrement (++)");
							if (!u.keyPath) throw new cm.Schema("Index must have a name and cannot be an empty string");
						}), M = E._createTableSchema(O, P, M), T[O] = M;
					}
				});
			}, Ag.prototype.stores = function(u) {
				var T = this.db;
				this._cfg.storesSource = this._cfg.storesSource ? F(this._cfg.storesSource, u) : u;
				var u = T._versions, E = {}, O = {};
				return u.forEach(function(u) {
					F(E, u._cfg.storesSource), O = u._cfg.dbschema = {}, u._parseStoresSpec(E, O);
				}), T._dbSchema = O, vg(T, [
					T._allTables,
					T,
					T.Transaction.prototype
				]), _g(T, [
					T._allTables,
					T,
					T.Transaction.prototype,
					this._cfg.tables
				], M(O), O), T._storeNames = M(O), this;
			}, Ag.prototype.upgrade = function(u) {
				return this._cfg.contentUpgrade = ym(this._cfg.contentUpgrade || dm, u), this;
			}, Ag);
			function Ag() {}
			function jg(u, T) {
				var E = u._dbNamesDB;
				return E || (E = u._dbNamesDB = new g_(_h, {
					addons: [],
					indexedDB: u,
					IDBKeyRange: T
				})).version(1).stores({ dbnames: "name" }), E.table("dbnames");
			}
			function Mg(u) {
				return u && typeof u.databases == "function";
			}
			function Ng(u) {
				return nh(function() {
					return Nm.letThrough = !0, u();
				});
			}
			function Pg(u) {
				return !("from" in u);
			}
			var Fg = function(u, T) {
				if (!this) {
					var E = new Fg();
					return u && "d" in u && F(E, u), E;
				}
				F(this, arguments.length ? {
					d: 1,
					from: u,
					to: 1 < arguments.length ? T : u
				} : { d: 0 });
			};
			function Ig(u, T, E) {
				var O = wh(T, E);
				if (!isNaN(O)) {
					if (0 < O) throw RangeError();
					if (Pg(u)) return F(u, {
						from: T,
						to: E,
						d: 1
					});
					var M = u.l, O = u.r;
					if (wh(E, u.from) < 0) return M ? Ig(M, T, E) : u.l = {
						from: T,
						to: E,
						d: 1,
						l: null,
						r: null
					}, Bg(u);
					if (0 < wh(T, u.to)) return O ? Ig(O, T, E) : u.r = {
						from: T,
						to: E,
						d: 1,
						l: null,
						r: null
					}, Bg(u);
					wh(T, u.from) < 0 && (u.from = T, u.l = null, u.d = O ? O.d + 1 : 1), 0 < wh(E, u.to) && (u.to = E, u.r = null, u.d = u.l ? u.l.d + 1 : 1), E = !u.r, M && !u.l && Lg(u, M), O && E && Lg(u, O);
				}
			}
			function Lg(u, T) {
				Pg(T) || function u(T, E) {
					var O = E.from, M = E.to, P = E.l, E = E.r;
					Ig(T, O, M), P && u(T, P), E && u(T, E);
				}(u, T);
			}
			function Rg(u, T) {
				var E = zg(T), O = E.next();
				if (O.done) return !1;
				for (var M = O.value, P = zg(u), F = P.next(M.from), I = F.value; !O.done && !F.done;) {
					if (wh(I.from, M.to) <= 0 && 0 <= wh(I.to, M.from)) return !0;
					wh(M.from, I.from) < 0 ? M = (O = E.next(I.from)).value : I = (F = P.next(M.from)).value;
				}
				return !1;
			}
			function zg(u) {
				var T = Pg(u) ? null : {
					s: 0,
					n: u
				};
				return { next: function(u) {
					for (var E = 0 < arguments.length; T;) switch (T.s) {
						case 0: if (T.s = 1, E) for (; T.n.l && wh(u, T.n.from) < 0;) T = {
							up: T,
							n: T.n.l,
							s: 1
						};
						else for (; T.n.l;) T = {
							up: T,
							n: T.n.l,
							s: 1
						};
						case 1: if (T.s = 2, !E || wh(u, T.n.to) <= 0) return {
							value: T.n,
							done: !1
						};
						case 2: if (T.n.r) {
							T.s = 3, T = {
								up: T,
								n: T.n.r,
								s: 0
							};
							continue;
						}
						case 3: T = T.up;
					}
					return { done: !0 };
				} };
			}
			function Bg(u) {
				var E, O, M = ((E = u.r)?.d || 0) - ((O = u.l)?.d || 0), P = 1 < M ? "r" : M < -1 ? "l" : "";
				P && (E = P == "r" ? "l" : "r", O = T({}, u), M = u[P], u.from = M.from, u.to = M.to, u[P] = M[P], O[P] = M[E], (u[E] = O).d = Vg(O)), u.d = Vg(u);
			}
			function Vg(u) {
				var T = u.r, u = u.l;
				return (T ? u ? Math.max(T.d, u.d) : T.d : u ? u.d : 0) + 1;
			}
			function Hg(u, T) {
				return M(T).forEach(function(E) {
					u[E] ? Lg(u[E], T[E]) : u[E] = function u(T) {
						var E, O, M = {};
						for (E in T) V(T, E) && (O = T[E], M[E] = !O || typeof O != "object" || Hp.has(O.constructor) ? O : u(O));
						return M;
					}(T[E]);
				}), u;
			}
			function Ug(u, T) {
				return u.all || T.all || Object.keys(u).some(function(E) {
					return T[E] && Rg(T[E], u[E]);
				});
			}
			U(Fg.prototype, ((em = {
				add: function(u) {
					return Lg(this, u), this;
				},
				addKey: function(u) {
					return Ig(this, u, u), this;
				},
				addKeys: function(u) {
					var T = this;
					return u.forEach(function(u) {
						return Ig(T, u, u);
					}), this;
				},
				hasKey: function(u) {
					var T = zg(this).next(u).value;
					return T && wh(T.from, u) <= 0 && 0 <= wh(T.to, u);
				}
			})[qp] = function() {
				return zg(this);
			}, em));
			var Wg = {}, Gg = {}, Kg = !1;
			function qg(u) {
				Hg(Gg, u), Kg || (Kg = !0, setTimeout(function() {
					Kg = !1, Jg(Gg, !(Gg = {}));
				}, 0));
			}
			function Jg(u, T) {
				T === void 0 && (T = !1);
				var E = /* @__PURE__ */ new Set();
				if (u.all) for (var O = 0, M = Object.values(Wg); O < M.length; O++) Yg(F = M[O], u, E, T);
				else for (var P in u) {
					var F, I = /^idb\:\/\/(.*)\/(.*)\//.exec(P);
					I && (P = I[1], I = I[2], (F = Wg[`idb://${P}/${I}`]) && Yg(F, u, E, T));
				}
				E.forEach(function(u) {
					return u();
				});
			}
			function Yg(u, T, E, O) {
				for (var M = [], P = 0, F = Object.entries(u.queries.query); P < F.length; P++) {
					for (var I = F[P], R = I[0], V = [], U = 0, Dp = I[1]; U < Dp.length; U++) {
						var Op = Dp[U];
						Ug(T, Op.obsSet) ? Op.subscribers.forEach(function(u) {
							return E.add(u);
						}) : O && V.push(Op);
					}
					O && M.push([R, V]);
				}
				if (O) for (var kp = 0, Ap = M; kp < Ap.length; kp++) {
					var jp = Ap[kp], R = jp[0], V = jp[1];
					u.queries.query[R] = V;
				}
			}
			function Xg(u) {
				var T = u._state, E = u._deps.indexedDB;
				if (T.isBeingOpened || u.idbdb) return T.dbReadyPromise.then(function() {
					return T.dbOpenError ? fh(T.dbOpenError) : u;
				});
				T.isBeingOpened = !0, T.dbOpenError = null, T.openComplete = !1;
				var O = T.openCanceller, P = Math.round(10 * u.verno), F = !1;
				function I() {
					if (T.openCanceller !== O) throw new cm.DatabaseClosed("db.open() was cancelled");
				}
				function R() {
					return new Lm(function(O, V) {
						if (I(), !E) throw new cm.MissingAPI();
						var U = u.name, kp = T.autoSchema || !P ? E.open(U) : E.open(U, P);
						if (!kp) throw new cm.MissingAPI();
						kp.onerror = $h(V), kp.onblocked = Ym(u._fireOnBlocked), kp.onupgradeneeded = Ym(function(O) {
							var M;
							Dp = kp.transaction, T.autoSchema && !u._options.allowEmptyDB ? (kp.onerror = eg, Dp.abort(), kp.result.close(), (M = E.deleteDatabase(U)).onsuccess = M.onerror = Ym(function() {
								V(new cm.NoSuchDatabase(`Database ${U} doesnt exist`));
							})) : (Dp.onerror = $h(V), O = O.oldVersion > 2 ** 62 ? 0 : O.oldVersion, Op = O < 1, u.idbdb = kp.result, F && xg(u, Dp), bg(u, O / 10, Dp, V));
						}, V), kp.onsuccess = Ym(function() {
							Dp = null;
							var E, I, V, Ap, jp, Np = u.idbdb = kp.result, Pp = Mp(Np.objectStoreNames);
							if (0 < Pp.length) try {
								var Fp = Np.transaction((Ap = Pp).length === 1 ? Ap[0] : Ap, "readonly");
								if (T.autoSchema) I = Np, V = Fp, (E = u).verno = I.version / 10, V = E._dbSchema = Eg(0, I, V), E._storeNames = Mp(I.objectStoreNames, 0), _g(E, [E._allTables], M(V), V);
								else if (Dg(u, u._dbSchema, Fp), ((jp = Sg(Eg(0, (jp = u).idbdb, Fp), jp._dbSchema)).add.length || jp.change.some(function(u) {
									return u.add.length || u.change.length;
								})) && !F) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), Np.close(), P = Np.version + 1, F = !0, O(R());
								gg(u, Fp);
							} catch {}
							gh.push(u), Np.onversionchange = Ym(function(E) {
								T.vcFired = !0, u.on("versionchange").fire(E);
							}), Np.onclose = Ym(function(T) {
								u.on("close").fire(T);
							}), Op && (jp = u._deps, Fp = U, Np = jp.indexedDB, jp = jp.IDBKeyRange, Mg(Np) || Fp === _h || jg(Np, jp).put({ name: Fp }).catch(dm)), O();
						}, V);
					}).catch(function(u) {
						switch (u?.name) {
							case "UnknownError":
								if (0 < T.PR1398_maxLoop) return T.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), R();
								break;
							case "VersionError": if (0 < P) return P = 0, R();
						}
						return Lm.reject(u);
					});
				}
				var V, U = T.dbReadyResolve, Dp = null, Op = !1;
				return Lm.race([O, (typeof navigator > "u" ? Lm.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(u) {
					function T() {
						return indexedDB.databases().finally(u);
					}
					V = setInterval(T, 100), T();
				}).finally(function() {
					return clearInterval(V);
				}) : Promise.resolve()).then(R)]).then(function() {
					return I(), T.onReadyBeingFired = [], Lm.resolve(Ng(function() {
						return u.on.ready.fire(u.vip);
					})).then(function E() {
						if (0 < T.onReadyBeingFired.length) {
							var O = T.onReadyBeingFired.reduce(ym, dm);
							return T.onReadyBeingFired = [], Lm.resolve(Ng(function() {
								return O(u.vip);
							})).then(E);
						}
					});
				}).finally(function() {
					T.openCanceller === O && (T.onReadyBeingFired = null, T.isBeingOpened = !1);
				}).catch(function(E) {
					T.dbOpenError = E;
					try {
						Dp && Dp.abort();
					} catch {}
					return O === T.openCanceller && u._close(), fh(E);
				}).finally(function() {
					T.openComplete = !0, U();
				}).then(function() {
					var T;
					return Op && (T = {}, u.tables.forEach(function(E) {
						E.schema.indexes.forEach(function(O) {
							O.name && (T[`idb://${u.name}/${E.name}/${O.name}`] = new Fg(-Infinity, [[[]]]));
						}), T[`idb://${u.name}/${E.name}/`] = T[`idb://${u.name}/${E.name}/:dels`] = new Fg(-Infinity, [[[]]]);
					}), rg(tg).fire(T), Jg(T, !0)), u;
				});
			}
			function Zg(u) {
				function T(T) {
					return u.next(T);
				}
				var E = M(T), O = M(function(T) {
					return u.throw(T);
				});
				function M(u) {
					return function(T) {
						var M = u(T), T = M.value;
						return M.done ? T : T && typeof T.then == "function" ? T.then(E, O) : P(T) ? Promise.all(T).then(E, O) : E(T);
					};
				}
				return M(T)();
			}
			function Qg(u, T, E) {
				for (var O = P(u) ? u.slice() : [u], M = 0; M < E; ++M) O.push(T);
				return O;
			}
			var $g = {
				stack: "dbcore",
				name: "VirtualIndexMiddleware",
				level: 1,
				create: function(u) {
					return T(T({}, u), { table: function(E) {
						var O = u.table(E), M = O.schema, P = {}, F = [];
						function I(u, E, O) {
							var M = pg(u), R = P[M] = P[M] || [], V = u == null ? 0 : typeof u == "string" ? 1 : u.length, U = 0 < E, U = T(T({}, O), {
								name: U ? `${M}(virtual-from:${O.name})` : O.name,
								lowLevelIndex: O,
								isVirtual: U,
								keyTail: E,
								keyLength: V,
								extractKey: ug(u),
								unique: !U && O.unique
							});
							return R.push(U), U.isPrimaryKey || F.push(U), 1 < V && I(V === 2 ? u[0] : u.slice(0, V - 1), E + 1, O), R.sort(function(u, T) {
								return u.keyTail - T.keyTail;
							}), U;
						}
						E = I(M.primaryKey.keyPath, 0, M.primaryKey), P[":id"] = [E];
						for (var R = 0, V = M.indexes; R < V.length; R++) {
							var U = V[R];
							I(U.keyPath, 0, U);
						}
						function Dp(E) {
							var O, M = E.query.index;
							return M.isVirtual ? T(T({}, E), { query: {
								index: M.lowLevelIndex,
								range: (O = E.query.range, M = M.keyTail, {
									type: O.type === 1 ? 2 : O.type,
									lower: Qg(O.lower, O.lowerOpen ? u.MAX_KEY : u.MIN_KEY, M),
									lowerOpen: !0,
									upper: Qg(O.upper, O.upperOpen ? u.MIN_KEY : u.MAX_KEY, M),
									upperOpen: !0
								})
							} }) : E;
						}
						return T(T({}, O), {
							schema: T(T({}, M), {
								primaryKey: E,
								indexes: F,
								getIndexByKeyPath: function(u) {
									return (u = P[pg(u)]) && u[0];
								}
							}),
							count: function(u) {
								return O.count(Dp(u));
							},
							query: function(u) {
								return O.query(Dp(u));
							},
							openCursor: function(T) {
								var E = T.query.index, M = E.keyTail, P = E.isVirtual, F = E.keyLength;
								return P ? O.openCursor(Dp(T)).then(function(u) {
									return u && I(u);
								}) : O.openCursor(T);
								function I(E) {
									return Object.create(E, {
										continue: { value: function(O) {
											O == null ? T.unique ? E.continue(E.key.slice(0, F).concat(T.reverse ? u.MIN_KEY : u.MAX_KEY, M)) : E.continue() : E.continue(Qg(O, T.reverse ? u.MAX_KEY : u.MIN_KEY, M));
										} },
										continuePrimaryKey: { value: function(T, O) {
											E.continuePrimaryKey(Qg(T, u.MAX_KEY, M), O);
										} },
										primaryKey: { get: function() {
											return E.primaryKey;
										} },
										key: { get: function() {
											var u = E.key;
											return F === 1 ? u[0] : u.slice(0, F);
										} },
										value: { get: function() {
											return E.value;
										} }
									});
								}
							}
						});
					} });
				}
			};
			function e_(u, T, E, O) {
				return E ||= {}, O ||= "", M(u).forEach(function(M) {
					var P, F, I;
					V(T, M) ? (P = u[M], F = T[M], typeof P == "object" && typeof F == "object" && P && F ? (I = Kp(P)) === Kp(F) ? I === "Object" ? e_(P, F, E, O + M + ".") : P !== F && (E[O + M] = T[M]) : E[O + M] = T[M] : P !== F && (E[O + M] = T[M])) : E[O + M] = void 0;
				}), M(T).forEach(function(M) {
					V(u, M) || (E[O + M] = T[M]);
				}), E;
			}
			function t_(u, T) {
				return T.type === "delete" ? T.keys : T.keys || T.values.map(u.extractKey);
			}
			var n_ = {
				stack: "dbcore",
				name: "HooksMiddleware",
				level: 2,
				create: function(u) {
					return T(T({}, u), { table: function(O) {
						var M = u.table(O), P = M.schema.primaryKey;
						return T(T({}, M), { mutate: function(u) {
							var F = Nm.trans, I = F.table(O).hook, R = I.deleting, U = I.creating, Dp = I.updating;
							switch (u.type) {
								case "add":
									if (U.fire === dm) break;
									return F._promise("readwrite", function() {
										return Op(u);
									}, !0);
								case "put":
									if (U.fire === dm && Dp.fire === dm) break;
									return F._promise("readwrite", function() {
										return Op(u);
									}, !0);
								case "delete":
									if (R.fire === dm) break;
									return F._promise("readwrite", function() {
										return Op(u);
									}, !0);
								case "deleteRange":
									if (R.fire === dm) break;
									return F._promise("readwrite", function() {
										return function u(E, O, F) {
											return M.query({
												trans: E,
												values: !1,
												query: {
													index: P,
													range: O
												},
												limit: F
											}).then(function(M) {
												var P = M.result;
												return Op({
													type: "delete",
													keys: P,
													trans: E
												}).then(function(M) {
													return 0 < M.numFailures ? Promise.reject(M.failures[0]) : P.length < F ? {
														failures: [],
														numFailures: 0,
														lastResult: void 0
													} : u(E, T(T({}, O), {
														lower: P[P.length - 1],
														lowerOpen: !0
													}), F);
												});
											});
										}(u.trans, u.range, 1e4);
									}, !0);
							}
							return M.mutate(u);
							function Op(u) {
								var O, F, I, Op = Nm.trans, kp = u.keys || t_(P, u);
								if (!kp) throw Error("Keys missing");
								return (u = u.type === "add" || u.type === "put" ? T(T({}, u), { keys: kp }) : T({}, u)).type !== "delete" && (u.values = E([], u.values)), u.keys &&= E([], u.keys), O = M, I = kp, ((F = u).type === "add" ? Promise.resolve([]) : O.getMany({
									trans: F.trans,
									keys: I,
									cache: "immutable"
								})).then(function(T) {
									var E = kp.map(function(E, O) {
										var M, F, I, kp = T[O], Ap = {
											onerror: null,
											onsuccess: null
										};
										return u.type === "delete" ? R.fire.call(Ap, E, kp, Op) : u.type === "add" || kp === void 0 ? (M = U.fire.call(Ap, E, u.values[O], Op), E == null && M != null && (u.keys[O] = E = M, P.outbound || Lp(u.values[O], P.keyPath, E))) : (M = e_(kp, u.values[O]), (F = Dp.fire.call(Ap, M, E, kp, Op)) && (I = u.values[O], Object.keys(F).forEach(function(u) {
											V(I, u) ? I[u] = F[u] : Lp(I, u, F[u]);
										}))), Ap;
									});
									return M.mutate(u).then(function(O) {
										for (var M = O.failures, P = O.results, F = O.numFailures, O = O.lastResult, I = 0; I < kp.length; ++I) {
											var R = (P || kp)[I], V = E[I];
											R == null ? V.onerror && V.onerror(M[I]) : V.onsuccess && V.onsuccess(u.type === "put" && T[I] ? u.values[I] : R);
										}
										return {
											failures: M,
											results: P,
											numFailures: F,
											lastResult: O
										};
									}).catch(function(u) {
										return E.forEach(function(T) {
											return T.onerror && T.onerror(u);
										}), Promise.reject(u);
									});
								});
							}
						} });
					} });
				}
			};
			function r_(u, T, E) {
				try {
					if (!T || T.keys.length < u.length) return null;
					for (var O = [], M = 0, P = 0; M < T.keys.length && P < u.length; ++M) wh(T.keys[M], u[P]) === 0 && (O.push(E ? Wp(T.values[M]) : T.values[M]), ++P);
					return O.length === u.length ? O : null;
				} catch {
					return null;
				}
			}
			var i_ = {
				stack: "dbcore",
				level: -1,
				create: function(u) {
					return { table: function(E) {
						var O = u.table(E);
						return T(T({}, O), {
							getMany: function(u) {
								if (!u.cache) return O.getMany(u);
								var T = r_(u.keys, u.trans._cache, u.cache === "clone");
								return T ? Lm.resolve(T) : O.getMany(u).then(function(T) {
									return u.trans._cache = {
										keys: u.keys,
										values: u.cache === "clone" ? Wp(T) : T
									}, T;
								});
							},
							mutate: function(u) {
								return u.type !== "add" && (u.trans._cache = null), O.mutate(u);
							}
						});
					} };
				}
			};
			function a_(u, T) {
				return u.trans.mode === "readonly" && !!u.subscr && !u.trans.explicit && u.trans.db._options.cache !== "disabled" && !T.schema.primaryKey.outbound;
			}
			function o_(u, T) {
				switch (u) {
					case "query": return T.values && !T.unique;
					case "get":
					case "getMany":
					case "count":
					case "openCursor": return !1;
				}
			}
			var s_ = {
				stack: "dbcore",
				level: 0,
				name: "Observability",
				create: function(u) {
					var E = u.schema.name, O = new Fg(u.MIN_KEY, u.MAX_KEY);
					return T(T({}, u), {
						transaction: function(T, E, O) {
							if (Nm.subscr && E !== "readonly") throw new cm.ReadOnly(`Readwrite transaction in liveQuery context. Querier source: ${Nm.querier}`);
							return u.transaction(T, E, O);
						},
						table: function(F) {
							var I = u.table(F), R = I.schema, V = R.primaryKey, U = R.indexes, Dp = V.extractKey, Op = V.outbound, kp = V.autoIncrement && U.filter(function(u) {
								return u.compound && u.keyPath.includes(V.keyPath);
							}), Ap = T(T({}, I), { mutate: function(T) {
								function M(u) {
									return u = `idb://${E}/${F}/${u}`, jp[u] || (jp[u] = new Fg());
								}
								var U, Dp, Op, Ap = T.trans, jp = T.mutatedParts ||= {}, Mp = M(""), Np = M(":dels"), Pp = T.type, Fp = T.type === "deleteRange" ? [T.range] : T.type === "delete" ? [T.keys] : T.values.length < 50 ? [t_(V, T).filter(function(u) {
									return u;
								}), T.values] : [], Ip = Fp[0], Lp = Fp[1], Fp = T.trans._cache;
								return P(Ip) ? (Mp.addKeys(Ip), (Fp = Pp === "delete" || Ip.length === Lp.length ? r_(Ip, Fp) : null) || Np.addKeys(Ip), (Fp || Lp) && (U = M, Dp = Fp, Op = Lp, R.indexes.forEach(function(u) {
									var T = U(u.name || "");
									function E(T) {
										return T == null ? null : u.extractKey(T);
									}
									function O(E) {
										return u.multiEntry && P(E) ? E.forEach(function(u) {
											return T.addKey(u);
										}) : T.addKey(E);
									}
									(Dp || Op).forEach(function(u, T) {
										var M = Dp && E(Dp[T]), T = Op && E(Op[T]);
										wh(M, T) !== 0 && (M != null && O(M), T != null && O(T));
									});
								}))) : Ip ? (Lp = {
									from: (Lp = Ip.lower) ?? u.MIN_KEY,
									to: (Lp = Ip.upper) ?? u.MAX_KEY
								}, Np.add(Lp), Mp.add(Lp)) : (Mp.add(O), Np.add(O), R.indexes.forEach(function(u) {
									return M(u.name).add(O);
								})), I.mutate(T).then(function(u) {
									return !Ip || T.type !== "add" && T.type !== "put" || (Mp.addKeys(u.results), kp && kp.forEach(function(E) {
										for (var O = T.values.map(function(u) {
											return E.extractKey(u);
										}), P = E.keyPath.findIndex(function(u) {
											return u === V.keyPath;
										}), F = 0, I = u.results.length; F < I; ++F) O[F][P] = u.results[F];
										M(E.name).addKeys(O);
									})), Ap.mutatedParts = Hg(Ap.mutatedParts || {}, jp), u;
								});
							} }), U = function(T) {
								var E = T.query, T = E.index, E = E.range;
								return [T, new Fg((T = E.lower) ?? u.MIN_KEY, (E = E.upper) ?? u.MAX_KEY)];
							}, jp = {
								get: function(u) {
									return [V, new Fg(u.key)];
								},
								getMany: function(u) {
									return [V, new Fg().addKeys(u.keys)];
								},
								count: U,
								query: U,
								openCursor: U
							};
							return M(jp).forEach(function(u) {
								Ap[u] = function(M) {
									var P = Nm.subscr, R = !!P, V = a_(Nm, I) && o_(u, M) ? M.obsSet = {} : P;
									if (R) {
										var U = function(u) {
											return u = `idb://${E}/${F}/${u}`, V[u] || (V[u] = new Fg());
										}, kp = U(""), Ap = U(":dels"), P = jp[u](M), R = P[0], P = P[1];
										if ((u === "query" && R.isPrimaryKey && !M.values ? Ap : U(R.name || "")).add(P), !R.isPrimaryKey) {
											if (u !== "count") {
												var Mp = u === "query" && Op && M.values && I.query(T(T({}, M), { values: !1 }));
												return I[u].apply(this, arguments).then(function(T) {
													if (u === "query") {
														if (Op && M.values) return Mp.then(function(u) {
															return u = u.result, kp.addKeys(u), T;
														});
														var E = M.values ? T.result.map(Dp) : T.result;
														(M.values ? kp : Ap).addKeys(E);
													} else if (u === "openCursor") {
														var O = T, P = M.values;
														return O && Object.create(O, {
															key: { get: function() {
																return Ap.addKey(O.primaryKey), O.key;
															} },
															primaryKey: { get: function() {
																var u = O.primaryKey;
																return Ap.addKey(u), u;
															} },
															value: { get: function() {
																return P && kp.addKey(O.primaryKey), O.value;
															} }
														});
													}
													return T;
												});
											}
											Ap.add(O);
										}
									}
									return I[u].apply(this, arguments);
								};
							}), Ap;
						}
					});
				}
			};
			function c_(u, E, O) {
				if (O.numFailures === 0) return E;
				if (E.type === "deleteRange") return null;
				var M = E.keys ? E.keys.length : "values" in E && E.values ? E.values.length : 1;
				return O.numFailures === M ? null : (E = T({}, E), P(E.keys) && (E.keys = E.keys.filter(function(u, T) {
					return !(T in O.failures);
				})), "values" in E && P(E.values) && (E.values = E.values.filter(function(u, T) {
					return !(T in O.failures);
				})), E);
			}
			function l_(u, T) {
				return E = u, ((O = T).lower === void 0 || (O.lowerOpen ? 0 < wh(E, O.lower) : 0 <= wh(E, O.lower))) && (u = u, (T = T).upper === void 0 || (T.upperOpen ? wh(u, T.upper) < 0 : wh(u, T.upper) <= 0));
				var E, O;
			}
			function u_(u, T, E, O, M, F) {
				if (!E || E.length === 0) return u;
				var I = T.query.index, R = I.multiEntry, V = T.query.range, U = O.schema.primaryKey.extractKey, Dp = I.extractKey, Op = (I.lowLevelIndex || I).extractKey, E = E.reduce(function(u, E) {
					var O = u, M = [];
					if (E.type === "add" || E.type === "put") for (var F = new Fg(), I = E.values.length - 1; 0 <= I; --I) {
						var Op, kp = E.values[I], Ap = U(kp);
						F.hasKey(Ap) || (Op = Dp(kp), (R && P(Op) ? Op.some(function(u) {
							return l_(u, V);
						}) : l_(Op, V)) && (F.addKey(Ap), M.push(kp)));
					}
					switch (E.type) {
						case "add":
							var jp = new Fg().addKeys(T.values ? u.map(function(u) {
								return U(u);
							}) : u), O = u.concat(T.values ? M.filter(function(u) {
								return u = U(u), !jp.hasKey(u) && (jp.addKey(u), !0);
							}) : M.map(function(u) {
								return U(u);
							}).filter(function(u) {
								return !jp.hasKey(u) && (jp.addKey(u), !0);
							}));
							break;
						case "put":
							var Mp = new Fg().addKeys(E.values.map(function(u) {
								return U(u);
							}));
							O = u.filter(function(u) {
								return !Mp.hasKey(T.values ? U(u) : u);
							}).concat(T.values ? M : M.map(function(u) {
								return U(u);
							}));
							break;
						case "delete":
							var Np = new Fg().addKeys(E.keys);
							O = u.filter(function(u) {
								return !Np.hasKey(T.values ? U(u) : u);
							});
							break;
						case "deleteRange":
							var Pp = E.range;
							O = u.filter(function(u) {
								return !l_(U(u), Pp);
							});
					}
					return O;
				}, u);
				return E === u ? u : (E.sort(function(u, T) {
					return wh(Op(u), Op(T)) || wh(U(u), U(T));
				}), T.limit && T.limit < Infinity && (E.length > T.limit ? E.length = T.limit : u.length === T.limit && E.length < T.limit && (M.dirty = !0)), F ? Object.freeze(E) : E);
			}
			function d_(u, T) {
				return wh(u.lower, T.lower) === 0 && wh(u.upper, T.upper) === 0 && !!u.lowerOpen == !!T.lowerOpen && !!u.upperOpen == !!T.upperOpen;
			}
			function f_(u, T) {
				return function(u, T, E, O) {
					if (u === void 0) return T === void 0 ? 0 : -1;
					if (T === void 0) return 1;
					if ((T = wh(u, T)) === 0) {
						if (E && O) return 0;
						if (E) return 1;
						if (O) return -1;
					}
					return T;
				}(u.lower, T.lower, u.lowerOpen, T.lowerOpen) <= 0 && 0 <= function(u, T, E, O) {
					if (u === void 0) return T === void 0 ? 0 : 1;
					if (T === void 0) return -1;
					if ((T = wh(u, T)) === 0) {
						if (E && O) return 0;
						if (E) return -1;
						if (O) return 1;
					}
					return T;
				}(u.upper, T.upper, u.upperOpen, T.upperOpen);
			}
			function p_(u, T, E, O) {
				u.subscribers.add(E), O.addEventListener("abort", function() {
					var O, M;
					u.subscribers.delete(E), u.subscribers.size === 0 && (O = u, M = T, setTimeout(function() {
						O.subscribers.size === 0 && Yp(M, O);
					}, 3e3));
				});
			}
			var m_ = {
				stack: "dbcore",
				level: 0,
				name: "Cache",
				create: function(u) {
					var E = u.schema.name;
					return T(T({}, u), {
						transaction: function(T, O, M) {
							var P, F, I = u.transaction(T, O, M);
							return O === "readwrite" && (F = (P = new AbortController()).signal, M = function(M) {
								return function() {
									if (P.abort(), O === "readwrite") {
										for (var F = /* @__PURE__ */ new Set(), R = 0, V = T; R < V.length; R++) {
											var U = V[R], Dp = Wg[`idb://${E}/${U}`];
											if (Dp) {
												var Op = u.table(U), kp = Dp.optimisticOps.filter(function(u) {
													return u.trans === I;
												});
												if (I._explicit && M && I.mutatedParts) for (var Ap = 0, jp = Object.values(Dp.queries.query); Ap < jp.length; Ap++) for (var Mp = 0, Np = (Ip = jp[Ap]).slice(); Mp < Np.length; Mp++) Ug((Lp = Np[Mp]).obsSet, I.mutatedParts) && (Yp(Ip, Lp), Lp.subscribers.forEach(function(u) {
													return F.add(u);
												}));
												else if (0 < kp.length) {
													Dp.optimisticOps = Dp.optimisticOps.filter(function(u) {
														return u.trans !== I;
													});
													for (var Pp = 0, Fp = Object.values(Dp.queries.query); Pp < Fp.length; Pp++) for (var Ip, Lp, Rp, zp = 0, Bp = (Ip = Fp[Pp]).slice(); zp < Bp.length; zp++) (Lp = Bp[zp]).res != null && I.mutatedParts && (M && !Lp.dirty ? (Rp = Object.isFrozen(Lp.res), Rp = u_(Lp.res, Lp.req, kp, Op, Lp, Rp), Lp.dirty ? (Yp(Ip, Lp), Lp.subscribers.forEach(function(u) {
														return F.add(u);
													})) : Rp !== Lp.res && (Lp.res = Rp, Lp.promise = Lm.resolve({ result: Rp }))) : (Lp.dirty && Yp(Ip, Lp), Lp.subscribers.forEach(function(u) {
														return F.add(u);
													})));
												}
											}
										}
										F.forEach(function(u) {
											return u();
										});
									}
								};
							}, I.addEventListener("abort", M(!1), { signal: F }), I.addEventListener("error", M(!1), { signal: F }), I.addEventListener("complete", M(!0), { signal: F })), I;
						},
						table: function(O) {
							var M = u.table(O), P = M.schema.primaryKey;
							return T(T({}, M), {
								mutate: function(u) {
									var F = Nm.trans;
									if (P.outbound || F.db._options.cache === "disabled" || F.explicit || F.idbtrans.mode !== "readwrite") return M.mutate(u);
									var I = Wg[`idb://${E}/${O}`];
									return I ? (F = M.mutate(u), u.type !== "add" && u.type !== "put" || !(50 <= u.values.length || t_(P, u).some(function(u) {
										return u == null;
									})) ? (I.optimisticOps.push(u), u.mutatedParts && qg(u.mutatedParts), F.then(function(T) {
										0 < T.numFailures && (Yp(I.optimisticOps, u), (T = c_(0, u, T)) && I.optimisticOps.push(T), u.mutatedParts && qg(u.mutatedParts));
									}), F.catch(function() {
										Yp(I.optimisticOps, u), u.mutatedParts && qg(u.mutatedParts);
									})) : F.then(function(E) {
										var O = c_(0, T(T({}, u), { values: u.values.map(function(u, O) {
											var M;
											return E.failures[O] ? u : (u = (M = P.keyPath) != null && M.includes(".") ? Wp(u) : T({}, u), Lp(u, P.keyPath, E.results[O]), u);
										}) }), E);
										I.optimisticOps.push(O), queueMicrotask(function() {
											return u.mutatedParts && qg(u.mutatedParts);
										});
									}), F) : M.mutate(u);
								},
								query: function(u) {
									if (!a_(Nm, M) || !o_("query", u)) return M.query(u);
									var T = (R = Nm.trans)?.db._options.cache === "immutable", P = Nm, F = P.requery, I = P.signal, R = function(u, T, E, O) {
										var M = Wg[`idb://${u}/${T}`];
										if (!M) return [];
										if (!(T = M.queries[E])) return [
											null,
											!1,
											M,
											null
										];
										var P = T[(O.query ? O.query.index.name : null) || ""];
										if (!P) return [
											null,
											!1,
											M,
											null
										];
										switch (E) {
											case "query":
												var F = P.find(function(u) {
													return u.req.limit === O.limit && u.req.values === O.values && d_(u.req.query.range, O.query.range);
												});
												return F ? [
													F,
													!0,
													M,
													P
												] : [
													P.find(function(u) {
														return ("limit" in u.req ? u.req.limit : Infinity) >= O.limit && (!O.values || u.req.values) && f_(u.req.query.range, O.query.range);
													}),
													!1,
													M,
													P
												];
											case "count": return F = P.find(function(u) {
												return d_(u.req.query.range, O.query.range);
											}), [
												F,
												!!F,
												M,
												P
											];
										}
									}(E, O, "query", u), V = R[0], P = R[1], U = R[2], Dp = R[3];
									return V && P ? V.obsSet = u.obsSet : (P = M.query(u).then(function(u) {
										var E = u.result;
										if (V && (V.res = E), T) {
											for (var O = 0, M = E.length; O < M; ++O) Object.freeze(E[O]);
											Object.freeze(E);
										} else u.result = Wp(E);
										return u;
									}).catch(function(u) {
										return Dp && V && Yp(Dp, V), Promise.reject(u);
									}), V = {
										obsSet: u.obsSet,
										promise: P,
										subscribers: /* @__PURE__ */ new Set(),
										type: "query",
										req: u,
										dirty: !1
									}, Dp ? Dp.push(V) : (Dp = [V], (U ||= Wg[`idb://${E}/${O}`] = {
										queries: {
											query: {},
											count: {}
										},
										objs: /* @__PURE__ */ new Map(),
										optimisticOps: [],
										unsignaledParts: {}
									}).queries.query[u.query.index.name || ""] = Dp)), p_(V, Dp, F, I), V.promise.then(function(E) {
										return { result: u_(E.result, u, U?.optimisticOps, M, V, T) };
									});
								}
							});
						}
					});
				}
			};
			function h_(u, T) {
				return new Proxy(u, { get: function(u, E, O) {
					return E === "db" ? T : Reflect.get(u, E, O);
				} });
			}
			var g_ = (__.prototype.version = function(u) {
				if (isNaN(u) || u < .1) throw new cm.Type("Given version is not a positive number");
				if (u = Math.round(10 * u) / 10, this.idbdb || this._state.isBeingOpened) throw new cm.Schema("Cannot add version when database is open");
				this.verno = Math.max(this.verno, u);
				var T = this._versions, E = T.filter(function(T) {
					return T._cfg.version === u;
				})[0];
				return E || (E = new this.Version(u), T.push(E), T.sort(yg), E.stores({}), this._state.autoSchema = !1, E);
			}, __.prototype._whenReady = function(u) {
				var T = this;
				return this.idbdb && (this._state.openComplete || Nm.letThrough || this._vip) ? u() : new Lm(function(u, E) {
					if (T._state.openComplete) return E(new cm.DatabaseClosed(T._state.dbOpenError));
					if (!T._state.isBeingOpened) {
						if (!T._state.autoOpen) return void E(new cm.DatabaseClosed());
						T.open().catch(dm);
					}
					T._state.dbReadyPromise.then(u, E);
				}).then(u);
			}, __.prototype.use = function(u) {
				var T = u.stack, E = u.create, O = u.level, M = u.name;
				return M && this.unuse({
					stack: T,
					name: M
				}), u = this._middlewares[T] || (this._middlewares[T] = []), u.push({
					stack: T,
					create: E,
					level: O ?? 10,
					name: M
				}), u.sort(function(u, T) {
					return u.level - T.level;
				}), this;
			}, __.prototype.unuse = function(u) {
				var T = u.stack, E = u.name, O = u.create;
				return T && this._middlewares[T] && (this._middlewares[T] = this._middlewares[T].filter(function(u) {
					return O ? u.create !== O : !!E && u.name !== E;
				})), this;
			}, __.prototype.open = function() {
				var u = this;
				return lh(Mm, function() {
					return Xg(u);
				});
			}, __.prototype._close = function() {
				this.on.close.fire(new CustomEvent("close"));
				var u = this._state, T = gh.indexOf(this);
				if (0 <= T && gh.splice(T, 1), this.idbdb) {
					try {
						this.idbdb.close();
					} catch {}
					this.idbdb = null;
				}
				u.isBeingOpened || (u.dbReadyPromise = new Lm(function(T) {
					u.dbReadyResolve = T;
				}), u.openCanceller = new Lm(function(T, E) {
					u.cancelOpen = E;
				}));
			}, __.prototype.close = function(u) {
				var T = (u === void 0 ? { disableAutoOpen: !0 } : u).disableAutoOpen, u = this._state;
				T ? (u.isBeingOpened && u.cancelOpen(new cm.DatabaseClosed()), this._close(), u.autoOpen = !1, u.dbOpenError = new cm.DatabaseClosed()) : (this._close(), u.autoOpen = this._options.autoOpen || u.isBeingOpened, u.openComplete = !1, u.dbOpenError = null);
			}, __.prototype.delete = function(u) {
				var T = this;
				u === void 0 && (u = { disableAutoOpen: !0 });
				var E = 0 < arguments.length && typeof arguments[0] != "object", O = this._state;
				return new Lm(function(M, P) {
					function F() {
						T.close(u);
						var E = T._deps.indexedDB.deleteDatabase(T.name);
						E.onsuccess = Ym(function() {
							var u = T._deps, E = T.name, O = u.indexedDB;
							u = u.IDBKeyRange, Mg(O) || E === _h || jg(O, u).delete(E).catch(dm), M();
						}), E.onerror = $h(P), E.onblocked = T._fireOnBlocked;
					}
					if (E) throw new cm.InvalidArgument("Invalid closeOptions argument to db.delete()");
					O.isBeingOpened ? O.dbReadyPromise.then(F) : F();
				});
			}, __.prototype.backendDB = function() {
				return this.idbdb;
			}, __.prototype.isOpen = function() {
				return this.idbdb !== null;
			}, __.prototype.hasBeenClosed = function() {
				var u = this._state.dbOpenError;
				return u && u.name === "DatabaseClosed";
			}, __.prototype.hasFailed = function() {
				return this._state.dbOpenError !== null;
			}, __.prototype.dynamicallyOpened = function() {
				return this._state.autoSchema;
			}, Object.defineProperty(__.prototype, "tables", {
				get: function() {
					var u = this;
					return M(this._allTables).map(function(T) {
						return u._allTables[T];
					});
				},
				enumerable: !1,
				configurable: !0
			}), __.prototype.transaction = function() {
				var u = (function(u, T, E) {
					var O = arguments.length;
					if (O < 2) throw new cm.InvalidArgument("Too few arguments");
					for (var M = Array(O - 1); --O;) M[O - 1] = arguments[O];
					return E = M.pop(), [
						u,
						Bp(M),
						E
					];
				}).apply(this, arguments);
				return this._transaction.apply(this, u);
			}, __.prototype._transaction = function(u, T, E) {
				var O = this, M = Nm.trans;
				M && M.db === this && u.indexOf("!") === -1 || (M = null);
				var P, F, I = u.indexOf("?") !== -1;
				u = u.replace("!", "").replace("?", "");
				try {
					if (F = T.map(function(u) {
						if (u = u instanceof O.Table ? u.name : u, typeof u != "string") throw TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
						return u;
					}), u == "r" || u === vh) P = vh;
					else {
						if (u != "rw" && u != yh) throw new cm.InvalidArgument("Invalid transaction mode: " + u);
						P = yh;
					}
					if (M) {
						if (M.mode === vh && P === yh) {
							if (!I) throw new cm.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
							M = null;
						}
						M && F.forEach(function(u) {
							if (M && M.storeNames.indexOf(u) === -1) {
								if (!I) throw new cm.SubTransaction("Table " + u + " not included in parent transaction.");
								M = null;
							}
						}), I && M && !M.active && (M = null);
					}
				} catch (u) {
					return M ? M._promise(null, function(T, E) {
						E(u);
					}) : fh(u);
				}
				var R = (function u(T, E, O, M, P) {
					return Lm.resolve().then(function() {
						var F = Nm.transless || Nm, I = T._createTransaction(E, O, T._dbSchema, M);
						if (I.explicit = !0, F = {
							trans: I,
							transless: F
						}, M) I.idbtrans = M.idbtrans;
						else try {
							I.create(), I.idbtrans._explicit = !0, T._state.PR1398_maxLoop = 3;
						} catch (M) {
							return M.name === om.InvalidState && T.isOpen() && 0 < --T._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), T.close({ disableAutoOpen: !1 }), T.open().then(function() {
								return u(T, E, O, null, P);
							})) : fh(M);
						}
						var R, V = Qp(P);
						return V && rh(), F = Lm.follow(function() {
							var u;
							(R = P.call(I, I)) && (V ? (u = ih.bind(null, null), R.then(u, u)) : typeof R.next == "function" && typeof R.throw == "function" && (R = Zg(R)));
						}, F), (R && typeof R.then == "function" ? Lm.resolve(R).then(function(u) {
							return I.active ? u : fh(new cm.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
						}) : F.then(function() {
							return R;
						})).then(function(u) {
							return M && I._resolve(), I._completion.then(function() {
								return u;
							});
						}).catch(function(u) {
							return I._reject(u), fh(u);
						});
					});
				}).bind(null, this, P, F, M, E);
				return M ? M._promise(P, R, "lock") : Nm.trans ? lh(Nm.transless, function() {
					return O._whenReady(R);
				}) : this._whenReady(R);
			}, __.prototype.table = function(u) {
				if (!V(this._allTables, u)) throw new cm.InvalidTable(`Table ${u} does not exist`);
				return this._allTables[u];
			}, __);
			function __(u, E) {
				var O = this;
				this._middlewares = {}, this.verno = 0;
				var M = __.dependencies;
				this._options = E = T({
					addons: __.addons,
					autoOpen: !0,
					indexedDB: M.indexedDB,
					IDBKeyRange: M.IDBKeyRange,
					cache: "cloned"
				}, E), this._deps = {
					indexedDB: E.indexedDB,
					IDBKeyRange: E.IDBKeyRange
				}, M = E.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
				var P, F, I, R, V, U = {
					dbOpenError: null,
					isBeingOpened: !1,
					onReadyBeingFired: null,
					openComplete: !1,
					dbReadyResolve: dm,
					dbReadyPromise: null,
					cancelOpen: dm,
					openCanceller: null,
					autoSchema: !0,
					PR1398_maxLoop: 3,
					autoOpen: E.autoOpen
				};
				U.dbReadyPromise = new Lm(function(u) {
					U.dbReadyResolve = u;
				}), U.openCanceller = new Lm(function(u, T) {
					U.cancelOpen = T;
				}), this._state = U, this.name = u, this.on = Ah(this, "populate", "blocked", "versionchange", "close", { ready: [ym, dm] }), this.once = function(u, T) {
					var E = function() {
						var M = [...arguments];
						O.on(u).unsubscribe(E), T.apply(O, M);
					};
					return O.on(u, E);
				}, this.on.ready.subscribe = Np(this.on.ready.subscribe, function(u) {
					return function(T, E) {
						__.vip(function() {
							var M, P = O._state;
							P.openComplete ? (P.dbOpenError || Lm.resolve().then(T), E && u(T)) : P.onReadyBeingFired ? (P.onReadyBeingFired.push(T), E && u(T)) : (u(T), M = O, E || u(function u() {
								M.on.ready.unsubscribe(T), M.on.ready.unsubscribe(u);
							}));
						});
					};
				}), this.Collection = (P = this, jh(Vh.prototype, function(u, T) {
					this.db = P;
					var E = xh, O = null;
					if (T) try {
						E = T();
					} catch (u) {
						O = u;
					}
					var M = u._ctx, T = M.table, u = T.hook.reading.fire;
					this._ctx = {
						table: T,
						index: M.index,
						isPrimKey: !M.index || T.schema.primKey.keyPath && M.index === T.schema.primKey.name,
						range: E,
						keysOnly: !1,
						dir: "next",
						unique: "",
						algorithm: null,
						filter: null,
						replayFilter: null,
						justLimit: !0,
						isMatch: null,
						offset: 0,
						limit: Infinity,
						error: O,
						or: M.or,
						valueMapper: u === fm ? null : u
					};
				})), this.Table = (F = this, jh(Oh.prototype, function(u, T, E) {
					this.db = F, this._tx = E, this.name = u, this.schema = T, this.hook = F._allTables[u] ? F._allTables[u].hook : Ah(null, {
						creating: [hm, dm],
						reading: [pm, fm],
						updating: [_m, dm],
						deleting: [gm, dm]
					});
				})), this.Transaction = (I = this, jh(ig.prototype, function(u, T, E, O, M) {
					var P = this;
					u !== "readonly" && T.forEach(function(u) {
						u = (u = E[u])?.yProps, u && (T = T.concat(u.map(function(u) {
							return u.updatesTable;
						})));
					}), this.db = I, this.mode = u, this.storeNames = T, this.schema = E, this.chromeTransactionDurability = O, this.idbtrans = null, this.on = Ah(this, "complete", "error", "abort"), this.parent = M || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Lm(function(u, T) {
						P._resolve = u, P._reject = T;
					}), this._completion.then(function() {
						P.active = !1, P.on.complete.fire();
					}, function(u) {
						var T = P.active;
						return P.active = !1, P.on.error.fire(u), P.parent ? P.parent._reject(u) : T && P.idbtrans && P.idbtrans.abort(), fh(u);
					});
				})), this.Version = (R = this, jh(kg.prototype, function(u) {
					this.db = R, this._cfg = {
						version: u,
						storesSource: null,
						dbschema: {},
						tables: {},
						contentUpgrade: null
					};
				})), this.WhereClause = (V = this, jh(Zh.prototype, function(u, T, E) {
					if (this.db = V, this._ctx = {
						table: u,
						index: T === ":id" ? null : T,
						or: E
					}, this._cmp = this._ascending = wh, this._descending = function(u, T) {
						return wh(T, u);
					}, this._max = function(u, T) {
						return 0 < wh(u, T) ? u : T;
					}, this._min = function(u, T) {
						return wh(u, T) < 0 ? u : T;
					}, this._IDBKeyRange = V._deps.IDBKeyRange, !this._IDBKeyRange) throw new cm.MissingAPI();
				})), this.on("versionchange", function(u) {
					0 < u.newVersion ? console.warn(`Another connection wants to upgrade database '${O.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${O.name}'. Closing db now to resume the delete request.`), O.close({ disableAutoOpen: !1 });
				}), this.on("blocked", function(u) {
					!u.newVersion || u.newVersion < u.oldVersion ? console.warn(`Dexie.delete('${O.name}') was blocked`) : console.warn(`Upgrade '${O.name}' blocked by other connection holding version ${u.oldVersion / 10}`);
				}), this._maxKey = lg(E.IDBKeyRange), this._createTransaction = function(u, T, E, M) {
					return new O.Transaction(u, T, E, O._options.chromeTransactionDurability, M);
				}, this._fireOnBlocked = function(u) {
					O.on("blocked").fire(u), gh.filter(function(u) {
						return u.name === O.name && u !== O && !u._state.vcFired;
					}).map(function(T) {
						return T.on("versionchange").fire(u);
					});
				}, this.use(i_), this.use(m_), this.use(s_), this.use($g), this.use(n_);
				var Dp = new Proxy(this, { get: function(u, T, E) {
					if (T === "_vip") return !0;
					if (T === "table") return function(u) {
						return h_(O.table(u), Dp);
					};
					var M = Reflect.get(u, T, E);
					return M instanceof Oh ? h_(M, Dp) : T === "tables" ? M.map(function(u) {
						return h_(u, Dp);
					}) : T === "_createTransaction" ? function() {
						return h_(M.apply(this, arguments), Dp);
					} : M;
				} });
				this.vip = Dp, M.forEach(function(u) {
					return u(O);
				});
			}
			var v_, em = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", y_ = (b_.prototype.subscribe = function(u, T, E) {
				return this._subscribe(u && typeof u != "function" ? u : {
					next: u,
					error: T,
					complete: E
				});
			}, b_.prototype[em] = function() {
				return this;
			}, b_);
			function b_(u) {
				this._subscribe = u;
			}
			try {
				v_ = {
					indexedDB: O.indexedDB || O.mozIndexedDB || O.webkitIndexedDB || O.msIndexedDB,
					IDBKeyRange: O.IDBKeyRange || O.webkitIDBKeyRange
				};
			} catch {
				v_ = {
					indexedDB: null,
					IDBKeyRange: null
				};
			}
			function x_(u) {
				var T, E = !1, O = new y_(function(O) {
					var M = Qp(u), P, F = !1, I = {}, R = {}, U = {
						get closed() {
							return F;
						},
						unsubscribe: function() {
							F || (F = !0, P && P.abort(), Dp && rg.storagemutated.unsubscribe(kp));
						}
					};
					O.start && O.start(U);
					var Dp = !1, Op = function() {
						return dh(Ap);
					}, kp = function(u) {
						Hg(I, u), Ug(R, I) && Op();
					}, Ap = function() {
						var U, Ap, jp;
						!F && v_.indexedDB && (I = {}, U = {}, P && P.abort(), P = new AbortController(), jp = function(T) {
							var E = Gm();
							try {
								M && rh();
								var O = nh(u, T);
								return O = M ? O.finally(ih) : O;
							} finally {
								E && Km();
							}
						}(Ap = {
							subscr: U,
							signal: P.signal,
							requery: Op,
							querier: u,
							trans: null
						}), Promise.resolve(jp).then(function(u) {
							E = !0, T = u, F || Ap.signal.aborted || (I = {}, function(u) {
								for (var T in u) if (V(u, T)) return;
								return 1;
							}(R = U) || Dp || (rg(tg, kp), Dp = !0), dh(function() {
								return !F && O.next && O.next(u);
							}));
						}, function(u) {
							E = !1, ["DatabaseClosedError", "AbortError"].includes(u?.name) || F || dh(function() {
								F || O.error && O.error(u);
							});
						}));
					};
					return setTimeout(Op, 0), U;
				});
				return O.hasValue = function() {
					return E;
				}, O.getValue = function() {
					return T;
				}, O;
			}
			var S_ = g_;
			function C_(u) {
				var T = T_;
				try {
					T_ = !0, rg.storagemutated.fire(u), Jg(u, !0);
				} finally {
					T_ = T;
				}
			}
			U(S_, T(T({}, um), {
				delete: function(u) {
					return new S_(u, { addons: [] }).delete();
				},
				exists: function(u) {
					return new S_(u, { addons: [] }).open().then(function(u) {
						return u.close(), !0;
					}).catch("NoSuchDatabaseError", function() {
						return !1;
					});
				},
				getDatabaseNames: function(u) {
					try {
						return T = S_.dependencies, E = T.indexedDB, T = T.IDBKeyRange, (Mg(E) ? Promise.resolve(E.databases()).then(function(u) {
							return u.map(function(u) {
								return u.name;
							}).filter(function(u) {
								return u !== _h;
							});
						}) : jg(E, T).toCollection().primaryKeys()).then(u);
					} catch {
						return fh(new cm.MissingAPI());
					}
					var T, E;
				},
				defineClass: function() {
					return function(u) {
						F(this, u);
					};
				},
				ignoreTransaction: function(u) {
					return Nm.trans ? lh(Nm.transless, u) : u();
				},
				vip: Ng,
				async: function(u) {
					return function() {
						try {
							var T = Zg(u.apply(this, arguments));
							return T && typeof T.then == "function" ? T : Lm.resolve(T);
						} catch (u) {
							return fh(u);
						}
					};
				},
				spawn: function(u, T, E) {
					try {
						var O = Zg(u.apply(E, T || []));
						return O && typeof O.then == "function" ? O : Lm.resolve(O);
					} catch (u) {
						return fh(u);
					}
				},
				currentTransaction: { get: function() {
					return Nm.trans || null;
				} },
				waitFor: function(u, T) {
					return T = Lm.resolve(typeof u == "function" ? S_.ignoreTransaction(u) : u).timeout(T || 6e4), Nm.trans ? Nm.trans.waitFor(T) : T;
				},
				Promise: Lm,
				debug: {
					get: function() {
						return bm;
					},
					set: function(u) {
						xm(u);
					}
				},
				derive: kp,
				extend: F,
				props: U,
				override: Np,
				Events: Ah,
				on: rg,
				liveQuery: x_,
				extendObservabilitySet: Hg,
				getByKeyPath: Ip,
				setByKeyPath: Lp,
				delByKeyPath: function(u, T) {
					typeof T == "string" ? Lp(u, T, void 0) : "length" in T && [].map.call(T, function(T) {
						Lp(u, T, void 0);
					});
				},
				shallowClone: Rp,
				deepClone: Wp,
				getObjectDiff: e_,
				cmp: wh,
				asap: Fp,
				minKey: -Infinity,
				addons: [],
				connections: gh,
				errnames: om,
				dependencies: v_,
				cache: Wg,
				semVer: "4.2.0",
				version: "4.2.0".split(".").map(function(u) {
					return parseInt(u);
				}).reduce(function(u, T, E) {
					return u + T / 10 ** (2 * E);
				})
			})), S_.maxKey = lg(S_.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (rg(tg, function(u) {
				T_ ||= (u = new CustomEvent(ng, { detail: u }), T_ = !0, dispatchEvent(u), !1);
			}), addEventListener(ng, function(u) {
				u = u.detail, T_ || C_(u);
			}));
			var w_, T_ = !1, E_ = function() {};
			return typeof BroadcastChannel < "u" && ((E_ = function() {
				(w_ = new BroadcastChannel(ng)).onmessage = function(u) {
					return u.data && C_(u.data);
				};
			})(), typeof w_.unref == "function" && w_.unref(), rg(tg, function(u) {
				T_ || w_.postMessage(u);
			})), typeof addEventListener < "u" && (addEventListener("pagehide", function(u) {
				if (!g_.disableBfCache && u.persisted) {
					bm && console.debug("Dexie: handling persisted pagehide"), w_?.close();
					for (var T = 0, E = gh; T < E.length; T++) E[T].close({ disableAutoOpen: !1 });
				}
			}), addEventListener("pageshow", function(u) {
				!g_.disableBfCache && u.persisted && (bm && console.debug("Dexie: handling persisted pageshow"), E_(), C_({ all: new Fg(-Infinity, [[]]) }));
			})), Lm.rejectionMapper = function(u, T) {
				return !u || u instanceof nm || u instanceof TypeError || u instanceof SyntaxError || !u.name || !lm[u.name] ? u : (T = new lm[u.name](T || u.message, u), "stack" in u && Op(T, "stack", { get: function() {
					return this.inner.stack;
				} }), T);
			}, xm(bm), T(g_, Object.freeze({
				__proto__: null,
				Dexie: g_,
				liveQuery: x_,
				Entity: Ch,
				cmp: wh,
				PropModification: zh,
				replacePrefix: function(u, T) {
					return new zh({ replacePrefix: [u, T] });
				},
				add: function(u) {
					return new zh({ add: u });
				},
				remove: function(u) {
					return new zh({ remove: u });
				},
				default: g_,
				RangeSet: Fg,
				mergeRanges: Lg,
				rangesOverlap: Rg
			}), { default: g_ }), g_;
		});
	}(_l)), _l.exports;
}
var Pe$1 = /* @__PURE__ */ au(su()), Lt = Symbol.for("Dexie"), Bl = globalThis[Lt] || (globalThis[Lt] = Pe$1);
if (Pe$1.semVer !== Bl.semVer) throw Error(`Two different versions of Dexie loaded in the same app: ${Pe$1.semVer} and ${Bl.semVer}`);
var { liveQuery: Lu, mergeRanges: Iu, rangesOverlap: Du, RangeSet: Ou, cmp: Su, Entity: wu, PropModification: qu, replacePrefix: yu, add: bu, remove: Cu, DexieYProvider: Pu } = Bl, ou = "sclElements", mu = "id, tagName, [id+tagName], &attributes.uuid, &attributes.id, attributes.name, parent.id, parent.tagName, *children.id, *children.tagName";
function Tu(u) {
	let { databaseName: T } = u, E = new Bl(T);
	return E.version(1).stores({ [`${ou}`]: mu }), E;
}
var pu = {
	FunctionCategory: {
		tag: "FunctionCategory",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Category of functions. To be added to Process, Line, Substation, VoltageLevel and Bay SCL elements\n\nCategory of functions. To be added to Process, Line, Substation, VoltageLevel and Bay SCL elements",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"SubCategory",
				"FunctionCatRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SubCategory: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				FunctionCatRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ProcessResources: {
		tag: "ProcessResources",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "List of Process Resources related to a function. to be added to the SCL elements Function, SubFunction, EqFunction and EqSubFunction\n\nList of Process Resources related to a function. to be added to the SCL elements Function, SubFunction, EqFunction and EqSubFunction",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: ["Text", "ProcessResource"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ProcessResource: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueResource",
						kind: "unique",
						paths: [["Resource"]],
						deep: !1,
						attributes: ["resInst"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniquePR",
			kind: "unique",
			paths: [["ProcessResource"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	PowerSystemRelations: {
		tag: "PowerSystemRelations",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Functional relation from a Function/SubFunction to another element of the process\n\nFunctional relation from a Function/SubFunction to another element of the process",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: ["Text", "PowerSystemRelation"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				PowerSystemRelation: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniquePSR",
			kind: "unique",
			paths: [["PowerSystemRelation"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNodeInputs: {
		tag: "LNodeInputs",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "List of specification inputs of the given LNode. To be added at LNode level\n\nList of specification inputs of the given LNode. To be added at LNode level",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: ["Text", "SourceRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SourceRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueSourceRef",
			kind: "unique",
			paths: [["SourceRef"]],
			deep: !1,
			attributes: [
				"input",
				"inputInst",
				"pDA"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNodeOutputs: {
		tag: "LNodeOutputs",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "List of specification outputs of the given LNode. To be added at LNode level\n\nList of specification outputs of the given LNode. To be added at LNode level",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: ["Text", "ControlRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ControlRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueControlRef",
			kind: "unique",
			paths: [["ControlRef"]],
			deep: !1,
			attributes: ["output", "outputInst"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ProcessEcho: {
		tag: "ProcessEcho",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Definition of an echo LNode, mirroring the DO of another LNode\n\nDefinition of an echo LNode, mirroring the DO of another LNode",
		parents: [
			"DAS",
			"DOS",
			"SDS"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"source",
				"sourceDaName",
				"sourceDoName",
				"sourceLNodeUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				source: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceDaName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceDoName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceLNodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNodeSpecNaming: {
		tag: "LNodeSpecNaming",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "LNode user specification. To be added to LNode SCL element\n\nLNode user specification. To be added to LNode SCL element",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"sIedName",
				"sLdInst",
				"sLnClass",
				"sLnInst",
				"sPrefix"
			],
			details: {
				sIedName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"None",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sLdInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sLnClass: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sLnInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sPrefix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DOS: {
		tag: "DOS",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Data Object specification. To be added to LNode SCL element\n\nData Object specification. To be added to LNode SCL element",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"mappedDoName",
				"mappedLnUuid",
				"name"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				mappedDoName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				mappedLnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 12,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"SDS",
				"DAS",
				"SubscriberLNode",
				"ControllingLNode",
				"ProcessEcho",
				"LogParametersRef",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SDS: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueSDS_DASinSDS",
						kind: "unique",
						paths: [["DAS|.", "SDS"]],
						deep: !1,
						attributes: ["name", "ix"],
						refer: null,
						text: !1
					}]
				},
				DAS: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SubscriberLNode: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ControllingLNode: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ProcessEcho: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				LogParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInDOS",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: [
					"SDS",
					"DAS",
					"SubscriberLNode",
					"ControllingLNode",
					"ProcessEcho",
					"LogParametersRef"
				]
			}]
		},
		constraints: [{
			name: "uniqueSDS_DASinDOS",
			kind: "unique",
			paths: [["DAS|.", "SDS"]],
			deep: !1,
			attributes: ["name", "ix"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionSclRef: {
		tag: "FunctionSclRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to the FSD files used to create a Function. Could be added under Function/SubFunction/EqFunction/EqSubFunction\n\nReference to the FSD files used to create a Function. Could be added under Function/SubFunction/EqFunction/EqSubFunction",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "SclFileReference"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SclFileReference: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	CheckoutID: {
		tag: "CheckoutID",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Element used by an IED to indicates that a file has been imported to give engineering rights on this IED. This is opening a transaction between both projects to lock it on first project until the checkout is given back from current project, which then lock the IED locally\n\nElement used by an IED to indicates that a file has been imported to give engineering rights on this IED. This is opening a transaction between both projects to lock it on first project until the checkout is given back from current project, which then lock the IED locally",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"engRight",
				"fileName",
				"fileType",
				"fileUuid",
				"headerId",
				"revision",
				"version",
				"when"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				engRight: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"full",
							"fix",
							"dataflow"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"SED",
							"SCC",
							"ICD",
							"IID",
							"CID",
							"SSD",
							"SCD"
						],
						pattern: ["\\i\\c*", "[A-Z]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				headerId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				revision: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				version: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				when: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["SubCheckoutID"],
			details: { SubCheckoutID: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tSclFileUUIDCheckoutRestriction",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Variable: {
		tag: "Variable",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "A Variable is a way to define a global variable which can be modified by a user and applied to a list of SCL attributes\n\nA Variable is a way to define a global variable which can be modified by a user and applied to a list of SCL attributes",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"uuid",
				"value"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				value: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "VariableApplyTo"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				VariableApplyTo: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	CommunicationServiceSpecifications: {
		tag: "CommunicationServiceSpecifications",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "The CommunicationServiceSpecifications is containing parameters used to create control blocks during implementation\n\nThe CommunicationServiceSpecifications is containing parameters used to create control blocks during implementation",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"GooseParameters",
				"SMVParameters",
				"ReportParameters"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GooseParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SMVParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ReportParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: [
					"GooseParameters",
					"SMVParameters",
					"ReportParameters"
				]
			}]
		},
		constraints: [{
			name: "commServiceSpecKey",
			kind: "key",
			paths: [["*"]],
			deep: !1,
			attributes: ["id"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ServiceSpecifications: {
		tag: "ServiceSpecifications",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "The ServiceSpecification is containing parameters used to create control blocks or physical interface (LPDI/LPDO) during implementation\n\nThe ServiceSpecification is containing parameters used to create control blocks or physical interface (LPDI/LPDO) during implementation",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"GooseParameters",
				"SMVParameters",
				"ReportParameters",
				"BinaryWiringParameters",
				"AnalogueWiringParameters",
				"LogParameters"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GooseParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SMVParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ReportParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				BinaryWiringParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				AnalogueWiringParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				LogParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: [
					"GooseParameters",
					"SMVParameters",
					"ReportParameters",
					"BinaryWiringParameters",
					"AnalogueWiringParameters",
					"LogParameters"
				]
			}]
		},
		constraints: [{
			name: "serviceSpecKey",
			kind: "key",
			paths: [["*"]],
			deep: !1,
			attributes: ["id"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BayType: {
		tag: "BayType",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Bay type element is keeping value of the type. It's a free string\n\nBay type element is keeping value of the type. It's a free string",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBayType",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	AllocationRole: {
		tag: "AllocationRole",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Definition of an allocation role allowing definition of possible allocation to devices type without using virtual IED\n\nDefinition of an allocation role allowing definition of possible allocation to devices type without using virtual IED",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Application: {
		tag: "Application",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Application definition to be added at Process, Substation, Voltage Level or Bay level\n\nApplication definition to be added at Process, Substation, Voltage Level or Bay level",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionRole",
				"FunctionalVariant",
				"FunctionalVariantGroup",
				"AllocationRoleRef",
				"ApplicationSclRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionRole: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueRoleContent",
						kind: "unique",
						paths: [["FunctionRoleContent"]],
						deep: !1,
						attributes: ["roleInst"],
						refer: null,
						text: !1
					}]
				},
				FunctionalVariant: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				FunctionalVariantGroup: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				AllocationRoleRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				ApplicationSclRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BehaviorDescription: {
		tag: "BehaviorDescription",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Element allowing to describe the behavior its parent (Application, Bay, Function, LN...)\n\nElement allowing to describe the behavior its parent (Application, Bay, Function, LN...)",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"fileReference",
				"format",
				"isSimulation",
				"isSpecification",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileReference: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				format: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"IEC 61131",
							"Textual",
							"Graphic"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				isSimulation: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				isSpecification: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"InputVar",
				"OutputVar",
				"BehaviorReference"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				InputVar: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				OutputVar: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				BehaviorReference: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueChildNameInBehaviorDescription",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["varName"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Project: {
		tag: "Project",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Element allowing to define a project, to identify the project and the process elements defined by this project\n\nElement allowing to define a project, to identify the project and the process elements defined by this project",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "ProjectProcessReference"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ProjectProcessReference: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionTemplate: {
		tag: "FunctionTemplate",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Base element for FSD format, will be used as a template element for Function/SubFunction or EqFunction/EqSubFunction\n\nBase element for FSD format, will be used as a template element for Function/SubFunction or EqFunction/EqSubFunction",
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"LNode",
				"SubFunctionTemplate",
				"GeneralEquipment",
				"ConductingEquipment"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SubFunctionTemplate: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubFunctionTemplate",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInSubFuncTemplate",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipmentOfFunctionTemplate",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGEFuncTemplate",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				ConductingEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInConductingEquipmentOfFunctionTemplate",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInCondEqTemplate",
						kind: "unique",
						paths: [["SubEquipment|.", "EqFunction"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "t6-100LNodeContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SCL: {
		tag: "SCL",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"release",
				"revision",
				"version"
			],
			details: {
				release: {
					required: !0,
					default: "5",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 255,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				revision: {
					required: !0,
					default: "C",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z]", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				version: {
					required: !0,
					default: "2007",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["2[0-2][0-9]{2}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Header",
				"Substation",
				"Communication",
				"IED",
				"DataTypeTemplates",
				"Line",
				"Process"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Header: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueHitem",
						kind: "unique",
						paths: [["History", "Hitem"]],
						deep: !1,
						attributes: ["version", "revision"],
						refer: null,
						text: !1
					}]
				},
				Substation: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Communication: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				IED: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				DataTypeTemplates: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Line: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Process: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [
			{
				name: "SubstationKey",
				kind: "key",
				paths: [[
					"Substation|.",
					"Process|.",
					"Line"
				]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "IEDKey",
				kind: "key",
				paths: [["IED"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "LNodeTypeKey",
				kind: "key",
				paths: [["DataTypeTemplates", "LNodeType"]],
				deep: !1,
				attributes: ["id", "lnClass"],
				refer: null,
				text: !1
			},
			{
				name: "ConnectivityNodeKey",
				kind: "key",
				paths: [["ConnectivityNode"]],
				deep: !0,
				attributes: ["pathName"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueHitem",
				kind: "unique",
				paths: [["History", "Hitem"]],
				deep: !1,
				attributes: ["version", "revision"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueUUID",
				kind: "unique",
				paths: [["*"]],
				deep: !0,
				attributes: ["uuid"],
				refer: null,
				text: !1
			},
			{
				name: "ref2LNodeTypeDomain1",
				kind: "keyref",
				paths: [[
					"IED",
					"AccessPoint",
					"LN"
				]],
				deep: !1,
				attributes: ["lnType", "lnClass"],
				refer: "LNodeTypeKey",
				text: !1
			},
			{
				name: "ref2LNodeTypeDomain2",
				kind: "keyref",
				paths: [[
					"IED",
					"AccessPoint",
					"Server",
					"LDevice",
					"LN"
				]],
				deep: !1,
				attributes: ["lnType", "lnClass"],
				refer: "LNodeTypeKey",
				text: !1
			},
			{
				name: "ref2LNodeTypeLLN0",
				kind: "keyref",
				paths: [[
					"IED",
					"AccessPoint",
					"Server",
					"LDevice",
					"LN0"
				]],
				deep: !1,
				attributes: ["lnType", "lnClass"],
				refer: "LNodeTypeKey",
				text: !1
			},
			{
				name: "refConnectedAP2IED",
				kind: "keyref",
				paths: [[
					"Communication",
					"SubNetwork",
					"ConnectedAP"
				]],
				deep: !1,
				attributes: ["iedName"],
				refer: "IEDKey",
				text: !1
			},
			{
				name: "ref2SubstationFromTerminal",
				kind: "keyref",
				paths: [["Terminal"]],
				deep: !0,
				attributes: ["substationName"],
				refer: "scl:SubstationKey",
				text: !1
			}
		],
		value: {
			type: "tBaseElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Substation: {
		tag: "Substation",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Process", "SCL"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"PowerTransformer",
				"GeneralEquipment",
				"VoltageLevel",
				"Function"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				PowerTransformer: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInPowerTransformer",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInPTR",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGE",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				VoltageLevel: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueChildNameInVoltageLevel",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}, {
						name: "uniqueLNodeInVoltageLevel",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}]
				},
				Function: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFunctionSS",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInSubstationFunc",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueChildNameInSubstation",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}, {
			name: "uniqueLNodeInSubstation",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tEquipmentContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Process: {
		tag: "Process",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Process", "SCL"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"GeneralEquipment",
				"Function",
				"ConductingEquipment",
				"Substation",
				"Line",
				"Process"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipment2",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGE2",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				Function: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFunction",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				ConductingEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Substation: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueChildNameInProcessSubstation",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}, {
						name: "uniqueLNodeInProcessSubstation",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}]
				},
				Line: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Process: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueChildNameInSubProcess",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}, {
						name: "uniqueLNodeInSubProcess",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueChildNameInProcess",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}, {
			name: "uniqueLNodeInProcess",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tGeneralEquipmentContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Line: {
		tag: "Line",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Process", "SCL"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"nomFreq",
				"numPhases",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				nomFreq: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: "0",
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				numPhases: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 255,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"GeneralEquipment",
				"Function",
				"Voltage",
				"ConductingEquipment",
				"ConnectivityNode"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipment2",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGE2",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				Function: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFunction",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				Voltage: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConductingEquipment: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				},
				ConnectivityNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueChildNameInLine",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}, {
			name: "uniqueLNodeInLine",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tGeneralEquipmentContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LN0: {
		tag: "LN0",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LDevice"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"inst",
				"lnClass",
				"lnType",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inst: {
					required: !0,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !0,
					default: "LLN0",
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"DataSet",
				"ReportControl",
				"LogControl",
				"DOI",
				"Inputs",
				"Outputs",
				"Log",
				"Labels",
				"GSEControl",
				"SampledValueControl",
				"SettingControl"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				DataSet: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				ReportControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				LogControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				DOI: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueSDI_DAIinDOI",
						kind: "unique",
						paths: [["DAI|.", "SDI"]],
						deep: !1,
						attributes: ["name", "ix"],
						refer: null,
						text: !1
					}]
				},
				Inputs: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Outputs: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Log: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInLN",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				GSEControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SampledValueControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SettingControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [
			{
				name: "DataSetKeyLN0",
				kind: "key",
				paths: [["DataSet"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueReportControlInLN0",
				kind: "unique",
				paths: [["ReportControl"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueLogControlInLN0",
				kind: "unique",
				paths: [["LogControl"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueGSEControlInLN0",
				kind: "unique",
				paths: [["GSEControl"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueSampledValueControlInLN0",
				kind: "unique",
				paths: [["SampledValueControl"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueDOIinLN0",
				kind: "unique",
				paths: [["DOI"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueLogInLN0",
				kind: "unique",
				paths: [["Log"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "ref2DataSetReportLN0",
				kind: "keyref",
				paths: [["ReportControl"]],
				deep: !1,
				attributes: ["datSet"],
				refer: "DataSetKeyLN0",
				text: !1
			},
			{
				name: "ref2DataSetLogLN0",
				kind: "keyref",
				paths: [["LogControl"]],
				deep: !1,
				attributes: ["datSet"],
				refer: "DataSetKeyLN0",
				text: !1
			},
			{
				name: "ref2DataSetGSELN0",
				kind: "keyref",
				paths: [["GSEControl"]],
				deep: !1,
				attributes: ["datSet"],
				refer: "DataSetKeyLN0",
				text: !1
			},
			{
				name: "ref2DataSetSVLN0",
				kind: "keyref",
				paths: [["SampledValueControl"]],
				deep: !1,
				attributes: ["datSet"],
				refer: "DataSetKeyLN0",
				text: !1
			}
		],
		value: {
			type: "tLN0",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LN: {
		tag: "LN",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["AccessPoint", "LDevice"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"inst",
				"lnClass",
				"lnType",
				"prefix",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"DataSet",
				"ReportControl",
				"LogControl",
				"DOI",
				"Inputs",
				"Outputs",
				"Log",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				DataSet: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				ReportControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				LogControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				DOI: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueSDI_DAIinDOI",
						kind: "unique",
						paths: [["DAI|.", "SDI"]],
						deep: !1,
						attributes: ["name", "ix"],
						refer: null,
						text: !1
					}]
				},
				Inputs: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Outputs: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Log: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInLN",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [
			{
				name: "DataSetKeyInLN",
				kind: "key",
				paths: [["DataSet"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueReportControlInLN",
				kind: "unique",
				paths: [["ReportControl"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueLogControlInLN",
				kind: "unique",
				paths: [["LogControl"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueDOIinLN",
				kind: "unique",
				paths: [["DOI"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueLogInLN",
				kind: "unique",
				paths: [["Log"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "ref2DataSetReport",
				kind: "keyref",
				paths: [["ReportControl"]],
				deep: !1,
				attributes: ["datSet"],
				refer: "DataSetKeyInLN",
				text: !1
			},
			{
				name: "ref2DataSetLog",
				kind: "keyref",
				paths: [["LogControl"]],
				deep: !1,
				attributes: ["datSet"],
				refer: "DataSetKeyInLN",
				text: !1
			}
		],
		value: {
			type: "tAnyLN",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	IED: {
		tag: "IED",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SCL"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"configVersion",
				"desc",
				"engRight",
				"manufacturer",
				"name",
				"originalSclRelease",
				"originalSclRevision",
				"originalSclVersion",
				"owner",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				configVersion: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				engRight: {
					required: !1,
					default: "full",
					namespace: null,
					validation: {
						enumeration: [
							"full",
							"fix",
							"dataflow"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				manufacturer: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originalSclRelease: {
					required: !1,
					default: "1",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 255,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originalSclRevision: {
					required: !1,
					default: "A",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z]", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originalSclVersion: {
					required: !1,
					default: "2003",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["2[0-2][0-9]{2}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				owner: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Services",
				"AccessPoint",
				"KDC",
				"IEDSourceFiles",
				"MinRequestedSCDFiles",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Services: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				AccessPoint: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNInAccessPoint",
						kind: "unique",
						paths: [["LN"]],
						deep: !1,
						attributes: [
							"inst",
							"lnClass",
							"prefix"
						],
						refer: null,
						text: !1
					}]
				},
				KDC: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				IEDSourceFiles: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				MinRequestedSCDFiles: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueProjectInReqSCD",
						kind: "unique",
						paths: [["MinRequestedSCDFile"]],
						deep: !1,
						attributes: ["fileUuid"],
						refer: null,
						text: !1
					}]
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInIED",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [
			{
				name: "LDeviceInIEDKey",
				kind: "key",
				paths: [[
					"AccessPoint",
					"Server",
					"LDevice"
				]],
				deep: !1,
				attributes: ["inst"],
				refer: null,
				text: !1
			},
			{
				name: "AccessPointInIEDKey",
				kind: "key",
				paths: [["AccessPoint"]],
				deep: !1,
				attributes: ["name"],
				refer: null,
				text: !1
			},
			{
				name: "ref2LDeviceInDataSetForFCDAinLN",
				kind: "keyref",
				paths: [[
					"AccessPoint",
					"Server",
					"LDevice",
					"LN",
					"DataSet",
					"FCDA"
				]],
				deep: !1,
				attributes: ["ldInst"],
				refer: "LDeviceInIEDKey",
				text: !1
			},
			{
				name: "ref2LDeviceInDataSetForFCDAinLN0",
				kind: "keyref",
				paths: [[
					"AccessPoint",
					"Server",
					"LDevice",
					"LN0",
					"DataSet",
					"FCDA"
				]],
				deep: !1,
				attributes: ["ldInst"],
				refer: "LDeviceInIEDKey",
				text: !1
			},
			{
				name: "ServerAtRef2AccessPoint",
				kind: "keyref",
				paths: [["AccessPoint", "ServerAt"]],
				deep: !1,
				attributes: ["apName"],
				refer: "AccessPointInIEDKey",
				text: !1
			}
		],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Communication: {
		tag: "Communication",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SCL"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"SubNetwork"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SubNetwork: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueConnectedAP",
						kind: "unique",
						paths: [["ConnectedAP"]],
						deep: !1,
						attributes: ["iedName", "apName"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueSubNetwork",
			kind: "unique",
			paths: [["SubNetwork"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DataTypeTemplates: {
		tag: "DataTypeTemplates",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SCL"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [
				"LNodeType",
				"DOType",
				"DAType",
				"EnumType"
			],
			details: {
				LNodeType: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueDOInLNodeType",
						kind: "unique",
						paths: [["DO"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				DOType: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueDAorSDOInDOType",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				DAType: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueBDAInDAType",
						kind: "unique",
						paths: [["BDA"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}, {
						name: "uniqueProtNs",
						kind: "unique",
						paths: [["ProtNs"]],
						deep: !1,
						attributes: ["type"],
						refer: null,
						text: !1
					}]
				},
				EnumType: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueOrdInEnumType",
						kind: "unique",
						paths: [["EnumVal"]],
						deep: !1,
						attributes: ["ord"],
						refer: null,
						text: !1
					}, {
						name: "uniqueEnumValue",
						kind: "unique",
						paths: [["EnumVal"]],
						deep: !1,
						attributes: [],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [
			{
				name: "DOTypeKey",
				kind: "key",
				paths: [["DOType"]],
				deep: !1,
				attributes: ["id"],
				refer: null,
				text: !1
			},
			{
				name: "EnumTypeDATypeKey",
				kind: "key",
				paths: [["DAType | scl:EnumType"]],
				deep: !1,
				attributes: ["id"],
				refer: null,
				text: !1
			},
			{
				name: "uniqueDTT_ID",
				kind: "unique",
				paths: [["*"]],
				deep: !1,
				attributes: ["id"],
				refer: null,
				text: !1
			},
			{
				name: "ref2DOType",
				kind: "keyref",
				paths: [["LNodeType", "DO"]],
				deep: !1,
				attributes: ["type"],
				refer: "DOTypeKey",
				text: !1
			},
			{
				name: "ref2DOTypeForSDO",
				kind: "keyref",
				paths: [["DOType", "SDO"]],
				deep: !1,
				attributes: ["type"],
				refer: "DOTypeKey",
				text: !1
			},
			{
				name: "ref2EnumTypeDAType",
				kind: "keyref",
				paths: [[
					"DOType",
					"DA | scl:DAType",
					"BDA"
				]],
				deep: !1,
				attributes: ["type"],
				refer: "scl:EnumTypeDATypeKey",
				text: !1
			}
		],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Text: {
		tag: "Text",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: /* @__PURE__ */ "AccessPoint.AllocationRole.AllocationRoleRef.AnalogueWiringParameters.AnalogueWiringParametersRef.Application.ApplicationSclRef.BDA.Bay.BehaviorDescription.BehaviorDescriptionRef.BehaviorReference.BinaryWiringParameters.BinaryWiringParametersRef.Communication.CommunicationServiceSpecifications.ConductingEquipment.ConnectedAP.ConnectivityNode.ControlRef.ControllingLNode.DA.DAI.DAS.DAType.DO.DOI.DOS.DOType.DataSet.EnumType.EqFunction.EqSubFunction.ExtCtrl.ExtRef.Function.FunctionCatRef.FunctionCategory.FunctionCategoryRef.FunctionRef.FunctionRole.FunctionRoleContent.FunctionSclRef.FunctionTemplate.FunctionalSubVariant.FunctionalVariant.FunctionalVariantGroup.FunctionalVariantRef.GOOSESecurity.GSE.GSEControl.GeneralEquipment.GooseParameters.GooseParametersRef.Header.IED.IEDSourceFiles.InputVar.InputVarRef.Inputs.L2CommParameters.L3IPv4CommParameters.L3IPv6CommParameters.LDevice.LN.LN0.LNode.LNodeDataRef.LNodeInputRef.LNodeInputs.LNodeOutputRef.LNodeOutputs.LNodeSpecNaming.LNodeType.Labels.Line.Log.LogControl.LogParameters.LogParametersRef.MinRequestedSCDFiles.NeutralPoint.OutputVar.OutputVarRef.Outputs.PhysConn.PowerSystemRelation.PowerSystemRelationRef.PowerSystemRelations.PowerTransformer.Process.ProcessEcho.ProcessResource.ProcessResourceRef.ProcessResources.Project.ProjectProcessReference.ReportControl.ReportParameters.ReportParametersRef.RptEnabled.SCL.SDI.SDO.SDS.SMV.SMVParameters.SMVParametersRef.SMVSecurity.SampledValueControl.SclFileReference.Server.ServerAt.ServiceSpecifications.SettingControl.SignalRole.SourceFiles.SourceRef.SubCategory.SubEquipment.SubFunction.SubFunctionTemplate.SubNetwork.SubscriberLNode.Substation.TapChanger.Terminal.TransformerWinding.Variable.VariableApplyTo.VariableRef.VoltageLevel".split("."),
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["source"],
			details: { source: {
				required: !1,
				default: null,
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tAnyContentFromOtherNamespace",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SubCategory: {
		tag: "SubCategory",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Recursive definition of function category\n\nRecursive definition of function category",
		parents: ["FunctionCategory", "SubCategory"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"SubCategory",
				"FunctionCatRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SubCategory: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				FunctionCatRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionCatRef: {
		tag: "FunctionCatRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a function which is part of the current category\n\nReference to a function which is part of the current category",
		parents: ["FunctionCategory", "SubCategory"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["function", "functionUuid"],
			details: {
				function: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				functionUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ProcessResource: {
		tag: "ProcessResource",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["ProcessResources"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"cardinality",
				"desc",
				"max",
				"name",
				"originUuid",
				"selector",
				"templateUuid",
				"uuid"
			],
			details: {
				cardinality: {
					required: !1,
					default: "1..1",
					namespace: null,
					validation: {
						enumeration: [
							"0..1",
							"1..1",
							"0..n",
							"1..n"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				max: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 2,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				selector: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Resource"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Resource: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueResource",
			kind: "unique",
			paths: [["Resource"]],
			deep: !1,
			attributes: ["resInst"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	PowerSystemRelation: {
		tag: "PowerSystemRelation",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["PowerSystemRelations"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"relation",
				"relationUuid",
				"selector",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				relation: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				relationUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				selector: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SourceRef: {
		tag: "SourceRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a data in the process\n\nReference to a data in the process",
		parents: ["LNodeInputs"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"extRefAddr",
				"extRefUuid",
				"input",
				"inputInst",
				"originUuid",
				"pDA",
				"pDO",
				"pLN",
				"resourceName",
				"resourceUuid",
				"service",
				"source",
				"sourceDaName",
				"sourceDoName",
				"sourceLNodeUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				extRefAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				extRefUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				input: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inputInst: {
					required: !1,
					default: "1",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 1,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pDA: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pDO: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pLN: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				service: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"Poll",
							"Report",
							"GOOSE",
							"SMV",
							"Wired",
							"Internal"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				source: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceDaName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceDoName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceLNodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"GooseParametersRef",
				"SMVParametersRef",
				"ReportParametersRef",
				"BinaryWiringParametersRef",
				"AnalogueWiringParametersRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GooseParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SMVParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ReportParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				BinaryWiringParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				AnalogueWiringParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: 1,
				options: [
					"GooseParametersRef",
					"SMVParametersRef",
					"ReportParametersRef",
					"BinaryWiringParametersRef",
					"AnalogueWiringParametersRef"
				]
			}]
		},
		constraints: [],
		value: {
			type: "tLinkFCDARef",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ControlRef: {
		tag: "ControlRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a control data in the process\n\nReference to a control data in the process",
		parents: ["LNodeOutputs"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"controlled",
				"controlledDoName",
				"controlledLNodeUuid",
				"desc",
				"extCtrlAddr",
				"extCtrlUuid",
				"originUuid",
				"output",
				"outputInst",
				"pDO",
				"pLN",
				"resourceName",
				"resourceUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				controlled: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				controlledDoName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				controlledLNodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				extCtrlAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				extCtrlUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				output: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outputInst: {
					required: !1,
					default: "1",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 1,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pDO: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pLN: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"BinaryWiringParametersRef",
				"AnalogueWiringParametersRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				BinaryWiringParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				AnalogueWiringParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: 1,
				options: ["BinaryWiringParametersRef", "AnalogueWiringParametersRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tLinkFCDRef",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SDS: {
		tag: "SDS",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of a sub-Data Object\n\nSpecification of a sub-Data Object",
		parents: ["DOS", "SDS"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"ix",
				"mappedDoName",
				"mappedLnUuid",
				"name"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				mappedDoName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				mappedLnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"SDS",
				"DAS",
				"SubscriberLNode",
				"ControllingLNode",
				"ProcessEcho",
				"LogParametersRef",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SDS: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				DAS: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SubscriberLNode: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ControllingLNode: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ProcessEcho: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				LogParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInSDS",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: [
					"SDS",
					"DAS",
					"SubscriberLNode",
					"ControllingLNode",
					"ProcessEcho",
					"LogParametersRef"
				]
			}]
		},
		constraints: [{
			name: "uniqueSDS_DASinSDS",
			kind: "unique",
			paths: [["DAS|.", "SDS"]],
			deep: !1,
			attributes: ["name", "ix"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DAS: {
		tag: "DAS",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of a Data attribute\n\nSpecification of a Data attribute",
		parents: ["DOS", "SDS"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"ix",
				"mappedDaName",
				"mappedLnUuid",
				"name",
				"valImport",
				"valKind"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				mappedDaName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)\\.([a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*)"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				mappedLnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valImport: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valKind: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"Spec",
							"Conf",
							"RO",
							"Set"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"SubscriberLNode",
				"ControllingLNode",
				"ProcessEcho",
				"LogParametersRef",
				"Val",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SubscriberLNode: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ControllingLNode: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ProcessEcho: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				LogParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Val: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInDAS",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: [
					"SubscriberLNode",
					"ControllingLNode",
					"ProcessEcho",
					"LogParametersRef",
					"Val",
					"Labels"
				]
			}]
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SubscriberLNode: {
		tag: "SubscriberLNode",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: [
			"DAS",
			"DOS",
			"SDS"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"inputName",
				"pLN",
				"resourceName",
				"resourceUuid",
				"service"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inputName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pLN: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				service: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"Poll",
							"Report",
							"GOOSE",
							"SMV",
							"Wired",
							"Internal"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"GooseParametersRef",
				"SMVParametersRef",
				"ReportParametersRef",
				"BinaryWiringParametersRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GooseParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SMVParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ReportParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				BinaryWiringParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: 1,
				options: [
					"GooseParametersRef",
					"SMVParametersRef",
					"ReportParametersRef",
					"BinaryWiringParametersRef"
				]
			}]
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ControllingLNode: {
		tag: "ControllingLNode",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: [
			"DAS",
			"DOS",
			"SDS"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"outputName",
				"pLN",
				"resourceName",
				"resourceUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outputName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pLN: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resourceUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"BinaryWiringParametersRef",
				"AnalogueWiringParametersRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				BinaryWiringParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				AnalogueWiringParametersRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: 1,
				options: ["BinaryWiringParametersRef", "AnalogueWiringParametersRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LogParametersRef: {
		tag: "LogParametersRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of the Log parameters expected for the current DOS when Log capability is required\n\nSpecification of the Log parameters expected for the current DOS when Log capability is required",
		parents: [
			"DAS",
			"DOS",
			"SDS"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc", "id"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Labels: {
		tag: "Labels",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: /* @__PURE__ */ "AccessPoint.BDA.Bay.ConductingEquipment.ConnectivityNode.DA.DAI.DAS.DAType.DO.DOI.DOS.DOType.EqFunction.EqSubFunction.Function.GOOSESecurity.GeneralEquipment.IED.LDevice.LN.LN0.LNode.LNodeType.Line.PowerTransformer.Process.SDI.SDO.SDS.SMVSecurity.SubEquipment.SubFunction.SubNetwork.Substation.TapChanger.TransformerWinding.VoltageLevel".split("."),
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Label"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Label: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLabel",
			kind: "unique",
			paths: [["Label"]],
			deep: !1,
			attributes: ["id", "lang"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SclFileReference: {
		tag: "SclFileReference",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"ApplicationSclRef",
			"FunctionSclRef",
			"IEDSourceFiles",
			"SourceFiles"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"fileName",
				"fileType",
				"fileUuid",
				"revision",
				"version",
				"when"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"ICD",
							"IID",
							"CID",
							"SSD",
							"SCD",
							"SED"
						],
						pattern: ["\\i\\c*", "[A-Z]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				revision: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				version: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				when: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SubCheckoutID: {
		tag: "SubCheckoutID",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "When an IED is checkedout for a collaborative work by an SCC, it may be required to give right to a subpart of the collaborative project. So a CheckoutID may have an additional SubCheckoutID giving IED to nother project\n\nWhen an IED is checkedout for a collaborative work by an SCC, it may be required to give right to a subpart of the collaborative project. So a CheckoutID may have an additional SubCheckoutID giving IED to nother project",
		parents: ["CheckoutID", "SubCheckoutID"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"engRight",
				"fileName",
				"fileType",
				"fileUuid",
				"headerId",
				"revision",
				"version",
				"when"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				engRight: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"full",
							"fix",
							"dataflow"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"SED",
							"SCC",
							"ICD",
							"IID",
							"CID",
							"SSD",
							"SCD"
						],
						pattern: ["\\i\\c*", "[A-Z]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				headerId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				revision: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				version: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				when: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["SubCheckoutID"],
			details: { SubCheckoutID: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tSclFileUUIDCheckoutRestriction",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	VariableApplyTo: {
		tag: "VariableApplyTo",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["Variable"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"attribute",
				"daName",
				"defaultValue",
				"desc",
				"doName",
				"element",
				"elementUuid",
				"format",
				"sGroup"
			],
			details: {
				attribute: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				daName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				defaultValue: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				doName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				element: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				elementUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				format: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sGroup: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GooseParameters: {
		tag: "GooseParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"cbName",
				"desc",
				"dsName",
				"goId",
				"id",
				"maxTime",
				"minTime",
				"securityEnabled"
			],
			details: {
				cbName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dsName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				goId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxTime: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				minTime: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				securityEnabled: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"L2CommParameters",
				"L3IPv4CommParameters",
				"L3IPv6CommParameters"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				L2CommParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				L3IPv4CommParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				L3IPv6CommParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: 1,
				options: [
					"L2CommParameters",
					"L3IPv4CommParameters",
					"L3IPv6CommParameters"
				]
			}]
		},
		constraints: [],
		value: {
			type: "tControlBlockParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SMVParameters: {
		tag: "SMVParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"cbName",
				"desc",
				"dsName",
				"id",
				"multicast",
				"nofASDU",
				"securityEnabled",
				"smpMod",
				"smpRate",
				"smvId"
			],
			details: {
				cbName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dsName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				multicast: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				nofASDU: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				securityEnabled: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				smpMod: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"SmpPerPeriod",
							"SmpPerSec",
							"SecPerSmp"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				smpRate: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				smvId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"L2CommParameters",
				"L3IPv4CommParameters",
				"L3IPv6CommParameters"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				L2CommParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				L3IPv4CommParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				L3IPv6CommParameters: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: 1,
				options: [
					"L2CommParameters",
					"L3IPv4CommParameters",
					"L3IPv6CommParameters"
				]
			}]
		},
		constraints: [],
		value: {
			type: "tControlBlockParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ReportParameters: {
		tag: "ReportParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"bufTime",
				"buffered",
				"cbName",
				"desc",
				"dsName",
				"id",
				"intgPd"
			],
			details: {
				bufTime: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				buffered: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cbName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dsName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intgPd: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlBlockParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BinaryWiringParameters: {
		tag: "BinaryWiringParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["ServiceSpecifications"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"debTm",
				"desc",
				"fastOutput",
				"id",
				"inpNam",
				"inpRef",
				"outNam",
				"outOffDl",
				"outOnDl",
				"outRef",
				"outTyp",
				"vInOff",
				"vInOn"
			],
			details: {
				debTm: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fastOutput: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inpNam: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inpRef: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outNam: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outOffDl: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outOnDl: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outRef: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outTyp: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"Normally open",
							"Normally closed",
							"Change over"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vInOff: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vInOn: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tWiringParameters",
			validation: {
				enumeration: [
					"Normally open",
					"Normally closed",
					"Change over"
				],
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	AnalogueWiringParameters: {
		tag: "AnalogueWiringParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["ServiceSpecifications"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"dsgInp",
				"fctInp",
				"id",
				"inpNam",
				"inpRef"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dsgInp: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fctInp: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inpNam: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inpRef: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tWiringParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LogParameters: {
		tag: "LogParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["ServiceSpecifications"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"cbName",
				"desc",
				"dsName",
				"id",
				"intgPd",
				"logEna",
				"logLdInst",
				"logLnClass",
				"logLnInst",
				"logName",
				"logPrefix",
				"reasonCode"
			],
			details: {
				cbName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dsName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intgPd: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logEna: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logLdInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logLnClass: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logLnInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logPrefix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				reasonCode: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlBlockParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionRef: {
		tag: "FunctionRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a function definition attached to current allocation role\n\nReference to a function definition attached to current allocation role",
		parents: ["AllocationRole", "FunctionRoleContent"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"function",
				"functionUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				function: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				functionUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionalVariantRef",
				"SignalRole"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SignalRole: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionRole: {
		tag: "FunctionRole",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Role attached to the application type\n\nRole attached to the application type",
		parents: ["Application"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"cardinality",
				"desc",
				"max",
				"name",
				"originUuid",
				"selector",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				cardinality: {
					required: !1,
					default: "1..1",
					namespace: null,
					validation: {
						enumeration: [
							"0..1",
							"1..1",
							"0..n",
							"1..n"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				max: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 2,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				selector: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionalVariantRef",
				"FunctionRoleContent"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				FunctionRoleContent: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}, {
				minOccurrence: 1,
				maxOccurrence: null,
				options: ["FunctionRoleContent"]
			}]
		},
		constraints: [{
			name: "uniqueRoleContent",
			kind: "unique",
			paths: [["FunctionRoleContent"]],
			deep: !1,
			attributes: ["roleInst"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionalVariant: {
		tag: "FunctionalVariant",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Variant attached to the application type\n\nVariant attached to the application type",
		parents: ["Application", "FunctionalVariantGroup"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"isBaseline",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				isBaseline: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionalSubVariant",
				"VariableRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalSubVariant: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				VariableRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalSubVariant", "VariableRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tAbstractFunctionalVariant",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionalVariantGroup: {
		tag: "FunctionalVariantGroup",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Group of variants attached to the application type\n\nGroup of variants attached to the application type",
		parents: ["Application"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariant"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariant: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	AllocationRoleRef: {
		tag: "AllocationRoleRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Allocation role attached to the application type\n\nAllocation role attached to the application type",
		parents: ["Application"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"allocationRole",
				"allocationRoleUuid",
				"desc"
			],
			details: {
				allocationRole: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				allocationRoleUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ApplicationSclRef: {
		tag: "ApplicationSclRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to the ASD files used to create an Application\n\nReference to the ASD files used to create an Application",
		parents: ["Application"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "SclFileReference"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SclFileReference: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	InputVar: {
		tag: "InputVar",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Input variable used in the behavior description\n\nInput variable used in the behavior description",
		parents: ["BehaviorDescription"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"daName",
				"dataName",
				"desc",
				"doName",
				"inputName",
				"inputUuid",
				"lnodeUuid",
				"value",
				"varName"
			],
			details: {
				daName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dataName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				doName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inputName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inputUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				value: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				varName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tLogicVarRef",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	OutputVar: {
		tag: "OutputVar",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Output variable used in the behavior description\n\nOutput variable used in the behavior description",
		parents: ["BehaviorDescription"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"daName",
				"dataName",
				"desc",
				"doName",
				"lnodeUuid",
				"outputName",
				"outputUuid",
				"value",
				"varName"
			],
			details: {
				daName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dataName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				doName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outputName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				outputUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				value: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				varName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tLogicVarRef",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BehaviorReference: {
		tag: "BehaviorReference",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a behavior description when for example a manufacturer wants to indicate its implementation of a user specification described by another behavior description\n\nReference to a behavior description when for example a manufacturer wants to indicate its implementation of a user specification described by another behavior description",
		parents: ["BehaviorDescription"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"behaviorReference",
				"behaviorUuid",
				"desc"
			],
			details: {
				behaviorReference: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				behaviorUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ProjectProcessReference: {
		tag: "ProjectProcessReference",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to the process elements belonging to the current project\n\nReference to the process elements belonging to the current project",
		parents: ["Project"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"processReference",
				"processUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				processReference: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				processUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNode: {
		tag: "LNode",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"Bay",
			"ConductingEquipment",
			"ConnectivityNode",
			"EqFunction",
			"EqSubFunction",
			"Function",
			"FunctionTemplate",
			"GeneralEquipment",
			"Line",
			"PowerTransformer",
			"Process",
			"SubEquipment",
			"SubFunction",
			"SubFunctionTemplate",
			"Substation",
			"TapChanger",
			"TransformerWinding",
			"VoltageLevel"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"iedName",
				"ldInst",
				"lnClass",
				"lnInst",
				"lnType",
				"lnUuid",
				"prefix",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedName: {
					required: !1,
					default: "None",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"None",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 0,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnType: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInLNode",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SubFunctionTemplate: {
		tag: "SubFunctionTemplate",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["FunctionTemplate", "SubFunctionTemplate"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"LNode",
				"GeneralEquipment",
				"ConductingEquipment",
				"SubFunctionTemplate"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipmentOfSubFunctionTemplate",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGESubFuncTemplate",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				ConductingEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInConductingEquipmentOfSubFunctionTemplate",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueSubEquipmentSubFuncTemplate",
						kind: "unique",
						paths: [["SubEquipment"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				SubFunctionTemplate: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubSubFunctionTemplate",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueSubSubFuncTemplate",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInSubFunctionTemplate",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInSubFuncTemplate",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "t6-100LNodeContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GeneralEquipment: {
		tag: "GeneralEquipment",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"Bay",
			"EqFunction",
			"EqSubFunction",
			"Function",
			"FunctionTemplate",
			"Line",
			"Process",
			"SubFunction",
			"SubFunctionTemplate",
			"Substation",
			"VoltageLevel"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid",
				"virtual"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"AXN",
							"BAT",
							"MOT",
							"FAN",
							"FIL",
							"PMP",
							"TNK",
							"VLV"
						],
						pattern: ["\\i\\c*", "E[A-Z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 3,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				virtual: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"EqFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				EqFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFuncForGE",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFuncForGE",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInGeneralEquipment",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInGE",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tEquipment",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConductingEquipment: {
		tag: "ConductingEquipment",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"Bay",
			"Function",
			"FunctionTemplate",
			"Line",
			"Process",
			"SubFunction",
			"SubFunctionTemplate"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid",
				"virtual"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "CBR.DIS.VTR.CTR.GEN.CAP.REA.CON.MOT.EFN.PSH.BAT.BSH.CAB.GIL.LIN.RES.RRC.SAR.TCF.TCR.IFL.FAN.SCR.SMC.PMP".split("."),
						pattern: ["\\i\\c*", "E[A-Z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 3,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				virtual: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"Terminal",
				"SubEquipment",
				"EqFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Terminal: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 2
					},
					constraints: null
				},
				SubEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInACESubEquipment",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				EqFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFuncForCE",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFuncForCE",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tAbstractConductingEquipment",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Private: {
		tag: "Private",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: /* @__PURE__ */ "AccessPoint.BDA.Bay.Communication.ConductingEquipment.ConnectedAP.ConnectivityNode.DA.DAI.DAType.DO.DOI.DOType.DataSet.EnumType.EqFunction.EqSubFunction.ExtCtrl.ExtRef.Function.GOOSESecurity.GSE.GSEControl.GeneralEquipment.IED.IEDSourceFiles.Inputs.LDevice.LN.LN0.LNode.LNodeType.Labels.Line.Log.LogControl.MinRequestedSCDFiles.NeutralPoint.Outputs.PhysConn.PowerTransformer.Process.ReportControl.RptEnabled.SCL.SDI.SDO.SMV.SMVSecurity.SampledValueControl.SclFileReference.Server.ServerAt.SettingControl.SourceFiles.SubEquipment.SubFunction.SubNetwork.Substation.TapChanger.Terminal.TransformerWinding.VoltageLevel".split("."),
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["source", "type"],
			details: {
				source: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tAnyContentFromOtherNamespace",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Header: {
		tag: "Header",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SCL"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"baseUuid",
				"fileType",
				"id",
				"nameStructure",
				"revision",
				"toolID",
				"uuid",
				"version"
			],
			details: {
				baseUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileType: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"ICD",
							"IID",
							"CID",
							"SSD",
							"SCD",
							"SED"
						],
						pattern: ["\\i\\c*", "[A-Z]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				nameStructure: {
					required: !1,
					default: "IEDName",
					namespace: null,
					validation: {
						enumeration: ["IEDName"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				revision: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				toolID: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				version: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [
				"Text",
				"History",
				"SourceFiles"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				History: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SourceFiles: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueHitem",
			kind: "unique",
			paths: [["History", "Hitem"]],
			deep: !1,
			attributes: ["version", "revision"],
			refer: null,
			text: !1
		}],
		value: {
			type: null,
			validation: {
				enumeration: ["IEDName"],
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	PowerTransformer: {
		tag: "PowerTransformer",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"Bay",
			"Substation",
			"VoltageLevel"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid",
				"virtual"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: "PTR",
					namespace: null,
					validation: {
						enumeration: ["PTR"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				virtual: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"TransformerWinding",
				"SubEquipment",
				"EqFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				TransformerWinding: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInTransformerWinding",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInPTW",
						kind: "unique",
						paths: [[
							"SubEquipment|.",
							"TapChanger|.",
							"EqFunction"
						]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				SubEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubEquipmentPTR",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInPTRSubEquipment",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				EqFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFuncForPTR",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFuncForPTR",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInPowerTransformer",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInPTR",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tEquipment",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	VoltageLevel: {
		tag: "VoltageLevel",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Substation"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"nomFreq",
				"numPhases",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				nomFreq: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: "0",
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				numPhases: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 255,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"PowerTransformer",
				"GeneralEquipment",
				"Voltage",
				"Bay",
				"Function"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				PowerTransformer: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInPowerTransformer",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInPTR",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGE",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				Voltage: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Bay: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueChildNameInBay",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}, {
						name: "uniqueLNodeInBay",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}]
				},
				Function: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFunctionVL",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInVoltageLevelFunc",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueChildNameInVoltageLevel",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}, {
			name: "uniqueLNodeInVoltageLevel",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tEquipmentContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Function: {
		tag: "Function",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"Bay",
			"Line",
			"Process",
			"Substation",
			"VoltageLevel"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"SubFunction",
				"GeneralEquipment",
				"ConductingEquipment"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SubFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInSubFunc",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipmentOfFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGEFunc",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				ConductingEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInConductingEquipmentOfFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInCondEq",
						kind: "unique",
						paths: [["SubEquipment|.", "EqFunction"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInFunctionSS",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInSubstationFunc",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tPowerSystemResource",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Voltage: {
		tag: "Voltage",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Line", "VoltageLevel"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["multiplier", "unit"],
			details: {
				multiplier: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: [
							"",
							"m",
							"k",
							"M",
							"mu",
							"y",
							"z",
							"a",
							"f",
							"p",
							"n",
							"c",
							"d",
							"da",
							"h",
							"G",
							"T",
							"P",
							"E",
							"Z",
							"Y"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				unit: {
					required: !0,
					default: "V",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConnectivityNode: {
		tag: "ConnectivityNode",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Bay", "Line"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"pathName",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pathName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+/.+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tLNodeContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DataSet: {
		tag: "DataSet",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN", "LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"FCDA"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				FCDA: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 1,
				maxOccurrence: null,
				options: ["FCDA"]
			}]
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ReportControl: {
		tag: "ReportControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN", "LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"bufTime",
				"buffered",
				"confRev",
				"datSet",
				"desc",
				"indexed",
				"intgPd",
				"name",
				"rptID",
				"templateUuid",
				"uuid"
			],
			details: {
				bufTime: {
					required: !1,
					default: "0",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				buffered: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				confRev: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				indexed: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intgPd: {
					required: !1,
					default: "0",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				rptID: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[ -~]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 129,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"TrgOps",
				"OptFields",
				"RptEnabled"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				TrgOps: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				OptFields: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				RptEnabled: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlWithTriggerOpt",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LogControl: {
		tag: "LogControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN", "LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"bufTime",
				"datSet",
				"desc",
				"intgPd",
				"ldInst",
				"lnClass",
				"lnInst",
				"logEna",
				"logName",
				"name",
				"prefix",
				"reasonCode",
				"templateUuid",
				"uuid"
			],
			details: {
				bufTime: {
					required: !1,
					default: "0",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intgPd: {
					required: !1,
					default: "0",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !1,
					default: "LLN0",
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logEna: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				reasonCode: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"TrgOps"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				TrgOps: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlWithTriggerOpt",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DOI: {
		tag: "DOI",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN", "LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"accessControl",
				"desc",
				"ix",
				"name"
			],
			details: {
				accessControl: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 12,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"SDI",
				"DAI",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SDI: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueSDI_DAIinSDI",
						kind: "unique",
						paths: [["DAI|.", "SDI"]],
						deep: !1,
						attributes: ["name", "ix"],
						refer: null,
						text: !1
					}]
				},
				DAI: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelinDOI",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["SDI", "DAI"]
			}]
		},
		constraints: [{
			name: "uniqueSDI_DAIinDOI",
			kind: "unique",
			paths: [["DAI|.", "SDI"]],
			deep: !1,
			attributes: ["name", "ix"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Inputs: {
		tag: "Inputs",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN", "LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"ExtRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				ExtRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Outputs: {
		tag: "Outputs",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN", "LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc"],
			details: { desc: {
				required: !1,
				default: "",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"ExtCtrl"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				ExtCtrl: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Log: {
		tag: "Log",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN", "LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc", "name"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GSEControl: {
		tag: "GSEControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"appID",
				"confRev",
				"datSet",
				"desc",
				"fixedOffs",
				"name",
				"securityEnable",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				appID: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[ -~]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 129,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				confRev: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fixedOffs: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				securityEnable: {
					required: !1,
					default: "None",
					namespace: null,
					validation: {
						enumeration: [
							"None",
							"Signature",
							"SignatureAndEncryption"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: "GOOSE",
					namespace: null,
					validation: {
						enumeration: ["GSSE", "GOOSE"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"IEDName",
				"Protocol"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				IEDName: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Protocol: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlWithIEDName",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SampledValueControl: {
		tag: "SampledValueControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"confRev",
				"datSet",
				"desc",
				"multicast",
				"name",
				"nofASDU",
				"securityEnable",
				"smpMod",
				"smpRate",
				"smvID",
				"templateUuid",
				"uuid"
			],
			details: {
				confRev: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				multicast: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				nofASDU: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				securityEnable: {
					required: !1,
					default: "None",
					namespace: null,
					validation: {
						enumeration: [
							"None",
							"Signature",
							"SignatureAndEncryption"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				smpMod: {
					required: !1,
					default: "SmpPerPeriod",
					namespace: null,
					validation: {
						enumeration: [
							"SmpPerPeriod",
							"SmpPerSec",
							"SecPerSmp"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				smpRate: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				smvID: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[ -~]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 129,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"IEDName",
				"SmvOpts",
				"Protocol"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				IEDName: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SmvOpts: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Protocol: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlWithIEDName",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SettingControl: {
		tag: "SettingControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LN0"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"actSG",
				"desc",
				"numOfSGs",
				"resvTms"
			],
			details: {
				actSG: {
					required: !1,
					default: "1",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 1,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				numOfSGs: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 1,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resvTms: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 65535,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Services: {
		tag: "Services",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["AccessPoint", "IED"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["nameLength"],
			details: { nameLength: {
				required: !1,
				default: "32",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: [
						"32",
						"64",
						"6[5-9]",
						"[7-9]\\d",
						"[1-9]\\d\\d+"
					],
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: /* @__PURE__ */ "DynAssociation.SettingGroups.GetDirectory.GetDataObjectDefinition.DataObjectDirectory.GetDataSetValue.SetDataSetValue.DataSetDirectory.ConfDataSet.DynDataSet.ReadWrite.TimerActivatedControl.ConfReportControl.GetCBValues.ConfLogControl.ReportSettings.LogSettings.GSESettings.SMVSettings.GSEDir.GOOSE.GSSE.SMVsc.FileHandling.ConfLNs.ClientServices.ConfLdName.SupSubscription.ConfSigRef.ValueHandling.RedProt.TimeSyncProt.CommProt.SCSM.Security.MultiAPPerSubNet".split("."),
			details: {
				DynAssociation: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SettingGroups: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GetDirectory: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GetDataObjectDefinition: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				DataObjectDirectory: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GetDataSetValue: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SetDataSetValue: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				DataSetDirectory: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConfDataSet: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				DynDataSet: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ReadWrite: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				TimerActivatedControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConfReportControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GetCBValues: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConfLogControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ReportSettings: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				LogSettings: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GSESettings: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SMVSettings: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GSEDir: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GOOSE: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GSSE: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SMVsc: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FileHandling: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConfLNs: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ClientServices: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConfLdName: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SupSubscription: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConfSigRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ValueHandling: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				RedProt: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				TimeSyncProt: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				CommProt: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SCSM: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Security: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				MultiAPPerSubNet: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	AccessPoint: {
		tag: "AccessPoint",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["IED"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"clock",
				"desc",
				"kdc",
				"name",
				"router",
				"templateUuid",
				"uuid"
			],
			details: {
				clock: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				kdc: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				router: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Server",
				"LN",
				"ServerAt",
				"Services",
				"GOOSESecurity",
				"SMVSecurity",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Server: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueAssociationInServer",
						kind: "unique",
						paths: [["Association"]],
						deep: !1,
						attributes: ["associationID"],
						refer: null,
						text: !1
					}]
				},
				LN: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				},
				ServerAt: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Services: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GOOSESecurity: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 7
					},
					constraints: null
				},
				SMVSecurity: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 7
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInAP",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: 1,
				options: [
					"Server",
					"LN",
					"ServerAt"
				]
			}]
		},
		constraints: [{
			name: "uniqueLNInAccessPoint",
			kind: "unique",
			paths: [["LN"]],
			deep: !1,
			attributes: [
				"inst",
				"lnClass",
				"prefix"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	KDC: {
		tag: "KDC",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["IED"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"apName",
				"apUuid",
				"iedName"
			],
			details: {
				apName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				apUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	IEDSourceFiles: {
		tag: "IEDSourceFiles",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["IED"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"SclFileReference"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SclFileReference: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	MinRequestedSCDFiles: {
		tag: "MinRequestedSCDFiles",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["IED"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"MinRequestedSCDFile"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				MinRequestedSCDFile: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueProjectInReqSCD",
			kind: "unique",
			paths: [["MinRequestedSCDFile"]],
			deep: !1,
			attributes: ["fileUuid"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tBaseElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SubNetwork: {
		tag: "SubNetwork",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Communication"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: ["8-MMS", "8-XMPP"],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"BitRate",
				"ConnectedAP"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				BitRate: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConnectedAP: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueGSEinConnectedAP",
						kind: "unique",
						paths: [["GSE"]],
						deep: !1,
						attributes: ["cbName", "ldInst"],
						refer: null,
						text: !1
					}, {
						name: "uniqueSMVinConnectedAP",
						kind: "unique",
						paths: [["SMV"]],
						deep: !1,
						attributes: ["cbName", "ldInst"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueConnectedAP",
			kind: "unique",
			paths: [["ConnectedAP"]],
			deep: !1,
			attributes: ["iedName", "apName"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNodeType: {
		tag: "LNodeType",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DataTypeTemplates"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"id",
				"iedType",
				"lnClass"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedType: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"DO",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				DO: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInLNType",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueDOInLNodeType",
			kind: "unique",
			paths: [["DO"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tIDNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DOType: {
		tag: "DOType",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DataTypeTemplates"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"cdc",
				"desc",
				"id",
				"iedType"
			],
			details: {
				cdc: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "SPS.DPS.INS.ENS.ACT.ACD.SEC.BCR.HST.VSS.MV.CMV.SAV.WYE.DEL.SEQ.HMV.HWYE.HDEL.SPC.DPC.INC.ENC.BSC.ISC.APC.BAC.SPG.ING.ENG.ORG.TSG.CUG.VSG.ASG.CURVE.CSG.DPL.LPL.CSD.CST.BTS.UTS.LTS.GTS.MTS.NTS.STS.CTS.OTS.VSD.ORS.TCS".split("."),
						pattern: ["\\i\\c*", "[A-Za-z]+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 5,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedType: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"SDO",
				"DA",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SDO: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				DA: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueProtNsInDA",
						kind: "unique",
						paths: [["ProtNs"]],
						deep: !1,
						attributes: ["type"],
						refer: null,
						text: !1
					}]
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInDOType",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["SDO", "DA"]
			}]
		},
		constraints: [{
			name: "uniqueDAorSDOInDOType",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tIDNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DAType: {
		tag: "DAType",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DataTypeTemplates"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"id",
				"iedType"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedType: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"BDA",
				"ProtNs",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				BDA: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				},
				ProtNs: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInDAType",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueBDAInDAType",
			kind: "unique",
			paths: [["BDA"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}, {
			name: "uniqueProtNs",
			kind: "unique",
			paths: [["ProtNs"]],
			deep: !1,
			attributes: ["type"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tIDNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	EnumType: {
		tag: "EnumType",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DataTypeTemplates"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc", "id"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"EnumVal"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				EnumVal: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: ["[\\p{IsBasicLatin}\\p{IsLatin-1Supplement}]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 127,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueOrdInEnumType",
			kind: "unique",
			paths: [["EnumVal"]],
			deep: !1,
			attributes: ["ord"],
			refer: null,
			text: !1
		}, {
			name: "uniqueEnumValue",
			kind: "unique",
			paths: [["EnumVal"]],
			deep: !1,
			attributes: [],
			refer: null,
			text: !1
		}],
		value: {
			type: "tIDNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Resource: {
		tag: "Resource",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "resource bound to this element could be multi\n\nresource bound to this element could be multi",
		parents: ["ProcessResource"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"resInst",
				"source",
				"sourceUuid"
			],
			details: {
				resInst: {
					required: !1,
					default: "1",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 1,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				source: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "normalizedString",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GooseParametersRef: {
		tag: "GooseParametersRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of the communication parameters expected for the current SourceRef when ServiceType is GOOSE\n\nSpecification of the communication parameters expected for the current SourceRef when ServiceType is GOOSE",
		parents: ["SourceRef", "SubscriberLNode"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc", "id"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SMVParametersRef: {
		tag: "SMVParametersRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of the communication parameters expected for the current SourceRef when ServiceType is SMV\n\nSpecification of the communication parameters expected for the current SourceRef when ServiceType is SMV",
		parents: ["SourceRef", "SubscriberLNode"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc", "id"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ReportParametersRef: {
		tag: "ReportParametersRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of the communication parameters expected for the current SourceRef when ServiceType is Report\n\nSpecification of the communication parameters expected for the current SourceRef when ServiceType is Report",
		parents: ["SourceRef", "SubscriberLNode"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc", "id"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BinaryWiringParametersRef: {
		tag: "BinaryWiringParametersRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of the binary wiring parameters expected for the current SourceRef when ServiceType is Wired\n\nSpecification of the binary wiring parameters expected for the current SourceRef when ServiceType is Wired",
		parents: [
			"ControlRef",
			"ControllingLNode",
			"SourceRef",
			"SubscriberLNode"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc", "id"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	AnalogueWiringParametersRef: {
		tag: "AnalogueWiringParametersRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Specification of the analogue wiring parameters expected for the current SourceRef when ServiceType is Wired\n\nSpecification of the analogue wiring parameters expected for the current SourceRef when ServiceType is Wired",
		parents: [
			"ControlRef",
			"ControllingLNode",
			"SourceRef"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc", "id"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				id: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElementWithDesc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Val: {
		tag: "Val",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"BDA",
			"DA",
			"DAI",
			"DAS"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["sGroup"],
			details: { sGroup: {
				required: !1,
				default: null,
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: 0,
					maxInclusive: 4294967295,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "normalizedString",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Label: {
		tag: "Label",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Labels"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["id", "lang"],
			details: {
				id: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\S+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lang: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "normalizedString",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	L2CommParameters: {
		tag: "L2CommParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["GooseParameters", "SMVParameters"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"appId",
				"desc",
				"macAddr",
				"vlanId",
				"vlanPriority"
			],
			details: {
				appId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-F]{4}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				macAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vlanId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-F]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vlanPriority: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-7]"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tCommParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	L3IPv4CommParameters: {
		tag: "L3IPv4CommParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["GooseParameters", "SMVParameters"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"IPv4",
				"IPv4-IGMPv3Src",
				"appId",
				"desc",
				"vlanId",
				"vlanPriority"
			],
			details: {
				IPv4: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				"IPv4-IGMPv3Src": {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				appId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-F]{4}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vlanId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-F]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vlanPriority: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-7]"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tCommParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	L3IPv6CommParameters: {
		tag: "L3IPv6CommParameters",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: null,
		parents: ["GooseParameters", "SMVParameters"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"IPv6",
				"IPv6-IGMPv3Src",
				"appId",
				"desc",
				"vlanId",
				"vlanPriority"
			],
			details: {
				IPv6: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["([0-9a-f]{1,4}:){7}[0-9a-f]{1,4}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				"IPv6-IGMPv3Src": {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["([0-9a-f]{1,4}:){7}[0-9a-f]{1,4}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				appId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-F]{4}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vlanId: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-F]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				vlanPriority: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-7]"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tCommParameters",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionalVariantRef: {
		tag: "FunctionalVariantRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Ref to a functional variant of the Application\n\nRef to a functional variant of the Application",
		parents: [
			"AllocationRoleRef",
			"BehaviorDescriptionRef",
			"FunctionCategoryRef",
			"FunctionRef",
			"FunctionRole",
			"InputVarRef",
			"LNodeDataRef",
			"LNodeInputRef",
			"LNodeOutputRef",
			"OutputVarRef",
			"PowerSystemRelationRef",
			"ProcessResourceRef",
			"SignalRole",
			"VariableRef"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"functionalVariant",
				"functionalVariantUuid",
				"update"
			],
			details: {
				functionalVariant: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				functionalVariantUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				update: {
					required: !1,
					default: "add",
					namespace: null,
					validation: {
						enumeration: ["add", "remove"],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text"],
			details: { Text: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElement",
			validation: {
				enumeration: ["add", "remove"],
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SignalRole: {
		tag: "SignalRole",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Signal list attached to the referenced function in the context of the cureent Role definition\n\nSignal list attached to the referenced function in the context of the cureent Role definition",
		parents: ["FunctionRef"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionalVariantRef",
				"LNodeInputRef",
				"LNodeOutputRef",
				"LNodeDataRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				LNodeInputRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				LNodeOutputRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				LNodeDataRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionRoleContent: {
		tag: "FunctionRoleContent",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "an instance of the current role. In case of application type definition, instance 1 is the default instance\n\nan instance of the current role. In case of application type definition, instance 1 is the default instance",
		parents: ["FunctionRole"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["roleInst"],
			details: { roleInst: {
				required: !1,
				default: "1",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: 1,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionRef",
				"BehaviorDescriptionRef",
				"ProcessResourceRef",
				"VariableRef",
				"FunctionCategoryRef",
				"PowerSystemRelationRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				BehaviorDescriptionRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				ProcessResourceRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				VariableRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionCategoryRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				PowerSystemRelationRef: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: [
					"FunctionRef",
					"BehaviorDescriptionRef",
					"ProcessResourceRef",
					"VariableRef",
					"FunctionCategoryRef",
					"PowerSystemRelationRef"
				]
			}]
		},
		constraints: [],
		value: {
			type: "tBaseExtensionElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionalSubVariant: {
		tag: "FunctionalSubVariant",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Sub variant of the current variant\n\nSub variant of the current variant",
		parents: ["FunctionalSubVariant", "FunctionalVariant"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"isBaseline",
				"name",
				"originUuid",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				isBaseline: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				originUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionalSubVariant",
				"VariableRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalSubVariant: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				VariableRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalSubVariant", "VariableRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tAbstractFunctionalVariant",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	VariableRef: {
		tag: "VariableRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a variable attached to current variant, to parameterize the instance with the value defined in the reference\n\nReference to a variable attached to current variant, to parameterize the instance with the value defined in the reference",
		parents: [
			"FunctionRoleContent",
			"FunctionalSubVariant",
			"FunctionalVariant"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"value",
				"variable",
				"variableUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				value: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				variable: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				variableUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tVariableRef",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	EqFunction: {
		tag: "EqFunction",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"ConductingEquipment",
			"GeneralEquipment",
			"PowerTransformer",
			"SubEquipment",
			"TapChanger",
			"TransformerWinding"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"GeneralEquipment",
				"EqSubFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipmentOfFuncForEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGEFuncForEquipment",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				EqSubFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubFuncForEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueSubFuncForEquipment",
						kind: "unique",
						paths: [["EqSubFunction"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInFuncForGE",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInFuncForGE",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tAbstractEqFuncSubFunc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Terminal: {
		tag: "Terminal",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ConductingEquipment", "TransformerWinding"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"bayName",
				"cNodeName",
				"cNodeUuid",
				"connectivityNode",
				"desc",
				"lineName",
				"name",
				"processName",
				"substationName",
				"voltageLevelName"
			],
			details: {
				bayName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cNodeName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cNodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				connectivityNode: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+/.+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lineName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				processName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				substationName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				voltageLevelName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SubEquipment: {
		tag: "SubEquipment",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"ConductingEquipment",
			"PowerTransformer",
			"TapChanger",
			"TransformerWinding"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"phase",
				"templateUuid",
				"uuid",
				"virtual"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				phase: {
					required: !1,
					default: "none",
					namespace: null,
					validation: {
						enumeration: [
							"A",
							"B",
							"C",
							"N",
							"all",
							"none",
							"AB",
							"BC",
							"CA"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				virtual: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"EqFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				EqFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFuncForSubEq",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFuncForSubEq",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInSubEquipment",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInACESubEquipment",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tPowerSystemResource",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	History: {
		tag: "History",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Header"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: ["Hitem"],
			details: { Hitem: {
				required: !0,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 1,
					maxOccurrence: null
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SourceFiles: {
		tag: "SourceFiles",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Header", "Hitem"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"SclFileReference"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SclFileReference: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tBaseElement",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	TransformerWinding: {
		tag: "TransformerWinding",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["PowerTransformer"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid",
				"virtual"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: "PTW",
					namespace: null,
					validation: {
						enumeration: ["PTW"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				virtual: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"Terminal",
				"SubEquipment",
				"TapChanger",
				"NeutralPoint",
				"EqFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Terminal: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 2
					},
					constraints: null
				},
				SubEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInACESubEquipment",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				TapChanger: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLNodeInTapChanger",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInLTC",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				NeutralPoint: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				EqFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFuncForPTW",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFuncForPTW",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInTransformerWinding",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInPTW",
			kind: "unique",
			paths: [[
				"SubEquipment|.",
				"TapChanger|.",
				"EqFunction"
			]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tAbstractConductingEquipment",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Bay: {
		tag: "Bay",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["VoltageLevel"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"PowerTransformer",
				"GeneralEquipment",
				"ConductingEquipment",
				"ConnectivityNode",
				"Function"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				PowerTransformer: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInPowerTransformer",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInPTR",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGE",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				ConductingEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInConductingEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInCE",
						kind: "unique",
						paths: [["SubEquipment|.", "EqFunction"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				ConnectivityNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInConnectivityNode",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}]
				},
				Function: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFunctionB",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInBayFunc",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueChildNameInBay",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}, {
			name: "uniqueLNodeInBay",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tEquipmentContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SubFunction: {
		tag: "SubFunction",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Function", "SubFunction"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"GeneralEquipment",
				"ConductingEquipment",
				"SubFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipmentOfSubFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGESubFunc",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				ConductingEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInConductingEquipmentOfSubFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueSubEquipmentSubFunc",
						kind: "unique",
						paths: [["SubEquipment"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				SubFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubSubFunction",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueSubSubFunc",
						kind: "unique",
						paths: [["SubFunction"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInSubFunction",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInSubFunc",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tPowerSystemResource",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FCDA: {
		tag: "FCDA",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DataSet"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"daName",
				"doName",
				"fc",
				"ix",
				"ldInst",
				"lnClass",
				"lnInst",
				"lnUuid",
				"prefix"
			],
			details: {
				daName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				doName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fc: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"ST",
							"MX",
							"CO",
							"SP",
							"SG",
							"SE",
							"SV",
							"CF",
							"DC",
							"EX",
							"SR",
							"BL",
							"OR"
						],
						pattern: ["\\i\\c*", "[A-Z]+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 2,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	TrgOps: {
		tag: "TrgOps",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LogControl", "ReportControl"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"dchg",
				"dupd",
				"gi",
				"period",
				"qchg"
			],
			details: {
				dchg: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dupd: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				gi: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				period: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				qchg: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	OptFields: {
		tag: "OptFields",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ReportControl"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"bufOvfl",
				"configRef",
				"dataRef",
				"dataSet",
				"entryID",
				"reasonCode",
				"seqNum",
				"timeStamp"
			],
			details: {
				bufOvfl: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				configRef: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dataRef: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dataSet: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				entryID: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				reasonCode: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				seqNum: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				timeStamp: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	RptEnabled: {
		tag: "RptEnabled",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ReportControl"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc", "max"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				max: {
					required: !1,
					default: "1",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"ClientLN"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				ClientLN: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SDI: {
		tag: "SDI",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DOI", "SDI"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"ix",
				"name",
				"sAddr"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"SDI",
				"DAI",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SDI: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				DAI: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelinSDI",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["SDI", "DAI"]
			}]
		},
		constraints: [{
			name: "uniqueSDI_DAIinSDI",
			kind: "unique",
			paths: [["DAI|.", "SDI"]],
			deep: !1,
			attributes: ["name", "ix"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DAI: {
		tag: "DAI",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DOI", "SDI"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"ix",
				"name",
				"sAddr",
				"valImport",
				"valKind"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valImport: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valKind: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"Spec",
							"Conf",
							"RO",
							"Set"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Val",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Val: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelinDAI",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ExtRef: {
		tag: "ExtRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Inputs"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"daName",
				"desc",
				"doName",
				"iedName",
				"intAddr",
				"ldInst",
				"lnClass",
				"lnInst",
				"lnUuid",
				"pDA",
				"pDO",
				"pLN",
				"pServT",
				"prefix",
				"serviceType",
				"srcCBName",
				"srcCBUuid",
				"srcLDInst",
				"srcLNClass",
				"srcLNInst",
				"srcPrefix",
				"templateUuid",
				"uuid"
			],
			details: {
				daName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				doName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"@",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pDA: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pDO: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pLN: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pServT: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"Poll",
							"Report",
							"GOOSE",
							"SMV"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				serviceType: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"Poll",
							"Report",
							"GOOSE",
							"SMV"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				srcCBName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				srcCBUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				srcLDInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				srcLNClass: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				srcLNInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				srcPrefix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tDORef",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ExtCtrl: {
		tag: "ExtCtrl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Outputs"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"apRef",
				"checkInterlock",
				"checkSynchrocheck",
				"desc",
				"doName",
				"iedName",
				"intAddr",
				"ldInst",
				"lnClass",
				"lnInst",
				"lnUuid",
				"pDO",
				"pLN",
				"prefix",
				"templateUuid",
				"uuid"
			],
			details: {
				apRef: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				checkInterlock: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: [
							"true",
							"false",
							"conserve"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				checkSynchrocheck: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: [
							"true",
							"false",
							"conserve"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				doName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"@",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pDO: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pLN: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tDORef",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	IEDName: {
		tag: "IEDName",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["GSEControl", "SampledValueControl"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"apRef",
				"apUuid",
				"ldInst",
				"ldUuid",
				"lnClass",
				"lnInst",
				"lnUuid",
				"prefix"
			],
			details: {
				apRef: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				apUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tIEDName",
			validation: {
				enumeration: null,
				pattern: [
					"[A-Za-z][0-9A-Za-z_]{0,2}",
					"[A-Za-z][0-9A-Za-z_]{4,63}",
					"[A-MO-Za-z][0-9A-Za-z_]{3}",
					"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
					"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
					"Non[0-9A-Za-df-z_]",
					"[A-Za-z][0-9A-Za-z_]*",
					"\\i\\c*"
				],
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: 64,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Protocol: {
		tag: "Protocol",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["GSEControl", "SampledValueControl"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["mustUnderstand"],
			details: { mustUnderstand: {
				required: !0,
				default: "true",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "normalizedString",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SmvOpts: {
		tag: "SmvOpts",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SampledValueControl"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"dataSet",
				"refreshTime",
				"sampleMode",
				"sampleRate",
				"sampleSynchronized",
				"security",
				"synchSourceId",
				"timestamp"
			],
			details: {
				dataSet: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				refreshTime: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sampleMode: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sampleRate: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sampleSynchronized: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				security: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				synchSourceId: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				timestamp: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DynAssociation: {
		tag: "DynAssociation",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["max"],
			details: { max: {
				required: !1,
				default: null,
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: 0,
					maxInclusive: 4294967295,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SettingGroups: {
		tag: "SettingGroups",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: ["SGEdit", "ConfSG"],
			details: {
				SGEdit: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				ConfSG: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GetDirectory: {
		tag: "GetDirectory",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GetDataObjectDefinition: {
		tag: "GetDataObjectDefinition",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DataObjectDirectory: {
		tag: "DataObjectDirectory",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GetDataSetValue: {
		tag: "GetDataSetValue",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SetDataSetValue: {
		tag: "SetDataSetValue",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DataSetDirectory: {
		tag: "DataSetDirectory",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConfDataSet: {
		tag: "ConfDataSet",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"max",
				"maxAttributes",
				"modify"
			],
			details: {
				max: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxAttributes: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				modify: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceWithMaxAndMaxAttributes",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DynDataSet: {
		tag: "DynDataSet",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["max", "maxAttributes"],
			details: {
				max: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxAttributes: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceWithMax",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ReadWrite: {
		tag: "ReadWrite",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	TimerActivatedControl: {
		tag: "TimerActivatedControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConfReportControl: {
		tag: "ConfReportControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"bufConf",
				"bufMode",
				"max",
				"maxBuf"
			],
			details: {
				bufConf: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				bufMode: {
					required: !1,
					default: "both",
					namespace: null,
					validation: {
						enumeration: [
							"unbuffered",
							"buffered",
							"both"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				max: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxBuf: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceWithMax",
			validation: {
				enumeration: [
					"unbuffered",
					"buffered",
					"both"
				],
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GetCBValues: {
		tag: "GetCBValues",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConfLogControl: {
		tag: "ConfLogControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["max"],
			details: { max: {
				required: !0,
				default: null,
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: 0,
					maxInclusive: 4294967295,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ReportSettings: {
		tag: "ReportSettings",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"bufTime",
				"cbName",
				"datSet",
				"intgPd",
				"optFields",
				"owner",
				"resvTms",
				"rptID",
				"trgOps"
			],
			details: {
				bufTime: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cbName: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: ["Conf", "Fix"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intgPd: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				optFields: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				owner: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				resvTms: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				rptID: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				trgOps: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceSettings",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LogSettings: {
		tag: "LogSettings",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"cbName",
				"datSet",
				"intgPd",
				"logEna",
				"trgOps"
			],
			details: {
				cbName: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: ["Conf", "Fix"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				intgPd: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				logEna: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				trgOps: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceSettings",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GSESettings: {
		tag: "GSESettings",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"appID",
				"cbName",
				"datSet",
				"dataLabel",
				"kdaParticipant"
			],
			details: {
				appID: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cbName: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: ["Conf", "Fix"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dataLabel: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				kdaParticipant: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: ["McSecurity"],
			details: { McSecurity: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceSettings",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SMVSettings: {
		tag: "SMVSettings",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"cbName",
				"datSet",
				"kdaParticipant",
				"nofASDU",
				"optFields",
				"pdcTimeStamp",
				"samplesPerSec",
				"smpRate",
				"svID",
				"synchSrcId"
			],
			details: {
				cbName: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: ["Conf", "Fix"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				datSet: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				kdaParticipant: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				nofASDU: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: ["Conf", "Fix"],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				optFields: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				pdcTimeStamp: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				samplesPerSec: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				smpRate: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				svID: {
					required: !1,
					default: "Fix",
					namespace: null,
					validation: {
						enumeration: [
							"Dyn",
							"Conf",
							"Fix"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				synchSrcId: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [
				"SmpRate",
				"SamplesPerSec",
				"SecPerSamples",
				"McSecurity"
			],
			details: {
				SmpRate: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SamplesPerSec: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				SecPerSamples: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				McSecurity: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 1,
				maxOccurrence: null,
				options: [
					"SmpRate",
					"SamplesPerSec",
					"SecPerSamples"
				]
			}]
		},
		constraints: [],
		value: {
			type: "tServiceSettings",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GSEDir: {
		tag: "GSEDir",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GOOSE: {
		tag: "GOOSE",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"fixedOffs",
				"goose",
				"max",
				"rGOOSE"
			],
			details: {
				fixedOffs: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				goose: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				max: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				rGOOSE: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceWithMax",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GSSE: {
		tag: "GSSE",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["max"],
			details: { max: {
				required: !0,
				default: null,
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: 0,
					maxInclusive: 4294967295,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SMVsc: {
		tag: "SMVsc",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"delivery",
				"deliveryConf",
				"max",
				"rSV",
				"sv"
			],
			details: {
				delivery: {
					required: !1,
					default: "multicast",
					namespace: null,
					validation: {
						enumeration: [
							"unicast",
							"multicast",
							"both"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				deliveryConf: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				max: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				rSV: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sv: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceWithMax",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FileHandling: {
		tag: "FileHandling",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"ftp",
				"ftps",
				"mms"
			],
			details: {
				ftp: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ftps: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				mms: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceYesNo",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConfLNs: {
		tag: "ConfLNs",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["fixLnInst", "fixPrefix"],
			details: {
				fixLnInst: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fixPrefix: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ClientServices: {
		tag: "ClientServices",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"acceptServerInitiatedAssociation",
				"bufReport",
				"goose",
				"gsse",
				"maxAttributes",
				"maxGOOSE",
				"maxReports",
				"maxSMV",
				"noIctBinding",
				"rGOOSE",
				"rSV",
				"readLog",
				"supportsLdName",
				"sv",
				"unbufReport"
			],
			details: {
				acceptServerInitiatedAssociation: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				bufReport: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				goose: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				gsse: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxAttributes: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxGOOSE: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxReports: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxSMV: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				noIctBinding: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				rGOOSE: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				rSV: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				readLog: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				supportsLdName: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sv: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				unbufReport: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [
				"TimeSyncProt",
				"GOOSEMcSecurity",
				"SVMcSecurity",
				"Security"
			],
			details: {
				TimeSyncProt: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GOOSEMcSecurity: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				SVMcSecurity: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Security: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConfLdName: {
		tag: "ConfLdName",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SupSubscription: {
		tag: "SupSubscription",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["maxGo", "maxSv"],
			details: {
				maxGo: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				maxSv: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConfSigRef: {
		tag: "ConfSigRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["max"],
			details: { max: {
				required: !0,
				default: null,
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: 0,
					maxInclusive: 4294967295,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ValueHandling: {
		tag: "ValueHandling",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["setToRO"],
			details: { setToRO: {
				required: !1,
				default: "false",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	RedProt: {
		tag: "RedProt",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"hsr",
				"prp",
				"rstp"
			],
			details: {
				hsr: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prp: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				rstp: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	TimeSyncProt: {
		tag: "TimeSyncProt",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ClientServices", "Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"c37_238",
				"iec61850_9_3",
				"other",
				"sntp"
			],
			details: {
				c37_238: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iec61850_9_3: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				other: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sntp: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceYesNo",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	CommProt: {
		tag: "CommProt",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["ipv6"],
			details: { ipv6: {
				required: !1,
				default: "false",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceYesNo",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SCSM: {
		tag: "SCSM",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"iec61850_8_1",
				"iec61850_8_2",
				"serverAssociationInitiation"
			],
			details: {
				iec61850_8_1: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iec61850_8_2: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				serverAssociationInitiation: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceYesNo",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Security: {
		tag: "Security",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ClientServices", "Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["ACSEAuthentication", "E2ESecurity"],
			details: {
				ACSEAuthentication: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				E2ESecurity: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	MultiAPPerSubNet: {
		tag: "MultiAPPerSubNet",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Services"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Server: {
		tag: "Server",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["AccessPoint"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc", "timeout"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				timeout: {
					required: !1,
					default: "30",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Authentication",
				"LDevice",
				"Association"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Authentication: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				LDevice: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNInLDevice",
						kind: "unique",
						paths: [["LN"]],
						deep: !1,
						attributes: [
							"inst",
							"lnClass",
							"prefix"
						],
						refer: null,
						text: !1
					}]
				},
				Association: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueAssociationInServer",
			kind: "unique",
			paths: [["Association"]],
			deep: !1,
			attributes: ["associationID"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ServerAt: {
		tag: "ServerAt",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["AccessPoint"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"apName",
				"apUuid",
				"desc"
			],
			details: {
				apName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				apUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GOOSESecurity: {
		tag: "GOOSESecurity",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["AccessPoint"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"serialNumber",
				"templateUuid",
				"uuid",
				"xferNumber"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				serialNumber: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				xferNumber: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"Subject",
				"IssuerName"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				Subject: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				IssuerName: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SMVSecurity: {
		tag: "SMVSecurity",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["AccessPoint"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"serialNumber",
				"templateUuid",
				"uuid",
				"xferNumber"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				serialNumber: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				xferNumber: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"Subject",
				"IssuerName"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				Subject: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				IssuerName: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	MinRequestedSCDFile: {
		tag: "MinRequestedSCDFile",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["MinRequestedSCDFiles"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"fileName",
				"fileType",
				"fileUuid",
				"revision",
				"version",
				"when"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"SCD",
							"ICD",
							"IID",
							"CID",
							"SSD",
							"SED"
						],
						pattern: ["\\i\\c*", "[A-Z]{3}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fileUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				revision: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				version: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				when: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tSclFileUUIDReference",
			validation: {
				enumeration: ["SCD"],
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BitRate: {
		tag: "BitRate",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SubNetwork"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["multiplier", "unit"],
			details: {
				multiplier: {
					required: !1,
					default: "M",
					namespace: null,
					validation: {
						enumeration: [
							"",
							"m",
							"k",
							"M",
							"mu",
							"y",
							"z",
							"a",
							"f",
							"p",
							"n",
							"c",
							"d",
							"da",
							"h",
							"G",
							"T",
							"P",
							"E",
							"Z",
							"Y"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				unit: {
					required: !1,
					default: "b/s",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "decimal",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConnectedAP: {
		tag: "ConnectedAP",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SubNetwork"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"apName",
				"apUuid",
				"desc",
				"iedName",
				"redProt"
			],
			details: {
				apName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				apUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				redProt: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"none",
							"hsr",
							"prp",
							"rstp"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Address",
				"GSE",
				"SMV",
				"PhysConn"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Address: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				GSE: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SMV: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				PhysConn: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniquePTypeInPhysConn",
						kind: "unique",
						paths: [["P"]],
						deep: !1,
						attributes: ["type"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueGSEinConnectedAP",
			kind: "unique",
			paths: [["GSE"]],
			deep: !1,
			attributes: ["cbName", "ldInst"],
			refer: null,
			text: !1
		}, {
			name: "uniqueSMVinConnectedAP",
			kind: "unique",
			paths: [["SMV"]],
			deep: !1,
			attributes: ["cbName", "ldInst"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DO: {
		tag: "DO",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LNodeType"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"accessControl",
				"desc",
				"name",
				"transient",
				"type"
			],
			details: {
				accessControl: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 12,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				transient: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInDO",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SDO: {
		tag: "SDO",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DOType"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"count",
				"desc",
				"name",
				"type"
			],
			details: {
				count: {
					required: !1,
					default: "0",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-z][0-9A-Za-z]*", "\\i\\c*"],
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-z][0-9A-Za-z]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInSDO",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	DA: {
		tag: "DA",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DOType"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"bType",
				"count",
				"dchg",
				"desc",
				"dupd",
				"fc",
				"name",
				"qchg",
				"sAddr",
				"type",
				"valImport",
				"valKind"
			],
			details: {
				bType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "BOOLEAN.INT8.INT16.INT24.INT32.INT64.INT128.INT8U.INT16U.INT24U.INT32U.FLOAT32.FLOAT64.Enum.Dbpos.Tcmd.Quality.Timestamp.VisString32.VisString64.VisString65.VisString129.VisString255.Octet64.Unicode255.Struct.EntryTime.Check.ObjRef.Currency.PhyComAddr.TrgOps.OptFlds.SvOptFlds.LogOptFlds.EntryID.Octet6.Octet16".split("."),
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				count: {
					required: !1,
					default: "0",
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dchg: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				dupd: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				fc: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"ST",
							"MX",
							"CO",
							"SP",
							"SG",
							"SE",
							"SV",
							"CF",
							"DC",
							"EX",
							"SR",
							"BL",
							"OR"
						],
						pattern: ["\\i\\c*", "[A-Z]+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: 2,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				qchg: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valImport: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valKind: {
					required: !1,
					default: "Set",
					namespace: null,
					validation: {
						enumeration: [
							"Spec",
							"Conf",
							"RO",
							"Set"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Val",
				"Labels",
				"ProtNs"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Val: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInDA",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				ProtNs: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueProtNsInDA",
			kind: "unique",
			paths: [["ProtNs"]],
			deep: !1,
			attributes: ["type"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tAbstractDataAttribute",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BDA: {
		tag: "BDA",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DAType"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"bType",
				"count",
				"desc",
				"name",
				"sAddr",
				"type",
				"valImport",
				"valKind"
			],
			details: {
				bType: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "BOOLEAN.INT8.INT16.INT24.INT32.INT64.INT128.INT8U.INT16U.INT24U.INT32U.FLOAT32.FLOAT64.Enum.Dbpos.Tcmd.Quality.Timestamp.VisString32.VisString64.VisString65.VisString129.VisString255.Octet64.Unicode255.Struct.EntryTime.Check.ObjRef.Currency.PhyComAddr.TrgOps.OptFlds.SvOptFlds.LogOptFlds.EntryID.Octet6.Octet16".split("."),
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				count: {
					required: !1,
					default: "0",
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: 0,
						maxInclusive: 4294967295,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: [
							"T",
							"Test",
							"Check",
							"SIUnit",
							"Oper",
							"SBO",
							"SBOw",
							"Cancel",
							"Addr",
							"PRIORITY",
							"VID",
							"APPID",
							"TransportInUse",
							"IPClassOfTraffic",
							"IPv6FlowLabel",
							"IPAddressLength",
							"IPAddress"
						],
						pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 60,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sAddr: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 255,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valImport: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				valKind: {
					required: !1,
					default: "Set",
					namespace: null,
					validation: {
						enumeration: [
							"Spec",
							"Conf",
							"RO",
							"Set"
						],
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Val",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Val: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInDA",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tAbstractDataAttribute",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ProtNs: {
		tag: "ProtNs",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["DA", "DAType"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["type"],
			details: { type: {
				required: !1,
				default: "8-MMS",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: 1,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tNamespaceName",
			validation: {
				enumeration: null,
				pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	EnumVal: {
		tag: "EnumVal",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["EnumType"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["desc", "ord"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ord: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: -2147483648,
						maxInclusive: 2147483647,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tEnumStringValue",
			validation: {
				enumeration: null,
				pattern: ["[\\p{IsBasicLatin}\\p{IsLatin-1Supplement}]*"],
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: 127,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNodeInputRef: {
		tag: "LNodeInputRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to SourceRefs belonging to current role\n\nReference to SourceRefs belonging to current role",
		parents: ["SignalRole"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"sourceRef",
				"sourceRefUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceRef: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				sourceRefUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNodeOutputRef: {
		tag: "LNodeOutputRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to ControlRefs belonging to current role\n\nReference to ControlRefs belonging to current role",
		parents: ["SignalRole"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"controlRef",
				"controlRefUuid",
				"desc"
			],
			details: {
				controlRef: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				controlRefUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LNodeDataRef: {
		tag: "LNodeDataRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to Data belonging to current role\n\nReference to Data belonging to current role",
		parents: ["SignalRole"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"daName",
				"data",
				"desc",
				"doName",
				"lnodeUuid"
			],
			details: {
				daName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				data: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				doName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	BehaviorDescriptionRef: {
		tag: "BehaviorDescriptionRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a behavior description attached to current role\n\nReference to a behavior description attached to current role",
		parents: ["FunctionRoleContent"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"behaviorDescription",
				"behaviorDescriptionUuid",
				"desc"
			],
			details: {
				behaviorDescription: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				behaviorDescriptionUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"FunctionalVariantRef",
				"InputVarRef",
				"OutputVarRef"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				InputVarRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				OutputVarRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}, {
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["InputVarRef", "OutputVarRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ProcessResourceRef: {
		tag: "ProcessResourceRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a process resource attached to current role\n\nReference to a process resource attached to current role",
		parents: ["FunctionRoleContent"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"processResource",
				"processResourceUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				processResource: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				processResourceUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	FunctionCategoryRef: {
		tag: "FunctionCategoryRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a function category attached to current role\n\nReference to a function category attached to current role",
		parents: ["FunctionRoleContent"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"functionCategory",
				"functionCategoryUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				functionCategory: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				functionCategoryUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	PowerSystemRelationRef: {
		tag: "PowerSystemRelationRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to a power system relation attached to current role\n\nReference to a power system relation attached to current role",
		parents: ["FunctionRoleContent"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"powerSystemRelation",
				"powerSystemRelationUuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				powerSystemRelation: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				powerSystemRelationUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	EqSubFunction: {
		tag: "EqSubFunction",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["EqFunction", "EqSubFunction"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"GeneralEquipment",
				"EqSubFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				GeneralEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInGeneralEquipmentOfFuncForEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInGEFuncForEquipment",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				EqSubFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubFuncForEquipment",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueSubFuncForEquipment",
						kind: "unique",
						paths: [["EqSubFunction"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInSubFuncForEquipment",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueSubFuncForEquipment",
			kind: "unique",
			paths: [["EqSubFunction"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tAbstractEqFuncSubFunc",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Hitem: {
		tag: "Hitem",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["History"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"revision",
				"version",
				"what",
				"when",
				"who",
				"why"
			],
			details: {
				revision: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				version: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				what: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				when: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				who: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				why: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["SourceFiles"],
			details: { SourceFiles: {
				required: !1,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: null,
					assertions: null,
					minOccurrence: 0,
					maxOccurrence: 1
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: "tAnyContentFromOtherNamespace",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	TapChanger: {
		tag: "TapChanger",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["TransformerWinding"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"name",
				"templateUuid",
				"type",
				"uuid",
				"virtual"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: "LTC",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				virtual: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Labels",
				"LNode",
				"SubEquipment",
				"EqFunction"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabel",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				},
				LNode: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				SubEquipment: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInSubEquipmentLTC",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInLTCSubEquipment",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				},
				EqFunction: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: [{
						name: "uniqueLNodeInFuncForLTC",
						kind: "unique",
						paths: [["LNode"]],
						deep: !1,
						attributes: [
							"lnInst",
							"lnClass",
							"iedName",
							"ldInst",
							"prefix"
						],
						refer: null,
						text: !1
					}, {
						name: "uniqueChildNameInFuncForLTC",
						kind: "unique",
						paths: [["*"]],
						deep: !1,
						attributes: ["name"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNodeInTapChanger",
			kind: "unique",
			paths: [["LNode"]],
			deep: !1,
			attributes: [
				"lnInst",
				"lnClass",
				"iedName",
				"ldInst",
				"prefix"
			],
			refer: null,
			text: !1
		}, {
			name: "uniqueChildNameInLTC",
			kind: "unique",
			paths: [["*"]],
			deep: !1,
			attributes: ["name"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tPowerSystemResource",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	NeutralPoint: {
		tag: "NeutralPoint",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["TransformerWinding"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"bayName",
				"cNodeName",
				"cNodeUuid",
				"connectivityNode",
				"desc",
				"lineName",
				"name",
				"processName",
				"substationName",
				"voltageLevelName"
			],
			details: {
				bayName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cNodeName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cNodeUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				connectivityNode: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+/.+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lineName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				name: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				processName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				substationName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				voltageLevelName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "Private"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ClientLN: {
		tag: "ClientLN",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["RptEnabled"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"apRef",
				"desc",
				"iedName",
				"ldInst",
				"lnClass",
				"lnInst",
				"lnUuid",
				"prefix"
			],
			details: {
				apRef: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 0,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SGEdit: {
		tag: "SGEdit",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SettingGroups"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["resvTms"],
			details: { resvTms: {
				required: !1,
				default: "false",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceYesNo",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	ConfSG: {
		tag: "ConfSG",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SettingGroups"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["resvTms"],
			details: { resvTms: {
				required: !1,
				default: "false",
				namespace: null,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "collapse",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tServiceYesNo",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	McSecurity: {
		tag: "McSecurity",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["GSESettings", "SMVSettings"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["encryption", "signature"],
			details: {
				encryption: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				signature: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SmpRate: {
		tag: "SmpRate",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SMVSettings"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: 0,
				maxInclusive: 4294967295,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SamplesPerSec: {
		tag: "SamplesPerSec",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SMVSettings"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: 0,
				maxInclusive: 4294967295,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SecPerSamples: {
		tag: "SecPerSamples",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["SMVSettings"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: 0,
				maxInclusive: 4294967295,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GOOSEMcSecurity: {
		tag: "GOOSEMcSecurity",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ClientServices"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["encryption", "signature"],
			details: {
				encryption: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				signature: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SVMcSecurity: {
		tag: "SVMcSecurity",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ClientServices"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["encryption", "signature"],
			details: {
				encryption: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				signature: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Authentication: {
		tag: "Authentication",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Server"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"certificate",
				"none",
				"password",
				"strong",
				"weak"
			],
			details: {
				certificate: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				none: {
					required: !1,
					default: "true",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				password: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				strong: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				weak: {
					required: !1,
					default: "false",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	LDevice: {
		tag: "LDevice",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Server"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"desc",
				"inst",
				"ldName",
				"templateUuid",
				"uuid"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				inst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldName: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				templateUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				uuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"LN0",
				"LN",
				"AccessControl",
				"Labels"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				LN0: {
					required: !0,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 1,
						maxOccurrence: 1
					},
					constraints: null
				},
				LN: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				AccessControl: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Labels: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: [{
						name: "uniqueLabelInLD",
						kind: "unique",
						paths: [["Label"]],
						deep: !1,
						attributes: ["id", "lang"],
						refer: null,
						text: !1
					}]
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniqueLNInLDevice",
			kind: "unique",
			paths: [["LN"]],
			deep: !1,
			attributes: [
				"inst",
				"lnClass",
				"prefix"
			],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Association: {
		tag: "Association",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Server"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"apRef",
				"associationID",
				"desc",
				"iedName",
				"initiator",
				"kind",
				"ldInst",
				"lnClass",
				"lnInst",
				"lnUuid",
				"prefix"
			],
			details: {
				apRef: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				associationID: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9A-Za-z]+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				iedName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [
							"[A-Za-z][0-9A-Za-z_]{0,2}",
							"[A-Za-z][0-9A-Za-z_]{4,63}",
							"[A-MO-Za-z][0-9A-Za-z_]{3}",
							"N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
							"No[0-9A-Za-mo-z_][0-9A-Za-z_]",
							"Non[0-9A-Za-df-z_]",
							"[A-Za-z][0-9A-Za-z_]*",
							"\\i\\c*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				initiator: {
					required: !1,
					default: "client",
					namespace: null,
					validation: {
						enumeration: ["client", "server"],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				kind: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: ["pre-established", "predefined"],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnClass: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: /* @__PURE__ */ "LLN0.LPHD.LCCH.LGOS.LSVS.LTIM.LTMS.LTRK.ANCR.ARCO.ARIS.ATCC.AVCO.CALH.CCGR.CILO.CPOW.CSWI.CSYN.FCNT.FCSD.FFIL.FLIM.FPID.FRMP.FSPT.FXOT.FXUT.GAPC.GGIO.GLOG.GSAL.IARC.IHMI.ISAF.ITCI.ITMI.ITPC.KFAN.KFIL.KPMP.KTNK.KVLV.MDIF.MENV.MFLK.MHAI.MHAN.MHYD.MMDC.MMET.MMTN.MMTR.MMXN.MMXU.MSQI.MSTA.PDIF.PDIR.PDIS.PDOP.PDUP.PFRC.PHAR.PHIZ.PIOC.PMRI.PMSS.POPF.PPAM.PRTR.PSCH.PSDE.PTEF.PTHF.PTOC.PTOF.PTOV.PTRC.PTTR.PTUC.PTUF.PTUV.PUPF.PVOC.PVPH.PZSU.QFVR.QITR.QIUB.QVTR.QVUB.QVVR.RADR.RBDR.RBRF.RDIR.RDRE.RDRS.RFLO.RMXU.RPSB.RREC.RSYN.SARC.SCBR.SIMG.SIML.SLTC.SOPM.SPDC.SPTR.SSWI.STMP.SVBR.TANG.TAXD.TCTR.TDST.TFLW.TFRQ.TGSN.THUM.TLVL.TMGF.TMVM.TPOS.TPRS.TRTN.TSND.TTMP.TTNS.TVBR.TVTR.TWPH.XCBR.XSWI.YEFN.YLTC.YPSH.YPTR.ZAXN.ZBAT.ZBSH.ZCAB.ZCAP.ZCON.ZGEN.ZGIL.ZLIN.ZMOT.ZREA.ZRES.ZRRC.ZSAR.ZSCR.ZSMC.ZTCF.ZTCR".split("."),
						pattern: [
							"[A-Z]+",
							"L[A-Z]*",
							"LLN0",
							"\\i\\c*",
							"A[A-Z]*",
							"C[A-Z]*",
							"F[A-Z]*",
							"G[A-Z]*",
							"I[A-Z]*",
							"K[A-Z]*",
							"M[A-Z]*",
							"P[A-Z]*",
							"Q[A-Z]*",
							"R[A-Z]*",
							"S[A-Z]*",
							"T[A-Z]*",
							"X[A-Z]*",
							"Y[A-Z]*",
							"Z[A-Z]*"
						],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnInst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9]{1,12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 0,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				lnUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				prefix: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 11,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Subject: {
		tag: "Subject",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["GOOSESecurity", "SMVSecurity"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["commonName", "idHierarchy"],
			details: {
				commonName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["none", "CN=.+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 4,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				idHierarchy: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	IssuerName: {
		tag: "IssuerName",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["GOOSESecurity", "SMVSecurity"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["commonName", "idHierarchy"],
			details: {
				commonName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["none", "CN=.+"],
						minInclusive: null,
						maxInclusive: null,
						minLength: 4,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				idHierarchy: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	Address: {
		tag: "Address",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: [
			"ConnectedAP",
			"GSE",
			"SMV"
		],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !1,
			sequence: ["P"],
			details: { P: {
				required: !0,
				validation: {
					enumeration: null,
					pattern: null,
					minInclusive: null,
					maxInclusive: null,
					minLength: 1,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: 1,
					maxOccurrence: null
				},
				constraints: null
			} },
			choices: []
		},
		constraints: [],
		value: {
			type: null,
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	GSE: {
		tag: "GSE",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ConnectedAP"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"cbName",
				"cbUuid",
				"desc",
				"ldInst"
			],
			details: {
				cbName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cbUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Address",
				"MinTime",
				"MaxTime"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Address: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				MinTime: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				MaxTime: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlBlock",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	SMV: {
		tag: "SMV",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ConnectedAP"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [
				"cbName",
				"cbUuid",
				"desc",
				"ldInst"
			],
			details: {
				cbName: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 32,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				cbUuid: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "preserve",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				ldInst: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: 64,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"Address"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				Address: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [],
		value: {
			type: "tControlBlock",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	PhysConn: {
		tag: "PhysConn",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["ConnectedAP"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: ["desc", "type"],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				type: {
					required: !0,
					default: null,
					namespace: null,
					validation: {
						enumeration: ["Connection", "RedConn"],
						pattern: ["[A-Z][0-9A-Za-z\\-]*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: [
				"Text",
				"Private",
				"P"
			],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				Private: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				},
				P: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: 1,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: []
		},
		constraints: [{
			name: "uniquePTypeInPhysConn",
			kind: "unique",
			paths: [["P"]],
			deep: !1,
			attributes: ["type"],
			refer: null,
			text: !1
		}],
		value: {
			type: "tUnNaming",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	InputVarRef: {
		tag: "InputVarRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to InputVar belonging to current behavior description\n\nReference to InputVar belonging to current behavior description",
		parents: ["BehaviorDescriptionRef"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"value",
				"variable"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				value: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				variable: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	OutputVarRef: {
		tag: "OutputVarRef",
		namespace: {
			uri: "http://www.iec.ch/61850/2019/SCL/6-100",
			prefix: "eIEC61850-6-100"
		},
		documentation: "Reference to OutputVar belonging to current behavior description\n\nReference to OutputVar belonging to current behavior description",
		parents: ["BehaviorDescriptionRef"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: [
				"desc",
				"value",
				"variable"
			],
			details: {
				desc: {
					required: !1,
					default: "",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				value: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				variable: {
					required: !1,
					default: null,
					namespace: null,
					validation: {
						enumeration: null,
						pattern: [".+(/.+)*"],
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !0,
			sequence: ["Text", "FunctionalVariantRef"],
			details: {
				Text: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: 1
					},
					constraints: null
				},
				FunctionalVariantRef: {
					required: !1,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: null,
						assertions: null,
						minOccurrence: 0,
						maxOccurrence: null
					},
					constraints: null
				}
			},
			choices: [{
				minOccurrence: 0,
				maxOccurrence: null,
				options: ["FunctionalVariantRef"]
			}]
		},
		constraints: [],
		value: {
			type: "tFunctionalVariantRefContainer",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	AccessControl: {
		tag: "AccessControl",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["LDevice"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !0,
			sequence: [],
			details: {}
		},
		subElements: {
			any: !0,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tAnyContentFromOtherNamespace",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: null,
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	P: {
		tag: "P",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["Address", "PhysConn"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["type"],
			details: { type: {
				required: !0,
				default: null,
				namespace: null,
				validation: {
					enumeration: /* @__PURE__ */ "IP.IP-SUBNET.IP-GATEWAY.OSI-NSAP.OSI-TSEL.OSI-SSEL.OSI-PSEL.OSI-AP-Title.OSI-AP-Invoke.OSI-AE-Qualifier.OSI-AE-Invoke.MAC-Address.APPID.VLAN-PRIORITY.VLAN-ID.SNTP-Port.MMS-Port.DNSName.IPv6FlowLabel.IPv6ClassOfTraffic.C37-118-IP-Port.IP-UDP-PORT.IP-TCP-PORT.IPv6.IPv6-SUBNET.IPv6-GATEWAY.IPv6-IGMPv3Src.IP-IGMPv3Src.IP-ClassOfTraffic".split("."),
					pattern: ["\\i\\c*", "[A-Z][0-9A-Za-z\\-]*"],
					minInclusive: null,
					maxInclusive: null,
					minLength: null,
					maxLength: null,
					fractionDigits: null,
					totalDigits: null,
					whitespace: "replace",
					assertions: null,
					minOccurrence: null,
					maxOccurrence: null
				}
			} }
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "tPAddr",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: 1,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "replace",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	MinTime: {
		tag: "MinTime",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["GSE"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["multiplier", "unit"],
			details: {
				multiplier: {
					required: !1,
					default: "m",
					namespace: null,
					validation: {
						enumeration: [
							"",
							"m",
							"k",
							"M",
							"mu",
							"y",
							"z",
							"a",
							"f",
							"p",
							"n",
							"c",
							"d",
							"da",
							"h",
							"G",
							"T",
							"P",
							"E",
							"Z",
							"Y"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				unit: {
					required: !1,
					default: "s",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "decimal",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	},
	MaxTime: {
		tag: "MaxTime",
		namespace: {
			uri: "http://www.iec.ch/61850/2003/SCL",
			prefix: ""
		},
		documentation: null,
		parents: ["GSE"],
		validation: {
			enumeration: null,
			pattern: null,
			minInclusive: null,
			maxInclusive: null,
			minLength: null,
			maxLength: null,
			fractionDigits: null,
			totalDigits: null,
			whitespace: null,
			assertions: null,
			minOccurrence: null,
			maxOccurrence: null
		},
		attributes: {
			any: !1,
			sequence: ["multiplier", "unit"],
			details: {
				multiplier: {
					required: !1,
					default: "m",
					namespace: null,
					validation: {
						enumeration: [
							"",
							"m",
							"k",
							"M",
							"mu",
							"y",
							"z",
							"a",
							"f",
							"p",
							"n",
							"c",
							"d",
							"da",
							"h",
							"G",
							"T",
							"P",
							"E",
							"Z",
							"Y"
						],
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "replace",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				},
				unit: {
					required: !1,
					default: "s",
					namespace: null,
					validation: {
						enumeration: null,
						pattern: null,
						minInclusive: null,
						maxInclusive: null,
						minLength: null,
						maxLength: null,
						fractionDigits: null,
						totalDigits: null,
						whitespace: "collapse",
						assertions: null,
						minOccurrence: null,
						maxOccurrence: null
					}
				}
			}
		},
		subElements: {
			any: !1,
			sequence: [],
			details: {},
			choices: []
		},
		constraints: [],
		value: {
			type: "decimal",
			validation: {
				enumeration: null,
				pattern: null,
				minInclusive: null,
				maxInclusive: null,
				minLength: null,
				maxLength: null,
				fractionDigits: null,
				totalDigits: null,
				whitespace: "collapse",
				assertions: null,
				minOccurrence: null,
				maxOccurrence: null
			}
		}
	}
}, gu = /* @__PURE__ */ "AccessControl.AccessPoint.Address.AllocationRole.AllocationRoleRef.AnalogueWiringParameters.AnalogueWiringParametersRef.Application.ApplicationSclRef.Association.Authentication.BDA.Bay.BayType.BehaviorDescription.BehaviorDescriptionRef.BehaviorReference.BinaryWiringParameters.BinaryWiringParametersRef.BitRate.CheckoutID.ClientLN.ClientServices.CommProt.Communication.CommunicationServiceSpecifications.ConductingEquipment.ConfDataSet.ConfLNs.ConfLdName.ConfLogControl.ConfReportControl.ConfSG.ConfSigRef.ConnectedAP.ConnectivityNode.ControlRef.ControllingLNode.DA.DAI.DAS.DAType.DO.DOI.DOS.DOType.DataObjectDirectory.DataSet.DataSetDirectory.DataTypeTemplates.DynAssociation.DynDataSet.EnumType.EnumVal.EqFunction.EqSubFunction.ExtCtrl.ExtRef.FCDA.FileHandling.Function.FunctionCatRef.FunctionCategory.FunctionCategoryRef.FunctionRef.FunctionRole.FunctionRoleContent.FunctionSclRef.FunctionTemplate.FunctionalSubVariant.FunctionalVariant.FunctionalVariantGroup.FunctionalVariantRef.GOOSE.GOOSEMcSecurity.GOOSESecurity.GSE.GSEControl.GSEDir.GSESettings.GSSE.GeneralEquipment.GetCBValues.GetDataObjectDefinition.GetDataSetValue.GetDirectory.GooseParameters.GooseParametersRef.Header.History.Hitem.IED.IEDName.IEDSourceFiles.InputVar.InputVarRef.Inputs.IssuerName.KDC.L2CommParameters.L3IPv4CommParameters.L3IPv6CommParameters.LDevice.LN.LN0.LNode.LNodeDataRef.LNodeInputRef.LNodeInputs.LNodeOutputRef.LNodeOutputs.LNodeSpecNaming.LNodeType.Label.Labels.Line.Log.LogControl.LogParameters.LogParametersRef.LogSettings.MaxTime.McSecurity.MinRequestedSCDFile.MinRequestedSCDFiles.MinTime.MultiAPPerSubNet.NeutralPoint.OptFields.OutputVar.OutputVarRef.Outputs.P.PhysConn.PowerSystemRelation.PowerSystemRelationRef.PowerSystemRelations.PowerTransformer.Private.Process.ProcessEcho.ProcessResource.ProcessResourceRef.ProcessResources.Project.ProjectProcessReference.ProtNs.Protocol.ReadWrite.RedProt.ReportControl.ReportParameters.ReportParametersRef.ReportSettings.Resource.RptEnabled.SCL.SCSM.SDI.SDO.SDS.SGEdit.SMV.SMVParameters.SMVParametersRef.SMVSecurity.SMVSettings.SMVsc.SVMcSecurity.SampledValueControl.SamplesPerSec.SclFileReference.SecPerSamples.Security.Server.ServerAt.ServiceSpecifications.Services.SetDataSetValue.SettingControl.SettingGroups.SignalRole.SmpRate.SmvOpts.SourceFiles.SourceRef.SubCategory.SubCheckoutID.SubEquipment.SubFunction.SubFunctionTemplate.SubNetwork.Subject.SubscriberLNode.Substation.SupSubscription.TapChanger.Terminal.Text.TimeSyncProt.TimerActivatedControl.TransformerWinding.TrgOps.Val.ValueHandling.Variable.VariableApplyTo.VariableRef.Voltage.VoltageLevel".split("."), du = {
	AccessControl: [],
	AccessPoint: ["name"],
	Address: [],
	AllocationRole: ["name"],
	AllocationRoleRef: [],
	AnalogueWiringParameters: ["id"],
	AnalogueWiringParametersRef: ["id"],
	Application: ["name"],
	ApplicationSclRef: [],
	Association: [
		"apRef",
		"iedName",
		"kind",
		"ldInst",
		"lnClass",
		"lnInst"
	],
	Authentication: [],
	BDA: ["bType", "name"],
	Bay: ["name"],
	BayType: [],
	BehaviorDescription: ["name"],
	BehaviorDescriptionRef: [],
	BehaviorReference: [],
	BinaryWiringParameters: ["id"],
	BinaryWiringParametersRef: ["id"],
	BitRate: [],
	CheckoutID: [
		"fileType",
		"revision",
		"version"
	],
	ClientLN: [
		"apRef",
		"iedName",
		"ldInst",
		"lnClass",
		"lnInst"
	],
	ClientServices: [],
	CommProt: [],
	Communication: [],
	CommunicationServiceSpecifications: [],
	ConductingEquipment: ["name", "type"],
	ConfDataSet: ["max"],
	ConfLNs: [],
	ConfLdName: [],
	ConfLogControl: ["max"],
	ConfReportControl: ["max"],
	ConfSG: [],
	ConfSigRef: ["max"],
	ConnectedAP: ["apName", "iedName"],
	ConnectivityNode: ["name", "pathName"],
	ControlRef: ["output"],
	ControllingLNode: ["outputName"],
	DA: [
		"bType",
		"fc",
		"name"
	],
	DAI: ["name"],
	DAS: ["name"],
	DAType: ["id"],
	DO: ["name", "type"],
	DOI: ["name"],
	DOS: ["name"],
	DOType: ["cdc", "id"],
	DataObjectDirectory: [],
	DataSet: ["name"],
	DataSetDirectory: [],
	DataTypeTemplates: [],
	DynAssociation: [],
	DynDataSet: ["max"],
	EnumType: ["id"],
	EnumVal: ["ord"],
	EqFunction: ["name"],
	EqSubFunction: ["name"],
	ExtCtrl: [],
	ExtRef: [],
	FCDA: ["fc"],
	FileHandling: [],
	Function: ["name"],
	FunctionCatRef: [],
	FunctionCategory: ["name"],
	FunctionCategoryRef: [],
	FunctionRef: [],
	FunctionRole: ["name"],
	FunctionRoleContent: [],
	FunctionSclRef: [],
	FunctionTemplate: ["name"],
	FunctionalSubVariant: ["name"],
	FunctionalVariant: ["name"],
	FunctionalVariantGroup: ["name"],
	FunctionalVariantRef: [],
	GOOSE: ["max"],
	GOOSEMcSecurity: [],
	GOOSESecurity: ["name", "serialNumber"],
	GSE: ["cbName", "ldInst"],
	GSEControl: ["appID", "name"],
	GSEDir: [],
	GSESettings: [],
	GSSE: ["max"],
	GeneralEquipment: ["name", "type"],
	GetCBValues: [],
	GetDataObjectDefinition: [],
	GetDataSetValue: [],
	GetDirectory: [],
	GooseParameters: ["id"],
	GooseParametersRef: ["id"],
	Header: ["id", "uuid"],
	History: [],
	Hitem: [
		"revision",
		"version",
		"when"
	],
	IED: ["name"],
	IEDName: ["apRef"],
	IEDSourceFiles: [],
	InputVar: ["varName"],
	InputVarRef: [],
	Inputs: [],
	IssuerName: ["commonName", "idHierarchy"],
	KDC: ["apName", "iedName"],
	L2CommParameters: [],
	L3IPv4CommParameters: [],
	L3IPv6CommParameters: [],
	LDevice: ["inst"],
	LN: [
		"inst",
		"lnClass",
		"lnType"
	],
	LN0: [
		"inst",
		"lnClass",
		"lnType"
	],
	LNode: ["lnClass"],
	LNodeDataRef: [],
	LNodeInputRef: [],
	LNodeInputs: [],
	LNodeOutputRef: [],
	LNodeOutputs: [],
	LNodeSpecNaming: [],
	LNodeType: ["id", "lnClass"],
	Label: ["lang"],
	Labels: [],
	Line: ["name"],
	Log: [],
	LogControl: ["logName", "name"],
	LogParameters: ["id"],
	LogParametersRef: ["id"],
	LogSettings: [],
	MaxTime: [],
	McSecurity: [],
	MinRequestedSCDFile: [
		"fileType",
		"revision",
		"version"
	],
	MinRequestedSCDFiles: [],
	MinTime: [],
	MultiAPPerSubNet: [],
	NeutralPoint: ["cNodeName", "connectivityNode"],
	OptFields: [],
	OutputVar: ["varName"],
	OutputVarRef: [],
	Outputs: [],
	P: ["type"],
	PhysConn: ["type"],
	PowerSystemRelation: ["name"],
	PowerSystemRelationRef: [],
	PowerSystemRelations: [],
	PowerTransformer: ["name", "type"],
	Private: ["type"],
	Process: ["name"],
	ProcessEcho: [],
	ProcessResource: ["name"],
	ProcessResourceRef: [],
	ProcessResources: [],
	Project: ["name"],
	ProjectProcessReference: [],
	ProtNs: [],
	Protocol: ["mustUnderstand"],
	ReadWrite: [],
	RedProt: [],
	ReportControl: ["confRev", "name"],
	ReportParameters: ["id"],
	ReportParametersRef: ["id"],
	ReportSettings: [],
	Resource: [],
	RptEnabled: [],
	SCL: [
		"release",
		"revision",
		"version"
	],
	SCSM: [],
	SDI: ["name"],
	SDO: ["name", "type"],
	SDS: ["name"],
	SGEdit: [],
	SMV: ["cbName", "ldInst"],
	SMVParameters: ["id"],
	SMVParametersRef: ["id"],
	SMVSecurity: ["name", "serialNumber"],
	SMVSettings: [],
	SMVsc: ["max"],
	SVMcSecurity: [],
	SampledValueControl: [
		"name",
		"nofASDU",
		"smpRate",
		"smvID"
	],
	SamplesPerSec: [],
	SclFileReference: [
		"fileType",
		"revision",
		"version"
	],
	SecPerSamples: [],
	Security: [],
	Server: [],
	ServerAt: ["apName"],
	ServiceSpecifications: [],
	Services: [],
	SetDataSetValue: [],
	SettingControl: ["numOfSGs"],
	SettingGroups: [],
	SignalRole: ["name"],
	SmpRate: [],
	SmvOpts: [],
	SourceFiles: [],
	SourceRef: ["input"],
	SubCategory: ["name"],
	SubCheckoutID: [
		"fileType",
		"revision",
		"version"
	],
	SubEquipment: ["name"],
	SubFunction: ["name"],
	SubFunctionTemplate: ["name"],
	SubNetwork: ["name"],
	Subject: ["commonName", "idHierarchy"],
	SubscriberLNode: ["inputName"],
	Substation: ["name"],
	SupSubscription: ["maxGo", "maxSv"],
	TapChanger: ["name", "type"],
	Terminal: ["cNodeName", "connectivityNode"],
	Text: [],
	TimeSyncProt: [],
	TimerActivatedControl: [],
	TransformerWinding: ["name", "type"],
	TrgOps: [],
	Val: [],
	ValueHandling: [],
	Variable: ["name"],
	VariableApplyTo: [],
	VariableRef: [],
	Voltage: ["unit"],
	VoltageLevel: ["name"]
}, Ru = { v2019C1: /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
	__proto__: null,
	ATTRIBUTES: {
		AccessControl: {},
		AccessPoint: {
			clock: "",
			desc: "",
			kdc: "",
			name: "",
			router: "",
			templateUuid: "",
			uuid: ""
		},
		Address: {},
		AllocationRole: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		AllocationRoleRef: {
			allocationRole: "",
			allocationRoleUuid: "",
			desc: ""
		},
		AnalogueWiringParameters: {
			desc: "",
			dsgInp: "",
			fctInp: "",
			id: "",
			inpNam: "",
			inpRef: ""
		},
		AnalogueWiringParametersRef: {
			desc: "",
			id: ""
		},
		Application: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		ApplicationSclRef: {},
		Association: {
			apRef: "",
			associationID: "",
			desc: "",
			iedName: "",
			initiator: "",
			kind: "",
			ldInst: "",
			lnClass: "",
			lnInst: "",
			lnUuid: "",
			prefix: ""
		},
		Authentication: {
			certificate: "",
			none: "",
			password: "",
			strong: "",
			weak: ""
		},
		BDA: {
			bType: "",
			count: "",
			desc: "",
			name: "",
			sAddr: "",
			type: "",
			valImport: "",
			valKind: ""
		},
		Bay: {
			desc: "",
			name: "",
			templateUuid: "",
			uuid: ""
		},
		BayType: {},
		BehaviorDescription: {
			desc: "",
			fileReference: "",
			format: "",
			isSimulation: "",
			isSpecification: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		BehaviorDescriptionRef: {
			behaviorDescription: "",
			behaviorDescriptionUuid: "",
			desc: ""
		},
		BehaviorReference: {
			behaviorReference: "",
			behaviorUuid: "",
			desc: ""
		},
		BinaryWiringParameters: {
			debTm: "",
			desc: "",
			fastOutput: "",
			id: "",
			inpNam: "",
			inpRef: "",
			outNam: "",
			outOffDl: "",
			outOnDl: "",
			outRef: "",
			outTyp: "",
			vInOff: "",
			vInOn: ""
		},
		BinaryWiringParametersRef: {
			desc: "",
			id: ""
		},
		BitRate: {
			multiplier: "",
			unit: ""
		},
		CheckoutID: {
			desc: "",
			engRight: "",
			fileName: "",
			fileType: "",
			fileUuid: "",
			headerId: "",
			revision: "",
			version: "",
			when: ""
		},
		ClientLN: {
			apRef: "",
			desc: "",
			iedName: "",
			ldInst: "",
			lnClass: "",
			lnInst: "",
			lnUuid: "",
			prefix: ""
		},
		ClientServices: {
			acceptServerInitiatedAssociation: "",
			bufReport: "",
			goose: "",
			gsse: "",
			maxAttributes: "",
			maxGOOSE: "",
			maxReports: "",
			maxSMV: "",
			noIctBinding: "",
			rGOOSE: "",
			rSV: "",
			readLog: "",
			supportsLdName: "",
			sv: "",
			unbufReport: ""
		},
		CommProt: { ipv6: "" },
		Communication: { desc: "" },
		CommunicationServiceSpecifications: { desc: "" },
		ConductingEquipment: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: "",
			virtual: ""
		},
		ConfDataSet: {
			max: "",
			maxAttributes: "",
			modify: ""
		},
		ConfLNs: {
			fixLnInst: "",
			fixPrefix: ""
		},
		ConfLdName: {},
		ConfLogControl: { max: "" },
		ConfReportControl: {
			bufConf: "",
			bufMode: "",
			max: "",
			maxBuf: ""
		},
		ConfSG: { resvTms: "" },
		ConfSigRef: { max: "" },
		ConnectedAP: {
			apName: "",
			apUuid: "",
			desc: "",
			iedName: "",
			redProt: ""
		},
		ConnectivityNode: {
			desc: "",
			name: "",
			pathName: "",
			templateUuid: "",
			uuid: ""
		},
		ControlRef: {
			controlled: "",
			controlledDoName: "",
			controlledLNodeUuid: "",
			desc: "",
			extCtrlAddr: "",
			extCtrlUuid: "",
			originUuid: "",
			output: "",
			outputInst: "",
			pDO: "",
			pLN: "",
			resourceName: "",
			resourceUuid: "",
			templateUuid: "",
			uuid: ""
		},
		ControllingLNode: {
			desc: "",
			outputName: "",
			pLN: "",
			resourceName: "",
			resourceUuid: ""
		},
		DA: {
			bType: "",
			count: "",
			dchg: "",
			desc: "",
			dupd: "",
			fc: "",
			name: "",
			qchg: "",
			sAddr: "",
			type: "",
			valImport: "",
			valKind: ""
		},
		DAI: {
			desc: "",
			ix: "",
			name: "",
			sAddr: "",
			valImport: "",
			valKind: ""
		},
		DAS: {
			desc: "",
			ix: "",
			mappedDaName: "",
			mappedLnUuid: "",
			name: "",
			valImport: "",
			valKind: ""
		},
		DAType: {
			desc: "",
			id: "",
			iedType: ""
		},
		DO: {
			accessControl: "",
			desc: "",
			name: "",
			transient: "",
			type: ""
		},
		DOI: {
			accessControl: "",
			desc: "",
			ix: "",
			name: ""
		},
		DOS: {
			desc: "",
			mappedDoName: "",
			mappedLnUuid: "",
			name: ""
		},
		DOType: {
			cdc: "",
			desc: "",
			id: "",
			iedType: ""
		},
		DataObjectDirectory: {},
		DataSet: {
			desc: "",
			name: "",
			templateUuid: "",
			uuid: ""
		},
		DataSetDirectory: {},
		DataTypeTemplates: {},
		DynAssociation: { max: "" },
		DynDataSet: {
			max: "",
			maxAttributes: ""
		},
		EnumType: {
			desc: "",
			id: ""
		},
		EnumVal: {
			desc: "",
			ord: ""
		},
		EqFunction: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		EqSubFunction: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		ExtCtrl: {
			apRef: "",
			checkInterlock: "",
			checkSynchrocheck: "",
			desc: "",
			doName: "",
			iedName: "",
			intAddr: "",
			ldInst: "",
			lnClass: "",
			lnInst: "",
			lnUuid: "",
			pDO: "",
			pLN: "",
			prefix: "",
			templateUuid: "",
			uuid: ""
		},
		ExtRef: {
			daName: "",
			desc: "",
			doName: "",
			iedName: "",
			intAddr: "",
			ldInst: "",
			lnClass: "",
			lnInst: "",
			lnUuid: "",
			pDA: "",
			pDO: "",
			pLN: "",
			pServT: "",
			prefix: "",
			serviceType: "",
			srcCBName: "",
			srcCBUuid: "",
			srcLDInst: "",
			srcLNClass: "",
			srcLNInst: "",
			srcPrefix: "",
			templateUuid: "",
			uuid: ""
		},
		FCDA: {
			daName: "",
			doName: "",
			fc: "",
			ix: "",
			ldInst: "",
			lnClass: "",
			lnInst: "",
			lnUuid: "",
			prefix: ""
		},
		FileHandling: {
			ftp: "",
			ftps: "",
			mms: ""
		},
		Function: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		FunctionCatRef: {
			function: "",
			functionUuid: ""
		},
		FunctionCategory: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		FunctionCategoryRef: {
			desc: "",
			functionCategory: "",
			functionCategoryUuid: ""
		},
		FunctionRef: {
			desc: "",
			function: "",
			functionUuid: ""
		},
		FunctionRole: {
			cardinality: "",
			desc: "",
			max: "",
			name: "",
			originUuid: "",
			selector: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		FunctionRoleContent: { roleInst: "" },
		FunctionSclRef: {},
		FunctionTemplate: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		FunctionalSubVariant: {
			desc: "",
			isBaseline: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		FunctionalVariant: {
			desc: "",
			isBaseline: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		FunctionalVariantGroup: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		FunctionalVariantRef: {
			functionalVariant: "",
			functionalVariantUuid: "",
			update: ""
		},
		GOOSE: {
			fixedOffs: "",
			goose: "",
			max: "",
			rGOOSE: ""
		},
		GOOSEMcSecurity: {
			encryption: "",
			signature: ""
		},
		GOOSESecurity: {
			desc: "",
			name: "",
			serialNumber: "",
			templateUuid: "",
			uuid: "",
			xferNumber: ""
		},
		GSE: {
			cbName: "",
			cbUuid: "",
			desc: "",
			ldInst: ""
		},
		GSEControl: {
			appID: "",
			confRev: "",
			datSet: "",
			desc: "",
			fixedOffs: "",
			name: "",
			securityEnable: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		GSEDir: {},
		GSESettings: {
			appID: "",
			cbName: "",
			datSet: "",
			dataLabel: "",
			kdaParticipant: ""
		},
		GSSE: { max: "" },
		GeneralEquipment: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: "",
			virtual: ""
		},
		GetCBValues: {},
		GetDataObjectDefinition: {},
		GetDataSetValue: {},
		GetDirectory: {},
		GooseParameters: {
			cbName: "",
			desc: "",
			dsName: "",
			goId: "",
			id: "",
			maxTime: "",
			minTime: "",
			securityEnabled: ""
		},
		GooseParametersRef: {
			desc: "",
			id: ""
		},
		Header: {
			baseUuid: "",
			fileType: "",
			id: "",
			nameStructure: "",
			revision: "",
			toolID: "",
			uuid: "",
			version: ""
		},
		History: {},
		Hitem: {
			revision: "",
			version: "",
			what: "",
			when: "",
			who: "",
			why: ""
		},
		IED: {
			configVersion: "",
			desc: "",
			engRight: "",
			manufacturer: "",
			name: "",
			originalSclRelease: "",
			originalSclRevision: "",
			originalSclVersion: "",
			owner: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		IEDName: {
			apRef: "",
			apUuid: "",
			ldInst: "",
			ldUuid: "",
			lnClass: "",
			lnInst: "",
			lnUuid: "",
			prefix: ""
		},
		IEDSourceFiles: {},
		InputVar: {
			daName: "",
			dataName: "",
			desc: "",
			doName: "",
			inputName: "",
			inputUuid: "",
			lnodeUuid: "",
			value: "",
			varName: ""
		},
		InputVarRef: {
			desc: "",
			value: "",
			variable: ""
		},
		Inputs: { desc: "" },
		IssuerName: {
			commonName: "",
			idHierarchy: ""
		},
		KDC: {
			apName: "",
			apUuid: "",
			iedName: ""
		},
		L2CommParameters: {
			appId: "",
			desc: "",
			macAddr: "",
			vlanId: "",
			vlanPriority: ""
		},
		L3IPv4CommParameters: {
			IPv4: "",
			"IPv4-IGMPv3Src": "",
			appId: "",
			desc: "",
			vlanId: "",
			vlanPriority: ""
		},
		L3IPv6CommParameters: {
			IPv6: "",
			"IPv6-IGMPv3Src": "",
			appId: "",
			desc: "",
			vlanId: "",
			vlanPriority: ""
		},
		LDevice: {
			desc: "",
			inst: "",
			ldName: "",
			templateUuid: "",
			uuid: ""
		},
		LN: {
			desc: "",
			inst: "",
			lnClass: "",
			lnType: "",
			prefix: "",
			templateUuid: "",
			uuid: ""
		},
		LN0: {
			desc: "",
			inst: "",
			lnClass: "",
			lnType: "",
			templateUuid: "",
			uuid: ""
		},
		LNode: {
			desc: "",
			iedName: "",
			ldInst: "",
			lnClass: "",
			lnInst: "",
			lnType: "",
			lnUuid: "",
			prefix: "",
			templateUuid: "",
			uuid: ""
		},
		LNodeDataRef: {
			daName: "",
			data: "",
			desc: "",
			doName: "",
			lnodeUuid: ""
		},
		LNodeInputRef: {
			desc: "",
			sourceRef: "",
			sourceRefUuid: ""
		},
		LNodeInputs: { desc: "" },
		LNodeOutputRef: {
			controlRef: "",
			controlRefUuid: "",
			desc: ""
		},
		LNodeOutputs: { desc: "" },
		LNodeSpecNaming: {
			sIedName: "",
			sLdInst: "",
			sLnClass: "",
			sLnInst: "",
			sPrefix: ""
		},
		LNodeType: {
			desc: "",
			id: "",
			iedType: "",
			lnClass: ""
		},
		Label: {
			id: "",
			lang: ""
		},
		Labels: { desc: "" },
		Line: {
			desc: "",
			name: "",
			nomFreq: "",
			numPhases: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		Log: {
			desc: "",
			name: ""
		},
		LogControl: {
			bufTime: "",
			datSet: "",
			desc: "",
			intgPd: "",
			ldInst: "",
			lnClass: "",
			lnInst: "",
			logEna: "",
			logName: "",
			name: "",
			prefix: "",
			reasonCode: "",
			templateUuid: "",
			uuid: ""
		},
		LogParameters: {
			cbName: "",
			desc: "",
			dsName: "",
			id: "",
			intgPd: "",
			logEna: "",
			logLdInst: "",
			logLnClass: "",
			logLnInst: "",
			logName: "",
			logPrefix: "",
			reasonCode: ""
		},
		LogParametersRef: {
			desc: "",
			id: ""
		},
		LogSettings: {
			cbName: "",
			datSet: "",
			intgPd: "",
			logEna: "",
			trgOps: ""
		},
		MaxTime: {
			multiplier: "",
			unit: ""
		},
		McSecurity: {
			encryption: "",
			signature: ""
		},
		MinRequestedSCDFile: {
			desc: "",
			fileName: "",
			fileType: "",
			fileUuid: "",
			revision: "",
			version: "",
			when: ""
		},
		MinRequestedSCDFiles: {},
		MinTime: {
			multiplier: "",
			unit: ""
		},
		MultiAPPerSubNet: {},
		NeutralPoint: {
			bayName: "",
			cNodeName: "",
			cNodeUuid: "",
			connectivityNode: "",
			desc: "",
			lineName: "",
			name: "",
			processName: "",
			substationName: "",
			voltageLevelName: ""
		},
		OptFields: {
			bufOvfl: "",
			configRef: "",
			dataRef: "",
			dataSet: "",
			entryID: "",
			reasonCode: "",
			seqNum: "",
			timeStamp: ""
		},
		OutputVar: {
			daName: "",
			dataName: "",
			desc: "",
			doName: "",
			lnodeUuid: "",
			outputName: "",
			outputUuid: "",
			value: "",
			varName: ""
		},
		OutputVarRef: {
			desc: "",
			value: "",
			variable: ""
		},
		Outputs: { desc: "" },
		P: { type: "" },
		PhysConn: {
			desc: "",
			type: ""
		},
		PowerSystemRelation: {
			desc: "",
			name: "",
			originUuid: "",
			relation: "",
			relationUuid: "",
			selector: "",
			templateUuid: "",
			uuid: ""
		},
		PowerSystemRelationRef: {
			desc: "",
			powerSystemRelation: "",
			powerSystemRelationUuid: ""
		},
		PowerSystemRelations: { desc: "" },
		PowerTransformer: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: "",
			virtual: ""
		},
		Private: {
			source: "",
			type: ""
		},
		Process: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		ProcessEcho: {
			desc: "",
			source: "",
			sourceDaName: "",
			sourceDoName: "",
			sourceLNodeUuid: ""
		},
		ProcessResource: {
			cardinality: "",
			desc: "",
			max: "",
			name: "",
			originUuid: "",
			selector: "",
			templateUuid: "",
			uuid: ""
		},
		ProcessResourceRef: {
			desc: "",
			processResource: "",
			processResourceUuid: ""
		},
		ProcessResources: { desc: "" },
		Project: {
			desc: "",
			name: "",
			uuid: ""
		},
		ProjectProcessReference: {
			desc: "",
			processReference: "",
			processUuid: ""
		},
		ProtNs: { type: "" },
		Protocol: { mustUnderstand: "" },
		ReadWrite: {},
		RedProt: {
			hsr: "",
			prp: "",
			rstp: ""
		},
		ReportControl: {
			bufTime: "",
			buffered: "",
			confRev: "",
			datSet: "",
			desc: "",
			indexed: "",
			intgPd: "",
			name: "",
			rptID: "",
			templateUuid: "",
			uuid: ""
		},
		ReportParameters: {
			bufTime: "",
			buffered: "",
			cbName: "",
			desc: "",
			dsName: "",
			id: "",
			intgPd: ""
		},
		ReportParametersRef: {
			desc: "",
			id: ""
		},
		ReportSettings: {
			bufTime: "",
			cbName: "",
			datSet: "",
			intgPd: "",
			optFields: "",
			owner: "",
			resvTms: "",
			rptID: "",
			trgOps: ""
		},
		Resource: {
			resInst: "",
			source: "",
			sourceUuid: ""
		},
		RptEnabled: {
			desc: "",
			max: ""
		},
		SCL: {
			release: "",
			revision: "",
			version: ""
		},
		SCSM: {
			iec61850_8_1: "",
			iec61850_8_2: "",
			serverAssociationInitiation: ""
		},
		SDI: {
			desc: "",
			ix: "",
			name: "",
			sAddr: ""
		},
		SDO: {
			count: "",
			desc: "",
			name: "",
			type: ""
		},
		SDS: {
			desc: "",
			ix: "",
			mappedDoName: "",
			mappedLnUuid: "",
			name: ""
		},
		SGEdit: { resvTms: "" },
		SMV: {
			cbName: "",
			cbUuid: "",
			desc: "",
			ldInst: ""
		},
		SMVParameters: {
			cbName: "",
			desc: "",
			dsName: "",
			id: "",
			multicast: "",
			nofASDU: "",
			securityEnabled: "",
			smpMod: "",
			smpRate: "",
			smvId: ""
		},
		SMVParametersRef: {
			desc: "",
			id: ""
		},
		SMVSecurity: {
			desc: "",
			name: "",
			serialNumber: "",
			templateUuid: "",
			uuid: "",
			xferNumber: ""
		},
		SMVSettings: {
			cbName: "",
			datSet: "",
			kdaParticipant: "",
			nofASDU: "",
			optFields: "",
			pdcTimeStamp: "",
			samplesPerSec: "",
			smpRate: "",
			svID: "",
			synchSrcId: ""
		},
		SMVsc: {
			delivery: "",
			deliveryConf: "",
			max: "",
			rSV: "",
			sv: ""
		},
		SVMcSecurity: {
			encryption: "",
			signature: ""
		},
		SampledValueControl: {
			confRev: "",
			datSet: "",
			desc: "",
			multicast: "",
			name: "",
			nofASDU: "",
			securityEnable: "",
			smpMod: "",
			smpRate: "",
			smvID: "",
			templateUuid: "",
			uuid: ""
		},
		SamplesPerSec: {},
		SclFileReference: {
			desc: "",
			fileName: "",
			fileType: "",
			fileUuid: "",
			revision: "",
			version: "",
			when: ""
		},
		SecPerSamples: {},
		Security: {
			ACSEAuthentication: "",
			E2ESecurity: ""
		},
		Server: {
			desc: "",
			timeout: ""
		},
		ServerAt: {
			apName: "",
			apUuid: "",
			desc: ""
		},
		ServiceSpecifications: { desc: "" },
		Services: { nameLength: "" },
		SetDataSetValue: {},
		SettingControl: {
			actSG: "",
			desc: "",
			numOfSGs: "",
			resvTms: ""
		},
		SettingGroups: {},
		SignalRole: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		SmpRate: {},
		SmvOpts: {
			dataSet: "",
			refreshTime: "",
			sampleMode: "",
			sampleRate: "",
			sampleSynchronized: "",
			security: "",
			synchSourceId: "",
			timestamp: ""
		},
		SourceFiles: {},
		SourceRef: {
			desc: "",
			extRefAddr: "",
			extRefUuid: "",
			input: "",
			inputInst: "",
			originUuid: "",
			pDA: "",
			pDO: "",
			pLN: "",
			resourceName: "",
			resourceUuid: "",
			service: "",
			source: "",
			sourceDaName: "",
			sourceDoName: "",
			sourceLNodeUuid: "",
			templateUuid: "",
			uuid: ""
		},
		SubCategory: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: ""
		},
		SubCheckoutID: {
			desc: "",
			engRight: "",
			fileName: "",
			fileType: "",
			fileUuid: "",
			headerId: "",
			revision: "",
			version: "",
			when: ""
		},
		SubEquipment: {
			desc: "",
			name: "",
			phase: "",
			templateUuid: "",
			uuid: "",
			virtual: ""
		},
		SubFunction: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		SubFunctionTemplate: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		SubNetwork: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: ""
		},
		Subject: {
			commonName: "",
			idHierarchy: ""
		},
		SubscriberLNode: {
			desc: "",
			inputName: "",
			pLN: "",
			resourceName: "",
			resourceUuid: "",
			service: ""
		},
		Substation: {
			desc: "",
			name: "",
			templateUuid: "",
			uuid: ""
		},
		SupSubscription: {
			maxGo: "",
			maxSv: ""
		},
		TapChanger: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: "",
			virtual: ""
		},
		Terminal: {
			bayName: "",
			cNodeName: "",
			cNodeUuid: "",
			connectivityNode: "",
			desc: "",
			lineName: "",
			name: "",
			processName: "",
			substationName: "",
			voltageLevelName: ""
		},
		Text: { source: "" },
		TimeSyncProt: {
			c37_238: "",
			iec61850_9_3: "",
			other: "",
			sntp: ""
		},
		TimerActivatedControl: {},
		TransformerWinding: {
			desc: "",
			name: "",
			templateUuid: "",
			type: "",
			uuid: "",
			virtual: ""
		},
		TrgOps: {
			dchg: "",
			dupd: "",
			gi: "",
			period: "",
			qchg: ""
		},
		Val: { sGroup: "" },
		ValueHandling: { setToRO: "" },
		Variable: {
			desc: "",
			name: "",
			originUuid: "",
			templateUuid: "",
			uuid: "",
			value: ""
		},
		VariableApplyTo: {
			attribute: "",
			daName: "",
			defaultValue: "",
			desc: "",
			doName: "",
			element: "",
			elementUuid: "",
			format: "",
			sGroup: ""
		},
		VariableRef: {
			desc: "",
			value: "",
			variable: "",
			variableUuid: ""
		},
		Voltage: {
			multiplier: "",
			unit: ""
		},
		VoltageLevel: {
			desc: "",
			name: "",
			nomFreq: "",
			numPhases: "",
			templateUuid: "",
			uuid: ""
		}
	},
	CHILDREN: {
		AccessControl: [],
		AccessPoint: [
			"Text",
			"Private",
			"Server",
			"LN",
			"ServerAt",
			"Services",
			"GOOSESecurity",
			"SMVSecurity",
			"Labels"
		],
		Address: ["P"],
		AllocationRole: ["Text", "FunctionRef"],
		AllocationRoleRef: ["Text", "FunctionalVariantRef"],
		AnalogueWiringParameters: ["Text"],
		AnalogueWiringParametersRef: ["Text"],
		Application: [
			"Text",
			"FunctionRole",
			"FunctionalVariant",
			"FunctionalVariantGroup",
			"AllocationRoleRef",
			"ApplicationSclRef"
		],
		ApplicationSclRef: ["Text", "SclFileReference"],
		Association: [],
		Authentication: [],
		BDA: [
			"Text",
			"Private",
			"Val",
			"Labels"
		],
		Bay: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"PowerTransformer",
			"GeneralEquipment",
			"ConductingEquipment",
			"ConnectivityNode",
			"Function"
		],
		BayType: [],
		BehaviorDescription: [
			"Text",
			"InputVar",
			"OutputVar",
			"BehaviorReference"
		],
		BehaviorDescriptionRef: [
			"Text",
			"FunctionalVariantRef",
			"InputVarRef",
			"OutputVarRef"
		],
		BehaviorReference: ["Text"],
		BinaryWiringParameters: ["Text"],
		BinaryWiringParametersRef: ["Text"],
		BitRate: [],
		CheckoutID: ["SubCheckoutID"],
		ClientLN: [],
		ClientServices: [
			"TimeSyncProt",
			"GOOSEMcSecurity",
			"SVMcSecurity",
			"Security"
		],
		CommProt: [],
		Communication: [
			"Text",
			"Private",
			"SubNetwork"
		],
		CommunicationServiceSpecifications: [
			"Text",
			"GooseParameters",
			"SMVParameters",
			"ReportParameters"
		],
		ConductingEquipment: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"Terminal",
			"SubEquipment",
			"EqFunction"
		],
		ConfDataSet: [],
		ConfLNs: [],
		ConfLdName: [],
		ConfLogControl: [],
		ConfReportControl: [],
		ConfSG: [],
		ConfSigRef: [],
		ConnectedAP: [
			"Text",
			"Private",
			"Address",
			"GSE",
			"SMV",
			"PhysConn"
		],
		ConnectivityNode: [
			"Text",
			"Private",
			"Labels",
			"LNode"
		],
		ControlRef: [
			"Text",
			"BinaryWiringParametersRef",
			"AnalogueWiringParametersRef"
		],
		ControllingLNode: [
			"Text",
			"BinaryWiringParametersRef",
			"AnalogueWiringParametersRef"
		],
		DA: [
			"Text",
			"Private",
			"Val",
			"Labels",
			"ProtNs"
		],
		DAI: [
			"Text",
			"Private",
			"Val",
			"Labels"
		],
		DAS: [
			"Text",
			"SubscriberLNode",
			"ControllingLNode",
			"ProcessEcho",
			"LogParametersRef",
			"Val",
			"Labels"
		],
		DAType: [
			"Text",
			"Private",
			"BDA",
			"ProtNs",
			"Labels"
		],
		DO: [
			"Text",
			"Private",
			"Labels"
		],
		DOI: [
			"Text",
			"Private",
			"SDI",
			"DAI",
			"Labels"
		],
		DOS: [
			"Text",
			"SDS",
			"DAS",
			"SubscriberLNode",
			"ControllingLNode",
			"ProcessEcho",
			"LogParametersRef",
			"Labels"
		],
		DOType: [
			"Text",
			"Private",
			"SDO",
			"DA",
			"Labels"
		],
		DataObjectDirectory: [],
		DataSet: [
			"Text",
			"Private",
			"FCDA"
		],
		DataSetDirectory: [],
		DataTypeTemplates: [
			"LNodeType",
			"DOType",
			"DAType",
			"EnumType"
		],
		DynAssociation: [],
		DynDataSet: [],
		EnumType: [
			"Text",
			"Private",
			"EnumVal"
		],
		EnumVal: [],
		EqFunction: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"GeneralEquipment",
			"EqSubFunction"
		],
		EqSubFunction: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"GeneralEquipment",
			"EqSubFunction"
		],
		ExtCtrl: ["Text", "Private"],
		ExtRef: ["Text", "Private"],
		FCDA: [],
		FileHandling: [],
		Function: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"SubFunction",
			"GeneralEquipment",
			"ConductingEquipment"
		],
		FunctionCatRef: ["Text"],
		FunctionCategory: [
			"Text",
			"SubCategory",
			"FunctionCatRef"
		],
		FunctionCategoryRef: ["Text", "FunctionalVariantRef"],
		FunctionRef: [
			"Text",
			"FunctionalVariantRef",
			"SignalRole"
		],
		FunctionRole: [
			"Text",
			"FunctionalVariantRef",
			"FunctionRoleContent"
		],
		FunctionRoleContent: [
			"Text",
			"FunctionRef",
			"BehaviorDescriptionRef",
			"ProcessResourceRef",
			"VariableRef",
			"FunctionCategoryRef",
			"PowerSystemRelationRef"
		],
		FunctionSclRef: ["Text", "SclFileReference"],
		FunctionTemplate: [
			"Text",
			"LNode",
			"SubFunctionTemplate",
			"GeneralEquipment",
			"ConductingEquipment"
		],
		FunctionalSubVariant: [
			"Text",
			"FunctionalSubVariant",
			"VariableRef"
		],
		FunctionalVariant: [
			"Text",
			"FunctionalSubVariant",
			"VariableRef"
		],
		FunctionalVariantGroup: ["Text", "FunctionalVariant"],
		FunctionalVariantRef: ["Text"],
		GOOSE: [],
		GOOSEMcSecurity: [],
		GOOSESecurity: [
			"Text",
			"Private",
			"Labels",
			"Subject",
			"IssuerName"
		],
		GSE: [
			"Text",
			"Private",
			"Address",
			"MinTime",
			"MaxTime"
		],
		GSEControl: [
			"Text",
			"Private",
			"IEDName",
			"Protocol"
		],
		GSEDir: [],
		GSESettings: ["McSecurity"],
		GSSE: [],
		GeneralEquipment: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"EqFunction"
		],
		GetCBValues: [],
		GetDataObjectDefinition: [],
		GetDataSetValue: [],
		GetDirectory: [],
		GooseParameters: [
			"Text",
			"L2CommParameters",
			"L3IPv4CommParameters",
			"L3IPv6CommParameters"
		],
		GooseParametersRef: ["Text"],
		Header: [
			"Text",
			"History",
			"SourceFiles"
		],
		History: ["Hitem"],
		Hitem: ["SourceFiles"],
		IED: [
			"Text",
			"Private",
			"Services",
			"AccessPoint",
			"KDC",
			"IEDSourceFiles",
			"MinRequestedSCDFiles",
			"Labels"
		],
		IEDName: [],
		IEDSourceFiles: [
			"Text",
			"Private",
			"SclFileReference"
		],
		InputVar: ["Text"],
		InputVarRef: ["Text", "FunctionalVariantRef"],
		Inputs: [
			"Text",
			"Private",
			"ExtRef"
		],
		IssuerName: [],
		KDC: [],
		L2CommParameters: ["Text"],
		L3IPv4CommParameters: ["Text"],
		L3IPv6CommParameters: ["Text"],
		LDevice: [
			"Text",
			"Private",
			"LN0",
			"LN",
			"AccessControl",
			"Labels"
		],
		LN: [
			"Text",
			"Private",
			"DataSet",
			"ReportControl",
			"LogControl",
			"DOI",
			"Inputs",
			"Outputs",
			"Log",
			"Labels"
		],
		LN0: [
			"Text",
			"Private",
			"DataSet",
			"ReportControl",
			"LogControl",
			"DOI",
			"Inputs",
			"Outputs",
			"Log",
			"Labels",
			"GSEControl",
			"SampledValueControl",
			"SettingControl"
		],
		LNode: [
			"Text",
			"Private",
			"Labels"
		],
		LNodeDataRef: ["Text", "FunctionalVariantRef"],
		LNodeInputRef: ["Text", "FunctionalVariantRef"],
		LNodeInputs: ["Text", "SourceRef"],
		LNodeOutputRef: ["Text", "FunctionalVariantRef"],
		LNodeOutputs: ["Text", "ControlRef"],
		LNodeSpecNaming: ["Text"],
		LNodeType: [
			"Text",
			"Private",
			"DO",
			"Labels"
		],
		Label: [],
		Labels: [
			"Text",
			"Private",
			"Label"
		],
		Line: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"GeneralEquipment",
			"Function",
			"Voltage",
			"ConductingEquipment",
			"ConnectivityNode"
		],
		Log: ["Text", "Private"],
		LogControl: [
			"Text",
			"Private",
			"TrgOps"
		],
		LogParameters: ["Text"],
		LogParametersRef: ["Text"],
		LogSettings: [],
		MaxTime: [],
		McSecurity: [],
		MinRequestedSCDFile: [],
		MinRequestedSCDFiles: [
			"Text",
			"Private",
			"MinRequestedSCDFile"
		],
		MinTime: [],
		MultiAPPerSubNet: [],
		NeutralPoint: ["Text", "Private"],
		OptFields: [],
		OutputVar: ["Text"],
		OutputVarRef: ["Text", "FunctionalVariantRef"],
		Outputs: [
			"Text",
			"Private",
			"ExtCtrl"
		],
		P: [],
		PhysConn: [
			"Text",
			"Private",
			"P"
		],
		PowerSystemRelation: ["Text"],
		PowerSystemRelationRef: ["Text", "FunctionalVariantRef"],
		PowerSystemRelations: ["Text", "PowerSystemRelation"],
		PowerTransformer: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"TransformerWinding",
			"SubEquipment",
			"EqFunction"
		],
		Private: [],
		Process: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"GeneralEquipment",
			"Function",
			"ConductingEquipment",
			"Substation",
			"Line",
			"Process"
		],
		ProcessEcho: ["Text"],
		ProcessResource: ["Text", "Resource"],
		ProcessResourceRef: ["Text", "FunctionalVariantRef"],
		ProcessResources: ["Text", "ProcessResource"],
		Project: ["Text", "ProjectProcessReference"],
		ProjectProcessReference: ["Text"],
		ProtNs: [],
		Protocol: [],
		ReadWrite: [],
		RedProt: [],
		ReportControl: [
			"Text",
			"Private",
			"TrgOps",
			"OptFields",
			"RptEnabled"
		],
		ReportParameters: ["Text"],
		ReportParametersRef: ["Text"],
		ReportSettings: [],
		Resource: [],
		RptEnabled: [
			"Text",
			"Private",
			"ClientLN"
		],
		SCL: [
			"Text",
			"Private",
			"Header",
			"Substation",
			"Communication",
			"IED",
			"DataTypeTemplates",
			"Line",
			"Process"
		],
		SCSM: [],
		SDI: [
			"Text",
			"Private",
			"SDI",
			"DAI",
			"Labels"
		],
		SDO: [
			"Text",
			"Private",
			"Labels"
		],
		SDS: [
			"Text",
			"SDS",
			"DAS",
			"SubscriberLNode",
			"ControllingLNode",
			"ProcessEcho",
			"LogParametersRef",
			"Labels"
		],
		SGEdit: [],
		SMV: [
			"Text",
			"Private",
			"Address"
		],
		SMVParameters: [
			"Text",
			"L2CommParameters",
			"L3IPv4CommParameters",
			"L3IPv6CommParameters"
		],
		SMVParametersRef: ["Text"],
		SMVSecurity: [
			"Text",
			"Private",
			"Labels",
			"Subject",
			"IssuerName"
		],
		SMVSettings: [
			"SmpRate",
			"SamplesPerSec",
			"SecPerSamples",
			"McSecurity"
		],
		SMVsc: [],
		SVMcSecurity: [],
		SampledValueControl: [
			"Text",
			"Private",
			"IEDName",
			"SmvOpts",
			"Protocol"
		],
		SamplesPerSec: [],
		SclFileReference: ["Text", "Private"],
		SecPerSamples: [],
		Security: [],
		Server: [
			"Text",
			"Private",
			"Authentication",
			"LDevice",
			"Association"
		],
		ServerAt: ["Text", "Private"],
		ServiceSpecifications: [
			"Text",
			"GooseParameters",
			"SMVParameters",
			"ReportParameters",
			"BinaryWiringParameters",
			"AnalogueWiringParameters",
			"LogParameters"
		],
		Services: /* @__PURE__ */ "DynAssociation.SettingGroups.GetDirectory.GetDataObjectDefinition.DataObjectDirectory.GetDataSetValue.SetDataSetValue.DataSetDirectory.ConfDataSet.DynDataSet.ReadWrite.TimerActivatedControl.ConfReportControl.GetCBValues.ConfLogControl.ReportSettings.LogSettings.GSESettings.SMVSettings.GSEDir.GOOSE.GSSE.SMVsc.FileHandling.ConfLNs.ClientServices.ConfLdName.SupSubscription.ConfSigRef.ValueHandling.RedProt.TimeSyncProt.CommProt.SCSM.Security.MultiAPPerSubNet".split("."),
		SetDataSetValue: [],
		SettingControl: ["Text", "Private"],
		SettingGroups: ["SGEdit", "ConfSG"],
		SignalRole: [
			"Text",
			"FunctionalVariantRef",
			"LNodeInputRef",
			"LNodeOutputRef",
			"LNodeDataRef"
		],
		SmpRate: [],
		SmvOpts: [],
		SourceFiles: [
			"Text",
			"Private",
			"SclFileReference"
		],
		SourceRef: [
			"Text",
			"GooseParametersRef",
			"SMVParametersRef",
			"ReportParametersRef",
			"BinaryWiringParametersRef",
			"AnalogueWiringParametersRef"
		],
		SubCategory: [
			"Text",
			"SubCategory",
			"FunctionCatRef"
		],
		SubCheckoutID: ["SubCheckoutID"],
		SubEquipment: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"EqFunction"
		],
		SubFunction: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"GeneralEquipment",
			"ConductingEquipment",
			"SubFunction"
		],
		SubFunctionTemplate: [
			"Text",
			"LNode",
			"GeneralEquipment",
			"ConductingEquipment",
			"SubFunctionTemplate"
		],
		SubNetwork: [
			"Text",
			"Private",
			"Labels",
			"BitRate",
			"ConnectedAP"
		],
		Subject: [],
		SubscriberLNode: [
			"Text",
			"GooseParametersRef",
			"SMVParametersRef",
			"ReportParametersRef",
			"BinaryWiringParametersRef"
		],
		Substation: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"PowerTransformer",
			"GeneralEquipment",
			"VoltageLevel",
			"Function"
		],
		SupSubscription: [],
		TapChanger: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"SubEquipment",
			"EqFunction"
		],
		Terminal: ["Text", "Private"],
		Text: [],
		TimeSyncProt: [],
		TimerActivatedControl: [],
		TransformerWinding: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"Terminal",
			"SubEquipment",
			"TapChanger",
			"NeutralPoint",
			"EqFunction"
		],
		TrgOps: [],
		Val: [],
		ValueHandling: [],
		Variable: ["Text", "VariableApplyTo"],
		VariableApplyTo: ["Text"],
		VariableRef: ["Text", "FunctionalVariantRef"],
		Voltage: [],
		VoltageLevel: [
			"Text",
			"Private",
			"Labels",
			"LNode",
			"PowerTransformer",
			"GeneralEquipment",
			"Voltage",
			"Bay",
			"Function"
		]
	},
	DEFINITION: pu,
	ELEMENT_NAMES: gu,
	PARENTS: {
		AccessControl: ["LDevice"],
		AccessPoint: ["IED"],
		Address: [
			"ConnectedAP",
			"GSE",
			"SMV"
		],
		AllocationRole: [],
		AllocationRoleRef: ["Application"],
		AnalogueWiringParameters: ["ServiceSpecifications"],
		AnalogueWiringParametersRef: [
			"ControlRef",
			"ControllingLNode",
			"SourceRef"
		],
		Application: [],
		ApplicationSclRef: ["Application"],
		Association: ["Server"],
		Authentication: ["Server"],
		BDA: ["DAType"],
		Bay: ["VoltageLevel"],
		BayType: [],
		BehaviorDescription: [],
		BehaviorDescriptionRef: ["FunctionRoleContent"],
		BehaviorReference: ["BehaviorDescription"],
		BinaryWiringParameters: ["ServiceSpecifications"],
		BinaryWiringParametersRef: [
			"ControlRef",
			"ControllingLNode",
			"SourceRef",
			"SubscriberLNode"
		],
		BitRate: ["SubNetwork"],
		CheckoutID: [],
		ClientLN: ["RptEnabled"],
		ClientServices: ["Services"],
		CommProt: ["Services"],
		Communication: ["SCL"],
		CommunicationServiceSpecifications: [],
		ConductingEquipment: [
			"Bay",
			"Function",
			"FunctionTemplate",
			"Line",
			"Process",
			"SubFunction",
			"SubFunctionTemplate"
		],
		ConfDataSet: ["Services"],
		ConfLNs: ["Services"],
		ConfLdName: ["Services"],
		ConfLogControl: ["Services"],
		ConfReportControl: ["Services"],
		ConfSG: ["SettingGroups"],
		ConfSigRef: ["Services"],
		ConnectedAP: ["SubNetwork"],
		ConnectivityNode: ["Bay", "Line"],
		ControlRef: ["LNodeOutputs"],
		ControllingLNode: [
			"DAS",
			"DOS",
			"SDS"
		],
		DA: ["DOType"],
		DAI: ["DOI", "SDI"],
		DAS: ["DOS", "SDS"],
		DAType: ["DataTypeTemplates"],
		DO: ["LNodeType"],
		DOI: ["LN", "LN0"],
		DOS: [],
		DOType: ["DataTypeTemplates"],
		DataObjectDirectory: ["Services"],
		DataSet: ["LN", "LN0"],
		DataSetDirectory: ["Services"],
		DataTypeTemplates: ["SCL"],
		DynAssociation: ["Services"],
		DynDataSet: ["Services"],
		EnumType: ["DataTypeTemplates"],
		EnumVal: ["EnumType"],
		EqFunction: [
			"ConductingEquipment",
			"GeneralEquipment",
			"PowerTransformer",
			"SubEquipment",
			"TapChanger",
			"TransformerWinding"
		],
		EqSubFunction: ["EqFunction", "EqSubFunction"],
		ExtCtrl: ["Outputs"],
		ExtRef: ["Inputs"],
		FCDA: ["DataSet"],
		FileHandling: ["Services"],
		Function: [
			"Bay",
			"Line",
			"Process",
			"Substation",
			"VoltageLevel"
		],
		FunctionCatRef: ["FunctionCategory", "SubCategory"],
		FunctionCategory: [],
		FunctionCategoryRef: ["FunctionRoleContent"],
		FunctionRef: ["AllocationRole", "FunctionRoleContent"],
		FunctionRole: ["Application"],
		FunctionRoleContent: ["FunctionRole"],
		FunctionSclRef: [],
		FunctionTemplate: [],
		FunctionalSubVariant: ["FunctionalSubVariant", "FunctionalVariant"],
		FunctionalVariant: ["Application", "FunctionalVariantGroup"],
		FunctionalVariantGroup: ["Application"],
		FunctionalVariantRef: [
			"AllocationRoleRef",
			"BehaviorDescriptionRef",
			"FunctionCategoryRef",
			"FunctionRef",
			"FunctionRole",
			"InputVarRef",
			"LNodeDataRef",
			"LNodeInputRef",
			"LNodeOutputRef",
			"OutputVarRef",
			"PowerSystemRelationRef",
			"ProcessResourceRef",
			"SignalRole",
			"VariableRef"
		],
		GOOSE: ["Services"],
		GOOSEMcSecurity: ["ClientServices"],
		GOOSESecurity: ["AccessPoint"],
		GSE: ["ConnectedAP"],
		GSEControl: ["LN0"],
		GSEDir: ["Services"],
		GSESettings: ["Services"],
		GSSE: ["Services"],
		GeneralEquipment: [
			"Bay",
			"EqFunction",
			"EqSubFunction",
			"Function",
			"FunctionTemplate",
			"Line",
			"Process",
			"SubFunction",
			"SubFunctionTemplate",
			"Substation",
			"VoltageLevel"
		],
		GetCBValues: ["Services"],
		GetDataObjectDefinition: ["Services"],
		GetDataSetValue: ["Services"],
		GetDirectory: ["Services"],
		GooseParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
		GooseParametersRef: ["SourceRef", "SubscriberLNode"],
		Header: ["SCL"],
		History: ["Header"],
		Hitem: ["History"],
		IED: ["SCL"],
		IEDName: ["GSEControl", "SampledValueControl"],
		IEDSourceFiles: ["IED"],
		InputVar: ["BehaviorDescription"],
		InputVarRef: ["BehaviorDescriptionRef"],
		Inputs: ["LN", "LN0"],
		IssuerName: ["GOOSESecurity", "SMVSecurity"],
		KDC: ["IED"],
		L2CommParameters: ["GooseParameters", "SMVParameters"],
		L3IPv4CommParameters: ["GooseParameters", "SMVParameters"],
		L3IPv6CommParameters: ["GooseParameters", "SMVParameters"],
		LDevice: ["Server"],
		LN: ["AccessPoint", "LDevice"],
		LN0: ["LDevice"],
		LNode: [
			"Bay",
			"ConductingEquipment",
			"ConnectivityNode",
			"EqFunction",
			"EqSubFunction",
			"Function",
			"FunctionTemplate",
			"GeneralEquipment",
			"Line",
			"PowerTransformer",
			"Process",
			"SubEquipment",
			"SubFunction",
			"SubFunctionTemplate",
			"Substation",
			"TapChanger",
			"TransformerWinding",
			"VoltageLevel"
		],
		LNodeDataRef: ["SignalRole"],
		LNodeInputRef: ["SignalRole"],
		LNodeInputs: [],
		LNodeOutputRef: ["SignalRole"],
		LNodeOutputs: [],
		LNodeSpecNaming: [],
		LNodeType: ["DataTypeTemplates"],
		Label: ["Labels"],
		Labels: /* @__PURE__ */ "AccessPoint.BDA.Bay.ConductingEquipment.ConnectivityNode.DA.DAI.DAS.DAType.DO.DOI.DOS.DOType.EqFunction.EqSubFunction.Function.GOOSESecurity.GeneralEquipment.IED.LDevice.LN.LN0.LNode.LNodeType.Line.PowerTransformer.Process.SDI.SDO.SDS.SMVSecurity.SubEquipment.SubFunction.SubNetwork.Substation.TapChanger.TransformerWinding.VoltageLevel".split("."),
		Line: ["Process", "SCL"],
		Log: ["LN", "LN0"],
		LogControl: ["LN", "LN0"],
		LogParameters: ["ServiceSpecifications"],
		LogParametersRef: [
			"DAS",
			"DOS",
			"SDS"
		],
		LogSettings: ["Services"],
		MaxTime: ["GSE"],
		McSecurity: ["GSESettings", "SMVSettings"],
		MinRequestedSCDFile: ["MinRequestedSCDFiles"],
		MinRequestedSCDFiles: ["IED"],
		MinTime: ["GSE"],
		MultiAPPerSubNet: ["Services"],
		NeutralPoint: ["TransformerWinding"],
		OptFields: ["ReportControl"],
		OutputVar: ["BehaviorDescription"],
		OutputVarRef: ["BehaviorDescriptionRef"],
		Outputs: ["LN", "LN0"],
		P: ["Address", "PhysConn"],
		PhysConn: ["ConnectedAP"],
		PowerSystemRelation: ["PowerSystemRelations"],
		PowerSystemRelationRef: ["FunctionRoleContent"],
		PowerSystemRelations: [],
		PowerTransformer: [
			"Bay",
			"Substation",
			"VoltageLevel"
		],
		Private: /* @__PURE__ */ "AccessPoint.BDA.Bay.Communication.ConductingEquipment.ConnectedAP.ConnectivityNode.DA.DAI.DAType.DO.DOI.DOType.DataSet.EnumType.EqFunction.EqSubFunction.ExtCtrl.ExtRef.Function.GOOSESecurity.GSE.GSEControl.GeneralEquipment.IED.IEDSourceFiles.Inputs.LDevice.LN.LN0.LNode.LNodeType.Labels.Line.Log.LogControl.MinRequestedSCDFiles.NeutralPoint.Outputs.PhysConn.PowerTransformer.Process.ReportControl.RptEnabled.SCL.SDI.SDO.SMV.SMVSecurity.SampledValueControl.SclFileReference.Server.ServerAt.SettingControl.SourceFiles.SubEquipment.SubFunction.SubNetwork.Substation.TapChanger.Terminal.TransformerWinding.VoltageLevel".split("."),
		Process: ["Process", "SCL"],
		ProcessEcho: [
			"DAS",
			"DOS",
			"SDS"
		],
		ProcessResource: ["ProcessResources"],
		ProcessResourceRef: ["FunctionRoleContent"],
		ProcessResources: [],
		Project: [],
		ProjectProcessReference: ["Project"],
		ProtNs: ["DA", "DAType"],
		Protocol: ["GSEControl", "SampledValueControl"],
		ReadWrite: ["Services"],
		RedProt: ["Services"],
		ReportControl: ["LN", "LN0"],
		ReportParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
		ReportParametersRef: ["SourceRef", "SubscriberLNode"],
		ReportSettings: ["Services"],
		Resource: ["ProcessResource"],
		RptEnabled: ["ReportControl"],
		SCL: [],
		SCSM: ["Services"],
		SDI: ["DOI", "SDI"],
		SDO: ["DOType"],
		SDS: ["DOS", "SDS"],
		SGEdit: ["SettingGroups"],
		SMV: ["ConnectedAP"],
		SMVParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
		SMVParametersRef: ["SourceRef", "SubscriberLNode"],
		SMVSecurity: ["AccessPoint"],
		SMVSettings: ["Services"],
		SMVsc: ["Services"],
		SVMcSecurity: ["ClientServices"],
		SampledValueControl: ["LN0"],
		SamplesPerSec: ["SMVSettings"],
		SclFileReference: [
			"ApplicationSclRef",
			"FunctionSclRef",
			"IEDSourceFiles",
			"SourceFiles"
		],
		SecPerSamples: ["SMVSettings"],
		Security: ["ClientServices", "Services"],
		Server: ["AccessPoint"],
		ServerAt: ["AccessPoint"],
		ServiceSpecifications: [],
		Services: ["AccessPoint", "IED"],
		SetDataSetValue: ["Services"],
		SettingControl: ["LN0"],
		SettingGroups: ["Services"],
		SignalRole: ["FunctionRef"],
		SmpRate: ["SMVSettings"],
		SmvOpts: ["SampledValueControl"],
		SourceFiles: ["Header", "Hitem"],
		SourceRef: ["LNodeInputs"],
		SubCategory: ["FunctionCategory", "SubCategory"],
		SubCheckoutID: ["CheckoutID", "SubCheckoutID"],
		SubEquipment: [
			"ConductingEquipment",
			"PowerTransformer",
			"TapChanger",
			"TransformerWinding"
		],
		SubFunction: ["Function", "SubFunction"],
		SubFunctionTemplate: ["FunctionTemplate", "SubFunctionTemplate"],
		SubNetwork: ["Communication"],
		Subject: ["GOOSESecurity", "SMVSecurity"],
		SubscriberLNode: [
			"DAS",
			"DOS",
			"SDS"
		],
		Substation: ["Process", "SCL"],
		SupSubscription: ["Services"],
		TapChanger: ["TransformerWinding"],
		Terminal: ["ConductingEquipment", "TransformerWinding"],
		Text: /* @__PURE__ */ "AccessPoint.AllocationRole.AllocationRoleRef.AnalogueWiringParameters.AnalogueWiringParametersRef.Application.ApplicationSclRef.BDA.Bay.BehaviorDescription.BehaviorDescriptionRef.BehaviorReference.BinaryWiringParameters.BinaryWiringParametersRef.Communication.CommunicationServiceSpecifications.ConductingEquipment.ConnectedAP.ConnectivityNode.ControlRef.ControllingLNode.DA.DAI.DAS.DAType.DO.DOI.DOS.DOType.DataSet.EnumType.EqFunction.EqSubFunction.ExtCtrl.ExtRef.Function.FunctionCatRef.FunctionCategory.FunctionCategoryRef.FunctionRef.FunctionRole.FunctionRoleContent.FunctionSclRef.FunctionTemplate.FunctionalSubVariant.FunctionalVariant.FunctionalVariantGroup.FunctionalVariantRef.GOOSESecurity.GSE.GSEControl.GeneralEquipment.GooseParameters.GooseParametersRef.Header.IED.IEDSourceFiles.InputVar.InputVarRef.Inputs.L2CommParameters.L3IPv4CommParameters.L3IPv6CommParameters.LDevice.LN.LN0.LNode.LNodeDataRef.LNodeInputRef.LNodeInputs.LNodeOutputRef.LNodeOutputs.LNodeSpecNaming.LNodeType.Labels.Line.Log.LogControl.LogParameters.LogParametersRef.MinRequestedSCDFiles.NeutralPoint.OutputVar.OutputVarRef.Outputs.PhysConn.PowerSystemRelation.PowerSystemRelationRef.PowerSystemRelations.PowerTransformer.Process.ProcessEcho.ProcessResource.ProcessResourceRef.ProcessResources.Project.ProjectProcessReference.ReportControl.ReportParameters.ReportParametersRef.RptEnabled.SCL.SDI.SDO.SDS.SMV.SMVParameters.SMVParametersRef.SMVSecurity.SampledValueControl.SclFileReference.Server.ServerAt.ServiceSpecifications.SettingControl.SignalRole.SourceFiles.SourceRef.SubCategory.SubEquipment.SubFunction.SubFunctionTemplate.SubNetwork.SubscriberLNode.Substation.TapChanger.Terminal.TransformerWinding.Variable.VariableApplyTo.VariableRef.VoltageLevel".split("."),
		TimeSyncProt: ["ClientServices", "Services"],
		TimerActivatedControl: ["Services"],
		TransformerWinding: ["PowerTransformer"],
		TrgOps: ["LogControl", "ReportControl"],
		Val: [
			"BDA",
			"DA",
			"DAI",
			"DAS"
		],
		ValueHandling: ["Services"],
		Variable: [],
		VariableApplyTo: ["Variable"],
		VariableRef: [
			"FunctionRoleContent",
			"FunctionalSubVariant",
			"FunctionalVariant"
		],
		Voltage: ["Line", "VoltageLevel"],
		VoltageLevel: ["Substation"]
	},
	REQUIRED: du
}, Symbol.toStringTag, { value: "Module" })) }, Au = { default: {
	prefix: "",
	uri: "http://www.iec.ch/61850/2003/SCL"
} };
function Nu(u) {
	return u.reduce((u, T) => {
		if (!T) return u;
		let E = T.tagName, O = u[E] ?? [];
		return O.push(T), u[E] = O, u;
	}, {});
}
function Eu(u) {
	return typeof u == "object" && !!u && "id" in u && "tagName" in u && "namespace" in u && "attributes" in u && "children" in u && !("treeChildren" in u) && !("status" in u);
}
function It(u) {
	return "treeChildren" in u && "status" in u;
}
function Fu(u) {
	return It(u) ? u : {
		...u,
		treeChildren: [],
		status: "unchanged"
	};
}
function Mu(u) {
	if (It(u)) {
		let { treeChildren: T, status: E,...O } = u;
		return O;
	}
	return u;
}
function D(u) {
	let { stagedOperations: T, id: E, tagName: O, throwOnDeleted: M = !0 } = u, P = [...T].reverse().find((u) => u.status === "created" || u.status === "updated" ? u.new.id === E : u.status === "deleted" ? u.old.id === E : !1);
	if (!P) return;
	if (P.status === "deleted") {
		let u = O ? ` ${O}` : "";
		if (M) throw Error(`Element${u} with id ${E} has been deleted`);
	}
	let F = P.status === "deleted" ? P.old : P.new;
	if (F.tagName !== O) throw Error(`Element tagName mismatch: expected ${O}, got ${F.tagName} for id ${E}`);
	return {
		record: F,
		status: P.status
	};
}
function A(u) {
	let { attributes: T, name: E } = u;
	return T.find((u) => u.name === E)?.value || "";
}
function z(u) {
	let { attributes: T } = u;
	return T.reduce((u, T) => {
		let E = T.value || "";
		return u[T.name] = E, u;
	}, {});
}
var _ = [
	"DO",
	"SDO",
	"DA",
	"BDA",
	"EnumVal"
], q$1 = {
	LNodeType: "id",
	DOType: "id",
	DAType: "id",
	EnumType: "id",
	DO: "name",
	SDO: "name",
	DA: "name",
	BDA: "name",
	EnumVal: "ord"
};
function L(u) {
	return q$1[u];
}
function B(u) {
	let { source: T, targets: E } = u, O;
	O = T.tagName === "LNode" || T.tagName === "LN" ? "lnType" : "type";
	let M = T.attributes, P = A({
		attributes: M,
		name: O
	});
	return E.find((u) => {
		let T = L(u.tagName), E = u.attributes;
		return A({
			attributes: E,
			name: T
		}) === P;
	});
}
function x$3(u) {
	let { sources: T, targets: E } = u, O = [];
	for (let u of T) {
		let T = B({
			source: u,
			targets: E
		});
		T && O.push(T);
	}
	return O;
}
function G(u) {
	let { version: T, records: E } = u;
	return E.length === 0 ? !0 : E.every((u) => {
		if (!It(u) || !Ru[T].CHILDREN.DataTypeTemplates.includes(u.tagName)) return !1;
		let E = Ru[T].CHILDREN[u.tagName];
		return u.treeChildren.every((u) => !!(_.includes(u.tagName) || E && E.includes(u.tagName)));
	});
}
function se(u) {
	let { version: T, records: E } = u;
	if (!G({
		version: T,
		records: E
	})) throw Error("Some records are not valid data model records.");
	return E;
}
function oe(u) {
	let { version: T, tagName: E, attributeName: O, value: M, elementId: P } = u, F = Ru[T].DEFINITION[E];
	if (!F || !F.attributes?.details) return;
	let I = F.attributes.details[O];
	if (!I?.validation?.enumeration) return;
	let R = I.validation.enumeration;
	if (!R.includes(M)) throw Error(`Invalid value '${M}' for attribute '${O}' on ${E}(element: ${P}). Expected one of: ${R.join(", ")}`);
}
var ie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
	__proto__: null,
	DATA_MODEL_CHILDREN_TAG_NAMES: _,
	DATA_MODEL_ROOT_ELEMENT_TO_ATTRIBUTE_KEY: q$1,
	areDataModelRecords: G,
	filterDataModelRootElements: x$3,
	getAttributeValueByName: A,
	getAttributesValuesByName: z,
	getDataModelRootElementKeyAttribute: L,
	groupRecordsByTagName: Nu,
	isDatabaseRecord: Eu,
	isTreeRecord: It,
	resolveDataModelRootElementReference: B,
	toDataModelRecords: se,
	toDatabaseRecord: Mu,
	toTreeRecord: Fu,
	validateAttributeValue: oe
}, Symbol.toStringTag, { value: "Module" }));
function ce(u) {
	let { childRecord: T, parentRecord: E, stagedOperations: O } = u;
	function M(u) {
		return D({
			stagedOperations: O,
			id: u,
			tagName: "Private"
		});
	}
	function P(u) {
		return {
			childRecord: {
				...T,
				parent: {
					id: u.id,
					tagName: "Private"
				}
			},
			privateRecord: {
				...u,
				children: [...u.children, {
					id: T.id,
					tagName: T.tagName
				}]
			}
		};
	}
	if (E.tagName === "Private") {
		let u = E, T = M(u.id), O = T && T.status !== "deleted" ? Fu(T.record) : u, { childRecord: F, privateRecord: I } = P(O);
		return {
			childRecord: F,
			privateRecord: I,
			oldPrivateRecord: O,
			updatedParentRecord: I,
			isNewPrivateElement: !1
		};
	}
	let F = E.children.find((u) => u.tagName === "Private");
	if (F) {
		let u = M(F.id);
		if (u) {
			let O = Fu(u.record);
			if (O.attributes.some((u) => u.name === "type" && u.value === T.namespace.prefix)) {
				let { childRecord: u, privateRecord: T } = P(O);
				return {
					childRecord: u,
					privateRecord: T,
					oldPrivateRecord: O,
					updatedParentRecord: E,
					isNewPrivateElement: !1
				};
			}
		}
	}
	let I = {
		id: crypto.randomUUID(),
		tagName: "Private",
		namespace: {
			prefix: Au.default.prefix,
			uri: Au.default.uri
		},
		attributes: [{
			name: "type",
			value: T.namespace.prefix
		}],
		value: "",
		parent: {
			id: E.id,
			tagName: E.tagName
		},
		children: [{
			id: T.id,
			tagName: T.tagName
		}],
		status: "created",
		treeChildren: []
	};
	return {
		childRecord: {
			...T,
			parent: {
				id: I.id,
				tagName: "Private"
			}
		},
		privateRecord: I,
		updatedParentRecord: {
			...E,
			children: [...E.children, {
				id: I.id,
				tagName: "Private"
			}]
		},
		isNewPrivateElement: !0
	};
}
function de(u) {
	let { genericApiBuilder: T, contextPromise: E, extensions: O } = u;
	return function(u) {
		let { tagName: M, attributes: P, namespace: F, value: I, setFocus: R = !1 } = u, V = crypto.randomUUID();
		return T({
			contextPromise: E.then((u) => {
				let T, E;
				if (Ru[u.version].DEFINITION.hasOwnProperty(M)) {
					E = Ru[u.version].DEFINITION[M].namespace;
					let O = Ru[u.version].DEFINITION[M].attributes.details;
					T = Array.isArray(P) ? P : Object.entries(P).map(([u, T]) => {
						let E = u;
						return {
							name: E,
							value: E === "uuid" ? crypto.randomUUID() : T,
							namespace: O[E]?.namespace
						};
					});
					let F = Object.keys(Ru[u.version].ATTRIBUTES[M]).includes("uuid"), I = T.some((u) => u.name === "uuid");
					if (F && !I) {
						let u = "uuid";
						T.push({
							name: u,
							value: crypto.randomUUID(),
							namespace: O[u]?.namespace
						});
					}
				} else E = F ?? {
					prefix: "",
					uri: ""
				}, T = Array.isArray(P) ? P : [];
				let O = {
					id: V,
					tagName: M,
					namespace: E,
					attributes: T,
					value: I ?? "",
					parent: {
						id: u.currentFocus.id,
						tagName: u.currentFocus.tagName
					},
					children: [],
					status: "created",
					treeChildren: []
				};
				if (O.namespace.prefix !== Au.default.prefix) {
					let { childRecord: T, privateRecord: E, oldPrivateRecord: M, updatedParentRecord: P, isNewPrivateElement: F } = ce({
						childRecord: O,
						parentRecord: u.currentFocus,
						stagedOperations: u.stagedOperations
					});
					if (F && b$1({
						context: u,
						status: "created",
						record: E
					}), b$1({
						context: u,
						status: "created",
						record: T
					}), !F && M && b$1({
						context: u,
						status: "updated",
						old: M,
						new: E
					}), b$1({
						context: u,
						status: "updated",
						old: Mu(u.currentFocus),
						new: P
					}), R) return {
						...u,
						currentFocus: T
					};
					{
						let T = {
							...u.currentFocus,
							...P
						};
						return {
							...u,
							currentFocus: T
						};
					}
				} else {
					b$1({
						context: u,
						status: "created",
						record: O
					});
					let T = {
						...u.currentFocus,
						children: [...u.currentFocus.children, {
							id: O.id,
							tagName: O.tagName
						}]
					};
					return b$1({
						context: u,
						status: "updated",
						old: Mu(u.currentFocus),
						new: Mu(T)
					}), R ? {
						...u,
						currentFocus: O
					} : {
						...u,
						currentFocus: T
					};
				}
			}),
			extensions: O,
			tagName: M
		});
	};
}
function ue(u) {
	let { genericApiBuilder: T, contextPromise: E, extensions: O } = u;
	return function(u) {
		let { record: M, setFocus: P = !1 } = u;
		return T({
			contextPromise: E.then(async (u) => {
				function E(u) {
					return 1 + u.treeChildren.reduce((u, T) => u + E(T), 0);
				}
				let F = E(M), I = 0;
				function R(T, E) {
					let O = T.addChild({
						tagName: E.tagName,
						namespace: E.namespace,
						attributes: E.attributes,
						value: E.value,
						setFocus: !0
					});
					I++, u.onProgress && u.onProgress({
						current: I,
						total: F,
						message: `Cloning ${E.tagName}`,
						scope: "deepCloneChild"
					});
					let M = O;
					for (let u of E.treeChildren) M = R(M, u), M = M.goToParent();
					return M;
				}
				let V = T({
					contextPromise: Promise.resolve(u),
					extensions: O,
					tagName: u.currentFocus.tagName
				});
				return V = R(V, M), P || (V = V.goToParent()), await V.getContext();
			}),
			extensions: O,
			tagName: M.tagName
		});
	};
}
function le(u) {
	let { genericApiBuilder: T, contextPromise: E, extensions: O, tagName: M } = u;
	return function(u) {
		let { attributes: P, value: F } = u;
		return T({
			contextPromise: E.then(async (u) => {
				let T = [...u.currentFocus.attributes];
				if (P) for (let u of P) {
					let E = T.findIndex((T) => T.name === u.name);
					if (u.value === "" || u.value === void 0 || u.value === null) {
						E >= 0 && T.splice(E, 1);
						continue;
					}
					let O = {
						name: u.name,
						value: String(u.value),
						...u.namespace && { namespace: u.namespace }
					};
					E >= 0 ? T[E] = O : T.push(O);
				}
				let E = Ru[u.version].DEFINITION[u.currentFocus.tagName].namespace, O = u.currentFocus.namespace?.prefix === E.prefix, M = {
					...u.currentFocus,
					namespace: E && !O ? E : u.currentFocus.namespace,
					attributes: P ? T : u.currentFocus.attributes,
					value: F ?? u.currentFocus.value
				};
				return b$1({
					context: u,
					status: "updated",
					old: Mu(u.currentFocus),
					new: Mu(M)
				}), {
					...u,
					currentFocus: M
				};
			}),
			extensions: O,
			tagName: M
		});
	};
}
function me(u) {
	let { genericApiBuilder: T, contextPromise: E, extensions: O } = u;
	return function() {
		let u;
		return T({
			contextPromise: E.then(async (T) => {
				let E = T.currentFocus.id;
				b$1({
					context: T,
					status: "deleted",
					record: Mu(T.currentFocus)
				});
				let O = T.currentFocus.parent;
				if (!O) throw Error("Cannot delete element without a parent");
				u = O.tagName, await M(T.currentFocus.children);
				async function M(u) {
					for (let E of u) {
						let u, O = D({
							stagedOperations: T.stagedOperations,
							id: E.id,
							tagName: E.tagName,
							throwOnDeleted: !1
						});
						if (!O) u = await T.databaseInstance.sclElements.get({
							id: E.id,
							tagName: E.tagName
						});
						else {
							if (O.status === "deleted") continue;
							u = O.record;
						}
						u && (u.children && u.children.length > 0 && await M(u.children), b$1({
							context: T,
							status: "deleted",
							record: u
						}));
					}
				}
				let P = D({
					stagedOperations: T.stagedOperations,
					id: O.id,
					tagName: O.tagName
				}), F;
				if (F = P ? P.record : await T.databaseInstance.sclElements.get({
					id: O.id,
					tagName: O.tagName
				}), !F) throw Error("Parent record not found in staged operations or database");
				let I = {
					...Fu(F),
					children: F.children.filter((u) => u.id !== E)
				};
				return b$1({
					context: T,
					status: "updated",
					old: Mu(F),
					new: Mu(I)
				}), {
					...T,
					currentFocus: I
				};
			}),
			extensions: O,
			tagName: u
		});
	};
}
function b$1(u) {
	let { context: T, status: E, record: O, old: M, new: P } = u;
	if (E === "created") {
		if (!O) throw Error("record is required for created");
		T.stagedOperations.push({
			status: E,
			old: void 0,
			new: O
		});
	} else if (E === "updated") {
		if (!M || !P) throw Error("old and new are required for update");
		T.stagedOperations.push({
			status: E,
			old: M,
			new: P
		});
	} else if (E === "deleted") {
		if (!O) throw Error("record is required for deleted");
		T.stagedOperations.push({
			status: E,
			old: O,
			new: void 0
		});
	}
}
function fe(u) {
	let { genericApiBuilder: T, contextPromise: E, extensions: O } = u;
	function M(u) {
		let { tagName: M, id: P } = u;
		return T({
			contextPromise: E.then(async (u) => {
				let T, E = M === "SCL" || M === "Header" || M === "Communication" || M === "DataTypeTemplates";
				if (P) {
					let E = D({
						stagedOperations: u.stagedOperations,
						id: P,
						tagName: M
					});
					E && E.status !== "deleted" && (T = E.record);
				}
				if (!T) if (E && !P) T = await u.databaseInstance[ou].where("tagName").equals(M).first();
				else if (P) T = await u.databaseInstance[ou].get({
					id: P,
					tagName: M
				});
				else throw Error(`Element ${M} requires an id parameter`);
				if (!T) {
					let u = P ? ` with id ${P}` : "";
					throw Error(`No element ${M}${u} found in database`);
				}
				if (T.tagName !== M) throw Error("Element tagName mismatch");
				let O = Fu(T);
				return {
					...u,
					entrypoint: O,
					currentFocus: O
				};
			}),
			extensions: O,
			tagName: M
		});
	}
	return M;
}
function ge(u) {
	let { genericApiBuilder: T, contextPromise: E, extensions: O } = u;
	return function() {
		let u;
		return T({
			contextPromise: E.then(async (T) => {
				let E = T.currentFocus.parent;
				if (!E) throw Error("No parent found");
				u = E.tagName;
				let O = D({
					stagedOperations: T.stagedOperations,
					id: E.id,
					tagName: E.tagName
				}), M;
				if (O) M = O.record;
				else {
					let u = await T.databaseInstance[ou].get({
						id: E.id,
						tagName: E.tagName
					});
					if (!u) throw Error("Parent record not found in database");
					M = u;
				}
				return {
					...T,
					currentFocus: Fu(M)
				};
			}),
			extensions: O,
			tagName: u
		});
	};
}
function H(u) {
	let T = /* @__PURE__ */ new Map();
	if (!u) return T;
	for (let E of u) typeof E == "string" ? T.set(E, { withAllDescendants: !1 }) : typeof E == "object" && "tagName" in E && T.set(E.tagName, {
		withAllDescendants: !!E.withAllDescendants,
		attributes: E.attributes,
		nestedPick: E.pick,
		nestedExclude: E.exclude
	});
	return T;
}
function K(u) {
	let T = /* @__PURE__ */ new Map();
	if (!u) return T;
	for (let E of u) typeof E == "string" ? T.set(E, { withAllDescendants: !1 }) : typeof E == "object" && "tagName" in E && T.set(E.tagName, {
		withAllDescendants: !1,
		attributes: E.attributes
	});
	return T;
}
function $$1(u, T) {
	if (!T || Object.keys(T).length === 0) return !0;
	for (let [E, O] of Object.entries(T)) {
		let T = A({
			attributes: u.attributes,
			name: E
		});
		if (T === "") return !1;
		if (Array.isArray(O)) {
			if (!O.some((u) => T === u)) return !1;
		} else if (T !== O) return !1;
	}
	return !0;
}
function W$1(u, T, E, O) {
	let { pickMap: M, excludeMap: P } = T, F = u.tagName;
	if (F === "Private" && !O) return {
		shouldInclude: !1,
		nextIncludeAllDescendants: !1
	};
	let I = P.get(F);
	if (I && $$1(u, I.attributes)) return {
		shouldInclude: !1,
		nextIncludeAllDescendants: !1
	};
	if (E) return {
		shouldInclude: !0,
		nextIncludeAllDescendants: !0
	};
	if (M.size > 0) {
		let T = M.get(F);
		return T && $$1(u, T.attributes) ? {
			shouldInclude: !0,
			nextIncludeAllDescendants: T.withAllDescendants,
			nestedPickMap: T.nestedPick ? H(T.nestedPick) : void 0,
			nestedExcludeMap: T.nestedExclude ? K(T.nestedExclude) : void 0
		} : {
			shouldInclude: !1,
			nextIncludeAllDescendants: !1
		};
	}
	return {
		shouldInclude: !0,
		nextIncludeAllDescendants: !1
	};
}
function Q(u) {
	let T = /* @__PURE__ */ new Set();
	if (!u) return T;
	for (let E of u) if (typeof E == "string") T.add(E);
	else if (typeof E == "object" && "tagName" in E && (T.add(E.tagName), E.pick)) for (let u of Q(E.pick)) T.add(u);
	return T;
}
function pe(u) {
	let T = /* @__PURE__ */ new Map();
	for (let E of u) {
		let u = E.status === "deleted" ? E.old.id : E.status === "created" || E.status === "updated" ? E.new.id : null;
		u && !T.has(u) && T.set(u, E);
	}
	return T;
}
function he(u, T) {
	return T.get(u)?.status ?? "unchanged";
}
function j(u, T) {
	let E = T ? he(u.id, T) : "unchanged";
	return {
		...u,
		status: E
	};
}
function Ne(u) {
	let { currentFocus: T, stagedOperations: E } = u, O = D({
		stagedOperations: E,
		id: T.id,
		tagName: T.tagName,
		throwOnDeleted: !1
	});
	return O?.status === "deleted" ? null : O ? O.record : T;
}
async function Y$1(u, T) {
	let { depth: E, filter: O, withPrivate: M = !1, flatten: P = !1 } = T ?? {}, F = Ne(u);
	if (!F) throw Error("Current focus has been deleted");
	let I = await S$1({
		context: u,
		record: F,
		currentDepth: 0,
		stagedOperationsMap: pe(u.stagedOperations),
		filterMaps: {
			pickMap: H(O?.pick),
			excludeMap: K(O?.exclude)
		},
		includeAllDescendants: !1,
		depth: E,
		withPrivate: M
	});
	return P && O?.pick ? Nu(X$1(I, Q(O.pick))) : I;
}
async function S$1(u) {
	let { context: T, record: E, currentDepth: O, stagedOperationsMap: M, filterMaps: P, includeAllDescendants: F, depth: I, withPrivate: R } = u, V = await we(T, E);
	if (I !== void 0 && O >= I && E.tagName !== "Private" && !R) return j({
		...E,
		treeChildren: []
	}, M);
	let U = [];
	for (let u of V) {
		let E = W$1(u, P, F, R), V = {
			pickMap: E.nestedPickMap ?? P.pickMap,
			excludeMap: E.nestedExcludeMap ?? P.excludeMap
		}, Dp = {
			context: T,
			record: u,
			currentDepth: O + 1,
			stagedOperationsMap: M,
			filterMaps: V,
			includeAllDescendants: E.nextIncludeAllDescendants,
			depth: I,
			withPrivate: R
		};
		if (E.shouldInclude) {
			let u = await S$1(Dp);
			U.push(u);
		} else if (u.tagName === "Private" || P.pickMap.size > 0) {
			let u = J(await S$1(Dp), P, R);
			U.push(...u);
		}
	}
	return j({
		...E,
		treeChildren: U
	}, M);
}
async function we(u, T) {
	return (await Promise.all(T.children.map(async (T) => {
		let E = D({
			stagedOperations: u.stagedOperations,
			id: T.id,
			tagName: T.tagName,
			throwOnDeleted: !1
		});
		return E?.status === "deleted" ? null : E ? E.record : u.databaseInstance[ou].get({
			id: T.id,
			tagName: T.tagName
		});
	}))).filter((u) => u !== null);
}
function J(u, T, E) {
	let O = [];
	for (let M of u.treeChildren) {
		let { shouldInclude: u } = W$1(M, T, !1, E);
		u ? O.push(M) : O.push(...J(M, T, E));
	}
	return O;
}
function X$1(u, T) {
	let E = [];
	T.has(u.tagName) && E.push(u);
	for (let O of u.treeChildren) E.push(...X$1(O, T));
	return E;
}
function Pe(u) {
	let { contextPromise: T } = u;
	return async function() {
		let u = await T;
		return Lu(() => u.databaseInstance[ou].get(u.currentFocus.id));
	};
}
function be(u) {
	let { contextPromise: T } = u;
	return async function() {
		return await Y$1(await T);
	};
}
function ve(u) {
	let { contextPromise: T } = u;
	return async function() {
		return await T;
	};
}
function ye(u) {
	let { contextPromise: T } = u;
	return async function(u) {
		let { depth: E, filter: O, withPrivate: M, flatten: P } = u || {};
		return await Y$1(await T, {
			depth: E,
			filter: O,
			withPrivate: M,
			flatten: P
		});
	};
}
function Te(u) {
	let { contextPromise: T } = u;
	return async function() {
		let u = await T, E = u.stagedOperations.length;
		try {
			await u.databaseInstance.transaction("rw", u.databaseInstance.tables, async () => {
				let T = u.stagedOperations.filter((u) => u.status === "created"), O = u.stagedOperations.filter((u) => u.status === "updated"), M = u.stagedOperations.filter((u) => u.status === "deleted"), P = 0;
				T.length > 0 && (u.onProgress?.({
					current: P,
					total: E,
					message: `Creating ${T.length} records`,
					scope: "commit"
				}), await u.databaseInstance.sclElements.bulkAdd(T.map((u) => u.new)), P += T.length, u.onProgress?.({
					current: P,
					total: E,
					message: `Created ${T.length} records`,
					scope: "commit"
				})), O.length > 0 && (u.onProgress?.({
					current: P,
					total: E,
					message: `Updating ${O.length} records`,
					scope: "commit"
				}), await u.databaseInstance.sclElements.bulkPut(O.map((u) => u.new)), P += O.length, u.onProgress?.({
					current: P,
					total: E,
					message: `Updated ${O.length} records`,
					scope: "commit"
				})), M.length > 0 && (u.onProgress?.({
					current: P,
					total: E,
					message: `Deleting ${M.length} records`,
					scope: "commit"
				}), await u.databaseInstance.sclElements.bulkDelete(M.map((u) => u.old.id)), P += M.length, u.onProgress?.({
					current: P,
					total: E,
					message: `Deleted ${M.length} records`,
					scope: "commit"
				}));
			});
		} catch (u) {
			throw Error("Transaction failed", { cause: u });
		}
	};
}
function y$4(u) {
	let { contextPromise: T, extensions: E, tagName: O } = u;
	return Ce({
		genericBuilder: {
			addChild: de({
				genericApiBuilder: y$4,
				contextPromise: T,
				extensions: E
			}),
			deepCloneChild: ue({
				genericApiBuilder: y$4,
				contextPromise: T,
				extensions: E
			}),
			update: le({
				genericApiBuilder: y$4,
				contextPromise: T,
				extensions: E,
				tagName: O
			}),
			delete: O === "SCL" ? void 0 : me({
				genericApiBuilder: y$4,
				contextPromise: T,
				extensions: E
			}),
			goToElement: fe({
				genericApiBuilder: y$4,
				contextPromise: T,
				extensions: E
			}),
			goToParent: ge({
				genericApiBuilder: y$4,
				contextPromise: T,
				extensions: E
			}),
			getObservable: Pe({ contextPromise: T }),
			getChildren: ye({ contextPromise: T }),
			getSnapshot: be({ contextPromise: T }),
			getContext: ve({ contextPromise: T }),
			commit: Te({ contextPromise: T })
		},
		extensions: E,
		tagName: O,
		contextPromise: T
	});
}
function Ce(u) {
	let { genericBuilder: T, extensions: E, tagName: O, contextPromise: M } = u, P = T, F = E[O] || {};
	for (let [u, T] of Object.entries(F)) typeof T == "function" && (P[u] = T({
		genericApiBuilder: y$4,
		contextPromise: M,
		extensions: E
	}));
	return P;
}
function Ee(u) {
	let { databaseInstance: T, tagName: E } = u;
	return Lu(() => T[ou].where({ tagName: E }).toArray());
}
function De(u) {
	let { version: T, databaseInstance: E, extensions: O, tagName: M, id: P, onProgress: F } = u;
	return y$4({
		contextPromise: Promise.resolve().then(async () => {
			let u = M === "SCL" || M === "Header" || M === "Communication" || M === "DataTypeTemplates", O;
			if (u && !P) O = await E[ou].where("tagName").equals(M).first();
			else if (P) O = await E[ou].get({
				id: P,
				tagName: M
			});
			else throw Error(`Element ${M} requires an id parameter`);
			if (!O) {
				let u = P ? ` with id ${P}` : "";
				throw Error(`No element ${M}${u} found in database`);
			}
			if (O.tagName !== M) throw Error("Element tagName mismatch");
			let I = Fu(O);
			return {
				version: T,
				databaseInstance: E,
				entrypoint: I,
				currentFocus: I,
				stagedOperations: [],
				onProgress: F
			};
		}),
		extensions: O,
		tagName: M
	});
}
function Re(u) {
	let { version: T, databaseInstance: E, extensions: O, onProgress: M } = u;
	return y$4({
		contextPromise: Promise.resolve().then(async () => {
			let u = await E[ou].where({ tagName: "SCL" }).count();
			if (u === 0) throw Error("No root SCL element found in database");
			if (u > 1) throw Error("Multiple root SCL elements found in database, database is corrupted");
			let O = await E[ou].get({ tagName: "SCL" });
			if (!O) throw Error("No root SCL element found in database");
			let P = Fu(O);
			return {
				version: T,
				databaseInstance: E,
				entrypoint: P,
				currentFocus: P,
				stagedOperations: [],
				onProgress: M
			};
		}),
		extensions: O,
		tagName: "SCL"
	});
}
async function Z(u) {
	let { record: T, dataTypeTemplates: E } = u, { LNodeType: O = [], DOType: M = [], DAType: P = [], EnumType: F = [] } = Nu(E.treeChildren), I = B({
		source: T,
		targets: O
	});
	if (!I) throw Error(`LNodeType for ${T.tagName} ${T.attributes.find((u) => u.name === "lnType")?.value} not found`);
	let R = x$3({
		sources: I.treeChildren.filter((u) => u.tagName === "DO"),
		targets: M
	}), V = x$3({
		sources: R.flatMap((u) => u.treeChildren.filter((u) => u.tagName === "DA")),
		targets: P
	}), U = x$3({
		sources: V.flatMap((u) => u.treeChildren.filter((u) => u.tagName === "BDA")),
		targets: F
	});
	return {
		...T,
		treeChildren: [
			I,
			...R,
			...V,
			...U
		],
		status: "unchanged"
	};
}
function Ae(u) {
	let { genericApiBuilder: T, contextPromise: E, extensions: O } = u;
	return function() {
		return T({
			contextPromise: E.then(async (u) => {
				let E = u.currentFocus, M = await Z({
					record: E,
					dataTypeTemplates: await T({
						contextPromise: Promise.resolve(u),
						extensions: O,
						tagName: u.currentFocus.tagName
					}).goToElement({ tagName: "DataTypeTemplates" }).getChildren()
				});
				return {
					...u,
					currentFocus: M
				};
			}),
			extensions: O,
			tagName: "LNode"
		});
	};
}
var Oe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
	__proto__: null,
	resolveDataModel: Ae
}, Symbol.toStringTag, { value: "Module" }));
function Ie(u) {
	let { genericApiBuilder: T, contextPromise: E, extensions: O } = u;
	return function(u) {
		let { subnetworkId: M } = u;
		return T({
			contextPromise: E.then(async (u) => {
				let E = T({
					contextPromise: Promise.resolve(u),
					extensions: O,
					tagName: "IED"
				}), P = A({
					attributes: u.currentFocus.attributes,
					name: "name"
				}), { AccessPoint: F = [] } = await E.getChildren({
					filter: { pick: ["AccessPoint"] },
					flatten: !0
				}), I = E.goToElement({
					tagName: "SubNetwork",
					id: M
				});
				for (let u of F) {
					let T = A({
						attributes: u.attributes,
						name: "name"
					});
					I = I.addChild({
						tagName: "ConnectedAP",
						attributes: {
							iedName: P,
							apName: T
						}
					});
				}
				let R = (await I.getContext()).stagedOperations;
				return {
					...u,
					stagedOperations: R
				};
			}),
			extensions: O,
			tagName: "IED"
		});
	};
}
var Me = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
	__proto__: null,
	attachAllAccessPointToSubNetwork: Ie
}, Symbol.toStringTag, { value: "Module" }));
function xe(u) {
	let { genericApiBuilder: T, contextPromise: E, extensions: O } = u;
	return function() {
		return T({
			contextPromise: E.then(async (u) => {
				let E = u.currentFocus, M = await Z({
					record: E,
					dataTypeTemplates: await T({
						contextPromise: Promise.resolve(u),
						extensions: O,
						tagName: u.currentFocus.tagName
					}).goToElement({ tagName: "DataTypeTemplates" }).getChildren()
				});
				return {
					...u,
					currentFocus: M
				};
			}),
			extensions: O,
			tagName: "LN"
		});
	};
}
var Fe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
	__proto__: null,
	resolveDataModel: xe
}, Symbol.toStringTag, { value: "Module" }));
function Se(u) {
	let { genericApiBuilder: T, contextPromise: E, extensions: O } = u;
	return function(u) {
		let { dataModel: M } = u;
		return T({
			contextPromise: E.then(async (u) => {
				let E = T({
					contextPromise: Promise.resolve(u),
					extensions: O,
					tagName: "DataTypeTemplates"
				});
				for (let u of M) {
					if (await te(E, u)) continue;
					E = ee(E, u);
					let T = u.treeChildren.filter((u) => _.includes(u.tagName));
					for (let u of T) E = await ke(E, u);
					E = E.goToParent();
				}
				return await E.getContext();
			}),
			extensions: O,
			tagName: "DataTypeTemplates"
		});
	};
}
async function ke(u, T) {
	return await te(u, T) ? u : ee(u, T).goToParent();
}
function ee(u, T) {
	let E = z({ attributes: T.attributes });
	return u.addChild({
		tagName: T.tagName,
		attributes: E,
		setFocus: !0
	});
}
async function te(u, T) {
	let E = L(T.tagName), O = T.attributes.find((u) => u.name === E)?.value;
	if (!O) throw Error(`Key attribute "${E}" is missing in element attributes.`);
	return (await u.getChildren({ depth: 1 })).treeChildren.find((u) => u.tagName === T.tagName && u.attributes.find((u) => u.name === E)?.value === O);
}
var Be = { v2019C1: {
	LNode: Oe,
	IED: Me,
	LN: Fe,
	DataTypeTemplates: /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
		__proto__: null,
		addToDataModel: Se
	}, Symbol.toStringTag, { value: "Module" }))
} };
function $e(u) {
	let { version: T, databaseInstance: E } = u, O = Be[T];
	return {
		fromRoot: (u) => Re({
			version: T,
			databaseInstance: E,
			extensions: O,
			onProgress: u?.onProgress
		}),
		fromElement: (u) => De({
			version: T,
			databaseInstance: E,
			extensions: O,
			tagName: u.tagName,
			id: u.id,
			onProgress: u?.onProgress
		}),
		getObservable: (u) => Ee({
			databaseInstance: E,
			...u
		}),
		getElement: async (u) => await E[ou].get({
			tagName: u.tagName,
			id: u.id
		})
	};
}
function Ue(u) {
	let { databaseName: T, version: E } = u, O = Tu({ databaseName: T });
	return {
		api: $e({
			version: E,
			databaseInstance: O
		}),
		utils: ie,
		database: O,
		standard: Ru[E]
	};
}
const useGlobalStore = defineStore("explorer/global", () => {
	let u = ref(""), T = computed(() => u.value ? Ue({
		databaseName: u.value,
		version: "v2019C1"
	}) : null);
	async function E(T) {
		u.value = T;
	}
	return {
		activeFilename: u,
		sdkInstance: T,
		initApp: E
	};
});
var isClient$1 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
var noop$1 = () => {};
function computedAsync(u, T, E) {
	let O;
	O = isRef(E) ? { evaluating: E } : E || {};
	let { lazy: M = !1, flush: P = "pre", evaluating: F = void 0, shallow: I = !0, onError: R = globalThis.reportError ?? noop$1 } = O, V = shallowRef(!M), U = I ? shallowRef(T) : ref(T), Dp = 0;
	return watchEffect(async (T) => {
		if (!V.value) return;
		Dp++;
		let E = Dp, O = !1;
		F && Promise.resolve().then(() => {
			F.value = !0;
		});
		try {
			let M = await u((u) => {
				T(() => {
					F && (F.value = !1), O || u();
				});
			});
			E === Dp && (U.value = M);
		} catch (u) {
			R(u);
		} finally {
			F && E === Dp && (F.value = !1), O = !0;
		}
	}, { flush: P }), M ? computed(() => (V.value = !0, U.value)) : U;
}
isClient$1 && window.document, isClient$1 && window.navigator, isClient$1 && window.location;
function serialize(u) {
	return typeof u == "string" ? `'${u}'` : new c$8().serialize(u);
}
var c$8 = /* @__PURE__ */ function() {
	class u {
		#t = /* @__PURE__ */ new Map();
		compare(u, T) {
			let E = typeof u, O = typeof T;
			return E === "string" && O === "string" ? u.localeCompare(T) : E === "number" && O === "number" ? u - T : String.prototype.localeCompare.call(this.serialize(u, !0), this.serialize(T, !0));
		}
		serialize(u, T) {
			if (u === null) return "null";
			switch (typeof u) {
				case "string": return T ? u : `'${u}'`;
				case "bigint": return `${u}n`;
				case "object": return this.$object(u);
				case "function": return this.$function(u);
			}
			return String(u);
		}
		serializeObject(u) {
			let T = Object.prototype.toString.call(u);
			if (T !== "[object Object]") return this.serializeBuiltInType(T.length < 10 ? `unknown:${T}` : T.slice(8, -1), u);
			let E = u.constructor, O = E === Object || E === void 0 ? "" : E.name;
			if (O !== "" && globalThis[O] === E) return this.serializeBuiltInType(O, u);
			if (typeof u.toJSON == "function") {
				let T = u.toJSON();
				return O + (typeof T == "object" && T ? this.$object(T) : `(${this.serialize(T)})`);
			}
			return this.serializeObjectEntries(O, Object.entries(u));
		}
		serializeBuiltInType(u, T) {
			let E = this["$" + u];
			if (E) return E.call(this, T);
			if (typeof T?.entries == "function") return this.serializeObjectEntries(u, T.entries());
			throw Error(`Cannot serialize ${u}`);
		}
		serializeObjectEntries(u, T) {
			let E = Array.from(T).sort((u, T) => this.compare(u[0], T[0])), O = `${u}{`;
			for (let u = 0; u < E.length; u++) {
				let [T, M] = E[u];
				O += `${this.serialize(T, !0)}:${this.serialize(M)}`, u < E.length - 1 && (O += ",");
			}
			return O + "}";
		}
		$object(u) {
			let T = this.#t.get(u);
			return T === void 0 && (this.#t.set(u, `#${this.#t.size}`), T = this.serializeObject(u), this.#t.set(u, T)), T;
		}
		$function(u) {
			let T = Function.prototype.toString.call(u);
			return T.slice(-15) === "[native code] }" ? `${u.name || ""}()[native]` : `${u.name}(${u.length})${T.replace(/\s*\n\s*/g, "")}`;
		}
		$Array(u) {
			let T = "[";
			for (let E = 0; E < u.length; E++) T += this.serialize(u[E]), E < u.length - 1 && (T += ",");
			return T + "]";
		}
		$Date(u) {
			try {
				return `Date(${u.toISOString()})`;
			} catch {
				return "Date(null)";
			}
		}
		$ArrayBuffer(u) {
			return `ArrayBuffer[${new Uint8Array(u).join(",")}]`;
		}
		$Set(u) {
			return `Set${this.$Array(Array.from(u).sort((u, T) => this.compare(u, T)))}`;
		}
		$Map(u) {
			return this.serializeObjectEntries("Map", u.entries());
		}
	}
	for (let T of [
		"Error",
		"RegExp",
		"URL"
	]) u.prototype["$" + T] = function(u) {
		return `${T}(${u})`;
	};
	for (let T of [
		"Int8Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"Int16Array",
		"Uint16Array",
		"Int32Array",
		"Uint32Array",
		"Float32Array",
		"Float64Array"
	]) u.prototype["$" + T] = function(u) {
		return `${T}[${u.join(",")}]`;
	};
	for (let T of ["BigInt64Array", "BigUint64Array"]) u.prototype["$" + T] = function(u) {
		return `${T}[${u.join("n,")}${u.length > 0 ? "n" : ""}]`;
	};
	return u;
}();
function isEqual(u, T) {
	return u === T || serialize(u) === serialize(T);
}
function findValuesBetween(u, T, E) {
	let O = u.findIndex((u) => isEqual(u, T)), M = u.findIndex((u) => isEqual(u, E));
	if (O === -1 || M === -1) return [];
	let [P, F] = [O, M].sort((u, T) => u - T);
	return u.slice(P, F + 1);
}
function createContext(u, T) {
	let E = typeof u == "string" && !T ? `${u}Context` : T, O = Symbol(E);
	return [(T) => {
		let E = inject(O, T);
		if (E || E === null) return E;
		throw Error(`Injection \`${O.toString()}\` not found. Component must be used within ${Array.isArray(u) ? `one of the following components: ${u.join(", ")}` : `\`${u}\``}`);
	}, (u) => (provide(O, u), u)];
}
function getActiveElement() {
	let u = document.activeElement;
	if (u == null) return null;
	for (; u != null && u.shadowRoot != null && u.shadowRoot.activeElement != null;) u = u.shadowRoot.activeElement;
	return u;
}
function handleAndDispatchCustomEvent(u, T, E) {
	let O = E.originalEvent.target, M = new CustomEvent(u, {
		bubbles: !1,
		cancelable: !0,
		detail: E
	});
	T && O.addEventListener(u, T, { once: !0 }), O.dispatchEvent(M);
}
function renderSlotFragments(u) {
	return u ? u.flatMap((u) => u.type === Fragment ? renderSlotFragments(u.children) : [u]) : [];
}
var [injectConfigProviderContext, provideConfigProviderContext] = createContext("ConfigProvider");
function tryOnScopeDispose(u) {
	return getCurrentScope() ? (onScopeDispose(u), !0) : !1;
}
function createEventHook() {
	let u = /* @__PURE__ */ new Set(), T = (T) => {
		u.delete(T);
	};
	return {
		on: (E) => {
			u.add(E);
			let O = () => T(E);
			return tryOnScopeDispose(O), { off: O };
		},
		off: T,
		trigger: (...T) => Promise.all(Array.from(u).map((u) => u(...T))),
		clear: () => {
			u.clear();
		}
	};
}
var isClient = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
var isDef = (u) => u !== void 0;
function refAutoReset(u, T = 1e4) {
	return customRef((E, O) => {
		let M = toValue(u), P, F = () => setTimeout(() => {
			M = toValue(u), O();
		}, toValue(T));
		return tryOnScopeDispose(() => {
			clearTimeout(P);
		}), {
			get() {
				return E(), M;
			},
			set(u) {
				M = u, O(), clearTimeout(P), P = F();
			}
		};
	});
}
isClient && window.document, isClient && window.navigator, isClient && window.location;
function unrefElement(u) {
	let T = toValue(u);
	return T?.$el ?? T;
}
function cloneFnJSON(u) {
	return JSON.parse(JSON.stringify(u));
}
function useVModel(u, T, E, O = {}) {
	let { clone: M = !1, passive: P = !1, eventName: F, deep: I = !1, defaultValue: R, shouldEmit: V } = O, U = getCurrentInstance(), Dp = E || U?.emit || (U?.$emit)?.bind(U) || (U?.proxy?.$emit)?.bind(U?.proxy), Op = F;
	T ||= "modelValue", Op ||= `update:${T.toString()}`;
	let kp = (u) => M ? typeof M == "function" ? M(u) : cloneFnJSON(u) : u, Ap = () => isDef(u[T]) ? kp(u[T]) : R, jp = (u) => {
		V ? V(u) && Dp(Op, u) : Dp(Op, u);
	};
	if (P) {
		let E = ref(Ap()), O = !1;
		return watch(() => u[T], (u) => {
			O || (O = !0, E.value = kp(u), nextTick(() => O = !1));
		}), watch(E, (E) => {
			!O && (E !== u[T] || I) && jp(E);
		}, { deep: I }), E;
	} else return computed({
		get() {
			return Ap();
		},
		set(u) {
			jp(u);
		}
	});
}
function useDirection(u) {
	let T = injectConfigProviderContext({ dir: ref("ltr") });
	return computed(() => u?.value || T.dir?.value || "ltr");
}
var count = 0;
function useId(u, T = "reka") {
	if (u) return u;
	if ("useId" in vue_runtime_esm_bundler_exports) return `${T}-${useId$1?.()}`;
	let E = injectConfigProviderContext({ useId: void 0 });
	return E.useId ? `${T}-${E.useId()}` : `${T}-${++count}`;
}
function useSelectionBehavior(u, T) {
	let E = ref(), O = (O, M) => {
		if (T.multiple && Array.isArray(u.value)) if (T.selectionBehavior === "replace") u.value = [O], E.value = O;
		else {
			let T = u.value.findIndex((u) => M(u));
			T === -1 ? u.value = [...u.value, O] : u.value = u.value.filter((u, E) => E !== T);
		}
		else T.selectionBehavior === "replace" ? u.value = { ...O } : !Array.isArray(u.value) && M(u.value) ? u.value = void 0 : u.value = { ...O };
		return u.value;
	};
	function M(O, M, P, F) {
		if (!E?.value || !T.multiple || !Array.isArray(u.value)) return;
		let I = P().filter((u) => u.ref.dataset.disabled !== "").find((u) => u.ref === M)?.value;
		if (!I) return;
		let R = null;
		switch (O) {
			case "prev":
			case "next":
				R = findValuesBetween(F, E.value, I);
				break;
			case "first":
				R = findValuesBetween(F, E.value, F?.[0]);
				break;
			case "last":
				R = findValuesBetween(F, E.value, F?.[F.length - 1]);
				break;
		}
		u.value = R;
	}
	return {
		firstValue: E,
		onSelectItem: O,
		handleMultipleReplace: M
	};
}
function useTypeahead(u) {
	let T = refAutoReset("", 1e3);
	return {
		search: T,
		handleTypeaheadSearch: (E, O) => {
			if (T.value += E, u) u(E);
			else {
				let u = getActiveElement(), E = O.map((u) => ({
					...u,
					textValue: u.value?.textValue ?? u.ref.textContent?.trim() ?? ""
				})), M = E.find((T) => T.ref === u), P = getNextMatch(E.map((u) => u.textValue), T.value, M?.textValue), F = E.find((u) => u.textValue === P);
				return F && F.ref.focus(), F?.ref;
			}
		},
		resetTypeahead: () => {
			T.value = "";
		}
	};
}
function wrapArray$1(u, T) {
	return u.map((E, O) => u[(T + O) % u.length]);
}
function getNextMatch(u, T, E) {
	let O = T.length > 1 && Array.from(T).every((u) => u === T[0]) ? T[0] : T, M = E ? u.indexOf(E) : -1, P = wrapArray$1(u, Math.max(M, 0));
	O.length === 1 && (P = P.filter((u) => u !== E));
	let F = P.find((u) => u.toLowerCase().startsWith(O.toLowerCase()));
	return F === E ? void 0 : F;
}
var Slot = /* @__PURE__ */ defineComponent({
	name: "PrimitiveSlot",
	inheritAttrs: !1,
	setup(u, { attrs: T, slots: E }) {
		return () => {
			if (!E.default) return null;
			let u = renderSlotFragments(E.default()), O = u.findIndex((u) => u.type !== Comment);
			if (O === -1) return u;
			let M = u[O];
			delete M.props?.ref;
			let P = M.props ? mergeProps(T, M.props) : T, F = cloneVNode({
				...M,
				props: {}
			}, P);
			return u.length === 1 ? F : (u[O] = F, u);
		};
	}
}), SELF_CLOSING_TAGS = [
	"area",
	"img",
	"input"
], Primitive = /* @__PURE__ */ defineComponent({
	name: "Primitive",
	inheritAttrs: !1,
	props: {
		asChild: {
			type: Boolean,
			default: !1
		},
		as: {
			type: [String, Object],
			default: "div"
		}
	},
	setup(u, { attrs: T, slots: E }) {
		let O = u.asChild ? "template" : u.as;
		return typeof O == "string" && SELF_CLOSING_TAGS.includes(O) ? () => h$5(O, T) : O === "template" ? () => h$5(Slot, T, { default: E.default }) : () => h$5(u.as, T, { default: E.default });
	}
});
function usePrimitiveElement() {
	let u = ref();
	return {
		primitiveElement: u,
		currentElement: computed(() => ["#text", "#comment"].includes(u.value?.$el.nodeName) ? u.value?.$el.nextElementSibling : unrefElement(u))
	};
}
var ITEM_DATA_ATTR = "data-reka-collection-item";
function useCollection(u = {}) {
	let { key: T = "", isProvider: E = !1 } = u, O = `${T}CollectionProvider`, M;
	if (E) {
		let u = ref(/* @__PURE__ */ new Map());
		M = {
			collectionRef: ref(),
			itemMap: u
		}, provide(O, M);
	} else M = inject(O);
	let P = (u = !1) => {
		let T = M.collectionRef.value;
		if (!T) return [];
		let E = Array.from(T.querySelectorAll(`[${ITEM_DATA_ATTR}]`)), O = Array.from(M.itemMap.value.values()).sort((u, T) => E.indexOf(u.ref) - E.indexOf(T.ref));
		return u ? O : O.filter((u) => u.ref.dataset.disabled !== "");
	}, F = /* @__PURE__ */ defineComponent({
		name: "CollectionSlot",
		setup(u, { slots: T }) {
			let { primitiveElement: E, currentElement: O } = usePrimitiveElement();
			return watch(O, () => {
				M.collectionRef.value = O.value;
			}), () => h$5(Slot, { ref: E }, T);
		}
	}), I = /* @__PURE__ */ defineComponent({
		name: "CollectionItem",
		inheritAttrs: !1,
		props: { value: { validator: () => !0 } },
		setup(u, { slots: T, attrs: E }) {
			let { primitiveElement: O, currentElement: P } = usePrimitiveElement();
			return watchEffect((T) => {
				if (P.value) {
					let E = markRaw(P.value);
					M.itemMap.value.set(E, {
						ref: P.value,
						value: u.value
					}), T(() => M.itemMap.value.delete(E));
				}
			}), () => h$5(Slot, {
				...E,
				[ITEM_DATA_ATTR]: "",
				ref: O
			}, T);
		}
	});
	return {
		getItems: P,
		reactiveItems: computed(() => Array.from(M.itemMap.value.values())),
		itemMapSize: computed(() => M.itemMap.value.size),
		CollectionSlot: F,
		CollectionItem: I
	};
}
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus", EVENT_OPTIONS = {
	bubbles: !1,
	cancelable: !0
}, MAP_KEY_TO_FOCUS_INTENT = {
	ArrowLeft: "prev",
	ArrowUp: "prev",
	ArrowRight: "next",
	ArrowDown: "next",
	PageUp: "first",
	Home: "first",
	PageDown: "last",
	End: "last"
};
function getDirectionAwareKey(u, T) {
	return T === "rtl" ? u === "ArrowLeft" ? "ArrowRight" : u === "ArrowRight" ? "ArrowLeft" : u : u;
}
function getFocusIntent(u, T, E) {
	let O = getDirectionAwareKey(u.key, E);
	if (!(T === "vertical" && ["ArrowLeft", "ArrowRight"].includes(O)) && !(T === "horizontal" && ["ArrowUp", "ArrowDown"].includes(O))) return MAP_KEY_TO_FOCUS_INTENT[O];
}
function focusFirst(u, T = !1) {
	let E = getActiveElement();
	for (let O of u) if (O === E || (O.focus({ preventScroll: T }), getActiveElement() !== E)) return;
}
function wrapArray(u, T) {
	return u.map((E, O) => u[(T + O) % u.length]);
}
var [injectRovingFocusGroupContext, provideRovingFocusGroupContext] = createContext("RovingFocusGroup"), RovingFocusGroup_default = /* @__PURE__ */ defineComponent({
	__name: "RovingFocusGroup",
	props: {
		orientation: {
			type: String,
			required: !1,
			default: void 0
		},
		dir: {
			type: String,
			required: !1
		},
		loop: {
			type: Boolean,
			required: !1,
			default: !1
		},
		currentTabStopId: {
			type: [String, null],
			required: !1
		},
		defaultCurrentTabStopId: {
			type: String,
			required: !1
		},
		preventScrollOnEntryFocus: {
			type: Boolean,
			required: !1,
			default: !1
		},
		asChild: {
			type: Boolean,
			required: !1
		},
		as: {
			type: null,
			required: !1
		}
	},
	emits: ["entryFocus", "update:currentTabStopId"],
	setup(u, { expose: T, emit: E }) {
		let O = u, M = E, { loop: P, orientation: F, dir: I } = toRefs(O), R = useDirection(I), V = useVModel(O, "currentTabStopId", M, {
			defaultValue: O.defaultCurrentTabStopId,
			passive: O.currentTabStopId === void 0
		}), U = ref(!1), Dp = ref(!1), Op = ref(0), { getItems: kp, CollectionSlot: Ap } = useCollection({ isProvider: !0 });
		function jp(u) {
			let T = !Dp.value;
			if (u.currentTarget && u.target === u.currentTarget && T && !U.value) {
				let T = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
				if (u.currentTarget.dispatchEvent(T), M("entryFocus", T), !T.defaultPrevented) {
					let u = kp().map((u) => u.ref).filter((u) => u.dataset.disabled !== "");
					focusFirst([
						u.find((u) => u.getAttribute("data-active") === ""),
						u.find((u) => u.getAttribute("data-highlighted") === ""),
						u.find((u) => u.id === V.value),
						...u
					].filter(Boolean), O.preventScrollOnEntryFocus);
				}
			}
			Dp.value = !1;
		}
		function Mp() {
			setTimeout(() => {
				Dp.value = !1;
			}, 1);
		}
		return T({ getItems: kp }), provideRovingFocusGroupContext({
			loop: P,
			dir: R,
			orientation: F,
			currentTabStopId: V,
			onItemFocus: (u) => {
				V.value = u;
			},
			onItemShiftTab: () => {
				U.value = !0;
			},
			onFocusableItemAdd: () => {
				Op.value++;
			},
			onFocusableItemRemove: () => {
				Op.value--;
			}
		}), (u, T) => (openBlock(), createBlock(unref(Ap), null, {
			default: withCtx(() => [createVNode(unref(Primitive), {
				tabindex: U.value || Op.value === 0 ? -1 : 0,
				"data-orientation": unref(F),
				as: u.as,
				"as-child": u.asChild,
				dir: unref(R),
				style: { outline: "none" },
				onMousedown: T[0] ||= (u) => Dp.value = !0,
				onMouseup: Mp,
				onFocus: jp,
				onBlur: T[1] ||= (u) => U.value = !1
			}, {
				default: withCtx(() => [renderSlot(u.$slots, "default")]),
				_: 3
			}, 8, [
				"tabindex",
				"data-orientation",
				"as",
				"as-child",
				"dir"
			])]),
			_: 3
		}));
	}
}), RovingFocusItem_default = /* @__PURE__ */ defineComponent({
	__name: "RovingFocusItem",
	props: {
		tabStopId: {
			type: String,
			required: !1
		},
		focusable: {
			type: Boolean,
			required: !1,
			default: !0
		},
		active: {
			type: Boolean,
			required: !1
		},
		allowShiftKey: {
			type: Boolean,
			required: !1
		},
		asChild: {
			type: Boolean,
			required: !1
		},
		as: {
			type: null,
			required: !1,
			default: "span"
		}
	},
	setup(u) {
		let T = u, E = injectRovingFocusGroupContext(), O = useId(), M = computed(() => T.tabStopId || O), P = computed(() => E.currentTabStopId.value === M.value), { getItems: F, CollectionItem: I } = useCollection();
		onMounted(() => {
			T.focusable && E.onFocusableItemAdd();
		}), onUnmounted(() => {
			T.focusable && E.onFocusableItemRemove();
		});
		function R(u) {
			if (u.key === "Tab" && u.shiftKey) {
				E.onItemShiftTab();
				return;
			}
			if (u.target !== u.currentTarget) return;
			let O = getFocusIntent(u, E.orientation.value, E.dir.value);
			if (O !== void 0) {
				if (u.metaKey || u.ctrlKey || u.altKey || !T.allowShiftKey && u.shiftKey) return;
				u.preventDefault();
				let M = [...F().map((u) => u.ref).filter((u) => u.dataset.disabled !== "")];
				if (O === "last") M.reverse();
				else if (O === "prev" || O === "next") {
					O === "prev" && M.reverse();
					let T = M.indexOf(u.currentTarget);
					M = E.loop.value ? wrapArray(M, T + 1) : M.slice(T + 1);
				}
				nextTick(() => focusFirst(M));
			}
		}
		return (u, T) => (openBlock(), createBlock(unref(I), null, {
			default: withCtx(() => [createVNode(unref(Primitive), {
				tabindex: P.value ? 0 : -1,
				"data-orientation": unref(E).orientation.value,
				"data-active": u.active ? "" : void 0,
				"data-disabled": u.focusable ? void 0 : "",
				as: u.as,
				"as-child": u.asChild,
				onMousedown: T[0] ||= (T) => {
					u.focusable ? unref(E).onItemFocus(M.value) : T.preventDefault();
				},
				onFocus: T[1] ||= (u) => unref(E).onItemFocus(M.value),
				onKeydown: R
			}, {
				default: withCtx(() => [renderSlot(u.$slots, "default")]),
				_: 3
			}, 8, [
				"tabindex",
				"data-orientation",
				"data-active",
				"data-disabled",
				"as",
				"as-child"
			])]),
			_: 3
		}));
	}
});
function flatten(u) {
	return u.reduce((u, T) => (u.push(T), T.children && u.push(...flatten(T.children)), u), []);
}
var [injectTreeRootContext, provideTreeRootContext] = createContext("TreeRoot"), TreeRoot_default = /* @__PURE__ */ defineComponent({
	__name: "TreeRoot",
	props: {
		modelValue: {
			type: null,
			required: !1
		},
		defaultValue: {
			type: null,
			required: !1
		},
		items: {
			type: Array,
			required: !1
		},
		expanded: {
			type: Array,
			required: !1
		},
		defaultExpanded: {
			type: Array,
			required: !1
		},
		getKey: {
			type: Function,
			required: !0
		},
		getChildren: {
			type: Function,
			required: !1,
			default: (u) => u.children
		},
		selectionBehavior: {
			type: String,
			required: !1,
			default: "toggle"
		},
		multiple: {
			type: Boolean,
			required: !1,
			skipCheck: !0
		},
		dir: {
			type: String,
			required: !1
		},
		disabled: {
			type: Boolean,
			required: !1
		},
		propagateSelect: {
			type: Boolean,
			required: !1
		},
		bubbleSelect: {
			type: Boolean,
			required: !1
		},
		asChild: {
			type: Boolean,
			required: !1
		},
		as: {
			type: null,
			required: !1,
			default: "ul"
		}
	},
	emits: ["update:modelValue", "update:expanded"],
	setup(u, { emit: T }) {
		let E = u, O = T, { items: M, multiple: P, disabled: F, propagateSelect: I, dir: R, bubbleSelect: V } = toRefs(E), { handleTypeaheadSearch: U } = useTypeahead(), Dp = useDirection(R), Op = ref(), kp = ref(!1), Ap = createEventHook(), jp = useVModel(E, "modelValue", O, {
			defaultValue: E.defaultValue ?? (P.value ? [] : void 0),
			passive: !0,
			deep: !0
		}), Mp = useVModel(E, "expanded", O, {
			defaultValue: E.defaultExpanded ?? [],
			passive: E.expanded === void 0,
			deep: !0
		}), { onSelectItem: Np, handleMultipleReplace: Pp } = useSelectionBehavior(jp, E), Fp = computed(() => P.value && Array.isArray(jp.value) ? jp.value.map((u) => E.getKey(u)) : [E.getKey(jp.value ?? {})]);
		function Ip(u, T = 1, O) {
			return u.reduce((M, P, F) => {
				let I = E.getKey(P), R = E.getChildren(P), V = Mp.value.includes(I), U = {
					_id: I,
					value: P,
					index: F,
					level: T,
					parentItem: O,
					hasChildren: !!R,
					bind: {
						value: P,
						level: T,
						"aria-setsize": u.length,
						"aria-posinset": F + 1
					}
				};
				return M.push(U), R && V && M.push(...Ip(R, T + 1, P)), M;
			}, []);
		}
		let Lp = computed(() => {
			let u = E.items;
			return Mp.value.map((u) => u), Ip(u ?? []);
		});
		function Rp(u) {
			if (kp.value) Ap.trigger(u);
			else {
				let T = Op.value?.getItems() ?? [];
				U(u.key, T);
			}
		}
		function zp(u) {
			if (kp.value) return;
			let T = MAP_KEY_TO_FOCUS_INTENT[u.key];
			nextTick(() => {
				Pp(T, getActiveElement(), Op.value?.getItems, Lp.value.map((u) => u.value));
			});
		}
		function Bp(u) {
			if (u.parentItem != null && Array.isArray(jp.value) && E.multiple) {
				let T = Lp.value.find((T) => u.parentItem != null && E.getKey(T.value) === E.getKey(u.parentItem));
				T != null && (E.getChildren(T.value)?.every((u) => jp.value.find((T) => E.getKey(T) === E.getKey(u))) ? jp.value = [...jp.value, T.value] : jp.value = jp.value.filter((u) => E.getKey(u) !== E.getKey(T.value)), Bp(T));
			}
		}
		return provideTreeRootContext({
			modelValue: jp,
			selectedKeys: Fp,
			onSelect: (u) => {
				let T = (T) => E.getKey(T ?? {}) === E.getKey(u), O = E.multiple && Array.isArray(jp.value) ? jp.value?.findIndex(T) !== -1 : void 0;
				if (Np(u, T), E.bubbleSelect && E.multiple && Array.isArray(jp.value)) {
					let T = Lp.value.find((T) => E.getKey(T.value) === E.getKey(u));
					T != null && Bp(T);
				}
				if (E.propagateSelect && E.multiple && Array.isArray(jp.value)) {
					let T = flatten(E.getChildren(u) ?? []);
					O ? jp.value = [...jp.value].filter((u) => !T.some((T) => E.getKey(u ?? {}) === E.getKey(T))) : jp.value = [...jp.value, ...T];
				}
			},
			expanded: Mp,
			onToggle(u) {
				if (!(u && E.getChildren(u))) return;
				let T = E.getKey(u) ?? u;
				Mp.value.includes(T) ? Mp.value = Mp.value.filter((u) => u !== T) : Mp.value.push(T);
			},
			getKey: E.getKey,
			getChildren: E.getChildren,
			items: M,
			expandedItems: Lp,
			disabled: F,
			multiple: P,
			dir: Dp,
			propagateSelect: I,
			bubbleSelect: V,
			isVirtual: kp,
			virtualKeydownHook: Ap,
			handleMultipleReplace: Pp
		}), (u, T) => (openBlock(), createBlock(unref(RovingFocusGroup_default), {
			ref_key: "rovingFocusGroupRef",
			ref: Op,
			"as-child": "",
			orientation: "vertical",
			dir: unref(Dp)
		}, {
			default: withCtx(() => [createVNode(unref(Primitive), {
				role: "tree",
				as: u.as,
				"as-child": u.asChild,
				"aria-multiselectable": unref(P) ? !0 : void 0,
				onKeydown: [Rp, withKeys(withModifiers(zp, ["shift"]), ["up", "down"])]
			}, {
				default: withCtx(() => [renderSlot(u.$slots, "default", {
					flattenItems: Lp.value,
					modelValue: unref(jp),
					expanded: unref(Mp)
				})]),
				_: 3
			}, 8, [
				"as",
				"as-child",
				"aria-multiselectable",
				"onKeydown"
			])]),
			_: 3
		}, 8, ["dir"]));
	}
}), TREE_SELECT = "tree.select", TREE_TOGGLE = "tree.toggle", TreeItem_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: !1,
	__name: "TreeItem",
	props: {
		value: {
			type: null,
			required: !0
		},
		level: {
			type: Number,
			required: !0
		},
		asChild: {
			type: Boolean,
			required: !1
		},
		as: {
			type: null,
			required: !1,
			default: "li"
		}
	},
	emits: ["select", "toggle"],
	setup(u, { expose: T, emit: E }) {
		let O = u, M = E, P = injectTreeRootContext(), { getItems: F } = useCollection(), I = computed(() => !!P.getChildren(O.value)), R = computed(() => {
			let u = P.getKey(O.value);
			return P.expanded.value.includes(u);
		}), V = computed(() => {
			let u = P.getKey(O.value);
			return P.selectedKeys.value.includes(u);
		}), U = computed(() => {
			if (P.bubbleSelect.value && I.value && Array.isArray(P.modelValue.value)) {
				let u = flatten(P.getChildren(O.value) || []);
				return u.some((u) => P.modelValue.value.find((T) => P.getKey(T) === P.getKey(u))) && !u.every((u) => P.modelValue.value.find((T) => P.getKey(T) === P.getKey(u)));
			} else if (P.propagateSelect.value && V.value && I.value && Array.isArray(P.modelValue.value)) return !flatten(P.getChildren(O.value) || []).every((u) => P.modelValue.value.find((T) => P.getKey(T) === P.getKey(u)));
			else return;
		});
		function Dp(u) {
			if (I.value) if (R.value) {
				let u = F().map((u) => u.ref), T = getActiveElement(), E = u.indexOf(T), M = [...u].slice(E).find((u) => Number(u.getAttribute("data-indent")) === O.level + 1);
				M && M.focus();
			} else Mp(u);
		}
		function Op(u) {
			if (R.value) Mp(u);
			else {
				let u = F().map((u) => u.ref), T = getActiveElement(), E = u.indexOf(T), M = [...u].slice(0, E).reverse().find((u) => Number(u.getAttribute("data-indent")) === O.level - 1);
				M && M.focus();
			}
		}
		async function kp(u) {
			M("select", u), !u?.defaultPrevented && P.onSelect(O.value);
		}
		async function Ap(u) {
			M("toggle", u), !u?.defaultPrevented && P.onToggle(O.value);
		}
		async function jp(u) {
			u && handleAndDispatchCustomEvent(TREE_SELECT, kp, {
				originalEvent: u,
				value: O.value,
				isExpanded: R.value,
				isSelected: V.value
			});
		}
		async function Mp(u) {
			u && handleAndDispatchCustomEvent(TREE_TOGGLE, Ap, {
				originalEvent: u,
				value: O.value,
				isExpanded: R.value,
				isSelected: V.value
			});
		}
		return T({
			isExpanded: R,
			isSelected: V,
			isIndeterminate: U,
			handleToggle: () => P.onToggle(O.value),
			handleSelect: () => P.onSelect(O.value)
		}), (u, T) => (openBlock(), createBlock(unref(RovingFocusItem_default), {
			"as-child": "",
			value: u.value,
			"allow-shift-key": ""
		}, {
			default: withCtx(() => [createVNode(unref(Primitive), mergeProps(u.$attrs, {
				role: "treeitem",
				as: u.as,
				"as-child": u.asChild,
				"aria-selected": V.value,
				"aria-expanded": I.value ? R.value : void 0,
				"aria-level": u.level,
				"data-indent": u.level,
				"data-selected": V.value ? "" : void 0,
				"data-expanded": R.value ? "" : void 0,
				onKeydown: [
					withKeys(withModifiers(jp, ["self", "prevent"]), ["enter", "space"]),
					T[0] ||= withKeys(withModifiers((u) => unref(P).dir.value === "ltr" ? Dp(u) : Op(u), ["prevent"]), ["right"]),
					T[1] ||= withKeys(withModifiers((u) => unref(P).dir.value === "ltr" ? Op(u) : Dp(u), ["prevent"]), ["left"])
				],
				onClick: T[2] ||= withModifiers((u) => {
					jp(u), Mp(u);
				}, ["stop"])
			}), {
				default: withCtx(() => [renderSlot(u.$slots, "default", {
					isExpanded: R.value,
					isSelected: V.value,
					isIndeterminate: U.value,
					handleSelect: () => unref(P).onSelect(u.value),
					handleToggle: () => unref(P).onToggle(u.value)
				})]),
				_: 3
			}, 16, [
				"as",
				"as-child",
				"aria-selected",
				"aria-expanded",
				"aria-level",
				"data-indent",
				"data-selected",
				"data-expanded",
				"onKeydown"
			])]),
			_: 3
		}, 8, ["value"]));
	}
});
function g(u) {
	return getCurrentScope() ? (onScopeDispose(u), !0) : !1;
}
var a$14 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
var f = Object.prototype.toString, y$2 = (u) => f.call(u) === "[object Object]", l$1 = () => {}, m = /* @__PURE__ */ w();
function w() {
	return a$14 && window?.navigator?.userAgent && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || window?.navigator?.maxTouchPoints > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function S(...u) {
	if (u.length !== 1) return toRef(...u);
	let T = u[0];
	return typeof T == "function" ? readonly(customRef(() => ({
		get: T,
		set: l$1
	}))) : ref(T);
}
function b(u) {
	return Array.isArray(u) ? u : [u];
}
function v(u, T, E) {
	return watch(u, T, {
		...E,
		immediate: !0
	});
}
var N = a$14 ? window : void 0;
function y$3(u) {
	let T = toValue(u);
	return T?.$el ?? T;
}
function k$1(...u) {
	let T = [], E = () => {
		T.forEach((u) => u()), T.length = 0;
	}, O = (u, T, E, O) => (u.addEventListener(T, E, O), () => u.removeEventListener(T, E, O)), M = computed(() => {
		let T = b(toValue(u[0])).filter((u) => u != null);
		return T.every((u) => typeof u != "string") ? T : void 0;
	}), P = v(() => [
		M.value?.map((u) => y$3(u)) ?? [N].filter((u) => u != null),
		b(toValue(M.value ? u[1] : u[0])),
		b(unref(M.value ? u[2] : u[1])),
		toValue(M.value ? u[3] : u[2])
	], ([u, M, P, F]) => {
		if (E(), !u?.length || !M?.length || !P?.length) return;
		let I = y$2(F) ? { ...F } : F;
		T.push(...u.flatMap((u) => M.flatMap((T) => P.map((E) => O(u, T, E, I)))));
	}, { flush: "post" });
	return g(E), () => {
		P(), E();
	};
}
function W(u) {
	return typeof Window < "u" && u instanceof Window ? u.document.documentElement : typeof Document < "u" && u instanceof Document ? u.documentElement : u;
}
function Y(u) {
	let T = window.getComputedStyle(u);
	if (T.overflowX === "scroll" || T.overflowY === "scroll" || T.overflowX === "auto" && u.clientWidth < u.scrollWidth || T.overflowY === "auto" && u.clientHeight < u.scrollHeight) return !0;
	{
		let T = u.parentNode;
		return !T || T.tagName === "BODY" ? !1 : Y(T);
	}
}
function X(u) {
	let T = u || window.event, E = T.target;
	return Y(E) ? !1 : T.touches.length > 1 ? !0 : (T.preventDefault && T.preventDefault(), !1);
}
var C$1 = /* @__PURE__ */ new WeakMap();
function q(u, T = !1) {
	let E = shallowRef(T), O = null, M = "";
	watch(S(u), (u) => {
		let T = W(toValue(u));
		if (T) {
			let u = T;
			if (C$1.get(u) || C$1.set(u, u.style.overflow), u.style.overflow !== "hidden" && (M = u.style.overflow), u.style.overflow === "hidden") return E.value = !0;
			if (E.value) return u.style.overflow = "hidden";
		}
	}, { immediate: !0 });
	let P = () => {
		let T = W(toValue(u));
		!T || E.value || (m && (O = k$1(T, "touchmove", (u) => {
			X(u);
		}, { passive: !1 })), T.style.overflow = "hidden", E.value = !0);
	}, F = () => {
		let T = W(toValue(u));
		!T || !E.value || (m && O?.(), T.style.overflow = M, C$1.delete(T), E.value = !1);
	};
	return g(F), computed({
		get() {
			return E.value;
		},
		set(u) {
			u ? P() : F();
		}
	});
}
function x$2() {
	let u = !1, T = shallowRef(!1);
	return (E, O) => {
		if (T.value = O.value, u) return;
		u = !0;
		let M = q(E, O.value);
		watch(T, (u) => M.value = u);
	};
}
x$2();
/**
* @license lucide-vue-next v0.545.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
var a$13 = (u) => u.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), s = (u) => u.replace(/^([A-Z])|[\s-_]+(\w)/g, (u, T, E) => E ? E.toUpperCase() : T.toLowerCase()), n = (u) => {
	let T = s(u);
	return T.charAt(0).toUpperCase() + T.slice(1);
}, c$7 = (...u) => u.filter((u, T, E) => !!u && u.trim() !== "" && E.indexOf(u) === T).join(" ").trim(), C = (u) => u === "", t$20 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: 24,
	height: 24,
	viewBox: "0 0 24 24",
	fill: "none",
	stroke: "currentColor",
	"stroke-width": 2,
	"stroke-linecap": "round",
	"stroke-linejoin": "round"
}, $ = ({ name: u, iconNode: T, absoluteStrokeWidth: E, "absolute-stroke-width": O, strokeWidth: M, "stroke-width": P, size: F = t$20.width, color: I = t$20.stroke,...R }, { slots: V }) => h$5("svg", {
	...t$20,
	...R,
	width: F,
	height: F,
	stroke: I,
	"stroke-width": C(E) || C(O) || E === !0 || O === !0 ? Number(M || P || t$20["stroke-width"]) * 24 / Number(F) : M || P || t$20["stroke-width"],
	class: c$7("lucide", R.class, ...u ? [`lucide-${a$13(n(u))}-icon`, `lucide-${a$13(u)}`] : ["lucide-icon"])
}, [...T.map((u) => h$5(...u)), ...V.default ? [V.default()] : []]), i$1 = (u, T) => (E, { slots: O, attrs: M }) => h$5($, {
	...M,
	...E,
	iconNode: T,
	name: u
}, O), e = i$1("activity", [["path", {
	d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",
	key: "169zse"
}]]), t = i$1("zap", [["path", {
	d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
	key: "1xq2db"
}]]), a = i$1("arrow-right", [["path", {
	d: "M5 12h14",
	key: "1ays0h"
}], ["path", {
	d: "m12 5 7 7-7 7",
	key: "xquz4c"
}]]), y = i$1("variable", [
	["path", {
		d: "M8 21s-4-3-4-9 4-9 4-9",
		key: "uto9ud"
	}],
	["path", {
		d: "M16 3s4 3 4 9-4 9-4 9",
		key: "4w2vsq"
	}],
	["line", {
		x1: "15",
		x2: "9",
		y1: "9",
		y2: "15",
		key: "f7djnv"
	}],
	["line", {
		x1: "9",
		x2: "15",
		y1: "9",
		y2: "15",
		key: "1shsy8"
	}]
]), r = i$1("square-pen", [["path", {
	d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7",
	key: "1m0v6g"
}], ["path", {
	d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",
	key: "ohrbg2"
}]]), x = i$1("hash", [
	["line", {
		x1: "4",
		x2: "20",
		y1: "9",
		y2: "9",
		key: "4lhtct"
	}],
	["line", {
		x1: "4",
		x2: "20",
		y1: "15",
		y2: "15",
		key: "vyu0kd"
	}],
	["line", {
		x1: "10",
		x2: "8",
		y1: "3",
		y2: "21",
		key: "1ggp8o"
	}],
	["line", {
		x1: "16",
		x2: "14",
		y1: "3",
		y2: "21",
		key: "weycgp"
	}]
]), a$1 = i$1("rotate-cw", [["path", {
	d: "M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8",
	key: "1p45f6"
}], ["path", {
	d: "M21 3v5h-5",
	key: "1q7to0"
}]]), i = i$1("timer", [
	["line", {
		x1: "10",
		x2: "14",
		y1: "2",
		y2: "2",
		key: "14vaq8"
	}],
	["line", {
		x1: "12",
		x2: "15",
		y1: "14",
		y2: "11",
		key: "17fdiu"
	}],
	["circle", {
		cx: "12",
		cy: "14",
		r: "8",
		key: "1e1u0o"
	}]
]), o = i$1("clock", [["path", {
	d: "M12 6v6l4 2",
	key: "mmk7yg"
}], ["circle", {
	cx: "12",
	cy: "12",
	r: "10",
	key: "1mglay"
}]]), t$1 = i$1("type", [
	["path", {
		d: "M12 4v16",
		key: "1654pz"
	}],
	["path", {
		d: "M4 7V5a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v2",
		key: "e0r10z"
	}],
	["path", {
		d: "M9 20h6",
		key: "s66wpe"
	}]
]), a$2 = i$1("terminal", [["path", {
	d: "M12 19h8",
	key: "baeox8"
}], ["path", {
	d: "m4 17 6-6-6-6",
	key: "1yngyt"
}]]), r$1 = i$1("toggle-right", [["circle", {
	cx: "15",
	cy: "12",
	r: "3",
	key: "1afu0r"
}], ["rect", {
	width: "20",
	height: "14",
	x: "2",
	y: "5",
	rx: "7",
	key: "g7kal2"
}]]), r$2 = i$1("users", [
	["path", {
		d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
		key: "1yyitq"
	}],
	["path", {
		d: "M16 3.128a4 4 0 0 1 0 7.744",
		key: "16gr8j"
	}],
	["path", {
		d: "M22 21v-2a4 4 0 0 0-3-3.87",
		key: "kshegd"
	}],
	["circle", {
		cx: "9",
		cy: "7",
		r: "4",
		key: "nufk8"
	}]
]), e$1 = i$1("building", [
	["path", {
		d: "M12 10h.01",
		key: "1nrarc"
	}],
	["path", {
		d: "M12 14h.01",
		key: "1etili"
	}],
	["path", {
		d: "M12 6h.01",
		key: "1vi96p"
	}],
	["path", {
		d: "M16 10h.01",
		key: "1m94wz"
	}],
	["path", {
		d: "M16 14h.01",
		key: "1gbofw"
	}],
	["path", {
		d: "M16 6h.01",
		key: "1x0f13"
	}],
	["path", {
		d: "M8 10h.01",
		key: "19clt8"
	}],
	["path", {
		d: "M8 14h.01",
		key: "6423bh"
	}],
	["path", {
		d: "M8 6h.01",
		key: "1dz90k"
	}],
	["path", {
		d: "M9 22v-3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3",
		key: "cabbwy"
	}],
	["rect", {
		x: "4",
		y: "2",
		width: "16",
		height: "20",
		rx: "2",
		key: "1uxh74"
	}]
]), r$3 = i$1("user-check", [
	["path", {
		d: "m16 11 2 2 4-4",
		key: "9rsbq5"
	}],
	["path", {
		d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
		key: "1yyitq"
	}],
	["circle", {
		cx: "9",
		cy: "7",
		r: "4",
		key: "nufk8"
	}]
]), r$4 = i$1("user", [["path", {
	d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",
	key: "975kel"
}], ["circle", {
	cx: "12",
	cy: "7",
	r: "4",
	key: "17ys0d"
}]]), h = i$1("network", [
	["rect", {
		x: "16",
		y: "16",
		width: "6",
		height: "6",
		rx: "1",
		key: "4q2zg0"
	}],
	["rect", {
		x: "2",
		y: "16",
		width: "6",
		height: "6",
		rx: "1",
		key: "8cvhb9"
	}],
	["rect", {
		x: "9",
		y: "2",
		width: "6",
		height: "6",
		rx: "1",
		key: "1egb70"
	}],
	["path", {
		d: "M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3",
		key: "1jsf9p"
	}],
	["path", {
		d: "M12 12V8",
		key: "2874zd"
	}]
]), a$3 = i$1("file-text", [
	["path", {
		d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",
		key: "1rqfz7"
	}],
	["path", {
		d: "M14 2v4a2 2 0 0 0 2 2h4",
		key: "tnqrlb"
	}],
	["path", {
		d: "M10 9H8",
		key: "b1mrlr"
	}],
	["path", {
		d: "M16 13H8",
		key: "t4e002"
	}],
	["path", {
		d: "M16 17H8",
		key: "z1uh3a"
	}]
]), r$5 = i$1("square", [["rect", {
	width: "18",
	height: "18",
	x: "3",
	y: "3",
	rx: "2",
	key: "afitv7"
}]]), e$2 = i$1("cpu", [
	["path", {
		d: "M12 20v2",
		key: "1lh1kg"
	}],
	["path", {
		d: "M12 2v2",
		key: "tus03m"
	}],
	["path", {
		d: "M17 20v2",
		key: "1rnc9c"
	}],
	["path", {
		d: "M17 2v2",
		key: "11trls"
	}],
	["path", {
		d: "M2 12h2",
		key: "1t8f8n"
	}],
	["path", {
		d: "M2 17h2",
		key: "7oei6x"
	}],
	["path", {
		d: "M2 7h2",
		key: "asdhe0"
	}],
	["path", {
		d: "M20 12h2",
		key: "1q8mjw"
	}],
	["path", {
		d: "M20 17h2",
		key: "1fpfkl"
	}],
	["path", {
		d: "M20 7h2",
		key: "1o8tra"
	}],
	["path", {
		d: "M7 20v2",
		key: "4gnj0m"
	}],
	["path", {
		d: "M7 2v2",
		key: "1i4yhu"
	}],
	["rect", {
		x: "4",
		y: "4",
		width: "16",
		height: "16",
		rx: "2",
		key: "1vbyd7"
	}],
	["rect", {
		x: "8",
		y: "8",
		width: "8",
		height: "8",
		rx: "1",
		key: "z9xiuo"
	}]
]), t$2 = i$1("circle-check-big", [["path", {
	d: "M21.801 10A10 10 0 1 1 17 3.335",
	key: "yps3ct"
}], ["path", {
	d: "m9 11 3 3L22 4",
	key: "1pflzl"
}]]), e$3 = i$1("tag", [["path", {
	d: "M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z",
	key: "vktsd0"
}], ["circle", {
	cx: "7.5",
	cy: "7.5",
	r: ".5",
	fill: "currentColor",
	key: "kqv944"
}]]), d = i$1("files", [
	["path", {
		d: "M15 2a2 2 0 0 1 1.414.586l4 4A2 2 0 0 1 21 8v7a2 2 0 0 1-2 2h-8a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z",
		key: "1vo8kb"
	}],
	["path", {
		d: "M15 2v4a2 2 0 0 0 2 2h4",
		key: "sud9ri"
	}],
	["path", {
		d: "M5 7a2 2 0 0 0-2 2v11a2 2 0 0 0 2 2h8a2 2 0 0 0 1.732-1",
		key: "l4dndm"
	}]
]), c = i$1("square-check-big", [["path", {
	d: "M21 10.656V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h12.344",
	key: "2acyp4"
}], ["path", {
	d: "m9 11 3 3L22 4",
	key: "1pflzl"
}]]), t$3 = i$1("gauge", [["path", {
	d: "m12 14 4-4",
	key: "9kzdfg"
}], ["path", {
	d: "M3.34 19a10 10 0 1 1 17.32 0",
	key: "19p75a"
}]]), c$1 = i$1("radio", [
	["path", {
		d: "M16.247 7.761a6 6 0 0 1 0 8.478",
		key: "1fwjs5"
	}],
	["path", {
		d: "M19.075 4.933a10 10 0 0 1 0 14.134",
		key: "ehdyv1"
	}],
	["path", {
		d: "M4.925 19.067a10 10 0 0 1 0-14.134",
		key: "1q22gi"
	}],
	["path", {
		d: "M7.753 16.239a6 6 0 0 1 0-8.478",
		key: "r2q7qm"
	}],
	["circle", {
		cx: "12",
		cy: "12",
		r: "2",
		key: "1c9p78"
	}]
]), h$1 = i$1("group", [
	["path", {
		d: "M3 7V5c0-1.1.9-2 2-2h2",
		key: "adw53z"
	}],
	["path", {
		d: "M17 3h2c1.1 0 2 .9 2 2v2",
		key: "an4l38"
	}],
	["path", {
		d: "M21 17v2c0 1.1-.9 2-2 2h-2",
		key: "144t0e"
	}],
	["path", {
		d: "M7 21H5c-1.1 0-2-.9-2-2v-2",
		key: "rtnfgi"
	}],
	["rect", {
		width: "7",
		height: "5",
		x: "7",
		y: "7",
		rx: "1",
		key: "1eyiv7"
	}],
	["rect", {
		width: "7",
		height: "5",
		x: "10",
		y: "12",
		rx: "1",
		key: "1qlmkx"
	}]
]), a$4 = i$1("gamepad-2", [
	["line", {
		x1: "6",
		x2: "10",
		y1: "11",
		y2: "11",
		key: "1gktln"
	}],
	["line", {
		x1: "8",
		x2: "8",
		y1: "9",
		y2: "13",
		key: "qnk9ow"
	}],
	["line", {
		x1: "15",
		x2: "15.01",
		y1: "12",
		y2: "12",
		key: "krot7o"
	}],
	["line", {
		x1: "18",
		x2: "18.01",
		y1: "10",
		y2: "10",
		key: "1lcuu1"
	}],
	["path", {
		d: "M17.32 5H6.68a4 4 0 0 0-3.978 3.59c-.006.052-.01.101-.017.152C2.604 9.416 2 14.456 2 16a3 3 0 0 0 3 3c1 0 1.5-.5 2-1l1.414-1.414A2 2 0 0 1 9.828 16h4.344a2 2 0 0 1 1.414.586L17 18c.5.5 1 1 2 1a3 3 0 0 0 3-3c0-1.545-.604-6.584-.685-7.258-.007-.05-.011-.1-.017-.151A4 4 0 0 0 17.32 5z",
		key: "mfqc10"
	}]
]), t$4 = i$1("upload", [
	["path", {
		d: "M12 3v12",
		key: "1x0j5s"
	}],
	["path", {
		d: "m17 8-5-5-5 5",
		key: "7q97r8"
	}],
	["path", {
		d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
		key: "ih7n3h"
	}]
]), t$5 = i$1("hand-platter", [
	["path", {
		d: "M12 3V2",
		key: "ar7q03"
	}],
	["path", {
		d: "m15.4 17.4 3.2-2.8a2 2 0 1 1 2.8 2.9l-3.6 3.3c-.7.8-1.7 1.2-2.8 1.2h-4c-1.1 0-2.1-.4-2.8-1.2l-1.302-1.464A1 1 0 0 0 6.151 19H5",
		key: "n2g93r"
	}],
	["path", {
		d: "M2 14h12a2 2 0 0 1 0 4h-2",
		key: "1o2jem"
	}],
	["path", {
		d: "M4 10h16",
		key: "img6z1"
	}],
	["path", {
		d: "M5 10a7 7 0 0 1 14 0",
		key: "1ega1o"
	}],
	["path", {
		d: "M5 14v6a1 1 0 0 1-1 1H2",
		key: "1hescx"
	}]
]), a$5 = i$1("list", [
	["path", {
		d: "M3 5h.01",
		key: "18ugdj"
	}],
	["path", {
		d: "M3 12h.01",
		key: "nlz23k"
	}],
	["path", {
		d: "M3 19h.01",
		key: "noohij"
	}],
	["path", {
		d: "M8 5h13",
		key: "1pao27"
	}],
	["path", {
		d: "M8 12h13",
		key: "1za7za"
	}],
	["path", {
		d: "M8 19h13",
		key: "m83p4d"
	}]
]), y$1 = i$1("server", [
	["rect", {
		width: "20",
		height: "8",
		x: "2",
		y: "2",
		rx: "2",
		ry: "2",
		key: "ngkwjq"
	}],
	["rect", {
		width: "20",
		height: "8",
		x: "2",
		y: "14",
		rx: "2",
		ry: "2",
		key: "iecqi9"
	}],
	["line", {
		x1: "6",
		x2: "6.01",
		y1: "6",
		y2: "6",
		key: "16zg32"
	}],
	["line", {
		x1: "6",
		x2: "6.01",
		y1: "18",
		y2: "18",
		key: "nzw8ys"
	}]
]), c$2 = i$1("shield", [["path", {
	d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
	key: "oel41y"
}]]), t$6 = i$1("external-link", [
	["path", {
		d: "M15 3h6v6",
		key: "1q9fwt"
	}],
	["path", {
		d: "M10 14 21 3",
		key: "gplh6r"
	}],
	["path", {
		d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
		key: "a6xqqp"
	}]
]), c$3 = i$1("shield-check", [["path", {
	d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
	key: "oel41y"
}], ["path", {
	d: "m9 12 2 2 4-4",
	key: "dzmm74"
}]]), t$7 = i$1("send", [["path", {
	d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
	key: "1ffxy3"
}], ["path", {
	d: "m21.854 2.147-10.94 10.939",
	key: "12cjpa"
}]]), c$4 = i$1("settings", [["path", {
	d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
	key: "1i5ecw"
}], ["circle", {
	cx: "12",
	cy: "12",
	r: "3",
	key: "1v7zrd"
}]]), t$8 = i$1("sliders-vertical", [
	["path", {
		d: "M10 8h4",
		key: "1sr2af"
	}],
	["path", {
		d: "M12 21v-9",
		key: "17s77i"
	}],
	["path", {
		d: "M12 8V3",
		key: "13r4qs"
	}],
	["path", {
		d: "M17 16h4",
		key: "h1uq16"
	}],
	["path", {
		d: "M19 12V3",
		key: "o1uvq1"
	}],
	["path", {
		d: "M19 21v-5",
		key: "qua636"
	}],
	["path", {
		d: "M3 14h4",
		key: "bcjad9"
	}],
	["path", {
		d: "M5 10V3",
		key: "cb8scm"
	}],
	["path", {
		d: "M5 21v-7",
		key: "1w1uti"
	}]
]), t$9 = i$1("database", [
	["ellipse", {
		cx: "12",
		cy: "5",
		rx: "9",
		ry: "3",
		key: "msslwz"
	}],
	["path", {
		d: "M3 5V19A9 3 0 0 0 21 19V5",
		key: "1wlel7"
	}],
	["path", {
		d: "M3 12A9 3 0 0 0 21 12",
		key: "mv7ke4"
	}]
]), e$4 = i$1("box", [
	["path", {
		d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",
		key: "hh9hay"
	}],
	["path", {
		d: "m3.3 7 8.7 5 8.7-5",
		key: "g66t2b"
	}],
	["path", {
		d: "M12 22V12",
		key: "d0xqtd"
	}]
]), t$10 = i$1("file-code", [
	["path", {
		d: "M10 12.5 8 15l2 2.5",
		key: "1tg20x"
	}],
	["path", {
		d: "m14 12.5 2 2.5-2 2.5",
		key: "yinavb"
	}],
	["path", {
		d: "M14 2v4a2 2 0 0 0 2 2h4",
		key: "tnqrlb"
	}],
	["path", {
		d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z",
		key: "1mlx9k"
	}]
]), t$11 = i$1("package", [
	["path", {
		d: "M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z",
		key: "1a0edw"
	}],
	["path", {
		d: "M12 22V12",
		key: "d0xqtd"
	}],
	["polyline", {
		points: "3.29 7 12 12 20.71 7",
		key: "ousv84"
	}],
	["path", {
		d: "m7.5 4.27 9 5.15",
		key: "1c824w"
	}]
]), t$12 = i$1("shield-alert", [
	["path", {
		d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
		key: "oel41y"
	}],
	["path", {
		d: "M12 8v4",
		key: "1got3b"
	}],
	["path", {
		d: "M12 16h.01",
		key: "1drbdi"
	}]
]), o$1 = i$1("folder-open", [["path", {
	d: "m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2",
	key: "usdka0"
}]]), l = i$1("layers", [
	["path", {
		d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",
		key: "zw3jo"
	}],
	["path", {
		d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",
		key: "1wduqc"
	}],
	["path", {
		d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",
		key: "kqbvx6"
	}]
]), a$6 = i$1("repeat", [
	["path", {
		d: "m17 2 4 4-4 4",
		key: "nntrym"
	}],
	["path", {
		d: "M3 11v-1a4 4 0 0 1 4-4h14",
		key: "84bu3i"
	}],
	["path", {
		d: "m7 22-4-4 4-4",
		key: "1wqhfi"
	}],
	["path", {
		d: "M21 13v1a4 4 0 0 1-4 4H3",
		key: "1rx37r"
	}]
]), t$13 = i$1("play", [["path", {
	d: "M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z",
	key: "10ikf1"
}]]), c$5 = i$1("lock", [["rect", {
	width: "18",
	height: "11",
	x: "3",
	y: "11",
	rx: "2",
	ry: "2",
	key: "1w4ew1"
}], ["path", {
	d: "M7 11V7a5 5 0 0 1 10 0v4",
	key: "fwvmzm"
}]]), e$5 = i$1("battery-charging", [
	["path", {
		d: "m11 7-3 5h4l-3 5",
		key: "b4a64w"
	}],
	["path", {
		d: "M14.856 6H16a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.935",
		key: "lre1cr"
	}],
	["path", {
		d: "M22 14v-4",
		key: "14q9d5"
	}],
	["path", {
		d: "M5.14 18H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h2.936",
		key: "13q5k0"
	}]
]), a$7 = i$1("link-2", [
	["path", {
		d: "M9 17H7A5 5 0 0 1 7 7h2",
		key: "8i5ue5"
	}],
	["path", {
		d: "M15 7h2a5 5 0 1 1 0 10h-2",
		key: "1b9ql8"
	}],
	["line", {
		x1: "8",
		x2: "16",
		y1: "12",
		y2: "12",
		key: "1jonct"
	}]
]), t$14 = i$1("link", [["path", {
	d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71",
	key: "1cjeqo"
}], ["path", {
	d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71",
	key: "19qd67"
}]]), e$6 = i$1("cable", [
	["path", {
		d: "M17 19a1 1 0 0 1-1-1v-2a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2a1 1 0 0 1-1 1z",
		key: "trhst0"
	}],
	["path", {
		d: "M17 21v-2",
		key: "ds4u3f"
	}],
	["path", {
		d: "M19 14V6.5a1 1 0 0 0-7 0v11a1 1 0 0 1-7 0V10",
		key: "1mo9zo"
	}],
	["path", {
		d: "M21 21v-2",
		key: "eo0ou"
	}],
	["path", {
		d: "M3 5V3",
		key: "1k5hjh"
	}],
	["path", {
		d: "M4 10a2 2 0 0 1-2-2V6a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2a2 2 0 0 1-2 2z",
		key: "1dd30t"
	}],
	["path", {
		d: "M7 5V3",
		key: "1t1388"
	}]
]), e$7 = i$1("arrow-up", [["path", {
	d: "m5 12 7-7 7 7",
	key: "hav0vg"
}], ["path", {
	d: "M12 19V5",
	key: "x0mq9r"
}]]), a$8 = i$1("arrow-up-right", [["path", {
	d: "M7 7h10v10",
	key: "1tivn9"
}], ["path", {
	d: "M7 17 17 7",
	key: "1vkiza"
}]]), t$15 = i$1("file", [["path", {
	d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",
	key: "1rqfz7"
}], ["path", {
	d: "M14 2v4a2 2 0 0 0 2 2h4",
	key: "tnqrlb"
}]]), a$9 = i$1("minus", [["path", {
	d: "M5 12h14",
	key: "1ays0h"
}]]), e$8 = i$1("tags", [
	["path", {
		d: "M13.172 2a2 2 0 0 1 1.414.586l6.71 6.71a2.4 2.4 0 0 1 0 3.408l-4.592 4.592a2.4 2.4 0 0 1-3.408 0l-6.71-6.71A2 2 0 0 1 6 9.172V3a1 1 0 0 1 1-1z",
		key: "16rjxf"
	}],
	["path", {
		d: "M2 7v6.172a2 2 0 0 0 .586 1.414l6.71 6.71a2.4 2.4 0 0 0 3.191.193",
		key: "178nd4"
	}],
	["circle", {
		cx: "10.5",
		cy: "6.5",
		r: ".5",
		fill: "currentColor",
		key: "12ikhr"
	}]
]), r$6 = i$1("arrow-down", [["path", {
	d: "M12 5v14",
	key: "s699le"
}], ["path", {
	d: "m19 12-7 7-7-7",
	key: "1idqje"
}]]), r$7 = i$1("git-branch", [
	["line", {
		x1: "6",
		x2: "6",
		y1: "3",
		y2: "15",
		key: "17qcm7"
	}],
	["circle", {
		cx: "18",
		cy: "6",
		r: "3",
		key: "1h7g24"
	}],
	["circle", {
		cx: "6",
		cy: "18",
		r: "3",
		key: "fqmcym"
	}],
	["path", {
		d: "M18 9a9 9 0 0 1-9 9",
		key: "n2h4wq"
	}]
]), a$10 = i$1("hard-drive", [
	["line", {
		x1: "22",
		x2: "2",
		y1: "12",
		y2: "12",
		key: "1y58io"
	}],
	["path", {
		d: "M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z",
		key: "oot6mr"
	}],
	["line", {
		x1: "6",
		x2: "6.01",
		y1: "16",
		y2: "16",
		key: "sgf278"
	}],
	["line", {
		x1: "10",
		x2: "10.01",
		y1: "16",
		y2: "16",
		key: "1l4acy"
	}]
]), o$2 = i$1("globe", [
	["circle", {
		cx: "12",
		cy: "12",
		r: "10",
		key: "1mglay"
	}],
	["path", {
		d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20",
		key: "13o1zl"
	}],
	["path", {
		d: "M2 12h20",
		key: "9i4pu4"
	}]
]), a$11 = i$1("key", [
	["path", {
		d: "m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4",
		key: "g0fldk"
	}],
	["path", {
		d: "m21 2-9.6 9.6",
		key: "1j0ho8"
	}],
	["circle", {
		cx: "7.5",
		cy: "15.5",
		r: "5.5",
		key: "yqb3hr"
	}]
]), a$12 = i$1("history", [
	["path", {
		d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",
		key: "1357e3"
	}],
	["path", {
		d: "M3 3v5h5",
		key: "1xhq8a"
	}],
	["path", {
		d: "M12 7v5l4 2",
		key: "1fdv2h"
	}]
]), t$16 = i$1("heading", [
	["path", {
		d: "M6 12h12",
		key: "8npq4p"
	}],
	["path", {
		d: "M6 20V4",
		key: "1w1bmo"
	}],
	["path", {
		d: "M18 20V4",
		key: "o2hl4u"
	}]
]), o$3 = i$1("folder", [["path", {
	d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z",
	key: "1kt360"
}]]), r$8 = i$1("git-fork", [
	["circle", {
		cx: "12",
		cy: "18",
		r: "3",
		key: "1mpf1b"
	}],
	["circle", {
		cx: "6",
		cy: "6",
		r: "3",
		key: "1lh9wr"
	}],
	["circle", {
		cx: "18",
		cy: "6",
		r: "3",
		key: "1h7g24"
	}],
	["path", {
		d: "M18 9v2c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V9",
		key: "1uq4wg"
	}],
	["path", {
		d: "M12 12v3",
		key: "158kv8"
	}]
]), k = i$1("user-cog", [
	["path", {
		d: "M10 15H6a4 4 0 0 0-4 4v2",
		key: "1nfge6"
	}],
	["path", {
		d: "m14.305 16.53.923-.382",
		key: "1itpsq"
	}],
	["path", {
		d: "m15.228 13.852-.923-.383",
		key: "eplpkm"
	}],
	["path", {
		d: "m16.852 12.228-.383-.923",
		key: "13v3q0"
	}],
	["path", {
		d: "m16.852 17.772-.383.924",
		key: "1i8mnm"
	}],
	["path", {
		d: "m19.148 12.228.383-.923",
		key: "1q8j1v"
	}],
	["path", {
		d: "m19.53 18.696-.382-.924",
		key: "vk1qj3"
	}],
	["path", {
		d: "m20.772 13.852.924-.383",
		key: "n880s0"
	}],
	["path", {
		d: "m20.772 16.148.924.383",
		key: "1g6xey"
	}],
	["circle", {
		cx: "18",
		cy: "15",
		r: "3",
		key: "gjjjvw"
	}],
	["circle", {
		cx: "9",
		cy: "7",
		r: "4",
		key: "nufk8"
	}]
]), c$6 = i$1("square-function", [
	["rect", {
		width: "18",
		height: "18",
		x: "3",
		y: "3",
		rx: "2",
		ry: "2",
		key: "1m3agn"
	}],
	["path", {
		d: "M9 17c2 0 2.8-1 2.8-2.8V10c0-2 1-3.3 3.2-3",
		key: "m1af9g"
	}],
	["path", {
		d: "M9 11.2h5.7",
		key: "3zgcl2"
	}]
]), d$1 = i$1("list-ordered", [
	["path", {
		d: "M11 5h10",
		key: "1cz7ny"
	}],
	["path", {
		d: "M11 12h10",
		key: "1438ji"
	}],
	["path", {
		d: "M11 19h10",
		key: "11t30w"
	}],
	["path", {
		d: "M4 4h1v5",
		key: "10yrso"
	}],
	["path", {
		d: "M4 9h2",
		key: "r1h2o0"
	}],
	["path", {
		d: "M6.5 20H3.4c0-1 2.6-1.925 2.6-3.5a1.5 1.5 0 0 0-2.6-1.02",
		key: "xtkcd5"
	}]
]), t$17 = i$1("table-2", [["path", {
	d: "M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18",
	key: "gugj83"
}]]), h$2 = i$1("layout-template", [
	["rect", {
		width: "18",
		height: "7",
		x: "3",
		y: "3",
		rx: "1",
		key: "f1a2em"
	}],
	["rect", {
		width: "9",
		height: "7",
		x: "3",
		y: "14",
		rx: "1",
		key: "jqznyg"
	}],
	["rect", {
		width: "5",
		height: "7",
		x: "16",
		y: "14",
		rx: "1",
		key: "q5h2i8"
	}]
]), h$3 = i$1("table", [
	["path", {
		d: "M12 3v18",
		key: "108xh3"
	}],
	["rect", {
		width: "18",
		height: "18",
		x: "3",
		y: "3",
		rx: "2",
		key: "afitv7"
	}],
	["path", {
		d: "M3 9h18",
		key: "1pudct"
	}],
	["path", {
		d: "M3 15h18",
		key: "5xshup"
	}]
]), x$1 = i$1("gamepad", [
	["line", {
		x1: "6",
		x2: "10",
		y1: "12",
		y2: "12",
		key: "161bw2"
	}],
	["line", {
		x1: "8",
		x2: "8",
		y1: "10",
		y2: "14",
		key: "1i6ji0"
	}],
	["line", {
		x1: "15",
		x2: "15.01",
		y1: "13",
		y2: "13",
		key: "dqpgro"
	}],
	["line", {
		x1: "18",
		x2: "18.01",
		y1: "11",
		y2: "11",
		key: "meh2c"
	}],
	["rect", {
		width: "20",
		height: "12",
		x: "2",
		y: "6",
		rx: "2",
		key: "9lu3g6"
	}]
]), p = i$1("plug-zap", [
	["path", {
		d: "M6.3 20.3a2.4 2.4 0 0 0 3.4 0L12 18l-6-6-2.3 2.3a2.4 2.4 0 0 0 0 3.4Z",
		key: "goz73y"
	}],
	["path", {
		d: "m2 22 3-3",
		key: "19mgm9"
	}],
	["path", {
		d: "M7.5 13.5 10 11",
		key: "7xgeeb"
	}],
	["path", {
		d: "M10.5 16.5 13 14",
		key: "10btkg"
	}],
	["path", {
		d: "m18 3-4 4h6l-4 4",
		key: "16psg9"
	}]
]), t$18 = i$1("wifi", [
	["path", {
		d: "M12 20h.01",
		key: "zekei9"
	}],
	["path", {
		d: "M2 8.82a15 15 0 0 1 20 0",
		key: "dnpr2z"
	}],
	["path", {
		d: "M5 12.859a10 10 0 0 1 14 0",
		key: "1x1e6c"
	}],
	["path", {
		d: "M8.5 16.429a5 5 0 0 1 7 0",
		key: "1bycff"
	}]
]), h$4 = i$1("binary", [
	["rect", {
		x: "14",
		y: "14",
		width: "4",
		height: "6",
		rx: "2",
		key: "p02svl"
	}],
	["rect", {
		x: "6",
		y: "4",
		width: "4",
		height: "6",
		rx: "2",
		key: "xm4xkj"
	}],
	["path", {
		d: "M6 20h4",
		key: "1i6q5t"
	}],
	["path", {
		d: "M14 10h4",
		key: "ru81e7"
	}],
	["path", {
		d: "M6 14h2v6",
		key: "16z9wg"
	}],
	["path", {
		d: "M14 4h2v6",
		key: "1idq9u"
	}]
]), r$9 = i$1("layout-grid", [
	["rect", {
		width: "7",
		height: "7",
		x: "3",
		y: "3",
		rx: "1",
		key: "1g98yp"
	}],
	["rect", {
		width: "7",
		height: "7",
		x: "14",
		y: "3",
		rx: "1",
		key: "6d4xhi"
	}],
	["rect", {
		width: "7",
		height: "7",
		x: "14",
		y: "14",
		rx: "1",
		key: "nxv5o0"
	}],
	["rect", {
		width: "7",
		height: "7",
		x: "3",
		y: "14",
		rx: "1",
		key: "1bb6yr"
	}]
]), o$4 = i$1("columns-2", [["rect", {
	width: "18",
	height: "18",
	x: "3",
	y: "3",
	rx: "2",
	key: "afitv7"
}], ["path", {
	d: "M12 3v18",
	key: "108xh3"
}]]), p$1 = i$1("app-window", [
	["rect", {
		x: "2",
		y: "4",
		width: "20",
		height: "16",
		rx: "2",
		key: "izxlao"
	}],
	["path", {
		d: "M10 4v4",
		key: "pp8u80"
	}],
	["path", {
		d: "M2 8h20",
		key: "d11cs7"
	}],
	["path", {
		d: "M6 4v4",
		key: "1svtjw"
	}]
]), e$9 = i$1("map-pin", [["path", {
	d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
	key: "1r0f0z"
}], ["circle", {
	cx: "12",
	cy: "10",
	r: "3",
	key: "ilqhr7"
}]]), re = {
	AccessControl: c$3,
	AccessPoint: i$1("plug", [
		["path", {
			d: "M12 22v-5",
			key: "1ega77"
		}],
		["path", {
			d: "M9 8V2",
			key: "14iosj"
		}],
		["path", {
			d: "M15 8V2",
			key: "18g5xt"
		}],
		["path", {
			d: "M18 8v5a4 4 0 0 1-4 4h-4a4 4 0 0 1-4-4V8Z",
			key: "osxo6l"
		}]
	]),
	Address: e$9,
	AllocationRole: k,
	AllocationRoleRef: r$3,
	AnalogueWiringParameters: e,
	AnalogueWiringParametersRef: e,
	Application: p$1,
	ApplicationSclRef: t$6,
	Association: t$14,
	Authentication: a$11,
	BDA: t$9,
	Bay: o$4,
	BayType: r$9,
	BehaviorDescription: a$3,
	BehaviorDescriptionRef: a$3,
	BehaviorReference: a,
	BinaryWiringParameters: h$4,
	BinaryWiringParametersRef: h$4,
	BitRate: t$3,
	CheckoutID: t$2,
	ClientLN: r$2,
	ClientServices: y$1,
	CommProt: c$2,
	Communication: t$18,
	CommunicationServiceSpecifications: h,
	ConductingEquipment: t,
	ConfDataSet: c$4,
	ConfLNs: c$4,
	ConfLdName: c$4,
	ConfLogControl: c$4,
	ConfReportControl: c$4,
	ConfSG: c$4,
	ConfSigRef: c$4,
	ConnectedAP: p,
	ConnectivityNode: r$7,
	ControlRef: a$4,
	ControllingLNode: x$1,
	DA: t$9,
	DAI: t$9,
	DAS: t$9,
	DAType: l,
	DO: e$4,
	DOI: e$4,
	DOS: e$4,
	DOType: l,
	DataObjectDirectory: o$3,
	DataSet: h$3,
	DataSetDirectory: o$1,
	DataTypeTemplates: h$2,
	DynAssociation: a$7,
	DynDataSet: t$17,
	EnumType: a$5,
	EnumVal: d$1,
	EqFunction: c$6,
	EqSubFunction: r$5,
	ExtCtrl: t$6,
	ExtRef: a$8,
	FCDA: t$9,
	FileHandling: t$15,
	Function: c$6,
	FunctionCatRef: e$3,
	FunctionCategory: e$3,
	FunctionCategoryRef: e$3,
	FunctionRef: a,
	FunctionRole: k,
	FunctionRoleContent: r$4,
	FunctionSclRef: t$6,
	FunctionTemplate: a$3,
	FunctionalSubVariant: r$7,
	FunctionalVariant: r$8,
	FunctionalVariantGroup: h$1,
	FunctionalVariantRef: a,
	GOOSE: t$7,
	GOOSEMcSecurity: c$3,
	GOOSESecurity: c$2,
	GSE: t$7,
	GSEControl: a$4,
	GSEDir: o$3,
	GSESettings: c$4,
	GSSE: t$7,
	GeneralEquipment: e$2,
	GetCBValues: t$4,
	GetDataObjectDefinition: t$4,
	GetDataSetValue: t$4,
	GetDirectory: o$1,
	GooseParameters: t$8,
	GooseParametersRef: t$8,
	Header: t$16,
	History: a$12,
	Hitem: o,
	IED: e$2,
	IEDName: e$3,
	IEDSourceFiles: d,
	InputVar: r$6,
	InputVarRef: a$8,
	Inputs: r$6,
	IssuerName: r$4,
	KDC: a$11,
	L2CommParameters: h,
	L3IPv4CommParameters: o$2,
	L3IPv6CommParameters: o$2,
	LDevice: a$10,
	LN: e$4,
	LN0: r$5,
	LNode: r$7,
	LNodeDataRef: a,
	LNodeInputRef: a$8,
	LNodeInputs: r$6,
	LNodeOutputRef: a$8,
	LNodeOutputs: e$7,
	LNodeSpecNaming: e$3,
	LNodeType: l,
	Label: e$3,
	Labels: e$8,
	Line: a$9,
	Log: a$3,
	LogControl: a$4,
	LogParameters: t$8,
	LogParametersRef: t$8,
	LogSettings: c$4,
	MaxTime: o,
	McSecurity: c$2,
	MinRequestedSCDFile: t$15,
	MinRequestedSCDFiles: d,
	MinTime: o,
	MultiAPPerSubNet: h,
	NeutralPoint: r$5,
	OptFields: c,
	OutputVar: e$7,
	OutputVarRef: a$8,
	Outputs: e$7,
	P: t$1,
	PhysConn: e$6,
	PowerSystemRelation: t$14,
	PowerSystemRelationRef: a,
	PowerSystemRelations: a$7,
	PowerTransformer: e$5,
	Private: c$5,
	Process: t$13,
	ProcessEcho: a$6,
	ProcessResource: e$2,
	ProcessResourceRef: a,
	ProcessResources: l,
	Project: o$1,
	ProjectProcessReference: a,
	ProtNs: c$2,
	Protocol: h,
	ReadWrite: r,
	RedProt: t$12,
	ReportControl: a$4,
	ReportParameters: t$8,
	ReportParametersRef: t$8,
	ReportSettings: c$4,
	Resource: t$11,
	RptEnabled: r$1,
	SCL: t$10,
	SCSM: c$2,
	SDI: t$9,
	SDO: e$4,
	SDS: t$9,
	SGEdit: r,
	SMV: t$7,
	SMVParameters: t$8,
	SMVParametersRef: t$8,
	SMVSecurity: c$2,
	SMVSettings: c$4,
	SMVsc: t$7,
	SVMcSecurity: c$3,
	SampledValueControl: a$4,
	SamplesPerSec: t$3,
	SclFileReference: t$6,
	SecPerSamples: o,
	Security: c$2,
	Server: y$1,
	ServerAt: y$1,
	ServiceSpecifications: a$5,
	Services: t$5,
	SetDataSetValue: t$4,
	SettingControl: a$4,
	SettingGroups: h$1,
	SignalRole: c$1,
	SmpRate: t$3,
	SmvOpts: c,
	SourceFiles: d,
	SourceRef: a,
	SubCategory: e$3,
	SubCheckoutID: t$2,
	SubEquipment: e$2,
	SubFunction: r$5,
	SubFunctionTemplate: a$3,
	SubNetwork: h,
	Subject: r$4,
	SubscriberLNode: r$3,
	Substation: e$1,
	SupSubscription: r$2,
	TapChanger: r$1,
	Terminal: a$2,
	Text: t$1,
	TimeSyncProt: o,
	TimerActivatedControl: i,
	TransformerWinding: a$1,
	TrgOps: t,
	Val: x,
	ValueHandling: r,
	Variable: y,
	VariableApplyTo: a,
	VariableRef: a,
	Voltage: t,
	VoltageLevel: e
}, _hoisted_1$1 = { class: "pl-2" }, element_tree_default = /* @__PURE__ */ defineComponent({
	__name: "element-tree",
	setup(u) {
		let { sdkInstance: T } = storeToRefs(useGlobalStore()), E = computedAsync(async () => {
			let u = await T.value?.api.fromRoot().getChildren();
			if (!u) return [];
			function E(u) {
				return {
					tag: u.tagName,
					id: u.id,
					...u.treeChildren.length && { children: u.treeChildren.map((u) => E(u)) }
				};
			}
			return [E(u)];
		}), O = computed(() => E.value?.find((u) => u.tag === "SCL")?.id);
		return (u, T) => O.value ? (openBlock(), createBlock(unref(TreeRoot_default), {
			key: 0,
			class: "list-none select-none w-full text-stone-700 p-2 text-sm font-medium",
			items: unref(E),
			"get-key": (u) => u.id,
			"default-expanded": [O.value]
		}, {
			default: withCtx(({ flattenItems: u }) => [(openBlock(!0), createElementBlock(Fragment, null, renderList(u, (u) => (openBlock(), createBlock(unref(TreeItem_default), mergeProps({
				key: u.value.id,
				style: { "padding-left": `${u.level - .5}rem` }
			}, { ref_for: !0 }, u.bind, { class: "flex items-center py-1 px-2 my-0.5 rounded outline-none focus:ring-grass8 focus:ring-2 data-[selected]:bg-grass4" }), {
				default: withCtx(() => [unref(re)[u.value.tag] ? (openBlock(), createBlock(resolveDynamicComponent(unref(re)[u.value.tag]), {
					key: 0,
					class: "h-4 w-4"
				})) : createCommentVNode("", !0), createBaseVNode("div", _hoisted_1$1, toDisplayString(u.value.tag), 1)]),
				_: 2
			}, 1040, ["style"]))), 128))]),
			_: 1
		}, 8, [
			"items",
			"get-key",
			"default-expanded"
		])) : createCommentVNode("", !0);
	}
}), _hoisted_1 = { class: "overflow-auto h-full" }, _hoisted_2 = { class: "pb-5" }, app_default = /* @__PURE__ */ defineComponent({
	__name: "app",
	props: { api: {} },
	setup(u) {
		let T = u, E = useGlobalStore(), O = ref();
		return onMounted(() => {
			O.value = T.api.activeFileName.subscribe((u) => {
				u && E.initApp(u);
			}), T.api.activeFileName.value && E.initApp(T.api.activeFileName.value);
		}), onUnmounted(() => {
			O.value?.();
		}), (u, T) => (openBlock(), createElementBlock("article", _hoisted_1, [createBaseVNode("div", _hoisted_2, [createVNode(element_tree_default)])]));
	}
});
function start(u, T) {
	if (!document.getElementById(u)) {
		console.error({
			msg: "could not found root element",
			rootId: u
		});
		return;
	}
	let E = createApp(app_default, { api: T });
	return E.use(createPinia()), E.mount(`#${u}`), E.unmount;
}
export { start as default };
