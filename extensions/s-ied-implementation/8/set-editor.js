(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode(`.layout[data-v-30346480]{display:grid;height:100vh;grid-template-rows:auto 1fr;grid-template-columns:4rem 1fr}.menubar[data-v-30346480]{grid-column-start:1;grid-column-end:5}.activity-bar[data-v-30346480]{padding:.5rem}@layer daisyui.component{:where(.btn-close[data-v-dadc7e4b]){width:unset}.btn-close[data-v-dadc7e4b]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-close[data-v-dadc7e4b]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-close[data-v-dadc7e4b]{--btn-noise:var(--fx-noise)}.prose .btn-close[data-v-dadc7e4b]{text-decoration-line:none}@media (hover:hover){.btn-close[data-v-dadc7e4b]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-close[data-v-dadc7e4b]:focus-visible,.btn-close[data-v-dadc7e4b]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-close[data-v-dadc7e4b]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-close[data-v-dadc7e4b]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-close[data-v-dadc7e4b]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-close[data-v-dadc7e4b]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-close[data-v-dadc7e4b]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-close[data-v-dadc7e4b]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}}@layer daisyui.modifier{.btn-close[data-v-dadc7e4b]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-close[data-v-dadc7e4b]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-close[data-v-dadc7e4b]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-close[data-v-dadc7e4b]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-close[data-v-dadc7e4b]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-close[disabled][data-v-dadc7e4b]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-dadc7e4b]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-close[disabled][data-v-dadc7e4b]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-close[disabled][data-v-dadc7e4b]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-dadc7e4b]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-close[disabled][data-v-dadc7e4b]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-dadc7e4b]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-close[disabled][data-v-dadc7e4b]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-dadc7e4b]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-close[data-v-dadc7e4b]{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}}@layer daisyui.component{:where(.btn-close[data-v-50475871]){width:unset}.btn-close[data-v-50475871]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-50475871]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-close[data-v-50475871]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-50475871]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-close[data-v-50475871]{--btn-noise:var(--fx-noise)}.prose .btn-close[data-v-50475871]{text-decoration-line:none}@media (hover:hover){.btn-close[data-v-50475871]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-50475871]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-close[data-v-50475871]:focus-visible,.btn-close[data-v-50475871]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-close[data-v-50475871]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-50475871]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-close[data-v-50475871]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-50475871]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-close[data-v-50475871]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-close[data-v-50475871]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-close[data-v-50475871]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-close[data-v-50475871]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}}@layer daisyui.modifier{.btn-close[data-v-50475871]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-50475871]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-close[data-v-50475871]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-close[data-v-50475871]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-50475871]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-close[data-v-50475871]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-50475871]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-close[data-v-50475871]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-50475871]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-close[disabled][data-v-50475871]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-50475871]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-close[disabled][data-v-50475871]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-close[disabled][data-v-50475871]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-50475871]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-close[disabled][data-v-50475871]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-50475871]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-close[disabled][data-v-50475871]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-50475871]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-close[data-v-50475871]{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}}@layer daisyui.component{:where(.btn-no[data-v-6ff5041e]){width:unset}.btn-no[data-v-6ff5041e]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-no[data-v-6ff5041e]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-no[data-v-6ff5041e]{--btn-noise:var(--fx-noise)}.prose .btn-no[data-v-6ff5041e]{text-decoration-line:none}@media (hover:hover){.btn-no[data-v-6ff5041e]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-no[data-v-6ff5041e]:focus-visible,.btn-no[data-v-6ff5041e]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-no[data-v-6ff5041e]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-no[data-v-6ff5041e]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-no[data-v-6ff5041e]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-no[data-v-6ff5041e]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-no[data-v-6ff5041e]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-no[data-v-6ff5041e]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}:where(.btn-yes[data-v-6ff5041e]){width:unset}.btn-yes[data-v-6ff5041e]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-yes[data-v-6ff5041e]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-yes[data-v-6ff5041e]{--btn-noise:var(--fx-noise)}.prose .btn-yes[data-v-6ff5041e]{text-decoration-line:none}@media (hover:hover){.btn-yes[data-v-6ff5041e]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-yes[data-v-6ff5041e]:focus-visible,.btn-yes[data-v-6ff5041e]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-yes[data-v-6ff5041e]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-yes[data-v-6ff5041e]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-yes[data-v-6ff5041e]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-yes[data-v-6ff5041e]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-yes[data-v-6ff5041e]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-yes[data-v-6ff5041e]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}}@layer daisyui.modifier{.btn-no[data-v-6ff5041e]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-no[data-v-6ff5041e]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-no[data-v-6ff5041e]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-no[data-v-6ff5041e]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-no[data-v-6ff5041e]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-no[disabled][data-v-6ff5041e]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[disabled][data-v-6ff5041e]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-no[disabled][data-v-6ff5041e]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-no[disabled][data-v-6ff5041e]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[disabled][data-v-6ff5041e]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-no[disabled][data-v-6ff5041e]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-no[disabled][data-v-6ff5041e]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-no[disabled][data-v-6ff5041e]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[disabled][data-v-6ff5041e]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-no[data-v-6ff5041e]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}@media (hover:none){.btn-no[data-v-6ff5041e]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}}.btn-no[data-v-6ff5041e]{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.btn-yes[data-v-6ff5041e]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-yes[data-v-6ff5041e]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-yes[data-v-6ff5041e]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-yes[data-v-6ff5041e]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-yes[data-v-6ff5041e]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-yes[disabled][data-v-6ff5041e]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[disabled][data-v-6ff5041e]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-yes[disabled][data-v-6ff5041e]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-yes[disabled][data-v-6ff5041e]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[disabled][data-v-6ff5041e]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-yes[disabled][data-v-6ff5041e]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-yes[disabled][data-v-6ff5041e]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-yes[disabled][data-v-6ff5041e]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[disabled][data-v-6ff5041e]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-yes[data-v-6ff5041e]{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.badge-soft[data-v-6ff5041e]{color:var(--badge-color,var(--color-base-content));background-color:var(--badge-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.badge-soft[data-v-6ff5041e]{background-color:color-mix(in oklab,var(--badge-color,var(--color-base-content))8%,var(--color-base-100))}}.badge-soft[data-v-6ff5041e]{border-color:var(--badge-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.badge-soft[data-v-6ff5041e]{border-color:color-mix(in oklab,var(--badge-color,var(--color-base-content))10%,var(--color-base-100))}}.badge-soft[data-v-6ff5041e]{background-image:none}.badge-warn[data-v-6ff5041e]{--badge-color:var(--color-neutral);--badge-fg:var(--color-neutral-content)}}.fade-slide-enter-from[data-v-d327a7a1],.fade-slide-leave-to[data-v-d327a7a1]{opacity:0;transform:translateY(16px)}.fade-slide-enter-active[data-v-d327a7a1]{transition:opacity .6s ease-out,transform .6s ease-out}.fade-slide-leave-active[data-v-d327a7a1]{transition:opacity .45s ease-in,transform .45s ease-in}.fade-slide-enter-to[data-v-d327a7a1],.fade-slide-leave-from[data-v-d327a7a1]{opacity:1;transform:translateY(0)}@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){[data-v-ee976485],[data-v-ee976485]:before,[data-v-ee976485]:after,[data-v-ee976485]::backdrop{--tw-leading:initial}}}@layer daisyui.component{.combobox-anchor[data-v-ee976485]{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);font-size:max(var(--font-size,.875rem),.875rem);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.combobox-anchor[data-v-ee976485]{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.combobox-anchor[data-v-ee976485]{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.combobox-anchor[data-v-ee976485]{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.combobox-anchor[data-v-ee976485]:where(input){display:inline-flex}.combobox-anchor[data-v-ee976485] :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.combobox-anchor[data-v-ee976485] :where(input):focus,.combobox-anchor[data-v-ee976485] :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.combobox-anchor[data-v-ee976485] :where(input):focus,.combobox-anchor[data-v-ee976485] :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.combobox-anchor[data-v-ee976485] :where(input[type=url]),.combobox-anchor[data-v-ee976485] :where(input[type=email]){direction:ltr}.combobox-anchor[data-v-ee976485] :where(input[type=date]){display:inline-flex}.combobox-anchor[data-v-ee976485]:focus,.combobox-anchor[data-v-ee976485]:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.combobox-anchor[data-v-ee976485]:focus,.combobox-anchor[data-v-ee976485]:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.combobox-anchor[data-v-ee976485]:focus,.combobox-anchor[data-v-ee976485]:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}@media (pointer:coarse){@supports (-webkit-touch-callout:none){.combobox-anchor[data-v-ee976485]:focus,.combobox-anchor[data-v-ee976485]:focus-within{--font-size:1rem}}}.combobox-anchor[data-v-ee976485]:has(>input[disabled]),.combobox-anchor[data-v-ee976485]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ee976485]{cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.combobox-anchor[data-v-ee976485]:has(>input[disabled]),.combobox-anchor[data-v-ee976485]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ee976485]{color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.combobox-anchor[data-v-ee976485]:has(>input[disabled]),.combobox-anchor[data-v-ee976485]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ee976485])::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.combobox-anchor[data-v-ee976485]:has(>input[disabled]),.combobox-anchor[data-v-ee976485]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ee976485])::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.combobox-anchor[data-v-ee976485]:has(>input[disabled]),.combobox-anchor[data-v-ee976485]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ee976485]{box-shadow:none}.combobox-anchor:has(>input[disabled])>input[disabled][data-v-ee976485]{cursor:not-allowed}.combobox-anchor[data-v-ee976485]::-webkit-date-and-time-value{text-align:inherit}.combobox-anchor[type=number][data-v-ee976485]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.combobox-anchor[data-v-ee976485]::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.combobox-anchor[data-v-ee976485]:has(>input[type=date]) :where(input[type=date]){webkit-appearance:none;appearance:none;display:inline-flex}.combobox-anchor:has(>input[type=date]) input[type=date][data-v-ee976485]::-webkit-calendar-picker-indicator{cursor:pointer;width:1em;height:1em;position:absolute;inset-inline-end:.75em}:where(.btn-remove-reset[data-v-ee976485]){width:unset}.btn-remove-reset[data-v-ee976485]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-remove-reset[data-v-ee976485]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-remove-reset[data-v-ee976485]{--btn-noise:var(--fx-noise)}.prose .btn-remove-reset[data-v-ee976485]{text-decoration-line:none}@media (hover:hover){.btn-remove-reset[data-v-ee976485]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-remove-reset[data-v-ee976485]:focus-visible,.btn-remove-reset[data-v-ee976485]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-remove-reset[data-v-ee976485]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-remove-reset[data-v-ee976485]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-remove-reset[data-v-ee976485]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-remove-reset[data-v-ee976485]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-remove-reset[data-v-ee976485]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-remove-reset[data-v-ee976485]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}:where(.btn-import-icd[data-v-ee976485]){width:unset}.btn-import-icd[data-v-ee976485]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-import-icd[data-v-ee976485]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-import-icd[data-v-ee976485]{--btn-noise:var(--fx-noise)}.prose .btn-import-icd[data-v-ee976485]{text-decoration-line:none}@media (hover:hover){.btn-import-icd[data-v-ee976485]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-import-icd[data-v-ee976485]:focus-visible,.btn-import-icd[data-v-ee976485]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-import-icd[data-v-ee976485]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-import-icd[data-v-ee976485]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-import-icd[data-v-ee976485]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-import-icd[data-v-ee976485]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-import-icd[data-v-ee976485]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-import-icd[data-v-ee976485]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}}.combobox-anchor[data-v-ee976485]{width:100%}@layer daisyui.modifier{.combobox-anchor[data-v-ee976485],.combobox-anchor[data-v-ee976485]:focus,.combobox-anchor[data-v-ee976485]:focus-within{--input-color:var(--color-primary)}.btn-remove-reset[data-v-ee976485]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-remove-reset[data-v-ee976485]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-remove-reset[data-v-ee976485]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-remove-reset[data-v-ee976485]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-remove-reset[data-v-ee976485]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-remove-reset[disabled][data-v-ee976485]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[disabled][data-v-ee976485]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-remove-reset[disabled][data-v-ee976485]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-remove-reset[disabled][data-v-ee976485]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[disabled][data-v-ee976485]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-remove-reset[disabled][data-v-ee976485]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[disabled][data-v-ee976485]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-remove-reset[disabled][data-v-ee976485]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[disabled][data-v-ee976485]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-remove-reset[data-v-ee976485]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}@media (hover:none){.btn-remove-reset[data-v-ee976485]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}}.btn-remove-reset[data-v-ee976485]{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.btn-import-icd[data-v-ee976485]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-import-icd[data-v-ee976485]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-import-icd[data-v-ee976485]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-import-icd[data-v-ee976485]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-import-icd[data-v-ee976485]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-import-icd[disabled][data-v-ee976485]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[disabled][data-v-ee976485]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-import-icd[disabled][data-v-ee976485]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-import-icd[disabled][data-v-ee976485]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[disabled][data-v-ee976485]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-import-icd[disabled][data-v-ee976485]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[disabled][data-v-ee976485]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-import-icd[disabled][data-v-ee976485]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[disabled][data-v-ee976485]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-import-icd[data-v-ee976485]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}@media (hover:none){.btn-import-icd[data-v-ee976485]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}}.btn-import-icd[data-v-ee976485]{--fontsize:.75rem;--btn-p:.75rem;--size:calc(var(--size-field,.25rem)*8);--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}}.combobox-item[data-v-ee976485]{cursor:pointer;height:25px;font-size:var(--text-xs,.75rem);line-height:var(--tw-leading,var(--text-xs--line-height,calc(1/.75)));--tw-leading:1;-webkit-user-select:none;user-select:none;border-radius:3px;justify-content:space-between;align-items:center;padding-left:25px;padding-right:35px;line-height:1;display:flex;position:relative}.combobox-item[data-disabled][data-v-ee976485]{pointer-events:none;color:var(--color-base-content)}.combobox-item[data-highlighted][data-v-ee976485]{background-color:var(--color-primary);color:var(--color-primary-content);--tw-outline-style:none;outline-style:none}.btn-remove-reset[data-v-ee976485]{flex:33.3333%}@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){[data-v-0ea1d8af],[data-v-0ea1d8af]:before,[data-v-0ea1d8af]:after,[data-v-0ea1d8af]::backdrop{--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000}}}@layer daisyui.component{:where(.dialog-button[data-v-0ea1d8af]){width:unset}.dialog-button[data-v-0ea1d8af]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.dialog-button[data-v-0ea1d8af]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.dialog-button[data-v-0ea1d8af]{--btn-noise:var(--fx-noise)}.prose .dialog-button[data-v-0ea1d8af]{text-decoration-line:none}@media (hover:hover){.dialog-button[data-v-0ea1d8af]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.dialog-button[data-v-0ea1d8af]:focus-visible,.dialog-button[data-v-0ea1d8af]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.dialog-button[data-v-0ea1d8af]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.dialog-button[data-v-0ea1d8af]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.dialog-button[data-v-0ea1d8af]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.dialog-button[data-v-0ea1d8af]:is(input[type=checkbox],input[type=radio]){appearance:none}.dialog-button[data-v-0ea1d8af]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.dialog-button[data-v-0ea1d8af]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}}@layer daisyui.modifier{.dialog-button[data-v-0ea1d8af]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.dialog-button[data-v-0ea1d8af]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.dialog-button[data-v-0ea1d8af]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.dialog-button[data-v-0ea1d8af]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.dialog-button[data-v-0ea1d8af]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.dialog-button[disabled][data-v-0ea1d8af]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[disabled][data-v-0ea1d8af]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.dialog-button[disabled][data-v-0ea1d8af]:not(.btn-link,.btn-ghost){box-shadow:none}.dialog-button[disabled][data-v-0ea1d8af]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[disabled][data-v-0ea1d8af]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.dialog-button[disabled][data-v-0ea1d8af]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.dialog-button[disabled][data-v-0ea1d8af]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.dialog-button[disabled][data-v-0ea1d8af]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[disabled][data-v-0ea1d8af]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.dialog-button[data-v-0ea1d8af]{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.dialog-button[data-v-0ea1d8af]:not(.btn-active,:hover,:active:focus,:focus-visible){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none}.dialog-button[data-v-0ea1d8af]:not(.btn-active,:hover,:active:focus,:focus-visible):not(:disabled,[disabled],.btn-disabled){--btn-fg:currentColor;outline-color:currentColor}@media (hover:none){.dialog-button[data-v-0ea1d8af]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none;--btn-fg:currentColor}}.dialog-button[data-v-0ea1d8af]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-fg:var(--btn-color,var(--color-base-content));--btn-bg:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-content))8%,var(--color-base-100))}}.dialog-button[data-v-0ea1d8af]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-content))10%,var(--color-base-100))}}.dialog-button[data-v-0ea1d8af]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-noise:none}@media (hover:none){.dialog-button[data-v-0ea1d8af]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-fg:var(--btn-color,var(--color-base-content));--btn-bg:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-content))8%,var(--color-base-100))}}.dialog-button[data-v-0ea1d8af]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-content))10%,var(--color-base-100))}}.dialog-button[data-v-0ea1d8af]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-noise:none}}.dialog-button[data-v-0ea1d8af]{--fontsize:.75rem;--btn-p:.75rem;--size:calc(var(--size-field,.25rem)*8);--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}}.dialog-button[data-v-0ea1d8af]{top:calc(var(--spacing,.25rem)*2);right:calc(var(--spacing,.25rem)*2);--tw-shadow:0 0 #0000;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow);position:absolute}@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-y-reverse:0;--tw-border-style:solid;--tw-leading:initial;--tw-font-weight:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-100:oklch(93.6% .032 17.717);--color-stone-700:oklch(37.4% .01 67.558);--color-black:#000;--spacing:.25rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--font-weight-medium:500;--font-weight-bold:700;--font-weight-black:900;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E");scrollbar-color:currentColor #0000}@supports (color:color-mix(in lab,red,red)){:root{scrollbar-color:color-mix(in oklch,currentColor 35%,#0000)#0000}}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),oklch(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}@supports (width:if(else: 1px)) and (animation-timeline:scroll()){:root{animation:forwards set-page-has-scroll;animation-timeline:scroll()}@keyframes set-page-has-scroll{0%,to{--page-has-scroll:1}}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:if(style(--page-has-scroll: 1): stable; else: unset)}}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:where(:root),:root:has(input.theme-controller[value=ocean-light]:checked),[data-theme=ocean-light]{color-scheme:light;--color-base-100:oklch(98% 0 0);--color-base-200:oklch(97% 0 0);--color-base-300:oklch(92% 0 0);--color-base-content:oklch(37% 0 0);--color-primary:oklch(58.13% .0903 209.8);--color-primary-content:oklch(100% 0 0);--color-secondary:oklch(65.24% .0821 207.95);--color-secondary-content:oklch(100% 0 0);--color-accent:oklch(60% .118 184.704);--color-accent-content:oklch(98% .001 106.423);--color-neutral:oklch(55% .013 58.071);--color-neutral-content:oklch(98% .031 120.757);--color-info:oklch(70% .165 254.624);--color-info-content:oklch(98% .001 106.423);--color-success:oklch(72% .219 149.579);--color-success-content:oklch(98% .001 106.423);--color-warning:oklch(87% .169 91.605);--color-warning-content:oklch(98% .001 106.423);--color-error:oklch(63% .237 25.331);--color-error-content:oklch(98% .001 106.423);--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-300)}}@layer components;@layer utilities{@layer daisyui.component{.modal{pointer-events:none;visibility:hidden;width:100%;max-width:none;height:100%;max-height:none;color:inherit;transition:visibility .3s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;overscroll-behavior:contain;z-index:999;scrollbar-gutter:auto;background-color:#0000;place-items:center;margin:0;padding:0;display:grid;position:fixed;inset:0;overflow:clip}.modal::backdrop{display:none}.dropdown{position-area:var(--anchor-v,bottom)var(--anchor-h,span-right);display:inline-block;position:relative}.dropdown>:not(summary):focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.dropdown>:not(summary):focus{outline-offset:2px;outline:2px solid #0000}}.dropdown .dropdown-content{position:absolute}.dropdown:not(details,.dropdown-open,.dropdown-hover:hover,:focus-within) .dropdown-content,.dropdown.dropdown-hover:not(:hover) [tabindex]:first-child:focus:not(:focus-visible)~.dropdown-content{transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover],.dropdown .dropdown-content{z-index:999}@media (prefers-reduced-motion:no-preference){.dropdown[popover],.dropdown .dropdown-content{transition-behavior:allow-discrete;transition-property:opacity,scale,display;transition-duration:.2s;transition-timing-function:cubic-bezier(.4,0,.2,1);animation:.2s dropdown}}@starting-style{.dropdown[popover],.dropdown .dropdown-content{opacity:0;scale:95%}}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within)>[tabindex]:first-child{pointer-events:none}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within) .dropdown-content{opacity:1}.dropdown.dropdown-hover:hover .dropdown-content{opacity:1;scale:100%}.dropdown:is(details) summary::-webkit-details-marker{display:none}:is(.dropdown.dropdown-open,.dropdown:focus,.dropdown:focus-within) .dropdown-content{scale:100%}.dropdown:where([popover]){background:0 0}.dropdown[popover]{color:inherit;position:fixed}@supports not (position-area:bottom){.dropdown[popover]{margin:auto}.dropdown[popover].dropdown-open:not(:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover]::backdrop{background-color:oklab(0% none none/.3)}}.dropdown[popover]:not(.dropdown-open,:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}:where(.btn){width:unset}.btn{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn{--btn-noise:var(--fx-noise)}.prose .btn{text-decoration-line:none}@media (hover:hover){.btn:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn:focus-visible,.btn:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn:is(input[type=checkbox],input[type=radio]){appearance:none}.btn:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.loading{pointer-events:none;aspect-ratio:1;vertical-align:middle;width:calc(var(--size-selector,.25rem)*6);background-color:currentColor;display:inline-block;-webkit-mask-image:url("data:image/svg+xml,%3Csvg width='24' height='24' stroke='black' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cg transform-origin='center'%3E%3Ccircle cx='12' cy='12' r='9.5' fill='none' stroke-width='3' stroke-linecap='round'%3E%3CanimateTransform attributeName='transform' type='rotate' from='0 12 12' to='360 12 12' dur='2s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dasharray' values='0,150;42,150;42,150' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dashoffset' values='0;-16;-59' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E");mask-image:url("data:image/svg+xml,%3Csvg width='24' height='24' stroke='black' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cg transform-origin='center'%3E%3Ccircle cx='12' cy='12' r='9.5' fill='none' stroke-width='3' stroke-linecap='round'%3E%3CanimateTransform attributeName='transform' type='rotate' from='0 12 12' to='360 12 12' dur='2s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dasharray' values='0,150;42,150;42,150' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dashoffset' values='0;-16;-59' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E");-webkit-mask-position:50%;mask-position:50%;-webkit-mask-size:100%;mask-size:100%;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat}.list{flex-direction:column;font-size:.875rem;display:flex}.list .list-row{--list-grid-cols:minmax(0,auto)1fr;border-radius:var(--radius-box);word-break:break-word;grid-auto-flow:column;grid-template-columns:var(--list-grid-cols);gap:1rem;padding:1rem;display:grid;position:relative}:is(.list>:not(:last-child).list-row,.list>:not(:last-child) .list-row):after{content:"";border-bottom:var(--border)solid;inset-inline:var(--radius-box);border-color:var(--color-base-content);position:absolute;bottom:0}@supports (color:color-mix(in lab,red,red)){:is(.list>:not(:last-child).list-row,.list>:not(:last-child) .list-row):after{border-color:color-mix(in oklab,var(--color-base-content)5%,transparent)}}.input{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);font-size:max(var(--font-size,.875rem),.875rem);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.input:where(input){display:inline-flex}.input :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.input :where(input):focus,.input :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.input :where(input):focus,.input :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.input :where(input[type=url]),.input :where(input[type=email]){direction:ltr}.input :where(input[type=date]){display:inline-flex}.input:focus,.input:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.input:focus,.input:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.input:focus,.input:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}@media (pointer:coarse){@supports (-webkit-touch-callout:none){.input:focus,.input:focus-within{--font-size:1rem}}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input{cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input{color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input)::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input)::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input{box-shadow:none}.input:has(>input[disabled])>input[disabled]{cursor:not-allowed}.input::-webkit-date-and-time-value{text-align:inherit}.input[type=number]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.input::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.input:has(>input[type=date]) :where(input[type=date]){webkit-appearance:none;appearance:none;display:inline-flex}.input:has(>input[type=date]) input[type=date]::-webkit-calendar-picker-indicator{cursor:pointer;width:1em;height:1em;position:absolute;inset-inline-end:.75em}.avatar{vertical-align:middle;display:inline-flex;position:relative}.avatar>div{aspect-ratio:1;display:block;overflow:hidden}.avatar img{object-fit:cover;width:100%;height:100%}.progress{appearance:none;border-radius:var(--radius-box);background-color:currentColor;width:100%;height:.5rem;position:relative;overflow:hidden}@supports (color:color-mix(in lab,red,red)){.progress{background-color:color-mix(in oklab,currentcolor 20%,transparent)}}.progress{color:var(--color-base-content)}.progress:indeterminate{background-image:repeating-linear-gradient(90deg,currentColor -1% 10%,#0000 10% 90%);background-position-x:15%;background-size:200%}@media (prefers-reduced-motion:no-preference){.progress:indeterminate{animation:5s ease-in-out infinite progress}}@supports ((-moz-appearance:none)){.progress:indeterminate::-moz-progress-bar{background-color:#0000}@media (prefers-reduced-motion:no-preference){.progress:indeterminate::-moz-progress-bar{background-image:repeating-linear-gradient(90deg,currentColor -1% 10%,#0000 10% 90%);background-position-x:15%;background-size:200%;animation:5s ease-in-out infinite progress}}.progress::-moz-progress-bar{border-radius:var(--radius-box);background-color:currentColor}}@supports ((-webkit-appearance:none)){.progress::-webkit-progress-bar{border-radius:var(--radius-box);background-color:#0000}.progress::-webkit-progress-value{border-radius:var(--radius-box);background-color:currentColor}}.file-input{cursor:pointer;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;webkit-user-select:none;-webkit-user-select:none;user-select:none;width:clamp(3rem,20rem,100%);height:var(--size);border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));align-items:center;padding-inline-end:.75rem;font-size:.875rem;line-height:2;display:inline-flex}@supports (color:color-mix(in lab,red,red)){.file-input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.file-input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.file-input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.file-input::file-selector-button{cursor:pointer;webkit-user-select:none;-webkit-user-select:none;user-select:none;height:calc(100% + var(--border)*2);margin-inline-end:1rem;margin-block:calc(var(--border)*-1);color:var(--btn-fg);border-width:var(--border);border-style:solid;border-color:var(--btn-border);background-color:var(--btn-bg);background-size:calc(var(--noise)*100%);background-image:var(--btn-noise);text-shadow:0 .5px oklch(1 0 0/calc(var(--depth)*.15));box-shadow:0 .5px 0 .5px #fff inset,var(--btn-shadow);border-start-start-radius:calc(var(--join-ss,var(--radius-field) - var(--border)));border-end-start-radius:calc(var(--join-es,var(--radius-field) - var(--border)));margin-inline-start:calc(var(--border)*-1);padding-inline:1rem;font-size:.875rem;font-weight:600}@supports (color:color-mix(in lab,red,red)){.file-input::file-selector-button{box-shadow:0 .5px 0 .5px color-mix(in oklab,color-mix(in oklab,white 30%,var(--btn-bg))calc(var(--depth)*20%),#0000) inset,var(--btn-shadow)}}.file-input::file-selector-button{--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-border:var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.file-input::file-selector-button{--btn-border:color-mix(in oklab,var(--btn-bg),#000 5%)}}.file-input::file-selector-button{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.file-input::file-selector-button{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)30%,#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)30%,#0000)}}.file-input::file-selector-button{--btn-noise:var(--fx-noise)}.file-input:focus{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.file-input:focus{box-shadow:0 1px color-mix(in oklab,var(--input-color)10%,#0000)}}.file-input:focus{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate}.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200)}:is(.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]){box-shadow:none;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]){color:color-mix(in oklch,var(--color-base-content)20%,#0000)}}:is(.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]))::file-selector-button{cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]))::file-selector-button{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}.modal-box{background-color:var(--color-base-100);border-top-left-radius:var(--modal-tl,var(--radius-box));border-top-right-radius:var(--modal-tr,var(--radius-box));border-bottom-left-radius:var(--modal-bl,var(--radius-box));border-bottom-right-radius:var(--modal-br,var(--radius-box));opacity:0;overscroll-behavior:contain;grid-row-start:1;grid-column-start:1;width:91.6667%;max-width:32rem;max-height:100vh;padding:1.5rem;transition:translate .3s ease-out,scale .3s ease-out,opacity .2s ease-out 50ms,box-shadow .3s ease-out;overflow-y:auto;scale:95%;box-shadow:0 25px 50px -12px #00000040}.filter{flex-wrap:wrap;display:flex}.filter input[type=radio]{width:auto}.filter input{opacity:1;transition:margin .1s,opacity .3s,padding .3s,border-width .1s;overflow:hidden;scale:1}.filter input:not(:last-child){margin-inline-end:.25rem}.filter input.filter-reset{aspect-ratio:1}.filter input.filter-reset:after{content:""}.filter:not(:has(input:checked:not(.filter-reset))) .filter-reset,.filter:not(:has(input:checked:not(.filter-reset))) input[type=reset],.filter:has(input:checked:not(.filter-reset)) input:not(:checked,.filter-reset,input[type=reset]){opacity:0;border-width:0;width:0;margin-inline:0;padding-inline:0;scale:0}.modal-action{justify-content:flex-end;gap:.5rem;margin-top:1.5rem;display:flex}.status{aspect-ratio:1;border-radius:var(--radius-selector);background-color:var(--color-base-content);width:.5rem;height:.5rem;display:inline-block}@supports (color:color-mix(in lab,red,red)){.status{background-color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.status{vertical-align:middle;color:#0000004d;background-position:50%;background-repeat:no-repeat}@supports (color:color-mix(in lab,red,red)){.status{color:color-mix(in oklab,var(--color-black)30%,transparent)}}.status{background-image:radial-gradient(circle at 35% 30%,oklch(1 0 0/calc(var(--depth)*.5)),#0000);box-shadow:0 2px 3px -1px}@supports (color:color-mix(in lab,red,red)){.status{box-shadow:0 2px 3px -1px color-mix(in oklab,currentColor calc(var(--depth)*100%),#0000)}}.badge{border-radius:var(--radius-selector);vertical-align:middle;color:var(--badge-fg);border:var(--border)solid var(--badge-color,var(--color-base-200));width:fit-content;padding-inline:calc(.25rem*3 - var(--border));background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);background-color:var(--badge-bg);--badge-bg:var(--badge-color,var(--color-base-100));--badge-fg:var(--color-base-content);--size:calc(var(--size-selector,.25rem)*6);height:var(--size);justify-content:center;align-items:center;gap:.5rem;font-size:.875rem;display:inline-flex}.alert{--alert-border-color:var(--color-base-200);border-radius:var(--radius-box);color:var(--color-base-content);background-color:var(--alert-color,var(--color-base-200));text-align:start;background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px #000,0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08));border-style:solid;grid-template-columns:auto;grid-auto-flow:column;justify-content:start;place-items:center start;gap:1rem;padding-block:.75rem;padding-inline:1rem;font-size:.875rem;line-height:1.25rem;display:grid}@supports (color:color-mix(in lab,red,red)){.alert{box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px color-mix(in oklab,color-mix(in oklab,#000 20%,var(--alert-color,var(--color-base-200)))calc(var(--depth)*20%),#0000),0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08))}}.alert:has(:nth-child(2)){grid-template-columns:auto minmax(auto,1fr)}}@layer daisyui.modifier{.modal.modal-open,.modal[open],.modal:target,.modal-toggle:checked+.modal{pointer-events:auto;visibility:visible;opacity:1;transition:visibility 0s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;background-color:#0006}:is(.modal.modal-open,.modal[open],.modal:target,.modal-toggle:checked+.modal) .modal-box{opacity:1;translate:0;scale:1}@starting-style{.modal.modal-open,.modal[open],.modal:target,.modal-toggle:checked+.modal{opacity:0}}.btn:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn[disabled]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn[disabled]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn[disabled]:not(.btn-link,.btn-ghost){box-shadow:none}.btn[disabled]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn[disabled]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn[disabled]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn[disabled]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn[disabled]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn[disabled]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.list .list-row:has(.list-col-grow:first-child){--list-grid-cols:1fr}.list .list-row:has(.list-col-grow:nth-child(2)){--list-grid-cols:minmax(0,auto)1fr}.list .list-row:has(.list-col-grow:nth-child(3)){--list-grid-cols:minmax(0,auto)minmax(0,auto)1fr}.list .list-row:has(.list-col-grow:nth-child(4)){--list-grid-cols:minmax(0,auto)minmax(0,auto)minmax(0,auto)1fr}.list .list-row:has(.list-col-grow:nth-child(5)){--list-grid-cols:minmax(0,auto)minmax(0,auto)minmax(0,auto)minmax(0,auto)1fr}.list .list-row:has(.list-col-grow:nth-child(6)){--list-grid-cols:minmax(0,auto)minmax(0,auto)minmax(0,auto)minmax(0,auto)minmax(0,auto)1fr}.list .list-row :not(.list-col-wrap){grid-row-start:1}.avatar-placeholder>div{justify-content:center;align-items:center;display:flex}.btn-circle{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.badge-soft{color:var(--badge-color,var(--color-base-content));background-color:var(--badge-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.badge-soft{background-color:color-mix(in oklab,var(--badge-color,var(--color-base-content))8%,var(--color-base-100))}}.badge-soft{border-color:var(--badge-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.badge-soft{border-color:color-mix(in oklab,var(--badge-color,var(--color-base-content))10%,var(--color-base-100))}}.badge-soft{background-image:none}.input-ghost{box-shadow:none;background-color:#0000;border-color:#0000}.input-ghost:focus,.input-ghost:focus-within{background-color:var(--color-base-100);color:var(--color-base-content);box-shadow:none;border-color:#0000}.loading-spinner{-webkit-mask-image:url("data:image/svg+xml,%3Csvg width='24' height='24' stroke='black' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cg transform-origin='center'%3E%3Ccircle cx='12' cy='12' r='9.5' fill='none' stroke-width='3' stroke-linecap='round'%3E%3CanimateTransform attributeName='transform' type='rotate' from='0 12 12' to='360 12 12' dur='2s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dasharray' values='0,150;42,150;42,150' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dashoffset' values='0;-16;-59' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E");mask-image:url("data:image/svg+xml,%3Csvg width='24' height='24' stroke='black' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cg transform-origin='center'%3E%3Ccircle cx='12' cy='12' r='9.5' fill='none' stroke-width='3' stroke-linecap='round'%3E%3CanimateTransform attributeName='transform' type='rotate' from='0 12 12' to='360 12 12' dur='2s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dasharray' values='0,150;42,150;42,150' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dashoffset' values='0;-16;-59' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E")}.alert-error{color:var(--color-error-content);--alert-border-color:var(--color-error);--alert-color:var(--color-error)}.file-input-primary{--btn-color:var(--color-primary)}.file-input-primary::file-selector-button{color:var(--color-primary-content)}.file-input-primary,.file-input-primary:focus,.file-input-primary:focus-within{--input-color:var(--color-primary)}.progress-primary{color:var(--color-primary)}.btn-ghost:not(.btn-active,:hover,:active:focus,:focus-visible){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none}.btn-ghost:not(.btn-active,:hover,:active:focus,:focus-visible):not(:disabled,[disabled],.btn-disabled){--btn-fg:currentColor;outline-color:currentColor}@media (hover:none){.btn-ghost:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none;--btn-fg:currentColor}}.btn-outline:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}@media (hover:none){.btn-outline:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}}.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-fg:var(--btn-color,var(--color-base-content));--btn-bg:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-content))8%,var(--color-base-100))}}.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-content))10%,var(--color-base-100))}}.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-noise:none}@media (hover:none){.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-fg:var(--btn-color,var(--color-base-content));--btn-bg:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-content))8%,var(--color-base-100))}}.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-content))10%,var(--color-base-100))}}.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-noise:none}}.btn-sm{--fontsize:.75rem;--btn-p:.75rem;--size:calc(var(--size-field,.25rem)*8)}.badge-error{--badge-color:var(--color-error);--badge-fg:var(--color-error-content)}.badge-neutral{--badge-color:var(--color-neutral);--badge-fg:var(--color-neutral-content)}.badge-primary{--badge-color:var(--color-primary);--badge-fg:var(--color-primary-content)}.badge-warning{--badge-color:var(--color-warning);--badge-fg:var(--color-warning-content)}.btn-primary{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.input-primary,.input-primary:focus,.input-primary:focus-within{--input-color:var(--color-primary)}}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.top-0{top:calc(var(--spacing)*0)}.top-2{top:calc(var(--spacing)*2)}.right-2{right:calc(var(--spacing)*2)}.left-0{left:calc(var(--spacing)*0)}.my-0\\.5{margin-block:calc(var(--spacing)*.5)}.mt-2{margin-top:calc(var(--spacing)*2)}.mt-10{margin-top:calc(var(--spacing)*10)}.mt-24{margin-top:calc(var(--spacing)*24)}.mr-5{margin-right:calc(var(--spacing)*5)}.mb-5{margin-bottom:calc(var(--spacing)*5)}.alert{border-width:var(--border);border-color:var(--alert-border-color,var(--color-base-200))}.flex{display:flex}.hidden{display:none}.inline-flex{display:inline-flex}.size-6{width:calc(var(--spacing)*6);height:calc(var(--spacing)*6)}.h-3{height:calc(var(--spacing)*3)}.h-4{height:calc(var(--spacing)*4)}.h-\\[25px\\]{height:25px}.h-full{height:100%}.h-screen{height:100vh}.w-1{width:calc(var(--spacing)*1)}.w-3{width:calc(var(--spacing)*3)}.w-4{width:calc(var(--spacing)*4)}.w-12{width:calc(var(--spacing)*12)}.w-56{width:calc(var(--spacing)*56)}.w-\\[25px\\]{width:25px}.w-full{width:100%}.w-max{width:max-content}.w-screen{width:100vw}.max-w-136{max-width:calc(var(--spacing)*136)}.min-w-fit{min-width:fit-content}.flex-2\\/3{flex:66.6667%}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.cursor-pointer{cursor:pointer}.list-none{list-style-type:none}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.gap-2{gap:calc(var(--spacing)*2)}.gap-4{gap:calc(var(--spacing)*4)}.gap-5{gap:calc(var(--spacing)*5)}:where(.space-y-5>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*5)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*5)*calc(1 - var(--tw-space-y-reverse)))}.self-end{align-self:flex-end}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.rounded{border-radius:.25rem}.rounded-\\[3px\\]{border-radius:3px}.rounded-box{border-radius:var(--radius-box)}.rounded-full{border-radius:3.40282e38px}.border-e{border-inline-end-style:var(--tw-border-style);border-inline-end-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.bg-base-100{background-color:var(--color-base-100)}.bg-base-300{background-color:var(--color-base-300)}.bg-red-100{background-color:var(--color-red-100)}@layer daisyui.style{.alert-soft{color:var(--alert-color,var(--color-base-content));background:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert-soft{background:color-mix(in oklab,var(--alert-color,var(--color-base-content))8%,var(--color-base-100))}}.alert-soft{--alert-border-color:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert-soft{--alert-border-color:color-mix(in oklab,var(--alert-color,var(--color-base-content))10%,var(--color-base-100))}}.alert-soft{box-shadow:none;background-image:none}}.p-2{padding:calc(var(--spacing)*2)}.p-4{padding:calc(var(--spacing)*4)}.p-\\[5px\\]{padding:5px}.px-2{padding-inline:calc(var(--spacing)*2)}.py-1{padding-block:calc(var(--spacing)*1)}.py-2{padding-block:calc(var(--spacing)*2)}.pr-\\[35px\\]{padding-right:35px}.pb-2{padding-bottom:calc(var(--spacing)*2)}.pb-20{padding-bottom:calc(var(--spacing)*20)}.pl-2{padding-left:calc(var(--spacing)*2)}.pl-\\[25px\\]{padding-left:25px}.text-center{text-align:center}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.leading-none{--tw-leading:1;line-height:1}.font-black{--tw-font-weight:var(--font-weight-black);font-weight:var(--font-weight-black)}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.text-base-content{color:var(--color-base-content)}.text-error{color:var(--color-error)}.text-error-content{color:var(--color-error-content)}.text-neutral-content{color:var(--color-neutral-content)}.text-primary{color:var(--color-primary)}.text-primary-content{color:var(--color-primary-content)}.text-stone-700{color:var(--color-stone-700)}.text-warning-content{color:var(--color-warning-content)}.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.outline-none{--tw-outline-style:none;outline-style:none}.select-none{-webkit-user-select:none;user-select:none}.focus\\:ring-2:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\\:ring-primary:focus{--tw-ring-color:var(--color-primary)}.data-\\[disabled\\]\\:pointer-events-none[data-disabled]{pointer-events:none}.data-\\[disabled\\]\\:text-base-content[data-disabled]{color:var(--color-base-content)}.data-\\[highlighted\\]\\:bg-primary[data-highlighted]{background-color:var(--color-primary)}.data-\\[highlighted\\]\\:outline-none[data-highlighted]{--tw-outline-style:none;outline-style:none}.data-\\[selected\\]\\:bg-primary\\/20[data-selected]{background-color:var(--color-primary)}@supports (color:color-mix(in lab,red,red)){.data-\\[selected\\]\\:bg-primary\\/20[data-selected]{background-color:color-mix(in oklab,var(--color-primary)20%,transparent)}}@media (min-width:40rem){.sm\\:block{display:block}}}:root{--color-ocean-gray-00:#fff;--color-ocean-gray-25:#fafbfb;--color-ocean-gray-50:#f5f6f7;--color-ocean-gray-75:#eaeeef;--color-ocean-gray-100:#e1e4e6;--color-ocean-gray-150:#c6ced1;--color-ocean-gray-200:#bac1c4;--color-ocean-gray-250:#9fadb2;--color-ocean-gray-300:#889499;--color-ocean-gray-350:#72858c;--color-ocean-gray-400:#617177;--color-ocean-gray-450:#3f555e;--color-ocean-gray-500:#394d55;--color-ocean-gray-550:#34464d;--color-ocean-gray-600:#2e3e44;--color-ocean-gray-650:#27353b;--color-ocean-gray-700:#222e33;--color-ocean-gray-750:#1f272b;--color-ocean-gray-800:#171f22;--color-ocean-gray-850:#11171a;--color-ocean-gray-900:#0b0f11;--color-chart-1:#f7931e;--color-chart-2:#40535b;--color-chart-3:#2798aa;--color-chart-4:#6da89c;--color-chart-5:#a4cadd;--color-chart-6:#97b42d;--color-chart-7:#ffcb05;--color-chart-8:#ee652e;--color-chart-9:#528694;--color-chart-10:#a10f3b}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes progress{50%{background-position-x:-115%}}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}`)),document.head.appendChild(o)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
// @__NO_SIDE_EFFECTS__
function Nc(e) {
  const l = /* @__PURE__ */ Object.create(null);
  for (const i of e.split(",")) l[i] = 1;
  return (i) => i in l;
}
const On = {}, Pa = [], bt = () => {
}, Pp = () => !1, ps = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // uppercase letter
(e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Zm = (e) => e.startsWith("onUpdate:"), kn = Object.assign, Um = (e, l) => {
  const i = e.indexOf(l);
  i > -1 && e.splice(i, 1);
}, Uv = Object.prototype.hasOwnProperty, Tn = (e, l) => Uv.call(e, l), Xe = Array.isArray, qa = (e) => ja(e) === "[object Map]", oa = (e) => ja(e) === "[object Set]", _f = (e) => ja(e) === "[object Date]", Kv = (e) => ja(e) === "[object RegExp]", cn = (e) => typeof e == "function", Wn = (e) => typeof e == "string", fi = (e) => typeof e == "symbol", _n = (e) => e !== null && typeof e == "object", Km = (e) => (_n(e) || cn(e)) && cn(e.then) && cn(e.catch), qp = Object.prototype.toString, ja = (e) => qp.call(e), Gv = (e) => ja(e).slice(8, -1), Fc = (e) => ja(e) === "[object Object]", Gm = (e) => Wn(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Aa = /* @__PURE__ */ Nc(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Mc = (e) => {
  const l = /* @__PURE__ */ Object.create(null);
  return (i) => l[i] || (l[i] = e(i));
}, zv = /-\w/g, gl = Mc(
  (e) => e.replace(zv, (l) => l.slice(1).toUpperCase())
), jv = /\B([A-Z])/g, ht = Mc(
  (e) => e.replace(jv, "-$1").toLowerCase()
), hs = Mc((e) => e.charAt(0).toUpperCase() + e.slice(1)), Ra = Mc(
  (e) => e ? `on${hs(e)}` : ""
), Vl = (e, l) => !Object.is(e, l), Ea = (e, ...l) => {
  for (let i = 0; i < e.length; i++)
    e[i](...l);
}, Ap = (e, l, i, a = !1) => {
  Object.defineProperty(e, l, {
    configurable: !0,
    enumerable: !1,
    writable: a,
    value: i
  });
}, cc = (e) => {
  const l = parseFloat(e);
  return isNaN(l) ? e : l;
}, oc = (e) => {
  const l = Wn(e) ? Number(e) : NaN;
  return isNaN(l) ? e : l;
};
let Nf;
const kc = () => Nf || (Nf = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}), Hv = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol", $v = /* @__PURE__ */ Nc(Hv);
function Hi(e) {
  if (Xe(e)) {
    const l = {};
    for (let i = 0; i < e.length; i++) {
      const a = e[i], s = Wn(a) ? Qv(a) : Hi(a);
      if (s)
        for (const o in s)
          l[o] = s[o];
    }
    return l;
  } else if (Wn(e) || _n(e))
    return e;
}
const Wv = /;(?![^(]*\))/g, Yv = /:([^]+)/, Xv = /\/\*[^]*?\*\//g;
function Qv(e) {
  const l = {};
  return e.replace(Xv, "").split(Wv).forEach((i) => {
    if (i) {
      const a = i.split(Yv);
      a.length > 1 && (l[a[0].trim()] = a[1].trim());
    }
  }), l;
}
function Bl(e) {
  let l = "";
  if (Wn(e))
    l = e;
  else if (Xe(e))
    for (let i = 0; i < e.length; i++) {
      const a = Bl(e[i]);
      a && (l += a + " ");
    }
  else if (_n(e))
    for (const i in e)
      e[i] && (l += i + " ");
  return l.trim();
}
function Vc(e) {
  if (!e) return null;
  let { class: l, style: i } = e;
  return l && !Wn(l) && (e.class = Bl(l)), i && (e.style = Hi(i)), e;
}
const Jv = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", ex = /* @__PURE__ */ Nc(Jv);
function Rp(e) {
  return !!e || e === "";
}
function nx(e, l) {
  if (e.length !== l.length) return !1;
  let i = !0;
  for (let a = 0; i && a < e.length; a++)
    i = Ku(e[a], l[a]);
  return i;
}
function Ku(e, l) {
  if (e === l) return !0;
  let i = _f(e), a = _f(l);
  if (i || a)
    return i && a ? e.getTime() === l.getTime() : !1;
  if (i = fi(e), a = fi(l), i || a)
    return e === l;
  if (i = Xe(e), a = Xe(l), i || a)
    return i && a ? nx(e, l) : !1;
  if (i = _n(e), a = _n(l), i || a) {
    if (!i || !a)
      return !1;
    const s = Object.keys(e).length, o = Object.keys(l).length;
    if (s !== o)
      return !1;
    for (const m in e) {
      const d = e.hasOwnProperty(m), h = l.hasOwnProperty(m);
      if (d && !h || !d && h || !Ku(e[m], l[m]))
        return !1;
    }
  }
  return String(e) === String(l);
}
function Bc(e, l) {
  return e.findIndex((i) => Ku(i, l));
}
const Ep = (e) => !!(e && e.__v_isRef === !0), Ul = (e) => Wn(e) ? e : e == null ? "" : Xe(e) || _n(e) && (e.toString === qp || !cn(e.toString)) ? Ep(e) ? Ul(e.value) : JSON.stringify(e, _p, 2) : String(e), _p = (e, l) => Ep(l) ? _p(e, l.value) : qa(l) ? {
  [`Map(${l.size})`]: [...l.entries()].reduce(
    (i, [a, s], o) => (i[xo(a, o) + " =>"] = s, i),
    {}
  )
} : oa(l) ? {
  [`Set(${l.size})`]: [...l.values()].map((i) => xo(i))
} : fi(l) ? xo(l) : _n(l) && !Xe(l) && !Fc(l) ? String(l) : l, xo = (e, l = "") => {
  var i;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    fi(e) ? `Symbol(${(i = e.description) != null ? i : l})` : e
  );
};
function lx(e) {
  return e == null ? "initial" : typeof e == "string" ? e === "" ? " " : e : String(e);
}
let El;
class zm {
  constructor(l = !1) {
    this.detached = l, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = El, !l && El && (this.index = (El.scopes || (El.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let l, i;
      if (this.scopes)
        for (l = 0, i = this.scopes.length; l < i; l++)
          this.scopes[l].pause();
      for (l = 0, i = this.effects.length; l < i; l++)
        this.effects[l].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let l, i;
      if (this.scopes)
        for (l = 0, i = this.scopes.length; l < i; l++)
          this.scopes[l].resume();
      for (l = 0, i = this.effects.length; l < i; l++)
        this.effects[l].resume();
    }
  }
  run(l) {
    if (this._active) {
      const i = El;
      try {
        return El = this, l();
      } finally {
        El = i;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = El, El = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (El = this.prevScope, this.prevScope = void 0);
  }
  stop(l) {
    if (this._active) {
      this._active = !1;
      let i, a;
      for (i = 0, a = this.effects.length; i < a; i++)
        this.effects[i].stop();
      for (this.effects.length = 0, i = 0, a = this.cleanups.length; i < a; i++)
        this.cleanups[i]();
      if (this.cleanups.length = 0, this.scopes) {
        for (i = 0, a = this.scopes.length; i < a; i++)
          this.scopes[i].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !l) {
        const s = this.parent.scopes.pop();
        s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Zc(e) {
  return new zm(e);
}
function $i() {
  return El;
}
function ma(e, l = !1) {
  El && El.cleanups.push(e);
}
let $n;
const yo = /* @__PURE__ */ new WeakSet();
class Jr {
  constructor(l) {
    this.fn = l, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, El && El.active && El.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, yo.has(this) && (yo.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Fp(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Ff(this), Mp(this);
    const l = $n, i = ci;
    $n = this, ci = !0;
    try {
      return this.fn();
    } finally {
      kp(this), $n = l, ci = i, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let l = this.deps; l; l = l.nextDep)
        $m(l);
      this.deps = this.depsTail = void 0, Ff(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? yo.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    lm(this) && this.run();
  }
  get dirty() {
    return lm(this);
  }
}
let Np = 0, Ur, Kr;
function Fp(e, l = !1) {
  if (e.flags |= 8, l) {
    e.next = Kr, Kr = e;
    return;
  }
  e.next = Ur, Ur = e;
}
function jm() {
  Np++;
}
function Hm() {
  if (--Np > 0)
    return;
  if (Kr) {
    let l = Kr;
    for (Kr = void 0; l; ) {
      const i = l.next;
      l.next = void 0, l.flags &= -9, l = i;
    }
  }
  let e;
  for (; Ur; ) {
    let l = Ur;
    for (Ur = void 0; l; ) {
      const i = l.next;
      if (l.next = void 0, l.flags &= -9, l.flags & 1)
        try {
          l.trigger();
        } catch (a) {
          e || (e = a);
        }
      l = i;
    }
  }
  if (e) throw e;
}
function Mp(e) {
  for (let l = e.deps; l; l = l.nextDep)
    l.version = -1, l.prevActiveLink = l.dep.activeLink, l.dep.activeLink = l;
}
function kp(e) {
  let l, i = e.depsTail, a = i;
  for (; a; ) {
    const s = a.prevDep;
    a.version === -1 ? (a === i && (i = s), $m(a), tx(a)) : l = a, a.dep.activeLink = a.prevActiveLink, a.prevActiveLink = void 0, a = s;
  }
  e.deps = l, e.depsTail = i;
}
function lm(e) {
  for (let l = e.deps; l; l = l.nextDep)
    if (l.dep.version !== l.version || l.dep.computed && (Vp(l.dep.computed) || l.dep.version !== l.version))
      return !0;
  return !!e._dirty;
}
function Vp(e) {
  if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === es) || (e.globalVersion = es, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !lm(e))))
    return;
  e.flags |= 2;
  const l = e.dep, i = $n, a = ci;
  $n = e, ci = !0;
  try {
    Mp(e);
    const s = e.fn(e._value);
    (l.version === 0 || Vl(s, e._value)) && (e.flags |= 128, e._value = s, l.version++);
  } catch (s) {
    throw l.version++, s;
  } finally {
    $n = i, ci = a, kp(e), e.flags &= -3;
  }
}
function $m(e, l = !1) {
  const { dep: i, prevSub: a, nextSub: s } = e;
  if (a && (a.nextSub = s, e.prevSub = void 0), s && (s.prevSub = a, e.nextSub = void 0), i.subs === e && (i.subs = a, !a && i.computed)) {
    i.computed.flags &= -5;
    for (let o = i.computed.deps; o; o = o.nextDep)
      $m(o, !0);
  }
  !l && !--i.sc && i.map && i.map.delete(i.key);
}
function tx(e) {
  const { prevDep: l, nextDep: i } = e;
  l && (l.nextDep = i, e.prevDep = void 0), i && (i.prevDep = l, e.nextDep = void 0);
}
function ix(e, l) {
  e.effect instanceof Jr && (e = e.effect.fn);
  const i = new Jr(e);
  l && kn(i, l);
  try {
    i.run();
  } catch (s) {
    throw i.stop(), s;
  }
  const a = i.run.bind(i);
  return a.effect = i, a;
}
function ux(e) {
  e.effect.stop();
}
let ci = !0;
const Bp = [];
function ki() {
  Bp.push(ci), ci = !1;
}
function Vi() {
  const e = Bp.pop();
  ci = e === void 0 ? !0 : e;
}
function Ff(e) {
  const { cleanup: l } = e;
  if (e.cleanup = void 0, l) {
    const i = $n;
    $n = void 0;
    try {
      l();
    } finally {
      $n = i;
    }
  }
}
let es = 0;
class ax {
  constructor(l, i) {
    this.sub = l, this.dep = i, this.version = i.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Uc {
  // TODO isolatedDeclarations "__v_skip"
  constructor(l) {
    this.computed = l, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(l) {
    if (!$n || !ci || $n === this.computed)
      return;
    let i = this.activeLink;
    if (i === void 0 || i.sub !== $n)
      i = this.activeLink = new ax($n, this), $n.deps ? (i.prevDep = $n.depsTail, $n.depsTail.nextDep = i, $n.depsTail = i) : $n.deps = $n.depsTail = i, Zp(i);
    else if (i.version === -1 && (i.version = this.version, i.nextDep)) {
      const a = i.nextDep;
      a.prevDep = i.prevDep, i.prevDep && (i.prevDep.nextDep = a), i.prevDep = $n.depsTail, i.nextDep = void 0, $n.depsTail.nextDep = i, $n.depsTail = i, $n.deps === i && ($n.deps = a);
    }
    return i;
  }
  trigger(l) {
    this.version++, es++, this.notify(l);
  }
  notify(l) {
    jm();
    try {
      for (let i = this.subs; i; i = i.prevSub)
        i.sub.notify() && i.sub.dep.notify();
    } finally {
      Hm();
    }
  }
}
function Zp(e) {
  if (e.dep.sc++, e.sub.flags & 4) {
    const l = e.dep.computed;
    if (l && !e.dep.subs) {
      l.flags |= 20;
      for (let a = l.deps; a; a = a.nextDep)
        Zp(a);
    }
    const i = e.dep.subs;
    i !== e && (e.prevSub = i, i && (i.nextSub = e)), e.dep.subs = e;
  }
}
const mc = /* @__PURE__ */ new WeakMap(), ta = Symbol(
  ""
), tm = Symbol(
  ""
), ns = Symbol(
  ""
);
function _l(e, l, i) {
  if (ci && $n) {
    let a = mc.get(e);
    a || mc.set(e, a = /* @__PURE__ */ new Map());
    let s = a.get(i);
    s || (a.set(i, s = new Uc()), s.map = a, s.key = i), s.track();
  }
}
function Ri(e, l, i, a, s, o) {
  const m = mc.get(e);
  if (!m) {
    es++;
    return;
  }
  const d = (h) => {
    h && h.trigger();
  };
  if (jm(), l === "clear")
    m.forEach(d);
  else {
    const h = Xe(e), x = h && Gm(i);
    if (h && i === "length") {
      const y = Number(a);
      m.forEach((I, q) => {
        (q === "length" || q === ns || !fi(q) && q >= y) && d(I);
      });
    } else
      switch ((i !== void 0 || m.has(void 0)) && d(m.get(i)), x && d(m.get(ns)), l) {
        case "add":
          h ? x && d(m.get("length")) : (d(m.get(ta)), qa(e) && d(m.get(tm)));
          break;
        case "delete":
          h || (d(m.get(ta)), qa(e) && d(m.get(tm)));
          break;
        case "set":
          qa(e) && d(m.get(ta));
          break;
      }
  }
  Hm();
}
function rx(e, l) {
  const i = mc.get(e);
  return i && i.get(l);
}
function xa(e) {
  const l = Ln(e);
  return l === e ? l : (_l(l, "iterate", ns), yt(e) ? l : l.map(ql));
}
function Kc(e) {
  return _l(e = Ln(e), "iterate", ns), e;
}
const sx = {
  __proto__: null,
  [Symbol.iterator]() {
    return Io(this, Symbol.iterator, ql);
  },
  concat(...e) {
    return xa(this).concat(
      ...e.map((l) => Xe(l) ? xa(l) : l)
    );
  },
  entries() {
    return Io(this, "entries", (e) => (e[1] = ql(e[1]), e));
  },
  every(e, l) {
    return Ci(this, "every", e, l, void 0, arguments);
  },
  filter(e, l) {
    return Ci(this, "filter", e, l, (i) => i.map(ql), arguments);
  },
  find(e, l) {
    return Ci(this, "find", e, l, ql, arguments);
  },
  findIndex(e, l) {
    return Ci(this, "findIndex", e, l, void 0, arguments);
  },
  findLast(e, l) {
    return Ci(this, "findLast", e, l, ql, arguments);
  },
  findLastIndex(e, l) {
    return Ci(this, "findLastIndex", e, l, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(e, l) {
    return Ci(this, "forEach", e, l, void 0, arguments);
  },
  includes(...e) {
    return Lo(this, "includes", e);
  },
  indexOf(...e) {
    return Lo(this, "indexOf", e);
  },
  join(e) {
    return xa(this).join(e);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...e) {
    return Lo(this, "lastIndexOf", e);
  },
  map(e, l) {
    return Ci(this, "map", e, l, void 0, arguments);
  },
  pop() {
    return wr(this, "pop");
  },
  push(...e) {
    return wr(this, "push", e);
  },
  reduce(e, ...l) {
    return Mf(this, "reduce", e, l);
  },
  reduceRight(e, ...l) {
    return Mf(this, "reduceRight", e, l);
  },
  shift() {
    return wr(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(e, l) {
    return Ci(this, "some", e, l, void 0, arguments);
  },
  splice(...e) {
    return wr(this, "splice", e);
  },
  toReversed() {
    return xa(this).toReversed();
  },
  toSorted(e) {
    return xa(this).toSorted(e);
  },
  toSpliced(...e) {
    return xa(this).toSpliced(...e);
  },
  unshift(...e) {
    return wr(this, "unshift", e);
  },
  values() {
    return Io(this, "values", ql);
  }
};
function Io(e, l, i) {
  const a = Kc(e), s = a[l]();
  return a !== e && !yt(e) && (s._next = s.next, s.next = () => {
    const o = s._next();
    return o.done || (o.value = i(o.value)), o;
  }), s;
}
const cx = Array.prototype;
function Ci(e, l, i, a, s, o) {
  const m = Kc(e), d = m !== e && !yt(e), h = m[l];
  if (h !== cx[l]) {
    const I = h.apply(e, o);
    return d ? ql(I) : I;
  }
  let x = i;
  m !== e && (d ? x = function(I, q) {
    return i.call(this, ql(I), q, e);
  } : i.length > 2 && (x = function(I, q) {
    return i.call(this, I, q, e);
  }));
  const y = h.call(m, x, a);
  return d && s ? s(y) : y;
}
function Mf(e, l, i, a) {
  const s = Kc(e);
  let o = i;
  return s !== e && (yt(e) ? i.length > 3 && (o = function(m, d, h) {
    return i.call(this, m, d, h, e);
  }) : o = function(m, d, h) {
    return i.call(this, m, ql(d), h, e);
  }), s[l](o, ...a);
}
function Lo(e, l, i) {
  const a = Ln(e);
  _l(a, "iterate", ns);
  const s = a[l](...i);
  return (s === -1 || s === !1) && jc(i[0]) ? (i[0] = Ln(i[0]), a[l](...i)) : s;
}
function wr(e, l, i = []) {
  ki(), jm();
  const a = Ln(e)[l].apply(e, i);
  return Hm(), Vi(), a;
}
const ox = /* @__PURE__ */ Nc("__proto__,__v_isRef,__isVue"), Up = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(fi)
);
function mx(e) {
  fi(e) || (e = String(e));
  const l = Ln(this);
  return _l(l, "has", e), l.hasOwnProperty(e);
}
class Kp {
  constructor(l = !1, i = !1) {
    this._isReadonly = l, this._isShallow = i;
  }
  get(l, i, a) {
    if (i === "__v_skip") return l.__v_skip;
    const s = this._isReadonly, o = this._isShallow;
    if (i === "__v_isReactive")
      return !s;
    if (i === "__v_isReadonly")
      return s;
    if (i === "__v_isShallow")
      return o;
    if (i === "__v_raw")
      return a === (s ? o ? Wp : $p : o ? Hp : jp).get(l) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(l) === Object.getPrototypeOf(a) ? l : void 0;
    const m = Xe(l);
    if (!s) {
      let h;
      if (m && (h = sx[i]))
        return h;
      if (i === "hasOwnProperty")
        return mx;
    }
    const d = Reflect.get(
      l,
      i,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      Vn(l) ? l : a
    );
    if ((fi(i) ? Up.has(i) : ox(i)) || (s || _l(l, "get", i), o))
      return d;
    if (Vn(d)) {
      const h = m && Gm(i) ? d : d.value;
      return s && _n(h) ? Bi(h) : h;
    }
    return _n(d) ? s ? Bi(d) : Ha(d) : d;
  }
}
class Gp extends Kp {
  constructor(l = !1) {
    super(!1, l);
  }
  set(l, i, a, s) {
    let o = l[i];
    if (!this._isShallow) {
      const h = Zi(o);
      if (!yt(a) && !Zi(a) && (o = Ln(o), a = Ln(a)), !Xe(l) && Vn(o) && !Vn(a))
        return h || (o.value = a), !0;
    }
    const m = Xe(l) && Gm(i) ? Number(i) < l.length : Tn(l, i), d = Reflect.set(
      l,
      i,
      a,
      Vn(l) ? l : s
    );
    return l === Ln(s) && (m ? Vl(a, o) && Ri(l, "set", i, a) : Ri(l, "add", i, a)), d;
  }
  deleteProperty(l, i) {
    const a = Tn(l, i);
    l[i];
    const s = Reflect.deleteProperty(l, i);
    return s && a && Ri(l, "delete", i, void 0), s;
  }
  has(l, i) {
    const a = Reflect.has(l, i);
    return (!fi(i) || !Up.has(i)) && _l(l, "has", i), a;
  }
  ownKeys(l) {
    return _l(
      l,
      "iterate",
      Xe(l) ? "length" : ta
    ), Reflect.ownKeys(l);
  }
}
class zp extends Kp {
  constructor(l = !1) {
    super(!0, l);
  }
  set(l, i) {
    return !0;
  }
  deleteProperty(l, i) {
    return !0;
  }
}
const fx = /* @__PURE__ */ new Gp(), dx = /* @__PURE__ */ new zp(), px = /* @__PURE__ */ new Gp(!0), hx = /* @__PURE__ */ new zp(!0), im = (e) => e, As = (e) => Reflect.getPrototypeOf(e);
function gx(e, l, i) {
  return function(...a) {
    const s = this.__v_raw, o = Ln(s), m = qa(o), d = e === "entries" || e === Symbol.iterator && m, h = e === "keys" && m, x = s[e](...a), y = i ? im : l ? fc : ql;
    return !l && _l(
      o,
      "iterate",
      h ? tm : ta
    ), {
      // iterator protocol
      next() {
        const { value: I, done: q } = x.next();
        return q ? { value: I, done: q } : {
          value: d ? [y(I[0]), y(I[1])] : y(I),
          done: q
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Rs(e) {
  return function(...l) {
    return e === "delete" ? !1 : e === "clear" ? void 0 : this;
  };
}
function vx(e, l) {
  const i = {
    get(s) {
      const o = this.__v_raw, m = Ln(o), d = Ln(s);
      e || (Vl(s, d) && _l(m, "get", s), _l(m, "get", d));
      const { has: h } = As(m), x = l ? im : e ? fc : ql;
      if (h.call(m, s))
        return x(o.get(s));
      if (h.call(m, d))
        return x(o.get(d));
      o !== m && o.get(s);
    },
    get size() {
      const s = this.__v_raw;
      return !e && _l(Ln(s), "iterate", ta), s.size;
    },
    has(s) {
      const o = this.__v_raw, m = Ln(o), d = Ln(s);
      return e || (Vl(s, d) && _l(m, "has", s), _l(m, "has", d)), s === d ? o.has(s) : o.has(s) || o.has(d);
    },
    forEach(s, o) {
      const m = this, d = m.__v_raw, h = Ln(d), x = l ? im : e ? fc : ql;
      return !e && _l(h, "iterate", ta), d.forEach((y, I) => s.call(o, x(y), x(I), m));
    }
  };
  return kn(
    i,
    e ? {
      add: Rs("add"),
      set: Rs("set"),
      delete: Rs("delete"),
      clear: Rs("clear")
    } : {
      add(s) {
        !l && !yt(s) && !Zi(s) && (s = Ln(s));
        const o = Ln(this);
        return As(o).has.call(o, s) || (o.add(s), Ri(o, "add", s, s)), this;
      },
      set(s, o) {
        !l && !yt(o) && !Zi(o) && (o = Ln(o));
        const m = Ln(this), { has: d, get: h } = As(m);
        let x = d.call(m, s);
        x || (s = Ln(s), x = d.call(m, s));
        const y = h.call(m, s);
        return m.set(s, o), x ? Vl(o, y) && Ri(m, "set", s, o) : Ri(m, "add", s, o), this;
      },
      delete(s) {
        const o = Ln(this), { has: m, get: d } = As(o);
        let h = m.call(o, s);
        h || (s = Ln(s), h = m.call(o, s)), d && d.call(o, s);
        const x = o.delete(s);
        return h && Ri(o, "delete", s, void 0), x;
      },
      clear() {
        const s = Ln(this), o = s.size !== 0, m = s.clear();
        return o && Ri(
          s,
          "clear",
          void 0,
          void 0
        ), m;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((s) => {
    i[s] = gx(s, e, l);
  }), i;
}
function Gc(e, l) {
  const i = vx(e, l);
  return (a, s, o) => s === "__v_isReactive" ? !e : s === "__v_isReadonly" ? e : s === "__v_raw" ? a : Reflect.get(
    Tn(i, s) && s in a ? i : a,
    s,
    o
  );
}
const xx = {
  get: /* @__PURE__ */ Gc(!1, !1)
}, yx = {
  get: /* @__PURE__ */ Gc(!1, !0)
}, Ix = {
  get: /* @__PURE__ */ Gc(!0, !1)
}, Lx = {
  get: /* @__PURE__ */ Gc(!0, !0)
}, jp = /* @__PURE__ */ new WeakMap(), Hp = /* @__PURE__ */ new WeakMap(), $p = /* @__PURE__ */ new WeakMap(), Wp = /* @__PURE__ */ new WeakMap();
function Dx(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Ox(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : Dx(Gv(e));
}
function Ha(e) {
  return Zi(e) ? e : zc(
    e,
    !1,
    fx,
    xx,
    jp
  );
}
function Yp(e) {
  return zc(
    e,
    !1,
    px,
    yx,
    Hp
  );
}
function Bi(e) {
  return zc(
    e,
    !0,
    dx,
    Ix,
    $p
  );
}
function Nu(e) {
  return zc(
    e,
    !0,
    hx,
    Lx,
    Wp
  );
}
function zc(e, l, i, a, s) {
  if (!_n(e) || e.__v_raw && !(l && e.__v_isReactive))
    return e;
  const o = Ox(e);
  if (o === 0)
    return e;
  const m = s.get(e);
  if (m)
    return m;
  const d = new Proxy(
    e,
    o === 2 ? a : i
  );
  return s.set(e, d), d;
}
function oi(e) {
  return Zi(e) ? oi(e.__v_raw) : !!(e && e.__v_isReactive);
}
function Zi(e) {
  return !!(e && e.__v_isReadonly);
}
function yt(e) {
  return !!(e && e.__v_isShallow);
}
function jc(e) {
  return e ? !!e.__v_raw : !1;
}
function Ln(e) {
  const l = e && e.__v_raw;
  return l ? Ln(l) : e;
}
function $a(e) {
  return !Tn(e, "__v_skip") && Object.isExtensible(e) && Ap(e, "__v_skip", !0), e;
}
const ql = (e) => _n(e) ? Ha(e) : e, fc = (e) => _n(e) ? Bi(e) : e;
function Vn(e) {
  return e ? e.__v_isRef === !0 : !1;
}
function Fe(e) {
  return Xp(e, !1);
}
function Fl(e) {
  return Xp(e, !0);
}
function Xp(e, l) {
  return Vn(e) ? e : new bx(e, l);
}
class bx {
  constructor(l, i) {
    this.dep = new Uc(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = i ? l : Ln(l), this._value = i ? l : ql(l), this.__v_isShallow = i;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(l) {
    const i = this._rawValue, a = this.__v_isShallow || yt(l) || Zi(l);
    l = a ? l : Ln(l), Vl(l, i) && (this._rawValue = l, this._value = a ? l : ql(l), this.dep.trigger());
  }
}
function wx(e) {
  e.dep && e.dep.trigger();
}
function le(e) {
  return Vn(e) ? e.value : e;
}
function hn(e) {
  return cn(e) ? e() : le(e);
}
const Sx = {
  get: (e, l, i) => l === "__v_raw" ? e : le(Reflect.get(e, l, i)),
  set: (e, l, i, a) => {
    const s = e[l];
    return Vn(s) && !Vn(i) ? (s.value = i, !0) : Reflect.set(e, l, i, a);
  }
};
function Wm(e) {
  return oi(e) ? e : new Proxy(e, Sx);
}
class Cx {
  constructor(l) {
    this.__v_isRef = !0, this._value = void 0;
    const i = this.dep = new Uc(), { get: a, set: s } = l(i.track.bind(i), i.trigger.bind(i));
    this._get = a, this._set = s;
  }
  get value() {
    return this._value = this._get();
  }
  set value(l) {
    this._set(l);
  }
}
function Wa(e) {
  return new Cx(e);
}
function St(e) {
  const l = Xe(e) ? new Array(e.length) : {};
  for (const i in e)
    l[i] = Qp(e, i);
  return l;
}
class Tx {
  constructor(l, i, a) {
    this._object = l, this._key = i, this._defaultValue = a, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const l = this._object[this._key];
    return this._value = l === void 0 ? this._defaultValue : l;
  }
  set value(l) {
    this._object[this._key] = l;
  }
  get dep() {
    return rx(Ln(this._object), this._key);
  }
}
class Px {
  constructor(l) {
    this._getter = l, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function gs(e, l, i) {
  return Vn(e) ? e : cn(e) ? new Px(e) : _n(e) && arguments.length > 1 ? Qp(e, l, i) : Fe(e);
}
function Qp(e, l, i) {
  const a = e[l];
  return Vn(a) ? a : new Tx(e, l, i);
}
class qx {
  constructor(l, i, a) {
    this.fn = l, this.setter = i, this._value = void 0, this.dep = new Uc(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = es - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !i, this.isSSR = a;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    $n !== this)
      return Fp(this, !0), !0;
  }
  get value() {
    const l = this.dep.track();
    return Vp(this), l && (l.version = this.dep.version), this._value;
  }
  set value(l) {
    this.setter && this.setter(l);
  }
}
function Ax(e, l, i = !1) {
  let a, s;
  return cn(e) ? a = e : (a = e.get, s = e.set), new qx(a, s, i);
}
const Rx = {
  GET: "get",
  HAS: "has",
  ITERATE: "iterate"
}, Ex = {
  SET: "set",
  ADD: "add",
  DELETE: "delete",
  CLEAR: "clear"
}, Es = {}, dc = /* @__PURE__ */ new WeakMap();
let Fu;
function _x() {
  return Fu;
}
function Jp(e, l = !1, i = Fu) {
  if (i) {
    let a = dc.get(i);
    a || dc.set(i, a = []), a.push(e);
  }
}
function Nx(e, l, i = On) {
  const { immediate: a, deep: s, once: o, scheduler: m, augmentJob: d, call: h } = i, x = (K) => s ? K : yt(K) || s === !1 || s === 0 ? Ei(K, 1) : Ei(K);
  let y, I, q, A, R = !1, V = !1;
  if (Vn(e) ? (I = () => e.value, R = yt(e)) : oi(e) ? (I = () => x(e), R = !0) : Xe(e) ? (V = !0, R = e.some((K) => oi(K) || yt(K)), I = () => e.map((K) => {
    if (Vn(K))
      return K.value;
    if (oi(K))
      return x(K);
    if (cn(K))
      return h ? h(K, 2) : K();
  })) : cn(e) ? l ? I = h ? () => h(e, 2) : e : I = () => {
    if (q) {
      ki();
      try {
        q();
      } finally {
        Vi();
      }
    }
    const K = Fu;
    Fu = y;
    try {
      return h ? h(e, 3, [A]) : e(A);
    } finally {
      Fu = K;
    }
  } : I = bt, l && s) {
    const K = I, W = s === !0 ? 1 / 0 : s;
    I = () => Ei(K(), W);
  }
  const U = $i(), z = () => {
    y.stop(), U && U.active && Um(U.effects, y);
  };
  if (o && l) {
    const K = l;
    l = (...W) => {
      K(...W), z();
    };
  }
  let X = V ? new Array(e.length).fill(Es) : Es;
  const B = (K) => {
    if (!(!(y.flags & 1) || !y.dirty && !K))
      if (l) {
        const W = y.run();
        if (s || R || (V ? W.some((se, te) => Vl(se, X[te])) : Vl(W, X))) {
          q && q();
          const se = Fu;
          Fu = y;
          try {
            const te = [
              W,
              // pass undefined as the old value when it's changed for the first time
              X === Es ? void 0 : V && X[0] === Es ? [] : X,
              A
            ];
            X = W, h ? h(l, 3, te) : (
              // @ts-expect-error
              l(...te)
            );
          } finally {
            Fu = se;
          }
        }
      } else
        y.run();
  };
  return d && d(B), y = new Jr(I), y.scheduler = m ? () => m(B, !1) : B, A = (K) => Jp(K, !1, y), q = y.onStop = () => {
    const K = dc.get(y);
    if (K) {
      if (h)
        h(K, 4);
      else
        for (const W of K) W();
      dc.delete(y);
    }
  }, l ? a ? B(!0) : X = y.run() : m ? m(B.bind(null, !0), !0) : y.run(), z.pause = y.pause.bind(y), z.resume = y.resume.bind(y), z.stop = z, z;
}
function Ei(e, l = 1 / 0, i) {
  if (l <= 0 || !_n(e) || e.__v_skip || (i = i || /* @__PURE__ */ new Map(), (i.get(e) || 0) >= l))
    return e;
  if (i.set(e, l), l--, Vn(e))
    Ei(e.value, l, i);
  else if (Xe(e))
    for (let a = 0; a < e.length; a++)
      Ei(e[a], l, i);
  else if (oa(e) || qa(e))
    e.forEach((a) => {
      Ei(a, l, i);
    });
  else if (Fc(e)) {
    for (const a in e)
      Ei(e[a], l, i);
    for (const a of Object.getOwnPropertySymbols(e))
      Object.prototype.propertyIsEnumerable.call(e, a) && Ei(e[a], l, i);
  }
  return e;
}
const eh = [];
function Fx(e) {
  eh.push(e);
}
function Mx() {
  eh.pop();
}
function kx(e, l) {
}
const Vx = {
  SETUP_FUNCTION: 0,
  0: "SETUP_FUNCTION",
  RENDER_FUNCTION: 1,
  1: "RENDER_FUNCTION",
  NATIVE_EVENT_HANDLER: 5,
  5: "NATIVE_EVENT_HANDLER",
  COMPONENT_EVENT_HANDLER: 6,
  6: "COMPONENT_EVENT_HANDLER",
  VNODE_HOOK: 7,
  7: "VNODE_HOOK",
  DIRECTIVE_HOOK: 8,
  8: "DIRECTIVE_HOOK",
  TRANSITION_HOOK: 9,
  9: "TRANSITION_HOOK",
  APP_ERROR_HANDLER: 10,
  10: "APP_ERROR_HANDLER",
  APP_WARN_HANDLER: 11,
  11: "APP_WARN_HANDLER",
  FUNCTION_REF: 12,
  12: "FUNCTION_REF",
  ASYNC_COMPONENT_LOADER: 13,
  13: "ASYNC_COMPONENT_LOADER",
  SCHEDULER: 14,
  14: "SCHEDULER",
  COMPONENT_UPDATE: 15,
  15: "COMPONENT_UPDATE",
  APP_UNMOUNT_CLEANUP: 16,
  16: "APP_UNMOUNT_CLEANUP"
}, Bx = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function"
};
function Ya(e, l, i, a) {
  try {
    return a ? e(...a) : e();
  } catch (s) {
    fa(s, l, i);
  }
}
function Ct(e, l, i, a) {
  if (cn(e)) {
    const s = Ya(e, l, i, a);
    return s && Km(s) && s.catch((o) => {
      fa(o, l, i);
    }), s;
  }
  if (Xe(e)) {
    const s = [];
    for (let o = 0; o < e.length; o++)
      s.push(Ct(e[o], l, i, a));
    return s;
  }
}
function fa(e, l, i, a = !0) {
  const s = l ? l.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: m } = l && l.appContext.config || On;
  if (l) {
    let d = l.parent;
    const h = l.proxy, x = `https://vuejs.org/error-reference/#runtime-${i}`;
    for (; d; ) {
      const y = d.ec;
      if (y) {
        for (let I = 0; I < y.length; I++)
          if (y[I](e, h, x) === !1)
            return;
      }
      d = d.parent;
    }
    if (o) {
      ki(), Ya(o, null, 10, [
        e,
        h,
        x
      ]), Vi();
      return;
    }
  }
  Zx(e, i, s, a, m);
}
function Zx(e, l, i, a = !0, s = !1) {
  if (s)
    throw e;
  console.error(e);
}
const Zl = [];
let Ii = -1;
const _a = [];
let Mu = null, ba = 0;
const nh = /* @__PURE__ */ Promise.resolve();
let pc = null;
function il(e) {
  const l = pc || nh;
  return e ? l.then(this ? e.bind(this) : e) : l;
}
function Ux(e) {
  let l = Ii + 1, i = Zl.length;
  for (; l < i; ) {
    const a = l + i >>> 1, s = Zl[a], o = ts(s);
    o < e || o === e && s.flags & 2 ? l = a + 1 : i = a;
  }
  return l;
}
function Ym(e) {
  if (!(e.flags & 1)) {
    const l = ts(e), i = Zl[Zl.length - 1];
    !i || // fast path when the job id is larger than the tail
    !(e.flags & 2) && l >= ts(i) ? Zl.push(e) : Zl.splice(Ux(l), 0, e), e.flags |= 1, lh();
  }
}
function lh() {
  pc || (pc = nh.then(th));
}
function ls(e) {
  Xe(e) ? _a.push(...e) : Mu && e.id === -1 ? Mu.splice(ba + 1, 0, e) : e.flags & 1 || (_a.push(e), e.flags |= 1), lh();
}
function kf(e, l, i = Ii + 1) {
  for (; i < Zl.length; i++) {
    const a = Zl[i];
    if (a && a.flags & 2) {
      if (e && a.id !== e.uid)
        continue;
      Zl.splice(i, 1), i--, a.flags & 4 && (a.flags &= -2), a(), a.flags & 4 || (a.flags &= -2);
    }
  }
}
function hc(e) {
  if (_a.length) {
    const l = [...new Set(_a)].sort(
      (i, a) => ts(i) - ts(a)
    );
    if (_a.length = 0, Mu) {
      Mu.push(...l);
      return;
    }
    for (Mu = l, ba = 0; ba < Mu.length; ba++) {
      const i = Mu[ba];
      i.flags & 4 && (i.flags &= -2), i.flags & 8 || i(), i.flags &= -2;
    }
    Mu = null, ba = 0;
  }
}
const ts = (e) => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;
function th(e) {
  try {
    for (Ii = 0; Ii < Zl.length; Ii++) {
      const l = Zl[Ii];
      l && !(l.flags & 8) && (l.flags & 4 && (l.flags &= -2), Ya(
        l,
        l.i,
        l.i ? 15 : 14
      ), l.flags & 4 || (l.flags &= -2));
    }
  } finally {
    for (; Ii < Zl.length; Ii++) {
      const l = Zl[Ii];
      l && (l.flags &= -2);
    }
    Ii = -1, Zl.length = 0, hc(), pc = null, (Zl.length || _a.length) && th();
  }
}
let wa, _s = [];
function ih(e, l) {
  var i, a;
  wa = e, wa ? (wa.enabled = !0, _s.forEach(({ event: s, args: o }) => wa.emit(s, ...o)), _s = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((a = (i = window.navigator) == null ? void 0 : i.userAgent) != null && a.includes("jsdom")) ? ((l.__VUE_DEVTOOLS_HOOK_REPLAY__ = l.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((o) => {
    ih(o, l);
  }), setTimeout(() => {
    wa || (l.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, _s = []);
  }, 3e3)) : _s = [];
}
let Rl = null, Hc = null;
function is(e) {
  const l = Rl;
  return Rl = e, Hc = e && e.type.__scopeId || null, l;
}
function Kx(e) {
  Hc = e;
}
function Gx() {
  Hc = null;
}
const zx = (e) => ln;
function ln(e, l = Rl, i) {
  if (!l || e._n)
    return e;
  const a = (...s) => {
    a._d && rs(-1);
    const o = is(l);
    let m;
    try {
      m = e(...s);
    } finally {
      is(o), a._d && rs(1);
    }
    return m;
  };
  return a._n = !0, a._c = !0, a._d = !0, a;
}
function jx(e, l) {
  if (Rl === null)
    return e;
  const i = Ds(Rl), a = e.dirs || (e.dirs = []);
  for (let s = 0; s < l.length; s++) {
    let [o, m, d, h = On] = l[s];
    o && (cn(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Ei(m), a.push({
      dir: o,
      instance: i,
      value: m,
      oldValue: void 0,
      arg: d,
      modifiers: h
    }));
  }
  return e;
}
function Li(e, l, i, a) {
  const s = e.dirs, o = l && l.dirs;
  for (let m = 0; m < s.length; m++) {
    const d = s[m];
    o && (d.oldValue = o[m].value);
    let h = d.dir[a];
    h && (ki(), Ct(h, i, 8, [
      e.el,
      d,
      e,
      l
    ]), Vi());
  }
}
const uh = Symbol("_vte"), ah = (e) => e.__isTeleport, Gr = (e) => e && (e.disabled || e.disabled === ""), Vf = (e) => e && (e.defer || e.defer === ""), Bf = (e) => typeof SVGElement < "u" && e instanceof SVGElement, Zf = (e) => typeof MathMLElement == "function" && e instanceof MathMLElement, um = (e, l) => {
  const i = e && e.to;
  return Wn(i) ? l ? l(i) : null : i;
}, rh = {
  name: "Teleport",
  __isTeleport: !0,
  process(e, l, i, a, s, o, m, d, h, x) {
    const {
      mc: y,
      pc: I,
      pbc: q,
      o: { insert: A, querySelector: R, createText: V, createComment: U }
    } = x, z = Gr(l.props);
    let { shapeFlag: X, children: B, dynamicChildren: K } = l;
    if (e == null) {
      const W = l.el = V(""), se = l.anchor = V("");
      A(W, i, a), A(se, i, a);
      const te = (M, ce) => {
        X & 16 && y(
          B,
          M,
          ce,
          s,
          o,
          m,
          d,
          h
        );
      }, me = () => {
        const M = l.target = um(l.props, R), ce = sh(M, l, V, A);
        M && (m !== "svg" && Bf(M) ? m = "svg" : m !== "mathml" && Zf(M) && (m = "mathml"), s && s.isCE && (s.ce._teleportTargets || (s.ce._teleportTargets = /* @__PURE__ */ new Set())).add(M), z || (te(M, ce), nc(l, !1)));
      };
      z && (te(i, se), nc(l, !0)), Vf(l.props) ? (l.el.__isMounted = !1, hl(() => {
        me(), delete l.el.__isMounted;
      }, o)) : me();
    } else {
      if (Vf(l.props) && e.el.__isMounted === !1) {
        hl(() => {
          rh.process(
            e,
            l,
            i,
            a,
            s,
            o,
            m,
            d,
            h,
            x
          );
        }, o);
        return;
      }
      l.el = e.el, l.targetStart = e.targetStart;
      const W = l.anchor = e.anchor, se = l.target = e.target, te = l.targetAnchor = e.targetAnchor, me = Gr(e.props), M = me ? i : se, ce = me ? W : te;
      if (m === "svg" || Bf(se) ? m = "svg" : (m === "mathml" || Zf(se)) && (m = "mathml"), K ? (q(
        e.dynamicChildren,
        K,
        M,
        s,
        o,
        m,
        d
      ), cf(e, l, !0)) : h || I(
        e,
        l,
        M,
        ce,
        s,
        o,
        m,
        d,
        !1
      ), z)
        me ? l.props && e.props && l.props.to !== e.props.to && (l.props.to = e.props.to) : Ns(
          l,
          i,
          W,
          x,
          1
        );
      else if ((l.props && l.props.to) !== (e.props && e.props.to)) {
        const Ie = l.target = um(
          l.props,
          R
        );
        Ie && Ns(
          l,
          Ie,
          null,
          x,
          0
        );
      } else me && Ns(
        l,
        se,
        te,
        x,
        1
      );
      nc(l, z);
    }
  },
  remove(e, l, i, { um: a, o: { remove: s } }, o) {
    const {
      shapeFlag: m,
      children: d,
      anchor: h,
      targetStart: x,
      targetAnchor: y,
      target: I,
      props: q
    } = e;
    if (I && (s(x), s(y)), o && s(h), m & 16) {
      const A = o || !Gr(q);
      for (let R = 0; R < d.length; R++) {
        const V = d[R];
        a(
          V,
          l,
          i,
          A,
          !!V.dynamicChildren
        );
      }
    }
  },
  move: Ns,
  hydrate: Hx
};
function Ns(e, l, i, { o: { insert: a }, m: s }, o = 2) {
  o === 0 && a(e.targetAnchor, l, i);
  const { el: m, anchor: d, shapeFlag: h, children: x, props: y } = e, I = o === 2;
  if (I && a(m, l, i), (!I || Gr(y)) && h & 16)
    for (let q = 0; q < x.length; q++)
      s(
        x[q],
        l,
        i,
        2
      );
  I && a(d, l, i);
}
function Hx(e, l, i, a, s, o, {
  o: { nextSibling: m, parentNode: d, querySelector: h, insert: x, createText: y }
}, I) {
  function q(V, U, z, X) {
    U.anchor = I(
      m(V),
      U,
      d(V),
      i,
      a,
      s,
      o
    ), U.targetStart = z, U.targetAnchor = X;
  }
  const A = l.target = um(
    l.props,
    h
  ), R = Gr(l.props);
  if (A) {
    const V = A._lpa || A.firstChild;
    if (l.shapeFlag & 16)
      if (R)
        q(
          e,
          l,
          V,
          V && m(V)
        );
      else {
        l.anchor = m(e);
        let U = V;
        for (; U; ) {
          if (U && U.nodeType === 8) {
            if (U.data === "teleport start anchor")
              l.targetStart = U;
            else if (U.data === "teleport anchor") {
              l.targetAnchor = U, A._lpa = l.targetAnchor && m(l.targetAnchor);
              break;
            }
          }
          U = m(U);
        }
        l.targetAnchor || sh(A, l, y, x), I(
          V && m(V),
          l,
          A,
          i,
          a,
          s,
          o
        );
      }
    nc(l, R);
  } else R && l.shapeFlag & 16 && q(e, l, e, m(e));
  return l.anchor && m(l.anchor);
}
const $x = rh;
function nc(e, l) {
  const i = e.ctx;
  if (i && i.ut) {
    let a, s;
    for (l ? (a = e.el, s = e.anchor) : (a = e.targetStart, s = e.targetAnchor); a && a !== s; )
      a.nodeType === 1 && a.setAttribute("data-v-owner", i.uid), a = a.nextSibling;
    i.ut();
  }
}
function sh(e, l, i, a) {
  const s = l.targetStart = i(""), o = l.targetAnchor = i("");
  return s[uh] = o, e && (a(s, e), a(o, e)), o;
}
const qi = Symbol("_leaveCb"), Fs = Symbol("_enterCb");
function Xm() {
  const e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return vl(() => {
    e.isMounted = !0;
  }), xs(() => {
    e.isUnmounting = !0;
  }), e;
}
const Ot = [Function, Array], Qm = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: Ot,
  onEnter: Ot,
  onAfterEnter: Ot,
  onEnterCancelled: Ot,
  // leave
  onBeforeLeave: Ot,
  onLeave: Ot,
  onAfterLeave: Ot,
  onLeaveCancelled: Ot,
  // appear
  onBeforeAppear: Ot,
  onAppear: Ot,
  onAfterAppear: Ot,
  onAppearCancelled: Ot
}, ch = (e) => {
  const l = e.subTree;
  return l.component ? ch(l.component) : l;
}, Wx = {
  name: "BaseTransition",
  props: Qm,
  setup(e, { slots: l }) {
    const i = Xn(), a = Xm();
    return () => {
      const s = l.default && $c(l.default(), !0);
      if (!s || !s.length)
        return;
      const o = oh(s), m = Ln(e), { mode: d } = m;
      if (a.isLeaving)
        return Do(o);
      const h = Uf(o);
      if (!h)
        return Do(o);
      let x = ka(
        h,
        m,
        a,
        i,
        // #11061, ensure enterHooks is fresh after clone
        (I) => x = I
      );
      h.type !== ul && Ui(h, x);
      let y = i.subTree && Uf(i.subTree);
      if (y && y.type !== ul && !ri(y, h) && ch(i).type !== ul) {
        let I = ka(
          y,
          m,
          a,
          i
        );
        if (Ui(y, I), d === "out-in" && h.type !== ul)
          return a.isLeaving = !0, I.afterLeave = () => {
            a.isLeaving = !1, i.job.flags & 8 || i.update(), delete I.afterLeave, y = void 0;
          }, Do(o);
        d === "in-out" && h.type !== ul ? I.delayLeave = (q, A, R) => {
          const V = fh(
            a,
            y
          );
          V[String(y.key)] = y, q[qi] = () => {
            A(), q[qi] = void 0, delete x.delayedLeave, y = void 0;
          }, x.delayedLeave = () => {
            R(), delete x.delayedLeave, y = void 0;
          };
        } : y = void 0;
      } else y && (y = void 0);
      return o;
    };
  }
};
function oh(e) {
  let l = e[0];
  if (e.length > 1) {
    for (const i of e)
      if (i.type !== ul) {
        l = i;
        break;
      }
  }
  return l;
}
const mh = Wx;
function fh(e, l) {
  const { leavingVNodes: i } = e;
  let a = i.get(l.type);
  return a || (a = /* @__PURE__ */ Object.create(null), i.set(l.type, a)), a;
}
function ka(e, l, i, a, s) {
  const {
    appear: o,
    mode: m,
    persisted: d = !1,
    onBeforeEnter: h,
    onEnter: x,
    onAfterEnter: y,
    onEnterCancelled: I,
    onBeforeLeave: q,
    onLeave: A,
    onAfterLeave: R,
    onLeaveCancelled: V,
    onBeforeAppear: U,
    onAppear: z,
    onAfterAppear: X,
    onAppearCancelled: B
  } = l, K = String(e.key), W = fh(i, e), se = (M, ce) => {
    M && Ct(
      M,
      a,
      9,
      ce
    );
  }, te = (M, ce) => {
    const Ie = ce[1];
    se(M, ce), Xe(M) ? M.every((ae) => ae.length <= 1) && Ie() : M.length <= 1 && Ie();
  }, me = {
    mode: m,
    persisted: d,
    beforeEnter(M) {
      let ce = h;
      if (!i.isMounted)
        if (o)
          ce = U || h;
        else
          return;
      M[qi] && M[qi](
        !0
        /* cancelled */
      );
      const Ie = W[K];
      Ie && ri(e, Ie) && Ie.el[qi] && Ie.el[qi](), se(ce, [M]);
    },
    enter(M) {
      let ce = x, Ie = y, ae = I;
      if (!i.isMounted)
        if (o)
          ce = z || x, Ie = X || y, ae = B || I;
        else
          return;
      let ve = !1;
      const ye = M[Fs] = (Se) => {
        ve || (ve = !0, Se ? se(ae, [M]) : se(Ie, [M]), me.delayedLeave && me.delayedLeave(), M[Fs] = void 0);
      };
      ce ? te(ce, [M, ye]) : ye();
    },
    leave(M, ce) {
      const Ie = String(e.key);
      if (M[Fs] && M[Fs](
        !0
        /* cancelled */
      ), i.isUnmounting)
        return ce();
      se(q, [M]);
      let ae = !1;
      const ve = M[qi] = (ye) => {
        ae || (ae = !0, ce(), ye ? se(V, [M]) : se(R, [M]), M[qi] = void 0, W[Ie] === e && delete W[Ie]);
      };
      W[Ie] = e, A ? te(A, [M, ve]) : ve();
    },
    clone(M) {
      const ce = ka(
        M,
        l,
        i,
        a,
        s
      );
      return s && s(ce), ce;
    }
  };
  return me;
}
function Do(e) {
  if (vs(e))
    return e = di(e), e.children = null, e;
}
function Uf(e) {
  if (!vs(e))
    return ah(e.type) && e.children ? oh(e.children) : e;
  if (e.component)
    return e.component.subTree;
  const { shapeFlag: l, children: i } = e;
  if (i) {
    if (l & 16)
      return i[0];
    if (l & 32 && cn(i.default))
      return i.default();
  }
}
function Ui(e, l) {
  e.shapeFlag & 6 && e.component ? (e.transition = l, Ui(e.component.subTree, l)) : e.shapeFlag & 128 ? (e.ssContent.transition = l.clone(e.ssContent), e.ssFallback.transition = l.clone(e.ssFallback)) : e.transition = l;
}
function $c(e, l = !1, i) {
  let a = [], s = 0;
  for (let o = 0; o < e.length; o++) {
    let m = e[o];
    const d = i == null ? m.key : String(i) + String(m.key != null ? m.key : o);
    m.type === Mn ? (m.patchFlag & 128 && s++, a = a.concat(
      $c(m.children, l, d)
    )) : (l || m.type !== ul) && a.push(d != null ? di(m, { key: d }) : m);
  }
  if (s > 1)
    for (let o = 0; o < a.length; o++)
      a[o].patchFlag = -2;
  return a;
}
// @__NO_SIDE_EFFECTS__
function dn(e, l) {
  return cn(e) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    kn({ name: e.name }, l, { setup: e })
  ) : e;
}
function dh() {
  const e = Xn();
  return e ? (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++ : "";
}
function Jm(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
}
function ef(e) {
  const l = Xn(), i = Fl(null);
  if (l) {
    const s = l.refs === On ? l.refs = {} : l.refs;
    Object.defineProperty(s, e, {
      enumerable: !0,
      get: () => i.value,
      set: (o) => i.value = o
    });
  }
  return i;
}
const gc = /* @__PURE__ */ new WeakMap();
function Na(e, l, i, a, s = !1) {
  if (Xe(e)) {
    e.forEach(
      (R, V) => Na(
        R,
        l && (Xe(l) ? l[V] : l),
        i,
        a,
        s
      )
    );
    return;
  }
  if (Zu(a) && !s) {
    a.shapeFlag & 512 && a.type.__asyncResolved && a.component.subTree.component && Na(e, l, i, a.component.subTree);
    return;
  }
  const o = a.shapeFlag & 4 ? Ds(a.component) : a.el, m = s ? null : o, { i: d, r: h } = e, x = l && l.r, y = d.refs === On ? d.refs = {} : d.refs, I = d.setupState, q = Ln(I), A = I === On ? Pp : (R) => Tn(q, R);
  if (x != null && x !== h) {
    if (Kf(l), Wn(x))
      y[x] = null, A(x) && (I[x] = null);
    else if (Vn(x)) {
      x.value = null;
      const R = l;
      R.k && (y[R.k] = null);
    }
  }
  if (cn(h))
    Ya(h, d, 12, [m, y]);
  else {
    const R = Wn(h), V = Vn(h);
    if (R || V) {
      const U = () => {
        if (e.f) {
          const z = R ? A(h) ? I[h] : y[h] : h.value;
          if (s)
            Xe(z) && Um(z, o);
          else if (Xe(z))
            z.includes(o) || z.push(o);
          else if (R)
            y[h] = [o], A(h) && (I[h] = y[h]);
          else {
            const X = [o];
            h.value = X, e.k && (y[e.k] = X);
          }
        } else R ? (y[h] = m, A(h) && (I[h] = m)) : V && (h.value = m, e.k && (y[e.k] = m));
      };
      if (m) {
        const z = () => {
          U(), gc.delete(e);
        };
        z.id = -1, gc.set(e, z), hl(z, i);
      } else
        Kf(e), U();
    }
  }
}
function Kf(e) {
  const l = gc.get(e);
  l && (l.flags |= 8, gc.delete(e));
}
let Gf = !1;
const ya = () => {
  Gf || (console.error("Hydration completed but contains mismatches."), Gf = !0);
}, Yx = (e) => e.namespaceURI.includes("svg") && e.tagName !== "foreignObject", Xx = (e) => e.namespaceURI.includes("MathML"), Ms = (e) => {
  if (e.nodeType === 1) {
    if (Yx(e)) return "svg";
    if (Xx(e)) return "mathml";
  }
}, Ca = (e) => e.nodeType === 8;
function Qx(e) {
  const {
    mt: l,
    p: i,
    o: {
      patchProp: a,
      createText: s,
      nextSibling: o,
      parentNode: m,
      remove: d,
      insert: h,
      createComment: x
    }
  } = e, y = (B, K) => {
    if (!K.hasChildNodes()) {
      i(null, B, K), hc(), K._vnode = B;
      return;
    }
    I(K.firstChild, B, null, null, null), hc(), K._vnode = B;
  }, I = (B, K, W, se, te, me = !1) => {
    me = me || !!K.dynamicChildren;
    const M = Ca(B) && B.data === "[", ce = () => V(
      B,
      K,
      W,
      se,
      te,
      M
    ), { type: Ie, ref: ae, shapeFlag: ve, patchFlag: ye } = K;
    let Se = B.nodeType;
    K.el = B, ye === -2 && (me = !1, K.dynamicChildren = null);
    let ge = null;
    switch (Ie) {
      case Uu:
        Se !== 3 ? K.children === "" ? (h(K.el = s(""), m(B), B), ge = B) : ge = ce() : (B.data !== K.children && (ya(), B.data = K.children), ge = o(B));
        break;
      case ul:
        X(B) ? (ge = o(B), z(
          K.el = B.content.firstChild,
          B,
          W
        )) : Se !== 8 || M ? ge = ce() : ge = o(B);
        break;
      case ua:
        if (M && (B = o(B), Se = B.nodeType), Se === 1 || Se === 3) {
          ge = B;
          const oe = !K.children.length;
          for (let de = 0; de < K.staticCount; de++)
            oe && (K.children += ge.nodeType === 1 ? ge.outerHTML : ge.data), de === K.staticCount - 1 && (K.anchor = ge), ge = o(ge);
          return M ? o(ge) : ge;
        } else
          ce();
        break;
      case Mn:
        M ? ge = R(
          B,
          K,
          W,
          se,
          te,
          me
        ) : ge = ce();
        break;
      default:
        if (ve & 1)
          (Se !== 1 || K.type.toLowerCase() !== B.tagName.toLowerCase()) && !X(B) ? ge = ce() : ge = q(
            B,
            K,
            W,
            se,
            te,
            me
          );
        else if (ve & 6) {
          K.slotScopeIds = te;
          const oe = m(B);
          if (M ? ge = U(B) : Ca(B) && B.data === "teleport start" ? ge = U(B, B.data, "teleport end") : ge = o(B), l(
            K,
            oe,
            null,
            W,
            se,
            Ms(oe),
            me
          ), Zu(K) && !K.type.__asyncResolved) {
            let de;
            M ? (de = je(Mn), de.anchor = ge ? ge.previousSibling : oe.lastChild) : de = B.nodeType === 3 ? Gi("") : je("div"), de.el = B, K.component.subTree = de;
          }
        } else ve & 64 ? Se !== 8 ? ge = ce() : ge = K.type.hydrate(
          B,
          K,
          W,
          se,
          te,
          me,
          e,
          A
        ) : ve & 128 && (ge = K.type.hydrate(
          B,
          K,
          W,
          se,
          Ms(m(B)),
          te,
          me,
          e,
          I
        ));
    }
    return ae != null && Na(ae, null, se, K), ge;
  }, q = (B, K, W, se, te, me) => {
    me = me || !!K.dynamicChildren;
    const { type: M, props: ce, patchFlag: Ie, shapeFlag: ae, dirs: ve, transition: ye } = K, Se = M === "input" || M === "option";
    if (Se || Ie !== -1) {
      ve && Li(K, null, W, "created");
      let ge = !1;
      if (X(B)) {
        ge = kh(
          null,
          // no need check parentSuspense in hydration
          ye
        ) && W && W.vnode.props && W.vnode.props.appear;
        const de = B.content.firstChild;
        if (ge) {
          const De = de.getAttribute("class");
          De && (de.$cls = De), ye.beforeEnter(de);
        }
        z(de, B, W), K.el = B = de;
      }
      if (ae & 16 && // skip if element has innerHTML / textContent
      !(ce && (ce.innerHTML || ce.textContent))) {
        let de = A(
          B.firstChild,
          K,
          B,
          W,
          se,
          te,
          me
        );
        for (; de; ) {
          ks(
            B,
            1
            /* CHILDREN */
          ) || ya();
          const De = de;
          de = de.nextSibling, d(De);
        }
      } else if (ae & 8) {
        let de = K.children;
        de[0] === `
` && (B.tagName === "PRE" || B.tagName === "TEXTAREA") && (de = de.slice(1)), B.textContent !== de && (ks(
          B,
          0
          /* TEXT */
        ) || ya(), B.textContent = K.children);
      }
      if (ce) {
        if (Se || !me || Ie & 48) {
          const de = B.tagName.includes("-");
          for (const De in ce)
            (Se && (De.endsWith("value") || De === "indeterminate") || ps(De) && !Aa(De) || // force hydrate v-bind with .prop modifiers
            De[0] === "." || de) && a(B, De, null, ce[De], void 0, W);
        } else if (ce.onClick)
          a(
            B,
            "onClick",
            null,
            ce.onClick,
            void 0,
            W
          );
        else if (Ie & 4 && oi(ce.style))
          for (const de in ce.style) ce.style[de];
      }
      let oe;
      (oe = ce && ce.onVnodeBeforeMount) && dt(oe, W, K), ve && Li(K, null, W, "beforeMount"), ((oe = ce && ce.onVnodeMounted) || ve || ge) && jh(() => {
        oe && dt(oe, W, K), ge && ye.enter(B), ve && Li(K, null, W, "mounted");
      }, se);
    }
    return B.nextSibling;
  }, A = (B, K, W, se, te, me, M) => {
    M = M || !!K.dynamicChildren;
    const ce = K.children, Ie = ce.length;
    for (let ae = 0; ae < Ie; ae++) {
      const ve = M ? ce[ae] : ce[ae] = pt(ce[ae]), ye = ve.type === Uu;
      B ? (ye && !M && ae + 1 < Ie && pt(ce[ae + 1]).type === Uu && (h(
        s(
          B.data.slice(ve.children.length)
        ),
        W,
        o(B)
      ), B.data = ve.children), B = I(
        B,
        ve,
        se,
        te,
        me,
        M
      )) : ye && !ve.children ? h(ve.el = s(""), W) : (ks(
        W,
        1
        /* CHILDREN */
      ) || ya(), i(
        null,
        ve,
        W,
        null,
        se,
        te,
        Ms(W),
        me
      ));
    }
    return B;
  }, R = (B, K, W, se, te, me) => {
    const { slotScopeIds: M } = K;
    M && (te = te ? te.concat(M) : M);
    const ce = m(B), Ie = A(
      o(B),
      K,
      ce,
      W,
      se,
      te,
      me
    );
    return Ie && Ca(Ie) && Ie.data === "]" ? o(K.anchor = Ie) : (ya(), h(K.anchor = x("]"), ce, Ie), Ie);
  }, V = (B, K, W, se, te, me) => {
    if (ks(
      B.parentElement,
      1
      /* CHILDREN */
    ) || ya(), K.el = null, me) {
      const Ie = U(B);
      for (; ; ) {
        const ae = o(B);
        if (ae && ae !== Ie)
          d(ae);
        else
          break;
      }
    }
    const M = o(B), ce = m(B);
    return d(B), i(
      null,
      K,
      ce,
      M,
      W,
      se,
      Ms(ce),
      te
    ), W && (W.vnode.el = K.el, eo(W, K.el)), M;
  }, U = (B, K = "[", W = "]") => {
    let se = 0;
    for (; B; )
      if (B = o(B), B && Ca(B) && (B.data === K && se++, B.data === W)) {
        if (se === 0)
          return o(B);
        se--;
      }
    return B;
  }, z = (B, K, W) => {
    const se = K.parentNode;
    se && se.replaceChild(B, K);
    let te = W;
    for (; te; )
      te.vnode.el === K && (te.vnode.el = te.subTree.el = B), te = te.parent;
  }, X = (B) => B.nodeType === 1 && B.tagName === "TEMPLATE";
  return [y, I];
}
const zf = "data-allow-mismatch", Jx = {
  0: "text",
  1: "children",
  2: "class",
  3: "style",
  4: "attribute"
};
function ks(e, l) {
  if (l === 0 || l === 1)
    for (; e && !e.hasAttribute(zf); )
      e = e.parentElement;
  const i = e && e.getAttribute(zf);
  if (i == null)
    return !1;
  if (i === "")
    return !0;
  {
    const a = i.split(",");
    return l === 0 && a.includes("children") ? !0 : a.includes(Jx[l]);
  }
}
const ey = kc().requestIdleCallback || ((e) => setTimeout(e, 1)), ny = kc().cancelIdleCallback || ((e) => clearTimeout(e)), ly = (e = 1e4) => (l) => {
  const i = ey(l, { timeout: e });
  return () => ny(i);
};
function ty(e) {
  const { top: l, left: i, bottom: a, right: s } = e.getBoundingClientRect(), { innerHeight: o, innerWidth: m } = window;
  return (l > 0 && l < o || a > 0 && a < o) && (i > 0 && i < m || s > 0 && s < m);
}
const iy = (e) => (l, i) => {
  const a = new IntersectionObserver((s) => {
    for (const o of s)
      if (o.isIntersecting) {
        a.disconnect(), l();
        break;
      }
  }, e);
  return i((s) => {
    if (s instanceof Element) {
      if (ty(s))
        return l(), a.disconnect(), !1;
      a.observe(s);
    }
  }), () => a.disconnect();
}, uy = (e) => (l) => {
  if (e) {
    const i = matchMedia(e);
    if (i.matches)
      l();
    else
      return i.addEventListener("change", l, { once: !0 }), () => i.removeEventListener("change", l);
  }
}, ay = (e = []) => (l, i) => {
  Wn(e) && (e = [e]);
  let a = !1;
  const s = (m) => {
    a || (a = !0, o(), l(), m.target.dispatchEvent(new m.constructor(m.type, m)));
  }, o = () => {
    i((m) => {
      for (const d of e)
        m.removeEventListener(d, s);
    });
  };
  return i((m) => {
    for (const d of e)
      m.addEventListener(d, s, { once: !0 });
  }), o;
};
function ry(e, l) {
  if (Ca(e) && e.data === "[") {
    let i = 1, a = e.nextSibling;
    for (; a; ) {
      if (a.nodeType === 1) {
        if (l(a) === !1)
          break;
      } else if (Ca(a))
        if (a.data === "]") {
          if (--i === 0) break;
        } else a.data === "[" && i++;
      a = a.nextSibling;
    }
  } else
    l(e);
}
const Zu = (e) => !!e.type.__asyncLoader;
// @__NO_SIDE_EFFECTS__
function sy(e) {
  cn(e) && (e = { loader: e });
  const {
    loader: l,
    loadingComponent: i,
    errorComponent: a,
    delay: s = 200,
    hydrate: o,
    timeout: m,
    // undefined = never times out
    suspensible: d = !0,
    onError: h
  } = e;
  let x = null, y, I = 0;
  const q = () => (I++, x = null, A()), A = () => {
    let R;
    return x || (R = x = l().catch((V) => {
      if (V = V instanceof Error ? V : new Error(String(V)), h)
        return new Promise((U, z) => {
          h(V, () => U(q()), () => z(V), I + 1);
        });
      throw V;
    }).then((V) => R !== x && x ? x : (V && (V.__esModule || V[Symbol.toStringTag] === "Module") && (V = V.default), y = V, V)));
  };
  return /* @__PURE__ */ dn({
    name: "AsyncComponentWrapper",
    __asyncLoader: A,
    __asyncHydrate(R, V, U) {
      let z = !1;
      (V.bu || (V.bu = [])).push(() => z = !0);
      const X = () => {
        z || U();
      }, B = o ? () => {
        const K = o(
          X,
          (W) => ry(R, W)
        );
        K && (V.bum || (V.bum = [])).push(K);
      } : X;
      y ? B() : A().then(() => !V.isUnmounted && B());
    },
    get __asyncResolved() {
      return y;
    },
    setup() {
      const R = Al;
      if (Jm(R), y)
        return () => Oo(y, R);
      const V = (B) => {
        x = null, fa(
          B,
          R,
          13,
          !a
        );
      };
      if (d && R.suspense || Va)
        return A().then((B) => () => Oo(B, R)).catch((B) => (V(B), () => a ? je(a, {
          error: B
        }) : null));
      const U = Fe(!1), z = Fe(), X = Fe(!!s);
      return s && setTimeout(() => {
        X.value = !1;
      }, s), m != null && setTimeout(() => {
        if (!U.value && !z.value) {
          const B = new Error(
            `Async component timed out after ${m}ms.`
          );
          V(B), z.value = B;
        }
      }, m), A().then(() => {
        U.value = !0, R.parent && vs(R.parent.vnode) && R.parent.update();
      }).catch((B) => {
        V(B), z.value = B;
      }), () => {
        if (U.value && y)
          return Oo(y, R);
        if (z.value && a)
          return je(a, {
            error: z.value
          });
        if (i && !X.value)
          return je(i);
      };
    }
  });
}
function Oo(e, l) {
  const { ref: i, props: a, children: s, ce: o } = l.vnode, m = je(e, a, s);
  return m.ref = i, m.ce = o, delete l.vnode.ce, m;
}
const vs = (e) => e.type.__isKeepAlive, cy = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: !0,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(e, { slots: l }) {
    const i = Xn(), a = i.ctx;
    if (!a.renderer)
      return () => {
        const X = l.default && l.default();
        return X && X.length === 1 ? X[0] : X;
      };
    const s = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Set();
    let m = null;
    const d = i.suspense, {
      renderer: {
        p: h,
        m: x,
        um: y,
        o: { createElement: I }
      }
    } = a, q = I("div");
    a.activate = (X, B, K, W, se) => {
      const te = X.component;
      x(X, B, K, 0, d), h(
        te.vnode,
        X,
        B,
        K,
        te,
        d,
        W,
        X.slotScopeIds,
        se
      ), hl(() => {
        te.isDeactivated = !1, te.a && Ea(te.a);
        const me = X.props && X.props.onVnodeMounted;
        me && dt(me, te.parent, X);
      }, d);
    }, a.deactivate = (X) => {
      const B = X.component;
      xc(B.m), xc(B.a), x(X, q, null, 1, d), hl(() => {
        B.da && Ea(B.da);
        const K = X.props && X.props.onVnodeUnmounted;
        K && dt(K, B.parent, X), B.isDeactivated = !0;
      }, d);
    };
    function A(X) {
      bo(X), y(X, i, d, !0);
    }
    function R(X) {
      s.forEach((B, K) => {
        const W = gm(B.type);
        W && !X(W) && V(K);
      });
    }
    function V(X) {
      const B = s.get(X);
      B && (!m || !ri(B, m)) ? A(B) : m && bo(m), s.delete(X), o.delete(X);
    }
    Sn(
      () => [e.include, e.exclude],
      ([X, B]) => {
        X && R((K) => kr(X, K)), B && R((K) => !kr(B, K));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: !0 }
    );
    let U = null;
    const z = () => {
      U != null && (yc(i.subTree.type) ? hl(() => {
        s.set(U, Vs(i.subTree));
      }, i.subTree.suspense) : s.set(U, Vs(i.subTree)));
    };
    return vl(z), Yc(z), xs(() => {
      s.forEach((X) => {
        const { subTree: B, suspense: K } = i, W = Vs(B);
        if (X.type === W.type && X.key === W.key) {
          bo(W);
          const se = W.component.da;
          se && hl(se, K);
          return;
        }
        A(X);
      });
    }), () => {
      if (U = null, !l.default)
        return m = null;
      const X = l.default(), B = X[0];
      if (X.length > 1)
        return m = null, X;
      if (!Ki(B) || !(B.shapeFlag & 4) && !(B.shapeFlag & 128))
        return m = null, B;
      let K = Vs(B);
      if (K.type === ul)
        return m = null, K;
      const W = K.type, se = gm(
        Zu(K) ? K.type.__asyncResolved || {} : W
      ), { include: te, exclude: me, max: M } = e;
      if (te && (!se || !kr(te, se)) || me && se && kr(me, se))
        return K.shapeFlag &= -257, m = K, B;
      const ce = K.key == null ? W : K.key, Ie = s.get(ce);
      return K.el && (K = di(K), B.shapeFlag & 128 && (B.ssContent = K)), U = ce, Ie ? (K.el = Ie.el, K.component = Ie.component, K.transition && Ui(K, K.transition), K.shapeFlag |= 512, o.delete(ce), o.add(ce)) : (o.add(ce), M && o.size > parseInt(M, 10) && V(o.values().next().value)), K.shapeFlag |= 256, m = K, yc(B.type) ? B : K;
    };
  }
}, oy = cy;
function kr(e, l) {
  return Xe(e) ? e.some((i) => kr(i, l)) : Wn(e) ? e.split(",").includes(l) : Kv(e) ? (e.lastIndex = 0, e.test(l)) : !1;
}
function ph(e, l) {
  gh(e, "a", l);
}
function hh(e, l) {
  gh(e, "da", l);
}
function gh(e, l, i = Al) {
  const a = e.__wdc || (e.__wdc = () => {
    let s = i;
    for (; s; ) {
      if (s.isDeactivated)
        return;
      s = s.parent;
    }
    return e();
  });
  if (Wc(l, a, i), i) {
    let s = i.parent;
    for (; s && s.parent; )
      vs(s.parent.vnode) && my(a, l, i, s), s = s.parent;
  }
}
function my(e, l, i, a) {
  const s = Wc(
    l,
    e,
    a,
    !0
    /* prepend */
  );
  Dt(() => {
    Um(a[l], s);
  }, i);
}
function bo(e) {
  e.shapeFlag &= -257, e.shapeFlag &= -513;
}
function Vs(e) {
  return e.shapeFlag & 128 ? e.ssContent : e;
}
function Wc(e, l, i = Al, a = !1) {
  if (i) {
    const s = i[e] || (i[e] = []), o = l.__weh || (l.__weh = (...m) => {
      ki();
      const d = ra(i), h = Ct(l, i, e, m);
      return d(), Vi(), h;
    });
    return a ? s.unshift(o) : s.push(o), o;
  }
}
const Wi = (e) => (l, i = Al) => {
  (!Va || e === "sp") && Wc(e, (...a) => l(...a), i);
}, vh = Wi("bm"), vl = Wi("m"), nf = Wi(
  "bu"
), Yc = Wi("u"), xs = Wi(
  "bum"
), Dt = Wi("um"), xh = Wi(
  "sp"
), yh = Wi("rtg"), Ih = Wi("rtc");
function Lh(e, l = Al) {
  Wc("ec", e, l);
}
const lf = "components", fy = "directives";
function dy(e, l) {
  return tf(lf, e, !0, l) || e;
}
const Dh = Symbol.for("v-ndc");
function ys(e) {
  return Wn(e) ? tf(lf, e, !1) || e : e || Dh;
}
function py(e) {
  return tf(fy, e);
}
function tf(e, l, i = !0, a = !1) {
  const s = Rl || Al;
  if (s) {
    const o = s.type;
    if (e === lf) {
      const d = gm(
        o,
        !1
      );
      if (d && (d === l || d === gl(l) || d === hs(gl(l))))
        return o;
    }
    const m = (
      // local registration
      // check instance[type] first which is resolved for options API
      jf(s[e] || o[e], l) || // global registration
      jf(s.appContext[e], l)
    );
    return !m && a ? o : m;
  }
}
function jf(e, l) {
  return e && (e[l] || e[gl(l)] || e[hs(gl(l))]);
}
function Is(e, l, i, a) {
  let s;
  const o = i && i[a], m = Xe(e);
  if (m || Wn(e)) {
    const d = m && oi(e);
    let h = !1, x = !1;
    d && (h = !yt(e), x = Zi(e), e = Kc(e)), s = new Array(e.length);
    for (let y = 0, I = e.length; y < I; y++)
      s[y] = l(
        h ? x ? fc(ql(e[y])) : ql(e[y]) : e[y],
        y,
        void 0,
        o && o[y]
      );
  } else if (typeof e == "number") {
    s = new Array(e);
    for (let d = 0; d < e; d++)
      s[d] = l(d + 1, d, void 0, o && o[d]);
  } else if (_n(e))
    if (e[Symbol.iterator])
      s = Array.from(
        e,
        (d, h) => l(d, h, void 0, o && o[h])
      );
    else {
      const d = Object.keys(e);
      s = new Array(d.length);
      for (let h = 0, x = d.length; h < x; h++) {
        const y = d[h];
        s[h] = l(e[y], y, h, o && o[h]);
      }
    }
  else
    s = [];
  return i && (i[a] = s), s;
}
function hy(e, l) {
  for (let i = 0; i < l.length; i++) {
    const a = l[i];
    if (Xe(a))
      for (let s = 0; s < a.length; s++)
        e[a[s].name] = a[s].fn;
    else a && (e[a.name] = a.key ? (...s) => {
      const o = a.fn(...s);
      return o && (o.key = a.key), o;
    } : a.fn);
  }
  return e;
}
function qn(e, l, i = {}, a, s) {
  if (Rl.ce || Rl.parent && Zu(Rl.parent) && Rl.parent.ce) {
    const x = Object.keys(i).length > 0;
    return l !== "default" && (i.name = l), We(), vn(
      Mn,
      null,
      [je("slot", i, a && a())],
      x ? -2 : 64
    );
  }
  let o = e[l];
  o && o._c && (o._d = !1), We();
  const m = o && uf(o(i)), d = i.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  m && m.key, h = vn(
    Mn,
    {
      key: (d && !fi(d) ? d : `_${l}`) + // #7256 force differentiate fallback content from actual content
      (!m && a ? "_fb" : "")
    },
    m || (a ? a() : []),
    m && e._ === 1 ? 64 : -2
  );
  return !s && h.scopeId && (h.slotScopeIds = [h.scopeId + "-s"]), o && o._c && (o._d = !0), h;
}
function uf(e) {
  return e.some((l) => Ki(l) ? !(l.type === ul || l.type === Mn && !uf(l.children)) : !0) ? e : null;
}
function gy(e, l) {
  const i = {};
  for (const a in e)
    i[l && /[A-Z]/.test(a) ? `on:${a}` : Ra(a)] = e[a];
  return i;
}
const am = (e) => e ? Xh(e) ? Ds(e) : am(e.parent) : null, zr = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ kn(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => e.props,
    $attrs: (e) => e.attrs,
    $slots: (e) => e.slots,
    $refs: (e) => e.refs,
    $parent: (e) => am(e.parent),
    $root: (e) => am(e.root),
    $host: (e) => e.ce,
    $emit: (e) => e.emit,
    $options: (e) => af(e),
    $forceUpdate: (e) => e.f || (e.f = () => {
      Ym(e.update);
    }),
    $nextTick: (e) => e.n || (e.n = il.bind(e.proxy)),
    $watch: (e) => Gy.bind(e)
  })
), wo = (e, l) => e !== On && !e.__isScriptSetup && Tn(e, l), rm = {
  get({ _: e }, l) {
    if (l === "__v_skip")
      return !0;
    const { ctx: i, setupState: a, data: s, props: o, accessCache: m, type: d, appContext: h } = e;
    let x;
    if (l[0] !== "$") {
      const A = m[l];
      if (A !== void 0)
        switch (A) {
          case 1:
            return a[l];
          case 2:
            return s[l];
          case 4:
            return i[l];
          case 3:
            return o[l];
        }
      else {
        if (wo(a, l))
          return m[l] = 1, a[l];
        if (s !== On && Tn(s, l))
          return m[l] = 2, s[l];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (x = e.propsOptions[0]) && Tn(x, l)
        )
          return m[l] = 3, o[l];
        if (i !== On && Tn(i, l))
          return m[l] = 4, i[l];
        sm && (m[l] = 0);
      }
    }
    const y = zr[l];
    let I, q;
    if (y)
      return l === "$attrs" && _l(e.attrs, "get", ""), y(e);
    if (
      // css module (injected by vue-loader)
      (I = d.__cssModules) && (I = I[l])
    )
      return I;
    if (i !== On && Tn(i, l))
      return m[l] = 4, i[l];
    if (
      // global properties
      q = h.config.globalProperties, Tn(q, l)
    )
      return q[l];
  },
  set({ _: e }, l, i) {
    const { data: a, setupState: s, ctx: o } = e;
    return wo(s, l) ? (s[l] = i, !0) : a !== On && Tn(a, l) ? (a[l] = i, !0) : Tn(e.props, l) || l[0] === "$" && l.slice(1) in e ? !1 : (o[l] = i, !0);
  },
  has({
    _: { data: e, setupState: l, accessCache: i, ctx: a, appContext: s, propsOptions: o, type: m }
  }, d) {
    let h, x;
    return !!(i[d] || e !== On && d[0] !== "$" && Tn(e, d) || wo(l, d) || (h = o[0]) && Tn(h, d) || Tn(a, d) || Tn(zr, d) || Tn(s.config.globalProperties, d) || (x = m.__cssModules) && x[d]);
  },
  defineProperty(e, l, i) {
    return i.get != null ? e._.accessCache[l] = 0 : Tn(i, "value") && this.set(e, l, i.value, null), Reflect.defineProperty(e, l, i);
  }
}, vy = /* @__PURE__ */ kn({}, rm, {
  get(e, l) {
    if (l !== Symbol.unscopables)
      return rm.get(e, l, e);
  },
  has(e, l) {
    return l[0] !== "_" && !$v(l);
  }
});
function xy() {
  return null;
}
function yy() {
  return null;
}
function Iy(e) {
}
function Ly(e) {
}
function Dy() {
  return null;
}
function Oy() {
}
function by(e, l) {
  return null;
}
function wy() {
  return Oh().slots;
}
function Sy() {
  return Oh().attrs;
}
function Oh(e) {
  const l = Xn();
  return l.setupContext || (l.setupContext = eg(l));
}
function us(e) {
  return Xe(e) ? e.reduce(
    (l, i) => (l[i] = null, l),
    {}
  ) : e;
}
function bh(e, l) {
  const i = us(e);
  for (const a in l) {
    if (a.startsWith("__skip")) continue;
    let s = i[a];
    s ? Xe(s) || cn(s) ? s = i[a] = { type: s, default: l[a] } : s.default = l[a] : s === null && (s = i[a] = { default: l[a] }), s && l[`__skip_${a}`] && (s.skipFactory = !0);
  }
  return i;
}
function Cy(e, l) {
  return !e || !l ? e || l : Xe(e) && Xe(l) ? e.concat(l) : kn({}, us(e), us(l));
}
function Ty(e, l) {
  const i = {};
  for (const a in e)
    l.includes(a) || Object.defineProperty(i, a, {
      enumerable: !0,
      get: () => e[a]
    });
  return i;
}
function Py(e) {
  const l = Xn();
  let i = e();
  return dm(), Km(i) && (i = i.catch((a) => {
    throw ra(l), a;
  })), [i, () => ra(l)];
}
let sm = !0;
function qy(e) {
  const l = af(e), i = e.proxy, a = e.ctx;
  sm = !1, l.beforeCreate && Hf(l.beforeCreate, e, "bc");
  const {
    // state
    data: s,
    computed: o,
    methods: m,
    watch: d,
    provide: h,
    inject: x,
    // lifecycle
    created: y,
    beforeMount: I,
    mounted: q,
    beforeUpdate: A,
    updated: R,
    activated: V,
    deactivated: U,
    beforeDestroy: z,
    beforeUnmount: X,
    destroyed: B,
    unmounted: K,
    render: W,
    renderTracked: se,
    renderTriggered: te,
    errorCaptured: me,
    serverPrefetch: M,
    // public API
    expose: ce,
    inheritAttrs: Ie,
    // assets
    components: ae,
    directives: ve,
    filters: ye
  } = l;
  if (x && Ay(x, a, null), m)
    for (const oe in m) {
      const de = m[oe];
      cn(de) && (a[oe] = de.bind(i));
    }
  if (s) {
    const oe = s.call(i, i);
    _n(oe) && (e.data = Ha(oe));
  }
  if (sm = !0, o)
    for (const oe in o) {
      const de = o[oe], De = cn(de) ? de.bind(i, i) : cn(de.get) ? de.get.bind(i, i) : bt, Ee = !cn(de) && cn(de.set) ? de.set.bind(i) : bt, Ye = Re({
        get: De,
        set: Ee
      });
      Object.defineProperty(a, oe, {
        enumerable: !0,
        configurable: !0,
        get: () => Ye.value,
        set: (ze) => Ye.value = ze
      });
    }
  if (d)
    for (const oe in d)
      wh(d[oe], a, i, oe);
  if (h) {
    const oe = cn(h) ? h.call(i) : h;
    Reflect.ownKeys(oe).forEach((de) => {
      Xc(de, oe[de]);
    });
  }
  y && Hf(y, e, "c");
  function ge(oe, de) {
    Xe(de) ? de.forEach((De) => oe(De.bind(i))) : de && oe(de.bind(i));
  }
  if (ge(vh, I), ge(vl, q), ge(nf, A), ge(Yc, R), ge(ph, V), ge(hh, U), ge(Lh, me), ge(Ih, se), ge(yh, te), ge(xs, X), ge(Dt, K), ge(xh, M), Xe(ce))
    if (ce.length) {
      const oe = e.exposed || (e.exposed = {});
      ce.forEach((de) => {
        Object.defineProperty(oe, de, {
          get: () => i[de],
          set: (De) => i[de] = De,
          enumerable: !0
        });
      });
    } else e.exposed || (e.exposed = {});
  W && e.render === bt && (e.render = W), Ie != null && (e.inheritAttrs = Ie), ae && (e.components = ae), ve && (e.directives = ve), M && Jm(e);
}
function Ay(e, l, i = bt) {
  Xe(e) && (e = cm(e));
  for (const a in e) {
    const s = e[a];
    let o;
    _n(s) ? "default" in s ? o = Fi(
      s.from || a,
      s.default,
      !0
    ) : o = Fi(s.from || a) : o = Fi(s), Vn(o) ? Object.defineProperty(l, a, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (m) => o.value = m
    }) : l[a] = o;
  }
}
function Hf(e, l, i) {
  Ct(
    Xe(e) ? e.map((a) => a.bind(l.proxy)) : e.bind(l.proxy),
    l,
    i
  );
}
function wh(e, l, i, a) {
  let s = a.includes(".") ? Uh(i, a) : () => i[a];
  if (Wn(e)) {
    const o = l[e];
    cn(o) && Sn(s, o);
  } else if (cn(e))
    Sn(s, e.bind(i));
  else if (_n(e))
    if (Xe(e))
      e.forEach((o) => wh(o, l, i, a));
    else {
      const o = cn(e.handler) ? e.handler.bind(i) : l[e.handler];
      cn(o) && Sn(s, o, e);
    }
}
function af(e) {
  const l = e.type, { mixins: i, extends: a } = l, {
    mixins: s,
    optionsCache: o,
    config: { optionMergeStrategies: m }
  } = e.appContext, d = o.get(l);
  let h;
  return d ? h = d : !s.length && !i && !a ? h = l : (h = {}, s.length && s.forEach(
    (x) => vc(h, x, m, !0)
  ), vc(h, l, m)), _n(l) && o.set(l, h), h;
}
function vc(e, l, i, a = !1) {
  const { mixins: s, extends: o } = l;
  o && vc(e, o, i, !0), s && s.forEach(
    (m) => vc(e, m, i, !0)
  );
  for (const m in l)
    if (!(a && m === "expose")) {
      const d = Ry[m] || i && i[m];
      e[m] = d ? d(e[m], l[m]) : l[m];
    }
  return e;
}
const Ry = {
  data: $f,
  props: Wf,
  emits: Wf,
  // objects
  methods: Vr,
  computed: Vr,
  // lifecycle
  beforeCreate: kl,
  created: kl,
  beforeMount: kl,
  mounted: kl,
  beforeUpdate: kl,
  updated: kl,
  beforeDestroy: kl,
  beforeUnmount: kl,
  destroyed: kl,
  unmounted: kl,
  activated: kl,
  deactivated: kl,
  errorCaptured: kl,
  serverPrefetch: kl,
  // assets
  components: Vr,
  directives: Vr,
  // watch
  watch: _y,
  // provide / inject
  provide: $f,
  inject: Ey
};
function $f(e, l) {
  return l ? e ? function() {
    return kn(
      cn(e) ? e.call(this, this) : e,
      cn(l) ? l.call(this, this) : l
    );
  } : l : e;
}
function Ey(e, l) {
  return Vr(cm(e), cm(l));
}
function cm(e) {
  if (Xe(e)) {
    const l = {};
    for (let i = 0; i < e.length; i++)
      l[e[i]] = e[i];
    return l;
  }
  return e;
}
function kl(e, l) {
  return e ? [...new Set([].concat(e, l))] : l;
}
function Vr(e, l) {
  return e ? kn(/* @__PURE__ */ Object.create(null), e, l) : l;
}
function Wf(e, l) {
  return e ? Xe(e) && Xe(l) ? [.../* @__PURE__ */ new Set([...e, ...l])] : kn(
    /* @__PURE__ */ Object.create(null),
    us(e),
    us(l ?? {})
  ) : l;
}
function _y(e, l) {
  if (!e) return l;
  if (!l) return e;
  const i = kn(/* @__PURE__ */ Object.create(null), e);
  for (const a in l)
    i[a] = kl(e[a], l[a]);
  return i;
}
function Sh() {
  return {
    app: null,
    config: {
      isNativeTag: Pp,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let Ny = 0;
function Fy(e, l) {
  return function(a, s = null) {
    cn(a) || (a = kn({}, a)), s != null && !_n(s) && (s = null);
    const o = Sh(), m = /* @__PURE__ */ new WeakSet(), d = [];
    let h = !1;
    const x = o.app = {
      _uid: Ny++,
      _component: a,
      _props: s,
      _container: null,
      _context: o,
      _instance: null,
      version: tg,
      get config() {
        return o.config;
      },
      set config(y) {
      },
      use(y, ...I) {
        return m.has(y) || (y && cn(y.install) ? (m.add(y), y.install(x, ...I)) : cn(y) && (m.add(y), y(x, ...I))), x;
      },
      mixin(y) {
        return o.mixins.includes(y) || o.mixins.push(y), x;
      },
      component(y, I) {
        return I ? (o.components[y] = I, x) : o.components[y];
      },
      directive(y, I) {
        return I ? (o.directives[y] = I, x) : o.directives[y];
      },
      mount(y, I, q) {
        if (!h) {
          const A = x._ceVNode || je(a, s);
          return A.appContext = o, q === !0 ? q = "svg" : q === !1 && (q = void 0), I && l ? l(A, y) : e(A, y, q), h = !0, x._container = y, y.__vue_app__ = x, Ds(A.component);
        }
      },
      onUnmount(y) {
        d.push(y);
      },
      unmount() {
        h && (Ct(
          d,
          x._instance,
          16
        ), e(null, x._container), delete x._container.__vue_app__);
      },
      provide(y, I) {
        return o.provides[y] = I, x;
      },
      runWithContext(y) {
        const I = ia;
        ia = x;
        try {
          return y();
        } finally {
          ia = I;
        }
      }
    };
    return x;
  };
}
let ia = null;
function Xc(e, l) {
  if (Al) {
    let i = Al.provides;
    const a = Al.parent && Al.parent.provides;
    a === i && (i = Al.provides = Object.create(a)), i[e] = l;
  }
}
function Fi(e, l, i = !1) {
  const a = Xn();
  if (a || ia) {
    let s = ia ? ia._context.provides : a ? a.parent == null || a.ce ? a.vnode.appContext && a.vnode.appContext.provides : a.parent.provides : void 0;
    if (s && e in s)
      return s[e];
    if (arguments.length > 1)
      return i && cn(l) ? l.call(a && a.proxy) : l;
  }
}
function Qc() {
  return !!(Xn() || ia);
}
const Ch = {}, Th = () => Object.create(Ch), Ph = (e) => Object.getPrototypeOf(e) === Ch;
function My(e, l, i, a = !1) {
  const s = {}, o = Th();
  e.propsDefaults = /* @__PURE__ */ Object.create(null), qh(e, l, s, o);
  for (const m in e.propsOptions[0])
    m in s || (s[m] = void 0);
  i ? e.props = a ? s : Yp(s) : e.type.props ? e.props = s : e.props = o, e.attrs = o;
}
function ky(e, l, i, a) {
  const {
    props: s,
    attrs: o,
    vnode: { patchFlag: m }
  } = e, d = Ln(s), [h] = e.propsOptions;
  let x = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (a || m > 0) && !(m & 16)
  ) {
    if (m & 8) {
      const y = e.vnode.dynamicProps;
      for (let I = 0; I < y.length; I++) {
        let q = y[I];
        if (Jc(e.emitsOptions, q))
          continue;
        const A = l[q];
        if (h)
          if (Tn(o, q))
            A !== o[q] && (o[q] = A, x = !0);
          else {
            const R = gl(q);
            s[R] = om(
              h,
              d,
              R,
              A,
              e,
              !1
            );
          }
        else
          A !== o[q] && (o[q] = A, x = !0);
      }
    }
  } else {
    qh(e, l, s, o) && (x = !0);
    let y;
    for (const I in d)
      (!l || // for camelCase
      !Tn(l, I) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((y = ht(I)) === I || !Tn(l, y))) && (h ? i && // for camelCase
      (i[I] !== void 0 || // for kebab-case
      i[y] !== void 0) && (s[I] = om(
        h,
        d,
        I,
        void 0,
        e,
        !0
      )) : delete s[I]);
    if (o !== d)
      for (const I in o)
        (!l || !Tn(l, I)) && (delete o[I], x = !0);
  }
  x && Ri(e.attrs, "set", "");
}
function qh(e, l, i, a) {
  const [s, o] = e.propsOptions;
  let m = !1, d;
  if (l)
    for (let h in l) {
      if (Aa(h))
        continue;
      const x = l[h];
      let y;
      s && Tn(s, y = gl(h)) ? !o || !o.includes(y) ? i[y] = x : (d || (d = {}))[y] = x : Jc(e.emitsOptions, h) || (!(h in a) || x !== a[h]) && (a[h] = x, m = !0);
    }
  if (o) {
    const h = Ln(i), x = d || On;
    for (let y = 0; y < o.length; y++) {
      const I = o[y];
      i[I] = om(
        s,
        h,
        I,
        x[I],
        e,
        !Tn(x, I)
      );
    }
  }
  return m;
}
function om(e, l, i, a, s, o) {
  const m = e[i];
  if (m != null) {
    const d = Tn(m, "default");
    if (d && a === void 0) {
      const h = m.default;
      if (m.type !== Function && !m.skipFactory && cn(h)) {
        const { propsDefaults: x } = s;
        if (i in x)
          a = x[i];
        else {
          const y = ra(s);
          a = x[i] = h.call(
            null,
            l
          ), y();
        }
      } else
        a = h;
      s.ce && s.ce._setProp(i, a);
    }
    m[
      0
      /* shouldCast */
    ] && (o && !d ? a = !1 : m[
      1
      /* shouldCastTrue */
    ] && (a === "" || a === ht(i)) && (a = !0));
  }
  return a;
}
const Vy = /* @__PURE__ */ new WeakMap();
function Ah(e, l, i = !1) {
  const a = i ? Vy : l.propsCache, s = a.get(e);
  if (s)
    return s;
  const o = e.props, m = {}, d = [];
  let h = !1;
  if (!cn(e)) {
    const y = (I) => {
      h = !0;
      const [q, A] = Ah(I, l, !0);
      kn(m, q), A && d.push(...A);
    };
    !i && l.mixins.length && l.mixins.forEach(y), e.extends && y(e.extends), e.mixins && e.mixins.forEach(y);
  }
  if (!o && !h)
    return _n(e) && a.set(e, Pa), Pa;
  if (Xe(o))
    for (let y = 0; y < o.length; y++) {
      const I = gl(o[y]);
      Yf(I) && (m[I] = On);
    }
  else if (o)
    for (const y in o) {
      const I = gl(y);
      if (Yf(I)) {
        const q = o[y], A = m[I] = Xe(q) || cn(q) ? { type: q } : kn({}, q), R = A.type;
        let V = !1, U = !0;
        if (Xe(R))
          for (let z = 0; z < R.length; ++z) {
            const X = R[z], B = cn(X) && X.name;
            if (B === "Boolean") {
              V = !0;
              break;
            } else B === "String" && (U = !1);
          }
        else
          V = cn(R) && R.name === "Boolean";
        A[
          0
          /* shouldCast */
        ] = V, A[
          1
          /* shouldCastTrue */
        ] = U, (V || Tn(A, "default")) && d.push(I);
      }
    }
  const x = [m, d];
  return _n(e) && a.set(e, x), x;
}
function Yf(e) {
  return e[0] !== "$" && !Aa(e);
}
const rf = (e) => e === "_" || e === "_ctx" || e === "$stable", sf = (e) => Xe(e) ? e.map(pt) : [pt(e)], By = (e, l, i) => {
  if (l._n)
    return l;
  const a = ln((...s) => sf(l(...s)), i);
  return a._c = !1, a;
}, Rh = (e, l, i) => {
  const a = e._ctx;
  for (const s in e) {
    if (rf(s)) continue;
    const o = e[s];
    if (cn(o))
      l[s] = By(s, o, a);
    else if (o != null) {
      const m = sf(o);
      l[s] = () => m;
    }
  }
}, Eh = (e, l) => {
  const i = sf(l);
  e.slots.default = () => i;
}, _h = (e, l, i) => {
  for (const a in l)
    (i || !rf(a)) && (e[a] = l[a]);
}, Zy = (e, l, i) => {
  const a = e.slots = Th();
  if (e.vnode.shapeFlag & 32) {
    const s = l._;
    s ? (_h(a, l, i), i && Ap(a, "_", s, !0)) : Rh(l, a);
  } else l && Eh(e, l);
}, Uy = (e, l, i) => {
  const { vnode: a, slots: s } = e;
  let o = !0, m = On;
  if (a.shapeFlag & 32) {
    const d = l._;
    d ? i && d === 1 ? o = !1 : _h(s, l, i) : (o = !l.$stable, Rh(l, s)), m = l;
  } else l && (Eh(e, l), m = { default: 1 });
  if (o)
    for (const d in s)
      !rf(d) && m[d] == null && delete s[d];
}, hl = jh;
function Nh(e) {
  return Mh(e);
}
function Fh(e) {
  return Mh(e, Qx);
}
function Mh(e, l) {
  const i = kc();
  i.__VUE__ = !0;
  const {
    insert: a,
    remove: s,
    patchProp: o,
    createElement: m,
    createText: d,
    createComment: h,
    setText: x,
    setElementText: y,
    parentNode: I,
    nextSibling: q,
    setScopeId: A = bt,
    insertStaticContent: R
  } = e, V = (j, ue, fe, Te = null, Le = null, we = null, Ne = void 0, _e = null, be = !!ue.dynamicChildren) => {
    if (j === ue)
      return;
    j && !ri(j, ue) && (Te = k(j), ze(j, Le, we, !0), j = null), ue.patchFlag === -2 && (be = !1, ue.dynamicChildren = null);
    const { type: Pe, ref: Ke, shapeFlag: ke } = ue;
    switch (Pe) {
      case Uu:
        U(j, ue, fe, Te);
        break;
      case ul:
        z(j, ue, fe, Te);
        break;
      case ua:
        j == null && X(ue, fe, Te, Ne);
        break;
      case Mn:
        ae(
          j,
          ue,
          fe,
          Te,
          Le,
          we,
          Ne,
          _e,
          be
        );
        break;
      default:
        ke & 1 ? W(
          j,
          ue,
          fe,
          Te,
          Le,
          we,
          Ne,
          _e,
          be
        ) : ke & 6 ? ve(
          j,
          ue,
          fe,
          Te,
          Le,
          we,
          Ne,
          _e,
          be
        ) : (ke & 64 || ke & 128) && Pe.process(
          j,
          ue,
          fe,
          Te,
          Le,
          we,
          Ne,
          _e,
          be,
          ie
        );
    }
    Ke != null && Le ? Na(Ke, j && j.ref, we, ue || j, !ue) : Ke == null && j && j.ref != null && Na(j.ref, null, we, j, !0);
  }, U = (j, ue, fe, Te) => {
    if (j == null)
      a(
        ue.el = d(ue.children),
        fe,
        Te
      );
    else {
      const Le = ue.el = j.el;
      ue.children !== j.children && x(Le, ue.children);
    }
  }, z = (j, ue, fe, Te) => {
    j == null ? a(
      ue.el = h(ue.children || ""),
      fe,
      Te
    ) : ue.el = j.el;
  }, X = (j, ue, fe, Te) => {
    [j.el, j.anchor] = R(
      j.children,
      ue,
      fe,
      Te,
      j.el,
      j.anchor
    );
  }, B = ({ el: j, anchor: ue }, fe, Te) => {
    let Le;
    for (; j && j !== ue; )
      Le = q(j), a(j, fe, Te), j = Le;
    a(ue, fe, Te);
  }, K = ({ el: j, anchor: ue }) => {
    let fe;
    for (; j && j !== ue; )
      fe = q(j), s(j), j = fe;
    s(ue);
  }, W = (j, ue, fe, Te, Le, we, Ne, _e, be) => {
    ue.type === "svg" ? Ne = "svg" : ue.type === "math" && (Ne = "mathml"), j == null ? se(
      ue,
      fe,
      Te,
      Le,
      we,
      Ne,
      _e,
      be
    ) : M(
      j,
      ue,
      Le,
      we,
      Ne,
      _e,
      be
    );
  }, se = (j, ue, fe, Te, Le, we, Ne, _e) => {
    let be, Pe;
    const { props: Ke, shapeFlag: ke, transition: Ze, dirs: Ue } = j;
    if (be = j.el = m(
      j.type,
      we,
      Ke && Ke.is,
      Ke
    ), ke & 8 ? y(be, j.children) : ke & 16 && me(
      j.children,
      be,
      null,
      Te,
      Le,
      So(j, we),
      Ne,
      _e
    ), Ue && Li(j, null, Te, "created"), te(be, j, j.scopeId, Ne, Te), Ke) {
      for (const yn in Ke)
        yn !== "value" && !Aa(yn) && o(be, yn, null, Ke[yn], we, Te);
      "value" in Ke && o(be, "value", null, Ke.value, we), (Pe = Ke.onVnodeBeforeMount) && dt(Pe, Te, j);
    }
    Ue && Li(j, null, Te, "beforeMount");
    const Je = kh(Le, Ze);
    Je && Ze.beforeEnter(be), a(be, ue, fe), ((Pe = Ke && Ke.onVnodeMounted) || Je || Ue) && hl(() => {
      Pe && dt(Pe, Te, j), Je && Ze.enter(be), Ue && Li(j, null, Te, "mounted");
    }, Le);
  }, te = (j, ue, fe, Te, Le) => {
    if (fe && A(j, fe), Te)
      for (let we = 0; we < Te.length; we++)
        A(j, Te[we]);
    if (Le) {
      let we = Le.subTree;
      if (ue === we || yc(we.type) && (we.ssContent === ue || we.ssFallback === ue)) {
        const Ne = Le.vnode;
        te(
          j,
          Ne,
          Ne.scopeId,
          Ne.slotScopeIds,
          Le.parent
        );
      }
    }
  }, me = (j, ue, fe, Te, Le, we, Ne, _e, be = 0) => {
    for (let Pe = be; Pe < j.length; Pe++) {
      const Ke = j[Pe] = _e ? ku(j[Pe]) : pt(j[Pe]);
      V(
        null,
        Ke,
        ue,
        fe,
        Te,
        Le,
        we,
        Ne,
        _e
      );
    }
  }, M = (j, ue, fe, Te, Le, we, Ne) => {
    const _e = ue.el = j.el;
    let { patchFlag: be, dynamicChildren: Pe, dirs: Ke } = ue;
    be |= j.patchFlag & 16;
    const ke = j.props || On, Ze = ue.props || On;
    let Ue;
    if (fe && Xu(fe, !1), (Ue = Ze.onVnodeBeforeUpdate) && dt(Ue, fe, ue, j), Ke && Li(ue, j, fe, "beforeUpdate"), fe && Xu(fe, !0), (ke.innerHTML && Ze.innerHTML == null || ke.textContent && Ze.textContent == null) && y(_e, ""), Pe ? ce(
      j.dynamicChildren,
      Pe,
      _e,
      fe,
      Te,
      So(ue, Le),
      we
    ) : Ne || de(
      j,
      ue,
      _e,
      null,
      fe,
      Te,
      So(ue, Le),
      we,
      !1
    ), be > 0) {
      if (be & 16)
        Ie(_e, ke, Ze, fe, Le);
      else if (be & 2 && ke.class !== Ze.class && o(_e, "class", null, Ze.class, Le), be & 4 && o(_e, "style", ke.style, Ze.style, Le), be & 8) {
        const Je = ue.dynamicProps;
        for (let yn = 0; yn < Je.length; yn++) {
          const on = Je[yn], Bn = ke[on], Cn = Ze[on];
          (Cn !== Bn || on === "value") && o(_e, on, Bn, Cn, Le, fe);
        }
      }
      be & 1 && j.children !== ue.children && y(_e, ue.children);
    } else !Ne && Pe == null && Ie(_e, ke, Ze, fe, Le);
    ((Ue = Ze.onVnodeUpdated) || Ke) && hl(() => {
      Ue && dt(Ue, fe, ue, j), Ke && Li(ue, j, fe, "updated");
    }, Te);
  }, ce = (j, ue, fe, Te, Le, we, Ne) => {
    for (let _e = 0; _e < ue.length; _e++) {
      const be = j[_e], Pe = ue[_e], Ke = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        be.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (be.type === Mn || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !ri(be, Pe) || // - In the case of a component, it could contain anything.
        be.shapeFlag & 198) ? I(be.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fe
        )
      );
      V(
        be,
        Pe,
        Ke,
        null,
        Te,
        Le,
        we,
        Ne,
        !0
      );
    }
  }, Ie = (j, ue, fe, Te, Le) => {
    if (ue !== fe) {
      if (ue !== On)
        for (const we in ue)
          !Aa(we) && !(we in fe) && o(
            j,
            we,
            ue[we],
            null,
            Le,
            Te
          );
      for (const we in fe) {
        if (Aa(we)) continue;
        const Ne = fe[we], _e = ue[we];
        Ne !== _e && we !== "value" && o(j, we, _e, Ne, Le, Te);
      }
      "value" in fe && o(j, "value", ue.value, fe.value, Le);
    }
  }, ae = (j, ue, fe, Te, Le, we, Ne, _e, be) => {
    const Pe = ue.el = j ? j.el : d(""), Ke = ue.anchor = j ? j.anchor : d("");
    let { patchFlag: ke, dynamicChildren: Ze, slotScopeIds: Ue } = ue;
    Ue && (_e = _e ? _e.concat(Ue) : Ue), j == null ? (a(Pe, fe, Te), a(Ke, fe, Te), me(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      ue.children || [],
      fe,
      Ke,
      Le,
      we,
      Ne,
      _e,
      be
    )) : ke > 0 && ke & 64 && Ze && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    j.dynamicChildren ? (ce(
      j.dynamicChildren,
      Ze,
      fe,
      Le,
      we,
      Ne,
      _e
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (ue.key != null || Le && ue === Le.subTree) && cf(
      j,
      ue,
      !0
      /* shallow */
    )) : de(
      j,
      ue,
      fe,
      Ke,
      Le,
      we,
      Ne,
      _e,
      be
    );
  }, ve = (j, ue, fe, Te, Le, we, Ne, _e, be) => {
    ue.slotScopeIds = _e, j == null ? ue.shapeFlag & 512 ? Le.ctx.activate(
      ue,
      fe,
      Te,
      Ne,
      be
    ) : ye(
      ue,
      fe,
      Te,
      Le,
      we,
      Ne,
      be
    ) : Se(j, ue, be);
  }, ye = (j, ue, fe, Te, Le, we, Ne) => {
    const _e = j.component = Yh(
      j,
      Te,
      Le
    );
    if (vs(j) && (_e.ctx.renderer = ie), Qh(_e, !1, Ne), _e.asyncDep) {
      if (Le && Le.registerDep(_e, ge, Ne), !j.el) {
        const be = _e.subTree = je(ul);
        z(null, be, ue, fe), j.placeholder = be.el;
      }
    } else
      ge(
        _e,
        j,
        ue,
        fe,
        Le,
        we,
        Ne
      );
  }, Se = (j, ue, fe) => {
    const Te = ue.component = j.component;
    if (Xy(j, ue, fe))
      if (Te.asyncDep && !Te.asyncResolved) {
        oe(Te, ue, fe);
        return;
      } else
        Te.next = ue, Te.update();
    else
      ue.el = j.el, Te.vnode = ue;
  }, ge = (j, ue, fe, Te, Le, we, Ne) => {
    const _e = () => {
      if (j.isMounted) {
        let { next: ke, bu: Ze, u: Ue, parent: Je, vnode: yn } = j;
        {
          const Nn = Vh(j);
          if (Nn) {
            ke && (ke.el = yn.el, oe(j, ke, Ne)), Nn.asyncDep.then(() => {
              j.isUnmounted || _e();
            });
            return;
          }
        }
        let on = ke, Bn;
        Xu(j, !1), ke ? (ke.el = yn.el, oe(j, ke, Ne)) : ke = yn, Ze && Ea(Ze), (Bn = ke.props && ke.props.onVnodeBeforeUpdate) && dt(Bn, Je, ke, yn), Xu(j, !0);
        const Cn = lc(j), Dn = j.subTree;
        j.subTree = Cn, V(
          Dn,
          Cn,
          // parent may have changed if it's in a teleport
          I(Dn.el),
          // anchor may have changed if it's in a fragment
          k(Dn),
          j,
          Le,
          we
        ), ke.el = Cn.el, on === null && eo(j, Cn.el), Ue && hl(Ue, Le), (Bn = ke.props && ke.props.onVnodeUpdated) && hl(
          () => dt(Bn, Je, ke, yn),
          Le
        );
      } else {
        let ke;
        const { el: Ze, props: Ue } = ue, { bm: Je, m: yn, parent: on, root: Bn, type: Cn } = j, Dn = Zu(ue);
        if (Xu(j, !1), Je && Ea(Je), !Dn && (ke = Ue && Ue.onVnodeBeforeMount) && dt(ke, on, ue), Xu(j, !0), Ze && Oe) {
          const Nn = () => {
            j.subTree = lc(j), Oe(
              Ze,
              j.subTree,
              j,
              Le,
              null
            );
          };
          Dn && Cn.__asyncHydrate ? Cn.__asyncHydrate(
            Ze,
            j,
            Nn
          ) : Nn();
        } else {
          Bn.ce && // @ts-expect-error _def is private
          Bn.ce._def.shadowRoot !== !1 && Bn.ce._injectChildStyle(Cn);
          const Nn = j.subTree = lc(j);
          V(
            null,
            Nn,
            fe,
            Te,
            j,
            Le,
            we
          ), ue.el = Nn.el;
        }
        if (yn && hl(yn, Le), !Dn && (ke = Ue && Ue.onVnodeMounted)) {
          const Nn = ue;
          hl(
            () => dt(ke, on, Nn),
            Le
          );
        }
        (ue.shapeFlag & 256 || on && Zu(on.vnode) && on.vnode.shapeFlag & 256) && j.a && hl(j.a, Le), j.isMounted = !0, ue = fe = Te = null;
      }
    };
    j.scope.on();
    const be = j.effect = new Jr(_e);
    j.scope.off();
    const Pe = j.update = be.run.bind(be), Ke = j.job = be.runIfDirty.bind(be);
    Ke.i = j, Ke.id = j.uid, be.scheduler = () => Ym(Ke), Xu(j, !0), Pe();
  }, oe = (j, ue, fe) => {
    ue.component = j;
    const Te = j.vnode.props;
    j.vnode = ue, j.next = null, ky(j, ue.props, Te, fe), Uy(j, ue.children, fe), ki(), kf(j), Vi();
  }, de = (j, ue, fe, Te, Le, we, Ne, _e, be = !1) => {
    const Pe = j && j.children, Ke = j ? j.shapeFlag : 0, ke = ue.children, { patchFlag: Ze, shapeFlag: Ue } = ue;
    if (Ze > 0) {
      if (Ze & 128) {
        Ee(
          Pe,
          ke,
          fe,
          Te,
          Le,
          we,
          Ne,
          _e,
          be
        );
        return;
      } else if (Ze & 256) {
        De(
          Pe,
          ke,
          fe,
          Te,
          Le,
          we,
          Ne,
          _e,
          be
        );
        return;
      }
    }
    Ue & 8 ? (Ke & 16 && tn(Pe, Le, we), ke !== Pe && y(fe, ke)) : Ke & 16 ? Ue & 16 ? Ee(
      Pe,
      ke,
      fe,
      Te,
      Le,
      we,
      Ne,
      _e,
      be
    ) : tn(Pe, Le, we, !0) : (Ke & 8 && y(fe, ""), Ue & 16 && me(
      ke,
      fe,
      Te,
      Le,
      we,
      Ne,
      _e,
      be
    ));
  }, De = (j, ue, fe, Te, Le, we, Ne, _e, be) => {
    j = j || Pa, ue = ue || Pa;
    const Pe = j.length, Ke = ue.length, ke = Math.min(Pe, Ke);
    let Ze;
    for (Ze = 0; Ze < ke; Ze++) {
      const Ue = ue[Ze] = be ? ku(ue[Ze]) : pt(ue[Ze]);
      V(
        j[Ze],
        Ue,
        fe,
        null,
        Le,
        we,
        Ne,
        _e,
        be
      );
    }
    Pe > Ke ? tn(
      j,
      Le,
      we,
      !0,
      !1,
      ke
    ) : me(
      ue,
      fe,
      Te,
      Le,
      we,
      Ne,
      _e,
      be,
      ke
    );
  }, Ee = (j, ue, fe, Te, Le, we, Ne, _e, be) => {
    let Pe = 0;
    const Ke = ue.length;
    let ke = j.length - 1, Ze = Ke - 1;
    for (; Pe <= ke && Pe <= Ze; ) {
      const Ue = j[Pe], Je = ue[Pe] = be ? ku(ue[Pe]) : pt(ue[Pe]);
      if (ri(Ue, Je))
        V(
          Ue,
          Je,
          fe,
          null,
          Le,
          we,
          Ne,
          _e,
          be
        );
      else
        break;
      Pe++;
    }
    for (; Pe <= ke && Pe <= Ze; ) {
      const Ue = j[ke], Je = ue[Ze] = be ? ku(ue[Ze]) : pt(ue[Ze]);
      if (ri(Ue, Je))
        V(
          Ue,
          Je,
          fe,
          null,
          Le,
          we,
          Ne,
          _e,
          be
        );
      else
        break;
      ke--, Ze--;
    }
    if (Pe > ke) {
      if (Pe <= Ze) {
        const Ue = Ze + 1, Je = Ue < Ke ? ue[Ue].el : Te;
        for (; Pe <= Ze; )
          V(
            null,
            ue[Pe] = be ? ku(ue[Pe]) : pt(ue[Pe]),
            fe,
            Je,
            Le,
            we,
            Ne,
            _e,
            be
          ), Pe++;
      }
    } else if (Pe > Ze)
      for (; Pe <= ke; )
        ze(j[Pe], Le, we, !0), Pe++;
    else {
      const Ue = Pe, Je = Pe, yn = /* @__PURE__ */ new Map();
      for (Pe = Je; Pe <= Ze; Pe++) {
        const re = ue[Pe] = be ? ku(ue[Pe]) : pt(ue[Pe]);
        re.key != null && yn.set(re.key, Pe);
      }
      let on, Bn = 0;
      const Cn = Ze - Je + 1;
      let Dn = !1, Nn = 0;
      const yl = new Array(Cn);
      for (Pe = 0; Pe < Cn; Pe++) yl[Pe] = 0;
      for (Pe = Ue; Pe <= ke; Pe++) {
        const re = j[Pe];
        if (Bn >= Cn) {
          ze(re, Le, we, !0);
          continue;
        }
        let Fn;
        if (re.key != null)
          Fn = yn.get(re.key);
        else
          for (on = Je; on <= Ze; on++)
            if (yl[on - Je] === 0 && ri(re, ue[on])) {
              Fn = on;
              break;
            }
        Fn === void 0 ? ze(re, Le, we, !0) : (yl[Fn - Je] = Pe + 1, Fn >= Nn ? Nn = Fn : Dn = !0, V(
          re,
          ue[Fn],
          fe,
          null,
          Le,
          we,
          Ne,
          _e,
          be
        ), Bn++);
      }
      const An = Dn ? Ky(yl) : Pa;
      for (on = An.length - 1, Pe = Cn - 1; Pe >= 0; Pe--) {
        const re = Je + Pe, Fn = ue[re], Zn = ue[re + 1], Il = re + 1 < Ke ? (
          // #13559, fallback to el placeholder for unresolved async component
          Zn.el || Zn.placeholder
        ) : Te;
        yl[Pe] === 0 ? V(
          null,
          Fn,
          fe,
          Il,
          Le,
          we,
          Ne,
          _e,
          be
        ) : Dn && (on < 0 || Pe !== An[on] ? Ye(Fn, fe, Il, 2) : on--);
      }
    }
  }, Ye = (j, ue, fe, Te, Le = null) => {
    const { el: we, type: Ne, transition: _e, children: be, shapeFlag: Pe } = j;
    if (Pe & 6) {
      Ye(j.component.subTree, ue, fe, Te);
      return;
    }
    if (Pe & 128) {
      j.suspense.move(ue, fe, Te);
      return;
    }
    if (Pe & 64) {
      Ne.move(j, ue, fe, ie);
      return;
    }
    if (Ne === Mn) {
      a(we, ue, fe);
      for (let ke = 0; ke < be.length; ke++)
        Ye(be[ke], ue, fe, Te);
      a(j.anchor, ue, fe);
      return;
    }
    if (Ne === ua) {
      B(j, ue, fe);
      return;
    }
    if (Te !== 2 && Pe & 1 && _e)
      if (Te === 0)
        _e.beforeEnter(we), a(we, ue, fe), hl(() => _e.enter(we), Le);
      else {
        const { leave: ke, delayLeave: Ze, afterLeave: Ue } = _e, Je = () => {
          j.ctx.isUnmounted ? s(we) : a(we, ue, fe);
        }, yn = () => {
          we._isLeaving && we[qi](
            !0
            /* cancelled */
          ), ke(we, () => {
            Je(), Ue && Ue();
          });
        };
        Ze ? Ze(we, Je, yn) : yn();
      }
    else
      a(we, ue, fe);
  }, ze = (j, ue, fe, Te = !1, Le = !1) => {
    const {
      type: we,
      props: Ne,
      ref: _e,
      children: be,
      dynamicChildren: Pe,
      shapeFlag: Ke,
      patchFlag: ke,
      dirs: Ze,
      cacheIndex: Ue
    } = j;
    if (ke === -2 && (Le = !1), _e != null && (ki(), Na(_e, null, fe, j, !0), Vi()), Ue != null && (ue.renderCache[Ue] = void 0), Ke & 256) {
      ue.ctx.deactivate(j);
      return;
    }
    const Je = Ke & 1 && Ze, yn = !Zu(j);
    let on;
    if (yn && (on = Ne && Ne.onVnodeBeforeUnmount) && dt(on, ue, j), Ke & 6)
      xn(j.component, fe, Te);
    else {
      if (Ke & 128) {
        j.suspense.unmount(fe, Te);
        return;
      }
      Je && Li(j, null, ue, "beforeUnmount"), Ke & 64 ? j.type.remove(
        j,
        ue,
        fe,
        ie,
        Te
      ) : Pe && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !Pe.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (we !== Mn || ke > 0 && ke & 64) ? tn(
        Pe,
        ue,
        fe,
        !1,
        !0
      ) : (we === Mn && ke & 384 || !Le && Ke & 16) && tn(be, ue, fe), Te && un(j);
    }
    (yn && (on = Ne && Ne.onVnodeUnmounted) || Je) && hl(() => {
      on && dt(on, ue, j), Je && Li(j, null, ue, "unmounted");
    }, fe);
  }, un = (j) => {
    const { type: ue, el: fe, anchor: Te, transition: Le } = j;
    if (ue === Mn) {
      Pn(fe, Te);
      return;
    }
    if (ue === ua) {
      K(j);
      return;
    }
    const we = () => {
      s(fe), Le && !Le.persisted && Le.afterLeave && Le.afterLeave();
    };
    if (j.shapeFlag & 1 && Le && !Le.persisted) {
      const { leave: Ne, delayLeave: _e } = Le, be = () => Ne(fe, we);
      _e ? _e(j.el, we, be) : be();
    } else
      we();
  }, Pn = (j, ue) => {
    let fe;
    for (; j !== ue; )
      fe = q(j), s(j), j = fe;
    s(ue);
  }, xn = (j, ue, fe) => {
    const { bum: Te, scope: Le, job: we, subTree: Ne, um: _e, m: be, a: Pe } = j;
    xc(be), xc(Pe), Te && Ea(Te), Le.stop(), we && (we.flags |= 8, ze(Ne, j, ue, fe)), _e && hl(_e, ue), hl(() => {
      j.isUnmounted = !0;
    }, ue);
  }, tn = (j, ue, fe, Te = !1, Le = !1, we = 0) => {
    for (let Ne = we; Ne < j.length; Ne++)
      ze(j[Ne], ue, fe, Te, Le);
  }, k = (j) => {
    if (j.shapeFlag & 6)
      return k(j.component.subTree);
    if (j.shapeFlag & 128)
      return j.suspense.next();
    const ue = q(j.anchor || j.el), fe = ue && ue[uh];
    return fe ? q(fe) : ue;
  };
  let _ = !1;
  const Z = (j, ue, fe) => {
    j == null ? ue._vnode && ze(ue._vnode, null, null, !0) : V(
      ue._vnode || null,
      j,
      ue,
      null,
      null,
      null,
      fe
    ), ue._vnode = j, _ || (_ = !0, kf(), hc(), _ = !1);
  }, ie = {
    p: V,
    um: ze,
    m: Ye,
    r: un,
    mt: ye,
    mc: me,
    pc: de,
    pbc: ce,
    n: k,
    o: e
  };
  let Qe, Oe;
  return l && ([Qe, Oe] = l(
    ie
  )), {
    render: Z,
    hydrate: Qe,
    createApp: Fy(Z, Qe)
  };
}
function So({ type: e, props: l }, i) {
  return i === "svg" && e === "foreignObject" || i === "mathml" && e === "annotation-xml" && l && l.encoding && l.encoding.includes("html") ? void 0 : i;
}
function Xu({ effect: e, job: l }, i) {
  i ? (e.flags |= 32, l.flags |= 4) : (e.flags &= -33, l.flags &= -5);
}
function kh(e, l) {
  return (!e || e && !e.pendingBranch) && l && !l.persisted;
}
function cf(e, l, i = !1) {
  const a = e.children, s = l.children;
  if (Xe(a) && Xe(s))
    for (let o = 0; o < a.length; o++) {
      const m = a[o];
      let d = s[o];
      d.shapeFlag & 1 && !d.dynamicChildren && ((d.patchFlag <= 0 || d.patchFlag === 32) && (d = s[o] = ku(s[o]), d.el = m.el), !i && d.patchFlag !== -2 && cf(m, d)), d.type === Uu && // avoid cached text nodes retaining detached dom nodes
      d.patchFlag !== -1 && (d.el = m.el), d.type === ul && !d.el && (d.el = m.el);
    }
}
function Ky(e) {
  const l = e.slice(), i = [0];
  let a, s, o, m, d;
  const h = e.length;
  for (a = 0; a < h; a++) {
    const x = e[a];
    if (x !== 0) {
      if (s = i[i.length - 1], e[s] < x) {
        l[a] = s, i.push(a);
        continue;
      }
      for (o = 0, m = i.length - 1; o < m; )
        d = o + m >> 1, e[i[d]] < x ? o = d + 1 : m = d;
      x < e[i[o]] && (o > 0 && (l[a] = i[o - 1]), i[o] = a);
    }
  }
  for (o = i.length, m = i[o - 1]; o-- > 0; )
    i[o] = m, m = l[m];
  return i;
}
function Vh(e) {
  const l = e.subTree.component;
  if (l)
    return l.asyncDep && !l.asyncResolved ? l : Vh(l);
}
function xc(e) {
  if (e)
    for (let l = 0; l < e.length; l++)
      e[l].flags |= 8;
}
const Bh = Symbol.for("v-scx"), Zh = () => Fi(Bh);
function Ml(e, l) {
  return Ls(e, null, l);
}
function of(e, l) {
  return Ls(
    e,
    null,
    { flush: "post" }
  );
}
function mf(e, l) {
  return Ls(
    e,
    null,
    { flush: "sync" }
  );
}
function Sn(e, l, i) {
  return Ls(e, l, i);
}
function Ls(e, l, i = On) {
  const { immediate: a, deep: s, flush: o, once: m } = i, d = kn({}, i), h = l && a || !l && o !== "post";
  let x;
  if (Va) {
    if (o === "sync") {
      const A = Zh();
      x = A.__watcherHandles || (A.__watcherHandles = []);
    } else if (!h) {
      const A = () => {
      };
      return A.stop = bt, A.resume = bt, A.pause = bt, A;
    }
  }
  const y = Al;
  d.call = (A, R, V) => Ct(A, y, R, V);
  let I = !1;
  o === "post" ? d.scheduler = (A) => {
    hl(A, y && y.suspense);
  } : o !== "sync" && (I = !0, d.scheduler = (A, R) => {
    R ? A() : Ym(A);
  }), d.augmentJob = (A) => {
    l && (A.flags |= 4), I && (A.flags |= 2, y && (A.id = y.uid, A.i = y));
  };
  const q = Nx(e, l, d);
  return Va && (x ? x.push(q) : h && q()), q;
}
function Gy(e, l, i) {
  const a = this.proxy, s = Wn(e) ? e.includes(".") ? Uh(a, e) : () => a[e] : e.bind(a, a);
  let o;
  cn(l) ? o = l : (o = l.handler, i = l);
  const m = ra(this), d = Ls(s, o.bind(a), i);
  return m(), d;
}
function Uh(e, l) {
  const i = l.split(".");
  return () => {
    let a = e;
    for (let s = 0; s < i.length && a; s++)
      a = a[i[s]];
    return a;
  };
}
function zy(e, l, i = On) {
  const a = Xn(), s = gl(l), o = ht(l), m = Kh(e, s), d = Wa((h, x) => {
    let y, I = On, q;
    return mf(() => {
      const A = e[s];
      Vl(y, A) && (y = A, x());
    }), {
      get() {
        return h(), i.get ? i.get(y) : y;
      },
      set(A) {
        const R = i.set ? i.set(A) : A;
        if (!Vl(R, y) && !(I !== On && Vl(A, I)))
          return;
        const V = a.vnode.props;
        V && // check if parent has passed v-model
        (l in V || s in V || o in V) && (`onUpdate:${l}` in V || `onUpdate:${s}` in V || `onUpdate:${o}` in V) || (y = A, x()), a.emit(`update:${l}`, R), Vl(A, R) && Vl(A, I) && !Vl(R, q) && x(), I = A, q = R;
      }
    };
  });
  return d[Symbol.iterator] = () => {
    let h = 0;
    return {
      next() {
        return h < 2 ? { value: h++ ? m || On : d, done: !1 } : { done: !0 };
      }
    };
  }, d;
}
const Kh = (e, l) => l === "modelValue" || l === "model-value" ? e.modelModifiers : e[`${l}Modifiers`] || e[`${gl(l)}Modifiers`] || e[`${ht(l)}Modifiers`];
function jy(e, l, ...i) {
  if (e.isUnmounted) return;
  const a = e.vnode.props || On;
  let s = i;
  const o = l.startsWith("update:"), m = o && Kh(a, l.slice(7));
  m && (m.trim && (s = i.map((y) => Wn(y) ? y.trim() : y)), m.number && (s = i.map(cc)));
  let d, h = a[d = Ra(l)] || // also try camelCase event handler (#2249)
  a[d = Ra(gl(l))];
  !h && o && (h = a[d = Ra(ht(l))]), h && Ct(
    h,
    e,
    6,
    s
  );
  const x = a[d + "Once"];
  if (x) {
    if (!e.emitted)
      e.emitted = {};
    else if (e.emitted[d])
      return;
    e.emitted[d] = !0, Ct(
      x,
      e,
      6,
      s
    );
  }
}
const Hy = /* @__PURE__ */ new WeakMap();
function Gh(e, l, i = !1) {
  const a = i ? Hy : l.emitsCache, s = a.get(e);
  if (s !== void 0)
    return s;
  const o = e.emits;
  let m = {}, d = !1;
  if (!cn(e)) {
    const h = (x) => {
      const y = Gh(x, l, !0);
      y && (d = !0, kn(m, y));
    };
    !i && l.mixins.length && l.mixins.forEach(h), e.extends && h(e.extends), e.mixins && e.mixins.forEach(h);
  }
  return !o && !d ? (_n(e) && a.set(e, null), null) : (Xe(o) ? o.forEach((h) => m[h] = null) : kn(m, o), _n(e) && a.set(e, m), m);
}
function Jc(e, l) {
  return !e || !ps(l) ? !1 : (l = l.slice(2).replace(/Once$/, ""), Tn(e, l[0].toLowerCase() + l.slice(1)) || Tn(e, ht(l)) || Tn(e, l));
}
function lc(e) {
  const {
    type: l,
    vnode: i,
    proxy: a,
    withProxy: s,
    propsOptions: [o],
    slots: m,
    attrs: d,
    emit: h,
    render: x,
    renderCache: y,
    props: I,
    data: q,
    setupState: A,
    ctx: R,
    inheritAttrs: V
  } = e, U = is(e);
  let z, X;
  try {
    if (i.shapeFlag & 4) {
      const K = s || a, W = K;
      z = pt(
        x.call(
          W,
          K,
          y,
          I,
          A,
          q,
          R
        )
      ), X = d;
    } else {
      const K = l;
      z = pt(
        K.length > 1 ? K(
          I,
          { attrs: d, slots: m, emit: h }
        ) : K(
          I,
          null
        )
      ), X = l.props ? d : Wy(d);
    }
  } catch (K) {
    jr.length = 0, fa(K, e, 1), z = je(ul);
  }
  let B = z;
  if (X && V !== !1) {
    const K = Object.keys(X), { shapeFlag: W } = B;
    K.length && W & 7 && (o && K.some(Zm) && (X = Yy(
      X,
      o
    )), B = di(B, X, !1, !0));
  }
  return i.dirs && (B = di(B, null, !1, !0), B.dirs = B.dirs ? B.dirs.concat(i.dirs) : i.dirs), i.transition && Ui(B, i.transition), z = B, is(U), z;
}
function $y(e, l = !0) {
  let i;
  for (let a = 0; a < e.length; a++) {
    const s = e[a];
    if (Ki(s)) {
      if (s.type !== ul || s.children === "v-if") {
        if (i)
          return;
        i = s;
      }
    } else
      return;
  }
  return i;
}
const Wy = (e) => {
  let l;
  for (const i in e)
    (i === "class" || i === "style" || ps(i)) && ((l || (l = {}))[i] = e[i]);
  return l;
}, Yy = (e, l) => {
  const i = {};
  for (const a in e)
    (!Zm(a) || !(a.slice(9) in l)) && (i[a] = e[a]);
  return i;
};
function Xy(e, l, i) {
  const { props: a, children: s, component: o } = e, { props: m, children: d, patchFlag: h } = l, x = o.emitsOptions;
  if (l.dirs || l.transition)
    return !0;
  if (i && h >= 0) {
    if (h & 1024)
      return !0;
    if (h & 16)
      return a ? Xf(a, m, x) : !!m;
    if (h & 8) {
      const y = l.dynamicProps;
      for (let I = 0; I < y.length; I++) {
        const q = y[I];
        if (m[q] !== a[q] && !Jc(x, q))
          return !0;
      }
    }
  } else
    return (s || d) && (!d || !d.$stable) ? !0 : a === m ? !1 : a ? m ? Xf(a, m, x) : !0 : !!m;
  return !1;
}
function Xf(e, l, i) {
  const a = Object.keys(l);
  if (a.length !== Object.keys(e).length)
    return !0;
  for (let s = 0; s < a.length; s++) {
    const o = a[s];
    if (l[o] !== e[o] && !Jc(i, o))
      return !0;
  }
  return !1;
}
function eo({ vnode: e, parent: l }, i) {
  for (; l; ) {
    const a = l.subTree;
    if (a.suspense && a.suspense.activeBranch === e && (a.el = e.el), a === e)
      (e = l.vnode).el = i, l = l.parent;
    else
      break;
  }
}
const yc = (e) => e.__isSuspense;
let mm = 0;
const Qy = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: !0,
  process(e, l, i, a, s, o, m, d, h, x) {
    if (e == null)
      eI(
        l,
        i,
        a,
        s,
        o,
        m,
        d,
        h,
        x
      );
    else {
      if (o && o.deps > 0 && !e.suspense.isInFallback) {
        l.suspense = e.suspense, l.suspense.vnode = l, l.el = e.el;
        return;
      }
      nI(
        e,
        l,
        i,
        a,
        s,
        m,
        d,
        h,
        x
      );
    }
  },
  hydrate: lI,
  normalize: tI
}, Jy = Qy;
function as(e, l) {
  const i = e.props && e.props[l];
  cn(i) && i();
}
function eI(e, l, i, a, s, o, m, d, h) {
  const {
    p: x,
    o: { createElement: y }
  } = h, I = y("div"), q = e.suspense = zh(
    e,
    s,
    a,
    l,
    I,
    i,
    o,
    m,
    d,
    h
  );
  x(
    null,
    q.pendingBranch = e.ssContent,
    I,
    null,
    a,
    q,
    o,
    m
  ), q.deps > 0 ? (as(e, "onPending"), as(e, "onFallback"), x(
    null,
    e.ssFallback,
    l,
    i,
    a,
    null,
    // fallback tree will not have suspense context
    o,
    m
  ), Fa(q, e.ssFallback)) : q.resolve(!1, !0);
}
function nI(e, l, i, a, s, o, m, d, { p: h, um: x, o: { createElement: y } }) {
  const I = l.suspense = e.suspense;
  I.vnode = l, l.el = e.el;
  const q = l.ssContent, A = l.ssFallback, { activeBranch: R, pendingBranch: V, isInFallback: U, isHydrating: z } = I;
  if (V)
    I.pendingBranch = q, ri(V, q) ? (h(
      V,
      q,
      I.hiddenContainer,
      null,
      s,
      I,
      o,
      m,
      d
    ), I.deps <= 0 ? I.resolve() : U && (z || (h(
      R,
      A,
      i,
      a,
      s,
      null,
      // fallback tree will not have suspense context
      o,
      m,
      d
    ), Fa(I, A)))) : (I.pendingId = mm++, z ? (I.isHydrating = !1, I.activeBranch = V) : x(V, s, I), I.deps = 0, I.effects.length = 0, I.hiddenContainer = y("div"), U ? (h(
      null,
      q,
      I.hiddenContainer,
      null,
      s,
      I,
      o,
      m,
      d
    ), I.deps <= 0 ? I.resolve() : (h(
      R,
      A,
      i,
      a,
      s,
      null,
      // fallback tree will not have suspense context
      o,
      m,
      d
    ), Fa(I, A))) : R && ri(R, q) ? (h(
      R,
      q,
      i,
      a,
      s,
      I,
      o,
      m,
      d
    ), I.resolve(!0)) : (h(
      null,
      q,
      I.hiddenContainer,
      null,
      s,
      I,
      o,
      m,
      d
    ), I.deps <= 0 && I.resolve()));
  else if (R && ri(R, q))
    h(
      R,
      q,
      i,
      a,
      s,
      I,
      o,
      m,
      d
    ), Fa(I, q);
  else if (as(l, "onPending"), I.pendingBranch = q, q.shapeFlag & 512 ? I.pendingId = q.component.suspenseId : I.pendingId = mm++, h(
    null,
    q,
    I.hiddenContainer,
    null,
    s,
    I,
    o,
    m,
    d
  ), I.deps <= 0)
    I.resolve();
  else {
    const { timeout: X, pendingId: B } = I;
    X > 0 ? setTimeout(() => {
      I.pendingId === B && I.fallback(A);
    }, X) : X === 0 && I.fallback(A);
  }
}
function zh(e, l, i, a, s, o, m, d, h, x, y = !1) {
  const {
    p: I,
    m: q,
    um: A,
    n: R,
    o: { parentNode: V, remove: U }
  } = x;
  let z;
  const X = iI(e);
  X && l && l.pendingBranch && (z = l.pendingId, l.deps++);
  const B = e.props ? oc(e.props.timeout) : void 0, K = o, W = {
    vnode: e,
    parent: l,
    parentComponent: i,
    namespace: m,
    container: a,
    hiddenContainer: s,
    deps: 0,
    pendingId: mm++,
    timeout: typeof B == "number" ? B : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !y,
    isHydrating: y,
    isUnmounted: !1,
    effects: [],
    resolve(se = !1, te = !1) {
      const {
        vnode: me,
        activeBranch: M,
        pendingBranch: ce,
        pendingId: Ie,
        effects: ae,
        parentComponent: ve,
        container: ye
      } = W;
      let Se = !1;
      W.isHydrating ? W.isHydrating = !1 : se || (Se = M && ce.transition && ce.transition.mode === "out-in", Se && (M.transition.afterLeave = () => {
        Ie === W.pendingId && (q(
          ce,
          ye,
          o === K ? R(M) : o,
          0
        ), ls(ae));
      }), M && (V(M.el) === ye && (o = R(M)), A(M, ve, W, !0)), Se || q(ce, ye, o, 0)), Fa(W, ce), W.pendingBranch = null, W.isInFallback = !1;
      let ge = W.parent, oe = !1;
      for (; ge; ) {
        if (ge.pendingBranch) {
          ge.effects.push(...ae), oe = !0;
          break;
        }
        ge = ge.parent;
      }
      !oe && !Se && ls(ae), W.effects = [], X && l && l.pendingBranch && z === l.pendingId && (l.deps--, l.deps === 0 && !te && l.resolve()), as(me, "onResolve");
    },
    fallback(se) {
      if (!W.pendingBranch)
        return;
      const { vnode: te, activeBranch: me, parentComponent: M, container: ce, namespace: Ie } = W;
      as(te, "onFallback");
      const ae = R(me), ve = () => {
        W.isInFallback && (I(
          null,
          se,
          ce,
          ae,
          M,
          null,
          // fallback tree will not have suspense context
          Ie,
          d,
          h
        ), Fa(W, se));
      }, ye = se.transition && se.transition.mode === "out-in";
      ye && (me.transition.afterLeave = ve), W.isInFallback = !0, A(
        me,
        M,
        null,
        // no suspense so unmount hooks fire now
        !0
        // shouldRemove
      ), ye || ve();
    },
    move(se, te, me) {
      W.activeBranch && q(W.activeBranch, se, te, me), W.container = se;
    },
    next() {
      return W.activeBranch && R(W.activeBranch);
    },
    registerDep(se, te, me) {
      const M = !!W.pendingBranch;
      M && W.deps++;
      const ce = se.vnode.el;
      se.asyncDep.catch((Ie) => {
        fa(Ie, se, 0);
      }).then((Ie) => {
        if (se.isUnmounted || W.isUnmounted || W.pendingId !== se.suspenseId)
          return;
        se.asyncResolved = !0;
        const { vnode: ae } = se;
        pm(se, Ie, !1), ce && (ae.el = ce);
        const ve = !ce && se.subTree.el;
        te(
          se,
          ae,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          V(ce || se.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          ce ? null : R(se.subTree),
          W,
          m,
          me
        ), ve && U(ve), eo(se, ae.el), M && --W.deps === 0 && W.resolve();
      });
    },
    unmount(se, te) {
      W.isUnmounted = !0, W.activeBranch && A(
        W.activeBranch,
        i,
        se,
        te
      ), W.pendingBranch && A(
        W.pendingBranch,
        i,
        se,
        te
      );
    }
  };
  return W;
}
function lI(e, l, i, a, s, o, m, d, h) {
  const x = l.suspense = zh(
    l,
    a,
    i,
    e.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    s,
    o,
    m,
    d,
    !0
  ), y = h(
    e,
    x.pendingBranch = l.ssContent,
    i,
    x,
    o,
    m
  );
  return x.deps === 0 && x.resolve(!1, !0), y;
}
function tI(e) {
  const { shapeFlag: l, children: i } = e, a = l & 32;
  e.ssContent = Qf(
    a ? i.default : i
  ), e.ssFallback = a ? Qf(i.fallback) : je(ul);
}
function Qf(e) {
  let l;
  if (cn(e)) {
    const i = aa && e._c;
    i && (e._d = !1, We()), e = e(), i && (e._d = !0, l = Nl, Hh());
  }
  return Xe(e) && (e = $y(e)), e = pt(e), l && !e.dynamicChildren && (e.dynamicChildren = l.filter((i) => i !== e)), e;
}
function jh(e, l) {
  l && l.pendingBranch ? Xe(e) ? l.effects.push(...e) : l.effects.push(e) : ls(e);
}
function Fa(e, l) {
  e.activeBranch = l;
  const { vnode: i, parentComponent: a } = e;
  let s = l.el;
  for (; !s && l.component; )
    l = l.component.subTree, s = l.el;
  i.el = s, a && a.subTree === i && (a.vnode.el = s, eo(a, s));
}
function iI(e) {
  const l = e.props && e.props.suspensible;
  return l != null && l !== !1;
}
const Mn = Symbol.for("v-fgt"), Uu = Symbol.for("v-txt"), ul = Symbol.for("v-cmt"), ua = Symbol.for("v-stc"), jr = [];
let Nl = null;
function We(e = !1) {
  jr.push(Nl = e ? null : []);
}
function Hh() {
  jr.pop(), Nl = jr[jr.length - 1] || null;
}
let aa = 1;
function rs(e, l = !1) {
  aa += e, e < 0 && Nl && l && (Nl.hasOnce = !0);
}
function $h(e) {
  return e.dynamicChildren = aa > 0 ? Nl || Pa : null, Hh(), aa > 0 && Nl && Nl.push(e), e;
}
function Yn(e, l, i, a, s, o) {
  return $h(
    fn(
      e,
      l,
      i,
      a,
      s,
      o,
      !0
    )
  );
}
function vn(e, l, i, a, s) {
  return $h(
    je(
      e,
      l,
      i,
      a,
      s,
      !0
    )
  );
}
function Ki(e) {
  return e ? e.__v_isVNode === !0 : !1;
}
function ri(e, l) {
  return e.type === l.type && e.key === l.key;
}
function uI(e) {
}
const Wh = ({ key: e }) => e ?? null, tc = ({
  ref: e,
  ref_key: l,
  ref_for: i
}) => (typeof e == "number" && (e = "" + e), e != null ? Wn(e) || Vn(e) || cn(e) ? { i: Rl, r: e, k: l, f: !!i } : e : null);
function fn(e, l = null, i = null, a = 0, s = null, o = e === Mn ? 0 : 1, m = !1, d = !1) {
  const h = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: l,
    key: l && Wh(l),
    ref: l && tc(l),
    scopeId: Hc,
    slotScopeIds: null,
    children: i,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: a,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: Rl
  };
  return d ? (df(h, i), o & 128 && e.normalize(h)) : i && (h.shapeFlag |= Wn(i) ? 8 : 16), aa > 0 && // avoid a block node from tracking itself
  !m && // has current parent block
  Nl && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (h.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  h.patchFlag !== 32 && Nl.push(h), h;
}
const je = aI;
function aI(e, l = null, i = null, a = 0, s = null, o = !1) {
  if ((!e || e === Dh) && (e = ul), Ki(e)) {
    const d = di(
      e,
      l,
      !0
      /* mergeRef: true */
    );
    return i && df(d, i), aa > 0 && !o && Nl && (d.shapeFlag & 6 ? Nl[Nl.indexOf(e)] = d : Nl.push(d)), d.patchFlag = -2, d;
  }
  if (pI(e) && (e = e.__vccOpts), l) {
    l = ff(l);
    let { class: d, style: h } = l;
    d && !Wn(d) && (l.class = Bl(d)), _n(h) && (jc(h) && !Xe(h) && (h = kn({}, h)), l.style = Hi(h));
  }
  const m = Wn(e) ? 1 : yc(e) ? 128 : ah(e) ? 64 : _n(e) ? 4 : cn(e) ? 2 : 0;
  return fn(
    e,
    l,
    i,
    a,
    s,
    m,
    o,
    !0
  );
}
function ff(e) {
  return e ? jc(e) || Ph(e) ? kn({}, e) : e : null;
}
function di(e, l, i = !1, a = !1) {
  const { props: s, ref: o, patchFlag: m, children: d, transition: h } = e, x = l ? pl(s || {}, l) : s, y = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: x,
    key: x && Wh(x),
    ref: l && l.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      i && o ? Xe(o) ? o.concat(tc(l)) : [o, tc(l)] : tc(l)
    ) : o,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: d,
    target: e.target,
    targetStart: e.targetStart,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: l && e.type !== Mn ? m === -1 ? 16 : m | 16 : m,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: h,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && di(e.ssContent),
    ssFallback: e.ssFallback && di(e.ssFallback),
    placeholder: e.placeholder,
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
  return h && a && Ui(
    y,
    h.clone(y)
  ), y;
}
function Gi(e = " ", l = 0) {
  return je(Uu, null, e, l);
}
function rI(e, l) {
  const i = je(ua, null, e);
  return i.staticCount = l, i;
}
function pi(e = "", l = !1) {
  return l ? (We(), vn(ul, null, e)) : je(ul, null, e);
}
function pt(e) {
  return e == null || typeof e == "boolean" ? je(ul) : Xe(e) ? je(
    Mn,
    null,
    // #3666, avoid reference pollution when reusing vnode
    e.slice()
  ) : Ki(e) ? ku(e) : je(Uu, null, String(e));
}
function ku(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : di(e);
}
function df(e, l) {
  let i = 0;
  const { shapeFlag: a } = e;
  if (l == null)
    l = null;
  else if (Xe(l))
    i = 16;
  else if (typeof l == "object")
    if (a & 65) {
      const s = l.default;
      s && (s._c && (s._d = !1), df(e, s()), s._c && (s._d = !0));
      return;
    } else {
      i = 32;
      const s = l._;
      !s && !Ph(l) ? l._ctx = Rl : s === 3 && Rl && (Rl.slots._ === 1 ? l._ = 1 : (l._ = 2, e.patchFlag |= 1024));
    }
  else cn(l) ? (l = { default: l, _ctx: Rl }, i = 32) : (l = String(l), a & 64 ? (i = 16, l = [Gi(l)]) : i = 8);
  e.children = l, e.shapeFlag |= i;
}
function pl(...e) {
  const l = {};
  for (let i = 0; i < e.length; i++) {
    const a = e[i];
    for (const s in a)
      if (s === "class")
        l.class !== a.class && (l.class = Bl([l.class, a.class]));
      else if (s === "style")
        l.style = Hi([l.style, a.style]);
      else if (ps(s)) {
        const o = l[s], m = a[s];
        m && o !== m && !(Xe(o) && o.includes(m)) && (l[s] = o ? [].concat(o, m) : m);
      } else s !== "" && (l[s] = a[s]);
  }
  return l;
}
function dt(e, l, i, a = null) {
  Ct(e, l, 7, [
    i,
    a
  ]);
}
const sI = Sh();
let cI = 0;
function Yh(e, l, i) {
  const a = e.type, s = (l ? l.appContext : e.appContext) || sI, o = {
    uid: cI++,
    vnode: e,
    type: a,
    parent: l,
    appContext: s,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new zm(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: l ? l.provides : Object.create(s.provides),
    ids: l ? l.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Ah(a, s),
    emitsOptions: Gh(a, s),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: On,
    // inheritAttrs
    inheritAttrs: a.inheritAttrs,
    // state
    ctx: On,
    data: On,
    props: On,
    attrs: On,
    slots: On,
    refs: On,
    setupState: On,
    setupContext: null,
    // suspense related
    suspense: i,
    suspenseId: i ? i.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return o.ctx = { _: o }, o.root = l ? l.root : o, o.emit = jy.bind(null, o), e.ce && e.ce(o), o;
}
let Al = null;
const Xn = () => Al || Rl;
let Ic, fm;
{
  const e = kc(), l = (i, a) => {
    let s;
    return (s = e[i]) || (s = e[i] = []), s.push(a), (o) => {
      s.length > 1 ? s.forEach((m) => m(o)) : s[0](o);
    };
  };
  Ic = l(
    "__VUE_INSTANCE_SETTERS__",
    (i) => Al = i
  ), fm = l(
    "__VUE_SSR_SETTERS__",
    (i) => Va = i
  );
}
const ra = (e) => {
  const l = Al;
  return Ic(e), e.scope.on(), () => {
    e.scope.off(), Ic(l);
  };
}, dm = () => {
  Al && Al.scope.off(), Ic(null);
};
function Xh(e) {
  return e.vnode.shapeFlag & 4;
}
let Va = !1;
function Qh(e, l = !1, i = !1) {
  l && fm(l);
  const { props: a, children: s } = e.vnode, o = Xh(e);
  My(e, a, o, l), Zy(e, s, i || l);
  const m = o ? oI(e, l) : void 0;
  return l && fm(!1), m;
}
function oI(e, l) {
  const i = e.type;
  e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = new Proxy(e.ctx, rm);
  const { setup: a } = i;
  if (a) {
    ki();
    const s = e.setupContext = a.length > 1 ? eg(e) : null, o = ra(e), m = Ya(
      a,
      e,
      0,
      [
        e.props,
        s
      ]
    ), d = Km(m);
    if (Vi(), o(), (d || e.sp) && !Zu(e) && Jm(e), d) {
      if (m.then(dm, dm), l)
        return m.then((h) => {
          pm(e, h, l);
        }).catch((h) => {
          fa(h, e, 0);
        });
      e.asyncDep = m;
    } else
      pm(e, m, l);
  } else
    Jh(e, l);
}
function pm(e, l, i) {
  cn(l) ? e.type.__ssrInlineRender ? e.ssrRender = l : e.render = l : _n(l) && (e.setupState = Wm(l)), Jh(e, i);
}
let Lc, hm;
function mI(e) {
  Lc = e, hm = (l) => {
    l.render._rc && (l.withProxy = new Proxy(l.ctx, vy));
  };
}
const fI = () => !Lc;
function Jh(e, l, i) {
  const a = e.type;
  if (!e.render) {
    if (!l && Lc && !a.render) {
      const s = a.template || af(e).template;
      if (s) {
        const { isCustomElement: o, compilerOptions: m } = e.appContext.config, { delimiters: d, compilerOptions: h } = a, x = kn(
          kn(
            {
              isCustomElement: o,
              delimiters: d
            },
            m
          ),
          h
        );
        a.render = Lc(s, x);
      }
    }
    e.render = a.render || bt, hm && hm(e);
  }
  {
    const s = ra(e);
    ki();
    try {
      qy(e);
    } finally {
      Vi(), s();
    }
  }
}
const dI = {
  get(e, l) {
    return _l(e, "get", ""), e[l];
  }
};
function eg(e) {
  const l = (i) => {
    e.exposed = i || {};
  };
  return {
    attrs: new Proxy(e.attrs, dI),
    slots: e.slots,
    emit: e.emit,
    expose: l
  };
}
function Ds(e) {
  return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Wm($a(e.exposed)), {
    get(l, i) {
      if (i in l)
        return l[i];
      if (i in zr)
        return zr[i](e);
    },
    has(l, i) {
      return i in l || i in zr;
    }
  })) : e.proxy;
}
function gm(e, l = !0) {
  return cn(e) ? e.displayName || e.name : e.name || l && e.__name;
}
function pI(e) {
  return cn(e) && "__vccOpts" in e;
}
const Re = (e, l) => Ax(e, l, Va);
function gt(e, l, i) {
  try {
    rs(-1);
    const a = arguments.length;
    return a === 2 ? _n(l) && !Xe(l) ? Ki(l) ? je(e, null, [l]) : je(e, l) : je(e, null, l) : (a > 3 ? i = Array.prototype.slice.call(arguments, 2) : a === 3 && Ki(i) && (i = [i]), je(e, l, i));
  } finally {
    rs(1);
  }
}
function hI() {
}
function ng(e, l, i, a) {
  const s = i[a];
  if (s && lg(s, e))
    return s;
  const o = l();
  return o.memo = e.slice(), o.cacheIndex = a, i[a] = o;
}
function lg(e, l) {
  const i = e.memo;
  if (i.length != l.length)
    return !1;
  for (let a = 0; a < i.length; a++)
    if (Vl(i[a], l[a]))
      return !1;
  return aa > 0 && Nl && Nl.push(e), !0;
}
const tg = "3.5.22", gI = bt, vI = Bx, xI = wa, yI = ih, II = {
  createComponentInstance: Yh,
  setupComponent: Qh,
  renderComponentRoot: lc,
  setCurrentRenderingInstance: is,
  isVNode: Ki,
  normalizeVNode: pt,
  getComponentPublicInstance: Ds,
  ensureValidVNode: uf,
  pushWarningContext: Fx,
  popWarningContext: Mx
}, LI = II, DI = null, OI = null, bI = null;
let vm;
const Jf = typeof window < "u" && window.trustedTypes;
if (Jf)
  try {
    vm = /* @__PURE__ */ Jf.createPolicy("vue", {
      createHTML: (e) => e
    });
  } catch {
  }
const ig = vm ? (e) => vm.createHTML(e) : (e) => e, wI = "http://www.w3.org/2000/svg", SI = "http://www.w3.org/1998/Math/MathML", Pi = typeof document < "u" ? document : null, ed = Pi && /* @__PURE__ */ Pi.createElement("template"), CI = {
  insert: (e, l, i) => {
    l.insertBefore(e, i || null);
  },
  remove: (e) => {
    const l = e.parentNode;
    l && l.removeChild(e);
  },
  createElement: (e, l, i, a) => {
    const s = l === "svg" ? Pi.createElementNS(wI, e) : l === "mathml" ? Pi.createElementNS(SI, e) : i ? Pi.createElement(e, { is: i }) : Pi.createElement(e);
    return e === "select" && a && a.multiple != null && s.setAttribute("multiple", a.multiple), s;
  },
  createText: (e) => Pi.createTextNode(e),
  createComment: (e) => Pi.createComment(e),
  setText: (e, l) => {
    e.nodeValue = l;
  },
  setElementText: (e, l) => {
    e.textContent = l;
  },
  parentNode: (e) => e.parentNode,
  nextSibling: (e) => e.nextSibling,
  querySelector: (e) => Pi.querySelector(e),
  setScopeId(e, l) {
    e.setAttribute(l, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(e, l, i, a, s, o) {
    const m = i ? i.previousSibling : l.lastChild;
    if (s && (s === o || s.nextSibling))
      for (; l.insertBefore(s.cloneNode(!0), i), !(s === o || !(s = s.nextSibling)); )
        ;
    else {
      ed.innerHTML = ig(
        a === "svg" ? `<svg>${e}</svg>` : a === "mathml" ? `<math>${e}</math>` : e
      );
      const d = ed.content;
      if (a === "svg" || a === "mathml") {
        const h = d.firstChild;
        for (; h.firstChild; )
          d.appendChild(h.firstChild);
        d.removeChild(h);
      }
      l.insertBefore(d, i);
    }
    return [
      // first
      m ? m.nextSibling : l.firstChild,
      // last
      i ? i.previousSibling : l.lastChild
    ];
  }
}, Tu = "transition", Sr = "animation", Ba = Symbol("_vtc"), ug = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, ag = /* @__PURE__ */ kn(
  {},
  Qm,
  ug
), TI = (e) => (e.displayName = "Transition", e.props = ag, e), rg = /* @__PURE__ */ TI(
  (e, { slots: l }) => gt(mh, sg(e), l)
), Qu = (e, l = []) => {
  Xe(e) ? e.forEach((i) => i(...l)) : e && e(...l);
}, nd = (e) => e ? Xe(e) ? e.some((l) => l.length > 1) : e.length > 1 : !1;
function sg(e) {
  const l = {};
  for (const ae in e)
    ae in ug || (l[ae] = e[ae]);
  if (e.css === !1)
    return l;
  const {
    name: i = "v",
    type: a,
    duration: s,
    enterFromClass: o = `${i}-enter-from`,
    enterActiveClass: m = `${i}-enter-active`,
    enterToClass: d = `${i}-enter-to`,
    appearFromClass: h = o,
    appearActiveClass: x = m,
    appearToClass: y = d,
    leaveFromClass: I = `${i}-leave-from`,
    leaveActiveClass: q = `${i}-leave-active`,
    leaveToClass: A = `${i}-leave-to`
  } = e, R = PI(s), V = R && R[0], U = R && R[1], {
    onBeforeEnter: z,
    onEnter: X,
    onEnterCancelled: B,
    onLeave: K,
    onLeaveCancelled: W,
    onBeforeAppear: se = z,
    onAppear: te = X,
    onAppearCancelled: me = B
  } = l, M = (ae, ve, ye, Se) => {
    ae._enterCancelled = Se, Eu(ae, ve ? y : d), Eu(ae, ve ? x : m), ye && ye();
  }, ce = (ae, ve) => {
    ae._isLeaving = !1, Eu(ae, I), Eu(ae, A), Eu(ae, q), ve && ve();
  }, Ie = (ae) => (ve, ye) => {
    const Se = ae ? te : X, ge = () => M(ve, ae, ye);
    Qu(Se, [ve, ge]), ld(() => {
      Eu(ve, ae ? h : o), yi(ve, ae ? y : d), nd(Se) || td(ve, a, V, ge);
    });
  };
  return kn(l, {
    onBeforeEnter(ae) {
      Qu(z, [ae]), yi(ae, o), yi(ae, m);
    },
    onBeforeAppear(ae) {
      Qu(se, [ae]), yi(ae, h), yi(ae, x);
    },
    onEnter: Ie(!1),
    onAppear: Ie(!0),
    onLeave(ae, ve) {
      ae._isLeaving = !0;
      const ye = () => ce(ae, ve);
      yi(ae, I), ae._enterCancelled ? (yi(ae, q), xm(ae)) : (xm(ae), yi(ae, q)), ld(() => {
        ae._isLeaving && (Eu(ae, I), yi(ae, A), nd(K) || td(ae, a, U, ye));
      }), Qu(K, [ae, ye]);
    },
    onEnterCancelled(ae) {
      M(ae, !1, void 0, !0), Qu(B, [ae]);
    },
    onAppearCancelled(ae) {
      M(ae, !0, void 0, !0), Qu(me, [ae]);
    },
    onLeaveCancelled(ae) {
      ce(ae), Qu(W, [ae]);
    }
  });
}
function PI(e) {
  if (e == null)
    return null;
  if (_n(e))
    return [Co(e.enter), Co(e.leave)];
  {
    const l = Co(e);
    return [l, l];
  }
}
function Co(e) {
  return oc(e);
}
function yi(e, l) {
  l.split(/\s+/).forEach((i) => i && e.classList.add(i)), (e[Ba] || (e[Ba] = /* @__PURE__ */ new Set())).add(l);
}
function Eu(e, l) {
  l.split(/\s+/).forEach((a) => a && e.classList.remove(a));
  const i = e[Ba];
  i && (i.delete(l), i.size || (e[Ba] = void 0));
}
function ld(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e);
  });
}
let qI = 0;
function td(e, l, i, a) {
  const s = e._endId = ++qI, o = () => {
    s === e._endId && a();
  };
  if (i != null)
    return setTimeout(o, i);
  const { type: m, timeout: d, propCount: h } = cg(e, l);
  if (!m)
    return a();
  const x = m + "end";
  let y = 0;
  const I = () => {
    e.removeEventListener(x, q), o();
  }, q = (A) => {
    A.target === e && ++y >= h && I();
  };
  setTimeout(() => {
    y < h && I();
  }, d + 1), e.addEventListener(x, q);
}
function cg(e, l) {
  const i = window.getComputedStyle(e), a = (R) => (i[R] || "").split(", "), s = a(`${Tu}Delay`), o = a(`${Tu}Duration`), m = id(s, o), d = a(`${Sr}Delay`), h = a(`${Sr}Duration`), x = id(d, h);
  let y = null, I = 0, q = 0;
  l === Tu ? m > 0 && (y = Tu, I = m, q = o.length) : l === Sr ? x > 0 && (y = Sr, I = x, q = h.length) : (I = Math.max(m, x), y = I > 0 ? m > x ? Tu : Sr : null, q = y ? y === Tu ? o.length : h.length : 0);
  const A = y === Tu && /\b(?:transform|all)(?:,|$)/.test(
    a(`${Tu}Property`).toString()
  );
  return {
    type: y,
    timeout: I,
    propCount: q,
    hasTransform: A
  };
}
function id(e, l) {
  for (; e.length < l.length; )
    e = e.concat(e);
  return Math.max(...l.map((i, a) => ud(i) + ud(e[a])));
}
function ud(e) {
  return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3;
}
function xm(e) {
  return (e ? e.ownerDocument : document).body.offsetHeight;
}
function AI(e, l, i) {
  const a = e[Ba];
  a && (l = (l ? [l, ...a] : [...a]).join(" ")), l == null ? e.removeAttribute("class") : i ? e.setAttribute("class", l) : e.className = l;
}
const Dc = Symbol("_vod"), og = Symbol("_vsh"), mg = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(e, { value: l }, { transition: i }) {
    e[Dc] = e.style.display === "none" ? "" : e.style.display, i && l ? i.beforeEnter(e) : Cr(e, l);
  },
  mounted(e, { value: l }, { transition: i }) {
    i && l && i.enter(e);
  },
  updated(e, { value: l, oldValue: i }, { transition: a }) {
    !l != !i && (a ? l ? (a.beforeEnter(e), Cr(e, !0), a.enter(e)) : a.leave(e, () => {
      Cr(e, !1);
    }) : Cr(e, l));
  },
  beforeUnmount(e, { value: l }) {
    Cr(e, l);
  }
};
function Cr(e, l) {
  e.style.display = l ? e[Dc] : "none", e[og] = !l;
}
function RI() {
  mg.getSSRProps = ({ value: e }) => {
    if (!e)
      return { style: { display: "none" } };
  };
}
const fg = Symbol("");
function EI(e) {
  const l = Xn();
  if (!l)
    return;
  const i = l.ut = (s = e(l.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${l.uid}"]`)
    ).forEach((o) => Oc(o, s));
  }, a = () => {
    const s = e(l.proxy);
    l.ce ? Oc(l.ce, s) : ym(l.subTree, s), i(s);
  };
  nf(() => {
    ls(a);
  }), vl(() => {
    Sn(a, bt, { flush: "post" });
    const s = new MutationObserver(a);
    s.observe(l.subTree.el.parentNode, { childList: !0 }), Dt(() => s.disconnect());
  });
}
function ym(e, l) {
  if (e.shapeFlag & 128) {
    const i = e.suspense;
    e = i.activeBranch, i.pendingBranch && !i.isHydrating && i.effects.push(() => {
      ym(i.activeBranch, l);
    });
  }
  for (; e.component; )
    e = e.component.subTree;
  if (e.shapeFlag & 1 && e.el)
    Oc(e.el, l);
  else if (e.type === Mn)
    e.children.forEach((i) => ym(i, l));
  else if (e.type === ua) {
    let { el: i, anchor: a } = e;
    for (; i && (Oc(i, l), i !== a); )
      i = i.nextSibling;
  }
}
function Oc(e, l) {
  if (e.nodeType === 1) {
    const i = e.style;
    let a = "";
    for (const s in l) {
      const o = lx(l[s]);
      i.setProperty(`--${s}`, o), a += `--${s}: ${o};`;
    }
    i[fg] = a;
  }
}
const _I = /(?:^|;)\s*display\s*:/;
function NI(e, l, i) {
  const a = e.style, s = Wn(i);
  let o = !1;
  if (i && !s) {
    if (l)
      if (Wn(l))
        for (const m of l.split(";")) {
          const d = m.slice(0, m.indexOf(":")).trim();
          i[d] == null && ic(a, d, "");
        }
      else
        for (const m in l)
          i[m] == null && ic(a, m, "");
    for (const m in i)
      m === "display" && (o = !0), ic(a, m, i[m]);
  } else if (s) {
    if (l !== i) {
      const m = a[fg];
      m && (i += ";" + m), a.cssText = i, o = _I.test(i);
    }
  } else l && e.removeAttribute("style");
  Dc in e && (e[Dc] = o ? a.display : "", e[og] && (a.display = "none"));
}
const ad = /\s*!important$/;
function ic(e, l, i) {
  if (Xe(i))
    i.forEach((a) => ic(e, l, a));
  else if (i == null && (i = ""), l.startsWith("--"))
    e.setProperty(l, i);
  else {
    const a = FI(e, l);
    ad.test(i) ? e.setProperty(
      ht(a),
      i.replace(ad, ""),
      "important"
    ) : e[a] = i;
  }
}
const rd = ["Webkit", "Moz", "ms"], To = {};
function FI(e, l) {
  const i = To[l];
  if (i)
    return i;
  let a = gl(l);
  if (a !== "filter" && a in e)
    return To[l] = a;
  a = hs(a);
  for (let s = 0; s < rd.length; s++) {
    const o = rd[s] + a;
    if (o in e)
      return To[l] = o;
  }
  return l;
}
const sd = "http://www.w3.org/1999/xlink";
function cd(e, l, i, a, s, o = ex(l)) {
  a && l.startsWith("xlink:") ? i == null ? e.removeAttributeNS(sd, l.slice(6, l.length)) : e.setAttributeNS(sd, l, i) : i == null || o && !Rp(i) ? e.removeAttribute(l) : e.setAttribute(
    l,
    o ? "" : fi(i) ? String(i) : i
  );
}
function od(e, l, i, a, s) {
  if (l === "innerHTML" || l === "textContent") {
    i != null && (e[l] = l === "innerHTML" ? ig(i) : i);
    return;
  }
  const o = e.tagName;
  if (l === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const d = o === "OPTION" ? e.getAttribute("value") || "" : e.value, h = i == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      e.type === "checkbox" ? "on" : ""
    ) : String(i);
    (d !== h || !("_value" in e)) && (e.value = h), i == null && e.removeAttribute(l), e._value = i;
    return;
  }
  let m = !1;
  if (i === "" || i == null) {
    const d = typeof e[l];
    d === "boolean" ? i = Rp(i) : i == null && d === "string" ? (i = "", m = !0) : d === "number" && (i = 0, m = !0);
  }
  try {
    e[l] = i;
  } catch {
  }
  m && e.removeAttribute(s || l);
}
function _i(e, l, i, a) {
  e.addEventListener(l, i, a);
}
function MI(e, l, i, a) {
  e.removeEventListener(l, i, a);
}
const md = Symbol("_vei");
function kI(e, l, i, a, s = null) {
  const o = e[md] || (e[md] = {}), m = o[l];
  if (a && m)
    m.value = a;
  else {
    const [d, h] = VI(l);
    if (a) {
      const x = o[l] = UI(
        a,
        s
      );
      _i(e, d, x, h);
    } else m && (MI(e, d, m, h), o[l] = void 0);
  }
}
const fd = /(?:Once|Passive|Capture)$/;
function VI(e) {
  let l;
  if (fd.test(e)) {
    l = {};
    let a;
    for (; a = e.match(fd); )
      e = e.slice(0, e.length - a[0].length), l[a[0].toLowerCase()] = !0;
  }
  return [e[2] === ":" ? e.slice(3) : ht(e.slice(2)), l];
}
let Po = 0;
const BI = /* @__PURE__ */ Promise.resolve(), ZI = () => Po || (BI.then(() => Po = 0), Po = Date.now());
function UI(e, l) {
  const i = (a) => {
    if (!a._vts)
      a._vts = Date.now();
    else if (a._vts <= i.attached)
      return;
    Ct(
      KI(a, i.value),
      l,
      5,
      [a]
    );
  };
  return i.value = e, i.attached = ZI(), i;
}
function KI(e, l) {
  if (Xe(l)) {
    const i = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      i.call(e), e._stopped = !0;
    }, l.map(
      (a) => (s) => !s._stopped && a && a(s)
    );
  } else
    return l;
}
const dd = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // lowercase letter
e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, GI = (e, l, i, a, s, o) => {
  const m = s === "svg";
  l === "class" ? AI(e, a, m) : l === "style" ? NI(e, i, a) : ps(l) ? Zm(l) || kI(e, l, i, a, o) : (l[0] === "." ? (l = l.slice(1), !0) : l[0] === "^" ? (l = l.slice(1), !1) : zI(e, l, a, m)) ? (od(e, l, a), !e.tagName.includes("-") && (l === "value" || l === "checked" || l === "selected") && cd(e, l, a, m, o, l !== "value")) : /* #11081 force set props for possible async custom element */ e._isVueCE && (/[A-Z]/.test(l) || !Wn(a)) ? od(e, gl(l), a, o, l) : (l === "true-value" ? e._trueValue = a : l === "false-value" && (e._falseValue = a), cd(e, l, a, m));
};
function zI(e, l, i, a) {
  if (a)
    return !!(l === "innerHTML" || l === "textContent" || l in e && dd(l) && cn(i));
  if (l === "spellcheck" || l === "draggable" || l === "translate" || l === "autocorrect" || l === "form" || l === "list" && e.tagName === "INPUT" || l === "type" && e.tagName === "TEXTAREA")
    return !1;
  if (l === "width" || l === "height") {
    const s = e.tagName;
    if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE")
      return !1;
  }
  return dd(l) && Wn(i) ? !1 : l in e;
}
const pd = {};
// @__NO_SIDE_EFFECTS__
function dg(e, l, i) {
  let a = /* @__PURE__ */ dn(e, l);
  Fc(a) && (a = kn({}, a, l));
  class s extends no {
    constructor(m) {
      super(a, m, i);
    }
  }
  return s.def = a, s;
}
const jI = /* @__NO_SIDE_EFFECTS__ */ (e, l) => /* @__PURE__ */ dg(e, l, wg), HI = typeof HTMLElement < "u" ? HTMLElement : class {
};
class no extends HI {
  constructor(l, i = {}, a = Sc) {
    super(), this._def = l, this._props = i, this._createApp = a, this._isVueCE = !0, this._instance = null, this._app = null, this._nonce = this._def.nonce, this._connected = !1, this._resolved = !1, this._numberProps = null, this._styleChildren = /* @__PURE__ */ new WeakSet(), this._ob = null, this.shadowRoot && a !== Sc ? this._root = this.shadowRoot : l.shadowRoot !== !1 ? (this.attachShadow(
      kn({}, l.shadowRootOptions, {
        mode: "open"
      })
    ), this._root = this.shadowRoot) : this._root = this;
  }
  connectedCallback() {
    if (!this.isConnected) return;
    !this.shadowRoot && !this._resolved && this._parseSlots(), this._connected = !0;
    let l = this;
    for (; l = l && (l.parentNode || l.host); )
      if (l instanceof no) {
        this._parent = l;
        break;
      }
    this._instance || (this._resolved ? this._mount(this._def) : l && l._pendingResolve ? this._pendingResolve = l._pendingResolve.then(() => {
      this._pendingResolve = void 0, this._resolveDef();
    }) : this._resolveDef());
  }
  _setParent(l = this._parent) {
    l && (this._instance.parent = l._instance, this._inheritParentContext(l));
  }
  _inheritParentContext(l = this._parent) {
    l && this._app && Object.setPrototypeOf(
      this._app._context.provides,
      l._instance.provides
    );
  }
  disconnectedCallback() {
    this._connected = !1, il(() => {
      this._connected || (this._ob && (this._ob.disconnect(), this._ob = null), this._app && this._app.unmount(), this._instance && (this._instance.ce = void 0), this._app = this._instance = null, this._teleportTargets && (this._teleportTargets.clear(), this._teleportTargets = void 0));
    });
  }
  _processMutations(l) {
    for (const i of l)
      this._setAttr(i.attributeName);
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    if (this._pendingResolve)
      return;
    for (let a = 0; a < this.attributes.length; a++)
      this._setAttr(this.attributes[a].name);
    this._ob = new MutationObserver(this._processMutations.bind(this)), this._ob.observe(this, { attributes: !0 });
    const l = (a, s = !1) => {
      this._resolved = !0, this._pendingResolve = void 0;
      const { props: o, styles: m } = a;
      let d;
      if (o && !Xe(o))
        for (const h in o) {
          const x = o[h];
          (x === Number || x && x.type === Number) && (h in this._props && (this._props[h] = oc(this._props[h])), (d || (d = /* @__PURE__ */ Object.create(null)))[gl(h)] = !0);
        }
      this._numberProps = d, this._resolveProps(a), this.shadowRoot && this._applyStyles(m), this._mount(a);
    }, i = this._def.__asyncLoader;
    i ? this._pendingResolve = i().then((a) => {
      a.configureApp = this._def.configureApp, l(this._def = a, !0);
    }) : l(this._def);
  }
  _mount(l) {
    this._app = this._createApp(l), this._inheritParentContext(), l.configureApp && l.configureApp(this._app), this._app._ceVNode = this._createVNode(), this._app.mount(this._root);
    const i = this._instance && this._instance.exposed;
    if (i)
      for (const a in i)
        Tn(this, a) || Object.defineProperty(this, a, {
          // unwrap ref to be consistent with public instance behavior
          get: () => le(i[a])
        });
  }
  _resolveProps(l) {
    const { props: i } = l, a = Xe(i) ? i : Object.keys(i || {});
    for (const s of Object.keys(this))
      s[0] !== "_" && a.includes(s) && this._setProp(s, this[s]);
    for (const s of a.map(gl))
      Object.defineProperty(this, s, {
        get() {
          return this._getProp(s);
        },
        set(o) {
          this._setProp(s, o, !0, !0);
        }
      });
  }
  _setAttr(l) {
    if (l.startsWith("data-v-")) return;
    const i = this.hasAttribute(l);
    let a = i ? this.getAttribute(l) : pd;
    const s = gl(l);
    i && this._numberProps && this._numberProps[s] && (a = oc(a)), this._setProp(s, a, !1, !0);
  }
  /**
   * @internal
   */
  _getProp(l) {
    return this._props[l];
  }
  /**
   * @internal
   */
  _setProp(l, i, a = !0, s = !1) {
    if (i !== this._props[l] && (i === pd ? delete this._props[l] : (this._props[l] = i, l === "key" && this._app && (this._app._ceVNode.key = i)), s && this._instance && this._update(), a)) {
      const o = this._ob;
      o && (this._processMutations(o.takeRecords()), o.disconnect()), i === !0 ? this.setAttribute(ht(l), "") : typeof i == "string" || typeof i == "number" ? this.setAttribute(ht(l), i + "") : i || this.removeAttribute(ht(l)), o && o.observe(this, { attributes: !0 });
    }
  }
  _update() {
    const l = this._createVNode();
    this._app && (l.appContext = this._app._context), bg(l, this._root);
  }
  _createVNode() {
    const l = {};
    this.shadowRoot || (l.onVnodeMounted = l.onVnodeUpdated = this._renderSlots.bind(this));
    const i = je(this._def, kn(l, this._props));
    return this._instance || (i.ce = (a) => {
      this._instance = a, a.ce = this, a.isCE = !0;
      const s = (o, m) => {
        this.dispatchEvent(
          new CustomEvent(
            o,
            Fc(m[0]) ? kn({ detail: m }, m[0]) : { detail: m }
          )
        );
      };
      a.emit = (o, ...m) => {
        s(o, m), ht(o) !== o && s(ht(o), m);
      }, this._setParent();
    }), i;
  }
  _applyStyles(l, i) {
    if (!l) return;
    if (i) {
      if (i === this._def || this._styleChildren.has(i))
        return;
      this._styleChildren.add(i);
    }
    const a = this._nonce;
    for (let s = l.length - 1; s >= 0; s--) {
      const o = document.createElement("style");
      a && o.setAttribute("nonce", a), o.textContent = l[s], this.shadowRoot.prepend(o);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _parseSlots() {
    const l = this._slots = {};
    let i;
    for (; i = this.firstChild; ) {
      const a = i.nodeType === 1 && i.getAttribute("slot") || "default";
      (l[a] || (l[a] = [])).push(i), this.removeChild(i);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _renderSlots() {
    const l = this._getSlots(), i = this._instance.type.__scopeId;
    for (let a = 0; a < l.length; a++) {
      const s = l[a], o = s.getAttribute("name") || "default", m = this._slots[o], d = s.parentNode;
      if (m)
        for (const h of m) {
          if (i && h.nodeType === 1) {
            const x = i + "-s", y = document.createTreeWalker(h, 1);
            h.setAttribute(x, "");
            let I;
            for (; I = y.nextNode(); )
              I.setAttribute(x, "");
          }
          d.insertBefore(h, s);
        }
      else
        for (; s.firstChild; ) d.insertBefore(s.firstChild, s);
      d.removeChild(s);
    }
  }
  /**
   * @internal
   */
  _getSlots() {
    const l = [this];
    return this._teleportTargets && l.push(...this._teleportTargets), l.reduce((i, a) => (i.push(...Array.from(a.querySelectorAll("slot"))), i), []);
  }
  /**
   * @internal
   */
  _injectChildStyle(l) {
    this._applyStyles(l.styles, l);
  }
  /**
   * @internal
   */
  _removeChildStyle(l) {
  }
}
function pg(e) {
  const l = Xn(), i = l && l.ce;
  return i || null;
}
function $I() {
  const e = pg();
  return e && e.shadowRoot;
}
function WI(e = "$style") {
  {
    const l = Xn();
    if (!l)
      return On;
    const i = l.type.__cssModules;
    if (!i)
      return On;
    const a = i[e];
    return a || On;
  }
}
const hg = /* @__PURE__ */ new WeakMap(), gg = /* @__PURE__ */ new WeakMap(), bc = Symbol("_moveCb"), hd = Symbol("_enterCb"), YI = (e) => (delete e.props.mode, e), XI = /* @__PURE__ */ YI({
  name: "TransitionGroup",
  props: /* @__PURE__ */ kn({}, ag, {
    tag: String,
    moveClass: String
  }),
  setup(e, { slots: l }) {
    const i = Xn(), a = Xm();
    let s, o;
    return Yc(() => {
      if (!s.length)
        return;
      const m = e.moveClass || `${e.name || "v"}-move`;
      if (!lL(
        s[0].el,
        i.vnode.el,
        m
      )) {
        s = [];
        return;
      }
      s.forEach(JI), s.forEach(eL);
      const d = s.filter(nL);
      xm(i.vnode.el), d.forEach((h) => {
        const x = h.el, y = x.style;
        yi(x, m), y.transform = y.webkitTransform = y.transitionDuration = "";
        const I = x[bc] = (q) => {
          q && q.target !== x || (!q || q.propertyName.endsWith("transform")) && (x.removeEventListener("transitionend", I), x[bc] = null, Eu(x, m));
        };
        x.addEventListener("transitionend", I);
      }), s = [];
    }), () => {
      const m = Ln(e), d = sg(m);
      let h = m.tag || Mn;
      if (s = [], o)
        for (let x = 0; x < o.length; x++) {
          const y = o[x];
          y.el && y.el instanceof Element && (s.push(y), Ui(
            y,
            ka(
              y,
              d,
              a,
              i
            )
          ), hg.set(
            y,
            y.el.getBoundingClientRect()
          ));
        }
      o = l.default ? $c(l.default()) : [];
      for (let x = 0; x < o.length; x++) {
        const y = o[x];
        y.key != null && Ui(
          y,
          ka(y, d, a, i)
        );
      }
      return je(h, null, o);
    };
  }
}), QI = XI;
function JI(e) {
  const l = e.el;
  l[bc] && l[bc](), l[hd] && l[hd]();
}
function eL(e) {
  gg.set(e, e.el.getBoundingClientRect());
}
function nL(e) {
  const l = hg.get(e), i = gg.get(e), a = l.left - i.left, s = l.top - i.top;
  if (a || s) {
    const o = e.el.style;
    return o.transform = o.webkitTransform = `translate(${a}px,${s}px)`, o.transitionDuration = "0s", e;
  }
}
function lL(e, l, i) {
  const a = e.cloneNode(), s = e[Ba];
  s && s.forEach((d) => {
    d.split(/\s+/).forEach((h) => h && a.classList.remove(h));
  }), i.split(/\s+/).forEach((d) => d && a.classList.add(d)), a.style.display = "none";
  const o = l.nodeType === 1 ? l : l.parentNode;
  o.appendChild(a);
  const { hasTransform: m } = cg(a);
  return o.removeChild(a), m;
}
const Gu = (e) => {
  const l = e.props["onUpdate:modelValue"] || !1;
  return Xe(l) ? (i) => Ea(l, i) : l;
};
function tL(e) {
  e.target.composing = !0;
}
function gd(e) {
  const l = e.target;
  l.composing && (l.composing = !1, l.dispatchEvent(new Event("input")));
}
const wt = Symbol("_assign"), wc = {
  created(e, { modifiers: { lazy: l, trim: i, number: a } }, s) {
    e[wt] = Gu(s);
    const o = a || s.props && s.props.type === "number";
    _i(e, l ? "change" : "input", (m) => {
      if (m.target.composing) return;
      let d = e.value;
      i && (d = d.trim()), o && (d = cc(d)), e[wt](d);
    }), i && _i(e, "change", () => {
      e.value = e.value.trim();
    }), l || (_i(e, "compositionstart", tL), _i(e, "compositionend", gd), _i(e, "change", gd));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(e, { value: l }) {
    e.value = l ?? "";
  },
  beforeUpdate(e, { value: l, oldValue: i, modifiers: { lazy: a, trim: s, number: o } }, m) {
    if (e[wt] = Gu(m), e.composing) return;
    const d = (o || e.type === "number") && !/^0\d/.test(e.value) ? cc(e.value) : e.value, h = l ?? "";
    d !== h && (document.activeElement === e && e.type !== "range" && (a && l === i || s && e.value.trim() === h) || (e.value = h));
  }
}, pf = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(e, l, i) {
    e[wt] = Gu(i), _i(e, "change", () => {
      const a = e._modelValue, s = Za(e), o = e.checked, m = e[wt];
      if (Xe(a)) {
        const d = Bc(a, s), h = d !== -1;
        if (o && !h)
          m(a.concat(s));
        else if (!o && h) {
          const x = [...a];
          x.splice(d, 1), m(x);
        }
      } else if (oa(a)) {
        const d = new Set(a);
        o ? d.add(s) : d.delete(s), m(d);
      } else
        m(xg(e, o));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: vd,
  beforeUpdate(e, l, i) {
    e[wt] = Gu(i), vd(e, l, i);
  }
};
function vd(e, { value: l, oldValue: i }, a) {
  e._modelValue = l;
  let s;
  if (Xe(l))
    s = Bc(l, a.props.value) > -1;
  else if (oa(l))
    s = l.has(a.props.value);
  else {
    if (l === i) return;
    s = Ku(l, xg(e, !0));
  }
  e.checked !== s && (e.checked = s);
}
const hf = {
  created(e, { value: l }, i) {
    e.checked = Ku(l, i.props.value), e[wt] = Gu(i), _i(e, "change", () => {
      e[wt](Za(e));
    });
  },
  beforeUpdate(e, { value: l, oldValue: i }, a) {
    e[wt] = Gu(a), l !== i && (e.checked = Ku(l, a.props.value));
  }
}, vg = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(e, { value: l, modifiers: { number: i } }, a) {
    const s = oa(l);
    _i(e, "change", () => {
      const o = Array.prototype.filter.call(e.options, (m) => m.selected).map(
        (m) => i ? cc(Za(m)) : Za(m)
      );
      e[wt](
        e.multiple ? s ? new Set(o) : o : o[0]
      ), e._assigning = !0, il(() => {
        e._assigning = !1;
      });
    }), e[wt] = Gu(a);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(e, { value: l }) {
    xd(e, l);
  },
  beforeUpdate(e, l, i) {
    e[wt] = Gu(i);
  },
  updated(e, { value: l }) {
    e._assigning || xd(e, l);
  }
};
function xd(e, l) {
  const i = e.multiple, a = Xe(l);
  if (!(i && !a && !oa(l))) {
    for (let s = 0, o = e.options.length; s < o; s++) {
      const m = e.options[s], d = Za(m);
      if (i)
        if (a) {
          const h = typeof d;
          h === "string" || h === "number" ? m.selected = l.some((x) => String(x) === String(d)) : m.selected = Bc(l, d) > -1;
        } else
          m.selected = l.has(d);
      else if (Ku(Za(m), l)) {
        e.selectedIndex !== s && (e.selectedIndex = s);
        return;
      }
    }
    !i && e.selectedIndex !== -1 && (e.selectedIndex = -1);
  }
}
function Za(e) {
  return "_value" in e ? e._value : e.value;
}
function xg(e, l) {
  const i = l ? "_trueValue" : "_falseValue";
  return i in e ? e[i] : l;
}
const yg = {
  created(e, l, i) {
    Bs(e, l, i, null, "created");
  },
  mounted(e, l, i) {
    Bs(e, l, i, null, "mounted");
  },
  beforeUpdate(e, l, i, a) {
    Bs(e, l, i, a, "beforeUpdate");
  },
  updated(e, l, i, a) {
    Bs(e, l, i, a, "updated");
  }
};
function Ig(e, l) {
  switch (e) {
    case "SELECT":
      return vg;
    case "TEXTAREA":
      return wc;
    default:
      switch (l) {
        case "checkbox":
          return pf;
        case "radio":
          return hf;
        default:
          return wc;
      }
  }
}
function Bs(e, l, i, a, s) {
  const m = Ig(
    e.tagName,
    i.props && i.props.type
  )[s];
  m && m(e, l, i, a);
}
function iL() {
  wc.getSSRProps = ({ value: e }) => ({ value: e }), hf.getSSRProps = ({ value: e }, l) => {
    if (l.props && Ku(l.props.value, e))
      return { checked: !0 };
  }, pf.getSSRProps = ({ value: e }, l) => {
    if (Xe(e)) {
      if (l.props && Bc(e, l.props.value) > -1)
        return { checked: !0 };
    } else if (oa(e)) {
      if (l.props && e.has(l.props.value))
        return { checked: !0 };
    } else if (e)
      return { checked: !0 };
  }, yg.getSSRProps = (e, l) => {
    if (typeof l.type != "string")
      return;
    const i = Ig(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      l.type.toUpperCase(),
      l.props && l.props.type
    );
    if (i.getSSRProps)
      return i.getSSRProps(e, l);
  };
}
const uL = ["ctrl", "shift", "alt", "meta"], aL = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, l) => uL.some((i) => e[`${i}Key`] && !l.includes(i))
}, si = (e, l) => {
  const i = e._withMods || (e._withMods = {}), a = l.join(".");
  return i[a] || (i[a] = (s, ...o) => {
    for (let m = 0; m < l.length; m++) {
      const d = aL[l[m]];
      if (d && d(s, l)) return;
    }
    return e(s, ...o);
  });
}, rL = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, mi = (e, l) => {
  const i = e._withKeys || (e._withKeys = {}), a = l.join(".");
  return i[a] || (i[a] = (s) => {
    if (!("key" in s))
      return;
    const o = ht(s.key);
    if (l.some(
      (m) => m === o || rL[m] === o
    ))
      return e(s);
  });
}, Lg = /* @__PURE__ */ kn({ patchProp: GI }, CI);
let Hr, yd = !1;
function Dg() {
  return Hr || (Hr = Nh(Lg));
}
function Og() {
  return Hr = yd ? Hr : Fh(Lg), yd = !0, Hr;
}
const bg = (...e) => {
  Dg().render(...e);
}, sL = (...e) => {
  Og().hydrate(...e);
}, Sc = (...e) => {
  const l = Dg().createApp(...e), { mount: i } = l;
  return l.mount = (a) => {
    const s = Cg(a);
    if (!s) return;
    const o = l._component;
    !cn(o) && !o.render && !o.template && (o.template = s.innerHTML), s.nodeType === 1 && (s.textContent = "");
    const m = i(s, !1, Sg(s));
    return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), m;
  }, l;
}, wg = (...e) => {
  const l = Og().createApp(...e), { mount: i } = l;
  return l.mount = (a) => {
    const s = Cg(a);
    if (s)
      return i(s, !0, Sg(s));
  }, l;
};
function Sg(e) {
  if (e instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement)
    return "mathml";
}
function Cg(e) {
  return Wn(e) ? document.querySelector(e) : e;
}
let Id = !1;
const cL = () => {
  Id || (Id = !0, iL(), RI());
};
const oL = () => {
}, mL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition: mh,
  BaseTransitionPropsValidators: Qm,
  Comment: ul,
  DeprecationTypes: bI,
  EffectScope: zm,
  ErrorCodes: Vx,
  ErrorTypeStrings: vI,
  Fragment: Mn,
  KeepAlive: oy,
  ReactiveEffect: Jr,
  Static: ua,
  Suspense: Jy,
  Teleport: $x,
  Text: Uu,
  TrackOpTypes: Rx,
  Transition: rg,
  TransitionGroup: QI,
  TriggerOpTypes: Ex,
  VueElement: no,
  assertNumber: kx,
  callWithAsyncErrorHandling: Ct,
  callWithErrorHandling: Ya,
  camelize: gl,
  capitalize: hs,
  cloneVNode: di,
  compatUtils: OI,
  compile: oL,
  computed: Re,
  createApp: Sc,
  createBlock: vn,
  createCommentVNode: pi,
  createElementBlock: Yn,
  createElementVNode: fn,
  createHydrationRenderer: Fh,
  createPropsRestProxy: Ty,
  createRenderer: Nh,
  createSSRApp: wg,
  createSlots: hy,
  createStaticVNode: rI,
  createTextVNode: Gi,
  createVNode: je,
  customRef: Wa,
  defineAsyncComponent: sy,
  defineComponent: dn,
  defineCustomElement: dg,
  defineEmits: yy,
  defineExpose: Iy,
  defineModel: Oy,
  defineOptions: Ly,
  defineProps: xy,
  defineSSRCustomElement: jI,
  defineSlots: Dy,
  devtools: xI,
  effect: ix,
  effectScope: Zc,
  getCurrentInstance: Xn,
  getCurrentScope: $i,
  getCurrentWatcher: _x,
  getTransitionRawChildren: $c,
  guardReactiveProps: ff,
  h: gt,
  handleError: fa,
  hasInjectionContext: Qc,
  hydrate: sL,
  hydrateOnIdle: ly,
  hydrateOnInteraction: ay,
  hydrateOnMediaQuery: uy,
  hydrateOnVisible: iy,
  initCustomFormatter: hI,
  initDirectivesForSSR: cL,
  inject: Fi,
  isMemoSame: lg,
  isProxy: jc,
  isReactive: oi,
  isReadonly: Zi,
  isRef: Vn,
  isRuntimeOnly: fI,
  isShallow: yt,
  isVNode: Ki,
  markRaw: $a,
  mergeDefaults: bh,
  mergeModels: Cy,
  mergeProps: pl,
  nextTick: il,
  normalizeClass: Bl,
  normalizeProps: Vc,
  normalizeStyle: Hi,
  onActivated: ph,
  onBeforeMount: vh,
  onBeforeUnmount: xs,
  onBeforeUpdate: nf,
  onDeactivated: hh,
  onErrorCaptured: Lh,
  onMounted: vl,
  onRenderTracked: Ih,
  onRenderTriggered: yh,
  onScopeDispose: ma,
  onServerPrefetch: xh,
  onUnmounted: Dt,
  onUpdated: Yc,
  onWatcherCleanup: Jp,
  openBlock: We,
  popScopeId: Gx,
  provide: Xc,
  proxyRefs: Wm,
  pushScopeId: Kx,
  queuePostFlushCb: ls,
  reactive: Ha,
  readonly: Bi,
  ref: Fe,
  registerRuntimeCompiler: mI,
  render: bg,
  renderList: Is,
  renderSlot: qn,
  resolveComponent: dy,
  resolveDirective: py,
  resolveDynamicComponent: ys,
  resolveFilter: DI,
  resolveTransitionHooks: ka,
  setBlockTracking: rs,
  setDevtoolsHook: yI,
  setTransitionHooks: Ui,
  shallowReactive: Yp,
  shallowReadonly: Nu,
  shallowRef: Fl,
  ssrContextKey: Bh,
  ssrUtils: LI,
  stop: ux,
  toDisplayString: Ul,
  toHandlerKey: Ra,
  toHandlers: gy,
  toRaw: Ln,
  toRef: gs,
  toRefs: St,
  toValue: hn,
  transformVNodeArgs: uI,
  triggerRef: wx,
  unref: le,
  useAttrs: Sy,
  useCssModule: WI,
  useCssVars: EI,
  useHost: pg,
  useId: dh,
  useModel: zy,
  useSSRContext: Zh,
  useShadowRoot: $I,
  useSlots: wy,
  useTemplateRef: ef,
  useTransitionState: Xm,
  vModelCheckbox: pf,
  vModelDynamic: yg,
  vModelRadio: hf,
  vModelSelect: vg,
  vModelText: wc,
  vShow: mg,
  version: tg,
  warn: gI,
  watch: Sn,
  watchEffect: Ml,
  watchPostEffect: of,
  watchSyncEffect: mf,
  withAsyncContext: Py,
  withCtx: ln,
  withDefaults: by,
  withDirectives: jx,
  withKeys: mi,
  withMemo: ng,
  withModifiers: si,
  withScopeId: zx
}, Symbol.toStringTag, { value: "Module" }));
let Tg;
const lo = (e) => Tg = e, Pg = (
  /* istanbul ignore next */
  Symbol()
);
function Im(e) {
  return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function";
}
var $r;
(function(e) {
  e.direct = "direct", e.patchObject = "patch object", e.patchFunction = "patch function";
})($r || ($r = {}));
function fL() {
  const e = Zc(!0), l = e.run(() => Fe({}));
  let i = [], a = [];
  const s = $a({
    install(o) {
      lo(s), s._a = o, o.provide(Pg, s), o.config.globalProperties.$pinia = s, a.forEach((m) => i.push(m)), a = [];
    },
    use(o) {
      return this._a ? i.push(o) : a.push(o), this;
    },
    _p: i,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: e,
    _s: /* @__PURE__ */ new Map(),
    state: l
  });
  return s;
}
const qg = () => {
};
function Ld(e, l, i, a = qg) {
  e.add(l);
  const s = () => {
    e.delete(l) && a();
  };
  return !i && $i() && ma(s), s;
}
function Ia(e, ...l) {
  e.forEach((i) => {
    i(...l);
  });
}
const dL = (e) => e(), Dd = Symbol(), qo = Symbol();
function Lm(e, l) {
  e instanceof Map && l instanceof Map ? l.forEach((i, a) => e.set(a, i)) : e instanceof Set && l instanceof Set && l.forEach(e.add, e);
  for (const i in l) {
    if (!l.hasOwnProperty(i))
      continue;
    const a = l[i], s = e[i];
    Im(s) && Im(a) && e.hasOwnProperty(i) && !Vn(a) && !oi(a) ? e[i] = Lm(s, a) : e[i] = a;
  }
  return e;
}
const pL = (
  /* istanbul ignore next */
  Symbol()
);
function hL(e) {
  return !Im(e) || !Object.prototype.hasOwnProperty.call(e, pL);
}
const { assign: _u } = Object;
function gL(e) {
  return !!(Vn(e) && e.effect);
}
function vL(e, l, i, a) {
  const { state: s, actions: o, getters: m } = l, d = i.state.value[e];
  let h;
  function x() {
    d || (i.state.value[e] = s ? s() : {});
    const y = St(i.state.value[e]);
    return _u(y, o, Object.keys(m || {}).reduce((I, q) => (I[q] = $a(Re(() => {
      lo(i);
      const A = i._s.get(e);
      return m[q].call(A, A);
    })), I), {}));
  }
  return h = Ag(e, x, l, i, a, !0), h;
}
function Ag(e, l, i = {}, a, s, o) {
  let m;
  const d = _u({ actions: {} }, i), h = { deep: !0 };
  let x, y, I = /* @__PURE__ */ new Set(), q = /* @__PURE__ */ new Set(), A;
  const R = a.state.value[e];
  !o && !R && (a.state.value[e] = {}), Fe({});
  let V;
  function U(me) {
    let M;
    x = y = !1, typeof me == "function" ? (me(a.state.value[e]), M = {
      type: $r.patchFunction,
      storeId: e,
      events: A
    }) : (Lm(a.state.value[e], me), M = {
      type: $r.patchObject,
      payload: me,
      storeId: e,
      events: A
    });
    const ce = V = Symbol();
    il().then(() => {
      V === ce && (x = !0);
    }), y = !0, Ia(I, M, a.state.value[e]);
  }
  const z = o ? function() {
    const { state: M } = i, ce = M ? M() : {};
    this.$patch((Ie) => {
      _u(Ie, ce);
    });
  } : (
    /* istanbul ignore next */
    qg
  );
  function X() {
    m.stop(), I.clear(), q.clear(), a._s.delete(e);
  }
  const B = (me, M = "") => {
    if (Dd in me)
      return me[qo] = M, me;
    const ce = function() {
      lo(a);
      const Ie = Array.from(arguments), ae = /* @__PURE__ */ new Set(), ve = /* @__PURE__ */ new Set();
      function ye(oe) {
        ae.add(oe);
      }
      function Se(oe) {
        ve.add(oe);
      }
      Ia(q, {
        args: Ie,
        name: ce[qo],
        store: W,
        after: ye,
        onError: Se
      });
      let ge;
      try {
        ge = me.apply(this && this.$id === e ? this : W, Ie);
      } catch (oe) {
        throw Ia(ve, oe), oe;
      }
      return ge instanceof Promise ? ge.then((oe) => (Ia(ae, oe), oe)).catch((oe) => (Ia(ve, oe), Promise.reject(oe))) : (Ia(ae, ge), ge);
    };
    return ce[Dd] = !0, ce[qo] = M, ce;
  }, K = {
    _p: a,
    // _s: scope,
    $id: e,
    $onAction: Ld.bind(null, q),
    $patch: U,
    $reset: z,
    $subscribe(me, M = {}) {
      const ce = Ld(I, me, M.detached, () => Ie()), Ie = m.run(() => Sn(() => a.state.value[e], (ae) => {
        (M.flush === "sync" ? y : x) && me({
          storeId: e,
          type: $r.direct,
          events: A
        }, ae);
      }, _u({}, h, M)));
      return ce;
    },
    $dispose: X
  }, W = Ha(K);
  a._s.set(e, W);
  const te = (a._a && a._a.runWithContext || dL)(() => a._e.run(() => (m = Zc()).run(() => l({ action: B }))));
  for (const me in te) {
    const M = te[me];
    if (Vn(M) && !gL(M) || oi(M))
      o || (R && hL(M) && (Vn(M) ? M.value = R[me] : Lm(M, R[me])), a.state.value[e][me] = M);
    else if (typeof M == "function") {
      const ce = B(M, me);
      te[me] = ce, d.actions[me] = M;
    }
  }
  return _u(W, te), _u(Ln(W), te), Object.defineProperty(W, "$state", {
    get: () => a.state.value[e],
    set: (me) => {
      U((M) => {
        _u(M, me);
      });
    }
  }), a._p.forEach((me) => {
    _u(W, m.run(() => me({
      store: W,
      app: a._a,
      pinia: a,
      options: d
    })));
  }), R && o && i.hydrate && i.hydrate(W.$state, R), x = !0, y = !0, W;
}
// @__NO_SIDE_EFFECTS__
function to(e, l, i) {
  let a;
  const s = typeof l == "function";
  a = s ? i : l;
  function o(m, d) {
    const h = Qc();
    return m = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    m || (h ? Fi(Pg, null) : null), m && lo(m), m = Tg, m._s.has(e) || (s ? Ag(e, l, a, m) : vL(e, a, m)), m._s.get(e);
  }
  return o.$id = e, o;
}
function Lt(e) {
  const l = Ln(e), i = {};
  for (const a in l) {
    const s = l[a];
    s.effect ? i[a] = // ...
    Re({
      get: () => e[a],
      set(o) {
        e[a] = o;
      }
    }) : (Vn(s) || oi(s)) && (i[a] = // ---
    gs(e, a));
  }
  return i;
}
var xL = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function yL(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Dm = { exports: {} }, IL = Dm.exports, Od;
function LL() {
  return Od || (Od = 1, function(e, l) {
    (function(i, a) {
      e.exports = a();
    })(IL, function() {
      var i = function(n, t) {
        return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(u, r) {
          u.__proto__ = r;
        } || function(u, r) {
          for (var c in r) Object.prototype.hasOwnProperty.call(r, c) && (u[c] = r[c]);
        })(n, t);
      }, a = function() {
        return (a = Object.assign || function(n) {
          for (var t, u = 1, r = arguments.length; u < r; u++) for (var c in t = arguments[u]) Object.prototype.hasOwnProperty.call(t, c) && (n[c] = t[c]);
          return n;
        }).apply(this, arguments);
      };
      function s(n, t, u) {
        for (var r, c = 0, f = t.length; c < f; c++) !r && c in t || ((r = r || Array.prototype.slice.call(t, 0, c))[c] = t[c]);
        return n.concat(r || Array.prototype.slice.call(t));
      }
      var o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : xL, m = Object.keys, d = Array.isArray;
      function h(n, t) {
        return typeof t != "object" || m(t).forEach(function(u) {
          n[u] = t[u];
        }), n;
      }
      typeof Promise > "u" || o.Promise || (o.Promise = Promise);
      var x = Object.getPrototypeOf, y = {}.hasOwnProperty;
      function I(n, t) {
        return y.call(n, t);
      }
      function q(n, t) {
        typeof t == "function" && (t = t(x(n))), (typeof Reflect > "u" ? m : Reflect.ownKeys)(t).forEach(function(u) {
          R(n, u, t[u]);
        });
      }
      var A = Object.defineProperty;
      function R(n, t, u, r) {
        A(n, t, h(u && I(u, "get") && typeof u.get == "function" ? { get: u.get, set: u.set, configurable: !0 } : { value: u, configurable: !0, writable: !0 }, r));
      }
      function V(n) {
        return { from: function(t) {
          return n.prototype = Object.create(t.prototype), R(n.prototype, "constructor", n), { extend: q.bind(null, n.prototype) };
        } };
      }
      var U = Object.getOwnPropertyDescriptor, z = [].slice;
      function X(n, t, u) {
        return z.call(n, t, u);
      }
      function B(n, t) {
        return t(n);
      }
      function K(n) {
        if (!n) throw new Error("Assertion Failed");
      }
      function W(n) {
        o.setImmediate ? setImmediate(n) : setTimeout(n, 0);
      }
      function se(n, t) {
        if (typeof t == "string" && I(n, t)) return n[t];
        if (!t) return n;
        if (typeof t != "string") {
          for (var u = [], r = 0, c = t.length; r < c; ++r) {
            var f = se(n, t[r]);
            u.push(f);
          }
          return u;
        }
        var p = t.indexOf(".");
        if (p !== -1) {
          var g = n[t.substr(0, p)];
          return g == null ? void 0 : se(g, t.substr(p + 1));
        }
      }
      function te(n, t, u) {
        if (n && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(n))) if (typeof t != "string" && "length" in t) {
          K(typeof u != "string" && "length" in u);
          for (var r = 0, c = t.length; r < c; ++r) te(n, t[r], u[r]);
        } else {
          var f, p, g = t.indexOf(".");
          g !== -1 ? (f = t.substr(0, g), (p = t.substr(g + 1)) === "" ? u === void 0 ? d(n) && !isNaN(parseInt(f)) ? n.splice(f, 1) : delete n[f] : n[f] = u : te(g = !(g = n[f]) || !I(n, f) ? n[f] = {} : g, p, u)) : u === void 0 ? d(n) && !isNaN(parseInt(t)) ? n.splice(t, 1) : delete n[t] : n[t] = u;
        }
      }
      function me(n) {
        var t, u = {};
        for (t in n) I(n, t) && (u[t] = n[t]);
        return u;
      }
      var M = [].concat;
      function ce(n) {
        return M.apply([], n);
      }
      var Ue = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(ce([8, 16, 32, 64].map(function(n) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + n + "Array";
        });
      }))).filter(function(n) {
        return o[n];
      }), Ie = new Set(Ue.map(function(n) {
        return o[n];
      })), ae = null;
      function ve(n) {
        return ae = /* @__PURE__ */ new WeakMap(), n = function t(u) {
          if (!u || typeof u != "object") return u;
          var r = ae.get(u);
          if (r) return r;
          if (d(u)) {
            r = [], ae.set(u, r);
            for (var c = 0, f = u.length; c < f; ++c) r.push(t(u[c]));
          } else if (Ie.has(u.constructor)) r = u;
          else {
            var p, g = x(u);
            for (p in r = g === Object.prototype ? {} : Object.create(g), ae.set(u, r), u) I(u, p) && (r[p] = t(u[p]));
          }
          return r;
        }(n), ae = null, n;
      }
      var ye = {}.toString;
      function Se(n) {
        return ye.call(n).slice(8, -1);
      }
      var ge = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", oe = typeof ge == "symbol" ? function(n) {
        var t;
        return n != null && (t = n[ge]) && t.apply(n);
      } : function() {
        return null;
      };
      function de(n, t) {
        return t = n.indexOf(t), 0 <= t && n.splice(t, 1), 0 <= t;
      }
      var De = {};
      function Ee(n) {
        var t, u, r, c;
        if (arguments.length === 1) {
          if (d(n)) return n.slice();
          if (this === De && typeof n == "string") return [n];
          if (c = oe(n)) {
            for (u = []; !(r = c.next()).done; ) u.push(r.value);
            return u;
          }
          if (n == null) return [n];
          if (typeof (t = n.length) != "number") return [n];
          for (u = new Array(t); t--; ) u[t] = n[t];
          return u;
        }
        for (t = arguments.length, u = new Array(t); t--; ) u[t] = arguments[t];
        return u;
      }
      var Ye = typeof Symbol < "u" ? function(n) {
        return n[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ze = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], In = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ze), ze = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function un(n, t) {
        this.name = n, this.message = t;
      }
      function Pn(n, t) {
        return n + ". Errors: " + Object.keys(t).map(function(u) {
          return t[u].toString();
        }).filter(function(u, r, c) {
          return c.indexOf(u) === r;
        }).join(`
`);
      }
      function xn(n, t, u, r) {
        this.failures = t, this.failedKeys = r, this.successCount = u, this.message = Pn(n, t);
      }
      function tn(n, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(u) {
          return t[u];
        }), this.failuresByPos = t, this.message = Pn(n, this.failures);
      }
      V(un).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), V(xn).from(un), V(tn).from(un);
      var k = In.reduce(function(n, t) {
        return n[t] = t + "Error", n;
      }, {}), _ = un, Z = In.reduce(function(n, t) {
        var u = t + "Error";
        function r(c, f) {
          this.name = u, c ? typeof c == "string" ? (this.message = "".concat(c).concat(f ? `
 ` + f : ""), this.inner = f || null) : typeof c == "object" && (this.message = "".concat(c.name, " ").concat(c.message), this.inner = c) : (this.message = ze[t] || u, this.inner = null);
        }
        return V(r).from(_), n[t] = r, n;
      }, {});
      Z.Syntax = SyntaxError, Z.Type = TypeError, Z.Range = RangeError;
      var ie = Ze.reduce(function(n, t) {
        return n[t + "Error"] = Z[t], n;
      }, {}), Qe = In.reduce(function(n, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (n[t + "Error"] = Z[t]), n;
      }, {});
      function Oe() {
      }
      function j(n) {
        return n;
      }
      function ue(n, t) {
        return n == null || n === j ? t : function(u) {
          return t(n(u));
        };
      }
      function fe(n, t) {
        return function() {
          n.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function Te(n, t) {
        return n === Oe ? t : function() {
          var u = n.apply(this, arguments);
          u !== void 0 && (arguments[0] = u);
          var r = this.onsuccess, c = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var f = t.apply(this, arguments);
          return r && (this.onsuccess = this.onsuccess ? fe(r, this.onsuccess) : r), c && (this.onerror = this.onerror ? fe(c, this.onerror) : c), f !== void 0 ? f : u;
        };
      }
      function Le(n, t) {
        return n === Oe ? t : function() {
          n.apply(this, arguments);
          var u = this.onsuccess, r = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), u && (this.onsuccess = this.onsuccess ? fe(u, this.onsuccess) : u), r && (this.onerror = this.onerror ? fe(r, this.onerror) : r);
        };
      }
      function we(n, t) {
        return n === Oe ? t : function(u) {
          var r = n.apply(this, arguments);
          h(u, r);
          var c = this.onsuccess, f = this.onerror;
          return this.onsuccess = null, this.onerror = null, u = t.apply(this, arguments), c && (this.onsuccess = this.onsuccess ? fe(c, this.onsuccess) : c), f && (this.onerror = this.onerror ? fe(f, this.onerror) : f), r === void 0 ? u === void 0 ? void 0 : u : h(r, u);
        };
      }
      function Ne(n, t) {
        return n === Oe ? t : function() {
          return t.apply(this, arguments) !== !1 && n.apply(this, arguments);
        };
      }
      function _e(n, t) {
        return n === Oe ? t : function() {
          var u = n.apply(this, arguments);
          if (u && typeof u.then == "function") {
            for (var r = this, c = arguments.length, f = new Array(c); c--; ) f[c] = arguments[c];
            return u.then(function() {
              return t.apply(r, f);
            });
          }
          return t.apply(this, arguments);
        };
      }
      Qe.ModifyError = xn, Qe.DexieError = un, Qe.BulkError = tn;
      var be = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function Pe(n) {
        be = n;
      }
      var Ke = {}, ke = 100, Ue = typeof Promise > "u" ? [] : function() {
        var n = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [n, x(n), n];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, x(t), n];
      }(), Ze = Ue[0], In = Ue[1], Ue = Ue[2], In = In && In.then, Je = Ze && Ze.constructor, yn = !!Ue, on = function(n, t) {
        Fn.push([n, t]), Cn && (queueMicrotask(nr), Cn = !1);
      }, Bn = !0, Cn = !0, Dn = [], Nn = [], yl = j, An = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: Oe, pgp: !1, env: {}, finalize: Oe }, re = An, Fn = [], Zn = 0, Il = [];
      function ee(n) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = re;
        if (typeof n != "function") {
          if (n !== Ke) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && qt(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function u(r, c) {
          try {
            c(function(f) {
              if (r._state === null) {
                if (f === r) throw new TypeError("A promise cannot be resolved with itself.");
                var p = r._lib && rl();
                f && typeof f.then == "function" ? u(r, function(g, L) {
                  f instanceof ee ? f._then(g, L) : f.then(g, L);
                }) : (r._state = !0, r._value = f, Xi(r)), p && sl();
              }
            }, qt.bind(null, r));
          } catch (f) {
            qt(r, f);
          }
        }(this, n);
      }
      var Pt = { get: function() {
        var n = re, t = Hl;
        function u(r, c) {
          var f = this, p = !n.global && (n !== re || t !== Hl), g = p && !Kn(), L = new ee(function(O, w) {
            At(f, new Yi(Ji(r, n, p, g), Ji(c, n, p, g), O, w, n));
          });
          return this._consoleTask && (L._consoleTask = this._consoleTask), L;
        }
        return u.prototype = Ke, u;
      }, set: function(n) {
        R(this, "then", n && n.prototype === Ke ? Pt : { get: function() {
          return n;
        }, set: Pt.set });
      } };
      function Yi(n, t, u, r, c) {
        this.onFulfilled = typeof n == "function" ? n : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = u, this.reject = r, this.psd = c;
      }
      function qt(n, t) {
        var u, r;
        Nn.push(t), n._state === null && (u = n._lib && rl(), t = yl(t), n._state = !1, n._value = t, r = n, Dn.some(function(c) {
          return c._value === r._value;
        }) || Dn.push(r), Xi(n), u && sl());
      }
      function Xi(n) {
        var t = n._listeners;
        n._listeners = [];
        for (var u = 0, r = t.length; u < r; ++u) At(n, t[u]);
        var c = n._PSD;
        --c.ref || c.finalize(), Zn === 0 && (++Zn, on(function() {
          --Zn == 0 && Rt();
        }, []));
      }
      function At(n, t) {
        if (n._state !== null) {
          var u = n._state ? t.onFulfilled : t.onRejected;
          if (u === null) return (n._state ? t.resolve : t.reject)(n._value);
          ++t.psd.ref, ++Zn, on(er, [u, n, t]);
        } else n._listeners.push(t);
      }
      function er(n, t, u) {
        try {
          var r, c = t._value;
          !t._state && Nn.length && (Nn = []), r = be && t._consoleTask ? t._consoleTask.run(function() {
            return n(c);
          }) : n(c), t._state || Nn.indexOf(c) !== -1 || function(f) {
            for (var p = Dn.length; p; ) if (Dn[--p]._value === f._value) return Dn.splice(p, 1);
          }(t), u.resolve(r);
        } catch (f) {
          u.reject(f);
        } finally {
          --Zn == 0 && Rt(), --u.psd.ref || u.psd.finalize();
        }
      }
      function nr() {
        Qn(An, function() {
          rl() && sl();
        });
      }
      function rl() {
        var n = Bn;
        return Cn = Bn = !1, n;
      }
      function sl() {
        var n, t, u;
        do
          for (; 0 < Fn.length; ) for (n = Fn, Fn = [], u = n.length, t = 0; t < u; ++t) {
            var r = n[t];
            r[0].apply(null, r[1]);
          }
        while (0 < Fn.length);
        Cn = Bn = !0;
      }
      function Rt() {
        var n = Dn;
        Dn = [], n.forEach(function(r) {
          r._PSD.onunhandled.call(null, r._value, r);
        });
        for (var t = Il.slice(0), u = t.length; u; ) t[--u]();
      }
      function Gl(n) {
        return new ee(Ke, !1, n);
      }
      function Be(n, t) {
        var u = re;
        return function() {
          var r = rl(), c = re;
          try {
            return Gn(u, !0), n.apply(this, arguments);
          } catch (f) {
            t && t(f);
          } finally {
            Gn(c, !1), r && sl();
          }
        };
      }
      q(ee.prototype, { then: Pt, _then: function(n, t) {
        At(this, new Yi(null, null, n, t, re));
      }, catch: function(n) {
        if (arguments.length === 1) return this.then(null, n);
        var t = n, u = arguments[1];
        return typeof t == "function" ? this.then(null, function(r) {
          return (r instanceof t ? u : Gl)(r);
        }) : this.then(null, function(r) {
          return (r && r.name === t ? u : Gl)(r);
        });
      }, finally: function(n) {
        return this.then(function(t) {
          return ee.resolve(n()).then(function() {
            return t;
          });
        }, function(t) {
          return ee.resolve(n()).then(function() {
            return Gl(t);
          });
        });
      }, timeout: function(n, t) {
        var u = this;
        return n < 1 / 0 ? new ee(function(r, c) {
          var f = setTimeout(function() {
            return c(new Z.Timeout(t));
          }, n);
          u.then(r, c).finally(clearTimeout.bind(null, f));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && R(ee.prototype, Symbol.toStringTag, "Dexie.Promise"), An.env = Qi(), q(ee, { all: function() {
        var n = Ee.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.length === 0 && t([]);
          var r = n.length;
          n.forEach(function(c, f) {
            return ee.resolve(c).then(function(p) {
              n[f] = p, --r || t(n);
            }, u);
          });
        });
      }, resolve: function(n) {
        return n instanceof ee ? n : n && typeof n.then == "function" ? new ee(function(t, u) {
          n.then(t, u);
        }) : new ee(Ke, !0, n);
      }, reject: Gl, race: function() {
        var n = Ee.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.map(function(r) {
            return ee.resolve(r).then(t, u);
          });
        });
      }, PSD: { get: function() {
        return re;
      }, set: function(n) {
        return re = n;
      } }, totalEchoes: { get: function() {
        return Hl;
      } }, newPSD: Un, usePSD: Qn, scheduler: { get: function() {
        return on;
      }, set: function(n) {
        on = n;
      } }, rejectionMapper: { get: function() {
        return yl;
      }, set: function(n) {
        yl = n;
      } }, follow: function(n, t) {
        return new ee(function(u, r) {
          return Un(function(c, f) {
            var p = re;
            p.unhandleds = [], p.onunhandled = f, p.finalize = fe(function() {
              var g, L = this;
              g = function() {
                L.unhandleds.length === 0 ? c() : f(L.unhandleds[0]);
              }, Il.push(function O() {
                g(), Il.splice(Il.indexOf(O), 1);
              }), ++Zn, on(function() {
                --Zn == 0 && Rt();
              }, []);
            }, p.finalize), n();
          }, t, u, r);
        });
      } }), Je && (Je.allSettled && R(ee, "allSettled", function() {
        var n = Ee.apply(null, arguments).map($l);
        return new ee(function(t) {
          n.length === 0 && t([]);
          var u = n.length, r = new Array(u);
          n.forEach(function(c, f) {
            return ee.resolve(c).then(function(p) {
              return r[f] = { status: "fulfilled", value: p };
            }, function(p) {
              return r[f] = { status: "rejected", reason: p };
            }).then(function() {
              return --u || t(r);
            });
          });
        });
      }), Je.any && typeof AggregateError < "u" && R(ee, "any", function() {
        var n = Ee.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.length === 0 && u(new AggregateError([]));
          var r = n.length, c = new Array(r);
          n.forEach(function(f, p) {
            return ee.resolve(f).then(function(g) {
              return t(g);
            }, function(g) {
              c[p] = g, --r || u(new AggregateError(c));
            });
          });
        });
      }), Je.withResolvers && (ee.withResolvers = Je.withResolvers));
      var en = { awaits: 0, echoes: 0, id: 0 }, lr = 0, zl = [], jl = 0, Hl = 0, tr = 0;
      function Un(n, t, u, r) {
        var c = re, f = Object.create(c);
        return f.parent = c, f.ref = 0, f.global = !1, f.id = ++tr, An.env, f.env = yn ? { Promise: ee, PromiseProp: { value: ee, configurable: !0, writable: !0 }, all: ee.all, race: ee.race, allSettled: ee.allSettled, any: ee.any, resolve: ee.resolve, reject: ee.reject } : {}, t && h(f, t), ++c.ref, f.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, r = Qn(f, n, u, r), f.ref === 0 && f.finalize(), r;
      }
      function cl() {
        return en.id || (en.id = ++lr), ++en.awaits, en.echoes += ke, en.id;
      }
      function Kn() {
        return !!en.awaits && (--en.awaits == 0 && (en.id = 0), en.echoes = en.awaits * ke, !0);
      }
      function $l(n) {
        return en.echoes && n && n.constructor === Je ? (cl(), n.then(function(t) {
          return Kn(), t;
        }, function(t) {
          return Kn(), He(t);
        })) : n;
      }
      function ir() {
        var n = zl[zl.length - 1];
        zl.pop(), Gn(n, !1);
      }
      function Gn(n, t) {
        var u, r = re;
        (t ? !en.echoes || jl++ && n === re : !jl || --jl && n === re) || queueMicrotask(t ? (function(c) {
          ++Hl, en.echoes && --en.echoes != 0 || (en.echoes = en.awaits = en.id = 0), zl.push(re), Gn(c, !0);
        }).bind(null, n) : ir), n !== re && (re = n, r === An && (An.env = Qi()), yn && (u = An.env.Promise, t = n.env, (r.global || n.global) && (Object.defineProperty(o, "Promise", t.PromiseProp), u.all = t.all, u.race = t.race, u.resolve = t.resolve, u.reject = t.reject, t.allSettled && (u.allSettled = t.allSettled), t.any && (u.any = t.any))));
      }
      function Qi() {
        var n = o.Promise;
        return yn ? { Promise: n, PromiseProp: Object.getOwnPropertyDescriptor(o, "Promise"), all: n.all, race: n.race, allSettled: n.allSettled, any: n.any, resolve: n.resolve, reject: n.reject } : {};
      }
      function Qn(n, t, u, r, c) {
        var f = re;
        try {
          return Gn(n, !0), t(u, r, c);
        } finally {
          Gn(f, !1);
        }
      }
      function Ji(n, t, u, r) {
        return typeof n != "function" ? n : function() {
          var c = re;
          u && cl(), Gn(t, !0);
          try {
            return n.apply(this, arguments);
          } finally {
            Gn(c, !1), r && queueMicrotask(Kn);
          }
        };
      }
      function Et(n) {
        Promise === Je && en.echoes === 0 ? jl === 0 ? n() : enqueueNativeMicroTask(n) : setTimeout(n, 0);
      }
      ("" + In).indexOf("[native code]") === -1 && (cl = Kn = Oe);
      var He = ee.reject, Jn = "", Rn = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", eu = "String expected.", ol = [], Wl = "__dbnames", _t = "readonly", Nt = "readwrite";
      function el(n, t) {
        return n ? t ? function() {
          return n.apply(this, arguments) && t.apply(this, arguments);
        } : n : t;
      }
      var nu = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Yl(n) {
        return typeof n != "string" || /\./.test(n) ? function(t) {
          return t;
        } : function(t) {
          return t[n] === void 0 && n in t && delete (t = ve(t))[n], t;
        };
      }
      function lu() {
        throw Z.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Ce(n, t) {
        try {
          var u = tu(n), r = tu(t);
          if (u !== r) return u === "Array" ? 1 : r === "Array" ? -1 : u === "binary" ? 1 : r === "binary" ? -1 : u === "string" ? 1 : r === "string" ? -1 : u === "Date" ? 1 : r !== "Date" ? NaN : -1;
          switch (u) {
            case "number":
            case "Date":
            case "string":
              return t < n ? 1 : n < t ? -1 : 0;
            case "binary":
              return function(c, f) {
                for (var p = c.length, g = f.length, L = p < g ? p : g, O = 0; O < L; ++O) if (c[O] !== f[O]) return c[O] < f[O] ? -1 : 1;
                return p === g ? 0 : p < g ? -1 : 1;
              }(iu(n), iu(t));
            case "Array":
              return function(c, f) {
                for (var p = c.length, g = f.length, L = p < g ? p : g, O = 0; O < L; ++O) {
                  var w = Ce(c[O], f[O]);
                  if (w !== 0) return w;
                }
                return p === g ? 0 : p < g ? -1 : 1;
              }(n, t);
          }
        } catch {
        }
        return NaN;
      }
      function tu(n) {
        var t = typeof n;
        return t != "object" ? t : ArrayBuffer.isView(n) ? "binary" : (n = Se(n), n === "ArrayBuffer" ? "binary" : n);
      }
      function iu(n) {
        return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n);
      }
      function Xl(n, t, u) {
        var r = n.schema.yProps;
        return r ? (t && 0 < u.numFailures && (t = t.filter(function(c, f) {
          return !u.failures[f];
        })), Promise.all(r.map(function(c) {
          return c = c.updatesTable, t ? n.db.table(c).where("k").anyOf(t).delete() : n.db.table(c).clear();
        })).then(function() {
          return u;
        })) : u;
      }
      var uu = (Ve.prototype._trans = function(n, t, u) {
        var r = this._tx || re.trans, c = this.name, f = be && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(n === "readonly" ? "read" : "write", " ").concat(this.name));
        function p(O, w, v) {
          if (!v.schema[c]) throw new Z.NotFound("Table " + c + " not part of transaction");
          return t(v.idbtrans, v);
        }
        var g = rl();
        try {
          var L = r && r.db._novip === this.db._novip ? r === re.trans ? r._promise(n, p, u) : Un(function() {
            return r._promise(n, p, u);
          }, { trans: r, transless: re.transless || re }) : function O(w, v, T, D) {
            if (w.idbdb && (w._state.openComplete || re.letThrough || w._vip)) {
              var b = w._createTransaction(v, T, w._dbSchema);
              try {
                b.create(), w._state.PR1398_maxLoop = 3;
              } catch (C) {
                return C.name === k.InvalidState && w.isOpen() && 0 < --w._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), w.close({ disableAutoOpen: !1 }), w.open().then(function() {
                  return O(w, v, T, D);
                })) : He(C);
              }
              return b._promise(v, function(C, S) {
                return Un(function() {
                  return re.trans = b, D(C, S, b);
                });
              }).then(function(C) {
                if (v === "readwrite") try {
                  b.idbtrans.commit();
                } catch {
                }
                return v === "readonly" ? C : b._completion.then(function() {
                  return C;
                });
              });
            }
            if (w._state.openComplete) return He(new Z.DatabaseClosed(w._state.dbOpenError));
            if (!w._state.isBeingOpened) {
              if (!w._state.autoOpen) return He(new Z.DatabaseClosed());
              w.open().catch(Oe);
            }
            return w._state.dbReadyPromise.then(function() {
              return O(w, v, T, D);
            });
          }(this.db, n, [this.name], p);
          return f && (L._consoleTask = f, L = L.catch(function(O) {
            return console.trace(O), He(O);
          })), L;
        } finally {
          g && sl();
        }
      }, Ve.prototype.get = function(n, t) {
        var u = this;
        return n && n.constructor === Object ? this.where(n).first(t) : n == null ? He(new Z.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(r) {
          return u.core.get({ trans: r, key: n }).then(function(c) {
            return u.hook.reading.fire(c);
          });
        }).then(t);
      }, Ve.prototype.where = function(n) {
        if (typeof n == "string") return new this.db.WhereClause(this, n);
        if (d(n)) return new this.db.WhereClause(this, "[".concat(n.join("+"), "]"));
        var t = m(n);
        if (t.length === 1) return this.where(t[0]).equals(n[t[0]]);
        var u = this.schema.indexes.concat(this.schema.primKey).filter(function(g) {
          if (g.compound && t.every(function(O) {
            return 0 <= g.keyPath.indexOf(O);
          })) {
            for (var L = 0; L < t.length; ++L) if (t.indexOf(g.keyPath[L]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(g, L) {
          return g.keyPath.length - L.keyPath.length;
        })[0];
        if (u && this.db._maxKey !== Jn) {
          var f = u.keyPath.slice(0, t.length);
          return this.where(f).equals(f.map(function(L) {
            return n[L];
          }));
        }
        !u && be && console.warn("The query ".concat(JSON.stringify(n), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var r = this.schema.idxByName;
        function c(g, L) {
          return Ce(g, L) === 0;
        }
        var p = t.reduce(function(v, L) {
          var O = v[0], w = v[1], v = r[L], T = n[L];
          return [O || v, O || !v ? el(w, v && v.multi ? function(D) {
            return D = se(D, L), d(D) && D.some(function(b) {
              return c(T, b);
            });
          } : function(D) {
            return c(T, se(D, L));
          }) : w];
        }, [null, null]), f = p[0], p = p[1];
        return f ? this.where(f.name).equals(n[f.keyPath]).filter(p) : u ? this.filter(p) : this.where(t).equals("");
      }, Ve.prototype.filter = function(n) {
        return this.toCollection().and(n);
      }, Ve.prototype.count = function(n) {
        return this.toCollection().count(n);
      }, Ve.prototype.offset = function(n) {
        return this.toCollection().offset(n);
      }, Ve.prototype.limit = function(n) {
        return this.toCollection().limit(n);
      }, Ve.prototype.each = function(n) {
        return this.toCollection().each(n);
      }, Ve.prototype.toArray = function(n) {
        return this.toCollection().toArray(n);
      }, Ve.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ve.prototype.orderBy = function(n) {
        return new this.db.Collection(new this.db.WhereClause(this, d(n) ? "[".concat(n.join("+"), "]") : n));
      }, Ve.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ve.prototype.mapToClass = function(n) {
        var t, u = this.db, r = this.name;
        function c() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = n).prototype instanceof lu && (function(L, O) {
          if (typeof O != "function" && O !== null) throw new TypeError("Class extends value " + String(O) + " is not a constructor or null");
          function w() {
            this.constructor = L;
          }
          i(L, O), L.prototype = O === null ? Object.create(O) : (w.prototype = O.prototype, new w());
        }(c, t = n), Object.defineProperty(c.prototype, "db", { get: function() {
          return u;
        }, enumerable: !1, configurable: !0 }), c.prototype.table = function() {
          return r;
        }, n = c);
        for (var f = /* @__PURE__ */ new Set(), p = n.prototype; p; p = x(p)) Object.getOwnPropertyNames(p).forEach(function(L) {
          return f.add(L);
        });
        function g(L) {
          if (!L) return L;
          var O, w = Object.create(n.prototype);
          for (O in L) if (!f.has(O)) try {
            w[O] = L[O];
          } catch {
          }
          return w;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = g, this.hook("reading", g), n;
      }, Ve.prototype.defineClass = function() {
        return this.mapToClass(function(n) {
          h(this, n);
        });
      }, Ve.prototype.add = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, f = r.keyPath, p = n;
        return f && c && (p = Yl(f)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "add", keys: t != null ? [t] : null, values: [p] });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (f) try {
            te(n, f, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.update = function(n, t) {
        return typeof n != "object" || d(n) ? this.where(":id").equals(n).modify(t) : (n = se(n, this.schema.primKey.keyPath), n === void 0 ? He(new Z.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(n).modify(t));
      }, Ve.prototype.put = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, f = r.keyPath, p = n;
        return f && c && (p = Yl(f)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "put", values: [p], keys: t != null ? [t] : null });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (f) try {
            te(n, f, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.delete = function(n) {
        var t = this;
        return this._trans("readwrite", function(u) {
          return t.core.mutate({ trans: u, type: "delete", keys: [n] }).then(function(r) {
            return Xl(t, [n], r);
          }).then(function(r) {
            return r.numFailures ? ee.reject(r.failures[0]) : void 0;
          });
        });
      }, Ve.prototype.clear = function() {
        var n = this;
        return this._trans("readwrite", function(t) {
          return n.core.mutate({ trans: t, type: "deleteRange", range: nu }).then(function(u) {
            return Xl(n, null, u);
          });
        }).then(function(t) {
          return t.numFailures ? ee.reject(t.failures[0]) : void 0;
        });
      }, Ve.prototype.bulkGet = function(n) {
        var t = this;
        return this._trans("readonly", function(u) {
          return t.core.getMany({ keys: n, trans: u }).then(function(r) {
            return r.map(function(c) {
              return t.hook.reading.fire(c);
            });
          });
        });
      }, Ve.prototype.bulkAdd = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, f = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new Z.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new Z.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Yl(O)) : n;
          return r.core.mutate({ trans: p, type: "add", keys: c, values: O, wantResults: f }).then(function(b) {
            var v = b.numFailures, T = b.results, D = b.lastResult, b = b.failures;
            if (v === 0) return f ? T : D;
            throw new tn("".concat(r.name, ".bulkAdd(): ").concat(v, " of ").concat(L, " operations failed"), b);
          });
        });
      }, Ve.prototype.bulkPut = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, f = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new Z.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new Z.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Yl(O)) : n;
          return r.core.mutate({ trans: p, type: "put", keys: c, values: O, wantResults: f }).then(function(b) {
            var v = b.numFailures, T = b.results, D = b.lastResult, b = b.failures;
            if (v === 0) return f ? T : D;
            throw new tn("".concat(r.name, ".bulkPut(): ").concat(v, " of ").concat(L, " operations failed"), b);
          });
        });
      }, Ve.prototype.bulkUpdate = function(n) {
        var t = this, u = this.core, r = n.map(function(p) {
          return p.key;
        }), c = n.map(function(p) {
          return p.changes;
        }), f = [];
        return this._trans("readwrite", function(p) {
          return u.getMany({ trans: p, keys: r, cache: "clone" }).then(function(g) {
            var L = [], O = [];
            n.forEach(function(v, T) {
              var D = v.key, b = v.changes, C = g[T];
              if (C) {
                for (var S = 0, P = Object.keys(b); S < P.length; S++) {
                  var E = P[S], N = b[E];
                  if (E === t.schema.primKey.keyPath) {
                    if (Ce(N, D) !== 0) throw new Z.Constraint("Cannot update primary key in bulkUpdate()");
                  } else te(C, E, N);
                }
                f.push(T), L.push(D), O.push(C);
              }
            });
            var w = L.length;
            return u.mutate({ trans: p, type: "put", keys: L, values: O, updates: { keys: r, changeSpecs: c } }).then(function(v) {
              var T = v.numFailures, D = v.failures;
              if (T === 0) return w;
              for (var b = 0, C = Object.keys(D); b < C.length; b++) {
                var S, P = C[b], E = f[Number(P)];
                E != null && (S = D[P], delete D[P], D[E] = S);
              }
              throw new tn("".concat(t.name, ".bulkUpdate(): ").concat(T, " of ").concat(w, " operations failed"), D);
            });
          });
        });
      }, Ve.prototype.bulkDelete = function(n) {
        var t = this, u = n.length;
        return this._trans("readwrite", function(r) {
          return t.core.mutate({ trans: r, type: "delete", keys: n }).then(function(c) {
            return Xl(t, n, c);
          });
        }).then(function(p) {
          var c = p.numFailures, f = p.lastResult, p = p.failures;
          if (c === 0) return f;
          throw new tn("".concat(t.name, ".bulkDelete(): ").concat(c, " of ").concat(u, " operations failed"), p);
        });
      }, Ve);
      function Ve() {
      }
      function Ll(n) {
        function t(p, g) {
          if (g) {
            for (var L = arguments.length, O = new Array(L - 1); --L; ) O[L - 1] = arguments[L];
            return u[p].subscribe.apply(null, O), n;
          }
          if (typeof p == "string") return u[p];
        }
        var u = {};
        t.addEventType = f;
        for (var r = 1, c = arguments.length; r < c; ++r) f(arguments[r]);
        return t;
        function f(p, g, L) {
          if (typeof p != "object") {
            var O;
            g = g || Ne;
            var w = { subscribers: [], fire: L = L || Oe, subscribe: function(v) {
              w.subscribers.indexOf(v) === -1 && (w.subscribers.push(v), w.fire = g(w.fire, v));
            }, unsubscribe: function(v) {
              w.subscribers = w.subscribers.filter(function(T) {
                return T !== v;
              }), w.fire = w.subscribers.reduce(g, L);
            } };
            return u[p] = t[p] = w;
          }
          m(O = p).forEach(function(v) {
            var T = O[v];
            if (d(T)) f(v, O[v][0], O[v][1]);
            else {
              if (T !== "asap") throw new Z.InvalidArgument("Invalid event config");
              var D = f(v, j, function() {
                for (var b = arguments.length, C = new Array(b); b--; ) C[b] = arguments[b];
                D.subscribers.forEach(function(S) {
                  W(function() {
                    S.apply(null, C);
                  });
                });
              });
            }
          });
        }
      }
      function Dl(n, t) {
        return V(t).from({ prototype: n }), t;
      }
      function ml(n, t) {
        return !(n.filter || n.algorithm || n.or) && (t ? n.justLimit : !n.replayFilter);
      }
      function Ft(n, t) {
        n.filter = el(n.filter, t);
      }
      function Mt(n, t, u) {
        var r = n.replayFilter;
        n.replayFilter = r ? function() {
          return el(r(), t());
        } : t, n.justLimit = u && !r;
      }
      function Ql(n, t) {
        if (n.isPrimKey) return t.primaryKey;
        var u = t.getIndexByKeyPath(n.index);
        if (!u) throw new Z.Schema("KeyPath " + n.index + " on object store " + t.name + " is not indexed");
        return u;
      }
      function au(n, t, u) {
        var r = Ql(n, t.schema);
        return t.openCursor({ trans: u, values: !n.keysOnly, reverse: n.dir === "prev", unique: !!n.unique, query: { index: r, range: n.range } });
      }
      function Jl(n, t, u, r) {
        var c = n.replayFilter ? el(n.filter, n.replayFilter()) : n.filter;
        if (n.or) {
          var f = {}, p = function(g, L, O) {
            var w, v;
            c && !c(L, O, function(T) {
              return L.stop(T);
            }, function(T) {
              return L.fail(T);
            }) || ((v = "" + (w = L.primaryKey)) == "[object ArrayBuffer]" && (v = "" + new Uint8Array(w)), I(f, v) || (f[v] = !0, t(g, L, O)));
          };
          return Promise.all([n.or._iterate(p, u), ru(au(n, r, u), n.algorithm, p, !n.keysOnly && n.valueMapper)]);
        }
        return ru(au(n, r, u), el(n.algorithm, c), t, !n.keysOnly && n.valueMapper);
      }
      function ru(n, t, u, r) {
        var c = Be(r ? function(f, p, g) {
          return u(r(f), p, g);
        } : u);
        return n.then(function(f) {
          if (f) return f.start(function() {
            var p = function() {
              return f.continue();
            };
            t && !t(f, function(g) {
              return p = g;
            }, function(g) {
              f.stop(g), p = Oe;
            }, function(g) {
              f.fail(g), p = Oe;
            }) || c(f.value, f, function(g) {
              return p = g;
            }), p();
          });
        });
      }
      var Ol = (su.prototype.execute = function(n) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var u = t.add;
          if (d(u)) return s(s([], d(n) ? n : [], !0), u).sort();
          if (typeof u == "number") return (Number(n) || 0) + u;
          if (typeof u == "bigint") try {
            return BigInt(n) + u;
          } catch {
            return BigInt(0) + u;
          }
          throw new TypeError("Invalid term ".concat(u));
        }
        if (t.remove !== void 0) {
          var r = t.remove;
          if (d(r)) return d(n) ? n.filter(function(c) {
            return !r.includes(c);
          }).sort() : [];
          if (typeof r == "number") return Number(n) - r;
          if (typeof r == "bigint") try {
            return BigInt(n) - r;
          } catch {
            return BigInt(0) - r;
          }
          throw new TypeError("Invalid subtrahend ".concat(r));
        }
        return u = (u = t.replacePrefix) === null || u === void 0 ? void 0 : u[0], u && typeof n == "string" && n.startsWith(u) ? t.replacePrefix[1] + n.substring(u.length) : n;
      }, su);
      function su(n) {
        this["@@propmod"] = n;
      }
      var ur = (Ae.prototype._read = function(n, t) {
        var u = this._ctx;
        return u.error ? u.table._trans(null, He.bind(null, u.error)) : u.table._trans("readonly", n).then(t);
      }, Ae.prototype._write = function(n) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, He.bind(null, t.error)) : t.table._trans("readwrite", n, "locked");
      }, Ae.prototype._addAlgorithm = function(n) {
        var t = this._ctx;
        t.algorithm = el(t.algorithm, n);
      }, Ae.prototype._iterate = function(n, t) {
        return Jl(this._ctx, n, t, this._ctx.table.core);
      }, Ae.prototype.clone = function(n) {
        var t = Object.create(this.constructor.prototype), u = Object.create(this._ctx);
        return n && h(u, n), t._ctx = u, t;
      }, Ae.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Ae.prototype.each = function(n) {
        var t = this._ctx;
        return this._read(function(u) {
          return Jl(t, n, u, t.table.core);
        });
      }, Ae.prototype.count = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx, c = r.table.core;
          if (ml(r, !0)) return c.count({ trans: u, query: { index: Ql(r, c.schema), range: r.range } }).then(function(p) {
            return Math.min(p, r.limit);
          });
          var f = 0;
          return Jl(r, function() {
            return ++f, !1;
          }, u, c).then(function() {
            return f;
          });
        }).then(n);
      }, Ae.prototype.sortBy = function(n, t) {
        var u = n.split(".").reverse(), r = u[0], c = u.length - 1;
        function f(L, O) {
          return O ? f(L[u[O]], O - 1) : L[r];
        }
        var p = this._ctx.dir === "next" ? 1 : -1;
        function g(L, O) {
          return Ce(f(L, c), f(O, c)) * p;
        }
        return this.toArray(function(L) {
          return L.sort(g);
        }).then(t);
      }, Ae.prototype.toArray = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx;
          if (r.dir === "next" && ml(r, !0) && 0 < r.limit) {
            var c = r.valueMapper, f = Ql(r, r.table.core.schema);
            return r.table.core.query({ trans: u, limit: r.limit, values: !0, query: { index: f, range: r.range } }).then(function(g) {
              return g = g.result, c ? g.map(c) : g;
            });
          }
          var p = [];
          return Jl(r, function(g) {
            return p.push(g);
          }, u, r.table.core).then(function() {
            return p;
          });
        }, n);
      }, Ae.prototype.offset = function(n) {
        var t = this._ctx;
        return n <= 0 || (t.offset += n, ml(t) ? Mt(t, function() {
          var u = n;
          return function(r, c) {
            return u === 0 || (u === 1 ? --u : c(function() {
              r.advance(u), u = 0;
            }), !1);
          };
        }) : Mt(t, function() {
          var u = n;
          return function() {
            return --u < 0;
          };
        })), this;
      }, Ae.prototype.limit = function(n) {
        return this._ctx.limit = Math.min(this._ctx.limit, n), Mt(this._ctx, function() {
          var t = n;
          return function(u, r, c) {
            return --t <= 0 && r(c), 0 <= t;
          };
        }, !0), this;
      }, Ae.prototype.until = function(n, t) {
        return Ft(this._ctx, function(u, r, c) {
          return !n(u.value) || (r(c), t);
        }), this;
      }, Ae.prototype.first = function(n) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(n);
      }, Ae.prototype.last = function(n) {
        return this.reverse().first(n);
      }, Ae.prototype.filter = function(n) {
        var t;
        return Ft(this._ctx, function(u) {
          return n(u.value);
        }), (t = this._ctx).isMatch = el(t.isMatch, n), this;
      }, Ae.prototype.and = function(n) {
        return this.filter(n);
      }, Ae.prototype.or = function(n) {
        return new this.db.WhereClause(this._ctx.table, n, this);
      }, Ae.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Ae.prototype.desc = function() {
        return this.reverse();
      }, Ae.prototype.eachKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.key, r);
        });
      }, Ae.prototype.eachUniqueKey = function(n) {
        return this._ctx.unique = "unique", this.eachKey(n);
      }, Ae.prototype.eachPrimaryKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.primaryKey, r);
        });
      }, Ae.prototype.keys = function(n) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.key);
        }).then(function() {
          return u;
        }).then(n);
      }, Ae.prototype.primaryKeys = function(n) {
        var t = this._ctx;
        if (t.dir === "next" && ml(t, !0) && 0 < t.limit) return this._read(function(r) {
          var c = Ql(t, t.table.core.schema);
          return t.table.core.query({ trans: r, values: !1, limit: t.limit, query: { index: c, range: t.range } });
        }).then(function(r) {
          return r.result;
        }).then(n);
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.primaryKey);
        }).then(function() {
          return u;
        }).then(n);
      }, Ae.prototype.uniqueKeys = function(n) {
        return this._ctx.unique = "unique", this.keys(n);
      }, Ae.prototype.firstKey = function(n) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(n);
      }, Ae.prototype.lastKey = function(n) {
        return this.reverse().firstKey(n);
      }, Ae.prototype.distinct = function() {
        var n = this._ctx, n = n.index && n.table.schema.idxByName[n.index];
        if (!n || !n.multi) return this;
        var t = {};
        return Ft(this._ctx, function(c) {
          var r = c.primaryKey.toString(), c = I(t, r);
          return t[r] = !0, !c;
        }), this;
      }, Ae.prototype.modify = function(n) {
        var t = this, u = this._ctx;
        return this._write(function(r) {
          var c, f, p;
          p = typeof n == "function" ? n : (c = m(n), f = c.length, function(P) {
            for (var E = !1, N = 0; N < f; ++N) {
              var F = c[N], G = n[F], Y = se(P, F);
              G instanceof Ol ? (te(P, F, G.execute(Y)), E = !0) : Y !== G && (te(P, F, G), E = !0);
            }
            return E;
          });
          var g = u.table.core, v = g.schema.primaryKey, L = v.outbound, O = v.extractKey, w = 200, v = t.db._options.modifyChunkSize;
          v && (w = typeof v == "object" ? v[g.name] || v["*"] || 200 : v);
          function T(P, F) {
            var N = F.failures, F = F.numFailures;
            b += P - F;
            for (var G = 0, Y = m(N); G < Y.length; G++) {
              var H = Y[G];
              D.push(N[H]);
            }
          }
          var D = [], b = 0, C = [], S = n === cu;
          return t.clone().primaryKeys().then(function(P) {
            function E(F) {
              var G = Math.min(w, P.length - F), Y = P.slice(F, F + G);
              return (S ? Promise.resolve([]) : g.getMany({ trans: r, keys: Y, cache: "immutable" })).then(function(H) {
                var $ = [], J = [], Q = L ? [] : null, ne = S ? Y : [];
                if (!S) for (var xe = 0; xe < G; ++xe) {
                  var qe = H[xe], he = { value: ve(qe), primKey: P[F + xe] };
                  p.call(he, he.value, he) !== !1 && (he.value == null ? ne.push(P[F + xe]) : L || Ce(O(qe), O(he.value)) === 0 ? (J.push(he.value), L && Q.push(P[F + xe])) : (ne.push(P[F + xe]), $.push(he.value)));
                }
                return Promise.resolve(0 < $.length && g.mutate({ trans: r, type: "add", values: $ }).then(function(Ge) {
                  for (var pe in Ge.failures) ne.splice(parseInt(pe), 1);
                  T($.length, Ge);
                })).then(function() {
                  return (0 < J.length || N && typeof n == "object") && g.mutate({ trans: r, type: "put", keys: Q, values: J, criteria: N, changeSpec: typeof n != "function" && n, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return T(J.length, Ge);
                  });
                }).then(function() {
                  return (0 < ne.length || N && S) && g.mutate({ trans: r, type: "delete", keys: ne, criteria: N, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return Xl(u.table, ne, Ge);
                  }).then(function(Ge) {
                    return T(ne.length, Ge);
                  });
                }).then(function() {
                  return P.length > F + G && E(F + w);
                });
              });
            }
            var N = ml(u) && u.limit === 1 / 0 && (typeof n != "function" || S) && { index: u.index, range: u.range };
            return E(0).then(function() {
              if (0 < D.length) throw new xn("Error modifying one or more objects", D, b, C);
              return P.length;
            });
          });
        });
      }, Ae.prototype.delete = function() {
        var n = this._ctx, t = n.range;
        return !ml(n) || n.table.schema.yProps || !n.isPrimKey && t.type !== 3 ? this.modify(cu) : this._write(function(u) {
          var r = n.table.core.schema.primaryKey, c = t;
          return n.table.core.count({ trans: u, query: { index: r, range: c } }).then(function(f) {
            return n.table.core.mutate({ trans: u, type: "deleteRange", range: c }).then(function(L) {
              var g = L.failures, L = L.numFailures;
              if (L) throw new xn("Could not delete some values", Object.keys(g).map(function(O) {
                return g[O];
              }), f - L);
              return f - L;
            });
          });
        });
      }, Ae);
      function Ae() {
      }
      var cu = function(n, t) {
        return t.value = null;
      };
      function ar(n, t) {
        return n < t ? -1 : n === t ? 0 : 1;
      }
      function rr(n, t) {
        return t < n ? -1 : n === t ? 0 : 1;
      }
      function pn(n, t, u) {
        return n = n instanceof mu ? new n.Collection(n) : n, n._ctx.error = new (u || TypeError)(t), n;
      }
      function fl(n) {
        return new n.Collection(n, function() {
          return ou("");
        }).limit(0);
      }
      function et(n, t, u, r) {
        var c, f, p, g, L, O, w, v = u.length;
        if (!u.every(function(b) {
          return typeof b == "string";
        })) return pn(n, eu);
        function T(b) {
          c = b === "next" ? function(S) {
            return S.toUpperCase();
          } : function(S) {
            return S.toLowerCase();
          }, f = b === "next" ? function(S) {
            return S.toLowerCase();
          } : function(S) {
            return S.toUpperCase();
          }, p = b === "next" ? ar : rr;
          var C = u.map(function(S) {
            return { lower: f(S), upper: c(S) };
          }).sort(function(S, P) {
            return p(S.lower, P.lower);
          });
          g = C.map(function(S) {
            return S.upper;
          }), L = C.map(function(S) {
            return S.lower;
          }), w = (O = b) === "next" ? "" : r;
        }
        T("next"), n = new n.Collection(n, function() {
          return zn(g[0], L[v - 1] + r);
        }), n._ondirectionchange = function(b) {
          T(b);
        };
        var D = 0;
        return n._addAlgorithm(function(b, C, S) {
          var P = b.key;
          if (typeof P != "string") return !1;
          var E = f(P);
          if (t(E, L, D)) return !0;
          for (var N = null, F = D; F < v; ++F) {
            var G = function(Y, H, $, J, Q, ne) {
              for (var xe = Math.min(Y.length, J.length), qe = -1, he = 0; he < xe; ++he) {
                var Ge = H[he];
                if (Ge !== J[he]) return Q(Y[he], $[he]) < 0 ? Y.substr(0, he) + $[he] + $.substr(he + 1) : Q(Y[he], J[he]) < 0 ? Y.substr(0, he) + J[he] + $.substr(he + 1) : 0 <= qe ? Y.substr(0, qe) + H[qe] + $.substr(qe + 1) : null;
                Q(Y[he], Ge) < 0 && (qe = he);
              }
              return xe < J.length && ne === "next" ? Y + $.substr(Y.length) : xe < Y.length && ne === "prev" ? Y.substr(0, $.length) : qe < 0 ? null : Y.substr(0, qe) + J[qe] + $.substr(qe + 1);
            }(P, E, g[F], L[F], p, O);
            G === null && N === null ? D = F + 1 : (N === null || 0 < p(N, G)) && (N = G);
          }
          return C(N !== null ? function() {
            b.continue(N + w);
          } : S), !1;
        }), n;
      }
      function zn(n, t, u, r) {
        return { type: 2, lower: n, upper: t, lowerOpen: u, upperOpen: r };
      }
      function ou(n) {
        return { type: 1, lower: n, upper: n };
      }
      var mu = (Object.defineProperty(nn.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), nn.prototype.between = function(n, t, u, r) {
        u = u !== !1, r = r === !0;
        try {
          return 0 < this._cmp(n, t) || this._cmp(n, t) === 0 && (u || r) && (!u || !r) ? fl(this) : new this.Collection(this, function() {
            return zn(n, t, !u, !r);
          });
        } catch {
          return pn(this, Rn);
        }
      }, nn.prototype.equals = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return ou(n);
        });
      }, nn.prototype.above = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return zn(n, void 0, !0);
        });
      }, nn.prototype.aboveOrEqual = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return zn(n, void 0, !1);
        });
      }, nn.prototype.below = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return zn(void 0, n, !1, !0);
        });
      }, nn.prototype.belowOrEqual = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return zn(void 0, n);
        });
      }, nn.prototype.startsWith = function(n) {
        return typeof n != "string" ? pn(this, eu) : this.between(n, n + Jn, !0, !0);
      }, nn.prototype.startsWithIgnoreCase = function(n) {
        return n === "" ? this.startsWith(n) : et(this, function(t, u) {
          return t.indexOf(u[0]) === 0;
        }, [n], Jn);
      }, nn.prototype.equalsIgnoreCase = function(n) {
        return et(this, function(t, u) {
          return t === u[0];
        }, [n], "");
      }, nn.prototype.anyOfIgnoreCase = function() {
        var n = Ee.apply(De, arguments);
        return n.length === 0 ? fl(this) : et(this, function(t, u) {
          return u.indexOf(t) !== -1;
        }, n, "");
      }, nn.prototype.startsWithAnyOfIgnoreCase = function() {
        var n = Ee.apply(De, arguments);
        return n.length === 0 ? fl(this) : et(this, function(t, u) {
          return u.some(function(r) {
            return t.indexOf(r) === 0;
          });
        }, n, Jn);
      }, nn.prototype.anyOf = function() {
        var n = this, t = Ee.apply(De, arguments), u = this._cmp;
        try {
          t.sort(u);
        } catch {
          return pn(this, Rn);
        }
        if (t.length === 0) return fl(this);
        var r = new this.Collection(this, function() {
          return zn(t[0], t[t.length - 1]);
        });
        r._ondirectionchange = function(f) {
          u = f === "next" ? n._ascending : n._descending, t.sort(u);
        };
        var c = 0;
        return r._addAlgorithm(function(f, p, g) {
          for (var L = f.key; 0 < u(L, t[c]); ) if (++c === t.length) return p(g), !1;
          return u(L, t[c]) === 0 || (p(function() {
            f.continue(t[c]);
          }), !1);
        }), r;
      }, nn.prototype.notEqual = function(n) {
        return this.inAnyRange([[-1 / 0, n], [n, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, nn.prototype.noneOf = function() {
        var n = Ee.apply(De, arguments);
        if (n.length === 0) return new this.Collection(this);
        try {
          n.sort(this._ascending);
        } catch {
          return pn(this, Rn);
        }
        var t = n.reduce(function(u, r) {
          return u ? u.concat([[u[u.length - 1][1], r]]) : [[-1 / 0, r]];
        }, null);
        return t.push([n[n.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, nn.prototype.inAnyRange = function(P, t) {
        var u = this, r = this._cmp, c = this._ascending, f = this._descending, p = this._min, g = this._max;
        if (P.length === 0) return fl(this);
        if (!P.every(function(E) {
          return E[0] !== void 0 && E[1] !== void 0 && c(E[0], E[1]) <= 0;
        })) return pn(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Z.InvalidArgument);
        var L = !t || t.includeLowers !== !1, O = t && t.includeUppers === !0, w, v = c;
        function T(E, N) {
          return v(E[0], N[0]);
        }
        try {
          (w = P.reduce(function(E, N) {
            for (var F = 0, G = E.length; F < G; ++F) {
              var Y = E[F];
              if (r(N[0], Y[1]) < 0 && 0 < r(N[1], Y[0])) {
                Y[0] = p(Y[0], N[0]), Y[1] = g(Y[1], N[1]);
                break;
              }
            }
            return F === G && E.push(N), E;
          }, [])).sort(T);
        } catch {
          return pn(this, Rn);
        }
        var D = 0, b = O ? function(E) {
          return 0 < c(E, w[D][1]);
        } : function(E) {
          return 0 <= c(E, w[D][1]);
        }, C = L ? function(E) {
          return 0 < f(E, w[D][0]);
        } : function(E) {
          return 0 <= f(E, w[D][0]);
        }, S = b, P = new this.Collection(this, function() {
          return zn(w[0][0], w[w.length - 1][1], !L, !O);
        });
        return P._ondirectionchange = function(E) {
          v = E === "next" ? (S = b, c) : (S = C, f), w.sort(T);
        }, P._addAlgorithm(function(E, N, F) {
          for (var G, Y = E.key; S(Y); ) if (++D === w.length) return N(F), !1;
          return !b(G = Y) && !C(G) || (u._cmp(Y, w[D][1]) === 0 || u._cmp(Y, w[D][0]) === 0 || N(function() {
            v === c ? E.continue(w[D][0]) : E.continue(w[D][1]);
          }), !1);
        }), P;
      }, nn.prototype.startsWithAnyOf = function() {
        var n = Ee.apply(De, arguments);
        return n.every(function(t) {
          return typeof t == "string";
        }) ? n.length === 0 ? fl(this) : this.inAnyRange(n.map(function(t) {
          return [t, t + Jn];
        })) : pn(this, "startsWithAnyOf() only works with strings");
      }, nn);
      function nn() {
      }
      function bn(n) {
        return Be(function(t) {
          return bl(t), n(t.target.error), !1;
        });
      }
      function bl(n) {
        n.stopPropagation && n.stopPropagation(), n.preventDefault && n.preventDefault();
      }
      var wl = "storagemutated", kt = "x-storagemutated-1", jn = Ll(null, wl), sr = (wn.prototype._lock = function() {
        return K(!re.global), ++this._reculock, this._reculock !== 1 || re.global || (re.lockOwnerFor = this), this;
      }, wn.prototype._unlock = function() {
        if (K(!re.global), --this._reculock == 0) for (re.global || (re.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var n = this._blockedFuncs.shift();
          try {
            Qn(n[1], n[0]);
          } catch {
          }
        }
        return this;
      }, wn.prototype._locked = function() {
        return this._reculock && re.lockOwnerFor !== this;
      }, wn.prototype.create = function(n) {
        var t = this;
        if (!this.mode) return this;
        var u = this.db.idbdb, r = this.db._state.dbOpenError;
        if (K(!this.idbtrans), !n && !u) switch (r && r.name) {
          case "DatabaseClosedError":
            throw new Z.DatabaseClosed(r);
          case "MissingAPIError":
            throw new Z.MissingAPI(r.message, r);
          default:
            throw new Z.OpenFailed(r);
        }
        if (!this.active) throw new Z.TransactionInactive();
        return K(this._completion._state === null), (n = this.idbtrans = n || (this.db.core || u).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Be(function(c) {
          bl(c), t._reject(n.error);
        }), n.onabort = Be(function(c) {
          bl(c), t.active && t._reject(new Z.Abort(n.error)), t.active = !1, t.on("abort").fire(c);
        }), n.oncomplete = Be(function() {
          t.active = !1, t._resolve(), "mutatedParts" in n && jn.storagemutated.fire(n.mutatedParts);
        }), this;
      }, wn.prototype._promise = function(n, t, u) {
        var r = this;
        if (n === "readwrite" && this.mode !== "readwrite") return He(new Z.ReadOnly("Transaction is readonly"));
        if (!this.active) return He(new Z.TransactionInactive());
        if (this._locked()) return new ee(function(f, p) {
          r._blockedFuncs.push([function() {
            r._promise(n, t, u).then(f, p);
          }, re]);
        });
        if (u) return Un(function() {
          var f = new ee(function(p, g) {
            r._lock();
            var L = t(p, g, r);
            L && L.then && L.then(p, g);
          });
          return f.finally(function() {
            return r._unlock();
          }), f._lib = !0, f;
        });
        var c = new ee(function(f, p) {
          var g = t(f, p, r);
          g && g.then && g.then(f, p);
        });
        return c._lib = !0, c;
      }, wn.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, wn.prototype.waitFor = function(n) {
        var t, u = this._root(), r = ee.resolve(n);
        u._waitingFor ? u._waitingFor = u._waitingFor.then(function() {
          return r;
        }) : (u._waitingFor = r, u._waitingQueue = [], t = u.idbtrans.objectStore(u.storeNames[0]), function f() {
          for (++u._spinCount; u._waitingQueue.length; ) u._waitingQueue.shift()();
          u._waitingFor && (t.get(-1 / 0).onsuccess = f);
        }());
        var c = u._waitingFor;
        return new ee(function(f, p) {
          r.then(function(g) {
            return u._waitingQueue.push(Be(f.bind(null, g)));
          }, function(g) {
            return u._waitingQueue.push(Be(p.bind(null, g)));
          }).finally(function() {
            u._waitingFor === c && (u._waitingFor = null);
          });
        });
      }, wn.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new Z.Abort()));
      }, wn.prototype.table = function(n) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (I(t, n)) return t[n];
        var u = this.schema[n];
        if (!u) throw new Z.NotFound("Table " + n + " not part of transaction");
        return u = new this.db.Table(n, u, this), u.core = this.db.core.table(n), t[n] = u;
      }, wn);
      function wn() {
      }
      function Vt(n, t, u, r, c, f, p, g) {
        return { name: n, keyPath: t, unique: u, multi: r, auto: c, compound: f, src: (u && !p ? "&" : "") + (r ? "*" : "") + (c ? "++" : "") + fu(t), type: g };
      }
      function fu(n) {
        return typeof n == "string" ? n : n ? "[" + [].join.call(n, "+") + "]" : "";
      }
      function Bt(n, t, u) {
        return { name: n, primKey: t, indexes: u, mappedClass: null, idxByName: (r = function(c) {
          return [c.name, c];
        }, u.reduce(function(c, f, p) {
          return p = r(f, p), p && (c[p[0]] = p[1]), c;
        }, {})) };
        var r;
      }
      var Sl = function(n) {
        try {
          return n.only([[]]), Sl = function() {
            return [[]];
          }, [[]];
        } catch {
          return Sl = function() {
            return Jn;
          }, Jn;
        }
      };
      function Zt(n) {
        return n == null ? function() {
        } : typeof n == "string" ? (t = n).split(".").length === 1 ? function(u) {
          return u[t];
        } : function(u) {
          return se(u, t);
        } : function(u) {
          return se(u, n);
        };
        var t;
      }
      function du(n) {
        return [].slice.call(n);
      }
      var cr = 0;
      function Cl(n) {
        return n == null ? ":id" : typeof n == "string" ? n : "[".concat(n.join("+"), "]");
      }
      function or(n, t, L) {
        function r(S) {
          if (S.type === 3) return null;
          if (S.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var D = S.lower, b = S.upper, C = S.lowerOpen, S = S.upperOpen;
          return D === void 0 ? b === void 0 ? null : t.upperBound(b, !!S) : b === void 0 ? t.lowerBound(D, !!C) : t.bound(D, b, !!C, !!S);
        }
        function c(T) {
          var D, b = T.name;
          return { name: b, schema: T, mutate: function(C) {
            var S = C.trans, P = C.type, E = C.keys, N = C.values, F = C.range;
            return new Promise(function(G, Y) {
              G = Be(G);
              var H = S.objectStore(b), $ = H.keyPath == null, J = P === "put" || P === "add";
              if (!J && P !== "delete" && P !== "deleteRange") throw new Error("Invalid operation type: " + P);
              var Q, ne = (E || N || { length: 1 }).length;
              if (E && N && E.length !== N.length) throw new Error("Given keys array must have same length as given values array.");
              if (ne === 0) return G({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function xe(mn) {
                ++Ge, bl(mn);
              }
              var qe = [], he = [], Ge = 0;
              if (P === "deleteRange") {
                if (F.type === 4) return G({ numFailures: Ge, failures: he, results: [], lastResult: void 0 });
                F.type === 3 ? qe.push(Q = H.clear()) : qe.push(Q = H.delete(r(F)));
              } else {
                var $ = J ? $ ? [N, E] : [N, null] : [E, null], pe = $[0], rn = $[1];
                if (J) for (var sn = 0; sn < ne; ++sn) qe.push(Q = rn && rn[sn] !== void 0 ? H[P](pe[sn], rn[sn]) : H[P](pe[sn])), Q.onerror = xe;
                else for (sn = 0; sn < ne; ++sn) qe.push(Q = H[P](pe[sn])), Q.onerror = xe;
              }
              function ft(mn) {
                mn = mn.target.result, qe.forEach(function(tl, ui) {
                  return tl.error != null && (he[ui] = tl.error);
                }), G({ numFailures: Ge, failures: he, results: P === "delete" ? E : qe.map(function(tl) {
                  return tl.result;
                }), lastResult: mn });
              }
              Q.onerror = function(mn) {
                xe(mn), ft(mn);
              }, Q.onsuccess = ft;
            });
          }, getMany: function(C) {
            var S = C.trans, P = C.keys;
            return new Promise(function(E, N) {
              E = Be(E);
              for (var F, G = S.objectStore(b), Y = P.length, H = new Array(Y), $ = 0, J = 0, Q = function(qe) {
                qe = qe.target, H[qe._pos] = qe.result, ++J === $ && E(H);
              }, ne = bn(N), xe = 0; xe < Y; ++xe) P[xe] != null && ((F = G.get(P[xe]))._pos = xe, F.onsuccess = Q, F.onerror = ne, ++$);
              $ === 0 && E(H);
            });
          }, get: function(C) {
            var S = C.trans, P = C.key;
            return new Promise(function(E, N) {
              E = Be(E);
              var F = S.objectStore(b).get(P);
              F.onsuccess = function(G) {
                return E(G.target.result);
              }, F.onerror = bn(N);
            });
          }, query: (D = O, function(C) {
            return new Promise(function(S, P) {
              S = Be(S);
              var E, N, F, $ = C.trans, G = C.values, Y = C.limit, Q = C.query, H = Y === 1 / 0 ? void 0 : Y, J = Q.index, Q = Q.range, $ = $.objectStore(b), J = J.isPrimaryKey ? $ : $.index(J.name), Q = r(Q);
              if (Y === 0) return S({ result: [] });
              D ? ((H = G ? J.getAll(Q, H) : J.getAllKeys(Q, H)).onsuccess = function(ne) {
                return S({ result: ne.target.result });
              }, H.onerror = bn(P)) : (E = 0, N = !G && "openKeyCursor" in J ? J.openKeyCursor(Q) : J.openCursor(Q), F = [], N.onsuccess = function(ne) {
                var xe = N.result;
                return xe ? (F.push(G ? xe.value : xe.primaryKey), ++E === Y ? S({ result: F }) : void xe.continue()) : S({ result: F });
              }, N.onerror = bn(P));
            });
          }), openCursor: function(C) {
            var S = C.trans, P = C.values, E = C.query, N = C.reverse, F = C.unique;
            return new Promise(function(G, Y) {
              G = Be(G);
              var J = E.index, H = E.range, $ = S.objectStore(b), $ = J.isPrimaryKey ? $ : $.index(J.name), J = N ? F ? "prevunique" : "prev" : F ? "nextunique" : "next", Q = !P && "openKeyCursor" in $ ? $.openKeyCursor(r(H), J) : $.openCursor(r(H), J);
              Q.onerror = bn(Y), Q.onsuccess = Be(function(ne) {
                var xe, qe, he, Ge, pe = Q.result;
                pe ? (pe.___id = ++cr, pe.done = !1, xe = pe.continue.bind(pe), qe = (qe = pe.continuePrimaryKey) && qe.bind(pe), he = pe.advance.bind(pe), Ge = function() {
                  throw new Error("Cursor not stopped");
                }, pe.trans = S, pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = function() {
                  throw new Error("Cursor not started");
                }, pe.fail = Be(Y), pe.next = function() {
                  var rn = this, sn = 1;
                  return this.start(function() {
                    return sn-- ? rn.continue() : rn.stop();
                  }).then(function() {
                    return rn;
                  });
                }, pe.start = function(rn) {
                  function sn() {
                    if (Q.result) try {
                      rn();
                    } catch (mn) {
                      pe.fail(mn);
                    }
                    else pe.done = !0, pe.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, pe.stop();
                  }
                  var ft = new Promise(function(mn, tl) {
                    mn = Be(mn), Q.onerror = bn(tl), pe.fail = tl, pe.stop = function(ui) {
                      pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = Ge, mn(ui);
                    };
                  });
                  return Q.onsuccess = Be(function(mn) {
                    Q.onsuccess = sn, sn();
                  }), pe.continue = xe, pe.continuePrimaryKey = qe, pe.advance = he, sn(), ft;
                }, G(pe)) : G(null);
              }, Y);
            });
          }, count: function(C) {
            var S = C.query, P = C.trans, E = S.index, N = S.range;
            return new Promise(function(F, G) {
              var Y = P.objectStore(b), H = E.isPrimaryKey ? Y : Y.index(E.name), Y = r(N), H = Y ? H.count(Y) : H.count();
              H.onsuccess = Be(function($) {
                return F($.target.result);
              }), H.onerror = bn(G);
            });
          } };
        }
        var f, p, g, w = (p = L, g = du((f = n).objectStoreNames), { schema: { name: f.name, tables: g.map(function(T) {
          return p.objectStore(T);
        }).map(function(T) {
          var D = T.keyPath, S = T.autoIncrement, b = d(D), C = {}, S = { name: T.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: D == null, compound: b, keyPath: D, autoIncrement: S, unique: !0, extractKey: Zt(D) }, indexes: du(T.indexNames).map(function(P) {
            return T.index(P);
          }).map(function(F) {
            var E = F.name, N = F.unique, G = F.multiEntry, F = F.keyPath, G = { name: E, compound: d(F), keyPath: F, unique: N, multiEntry: G, extractKey: Zt(F) };
            return C[Cl(F)] = G;
          }), getIndexByKeyPath: function(P) {
            return C[Cl(P)];
          } };
          return C[":id"] = S.primaryKey, D != null && (C[Cl(D)] = S.primaryKey), S;
        }) }, hasGetAll: 0 < g.length && "getAll" in p.objectStore(g[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), L = w.schema, O = w.hasGetAll, w = L.tables.map(c), v = {};
        return w.forEach(function(T) {
          return v[T.name] = T;
        }), { stack: "dbcore", transaction: n.transaction.bind(n), table: function(T) {
          if (!v[T]) throw new Error("Table '".concat(T, "' not found"));
          return v[T];
        }, MIN_KEY: -1 / 0, MAX_KEY: Sl(t), schema: L };
      }
      function mr(n, t, u, r) {
        var c = u.IDBKeyRange;
        return u.indexedDB, { dbcore: (r = or(t, c, r), n.dbcore.reduce(function(f, p) {
          return p = p.create, a(a({}, f), p(f));
        }, r)) };
      }
      function nt(n, r) {
        var u = r.db, r = mr(n._middlewares, u, n._deps, r);
        n.core = r.dbcore, n.tables.forEach(function(c) {
          var f = c.name;
          n.core.schema.tables.some(function(p) {
            return p.name === f;
          }) && (c.core = n.core.table(f), n[f] instanceof n.Table && (n[f].core = c.core));
        });
      }
      function lt(n, t, u, r) {
        u.forEach(function(c) {
          var f = r[c];
          t.forEach(function(p) {
            var g = function L(O, w) {
              return U(O, w) || (O = x(O)) && L(O, w);
            }(p, c);
            (!g || "value" in g && g.value === void 0) && (p === n.Transaction.prototype || p instanceof n.Transaction ? R(p, c, { get: function() {
              return this.table(c);
            }, set: function(L) {
              A(this, c, { value: L, writable: !0, configurable: !0, enumerable: !0 });
            } }) : p[c] = new n.Table(c, f));
          });
        });
      }
      function Ut(n, t) {
        t.forEach(function(u) {
          for (var r in u) u[r] instanceof n.Table && delete u[r];
        });
      }
      function fr(n, t) {
        return n._cfg.version - t._cfg.version;
      }
      function dr(n, t, u, r) {
        var c = n._dbSchema;
        u.objectStoreNames.contains("$meta") && !c.$meta && (c.$meta = Bt("$meta", hu("")[0], []), n._storeNames.push("$meta"));
        var f = n._createTransaction("readwrite", n._storeNames, c);
        f.create(u), f._completion.catch(r);
        var p = f._reject.bind(f), g = re.transless || re;
        Un(function() {
          return re.trans = f, re.transless = g, t !== 0 ? (nt(n, u), O = t, ((L = f).storeNames.includes("$meta") ? L.table("$meta").get("version").then(function(w) {
            return w ?? O;
          }) : ee.resolve(O)).then(function(w) {
            return T = w, D = f, b = u, C = [], w = (v = n)._versions, S = v._dbSchema = it(0, v.idbdb, b), (w = w.filter(function(P) {
              return P._cfg.version >= T;
            })).length !== 0 ? (w.forEach(function(P) {
              C.push(function() {
                var E = S, N = P._cfg.dbschema;
                ut(v, E, b), ut(v, N, b), S = v._dbSchema = N;
                var F = Kt(E, N);
                F.add.forEach(function(J) {
                  Gt(b, J[0], J[1].primKey, J[1].indexes);
                }), F.change.forEach(function(J) {
                  if (J.recreate) throw new Z.Upgrade("Not yet support for changing primary key");
                  var Q = b.objectStore(J.name);
                  J.add.forEach(function(ne) {
                    return tt(Q, ne);
                  }), J.change.forEach(function(ne) {
                    Q.deleteIndex(ne.name), tt(Q, ne);
                  }), J.del.forEach(function(ne) {
                    return Q.deleteIndex(ne);
                  });
                });
                var G = P._cfg.contentUpgrade;
                if (G && P._cfg.version > T) {
                  nt(v, b), D._memoizedTables = {};
                  var Y = me(N);
                  F.del.forEach(function(J) {
                    Y[J] = E[J];
                  }), Ut(v, [v.Transaction.prototype]), lt(v, [v.Transaction.prototype], m(Y), Y), D.schema = Y;
                  var H, $ = Ye(G);
                  return $ && cl(), F = ee.follow(function() {
                    var J;
                    (H = G(D)) && $ && (J = Kn.bind(null, null), H.then(J, J));
                  }), H && typeof H.then == "function" ? ee.resolve(H) : F.then(function() {
                    return H;
                  });
                }
              }), C.push(function(E) {
                var N, F, G = P._cfg.dbschema;
                N = G, F = E, [].slice.call(F.db.objectStoreNames).forEach(function(Y) {
                  return N[Y] == null && F.db.deleteObjectStore(Y);
                }), Ut(v, [v.Transaction.prototype]), lt(v, [v.Transaction.prototype], v._storeNames, v._dbSchema), D.schema = v._dbSchema;
              }), C.push(function(E) {
                v.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(v.idbdb.version / 10) === P._cfg.version ? (v.idbdb.deleteObjectStore("$meta"), delete v._dbSchema.$meta, v._storeNames = v._storeNames.filter(function(N) {
                  return N !== "$meta";
                })) : E.objectStore("$meta").put(P._cfg.version, "version"));
              });
            }), function P() {
              return C.length ? ee.resolve(C.shift()(D.idbtrans)).then(P) : ee.resolve();
            }().then(function() {
              pu(S, b);
            })) : ee.resolve();
            var v, T, D, b, C, S;
          }).catch(p)) : (m(c).forEach(function(w) {
            Gt(u, w, c[w].primKey, c[w].indexes);
          }), nt(n, u), void ee.follow(function() {
            return n.on.populate.fire(f);
          }).catch(p));
          var L, O;
        });
      }
      function pr(n, t) {
        pu(n._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var u = it(0, n.idbdb, t);
        ut(n, n._dbSchema, t);
        for (var r = 0, c = Kt(u, n._dbSchema).change; r < c.length; r++) {
          var f = function(p) {
            if (p.change.length || p.recreate) return console.warn("Unable to patch indexes of table ".concat(p.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var g = t.objectStore(p.name);
            p.add.forEach(function(L) {
              be && console.debug("Dexie upgrade patch: Creating missing index ".concat(p.name, ".").concat(L.src)), tt(g, L);
            });
          }(c[r]);
          if (typeof f == "object") return f.value;
        }
      }
      function Kt(n, t) {
        var u, r = { del: [], add: [], change: [] };
        for (u in n) t[u] || r.del.push(u);
        for (u in t) {
          var c = n[u], f = t[u];
          if (c) {
            var p = { name: u, def: f, recreate: !1, del: [], add: [], change: [] };
            if ("" + (c.primKey.keyPath || "") != "" + (f.primKey.keyPath || "") || c.primKey.auto !== f.primKey.auto) p.recreate = !0, r.change.push(p);
            else {
              var g = c.idxByName, L = f.idxByName, O = void 0;
              for (O in g) L[O] || p.del.push(O);
              for (O in L) {
                var w = g[O], v = L[O];
                w ? w.src !== v.src && p.change.push(v) : p.add.push(v);
              }
              (0 < p.del.length || 0 < p.add.length || 0 < p.change.length) && r.change.push(p);
            }
          } else r.add.push([u, f]);
        }
        return r;
      }
      function Gt(n, t, u, r) {
        var c = n.db.createObjectStore(t, u.keyPath ? { keyPath: u.keyPath, autoIncrement: u.auto } : { autoIncrement: u.auto });
        return r.forEach(function(f) {
          return tt(c, f);
        }), c;
      }
      function pu(n, t) {
        m(n).forEach(function(u) {
          t.db.objectStoreNames.contains(u) || (be && console.debug("Dexie: Creating missing table", u), Gt(t, u, n[u].primKey, n[u].indexes));
        });
      }
      function tt(n, t) {
        n.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function it(n, t, u) {
        var r = {};
        return X(t.objectStoreNames, 0).forEach(function(c) {
          for (var f = u.objectStore(c), p = Vt(fu(O = f.keyPath), O || "", !0, !1, !!f.autoIncrement, O && typeof O != "string", !0), g = [], L = 0; L < f.indexNames.length; ++L) {
            var w = f.index(f.indexNames[L]), O = w.keyPath, w = Vt(w.name, O, !!w.unique, !!w.multiEntry, !1, O && typeof O != "string", !1);
            g.push(w);
          }
          r[c] = Bt(c, p, g);
        }), r;
      }
      function ut(n, t, u) {
        for (var r = u.db.objectStoreNames, c = 0; c < r.length; ++c) {
          var f = r[c], p = u.objectStore(f);
          n._hasGetAll = "getAll" in p;
          for (var g = 0; g < p.indexNames.length; ++g) {
            var L = p.indexNames[g], O = p.index(L).keyPath, w = typeof O == "string" ? O : "[" + X(O).join("+") + "]";
            !t[f] || (O = t[f].idxByName[w]) && (O.name = L, delete t[f].idxByName[w], t[f].idxByName[L] = O);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && o.WorkerGlobalScope && o instanceof o.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1);
      }
      function hu(n) {
        return n.split(",").map(function(t, u) {
          var f = t.split(":"), r = (c = f[1]) === null || c === void 0 ? void 0 : c.trim(), c = (t = f[0].trim()).replace(/([&*]|\+\+)/g, ""), f = /^\[/.test(c) ? c.match(/^\[(.*)\]$/)[1].split("+") : c;
          return Vt(c, f || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), d(f), u === 0, r);
        });
      }
      var hr = (dl.prototype._createTableSchema = Bt, dl.prototype._parseIndexSyntax = hu, dl.prototype._parseStoresSpec = function(n, t) {
        var u = this;
        m(n).forEach(function(r) {
          if (n[r] !== null) {
            var c = u._parseIndexSyntax(n[r]), f = c.shift();
            if (!f) throw new Z.Schema("Invalid schema for table " + r + ": " + n[r]);
            if (f.unique = !0, f.multi) throw new Z.Schema("Primary key cannot be multiEntry*");
            c.forEach(function(p) {
              if (p.auto) throw new Z.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!p.keyPath) throw new Z.Schema("Index must have a name and cannot be an empty string");
            }), c = u._createTableSchema(r, f, c), t[r] = c;
          }
        });
      }, dl.prototype.stores = function(u) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? h(this._cfg.storesSource, u) : u;
        var u = t._versions, r = {}, c = {};
        return u.forEach(function(f) {
          h(r, f._cfg.storesSource), c = f._cfg.dbschema = {}, f._parseStoresSpec(r, c);
        }), t._dbSchema = c, Ut(t, [t._allTables, t, t.Transaction.prototype]), lt(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], m(c), c), t._storeNames = m(c), this;
      }, dl.prototype.upgrade = function(n) {
        return this._cfg.contentUpgrade = _e(this._cfg.contentUpgrade || Oe, n), this;
      }, dl);
      function dl() {
      }
      function zt(n, t) {
        var u = n._dbNamesDB;
        return u || (u = n._dbNamesDB = new En(Wl, { addons: [], indexedDB: n, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), u.table("dbnames");
      }
      function jt(n) {
        return n && typeof n.databases == "function";
      }
      function Ht(n) {
        return Un(function() {
          return re.letThrough = !0, n();
        });
      }
      function $t(n) {
        return !("from" in n);
      }
      var an = function(n, t) {
        if (!this) {
          var u = new an();
          return n && "d" in n && h(u, n), u;
        }
        h(this, arguments.length ? { d: 1, from: n, to: 1 < arguments.length ? t : n } : { d: 0 });
      };
      function Tl(n, t, u) {
        var r = Ce(t, u);
        if (!isNaN(r)) {
          if (0 < r) throw RangeError();
          if ($t(n)) return h(n, { from: t, to: u, d: 1 });
          var c = n.l, r = n.r;
          if (Ce(u, n.from) < 0) return c ? Tl(c, t, u) : n.l = { from: t, to: u, d: 1, l: null, r: null }, vu(n);
          if (0 < Ce(t, n.to)) return r ? Tl(r, t, u) : n.r = { from: t, to: u, d: 1, l: null, r: null }, vu(n);
          Ce(t, n.from) < 0 && (n.from = t, n.l = null, n.d = r ? r.d + 1 : 1), 0 < Ce(u, n.to) && (n.to = u, n.r = null, n.d = n.l ? n.l.d + 1 : 1), u = !n.r, c && !n.l && Pl(n, c), r && u && Pl(n, r);
        }
      }
      function Pl(n, t) {
        $t(t) || function u(r, L) {
          var f = L.from, p = L.to, g = L.l, L = L.r;
          Tl(r, f, p), g && u(r, g), L && u(r, L);
        }(n, t);
      }
      function gu(n, t) {
        var u = at(t), r = u.next();
        if (r.done) return !1;
        for (var c = r.value, f = at(n), p = f.next(c.from), g = p.value; !r.done && !p.done; ) {
          if (Ce(g.from, c.to) <= 0 && 0 <= Ce(g.to, c.from)) return !0;
          Ce(c.from, g.from) < 0 ? c = (r = u.next(g.from)).value : g = (p = f.next(c.from)).value;
        }
        return !1;
      }
      function at(n) {
        var t = $t(n) ? null : { s: 0, n };
        return { next: function(u) {
          for (var r = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, r) for (; t.n.l && Ce(u, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !r || Ce(u, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function vu(n) {
        var t, u, r = (((t = n.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((u = n.l) === null || u === void 0 ? void 0 : u.d) || 0), c = 1 < r ? "r" : r < -1 ? "l" : "";
        c && (t = c == "r" ? "l" : "r", u = a({}, n), r = n[c], n.from = r.from, n.to = r.to, n[c] = r[c], u[c] = r[t], (n[t] = u).d = xu(u)), n.d = xu(n);
      }
      function xu(u) {
        var t = u.r, u = u.l;
        return (t ? u ? Math.max(t.d, u.d) : t.d : u ? u.d : 0) + 1;
      }
      function rt(n, t) {
        return m(t).forEach(function(u) {
          n[u] ? Pl(n[u], t[u]) : n[u] = function r(c) {
            var f, p, g = {};
            for (f in c) I(c, f) && (p = c[f], g[f] = !p || typeof p != "object" || Ie.has(p.constructor) ? p : r(p));
            return g;
          }(t[u]);
        }), n;
      }
      function Wt(n, t) {
        return n.all || t.all || Object.keys(n).some(function(u) {
          return t[u] && gu(t[u], n[u]);
        });
      }
      q(an.prototype, ((In = { add: function(n) {
        return Pl(this, n), this;
      }, addKey: function(n) {
        return Tl(this, n, n), this;
      }, addKeys: function(n) {
        var t = this;
        return n.forEach(function(u) {
          return Tl(t, u, u);
        }), this;
      }, hasKey: function(n) {
        var t = at(this).next(n).value;
        return t && Ce(t.from, n) <= 0 && 0 <= Ce(t.to, n);
      } })[ge] = function() {
        return at(this);
      }, In));
      var nl = {}, Yt = {}, Xt = !1;
      function st(n) {
        rt(Yt, n), Xt || (Xt = !0, setTimeout(function() {
          Xt = !1, Qt(Yt, !(Yt = {}));
        }, 0));
      }
      function Qt(n, t) {
        t === void 0 && (t = !1);
        var u = /* @__PURE__ */ new Set();
        if (n.all) for (var r = 0, c = Object.values(nl); r < c.length; r++) yu(p = c[r], n, u, t);
        else for (var f in n) {
          var p, g = /^idb\:\/\/(.*)\/(.*)\//.exec(f);
          g && (f = g[1], g = g[2], (p = nl["idb://".concat(f, "/").concat(g)]) && yu(p, n, u, t));
        }
        u.forEach(function(L) {
          return L();
        });
      }
      function yu(n, t, u, r) {
        for (var c = [], f = 0, p = Object.entries(n.queries.query); f < p.length; f++) {
          for (var g = p[f], L = g[0], O = [], w = 0, v = g[1]; w < v.length; w++) {
            var T = v[w];
            Wt(t, T.obsSet) ? T.subscribers.forEach(function(S) {
              return u.add(S);
            }) : r && O.push(T);
          }
          r && c.push([L, O]);
        }
        if (r) for (var D = 0, b = c; D < b.length; D++) {
          var C = b[D], L = C[0], O = C[1];
          n.queries.query[L] = O;
        }
      }
      function gr(n) {
        var t = n._state, u = n._deps.indexedDB;
        if (t.isBeingOpened || n.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? He(t.dbOpenError) : n;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var r = t.openCanceller, c = Math.round(10 * n.verno), f = !1;
        function p() {
          if (t.openCanceller !== r) throw new Z.DatabaseClosed("db.open() was cancelled");
        }
        function g() {
          return new ee(function(T, D) {
            if (p(), !u) throw new Z.MissingAPI();
            var b = n.name, C = t.autoSchema || !c ? u.open(b) : u.open(b, c);
            if (!C) throw new Z.MissingAPI();
            C.onerror = bn(D), C.onblocked = Be(n._fireOnBlocked), C.onupgradeneeded = Be(function(S) {
              var P;
              w = C.transaction, t.autoSchema && !n._options.allowEmptyDB ? (C.onerror = bl, w.abort(), C.result.close(), (P = u.deleteDatabase(b)).onsuccess = P.onerror = Be(function() {
                D(new Z.NoSuchDatabase("Database ".concat(b, " doesnt exist")));
              })) : (w.onerror = bn(D), S = S.oldVersion > Math.pow(2, 62) ? 0 : S.oldVersion, v = S < 1, n.idbdb = C.result, f && pr(n, w), dr(n, S / 10, w, D));
            }, D), C.onsuccess = Be(function() {
              w = null;
              var S, P, E, N, F, G = n.idbdb = C.result, Y = X(G.objectStoreNames);
              if (0 < Y.length) try {
                var H = G.transaction((N = Y).length === 1 ? N[0] : N, "readonly");
                if (t.autoSchema) P = G, E = H, (S = n).verno = P.version / 10, E = S._dbSchema = it(0, P, E), S._storeNames = X(P.objectStoreNames, 0), lt(S, [S._allTables], m(E), E);
                else if (ut(n, n._dbSchema, H), ((F = Kt(it(0, (F = n).idbdb, H), F._dbSchema)).add.length || F.change.some(function($) {
                  return $.add.length || $.change.length;
                })) && !f) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), G.close(), c = G.version + 1, f = !0, T(g());
                nt(n, H);
              } catch {
              }
              ol.push(n), G.onversionchange = Be(function($) {
                t.vcFired = !0, n.on("versionchange").fire($);
              }), G.onclose = Be(function($) {
                n.on("close").fire($);
              }), v && (F = n._deps, H = b, G = F.indexedDB, F = F.IDBKeyRange, jt(G) || H === Wl || zt(G, F).put({ name: H }).catch(Oe)), T();
            }, D);
          }).catch(function(T) {
            switch (T?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), g();
                break;
              case "VersionError":
                if (0 < c) return c = 0, g();
            }
            return ee.reject(T);
          });
        }
        var L, O = t.dbReadyResolve, w = null, v = !1;
        return ee.race([r, (typeof navigator > "u" ? ee.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(T) {
          function D() {
            return indexedDB.databases().finally(T);
          }
          L = setInterval(D, 100), D();
        }).finally(function() {
          return clearInterval(L);
        }) : Promise.resolve()).then(g)]).then(function() {
          return p(), t.onReadyBeingFired = [], ee.resolve(Ht(function() {
            return n.on.ready.fire(n.vip);
          })).then(function T() {
            if (0 < t.onReadyBeingFired.length) {
              var D = t.onReadyBeingFired.reduce(_e, Oe);
              return t.onReadyBeingFired = [], ee.resolve(Ht(function() {
                return D(n.vip);
              })).then(T);
            }
          });
        }).finally(function() {
          t.openCanceller === r && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(T) {
          t.dbOpenError = T;
          try {
            w && w.abort();
          } catch {
          }
          return r === t.openCanceller && n._close(), He(T);
        }).finally(function() {
          t.openComplete = !0, O();
        }).then(function() {
          var T;
          return v && (T = {}, n.tables.forEach(function(D) {
            D.schema.indexes.forEach(function(b) {
              b.name && (T["idb://".concat(n.name, "/").concat(D.name, "/").concat(b.name)] = new an(-1 / 0, [[[]]]));
            }), T["idb://".concat(n.name, "/").concat(D.name, "/")] = T["idb://".concat(n.name, "/").concat(D.name, "/:dels")] = new an(-1 / 0, [[[]]]);
          }), jn(wl).fire(T), Qt(T, !0)), n;
        });
      }
      function Jt(n) {
        function t(f) {
          return n.next(f);
        }
        var u = c(t), r = c(function(f) {
          return n.throw(f);
        });
        function c(f) {
          return function(L) {
            var g = f(L), L = g.value;
            return g.done ? L : L && typeof L.then == "function" ? L.then(u, r) : d(L) ? Promise.all(L).then(u, r) : u(L);
          };
        }
        return c(t)();
      }
      function ct(n, t, u) {
        for (var r = d(n) ? n.slice() : [n], c = 0; c < u; ++c) r.push(t);
        return r;
      }
      var vr = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema, c = {}, f = [];
          function p(v, T, D) {
            var b = Cl(v), C = c[b] = c[b] || [], S = v == null ? 0 : typeof v == "string" ? 1 : v.length, P = 0 < T, P = a(a({}, D), { name: P ? "".concat(b, "(virtual-from:").concat(D.name, ")") : D.name, lowLevelIndex: D, isVirtual: P, keyTail: T, keyLength: S, extractKey: Zt(v), unique: !P && D.unique });
            return C.push(P), P.isPrimaryKey || f.push(P), 1 < S && p(S === 2 ? v[0] : v.slice(0, S - 1), T + 1, D), C.sort(function(E, N) {
              return E.keyTail - N.keyTail;
            }), P;
          }
          t = p(r.primaryKey.keyPath, 0, r.primaryKey), c[":id"] = [t];
          for (var g = 0, L = r.indexes; g < L.length; g++) {
            var O = L[g];
            p(O.keyPath, 0, O);
          }
          function w(v) {
            var T, D = v.query.index;
            return D.isVirtual ? a(a({}, v), { query: { index: D.lowLevelIndex, range: (T = v.query.range, D = D.keyTail, { type: T.type === 1 ? 2 : T.type, lower: ct(T.lower, T.lowerOpen ? n.MAX_KEY : n.MIN_KEY, D), lowerOpen: !0, upper: ct(T.upper, T.upperOpen ? n.MIN_KEY : n.MAX_KEY, D), upperOpen: !0 }) } }) : v;
          }
          return a(a({}, u), { schema: a(a({}, r), { primaryKey: t, indexes: f, getIndexByKeyPath: function(v) {
            return (v = c[Cl(v)]) && v[0];
          } }), count: function(v) {
            return u.count(w(v));
          }, query: function(v) {
            return u.query(w(v));
          }, openCursor: function(v) {
            var T = v.query.index, D = T.keyTail, b = T.isVirtual, C = T.keyLength;
            return b ? u.openCursor(w(v)).then(function(P) {
              return P && S(P);
            }) : u.openCursor(v);
            function S(P) {
              return Object.create(P, { continue: { value: function(E) {
                E != null ? P.continue(ct(E, v.reverse ? n.MAX_KEY : n.MIN_KEY, D)) : v.unique ? P.continue(P.key.slice(0, C).concat(v.reverse ? n.MIN_KEY : n.MAX_KEY, D)) : P.continue();
              } }, continuePrimaryKey: { value: function(E, N) {
                P.continuePrimaryKey(ct(E, n.MAX_KEY, D), N);
              } }, primaryKey: { get: function() {
                return P.primaryKey;
              } }, key: { get: function() {
                var E = P.key;
                return C === 1 ? E[0] : E.slice(0, C);
              } }, value: { get: function() {
                return P.value;
              } } });
            }
          } });
        } });
      } };
      function ei(n, t, u, r) {
        return u = u || {}, r = r || "", m(n).forEach(function(c) {
          var f, p, g;
          I(t, c) ? (f = n[c], p = t[c], typeof f == "object" && typeof p == "object" && f && p ? (g = Se(f)) !== Se(p) ? u[r + c] = t[c] : g === "Object" ? ei(f, p, u, r + c + ".") : f !== p && (u[r + c] = t[c]) : f !== p && (u[r + c] = t[c])) : u[r + c] = void 0;
        }), m(t).forEach(function(c) {
          I(n, c) || (u[r + c] = t[c]);
        }), u;
      }
      function ni(n, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(n.extractKey);
      }
      var xr = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema.primaryKey;
          return a(a({}, u), { mutate: function(c) {
            var f = re.trans, p = f.table(t).hook, g = p.deleting, L = p.creating, O = p.updating;
            switch (c.type) {
              case "add":
                if (L.fire === Oe) break;
                return f._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "put":
                if (L.fire === Oe && O.fire === Oe) break;
                return f._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "delete":
                if (g.fire === Oe) break;
                return f._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "deleteRange":
                if (g.fire === Oe) break;
                return f._promise("readwrite", function() {
                  return function v(T, D, b) {
                    return u.query({ trans: T, values: !1, query: { index: r, range: D }, limit: b }).then(function(C) {
                      var S = C.result;
                      return w({ type: "delete", keys: S, trans: T }).then(function(P) {
                        return 0 < P.numFailures ? Promise.reject(P.failures[0]) : S.length < b ? { failures: [], numFailures: 0, lastResult: void 0 } : v(T, a(a({}, D), { lower: S[S.length - 1], lowerOpen: !0 }), b);
                      });
                    });
                  }(c.trans, c.range, 1e4);
                }, !0);
            }
            return u.mutate(c);
            function w(v) {
              var T, D, b, C = re.trans, S = v.keys || ni(r, v);
              if (!S) throw new Error("Keys missing");
              return (v = v.type === "add" || v.type === "put" ? a(a({}, v), { keys: S }) : a({}, v)).type !== "delete" && (v.values = s([], v.values)), v.keys && (v.keys = s([], v.keys)), T = u, b = S, ((D = v).type === "add" ? Promise.resolve([]) : T.getMany({ trans: D.trans, keys: b, cache: "immutable" })).then(function(P) {
                var E = S.map(function(N, F) {
                  var G, Y, H, $ = P[F], J = { onerror: null, onsuccess: null };
                  return v.type === "delete" ? g.fire.call(J, N, $, C) : v.type === "add" || $ === void 0 ? (G = L.fire.call(J, N, v.values[F], C), N == null && G != null && (v.keys[F] = N = G, r.outbound || te(v.values[F], r.keyPath, N))) : (G = ei($, v.values[F]), (Y = O.fire.call(J, G, N, $, C)) && (H = v.values[F], Object.keys(Y).forEach(function(Q) {
                    I(H, Q) ? H[Q] = Y[Q] : te(H, Q, Y[Q]);
                  }))), J;
                });
                return u.mutate(v).then(function(N) {
                  for (var F = N.failures, G = N.results, Y = N.numFailures, N = N.lastResult, H = 0; H < S.length; ++H) {
                    var $ = (G || S)[H], J = E[H];
                    $ == null ? J.onerror && J.onerror(F[H]) : J.onsuccess && J.onsuccess(v.type === "put" && P[H] ? v.values[H] : $);
                  }
                  return { failures: F, results: G, numFailures: Y, lastResult: N };
                }).catch(function(N) {
                  return E.forEach(function(F) {
                    return F.onerror && F.onerror(N);
                  }), Promise.reject(N);
                });
              });
            }
          } });
        } });
      } };
      function Iu(n, t, u) {
        try {
          if (!t || t.keys.length < n.length) return null;
          for (var r = [], c = 0, f = 0; c < t.keys.length && f < n.length; ++c) Ce(t.keys[c], n[f]) === 0 && (r.push(u ? ve(t.values[c]) : t.values[c]), ++f);
          return r.length === n.length ? r : null;
        } catch {
          return null;
        }
      }
      var yr = { stack: "dbcore", level: -1, create: function(n) {
        return { table: function(t) {
          var u = n.table(t);
          return a(a({}, u), { getMany: function(r) {
            if (!r.cache) return u.getMany(r);
            var c = Iu(r.keys, r.trans._cache, r.cache === "clone");
            return c ? ee.resolve(c) : u.getMany(r).then(function(f) {
              return r.trans._cache = { keys: r.keys, values: r.cache === "clone" ? ve(f) : f }, f;
            });
          }, mutate: function(r) {
            return r.type !== "add" && (r.trans._cache = null), u.mutate(r);
          } });
        } };
      } };
      function Lu(n, t) {
        return n.trans.mode === "readonly" && !!n.subscr && !n.trans.explicit && n.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function Du(n, t) {
        switch (n) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var Ir = { stack: "dbcore", level: 0, name: "Observability", create: function(n) {
        var t = n.schema.name, u = new an(n.MIN_KEY, n.MAX_KEY);
        return a(a({}, n), { transaction: function(r, c, f) {
          if (re.subscr && c !== "readonly") throw new Z.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(re.querier));
          return n.transaction(r, c, f);
        }, table: function(r) {
          var c = n.table(r), f = c.schema, p = f.primaryKey, v = f.indexes, g = p.extractKey, L = p.outbound, O = p.autoIncrement && v.filter(function(D) {
            return D.compound && D.keyPath.includes(p.keyPath);
          }), w = a(a({}, c), { mutate: function(D) {
            function b(Q) {
              return Q = "idb://".concat(t, "/").concat(r, "/").concat(Q), N[Q] || (N[Q] = new an());
            }
            var C, S, P, E = D.trans, N = D.mutatedParts || (D.mutatedParts = {}), F = b(""), G = b(":dels"), Y = D.type, J = D.type === "deleteRange" ? [D.range] : D.type === "delete" ? [D.keys] : D.values.length < 50 ? [ni(p, D).filter(function(Q) {
              return Q;
            }), D.values] : [], H = J[0], $ = J[1], J = D.trans._cache;
            return d(H) ? (F.addKeys(H), (J = Y === "delete" || H.length === $.length ? Iu(H, J) : null) || G.addKeys(H), (J || $) && (C = b, S = J, P = $, f.indexes.forEach(function(Q) {
              var ne = C(Q.name || "");
              function xe(he) {
                return he != null ? Q.extractKey(he) : null;
              }
              function qe(he) {
                return Q.multiEntry && d(he) ? he.forEach(function(Ge) {
                  return ne.addKey(Ge);
                }) : ne.addKey(he);
              }
              (S || P).forEach(function(he, rn) {
                var pe = S && xe(S[rn]), rn = P && xe(P[rn]);
                Ce(pe, rn) !== 0 && (pe != null && qe(pe), rn != null && qe(rn));
              });
            }))) : H ? ($ = { from: ($ = H.lower) !== null && $ !== void 0 ? $ : n.MIN_KEY, to: ($ = H.upper) !== null && $ !== void 0 ? $ : n.MAX_KEY }, G.add($), F.add($)) : (F.add(u), G.add(u), f.indexes.forEach(function(Q) {
              return b(Q.name).add(u);
            })), c.mutate(D).then(function(Q) {
              return !H || D.type !== "add" && D.type !== "put" || (F.addKeys(Q.results), O && O.forEach(function(ne) {
                for (var xe = D.values.map(function(pe) {
                  return ne.extractKey(pe);
                }), qe = ne.keyPath.findIndex(function(pe) {
                  return pe === p.keyPath;
                }), he = 0, Ge = Q.results.length; he < Ge; ++he) xe[he][qe] = Q.results[he];
                b(ne.name).addKeys(xe);
              })), E.mutatedParts = rt(E.mutatedParts || {}, N), Q;
            });
          } }), v = function(b) {
            var C = b.query, b = C.index, C = C.range;
            return [b, new an((b = C.lower) !== null && b !== void 0 ? b : n.MIN_KEY, (C = C.upper) !== null && C !== void 0 ? C : n.MAX_KEY)];
          }, T = { get: function(D) {
            return [p, new an(D.key)];
          }, getMany: function(D) {
            return [p, new an().addKeys(D.keys)];
          }, count: v, query: v, openCursor: v };
          return m(T).forEach(function(D) {
            w[D] = function(b) {
              var C = re.subscr, S = !!C, P = Lu(re, c) && Du(D, b) ? b.obsSet = {} : C;
              if (S) {
                var E = function($) {
                  return $ = "idb://".concat(t, "/").concat(r, "/").concat($), P[$] || (P[$] = new an());
                }, N = E(""), F = E(":dels"), C = T[D](b), S = C[0], C = C[1];
                if ((D === "query" && S.isPrimaryKey && !b.values ? F : E(S.name || "")).add(C), !S.isPrimaryKey) {
                  if (D !== "count") {
                    var G = D === "query" && L && b.values && c.query(a(a({}, b), { values: !1 }));
                    return c[D].apply(this, arguments).then(function($) {
                      if (D === "query") {
                        if (L && b.values) return G.then(function(xe) {
                          return xe = xe.result, N.addKeys(xe), $;
                        });
                        var J = b.values ? $.result.map(g) : $.result;
                        (b.values ? N : F).addKeys(J);
                      } else if (D === "openCursor") {
                        var Q = $, ne = b.values;
                        return Q && Object.create(Q, { key: { get: function() {
                          return F.addKey(Q.primaryKey), Q.key;
                        } }, primaryKey: { get: function() {
                          var xe = Q.primaryKey;
                          return F.addKey(xe), xe;
                        } }, value: { get: function() {
                          return ne && N.addKey(Q.primaryKey), Q.value;
                        } } });
                      }
                      return $;
                    });
                  }
                  F.add(u);
                }
              }
              return c[D].apply(this, arguments);
            };
          }), w;
        } });
      } };
      function Ou(n, t, u) {
        if (u.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var r = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return u.numFailures === r ? null : (t = a({}, t), d(t.keys) && (t.keys = t.keys.filter(function(c, f) {
          return !(f in u.failures);
        })), "values" in t && d(t.values) && (t.values = t.values.filter(function(c, f) {
          return !(f in u.failures);
        })), t);
      }
      function li(n, t) {
        return u = n, ((r = t).lower === void 0 || (r.lowerOpen ? 0 < Ce(u, r.lower) : 0 <= Ce(u, r.lower))) && (n = n, (t = t).upper === void 0 || (t.upperOpen ? Ce(n, t.upper) < 0 : Ce(n, t.upper) <= 0));
        var u, r;
      }
      function bu(n, t, T, r, c, f) {
        if (!T || T.length === 0) return n;
        var p = t.query.index, g = p.multiEntry, L = t.query.range, O = r.schema.primaryKey.extractKey, w = p.extractKey, v = (p.lowLevelIndex || p).extractKey, T = T.reduce(function(D, b) {
          var C = D, S = [];
          if (b.type === "add" || b.type === "put") for (var P = new an(), E = b.values.length - 1; 0 <= E; --E) {
            var N, F = b.values[E], G = O(F);
            P.hasKey(G) || (N = w(F), (g && d(N) ? N.some(function(Q) {
              return li(Q, L);
            }) : li(N, L)) && (P.addKey(G), S.push(F)));
          }
          switch (b.type) {
            case "add":
              var Y = new an().addKeys(t.values ? D.map(function(ne) {
                return O(ne);
              }) : D), C = D.concat(t.values ? S.filter(function(ne) {
                return ne = O(ne), !Y.hasKey(ne) && (Y.addKey(ne), !0);
              }) : S.map(function(ne) {
                return O(ne);
              }).filter(function(ne) {
                return !Y.hasKey(ne) && (Y.addKey(ne), !0);
              }));
              break;
            case "put":
              var H = new an().addKeys(b.values.map(function(ne) {
                return O(ne);
              }));
              C = D.filter(function(ne) {
                return !H.hasKey(t.values ? O(ne) : ne);
              }).concat(t.values ? S : S.map(function(ne) {
                return O(ne);
              }));
              break;
            case "delete":
              var $ = new an().addKeys(b.keys);
              C = D.filter(function(ne) {
                return !$.hasKey(t.values ? O(ne) : ne);
              });
              break;
            case "deleteRange":
              var J = b.range;
              C = D.filter(function(ne) {
                return !li(O(ne), J);
              });
          }
          return C;
        }, n);
        return T === n ? n : (T.sort(function(D, b) {
          return Ce(v(D), v(b)) || Ce(O(D), O(b));
        }), t.limit && t.limit < 1 / 0 && (T.length > t.limit ? T.length = t.limit : n.length === t.limit && T.length < t.limit && (c.dirty = !0)), f ? Object.freeze(T) : T);
      }
      function wu(n, t) {
        return Ce(n.lower, t.lower) === 0 && Ce(n.upper, t.upper) === 0 && !!n.lowerOpen == !!t.lowerOpen && !!n.upperOpen == !!t.upperOpen;
      }
      function Lr(n, t) {
        return function(u, r, c, f) {
          if (u === void 0) return r !== void 0 ? -1 : 0;
          if (r === void 0) return 1;
          if ((r = Ce(u, r)) === 0) {
            if (c && f) return 0;
            if (c) return 1;
            if (f) return -1;
          }
          return r;
        }(n.lower, t.lower, n.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(u, r, c, f) {
          if (u === void 0) return r !== void 0 ? 1 : 0;
          if (r === void 0) return -1;
          if ((r = Ce(u, r)) === 0) {
            if (c && f) return 0;
            if (c) return -1;
            if (f) return 1;
          }
          return r;
        }(n.upper, t.upper, n.upperOpen, t.upperOpen);
      }
      function Dr(n, t, u, r) {
        n.subscribers.add(u), r.addEventListener("abort", function() {
          var c, f;
          n.subscribers.delete(u), n.subscribers.size === 0 && (c = n, f = t, setTimeout(function() {
            c.subscribers.size === 0 && de(f, c);
          }, 3e3));
        });
      }
      var Or = { stack: "dbcore", level: 0, name: "Cache", create: function(n) {
        var t = n.schema.name;
        return a(a({}, n), { transaction: function(u, r, c) {
          var f, p, g = n.transaction(u, r, c);
          return r === "readwrite" && (p = (f = new AbortController()).signal, c = function(L) {
            return function() {
              if (f.abort(), r === "readwrite") {
                for (var O = /* @__PURE__ */ new Set(), w = 0, v = u; w < v.length; w++) {
                  var T = v[w], D = nl["idb://".concat(t, "/").concat(T)];
                  if (D) {
                    var b = n.table(T), C = D.optimisticOps.filter(function(ne) {
                      return ne.trans === g;
                    });
                    if (g._explicit && L && g.mutatedParts) for (var S = 0, P = Object.values(D.queries.query); S < P.length; S++) for (var E = 0, N = (Y = P[S]).slice(); E < N.length; E++) Wt((H = N[E]).obsSet, g.mutatedParts) && (de(Y, H), H.subscribers.forEach(function(ne) {
                      return O.add(ne);
                    }));
                    else if (0 < C.length) {
                      D.optimisticOps = D.optimisticOps.filter(function(ne) {
                        return ne.trans !== g;
                      });
                      for (var F = 0, G = Object.values(D.queries.query); F < G.length; F++) for (var Y, H, $, J = 0, Q = (Y = G[F]).slice(); J < Q.length; J++) (H = Q[J]).res != null && g.mutatedParts && (L && !H.dirty ? ($ = Object.isFrozen(H.res), $ = bu(H.res, H.req, C, b, H, $), H.dirty ? (de(Y, H), H.subscribers.forEach(function(ne) {
                        return O.add(ne);
                      })) : $ !== H.res && (H.res = $, H.promise = ee.resolve({ result: $ }))) : (H.dirty && de(Y, H), H.subscribers.forEach(function(ne) {
                        return O.add(ne);
                      })));
                    }
                  }
                }
                O.forEach(function(ne) {
                  return ne();
                });
              }
            };
          }, g.addEventListener("abort", c(!1), { signal: p }), g.addEventListener("error", c(!1), { signal: p }), g.addEventListener("complete", c(!0), { signal: p })), g;
        }, table: function(u) {
          var r = n.table(u), c = r.schema.primaryKey;
          return a(a({}, r), { mutate: function(f) {
            var p = re.trans;
            if (c.outbound || p.db._options.cache === "disabled" || p.explicit || p.idbtrans.mode !== "readwrite") return r.mutate(f);
            var g = nl["idb://".concat(t, "/").concat(u)];
            return g ? (p = r.mutate(f), f.type !== "add" && f.type !== "put" || !(50 <= f.values.length || ni(c, f).some(function(L) {
              return L == null;
            })) ? (g.optimisticOps.push(f), f.mutatedParts && st(f.mutatedParts), p.then(function(L) {
              0 < L.numFailures && (de(g.optimisticOps, f), (L = Ou(0, f, L)) && g.optimisticOps.push(L), f.mutatedParts && st(f.mutatedParts));
            }), p.catch(function() {
              de(g.optimisticOps, f), f.mutatedParts && st(f.mutatedParts);
            })) : p.then(function(L) {
              var O = Ou(0, a(a({}, f), { values: f.values.map(function(w, v) {
                var T;
                return L.failures[v] || (w = (T = c.keyPath) !== null && T !== void 0 && T.includes(".") ? ve(w) : a({}, w), te(w, c.keyPath, L.results[v])), w;
              }) }), L);
              g.optimisticOps.push(O), queueMicrotask(function() {
                return f.mutatedParts && st(f.mutatedParts);
              });
            }), p) : r.mutate(f);
          }, query: function(f) {
            if (!Lu(re, r) || !Du("query", f)) return r.query(f);
            var p = ((O = re.trans) === null || O === void 0 ? void 0 : O.db._options.cache) === "immutable", v = re, g = v.requery, L = v.signal, O = function(b, C, S, P) {
              var E = nl["idb://".concat(b, "/").concat(C)];
              if (!E) return [];
              if (!(C = E.queries[S])) return [null, !1, E, null];
              var N = C[(P.query ? P.query.index.name : null) || ""];
              if (!N) return [null, !1, E, null];
              switch (S) {
                case "query":
                  var F = N.find(function(G) {
                    return G.req.limit === P.limit && G.req.values === P.values && wu(G.req.query.range, P.query.range);
                  });
                  return F ? [F, !0, E, N] : [N.find(function(G) {
                    return ("limit" in G.req ? G.req.limit : 1 / 0) >= P.limit && (!P.values || G.req.values) && Lr(G.req.query.range, P.query.range);
                  }), !1, E, N];
                case "count":
                  return F = N.find(function(G) {
                    return wu(G.req.query.range, P.query.range);
                  }), [F, !!F, E, N];
              }
            }(t, u, "query", f), w = O[0], v = O[1], T = O[2], D = O[3];
            return w && v ? w.obsSet = f.obsSet : (v = r.query(f).then(function(b) {
              var C = b.result;
              if (w && (w.res = C), p) {
                for (var S = 0, P = C.length; S < P; ++S) Object.freeze(C[S]);
                Object.freeze(C);
              } else b.result = ve(C);
              return b;
            }).catch(function(b) {
              return D && w && de(D, w), Promise.reject(b);
            }), w = { obsSet: f.obsSet, promise: v, subscribers: /* @__PURE__ */ new Set(), type: "query", req: f, dirty: !1 }, D ? D.push(w) : (D = [w], (T = T || (nl["idb://".concat(t, "/").concat(u)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[f.query.index.name || ""] = D)), Dr(w, D, g, L), w.promise.then(function(b) {
              return { result: bu(b.result, f, T?.optimisticOps, r, w, p) };
            });
          } });
        } });
      } };
      function ot(n, t) {
        return new Proxy(n, { get: function(u, r, c) {
          return r === "db" ? t : Reflect.get(u, r, c);
        } });
      }
      var En = ($e.prototype.version = function(n) {
        if (isNaN(n) || n < 0.1) throw new Z.Type("Given version is not a positive number");
        if (n = Math.round(10 * n) / 10, this.idbdb || this._state.isBeingOpened) throw new Z.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, n);
        var t = this._versions, u = t.filter(function(r) {
          return r._cfg.version === n;
        })[0];
        return u || (u = new this.Version(n), t.push(u), t.sort(fr), u.stores({}), this._state.autoSchema = !1, u);
      }, $e.prototype._whenReady = function(n) {
        var t = this;
        return this.idbdb && (this._state.openComplete || re.letThrough || this._vip) ? n() : new ee(function(u, r) {
          if (t._state.openComplete) return r(new Z.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void r(new Z.DatabaseClosed());
            t.open().catch(Oe);
          }
          t._state.dbReadyPromise.then(u, r);
        }).then(n);
      }, $e.prototype.use = function(n) {
        var t = n.stack, u = n.create, r = n.level, c = n.name;
        return c && this.unuse({ stack: t, name: c }), n = this._middlewares[t] || (this._middlewares[t] = []), n.push({ stack: t, create: u, level: r ?? 10, name: c }), n.sort(function(f, p) {
          return f.level - p.level;
        }), this;
      }, $e.prototype.unuse = function(n) {
        var t = n.stack, u = n.name, r = n.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(c) {
          return r ? c.create !== r : !!u && c.name !== u;
        })), this;
      }, $e.prototype.open = function() {
        var n = this;
        return Qn(An, function() {
          return gr(n);
        });
      }, $e.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var n = this._state, t = ol.indexOf(this);
        if (0 <= t && ol.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        n.isBeingOpened || (n.dbReadyPromise = new ee(function(u) {
          n.dbReadyResolve = u;
        }), n.openCanceller = new ee(function(u, r) {
          n.cancelOpen = r;
        }));
      }, $e.prototype.close = function(u) {
        var t = (u === void 0 ? { disableAutoOpen: !0 } : u).disableAutoOpen, u = this._state;
        t ? (u.isBeingOpened && u.cancelOpen(new Z.DatabaseClosed()), this._close(), u.autoOpen = !1, u.dbOpenError = new Z.DatabaseClosed()) : (this._close(), u.autoOpen = this._options.autoOpen || u.isBeingOpened, u.openComplete = !1, u.dbOpenError = null);
      }, $e.prototype.delete = function(n) {
        var t = this;
        n === void 0 && (n = { disableAutoOpen: !0 });
        var u = 0 < arguments.length && typeof arguments[0] != "object", r = this._state;
        return new ee(function(c, f) {
          function p() {
            t.close(n);
            var g = t._deps.indexedDB.deleteDatabase(t.name);
            g.onsuccess = Be(function() {
              var L, O, w;
              L = t._deps, O = t.name, w = L.indexedDB, L = L.IDBKeyRange, jt(w) || O === Wl || zt(w, L).delete(O).catch(Oe), c();
            }), g.onerror = bn(f), g.onblocked = t._fireOnBlocked;
          }
          if (u) throw new Z.InvalidArgument("Invalid closeOptions argument to db.delete()");
          r.isBeingOpened ? r.dbReadyPromise.then(p) : p();
        });
      }, $e.prototype.backendDB = function() {
        return this.idbdb;
      }, $e.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, $e.prototype.hasBeenClosed = function() {
        var n = this._state.dbOpenError;
        return n && n.name === "DatabaseClosed";
      }, $e.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, $e.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty($e.prototype, "tables", { get: function() {
        var n = this;
        return m(this._allTables).map(function(t) {
          return n._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), $e.prototype.transaction = function() {
        var n = (function(t, u, r) {
          var c = arguments.length;
          if (c < 2) throw new Z.InvalidArgument("Too few arguments");
          for (var f = new Array(c - 1); --c; ) f[c - 1] = arguments[c];
          return r = f.pop(), [t, ce(f), r];
        }).apply(this, arguments);
        return this._transaction.apply(this, n);
      }, $e.prototype._transaction = function(n, t, u) {
        var r = this, c = re.trans;
        c && c.db === this && n.indexOf("!") === -1 || (c = null);
        var f, p, g = n.indexOf("?") !== -1;
        n = n.replace("!", "").replace("?", "");
        try {
          if (p = t.map(function(O) {
            if (O = O instanceof r.Table ? O.name : O, typeof O != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return O;
          }), n == "r" || n === _t) f = _t;
          else {
            if (n != "rw" && n != Nt) throw new Z.InvalidArgument("Invalid transaction mode: " + n);
            f = Nt;
          }
          if (c) {
            if (c.mode === _t && f === Nt) {
              if (!g) throw new Z.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              c = null;
            }
            c && p.forEach(function(O) {
              if (c && c.storeNames.indexOf(O) === -1) {
                if (!g) throw new Z.SubTransaction("Table " + O + " not included in parent transaction.");
                c = null;
              }
            }), g && c && !c.active && (c = null);
          }
        } catch (O) {
          return c ? c._promise(null, function(w, v) {
            v(O);
          }) : He(O);
        }
        var L = (function O(w, v, T, D, b) {
          return ee.resolve().then(function() {
            var C = re.transless || re, S = w._createTransaction(v, T, w._dbSchema, D);
            if (S.explicit = !0, C = { trans: S, transless: C }, D) S.idbtrans = D.idbtrans;
            else try {
              S.create(), S.idbtrans._explicit = !0, w._state.PR1398_maxLoop = 3;
            } catch (N) {
              return N.name === k.InvalidState && w.isOpen() && 0 < --w._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), w.close({ disableAutoOpen: !1 }), w.open().then(function() {
                return O(w, v, T, null, b);
              })) : He(N);
            }
            var P, E = Ye(b);
            return E && cl(), C = ee.follow(function() {
              var N;
              (P = b.call(S, S)) && (E ? (N = Kn.bind(null, null), P.then(N, N)) : typeof P.next == "function" && typeof P.throw == "function" && (P = Jt(P)));
            }, C), (P && typeof P.then == "function" ? ee.resolve(P).then(function(N) {
              return S.active ? N : He(new Z.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : C.then(function() {
              return P;
            })).then(function(N) {
              return D && S._resolve(), S._completion.then(function() {
                return N;
              });
            }).catch(function(N) {
              return S._reject(N), He(N);
            });
          });
        }).bind(null, this, f, p, c, u);
        return c ? c._promise(f, L, "lock") : re.trans ? Qn(re.transless, function() {
          return r._whenReady(L);
        }) : this._whenReady(L);
      }, $e.prototype.table = function(n) {
        if (!I(this._allTables, n)) throw new Z.InvalidTable("Table ".concat(n, " does not exist"));
        return this._allTables[n];
      }, $e);
      function $e(n, t) {
        var u = this;
        this._middlewares = {}, this.verno = 0;
        var r = $e.dependencies;
        this._options = t = a({ addons: $e.addons, autoOpen: !0, indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, r = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var c, f, p, g, L, O = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: Oe, dbReadyPromise: null, cancelOpen: Oe, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        O.dbReadyPromise = new ee(function(v) {
          O.dbReadyResolve = v;
        }), O.openCanceller = new ee(function(v, T) {
          O.cancelOpen = T;
        }), this._state = O, this.name = n, this.on = Ll(this, "populate", "blocked", "versionchange", "close", { ready: [_e, Oe] }), this.once = function(v, T) {
          var D = function() {
            for (var b = [], C = 0; C < arguments.length; C++) b[C] = arguments[C];
            u.on(v).unsubscribe(D), T.apply(u, b);
          };
          return u.on(v, D);
        }, this.on.ready.subscribe = B(this.on.ready.subscribe, function(v) {
          return function(T, D) {
            $e.vip(function() {
              var b, C = u._state;
              C.openComplete ? (C.dbOpenError || ee.resolve().then(T), D && v(T)) : C.onReadyBeingFired ? (C.onReadyBeingFired.push(T), D && v(T)) : (v(T), b = u, D || v(function S() {
                b.on.ready.unsubscribe(T), b.on.ready.unsubscribe(S);
              }));
            });
          };
        }), this.Collection = (c = this, Dl(ur.prototype, function(P, S) {
          this.db = c;
          var D = nu, b = null;
          if (S) try {
            D = S();
          } catch (E) {
            b = E;
          }
          var C = P._ctx, S = C.table, P = S.hook.reading.fire;
          this._ctx = { table: S, index: C.index, isPrimKey: !C.index || S.schema.primKey.keyPath && C.index === S.schema.primKey.name, range: D, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: b, or: C.or, valueMapper: P !== j ? P : null };
        })), this.Table = (f = this, Dl(uu.prototype, function(v, T, D) {
          this.db = f, this._tx = D, this.name = v, this.schema = T, this.hook = f._allTables[v] ? f._allTables[v].hook : Ll(null, { creating: [Te, Oe], reading: [ue, j], updating: [we, Oe], deleting: [Le, Oe] });
        })), this.Transaction = (p = this, Dl(sr.prototype, function(v, T, D, b, C) {
          var S = this;
          v !== "readonly" && T.forEach(function(P) {
            P = (P = D[P]) === null || P === void 0 ? void 0 : P.yProps, P && (T = T.concat(P.map(function(E) {
              return E.updatesTable;
            })));
          }), this.db = p, this.mode = v, this.storeNames = T, this.schema = D, this.chromeTransactionDurability = b, this.idbtrans = null, this.on = Ll(this, "complete", "error", "abort"), this.parent = C || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ee(function(P, E) {
            S._resolve = P, S._reject = E;
          }), this._completion.then(function() {
            S.active = !1, S.on.complete.fire();
          }, function(P) {
            var E = S.active;
            return S.active = !1, S.on.error.fire(P), S.parent ? S.parent._reject(P) : E && S.idbtrans && S.idbtrans.abort(), He(P);
          });
        })), this.Version = (g = this, Dl(hr.prototype, function(v) {
          this.db = g, this._cfg = { version: v, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (L = this, Dl(mu.prototype, function(v, T, D) {
          if (this.db = L, this._ctx = { table: v, index: T === ":id" ? null : T, or: D }, this._cmp = this._ascending = Ce, this._descending = function(b, C) {
            return Ce(C, b);
          }, this._max = function(b, C) {
            return 0 < Ce(b, C) ? b : C;
          }, this._min = function(b, C) {
            return Ce(b, C) < 0 ? b : C;
          }, this._IDBKeyRange = L._deps.IDBKeyRange, !this._IDBKeyRange) throw new Z.MissingAPI();
        })), this.on("versionchange", function(v) {
          0 < v.newVersion ? console.warn("Another connection wants to upgrade database '".concat(u.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(u.name, "'. Closing db now to resume the delete request.")), u.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(v) {
          !v.newVersion || v.newVersion < v.oldVersion ? console.warn("Dexie.delete('".concat(u.name, "') was blocked")) : console.warn("Upgrade '".concat(u.name, "' blocked by other connection holding version ").concat(v.oldVersion / 10));
        }), this._maxKey = Sl(t.IDBKeyRange), this._createTransaction = function(v, T, D, b) {
          return new u.Transaction(v, T, D, u._options.chromeTransactionDurability, b);
        }, this._fireOnBlocked = function(v) {
          u.on("blocked").fire(v), ol.filter(function(T) {
            return T.name === u.name && T !== u && !T._state.vcFired;
          }).map(function(T) {
            return T.on("versionchange").fire(v);
          });
        }, this.use(yr), this.use(Or), this.use(Ir), this.use(vr), this.use(xr);
        var w = new Proxy(this, { get: function(v, T, D) {
          if (T === "_vip") return !0;
          if (T === "table") return function(C) {
            return ot(u.table(C), w);
          };
          var b = Reflect.get(v, T, D);
          return b instanceof uu ? ot(b, w) : T === "tables" ? b.map(function(C) {
            return ot(C, w);
          }) : T === "_createTransaction" ? function() {
            return ot(b.apply(this, arguments), w);
          } : b;
        } });
        this.vip = w, r.forEach(function(v) {
          return v(u);
        });
      }
      var mt, In = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", br = (ti.prototype.subscribe = function(n, t, u) {
        return this._subscribe(n && typeof n != "function" ? n : { next: n, error: t, complete: u });
      }, ti.prototype[In] = function() {
        return this;
      }, ti);
      function ti(n) {
        this._subscribe = n;
      }
      try {
        mt = { indexedDB: o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB, IDBKeyRange: o.IDBKeyRange || o.webkitIDBKeyRange };
      } catch {
        mt = { indexedDB: null, IDBKeyRange: null };
      }
      function Su(n) {
        var t, u = !1, r = new br(function(c) {
          var f = Ye(n), p, g = !1, L = {}, O = {}, w = { get closed() {
            return g;
          }, unsubscribe: function() {
            g || (g = !0, p && p.abort(), v && jn.storagemutated.unsubscribe(D));
          } };
          c.start && c.start(w);
          var v = !1, T = function() {
            return Et(b);
          }, D = function(C) {
            rt(L, C), Wt(O, L) && T();
          }, b = function() {
            var C, S, P;
            !g && mt.indexedDB && (L = {}, C = {}, p && p.abort(), p = new AbortController(), P = function(E) {
              var N = rl();
              try {
                f && cl();
                var F = Un(n, E);
                return F = f ? F.finally(Kn) : F;
              } finally {
                N && sl();
              }
            }(S = { subscr: C, signal: p.signal, requery: T, querier: n, trans: null }), Promise.resolve(P).then(function(E) {
              u = !0, t = E, g || S.signal.aborted || (L = {}, function(N) {
                for (var F in N) if (I(N, F)) return;
                return 1;
              }(O = C) || v || (jn(wl, D), v = !0), Et(function() {
                return !g && c.next && c.next(E);
              }));
            }, function(E) {
              u = !1, ["DatabaseClosedError", "AbortError"].includes(E?.name) || g || Et(function() {
                g || c.error && c.error(E);
              });
            }));
          };
          return setTimeout(T, 0), w;
        });
        return r.hasValue = function() {
          return u;
        }, r.getValue = function() {
          return t;
        }, r;
      }
      var ll = En;
      function ii(n) {
        var t = Hn;
        try {
          Hn = !0, jn.storagemutated.fire(n), Qt(n, !0);
        } finally {
          Hn = t;
        }
      }
      q(ll, a(a({}, Qe), { delete: function(n) {
        return new ll(n, { addons: [] }).delete();
      }, exists: function(n) {
        return new ll(n, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(n) {
        try {
          return t = ll.dependencies, u = t.indexedDB, t = t.IDBKeyRange, (jt(u) ? Promise.resolve(u.databases()).then(function(r) {
            return r.map(function(c) {
              return c.name;
            }).filter(function(c) {
              return c !== Wl;
            });
          }) : zt(u, t).toCollection().primaryKeys()).then(n);
        } catch {
          return He(new Z.MissingAPI());
        }
        var t, u;
      }, defineClass: function() {
        return function(n) {
          h(this, n);
        };
      }, ignoreTransaction: function(n) {
        return re.trans ? Qn(re.transless, n) : n();
      }, vip: Ht, async: function(n) {
        return function() {
          try {
            var t = Jt(n.apply(this, arguments));
            return t && typeof t.then == "function" ? t : ee.resolve(t);
          } catch (u) {
            return He(u);
          }
        };
      }, spawn: function(n, t, u) {
        try {
          var r = Jt(n.apply(u, t || []));
          return r && typeof r.then == "function" ? r : ee.resolve(r);
        } catch (c) {
          return He(c);
        }
      }, currentTransaction: { get: function() {
        return re.trans || null;
      } }, waitFor: function(n, t) {
        return t = ee.resolve(typeof n == "function" ? ll.ignoreTransaction(n) : n).timeout(t || 6e4), re.trans ? re.trans.waitFor(t) : t;
      }, Promise: ee, debug: { get: function() {
        return be;
      }, set: function(n) {
        Pe(n);
      } }, derive: V, extend: h, props: q, override: B, Events: Ll, on: jn, liveQuery: Su, extendObservabilitySet: rt, getByKeyPath: se, setByKeyPath: te, delByKeyPath: function(n, t) {
        typeof t == "string" ? te(n, t, void 0) : "length" in t && [].map.call(t, function(u) {
          te(n, u, void 0);
        });
      }, shallowClone: me, deepClone: ve, getObjectDiff: ei, cmp: Ce, asap: W, minKey: -1 / 0, addons: [], connections: ol, errnames: k, dependencies: mt, cache: nl, semVer: "4.2.0", version: "4.2.0".split(".").map(function(n) {
        return parseInt(n);
      }).reduce(function(n, t, u) {
        return n + t / Math.pow(10, 2 * u);
      }) })), ll.maxKey = Sl(ll.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (jn(wl, function(n) {
        Hn || (n = new CustomEvent(kt, { detail: n }), Hn = !0, dispatchEvent(n), Hn = !1);
      }), addEventListener(kt, function(n) {
        n = n.detail, Hn || ii(n);
      }));
      var xl, Hn = !1, Cu = function() {
      };
      return typeof BroadcastChannel < "u" && ((Cu = function() {
        (xl = new BroadcastChannel(kt)).onmessage = function(n) {
          return n.data && ii(n.data);
        };
      })(), typeof xl.unref == "function" && xl.unref(), jn(wl, function(n) {
        Hn || xl.postMessage(n);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(n) {
        if (!En.disableBfCache && n.persisted) {
          be && console.debug("Dexie: handling persisted pagehide"), xl?.close();
          for (var t = 0, u = ol; t < u.length; t++) u[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(n) {
        !En.disableBfCache && n.persisted && (be && console.debug("Dexie: handling persisted pageshow"), Cu(), ii({ all: new an(-1 / 0, [[]]) }));
      })), ee.rejectionMapper = function(n, t) {
        return !n || n instanceof un || n instanceof TypeError || n instanceof SyntaxError || !n.name || !ie[n.name] ? n : (t = new ie[n.name](t || n.message, n), "stack" in n && R(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, Pe(be), a(En, Object.freeze({ __proto__: null, Dexie: En, liveQuery: Su, Entity: lu, cmp: Ce, PropModification: Ol, replacePrefix: function(n, t) {
        return new Ol({ replacePrefix: [n, t] });
      }, add: function(n) {
        return new Ol({ add: n });
      }, remove: function(n) {
        return new Ol({ remove: n });
      }, default: En, RangeSet: an, mergeRanges: Pl, rangesOverlap: gu }), { default: En }), En;
    });
  }(Dm)), Dm.exports;
}
var DL = LL();
const Om = /* @__PURE__ */ yL(DL), bd = Symbol.for("Dexie"), Cc = globalThis[bd] || (globalThis[bd] = Om);
if (Om.semVer !== Cc.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Om.semVer} and ${Cc.semVer}`);
const {
  liveQuery: Rg,
  mergeRanges: OC,
  rangesOverlap: bC,
  RangeSet: wC,
  cmp: SC,
  Entity: CC,
  PropModification: TC,
  replacePrefix: PC,
  add: qC,
  remove: AC,
  DexieYProvider: RC
} = Cc, Kl = "sclElements", OL = "id, tagName, [id+tagName], &attributes.uuid, &attributes.id, attributes.name, parent.id, parent.tagName, *children.id, *children.tagName";
function bL(e) {
  const { databaseName: l } = e, i = new Cc(l);
  return i.version(1).stores({
    [`${Kl}`]: OL
  }), i;
}
const wL = {
  FunctionCategory: {
    tag: "FunctionCategory",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Category of functions. To be added to Process, Line, Substation, VoltageLevel and Bay SCL elements

Category of functions. To be added to Process, Line, Substation, VoltageLevel and Bay SCL elements`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SubCategory", "FunctionCatRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubCategory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FunctionCatRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProcessResources: {
    tag: "ProcessResources",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `List of Process Resources related to a function. to be added to the SCL elements Function, SubFunction, EqFunction and EqSubFunction

List of Process Resources related to a function. to be added to the SCL elements Function, SubFunction, EqFunction and EqSubFunction`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "ProcessResource"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessResource: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueResource",
              kind: "unique",
              paths: [["Resource"]],
              deep: !1,
              attributes: ["resInst"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniquePR",
        kind: "unique",
        paths: [["ProcessResource"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PowerSystemRelations: {
    tag: "PowerSystemRelations",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Functional relation from a Function/SubFunction to another element of the process

Functional relation from a Function/SubFunction to another element of the process`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "PowerSystemRelation"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        PowerSystemRelation: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniquePSR",
        kind: "unique",
        paths: [["PowerSystemRelation"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeInputs: {
    tag: "LNodeInputs",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `List of specification inputs of the given LNode. To be added at LNode level

List of specification inputs of the given LNode. To be added at LNode level`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SourceRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SourceRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueSourceRef",
        kind: "unique",
        paths: [["SourceRef"]],
        deep: !1,
        attributes: ["input", "inputInst", "pDA"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeOutputs: {
    tag: "LNodeOutputs",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `List of specification outputs of the given LNode. To be added at LNode level

List of specification outputs of the given LNode. To be added at LNode level`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "ControlRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ControlRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueControlRef",
        kind: "unique",
        paths: [["ControlRef"]],
        deep: !1,
        attributes: ["output", "outputInst"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProcessEcho: {
    tag: "ProcessEcho",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Definition of an echo LNode, mirroring the DO of another LNode

Definition of an echo LNode, mirroring the DO of another LNode`,
    parents: ["DAS", "DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "source", "sourceDaName", "sourceDoName", "sourceLNodeUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceDaName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceLNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeSpecNaming: {
    tag: "LNodeSpecNaming",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `LNode user specification. To be added to LNode SCL element

LNode user specification. To be added to LNode SCL element`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["sIedName", "sLdInst", "sLnClass", "sLnInst", "sPrefix"],
      details: {
        sIedName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "None",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sLdInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sLnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sLnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sPrefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DOS: {
    tag: "DOS",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Data Object specification. To be added to LNode SCL element

Data Object specification. To be added to LNode SCL element`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "mappedDoName", "mappedLnUuid", "name"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedLnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 12,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "SDS",
        "DAS",
        "SubscriberLNode",
        "ControllingLNode",
        "ProcessEcho",
        "LogParametersRef",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SDS: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueSDS_DASinSDS",
              kind: "unique",
              paths: [["DAS|.", "SDS"]],
              deep: !1,
              attributes: ["name", "ix"],
              refer: null,
              text: !1
            }
          ]
        },
        DAS: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubscriberLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ControllingLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessEcho: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDOS",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "SDS",
            "DAS",
            "SubscriberLNode",
            "ControllingLNode",
            "ProcessEcho",
            "LogParametersRef"
          ]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueSDS_DASinDOS",
        kind: "unique",
        paths: [["DAS|.", "SDS"]],
        deep: !1,
        attributes: ["name", "ix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionSclRef: {
    tag: "FunctionSclRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to the FSD files used to create a Function. Could be added under Function/SubFunction/EqFunction/EqSubFunction

Reference to the FSD files used to create a Function. Could be added under Function/SubFunction/EqFunction/EqSubFunction`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SclFileReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SclFileReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  CheckoutID: {
    tag: "CheckoutID",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Element used by an IED to indicates that a file has been imported to give engineering rights on this IED. This is opening a transaction between both projects to lock it on first project until the checkout is given back from current project, which then lock the IED locally

Element used by an IED to indicates that a file has been imported to give engineering rights on this IED. This is opening a transaction between both projects to lock it on first project until the checkout is given back from current project, which then lock the IED locally`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "desc",
        "engRight",
        "fileName",
        "fileType",
        "fileUuid",
        "headerId",
        "revision",
        "version",
        "when"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        engRight: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["full", "fix", "dataflow"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["SED", "SCC", "ICD", "IID", "CID", "SSD", "SCD"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        headerId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["SubCheckoutID"],
      details: {
        SubCheckoutID: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tSclFileUUIDCheckoutRestriction",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Variable: {
    tag: "Variable",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `A Variable is a way to define a global variable which can be modified by a user and applied to a list of SCL attributes

A Variable is a way to define a global variable which can be modified by a user and applied to a list of SCL attributes`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid", "value"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "VariableApplyTo"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        VariableApplyTo: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  CommunicationServiceSpecifications: {
    tag: "CommunicationServiceSpecifications",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `The CommunicationServiceSpecifications is containing parameters used to create control blocks during implementation

The CommunicationServiceSpecifications is containing parameters used to create control blocks during implementation`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "GooseParameters", "SMVParameters", "ReportParameters"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GooseParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["GooseParameters", "SMVParameters", "ReportParameters"]
        }
      ]
    },
    constraints: [
      {
        name: "commServiceSpecKey",
        kind: "key",
        paths: [["*"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ServiceSpecifications: {
    tag: "ServiceSpecifications",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `The ServiceSpecification is containing parameters used to create control blocks or physical interface (LPDI/LPDO) during implementation

The ServiceSpecification is containing parameters used to create control blocks or physical interface (LPDI/LPDO) during implementation`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "GooseParameters",
        "SMVParameters",
        "ReportParameters",
        "BinaryWiringParameters",
        "AnalogueWiringParameters",
        "LogParameters"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GooseParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        AnalogueWiringParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "GooseParameters",
            "SMVParameters",
            "ReportParameters",
            "BinaryWiringParameters",
            "AnalogueWiringParameters",
            "LogParameters"
          ]
        }
      ]
    },
    constraints: [
      {
        name: "serviceSpecKey",
        kind: "key",
        paths: [["*"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BayType: {
    tag: "BayType",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Bay type element is keeping value of the type. It's a free string

Bay type element is keeping value of the type. It's a free string`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tBayType",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AllocationRole: {
    tag: "AllocationRole",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Definition of an allocation role allowing definition of possible allocation to devices type without using virtual IED

Definition of an allocation role allowing definition of possible allocation to devices type without using virtual IED`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Application: {
    tag: "Application",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Application definition to be added at Process, Substation, Voltage Level or Bay level

Application definition to be added at Process, Substation, Voltage Level or Bay level`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "FunctionRole",
        "FunctionalVariant",
        "FunctionalVariantGroup",
        "AllocationRoleRef",
        "ApplicationSclRef"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionRole: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueRoleContent",
              kind: "unique",
              paths: [["FunctionRoleContent"]],
              deep: !1,
              attributes: ["roleInst"],
              refer: null,
              text: !1
            }
          ]
        },
        FunctionalVariant: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FunctionalVariantGroup: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        AllocationRoleRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ApplicationSclRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BehaviorDescription: {
    tag: "BehaviorDescription",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Element allowing to describe the behavior its parent (Application, Bay, Function, LN...)

Element allowing to describe the behavior its parent (Application, Bay, Function, LN...)`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "desc",
        "fileReference",
        "format",
        "isSimulation",
        "isSpecification",
        "name",
        "originUuid",
        "templateUuid",
        "uuid"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileReference: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        format: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["IEC 61131", "Textual", "Graphic"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        isSimulation: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        isSpecification: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "InputVar", "OutputVar", "BehaviorReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        InputVar: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        OutputVar: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        BehaviorReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInBehaviorDescription",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["varName"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Project: {
    tag: "Project",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Element allowing to define a project, to identify the project and the process elements defined by this project

Element allowing to define a project, to identify the project and the process elements defined by this project`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "ProjectProcessReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProjectProcessReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionTemplate: {
    tag: "FunctionTemplate",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Base element for FSD format, will be used as a template element for Function/SubFunction or EqFunction/EqSubFunction

Base element for FSD format, will be used as a template element for Function/SubFunction or EqFunction/EqSubFunction`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "LNode", "SubFunctionTemplate", "GeneralEquipment", "ConductingEquipment"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SubFunctionTemplate: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInSubFuncTemplate",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGEFuncTemplate",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipmentOfFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInCondEqTemplate",
              kind: "unique",
              paths: [["SubEquipment|.", "EqFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "t6-100LNodeContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SCL: {
    tag: "SCL",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["release", "revision", "version"],
      details: {
        release: {
          required: !0,
          default: "5",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 255,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: "C",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z]", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: "2007",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["2[0-2][0-9]{2}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Header",
        "Substation",
        "Communication",
        "IED",
        "DataTypeTemplates",
        "Line",
        "Process"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Header: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueHitem",
              kind: "unique",
              paths: [["History", "Hitem"]],
              deep: !1,
              attributes: ["version", "revision"],
              refer: null,
              text: !1
            }
          ]
        },
        Substation: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Communication: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        IED: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DataTypeTemplates: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Line: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Process: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "SubstationKey",
        kind: "key",
        paths: [["Substation|.", "Process|.", "Line"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "IEDKey",
        kind: "key",
        paths: [["IED"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "LNodeTypeKey",
        kind: "key",
        paths: [["DataTypeTemplates", "LNodeType"]],
        deep: !1,
        attributes: ["id", "lnClass"],
        refer: null,
        text: !1
      },
      {
        name: "ConnectivityNodeKey",
        kind: "key",
        paths: [["ConnectivityNode"]],
        deep: !0,
        attributes: ["pathName"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueHitem",
        kind: "unique",
        paths: [["History", "Hitem"]],
        deep: !1,
        attributes: ["version", "revision"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueUUID",
        kind: "unique",
        paths: [["*"]],
        deep: !0,
        attributes: ["uuid"],
        refer: null,
        text: !1
      },
      {
        name: "ref2LNodeTypeDomain1",
        kind: "keyref",
        paths: [["IED", "AccessPoint", "LN"]],
        deep: !1,
        attributes: ["lnType", "lnClass"],
        refer: "LNodeTypeKey",
        text: !1
      },
      {
        name: "ref2LNodeTypeDomain2",
        kind: "keyref",
        paths: [["IED", "AccessPoint", "Server", "LDevice", "LN"]],
        deep: !1,
        attributes: ["lnType", "lnClass"],
        refer: "LNodeTypeKey",
        text: !1
      },
      {
        name: "ref2LNodeTypeLLN0",
        kind: "keyref",
        paths: [["IED", "AccessPoint", "Server", "LDevice", "LN0"]],
        deep: !1,
        attributes: ["lnType", "lnClass"],
        refer: "LNodeTypeKey",
        text: !1
      },
      {
        name: "refConnectedAP2IED",
        kind: "keyref",
        paths: [["Communication", "SubNetwork", "ConnectedAP"]],
        deep: !1,
        attributes: ["iedName"],
        refer: "IEDKey",
        text: !1
      },
      {
        name: "ref2SubstationFromTerminal",
        kind: "keyref",
        paths: [["Terminal"]],
        deep: !0,
        attributes: ["substationName"],
        refer: "scl:SubstationKey",
        text: !1
      }
    ],
    value: {
      type: "tBaseElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Substation: {
    tag: "Substation",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Process", "SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "PowerTransformer",
        "GeneralEquipment",
        "VoltageLevel",
        "Function"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        PowerTransformer: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInPowerTransformer",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTR",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        VoltageLevel: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueChildNameInVoltageLevel",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueLNodeInVoltageLevel",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunctionSS",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInSubstationFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInSubstation",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInSubstation",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Process: {
    tag: "Process",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Process", "SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "GeneralEquipment",
        "Function",
        "ConductingEquipment",
        "Substation",
        "Line",
        "Process"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment2",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE2",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFunction",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Substation: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueChildNameInProcessSubstation",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueLNodeInProcessSubstation",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Line: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Process: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueChildNameInSubProcess",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueLNodeInSubProcess",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInProcess",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInProcess",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tGeneralEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Line: {
    tag: "Line",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Process", "SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "nomFreq", "numPhases", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nomFreq: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: "0",
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        numPhases: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 255,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "GeneralEquipment",
        "Function",
        "Voltage",
        "ConductingEquipment",
        "ConnectivityNode"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment2",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE2",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFunction",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        Voltage: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConductingEquipment: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        },
        ConnectivityNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInLine",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInLine",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tGeneralEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LN0: {
    tag: "LN0",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LDevice"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "inst", "lnClass", "lnType", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inst: {
          required: !0,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: "LLN0",
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "DataSet",
        "ReportControl",
        "LogControl",
        "DOI",
        "Inputs",
        "Outputs",
        "Log",
        "Labels",
        "GSEControl",
        "SampledValueControl",
        "SettingControl"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DataSet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ReportControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LogControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DOI: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueSDI_DAIinDOI",
              kind: "unique",
              paths: [["DAI|.", "SDI"]],
              deep: !1,
              attributes: ["name", "ix"],
              refer: null,
              text: !1
            }
          ]
        },
        Inputs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Outputs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Log: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLN",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        GSEControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SampledValueControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SettingControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "DataSetKeyLN0",
        kind: "key",
        paths: [["DataSet"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueReportControlInLN0",
        kind: "unique",
        paths: [["ReportControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLogControlInLN0",
        kind: "unique",
        paths: [["LogControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueGSEControlInLN0",
        kind: "unique",
        paths: [["GSEControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueSampledValueControlInLN0",
        kind: "unique",
        paths: [["SampledValueControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueDOIinLN0",
        kind: "unique",
        paths: [["DOI"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLogInLN0",
        kind: "unique",
        paths: [["Log"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "ref2DataSetReportLN0",
        kind: "keyref",
        paths: [["ReportControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyLN0",
        text: !1
      },
      {
        name: "ref2DataSetLogLN0",
        kind: "keyref",
        paths: [["LogControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyLN0",
        text: !1
      },
      {
        name: "ref2DataSetGSELN0",
        kind: "keyref",
        paths: [["GSEControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyLN0",
        text: !1
      },
      {
        name: "ref2DataSetSVLN0",
        kind: "keyref",
        paths: [["SampledValueControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyLN0",
        text: !1
      }
    ],
    value: {
      type: "tLN0",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LN: {
    tag: "LN",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["AccessPoint", "LDevice"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "inst", "lnClass", "lnType", "prefix", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "DataSet",
        "ReportControl",
        "LogControl",
        "DOI",
        "Inputs",
        "Outputs",
        "Log",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DataSet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ReportControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LogControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DOI: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueSDI_DAIinDOI",
              kind: "unique",
              paths: [["DAI|.", "SDI"]],
              deep: !1,
              attributes: ["name", "ix"],
              refer: null,
              text: !1
            }
          ]
        },
        Inputs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Outputs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Log: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLN",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "DataSetKeyInLN",
        kind: "key",
        paths: [["DataSet"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueReportControlInLN",
        kind: "unique",
        paths: [["ReportControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLogControlInLN",
        kind: "unique",
        paths: [["LogControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueDOIinLN",
        kind: "unique",
        paths: [["DOI"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLogInLN",
        kind: "unique",
        paths: [["Log"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "ref2DataSetReport",
        kind: "keyref",
        paths: [["ReportControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyInLN",
        text: !1
      },
      {
        name: "ref2DataSetLog",
        kind: "keyref",
        paths: [["LogControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyInLN",
        text: !1
      }
    ],
    value: {
      type: "tAnyLN",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  IED: {
    tag: "IED",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "configVersion",
        "desc",
        "engRight",
        "manufacturer",
        "name",
        "originalSclRelease",
        "originalSclRevision",
        "originalSclVersion",
        "owner",
        "templateUuid",
        "type",
        "uuid"
      ],
      details: {
        configVersion: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        engRight: {
          required: !1,
          default: "full",
          namespace: null,
          validation: {
            enumeration: ["full", "fix", "dataflow"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        manufacturer: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originalSclRelease: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 255,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originalSclRevision: {
          required: !1,
          default: "A",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z]", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originalSclVersion: {
          required: !1,
          default: "2003",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["2[0-2][0-9]{2}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        owner: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Services",
        "AccessPoint",
        "KDC",
        "IEDSourceFiles",
        "MinRequestedSCDFiles",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Services: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        AccessPoint: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNInAccessPoint",
              kind: "unique",
              paths: [["LN"]],
              deep: !1,
              attributes: ["inst", "lnClass", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        KDC: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        IEDSourceFiles: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        MinRequestedSCDFiles: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueProjectInReqSCD",
              kind: "unique",
              paths: [["MinRequestedSCDFile"]],
              deep: !1,
              attributes: ["fileUuid"],
              refer: null,
              text: !1
            }
          ]
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInIED",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "LDeviceInIEDKey",
        kind: "key",
        paths: [["AccessPoint", "Server", "LDevice"]],
        deep: !1,
        attributes: ["inst"],
        refer: null,
        text: !1
      },
      {
        name: "AccessPointInIEDKey",
        kind: "key",
        paths: [["AccessPoint"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "ref2LDeviceInDataSetForFCDAinLN",
        kind: "keyref",
        paths: [["AccessPoint", "Server", "LDevice", "LN", "DataSet", "FCDA"]],
        deep: !1,
        attributes: ["ldInst"],
        refer: "LDeviceInIEDKey",
        text: !1
      },
      {
        name: "ref2LDeviceInDataSetForFCDAinLN0",
        kind: "keyref",
        paths: [["AccessPoint", "Server", "LDevice", "LN0", "DataSet", "FCDA"]],
        deep: !1,
        attributes: ["ldInst"],
        refer: "LDeviceInIEDKey",
        text: !1
      },
      {
        name: "ServerAtRef2AccessPoint",
        kind: "keyref",
        paths: [["AccessPoint", "ServerAt"]],
        deep: !1,
        attributes: ["apName"],
        refer: "AccessPointInIEDKey",
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Communication: {
    tag: "Communication",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SubNetwork"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SubNetwork: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueConnectedAP",
              kind: "unique",
              paths: [["ConnectedAP"]],
              deep: !1,
              attributes: ["iedName", "apName"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueSubNetwork",
        kind: "unique",
        paths: [["SubNetwork"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DataTypeTemplates: {
    tag: "DataTypeTemplates",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: ["LNodeType", "DOType", "DAType", "EnumType"],
      details: {
        LNodeType: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueDOInLNodeType",
              kind: "unique",
              paths: [["DO"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        DOType: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueDAorSDOInDOType",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        DAType: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueBDAInDAType",
              kind: "unique",
              paths: [["BDA"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueProtNs",
              kind: "unique",
              paths: [["ProtNs"]],
              deep: !1,
              attributes: ["type"],
              refer: null,
              text: !1
            }
          ]
        },
        EnumType: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueOrdInEnumType",
              kind: "unique",
              paths: [["EnumVal"]],
              deep: !1,
              attributes: ["ord"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueEnumValue",
              kind: "unique",
              paths: [["EnumVal"]],
              deep: !1,
              attributes: [],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "DOTypeKey",
        kind: "key",
        paths: [["DOType"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      },
      {
        name: "EnumTypeDATypeKey",
        kind: "key",
        paths: [["DAType | scl:EnumType"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueDTT_ID",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      },
      {
        name: "ref2DOType",
        kind: "keyref",
        paths: [["LNodeType", "DO"]],
        deep: !1,
        attributes: ["type"],
        refer: "DOTypeKey",
        text: !1
      },
      {
        name: "ref2DOTypeForSDO",
        kind: "keyref",
        paths: [["DOType", "SDO"]],
        deep: !1,
        attributes: ["type"],
        refer: "DOTypeKey",
        text: !1
      },
      {
        name: "ref2EnumTypeDAType",
        kind: "keyref",
        paths: [["DOType", "DA | scl:DAType", "BDA"]],
        deep: !1,
        attributes: ["type"],
        refer: "scl:EnumTypeDATypeKey",
        text: !1
      }
    ],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Text: {
    tag: "Text",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [
      "AccessPoint",
      "AllocationRole",
      "AllocationRoleRef",
      "AnalogueWiringParameters",
      "AnalogueWiringParametersRef",
      "Application",
      "ApplicationSclRef",
      "BDA",
      "Bay",
      "BehaviorDescription",
      "BehaviorDescriptionRef",
      "BehaviorReference",
      "BinaryWiringParameters",
      "BinaryWiringParametersRef",
      "Communication",
      "CommunicationServiceSpecifications",
      "ConductingEquipment",
      "ConnectedAP",
      "ConnectivityNode",
      "ControlRef",
      "ControllingLNode",
      "DA",
      "DAI",
      "DAS",
      "DAType",
      "DO",
      "DOI",
      "DOS",
      "DOType",
      "DataSet",
      "EnumType",
      "EqFunction",
      "EqSubFunction",
      "ExtCtrl",
      "ExtRef",
      "Function",
      "FunctionCatRef",
      "FunctionCategory",
      "FunctionCategoryRef",
      "FunctionRef",
      "FunctionRole",
      "FunctionRoleContent",
      "FunctionSclRef",
      "FunctionTemplate",
      "FunctionalSubVariant",
      "FunctionalVariant",
      "FunctionalVariantGroup",
      "FunctionalVariantRef",
      "GOOSESecurity",
      "GSE",
      "GSEControl",
      "GeneralEquipment",
      "GooseParameters",
      "GooseParametersRef",
      "Header",
      "IED",
      "IEDSourceFiles",
      "InputVar",
      "InputVarRef",
      "Inputs",
      "L2CommParameters",
      "L3IPv4CommParameters",
      "L3IPv6CommParameters",
      "LDevice",
      "LN",
      "LN0",
      "LNode",
      "LNodeDataRef",
      "LNodeInputRef",
      "LNodeInputs",
      "LNodeOutputRef",
      "LNodeOutputs",
      "LNodeSpecNaming",
      "LNodeType",
      "Labels",
      "Line",
      "Log",
      "LogControl",
      "LogParameters",
      "LogParametersRef",
      "MinRequestedSCDFiles",
      "NeutralPoint",
      "OutputVar",
      "OutputVarRef",
      "Outputs",
      "PhysConn",
      "PowerSystemRelation",
      "PowerSystemRelationRef",
      "PowerSystemRelations",
      "PowerTransformer",
      "Process",
      "ProcessEcho",
      "ProcessResource",
      "ProcessResourceRef",
      "ProcessResources",
      "Project",
      "ProjectProcessReference",
      "ReportControl",
      "ReportParameters",
      "ReportParametersRef",
      "RptEnabled",
      "SCL",
      "SDI",
      "SDO",
      "SDS",
      "SMV",
      "SMVParameters",
      "SMVParametersRef",
      "SMVSecurity",
      "SampledValueControl",
      "SclFileReference",
      "Server",
      "ServerAt",
      "ServiceSpecifications",
      "SettingControl",
      "SignalRole",
      "SourceFiles",
      "SourceRef",
      "SubCategory",
      "SubEquipment",
      "SubFunction",
      "SubFunctionTemplate",
      "SubNetwork",
      "SubscriberLNode",
      "Substation",
      "TapChanger",
      "Terminal",
      "TransformerWinding",
      "Variable",
      "VariableApplyTo",
      "VariableRef",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["source"],
      details: {
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tAnyContentFromOtherNamespace",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubCategory: {
    tag: "SubCategory",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Recursive definition of function category

Recursive definition of function category`,
    parents: ["FunctionCategory", "SubCategory"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SubCategory", "FunctionCatRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubCategory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FunctionCatRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionCatRef: {
    tag: "FunctionCatRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a function which is part of the current category

Reference to a function which is part of the current category`,
    parents: ["FunctionCategory", "SubCategory"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["function", "functionUuid"],
      details: {
        function: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProcessResource: {
    tag: "ProcessResource",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["ProcessResources"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cardinality",
        "desc",
        "max",
        "name",
        "originUuid",
        "selector",
        "templateUuid",
        "uuid"
      ],
      details: {
        cardinality: {
          required: !1,
          default: "1..1",
          namespace: null,
          validation: {
            enumeration: ["0..1", "1..1", "0..n", "1..n"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 2,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        selector: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Resource"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Resource: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueResource",
        kind: "unique",
        paths: [["Resource"]],
        deep: !1,
        attributes: ["resInst"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PowerSystemRelation: {
    tag: "PowerSystemRelation",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["PowerSystemRelations"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "desc",
        "name",
        "originUuid",
        "relation",
        "relationUuid",
        "selector",
        "templateUuid",
        "uuid"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        relation: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        relationUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        selector: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SourceRef: {
    tag: "SourceRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a data in the process

Reference to a data in the process`,
    parents: ["LNodeInputs"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "desc",
        "extRefAddr",
        "extRefUuid",
        "input",
        "inputInst",
        "originUuid",
        "pDA",
        "pDO",
        "pLN",
        "resourceName",
        "resourceUuid",
        "service",
        "source",
        "sourceDaName",
        "sourceDoName",
        "sourceLNodeUuid",
        "templateUuid",
        "uuid"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        extRefAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        extRefUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        input: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inputInst: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDA: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDO: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        service: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Poll", "Report", "GOOSE", "SMV", "Wired", "Internal"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceDaName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceLNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "GooseParametersRef",
        "SMVParametersRef",
        "ReportParametersRef",
        "BinaryWiringParametersRef",
        "AnalogueWiringParametersRef"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GooseParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        AnalogueWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: [
            "GooseParametersRef",
            "SMVParametersRef",
            "ReportParametersRef",
            "BinaryWiringParametersRef",
            "AnalogueWiringParametersRef"
          ]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tLinkFCDARef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ControlRef: {
    tag: "ControlRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a control data in the process

Reference to a control data in the process`,
    parents: ["LNodeOutputs"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "controlled",
        "controlledDoName",
        "controlledLNodeUuid",
        "desc",
        "extCtrlAddr",
        "extCtrlUuid",
        "originUuid",
        "output",
        "outputInst",
        "pDO",
        "pLN",
        "resourceName",
        "resourceUuid",
        "templateUuid",
        "uuid"
      ],
      details: {
        controlled: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        controlledDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        controlledLNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        extCtrlAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        extCtrlUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        output: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outputInst: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDO: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "BinaryWiringParametersRef", "AnalogueWiringParametersRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        AnalogueWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["BinaryWiringParametersRef", "AnalogueWiringParametersRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tLinkFCDRef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SDS: {
    tag: "SDS",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of a sub-Data Object

Specification of a sub-Data Object`,
    parents: ["DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "ix", "mappedDoName", "mappedLnUuid", "name"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedLnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "SDS",
        "DAS",
        "SubscriberLNode",
        "ControllingLNode",
        "ProcessEcho",
        "LogParametersRef",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SDS: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        DAS: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubscriberLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ControllingLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessEcho: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInSDS",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "SDS",
            "DAS",
            "SubscriberLNode",
            "ControllingLNode",
            "ProcessEcho",
            "LogParametersRef"
          ]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueSDS_DASinSDS",
        kind: "unique",
        paths: [["DAS|.", "SDS"]],
        deep: !1,
        attributes: ["name", "ix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DAS: {
    tag: "DAS",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of a Data attribute

Specification of a Data attribute`,
    parents: ["DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "ix", "mappedDaName", "mappedLnUuid", "name", "valImport", "valKind"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedDaName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)\\.([a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*)"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedLnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valImport: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valKind: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Spec", "Conf", "RO", "Set"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "SubscriberLNode",
        "ControllingLNode",
        "ProcessEcho",
        "LogParametersRef",
        "Val",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubscriberLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ControllingLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessEcho: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Val: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDAS",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "SubscriberLNode",
            "ControllingLNode",
            "ProcessEcho",
            "LogParametersRef",
            "Val",
            "Labels"
          ]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubscriberLNode: {
    tag: "SubscriberLNode",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["DAS", "DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "inputName", "pLN", "resourceName", "resourceUuid", "service"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inputName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        service: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Poll", "Report", "GOOSE", "SMV", "Wired", "Internal"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "GooseParametersRef",
        "SMVParametersRef",
        "ReportParametersRef",
        "BinaryWiringParametersRef"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GooseParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: [
            "GooseParametersRef",
            "SMVParametersRef",
            "ReportParametersRef",
            "BinaryWiringParametersRef"
          ]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ControllingLNode: {
    tag: "ControllingLNode",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["DAS", "DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "outputName", "pLN", "resourceName", "resourceUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outputName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "BinaryWiringParametersRef", "AnalogueWiringParametersRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        AnalogueWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["BinaryWiringParametersRef", "AnalogueWiringParametersRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LogParametersRef: {
    tag: "LogParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the Log parameters expected for the current DOS when Log capability is required

Specification of the Log parameters expected for the current DOS when Log capability is required`,
    parents: ["DAS", "DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Labels: {
    tag: "Labels",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [
      "AccessPoint",
      "BDA",
      "Bay",
      "ConductingEquipment",
      "ConnectivityNode",
      "DA",
      "DAI",
      "DAS",
      "DAType",
      "DO",
      "DOI",
      "DOS",
      "DOType",
      "EqFunction",
      "EqSubFunction",
      "Function",
      "GOOSESecurity",
      "GeneralEquipment",
      "IED",
      "LDevice",
      "LN",
      "LN0",
      "LNode",
      "LNodeType",
      "Line",
      "PowerTransformer",
      "Process",
      "SDI",
      "SDO",
      "SDS",
      "SMVSecurity",
      "SubEquipment",
      "SubFunction",
      "SubNetwork",
      "Substation",
      "TapChanger",
      "TransformerWinding",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Label"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Label: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLabel",
        kind: "unique",
        paths: [["Label"]],
        deep: !1,
        attributes: ["id", "lang"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SclFileReference: {
    tag: "SclFileReference",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ApplicationSclRef", "FunctionSclRef", "IEDSourceFiles", "SourceFiles"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "fileName", "fileType", "fileUuid", "revision", "version", "when"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["ICD", "IID", "CID", "SSD", "SCD", "SED"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubCheckoutID: {
    tag: "SubCheckoutID",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `When an IED is checkedout for a collaborative work by an SCC, it may be required to give right to a subpart of the collaborative project. So a CheckoutID may have an additional SubCheckoutID giving IED to nother project

When an IED is checkedout for a collaborative work by an SCC, it may be required to give right to a subpart of the collaborative project. So a CheckoutID may have an additional SubCheckoutID giving IED to nother project`,
    parents: ["CheckoutID", "SubCheckoutID"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "desc",
        "engRight",
        "fileName",
        "fileType",
        "fileUuid",
        "headerId",
        "revision",
        "version",
        "when"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        engRight: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["full", "fix", "dataflow"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["SED", "SCC", "ICD", "IID", "CID", "SSD", "SCD"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        headerId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["SubCheckoutID"],
      details: {
        SubCheckoutID: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tSclFileUUIDCheckoutRestriction",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  VariableApplyTo: {
    tag: "VariableApplyTo",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["Variable"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "attribute",
        "daName",
        "defaultValue",
        "desc",
        "doName",
        "element",
        "elementUuid",
        "format",
        "sGroup"
      ],
      details: {
        attribute: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        defaultValue: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        element: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        elementUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        format: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sGroup: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GooseParameters: {
    tag: "GooseParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["cbName", "desc", "dsName", "goId", "id", "maxTime", "minTime", "securityEnabled"],
      details: {
        cbName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        goId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxTime: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        minTime: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        securityEnabled: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "L2CommParameters", "L3IPv4CommParameters", "L3IPv6CommParameters"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        L2CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        L3IPv4CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        L3IPv6CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["L2CommParameters", "L3IPv4CommParameters", "L3IPv6CommParameters"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tControlBlockParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVParameters: {
    tag: "SMVParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cbName",
        "desc",
        "dsName",
        "id",
        "multicast",
        "nofASDU",
        "securityEnabled",
        "smpMod",
        "smpRate",
        "smvId"
      ],
      details: {
        cbName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        multicast: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nofASDU: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        securityEnabled: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpMod: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["SmpPerPeriod", "SmpPerSec", "SecPerSmp"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpRate: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smvId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "L2CommParameters", "L3IPv4CommParameters", "L3IPv6CommParameters"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        L2CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        L3IPv4CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        L3IPv6CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["L2CommParameters", "L3IPv4CommParameters", "L3IPv6CommParameters"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tControlBlockParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReportParameters: {
    tag: "ReportParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["bufTime", "buffered", "cbName", "desc", "dsName", "id", "intgPd"],
      details: {
        bufTime: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        buffered: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlBlockParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BinaryWiringParameters: {
    tag: "BinaryWiringParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "debTm",
        "desc",
        "fastOutput",
        "id",
        "inpNam",
        "inpRef",
        "outNam",
        "outOffDl",
        "outOnDl",
        "outRef",
        "outTyp",
        "vInOff",
        "vInOn"
      ],
      details: {
        debTm: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fastOutput: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inpNam: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inpRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outNam: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outOffDl: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outOnDl: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outTyp: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Normally open", "Normally closed", "Change over"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vInOff: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vInOn: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tWiringParameters",
      validation: {
        enumeration: ["Normally open", "Normally closed", "Change over"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AnalogueWiringParameters: {
    tag: "AnalogueWiringParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "dsgInp", "fctInp", "id", "inpNam", "inpRef"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsgInp: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fctInp: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inpNam: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inpRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tWiringParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LogParameters: {
    tag: "LogParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cbName",
        "desc",
        "dsName",
        "id",
        "intgPd",
        "logEna",
        "logLdInst",
        "logLnClass",
        "logLnInst",
        "logName",
        "logPrefix",
        "reasonCode"
      ],
      details: {
        cbName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logEna: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logLdInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logLnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logLnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logPrefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        reasonCode: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlBlockParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionRef: {
    tag: "FunctionRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a function definition attached to current allocation role

Reference to a function definition attached to current allocation role`,
    parents: ["AllocationRole", "FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "function", "functionUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        function: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef", "SignalRole"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SignalRole: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionRole: {
    tag: "FunctionRole",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Role attached to the application type

Role attached to the application type`,
    parents: ["Application"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cardinality",
        "desc",
        "max",
        "name",
        "originUuid",
        "selector",
        "templateUuid",
        "type",
        "uuid"
      ],
      details: {
        cardinality: {
          required: !1,
          default: "1..1",
          namespace: null,
          validation: {
            enumeration: ["0..1", "1..1", "0..n", "1..n"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 2,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        selector: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef", "FunctionRoleContent"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FunctionRoleContent: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        },
        {
          minOccurrence: 1,
          maxOccurrence: null,
          options: ["FunctionRoleContent"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueRoleContent",
        kind: "unique",
        paths: [["FunctionRoleContent"]],
        deep: !1,
        attributes: ["roleInst"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionalVariant: {
    tag: "FunctionalVariant",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Variant attached to the application type

Variant attached to the application type`,
    parents: ["Application", "FunctionalVariantGroup"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "isBaseline", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        isBaseline: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalSubVariant", "VariableRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalSubVariant: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        VariableRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalSubVariant", "VariableRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tAbstractFunctionalVariant",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionalVariantGroup: {
    tag: "FunctionalVariantGroup",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Group of variants attached to the application type

Group of variants attached to the application type`,
    parents: ["Application"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariant"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariant: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AllocationRoleRef: {
    tag: "AllocationRoleRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Allocation role attached to the application type

Allocation role attached to the application type`,
    parents: ["Application"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["allocationRole", "allocationRoleUuid", "desc"],
      details: {
        allocationRole: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        allocationRoleUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ApplicationSclRef: {
    tag: "ApplicationSclRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to the ASD files used to create an Application

Reference to the ASD files used to create an Application`,
    parents: ["Application"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SclFileReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SclFileReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  InputVar: {
    tag: "InputVar",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Input variable used in the behavior description

Input variable used in the behavior description`,
    parents: ["BehaviorDescription"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "daName",
        "dataName",
        "desc",
        "doName",
        "inputName",
        "inputUuid",
        "lnodeUuid",
        "value",
        "varName"
      ],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inputName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inputUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        varName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tLogicVarRef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  OutputVar: {
    tag: "OutputVar",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Output variable used in the behavior description

Output variable used in the behavior description`,
    parents: ["BehaviorDescription"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "daName",
        "dataName",
        "desc",
        "doName",
        "lnodeUuid",
        "outputName",
        "outputUuid",
        "value",
        "varName"
      ],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outputName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outputUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        varName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tLogicVarRef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BehaviorReference: {
    tag: "BehaviorReference",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a behavior description when for example a manufacturer wants to indicate its implementation of a user specification described by another behavior description

Reference to a behavior description when for example a manufacturer wants to indicate its implementation of a user specification described by another behavior description`,
    parents: ["BehaviorDescription"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["behaviorReference", "behaviorUuid", "desc"],
      details: {
        behaviorReference: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        behaviorUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProjectProcessReference: {
    tag: "ProjectProcessReference",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to the process elements belonging to the current project

Reference to the process elements belonging to the current project`,
    parents: ["Project"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "processReference", "processUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processReference: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNode: {
    tag: "LNode",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [
      "Bay",
      "ConductingEquipment",
      "ConnectivityNode",
      "EqFunction",
      "EqSubFunction",
      "Function",
      "FunctionTemplate",
      "GeneralEquipment",
      "Line",
      "PowerTransformer",
      "Process",
      "SubEquipment",
      "SubFunction",
      "SubFunctionTemplate",
      "Substation",
      "TapChanger",
      "TransformerWinding",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "desc",
        "iedName",
        "ldInst",
        "lnClass",
        "lnInst",
        "lnType",
        "lnUuid",
        "prefix",
        "templateUuid",
        "uuid"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !1,
          default: "None",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "None",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 0,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnType: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLNode",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubFunctionTemplate: {
    tag: "SubFunctionTemplate",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["FunctionTemplate", "SubFunctionTemplate"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "LNode", "GeneralEquipment", "ConductingEquipment", "SubFunctionTemplate"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfSubFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGESubFuncTemplate",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipmentOfSubFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubEquipmentSubFuncTemplate",
              kind: "unique",
              paths: [["SubEquipment"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        SubFunctionTemplate: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubSubFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubSubFuncTemplate",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInSubFunctionTemplate",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInSubFuncTemplate",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "t6-100LNodeContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GeneralEquipment: {
    tag: "GeneralEquipment",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [
      "Bay",
      "EqFunction",
      "EqSubFunction",
      "Function",
      "FunctionTemplate",
      "Line",
      "Process",
      "SubFunction",
      "SubFunctionTemplate",
      "Substation",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["AXN", "BAT", "MOT", "FAN", "FIL", "PMP", "TNK", "VLV"],
            pattern: ["\\i\\c*", "E[A-Z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 3,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "EqFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForGE",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForGE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInGeneralEquipment",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInGE",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipment",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConductingEquipment: {
    tag: "ConductingEquipment",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [
      "Bay",
      "Function",
      "FunctionTemplate",
      "Line",
      "Process",
      "SubFunction",
      "SubFunctionTemplate"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "CBR",
              "DIS",
              "VTR",
              "CTR",
              "GEN",
              "CAP",
              "REA",
              "CON",
              "MOT",
              "EFN",
              "PSH",
              "BAT",
              "BSH",
              "CAB",
              "GIL",
              "LIN",
              "RES",
              "RRC",
              "SAR",
              "TCF",
              "TCR",
              "IFL",
              "FAN",
              "SCR",
              "SMC",
              "PMP"
            ],
            pattern: ["\\i\\c*", "E[A-Z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 3,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "Terminal", "SubEquipment", "EqFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Terminal: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 2
          },
          constraints: null
        },
        SubEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInACESubEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForCE",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForCE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tAbstractConductingEquipment",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Private: {
    tag: "Private",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [
      "AccessPoint",
      "BDA",
      "Bay",
      "Communication",
      "ConductingEquipment",
      "ConnectedAP",
      "ConnectivityNode",
      "DA",
      "DAI",
      "DAType",
      "DO",
      "DOI",
      "DOType",
      "DataSet",
      "EnumType",
      "EqFunction",
      "EqSubFunction",
      "ExtCtrl",
      "ExtRef",
      "Function",
      "GOOSESecurity",
      "GSE",
      "GSEControl",
      "GeneralEquipment",
      "IED",
      "IEDSourceFiles",
      "Inputs",
      "LDevice",
      "LN",
      "LN0",
      "LNode",
      "LNodeType",
      "Labels",
      "Line",
      "Log",
      "LogControl",
      "MinRequestedSCDFiles",
      "NeutralPoint",
      "Outputs",
      "PhysConn",
      "PowerTransformer",
      "Process",
      "ReportControl",
      "RptEnabled",
      "SCL",
      "SDI",
      "SDO",
      "SMV",
      "SMVSecurity",
      "SampledValueControl",
      "SclFileReference",
      "Server",
      "ServerAt",
      "SettingControl",
      "SourceFiles",
      "SubEquipment",
      "SubFunction",
      "SubNetwork",
      "Substation",
      "TapChanger",
      "Terminal",
      "TransformerWinding",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["source", "type"],
      details: {
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tAnyContentFromOtherNamespace",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Header: {
    tag: "Header",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "baseUuid",
        "fileType",
        "id",
        "nameStructure",
        "revision",
        "toolID",
        "uuid",
        "version"
      ],
      details: {
        baseUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["ICD", "IID", "CID", "SSD", "SCD", "SED"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nameStructure: {
          required: !1,
          default: "IEDName",
          namespace: null,
          validation: {
            enumeration: ["IEDName"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        toolID: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: ["Text", "History", "SourceFiles"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        History: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SourceFiles: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueHitem",
        kind: "unique",
        paths: [["History", "Hitem"]],
        deep: !1,
        attributes: ["version", "revision"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: null,
      validation: {
        enumeration: ["IEDName"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PowerTransformer: {
    tag: "PowerTransformer",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Bay", "Substation", "VoltageLevel"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: "PTR",
          namespace: null,
          validation: {
            enumeration: ["PTR"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "TransformerWinding",
        "SubEquipment",
        "EqFunction"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        TransformerWinding: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInTransformerWinding",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTW",
              kind: "unique",
              paths: [["SubEquipment|.", "TapChanger|.", "EqFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        SubEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubEquipmentPTR",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTRSubEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForPTR",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForPTR",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInPowerTransformer",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInPTR",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipment",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  VoltageLevel: {
    tag: "VoltageLevel",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Substation"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "nomFreq", "numPhases", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nomFreq: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: "0",
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        numPhases: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 255,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "PowerTransformer",
        "GeneralEquipment",
        "Voltage",
        "Bay",
        "Function"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        PowerTransformer: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInPowerTransformer",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTR",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        Voltage: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Bay: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueChildNameInBay",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueLNodeInBay",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunctionVL",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInVoltageLevelFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInVoltageLevel",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInVoltageLevel",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Function: {
    tag: "Function",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Bay", "Line", "Process", "Substation", "VoltageLevel"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "SubFunction",
        "GeneralEquipment",
        "ConductingEquipment"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SubFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInSubFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGEFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipmentOfFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInCondEq",
              kind: "unique",
              paths: [["SubEquipment|.", "EqFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInFunctionSS",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInSubstationFunc",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tPowerSystemResource",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Voltage: {
    tag: "Voltage",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Line", "VoltageLevel"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["multiplier", "unit"],
      details: {
        multiplier: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: [
              "",
              "m",
              "k",
              "M",
              "mu",
              "y",
              "z",
              "a",
              "f",
              "p",
              "n",
              "c",
              "d",
              "da",
              "h",
              "G",
              "T",
              "P",
              "E",
              "Z",
              "Y"
            ],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unit: {
          required: !0,
          default: "V",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConnectivityNode: {
    tag: "ConnectivityNode",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Bay", "Line"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "pathName", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pathName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+/.+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tLNodeContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DataSet: {
    tag: "DataSet",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "FCDA"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FCDA: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 1,
          maxOccurrence: null,
          options: ["FCDA"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReportControl: {
    tag: "ReportControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bufTime",
        "buffered",
        "confRev",
        "datSet",
        "desc",
        "indexed",
        "intgPd",
        "name",
        "rptID",
        "templateUuid",
        "uuid"
      ],
      details: {
        bufTime: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        buffered: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        confRev: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        indexed: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rptID: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[ -~]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 129,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "TrgOps", "OptFields", "RptEnabled"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        TrgOps: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        OptFields: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        RptEnabled: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlWithTriggerOpt",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LogControl: {
    tag: "LogControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bufTime",
        "datSet",
        "desc",
        "intgPd",
        "ldInst",
        "lnClass",
        "lnInst",
        "logEna",
        "logName",
        "name",
        "prefix",
        "reasonCode",
        "templateUuid",
        "uuid"
      ],
      details: {
        bufTime: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: "LLN0",
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logEna: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        reasonCode: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "TrgOps"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        TrgOps: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlWithTriggerOpt",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DOI: {
    tag: "DOI",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["accessControl", "desc", "ix", "name"],
      details: {
        accessControl: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 12,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SDI", "DAI", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SDI: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueSDI_DAIinSDI",
              kind: "unique",
              paths: [["DAI|.", "SDI"]],
              deep: !1,
              attributes: ["name", "ix"],
              refer: null,
              text: !1
            }
          ]
        },
        DAI: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelinDOI",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["SDI", "DAI"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueSDI_DAIinDOI",
        kind: "unique",
        paths: [["DAI|.", "SDI"]],
        deep: !1,
        attributes: ["name", "ix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Inputs: {
    tag: "Inputs",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "ExtRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ExtRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Outputs: {
    tag: "Outputs",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "ExtCtrl"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ExtCtrl: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Log: {
    tag: "Log",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSEControl: {
    tag: "GSEControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "appID",
        "confRev",
        "datSet",
        "desc",
        "fixedOffs",
        "name",
        "securityEnable",
        "templateUuid",
        "type",
        "uuid"
      ],
      details: {
        appID: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[ -~]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 129,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        confRev: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fixedOffs: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        securityEnable: {
          required: !1,
          default: "None",
          namespace: null,
          validation: {
            enumeration: ["None", "Signature", "SignatureAndEncryption"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: "GOOSE",
          namespace: null,
          validation: {
            enumeration: ["GSSE", "GOOSE"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "IEDName", "Protocol"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        IEDName: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Protocol: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlWithIEDName",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SampledValueControl: {
    tag: "SampledValueControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "confRev",
        "datSet",
        "desc",
        "multicast",
        "name",
        "nofASDU",
        "securityEnable",
        "smpMod",
        "smpRate",
        "smvID",
        "templateUuid",
        "uuid"
      ],
      details: {
        confRev: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        multicast: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nofASDU: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        securityEnable: {
          required: !1,
          default: "None",
          namespace: null,
          validation: {
            enumeration: ["None", "Signature", "SignatureAndEncryption"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpMod: {
          required: !1,
          default: "SmpPerPeriod",
          namespace: null,
          validation: {
            enumeration: ["SmpPerPeriod", "SmpPerSec", "SecPerSmp"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpRate: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smvID: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[ -~]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 129,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "IEDName", "SmvOpts", "Protocol"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        IEDName: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SmvOpts: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Protocol: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlWithIEDName",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SettingControl: {
    tag: "SettingControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["actSG", "desc", "numOfSGs", "resvTms"],
      details: {
        actSG: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        numOfSGs: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resvTms: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 65535,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Services: {
    tag: "Services",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["AccessPoint", "IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["nameLength"],
      details: {
        nameLength: {
          required: !1,
          default: "32",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["32", "64", "6[5-9]", "[7-9]\\d", "[1-9]\\d\\d+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [
        "DynAssociation",
        "SettingGroups",
        "GetDirectory",
        "GetDataObjectDefinition",
        "DataObjectDirectory",
        "GetDataSetValue",
        "SetDataSetValue",
        "DataSetDirectory",
        "ConfDataSet",
        "DynDataSet",
        "ReadWrite",
        "TimerActivatedControl",
        "ConfReportControl",
        "GetCBValues",
        "ConfLogControl",
        "ReportSettings",
        "LogSettings",
        "GSESettings",
        "SMVSettings",
        "GSEDir",
        "GOOSE",
        "GSSE",
        "SMVsc",
        "FileHandling",
        "ConfLNs",
        "ClientServices",
        "ConfLdName",
        "SupSubscription",
        "ConfSigRef",
        "ValueHandling",
        "RedProt",
        "TimeSyncProt",
        "CommProt",
        "SCSM",
        "Security",
        "MultiAPPerSubNet"
      ],
      details: {
        DynAssociation: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SettingGroups: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GetDirectory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GetDataObjectDefinition: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        DataObjectDirectory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GetDataSetValue: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SetDataSetValue: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        DataSetDirectory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfDataSet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        DynDataSet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReadWrite: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        TimerActivatedControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfReportControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GetCBValues: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfLogControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportSettings: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogSettings: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GSESettings: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVSettings: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GSEDir: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GOOSE: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GSSE: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVsc: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FileHandling: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfLNs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ClientServices: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfLdName: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SupSubscription: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfSigRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ValueHandling: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        RedProt: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        TimeSyncProt: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        CommProt: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SCSM: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Security: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        MultiAPPerSubNet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AccessPoint: {
    tag: "AccessPoint",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["clock", "desc", "kdc", "name", "router", "templateUuid", "uuid"],
      details: {
        clock: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        kdc: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        router: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Server",
        "LN",
        "ServerAt",
        "Services",
        "GOOSESecurity",
        "SMVSecurity",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Server: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueAssociationInServer",
              kind: "unique",
              paths: [["Association"]],
              deep: !1,
              attributes: ["associationID"],
              refer: null,
              text: !1
            }
          ]
        },
        LN: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        },
        ServerAt: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Services: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GOOSESecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 7
          },
          constraints: null
        },
        SMVSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 7
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInAP",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["Server", "LN", "ServerAt"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueLNInAccessPoint",
        kind: "unique",
        paths: [["LN"]],
        deep: !1,
        attributes: ["inst", "lnClass", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  KDC: {
    tag: "KDC",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["apName", "apUuid", "iedName"],
      details: {
        apName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        apUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  IEDSourceFiles: {
    tag: "IEDSourceFiles",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SclFileReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SclFileReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MinRequestedSCDFiles: {
    tag: "MinRequestedSCDFiles",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "MinRequestedSCDFile"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        MinRequestedSCDFile: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueProjectInReqSCD",
        kind: "unique",
        paths: [["MinRequestedSCDFile"]],
        deep: !1,
        attributes: ["fileUuid"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubNetwork: {
    tag: "SubNetwork",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Communication"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["8-MMS", "8-XMPP"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "BitRate", "ConnectedAP"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        BitRate: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConnectedAP: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueGSEinConnectedAP",
              kind: "unique",
              paths: [["GSE"]],
              deep: !1,
              attributes: ["cbName", "ldInst"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSMVinConnectedAP",
              kind: "unique",
              paths: [["SMV"]],
              deep: !1,
              attributes: ["cbName", "ldInst"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueConnectedAP",
        kind: "unique",
        paths: [["ConnectedAP"]],
        deep: !1,
        attributes: ["iedName", "apName"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeType: {
    tag: "LNodeType",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DataTypeTemplates"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "id", "iedType", "lnClass"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedType: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "DO", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DO: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLNType",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueDOInLNodeType",
        kind: "unique",
        paths: [["DO"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tIDNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DOType: {
    tag: "DOType",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DataTypeTemplates"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["cdc", "desc", "id", "iedType"],
      details: {
        cdc: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "SPS",
              "DPS",
              "INS",
              "ENS",
              "ACT",
              "ACD",
              "SEC",
              "BCR",
              "HST",
              "VSS",
              "MV",
              "CMV",
              "SAV",
              "WYE",
              "DEL",
              "SEQ",
              "HMV",
              "HWYE",
              "HDEL",
              "SPC",
              "DPC",
              "INC",
              "ENC",
              "BSC",
              "ISC",
              "APC",
              "BAC",
              "SPG",
              "ING",
              "ENG",
              "ORG",
              "TSG",
              "CUG",
              "VSG",
              "ASG",
              "CURVE",
              "CSG",
              "DPL",
              "LPL",
              "CSD",
              "CST",
              "BTS",
              "UTS",
              "LTS",
              "GTS",
              "MTS",
              "NTS",
              "STS",
              "CTS",
              "OTS",
              "VSD",
              "ORS",
              "TCS"
            ],
            pattern: ["\\i\\c*", "[A-Za-z]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 5,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedType: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SDO", "DA", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SDO: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        DA: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueProtNsInDA",
              kind: "unique",
              paths: [["ProtNs"]],
              deep: !1,
              attributes: ["type"],
              refer: null,
              text: !1
            }
          ]
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDOType",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["SDO", "DA"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueDAorSDOInDOType",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tIDNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DAType: {
    tag: "DAType",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DataTypeTemplates"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "id", "iedType"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedType: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "BDA", "ProtNs", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        BDA: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        },
        ProtNs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDAType",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueBDAInDAType",
        kind: "unique",
        paths: [["BDA"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueProtNs",
        kind: "unique",
        paths: [["ProtNs"]],
        deep: !1,
        attributes: ["type"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tIDNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  EnumType: {
    tag: "EnumType",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DataTypeTemplates"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "EnumVal"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        EnumVal: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: ["[\\p{IsBasicLatin}\\p{IsLatin-1Supplement}]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 127,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueOrdInEnumType",
        kind: "unique",
        paths: [["EnumVal"]],
        deep: !1,
        attributes: ["ord"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueEnumValue",
        kind: "unique",
        paths: [["EnumVal"]],
        deep: !1,
        attributes: [],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tIDNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Resource: {
    tag: "Resource",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `resource bound to this element could be multi

resource bound to this element could be multi`,
    parents: ["ProcessResource"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["resInst", "source", "sourceUuid"],
      details: {
        resInst: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "normalizedString",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GooseParametersRef: {
    tag: "GooseParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the communication parameters expected for the current SourceRef when ServiceType is GOOSE

Specification of the communication parameters expected for the current SourceRef when ServiceType is GOOSE`,
    parents: ["SourceRef", "SubscriberLNode"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVParametersRef: {
    tag: "SMVParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the communication parameters expected for the current SourceRef when ServiceType is SMV

Specification of the communication parameters expected for the current SourceRef when ServiceType is SMV`,
    parents: ["SourceRef", "SubscriberLNode"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReportParametersRef: {
    tag: "ReportParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the communication parameters expected for the current SourceRef when ServiceType is Report

Specification of the communication parameters expected for the current SourceRef when ServiceType is Report`,
    parents: ["SourceRef", "SubscriberLNode"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BinaryWiringParametersRef: {
    tag: "BinaryWiringParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the binary wiring parameters expected for the current SourceRef when ServiceType is Wired

Specification of the binary wiring parameters expected for the current SourceRef when ServiceType is Wired`,
    parents: ["ControlRef", "ControllingLNode", "SourceRef", "SubscriberLNode"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AnalogueWiringParametersRef: {
    tag: "AnalogueWiringParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the analogue wiring parameters expected for the current SourceRef when ServiceType is Wired

Specification of the analogue wiring parameters expected for the current SourceRef when ServiceType is Wired`,
    parents: ["ControlRef", "ControllingLNode", "SourceRef"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Val: {
    tag: "Val",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["BDA", "DA", "DAI", "DAS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["sGroup"],
      details: {
        sGroup: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "normalizedString",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Label: {
    tag: "Label",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Labels"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["id", "lang"],
      details: {
        id: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lang: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "normalizedString",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  L2CommParameters: {
    tag: "L2CommParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["GooseParameters", "SMVParameters"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["appId", "desc", "macAddr", "vlanId", "vlanPriority"],
      details: {
        appId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        macAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanPriority: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-7]"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tCommParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  L3IPv4CommParameters: {
    tag: "L3IPv4CommParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["GooseParameters", "SMVParameters"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["IPv4", "IPv4-IGMPv3Src", "appId", "desc", "vlanId", "vlanPriority"],
      details: {
        IPv4: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        "IPv4-IGMPv3Src": {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        appId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanPriority: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-7]"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tCommParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  L3IPv6CommParameters: {
    tag: "L3IPv6CommParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["GooseParameters", "SMVParameters"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["IPv6", "IPv6-IGMPv3Src", "appId", "desc", "vlanId", "vlanPriority"],
      details: {
        IPv6: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["([0-9a-f]{1,4}:){7}[0-9a-f]{1,4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        "IPv6-IGMPv3Src": {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["([0-9a-f]{1,4}:){7}[0-9a-f]{1,4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        appId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanPriority: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-7]"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tCommParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionalVariantRef: {
    tag: "FunctionalVariantRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Ref to a functional variant of the Application

Ref to a functional variant of the Application`,
    parents: [
      "AllocationRoleRef",
      "BehaviorDescriptionRef",
      "FunctionCategoryRef",
      "FunctionRef",
      "FunctionRole",
      "InputVarRef",
      "LNodeDataRef",
      "LNodeInputRef",
      "LNodeOutputRef",
      "OutputVarRef",
      "PowerSystemRelationRef",
      "ProcessResourceRef",
      "SignalRole",
      "VariableRef"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["functionalVariant", "functionalVariantUuid", "update"],
      details: {
        functionalVariant: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionalVariantUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        update: {
          required: !1,
          default: "add",
          namespace: null,
          validation: {
            enumeration: ["add", "remove"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: ["add", "remove"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SignalRole: {
    tag: "SignalRole",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Signal list attached to the referenced function in the context of the cureent Role definition

Signal list attached to the referenced function in the context of the cureent Role definition`,
    parents: ["FunctionRef"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef", "LNodeInputRef", "LNodeOutputRef", "LNodeDataRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LNodeInputRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LNodeOutputRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LNodeDataRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionRoleContent: {
    tag: "FunctionRoleContent",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `an instance of the current role. In case of application type definition, instance 1 is the default instance

an instance of the current role. In case of application type definition, instance 1 is the default instance`,
    parents: ["FunctionRole"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["roleInst"],
      details: {
        roleInst: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "FunctionRef",
        "BehaviorDescriptionRef",
        "ProcessResourceRef",
        "VariableRef",
        "FunctionCategoryRef",
        "PowerSystemRelationRef"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        BehaviorDescriptionRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessResourceRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        VariableRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionCategoryRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        PowerSystemRelationRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "FunctionRef",
            "BehaviorDescriptionRef",
            "ProcessResourceRef",
            "VariableRef",
            "FunctionCategoryRef",
            "PowerSystemRelationRef"
          ]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionalSubVariant: {
    tag: "FunctionalSubVariant",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Sub variant of the current variant

Sub variant of the current variant`,
    parents: ["FunctionalSubVariant", "FunctionalVariant"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "isBaseline", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        isBaseline: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalSubVariant", "VariableRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalSubVariant: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        VariableRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalSubVariant", "VariableRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tAbstractFunctionalVariant",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  VariableRef: {
    tag: "VariableRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a variable attached to current variant, to parameterize the instance with the value defined in the reference

Reference to a variable attached to current variant, to parameterize the instance with the value defined in the reference`,
    parents: ["FunctionRoleContent", "FunctionalSubVariant", "FunctionalVariant"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "value", "variable", "variableUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        variable: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        variableUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tVariableRef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  EqFunction: {
    tag: "EqFunction",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [
      "ConductingEquipment",
      "GeneralEquipment",
      "PowerTransformer",
      "SubEquipment",
      "TapChanger",
      "TransformerWinding"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "GeneralEquipment", "EqSubFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfFuncForEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGEFuncForEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqSubFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubFuncForEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubFuncForEquipment",
              kind: "unique",
              paths: [["EqSubFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInFuncForGE",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInFuncForGE",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tAbstractEqFuncSubFunc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Terminal: {
    tag: "Terminal",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ConductingEquipment", "TransformerWinding"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bayName",
        "cNodeName",
        "cNodeUuid",
        "connectivityNode",
        "desc",
        "lineName",
        "name",
        "processName",
        "substationName",
        "voltageLevelName"
      ],
      details: {
        bayName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cNodeName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        connectivityNode: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+/.+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lineName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        substationName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        voltageLevelName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubEquipment: {
    tag: "SubEquipment",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ConductingEquipment", "PowerTransformer", "TapChanger", "TransformerWinding"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "phase", "templateUuid", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        phase: {
          required: !1,
          default: "none",
          namespace: null,
          validation: {
            enumeration: ["A", "B", "C", "N", "all", "none", "AB", "BC", "CA"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "EqFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForSubEq",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForSubEq",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInSubEquipment",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInACESubEquipment",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tPowerSystemResource",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  History: {
    tag: "History",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Header"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: ["Hitem"],
      details: {
        Hitem: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SourceFiles: {
    tag: "SourceFiles",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Header", "Hitem"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SclFileReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SclFileReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TransformerWinding: {
    tag: "TransformerWinding",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["PowerTransformer"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: "PTW",
          namespace: null,
          validation: {
            enumeration: ["PTW"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "Terminal",
        "SubEquipment",
        "TapChanger",
        "NeutralPoint",
        "EqFunction"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Terminal: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 2
          },
          constraints: null
        },
        SubEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInACESubEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        TapChanger: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLNodeInTapChanger",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInLTC",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        NeutralPoint: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForPTW",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForPTW",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInTransformerWinding",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInPTW",
        kind: "unique",
        paths: [["SubEquipment|.", "TapChanger|.", "EqFunction"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tAbstractConductingEquipment",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Bay: {
    tag: "Bay",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["VoltageLevel"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "PowerTransformer",
        "GeneralEquipment",
        "ConductingEquipment",
        "ConnectivityNode",
        "Function"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        PowerTransformer: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInPowerTransformer",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTR",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInCE",
              kind: "unique",
              paths: [["SubEquipment|.", "EqFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConnectivityNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConnectivityNode",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunctionB",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInBayFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInBay",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInBay",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubFunction: {
    tag: "SubFunction",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Function", "SubFunction"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "GeneralEquipment",
        "ConductingEquipment",
        "SubFunction"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfSubFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGESubFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipmentOfSubFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubEquipmentSubFunc",
              kind: "unique",
              paths: [["SubEquipment"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        SubFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubSubFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubSubFunc",
              kind: "unique",
              paths: [["SubFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInSubFunction",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInSubFunc",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tPowerSystemResource",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FCDA: {
    tag: "FCDA",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DataSet"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["daName", "doName", "fc", "ix", "ldInst", "lnClass", "lnInst", "lnUuid", "prefix"],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fc: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "ST",
              "MX",
              "CO",
              "SP",
              "SG",
              "SE",
              "SV",
              "CF",
              "DC",
              "EX",
              "SR",
              "BL",
              "OR"
            ],
            pattern: ["\\i\\c*", "[A-Z]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 2,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TrgOps: {
    tag: "TrgOps",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LogControl", "ReportControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["dchg", "dupd", "gi", "period", "qchg"],
      details: {
        dchg: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dupd: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        gi: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        period: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        qchg: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  OptFields: {
    tag: "OptFields",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ReportControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "bufOvfl",
        "configRef",
        "dataRef",
        "dataSet",
        "entryID",
        "reasonCode",
        "seqNum",
        "timeStamp"
      ],
      details: {
        bufOvfl: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        configRef: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataRef: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataSet: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        entryID: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        reasonCode: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        seqNum: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        timeStamp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  RptEnabled: {
    tag: "RptEnabled",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ReportControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "max"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "ClientLN"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ClientLN: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SDI: {
    tag: "SDI",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DOI", "SDI"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "ix", "name", "sAddr"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SDI", "DAI", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SDI: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        DAI: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelinSDI",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["SDI", "DAI"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueSDI_DAIinSDI",
        kind: "unique",
        paths: [["DAI|.", "SDI"]],
        deep: !1,
        attributes: ["name", "ix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DAI: {
    tag: "DAI",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DOI", "SDI"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "ix", "name", "sAddr", "valImport", "valKind"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valImport: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valKind: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Spec", "Conf", "RO", "Set"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Val", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Val: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelinDAI",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ExtRef: {
    tag: "ExtRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Inputs"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "daName",
        "desc",
        "doName",
        "iedName",
        "intAddr",
        "ldInst",
        "lnClass",
        "lnInst",
        "lnUuid",
        "pDA",
        "pDO",
        "pLN",
        "pServT",
        "prefix",
        "serviceType",
        "srcCBName",
        "srcCBUuid",
        "srcLDInst",
        "srcLNClass",
        "srcLNInst",
        "srcPrefix",
        "templateUuid",
        "uuid"
      ],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "@",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDA: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDO: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pServT: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Poll", "Report", "GOOSE", "SMV"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        serviceType: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Poll", "Report", "GOOSE", "SMV"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcCBName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcCBUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcLDInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcLNClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcLNInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcPrefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tDORef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ExtCtrl: {
    tag: "ExtCtrl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Outputs"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "apRef",
        "checkInterlock",
        "checkSynchrocheck",
        "desc",
        "doName",
        "iedName",
        "intAddr",
        "ldInst",
        "lnClass",
        "lnInst",
        "lnUuid",
        "pDO",
        "pLN",
        "prefix",
        "templateUuid",
        "uuid"
      ],
      details: {
        apRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        checkInterlock: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: ["true", "false", "conserve"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        checkSynchrocheck: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: ["true", "false", "conserve"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "@",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDO: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tDORef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  IEDName: {
    tag: "IEDName",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["GSEControl", "SampledValueControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["apRef", "apUuid", "ldInst", "ldUuid", "lnClass", "lnInst", "lnUuid", "prefix"],
      details: {
        apRef: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        apUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tIEDName",
      validation: {
        enumeration: null,
        pattern: [
          "[A-Za-z][0-9A-Za-z_]{0,2}",
          "[A-Za-z][0-9A-Za-z_]{4,63}",
          "[A-MO-Za-z][0-9A-Za-z_]{3}",
          "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
          "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
          "Non[0-9A-Za-df-z_]",
          "[A-Za-z][0-9A-Za-z_]*",
          "\\i\\c*"
        ],
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: 64,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Protocol: {
    tag: "Protocol",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["GSEControl", "SampledValueControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["mustUnderstand"],
      details: {
        mustUnderstand: {
          required: !0,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "normalizedString",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SmvOpts: {
    tag: "SmvOpts",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SampledValueControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "dataSet",
        "refreshTime",
        "sampleMode",
        "sampleRate",
        "sampleSynchronized",
        "security",
        "synchSourceId",
        "timestamp"
      ],
      details: {
        dataSet: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        refreshTime: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sampleMode: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sampleRate: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sampleSynchronized: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        security: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        synchSourceId: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        timestamp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DynAssociation: {
    tag: "DynAssociation",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max"],
      details: {
        max: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SettingGroups: {
    tag: "SettingGroups",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: ["SGEdit", "ConfSG"],
      details: {
        SGEdit: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfSG: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GetDirectory: {
    tag: "GetDirectory",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GetDataObjectDefinition: {
    tag: "GetDataObjectDefinition",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DataObjectDirectory: {
    tag: "DataObjectDirectory",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GetDataSetValue: {
    tag: "GetDataSetValue",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SetDataSetValue: {
    tag: "SetDataSetValue",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DataSetDirectory: {
    tag: "DataSetDirectory",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfDataSet: {
    tag: "ConfDataSet",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max", "maxAttributes", "modify"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxAttributes: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        modify: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMaxAndMaxAttributes",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DynDataSet: {
    tag: "DynDataSet",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max", "maxAttributes"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxAttributes: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMax",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReadWrite: {
    tag: "ReadWrite",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TimerActivatedControl: {
    tag: "TimerActivatedControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfReportControl: {
    tag: "ConfReportControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["bufConf", "bufMode", "max", "maxBuf"],
      details: {
        bufConf: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        bufMode: {
          required: !1,
          default: "both",
          namespace: null,
          validation: {
            enumeration: ["unbuffered", "buffered", "both"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxBuf: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMax",
      validation: {
        enumeration: ["unbuffered", "buffered", "both"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GetCBValues: {
    tag: "GetCBValues",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfLogControl: {
    tag: "ConfLogControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReportSettings: {
    tag: "ReportSettings",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "bufTime",
        "cbName",
        "datSet",
        "intgPd",
        "optFields",
        "owner",
        "resvTms",
        "rptID",
        "trgOps"
      ],
      details: {
        bufTime: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbName: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        optFields: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        owner: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resvTms: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rptID: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        trgOps: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceSettings",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LogSettings: {
    tag: "LogSettings",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["cbName", "datSet", "intgPd", "logEna", "trgOps"],
      details: {
        cbName: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logEna: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        trgOps: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceSettings",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSESettings: {
    tag: "GSESettings",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["appID", "cbName", "datSet", "dataLabel", "kdaParticipant"],
      details: {
        appID: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbName: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataLabel: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        kdaParticipant: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: ["McSecurity"],
      details: {
        McSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceSettings",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVSettings: {
    tag: "SMVSettings",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cbName",
        "datSet",
        "kdaParticipant",
        "nofASDU",
        "optFields",
        "pdcTimeStamp",
        "samplesPerSec",
        "smpRate",
        "svID",
        "synchSrcId"
      ],
      details: {
        cbName: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        kdaParticipant: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nofASDU: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        optFields: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pdcTimeStamp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        samplesPerSec: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpRate: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        svID: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        synchSrcId: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: ["SmpRate", "SamplesPerSec", "SecPerSamples", "McSecurity"],
      details: {
        SmpRate: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SamplesPerSec: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SecPerSamples: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        McSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 1,
          maxOccurrence: null,
          options: ["SmpRate", "SamplesPerSec", "SecPerSamples"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tServiceSettings",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSEDir: {
    tag: "GSEDir",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GOOSE: {
    tag: "GOOSE",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["fixedOffs", "goose", "max", "rGOOSE"],
      details: {
        fixedOffs: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        goose: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rGOOSE: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMax",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSSE: {
    tag: "GSSE",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVsc: {
    tag: "SMVsc",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["delivery", "deliveryConf", "max", "rSV", "sv"],
      details: {
        delivery: {
          required: !1,
          default: "multicast",
          namespace: null,
          validation: {
            enumeration: ["unicast", "multicast", "both"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        deliveryConf: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rSV: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sv: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMax",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FileHandling: {
    tag: "FileHandling",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["ftp", "ftps", "mms"],
      details: {
        ftp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ftps: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mms: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfLNs: {
    tag: "ConfLNs",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["fixLnInst", "fixPrefix"],
      details: {
        fixLnInst: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fixPrefix: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ClientServices: {
    tag: "ClientServices",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "acceptServerInitiatedAssociation",
        "bufReport",
        "goose",
        "gsse",
        "maxAttributes",
        "maxGOOSE",
        "maxReports",
        "maxSMV",
        "noIctBinding",
        "rGOOSE",
        "rSV",
        "readLog",
        "supportsLdName",
        "sv",
        "unbufReport"
      ],
      details: {
        acceptServerInitiatedAssociation: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        bufReport: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        goose: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        gsse: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxAttributes: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxGOOSE: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxReports: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxSMV: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        noIctBinding: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rGOOSE: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rSV: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        readLog: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        supportsLdName: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sv: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unbufReport: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: ["TimeSyncProt", "GOOSEMcSecurity", "SVMcSecurity", "Security"],
      details: {
        TimeSyncProt: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GOOSEMcSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SVMcSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Security: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfLdName: {
    tag: "ConfLdName",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SupSubscription: {
    tag: "SupSubscription",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["maxGo", "maxSv"],
      details: {
        maxGo: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxSv: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfSigRef: {
    tag: "ConfSigRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ValueHandling: {
    tag: "ValueHandling",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["setToRO"],
      details: {
        setToRO: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  RedProt: {
    tag: "RedProt",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["hsr", "prp", "rstp"],
      details: {
        hsr: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rstp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TimeSyncProt: {
    tag: "TimeSyncProt",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ClientServices", "Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["c37_238", "iec61850_9_3", "other", "sntp"],
      details: {
        c37_238: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iec61850_9_3: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        other: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sntp: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  CommProt: {
    tag: "CommProt",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["ipv6"],
      details: {
        ipv6: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SCSM: {
    tag: "SCSM",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["iec61850_8_1", "iec61850_8_2", "serverAssociationInitiation"],
      details: {
        iec61850_8_1: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iec61850_8_2: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        serverAssociationInitiation: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Security: {
    tag: "Security",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ClientServices", "Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["ACSEAuthentication", "E2ESecurity"],
      details: {
        ACSEAuthentication: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        E2ESecurity: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MultiAPPerSubNet: {
    tag: "MultiAPPerSubNet",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Server: {
    tag: "Server",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["AccessPoint"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "timeout"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        timeout: {
          required: !1,
          default: "30",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Authentication", "LDevice", "Association"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Authentication: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LDevice: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNInLDevice",
              kind: "unique",
              paths: [["LN"]],
              deep: !1,
              attributes: ["inst", "lnClass", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Association: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueAssociationInServer",
        kind: "unique",
        paths: [["Association"]],
        deep: !1,
        attributes: ["associationID"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ServerAt: {
    tag: "ServerAt",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["AccessPoint"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["apName", "apUuid", "desc"],
      details: {
        apName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        apUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GOOSESecurity: {
    tag: "GOOSESecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["AccessPoint"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "serialNumber", "templateUuid", "uuid", "xferNumber"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        serialNumber: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        xferNumber: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "Subject", "IssuerName"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        Subject: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        IssuerName: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVSecurity: {
    tag: "SMVSecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["AccessPoint"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "serialNumber", "templateUuid", "uuid", "xferNumber"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        serialNumber: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        xferNumber: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "Subject", "IssuerName"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        Subject: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        IssuerName: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MinRequestedSCDFile: {
    tag: "MinRequestedSCDFile",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["MinRequestedSCDFiles"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "fileName", "fileType", "fileUuid", "revision", "version", "when"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["SCD", "ICD", "IID", "CID", "SSD", "SED"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tSclFileUUIDReference",
      validation: {
        enumeration: ["SCD"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BitRate: {
    tag: "BitRate",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SubNetwork"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["multiplier", "unit"],
      details: {
        multiplier: {
          required: !1,
          default: "M",
          namespace: null,
          validation: {
            enumeration: [
              "",
              "m",
              "k",
              "M",
              "mu",
              "y",
              "z",
              "a",
              "f",
              "p",
              "n",
              "c",
              "d",
              "da",
              "h",
              "G",
              "T",
              "P",
              "E",
              "Z",
              "Y"
            ],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unit: {
          required: !1,
          default: "b/s",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "decimal",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConnectedAP: {
    tag: "ConnectedAP",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SubNetwork"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["apName", "apUuid", "desc", "iedName", "redProt"],
      details: {
        apName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        apUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        redProt: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["none", "hsr", "prp", "rstp"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Address", "GSE", "SMV", "PhysConn"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Address: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GSE: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SMV: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        PhysConn: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniquePTypeInPhysConn",
              kind: "unique",
              paths: [["P"]],
              deep: !1,
              attributes: ["type"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueGSEinConnectedAP",
        kind: "unique",
        paths: [["GSE"]],
        deep: !1,
        attributes: ["cbName", "ldInst"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueSMVinConnectedAP",
        kind: "unique",
        paths: [["SMV"]],
        deep: !1,
        attributes: ["cbName", "ldInst"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DO: {
    tag: "DO",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LNodeType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["accessControl", "desc", "name", "transient", "type"],
      details: {
        accessControl: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 12,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        transient: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDO",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SDO: {
    tag: "SDO",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DOType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["count", "desc", "name", "type"],
      details: {
        count: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[a-z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[a-z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInSDO",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DA: {
    tag: "DA",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DOType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bType",
        "count",
        "dchg",
        "desc",
        "dupd",
        "fc",
        "name",
        "qchg",
        "sAddr",
        "type",
        "valImport",
        "valKind"
      ],
      details: {
        bType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "BOOLEAN",
              "INT8",
              "INT16",
              "INT24",
              "INT32",
              "INT64",
              "INT128",
              "INT8U",
              "INT16U",
              "INT24U",
              "INT32U",
              "FLOAT32",
              "FLOAT64",
              "Enum",
              "Dbpos",
              "Tcmd",
              "Quality",
              "Timestamp",
              "VisString32",
              "VisString64",
              "VisString65",
              "VisString129",
              "VisString255",
              "Octet64",
              "Unicode255",
              "Struct",
              "EntryTime",
              "Check",
              "ObjRef",
              "Currency",
              "PhyComAddr",
              "TrgOps",
              "OptFlds",
              "SvOptFlds",
              "LogOptFlds",
              "EntryID",
              "Octet6",
              "Octet16"
            ],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        count: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dchg: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dupd: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fc: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "ST",
              "MX",
              "CO",
              "SP",
              "SG",
              "SE",
              "SV",
              "CF",
              "DC",
              "EX",
              "SR",
              "BL",
              "OR"
            ],
            pattern: ["\\i\\c*", "[A-Z]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 2,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        qchg: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valImport: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valKind: {
          required: !1,
          default: "Set",
          namespace: null,
          validation: {
            enumeration: ["Spec", "Conf", "RO", "Set"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Val", "Labels", "ProtNs"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Val: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDA",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        ProtNs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueProtNsInDA",
        kind: "unique",
        paths: [["ProtNs"]],
        deep: !1,
        attributes: ["type"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tAbstractDataAttribute",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BDA: {
    tag: "BDA",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DAType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["bType", "count", "desc", "name", "sAddr", "type", "valImport", "valKind"],
      details: {
        bType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "BOOLEAN",
              "INT8",
              "INT16",
              "INT24",
              "INT32",
              "INT64",
              "INT128",
              "INT8U",
              "INT16U",
              "INT24U",
              "INT32U",
              "FLOAT32",
              "FLOAT64",
              "Enum",
              "Dbpos",
              "Tcmd",
              "Quality",
              "Timestamp",
              "VisString32",
              "VisString64",
              "VisString65",
              "VisString129",
              "VisString255",
              "Octet64",
              "Unicode255",
              "Struct",
              "EntryTime",
              "Check",
              "ObjRef",
              "Currency",
              "PhyComAddr",
              "TrgOps",
              "OptFlds",
              "SvOptFlds",
              "LogOptFlds",
              "EntryID",
              "Octet6",
              "Octet16"
            ],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        count: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valImport: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valKind: {
          required: !1,
          default: "Set",
          namespace: null,
          validation: {
            enumeration: ["Spec", "Conf", "RO", "Set"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Val", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Val: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDA",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tAbstractDataAttribute",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProtNs: {
    tag: "ProtNs",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DA", "DAType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["type"],
      details: {
        type: {
          required: !1,
          default: "8-MMS",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tNamespaceName",
      validation: {
        enumeration: null,
        pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  EnumVal: {
    tag: "EnumVal",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["EnumType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "ord"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ord: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: -2147483648,
            maxInclusive: 2147483647,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tEnumStringValue",
      validation: {
        enumeration: null,
        pattern: ["[\\p{IsBasicLatin}\\p{IsLatin-1Supplement}]*"],
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: 127,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeInputRef: {
    tag: "LNodeInputRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to SourceRefs belonging to current role

Reference to SourceRefs belonging to current role`,
    parents: ["SignalRole"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "sourceRef", "sourceRefUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceRefUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeOutputRef: {
    tag: "LNodeOutputRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to ControlRefs belonging to current role

Reference to ControlRefs belonging to current role`,
    parents: ["SignalRole"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["controlRef", "controlRefUuid", "desc"],
      details: {
        controlRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        controlRefUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeDataRef: {
    tag: "LNodeDataRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to Data belonging to current role

Reference to Data belonging to current role`,
    parents: ["SignalRole"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["daName", "data", "desc", "doName", "lnodeUuid"],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        data: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BehaviorDescriptionRef: {
    tag: "BehaviorDescriptionRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a behavior description attached to current role

Reference to a behavior description attached to current role`,
    parents: ["FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["behaviorDescription", "behaviorDescriptionUuid", "desc"],
      details: {
        behaviorDescription: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        behaviorDescriptionUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef", "InputVarRef", "OutputVarRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        InputVarRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        OutputVarRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        },
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["InputVarRef", "OutputVarRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProcessResourceRef: {
    tag: "ProcessResourceRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a process resource attached to current role

Reference to a process resource attached to current role`,
    parents: ["FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "processResource", "processResourceUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processResource: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processResourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionCategoryRef: {
    tag: "FunctionCategoryRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a function category attached to current role

Reference to a function category attached to current role`,
    parents: ["FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "functionCategory", "functionCategoryUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionCategory: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionCategoryUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PowerSystemRelationRef: {
    tag: "PowerSystemRelationRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a power system relation attached to current role

Reference to a power system relation attached to current role`,
    parents: ["FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "powerSystemRelation", "powerSystemRelationUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        powerSystemRelation: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        powerSystemRelationUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  EqSubFunction: {
    tag: "EqSubFunction",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["EqFunction", "EqSubFunction"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "GeneralEquipment", "EqSubFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfFuncForEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGEFuncForEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqSubFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubFuncForEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubFuncForEquipment",
              kind: "unique",
              paths: [["EqSubFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInSubFuncForEquipment",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueSubFuncForEquipment",
        kind: "unique",
        paths: [["EqSubFunction"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tAbstractEqFuncSubFunc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Hitem: {
    tag: "Hitem",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["History"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["revision", "version", "what", "when", "who", "why"],
      details: {
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        what: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        who: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        why: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["SourceFiles"],
      details: {
        SourceFiles: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tAnyContentFromOtherNamespace",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TapChanger: {
    tag: "TapChanger",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["TransformerWinding"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: "LTC",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "SubEquipment", "EqFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SubEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubEquipmentLTC",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInLTCSubEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForLTC",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForLTC",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInTapChanger",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInLTC",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tPowerSystemResource",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  NeutralPoint: {
    tag: "NeutralPoint",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["TransformerWinding"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bayName",
        "cNodeName",
        "cNodeUuid",
        "connectivityNode",
        "desc",
        "lineName",
        "name",
        "processName",
        "substationName",
        "voltageLevelName"
      ],
      details: {
        bayName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cNodeName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        connectivityNode: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+/.+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lineName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        substationName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        voltageLevelName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ClientLN: {
    tag: "ClientLN",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["RptEnabled"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["apRef", "desc", "iedName", "ldInst", "lnClass", "lnInst", "lnUuid", "prefix"],
      details: {
        apRef: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 0,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SGEdit: {
    tag: "SGEdit",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SettingGroups"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["resvTms"],
      details: {
        resvTms: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfSG: {
    tag: "ConfSG",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SettingGroups"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["resvTms"],
      details: {
        resvTms: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  McSecurity: {
    tag: "McSecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["GSESettings", "SMVSettings"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["encryption", "signature"],
      details: {
        encryption: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        signature: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SmpRate: {
    tag: "SmpRate",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SMVSettings"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: 0,
        maxInclusive: 4294967295,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SamplesPerSec: {
    tag: "SamplesPerSec",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SMVSettings"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: 0,
        maxInclusive: 4294967295,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SecPerSamples: {
    tag: "SecPerSamples",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SMVSettings"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: 0,
        maxInclusive: 4294967295,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GOOSEMcSecurity: {
    tag: "GOOSEMcSecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ClientServices"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["encryption", "signature"],
      details: {
        encryption: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        signature: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SVMcSecurity: {
    tag: "SVMcSecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ClientServices"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["encryption", "signature"],
      details: {
        encryption: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        signature: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Authentication: {
    tag: "Authentication",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Server"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["certificate", "none", "password", "strong", "weak"],
      details: {
        certificate: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        none: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        password: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        strong: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        weak: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LDevice: {
    tag: "LDevice",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Server"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "inst", "ldName", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "LN0", "LN", "AccessControl", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LN0: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LN: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        AccessControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLD",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNInLDevice",
        kind: "unique",
        paths: [["LN"]],
        deep: !1,
        attributes: ["inst", "lnClass", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Association: {
    tag: "Association",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Server"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "apRef",
        "associationID",
        "desc",
        "iedName",
        "initiator",
        "kind",
        "ldInst",
        "lnClass",
        "lnInst",
        "lnUuid",
        "prefix"
      ],
      details: {
        apRef: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        associationID: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-Za-z]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        initiator: {
          required: !1,
          default: "client",
          namespace: null,
          validation: {
            enumeration: ["client", "server"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        kind: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["pre-established", "predefined"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 0,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Subject: {
    tag: "Subject",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["GOOSESecurity", "SMVSecurity"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["commonName", "idHierarchy"],
      details: {
        commonName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["none", "CN=.+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 4,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        idHierarchy: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  IssuerName: {
    tag: "IssuerName",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["GOOSESecurity", "SMVSecurity"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["commonName", "idHierarchy"],
      details: {
        commonName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["none", "CN=.+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 4,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        idHierarchy: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Address: {
    tag: "Address",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ConnectedAP", "GSE", "SMV"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: ["P"],
      details: {
        P: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSE: {
    tag: "GSE",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ConnectedAP"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["cbName", "cbUuid", "desc", "ldInst"],
      details: {
        cbName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Address", "MinTime", "MaxTime"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Address: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        MinTime: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        MaxTime: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlBlock",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMV: {
    tag: "SMV",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ConnectedAP"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["cbName", "cbUuid", "desc", "ldInst"],
      details: {
        cbName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Address"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Address: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlBlock",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PhysConn: {
    tag: "PhysConn",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ConnectedAP"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "type"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Connection", "RedConn"],
            pattern: ["[A-Z][0-9A-Za-z\\-]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "P"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        P: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniquePTypeInPhysConn",
        kind: "unique",
        paths: [["P"]],
        deep: !1,
        attributes: ["type"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  InputVarRef: {
    tag: "InputVarRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to InputVar belonging to current behavior description

Reference to InputVar belonging to current behavior description`,
    parents: ["BehaviorDescriptionRef"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "value", "variable"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        variable: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  OutputVarRef: {
    tag: "OutputVarRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to OutputVar belonging to current behavior description

Reference to OutputVar belonging to current behavior description`,
    parents: ["BehaviorDescriptionRef"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "value", "variable"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        variable: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AccessControl: {
    tag: "AccessControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LDevice"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tAnyContentFromOtherNamespace",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  P: {
    tag: "P",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Address", "PhysConn"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["type"],
      details: {
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "IP",
              "IP-SUBNET",
              "IP-GATEWAY",
              "OSI-NSAP",
              "OSI-TSEL",
              "OSI-SSEL",
              "OSI-PSEL",
              "OSI-AP-Title",
              "OSI-AP-Invoke",
              "OSI-AE-Qualifier",
              "OSI-AE-Invoke",
              "MAC-Address",
              "APPID",
              "VLAN-PRIORITY",
              "VLAN-ID",
              "SNTP-Port",
              "MMS-Port",
              "DNSName",
              "IPv6FlowLabel",
              "IPv6ClassOfTraffic",
              "C37-118-IP-Port",
              "IP-UDP-PORT",
              "IP-TCP-PORT",
              "IPv6",
              "IPv6-SUBNET",
              "IPv6-GATEWAY",
              "IPv6-IGMPv3Src",
              "IP-IGMPv3Src",
              "IP-ClassOfTraffic"
            ],
            pattern: ["\\i\\c*", "[A-Z][0-9A-Za-z\\-]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tPAddr",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: 1,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MinTime: {
    tag: "MinTime",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["GSE"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["multiplier", "unit"],
      details: {
        multiplier: {
          required: !1,
          default: "m",
          namespace: null,
          validation: {
            enumeration: [
              "",
              "m",
              "k",
              "M",
              "mu",
              "y",
              "z",
              "a",
              "f",
              "p",
              "n",
              "c",
              "d",
              "da",
              "h",
              "G",
              "T",
              "P",
              "E",
              "Z",
              "Y"
            ],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unit: {
          required: !1,
          default: "s",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "decimal",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MaxTime: {
    tag: "MaxTime",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["GSE"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["multiplier", "unit"],
      details: {
        multiplier: {
          required: !1,
          default: "m",
          namespace: null,
          validation: {
            enumeration: [
              "",
              "m",
              "k",
              "M",
              "mu",
              "y",
              "z",
              "a",
              "f",
              "p",
              "n",
              "c",
              "d",
              "da",
              "h",
              "G",
              "T",
              "P",
              "E",
              "Z",
              "Y"
            ],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unit: {
          required: !1,
          default: "s",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "decimal",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  }
}, SL = [
  "AccessControl",
  "AccessPoint",
  "Address",
  "AllocationRole",
  "AllocationRoleRef",
  "AnalogueWiringParameters",
  "AnalogueWiringParametersRef",
  "Application",
  "ApplicationSclRef",
  "Association",
  "Authentication",
  "BDA",
  "Bay",
  "BayType",
  "BehaviorDescription",
  "BehaviorDescriptionRef",
  "BehaviorReference",
  "BinaryWiringParameters",
  "BinaryWiringParametersRef",
  "BitRate",
  "CheckoutID",
  "ClientLN",
  "ClientServices",
  "CommProt",
  "Communication",
  "CommunicationServiceSpecifications",
  "ConductingEquipment",
  "ConfDataSet",
  "ConfLNs",
  "ConfLdName",
  "ConfLogControl",
  "ConfReportControl",
  "ConfSG",
  "ConfSigRef",
  "ConnectedAP",
  "ConnectivityNode",
  "ControlRef",
  "ControllingLNode",
  "DA",
  "DAI",
  "DAS",
  "DAType",
  "DO",
  "DOI",
  "DOS",
  "DOType",
  "DataObjectDirectory",
  "DataSet",
  "DataSetDirectory",
  "DataTypeTemplates",
  "DynAssociation",
  "DynDataSet",
  "EnumType",
  "EnumVal",
  "EqFunction",
  "EqSubFunction",
  "ExtCtrl",
  "ExtRef",
  "FCDA",
  "FileHandling",
  "Function",
  "FunctionCatRef",
  "FunctionCategory",
  "FunctionCategoryRef",
  "FunctionRef",
  "FunctionRole",
  "FunctionRoleContent",
  "FunctionSclRef",
  "FunctionTemplate",
  "FunctionalSubVariant",
  "FunctionalVariant",
  "FunctionalVariantGroup",
  "FunctionalVariantRef",
  "GOOSE",
  "GOOSEMcSecurity",
  "GOOSESecurity",
  "GSE",
  "GSEControl",
  "GSEDir",
  "GSESettings",
  "GSSE",
  "GeneralEquipment",
  "GetCBValues",
  "GetDataObjectDefinition",
  "GetDataSetValue",
  "GetDirectory",
  "GooseParameters",
  "GooseParametersRef",
  "Header",
  "History",
  "Hitem",
  "IED",
  "IEDName",
  "IEDSourceFiles",
  "InputVar",
  "InputVarRef",
  "Inputs",
  "IssuerName",
  "KDC",
  "L2CommParameters",
  "L3IPv4CommParameters",
  "L3IPv6CommParameters",
  "LDevice",
  "LN",
  "LN0",
  "LNode",
  "LNodeDataRef",
  "LNodeInputRef",
  "LNodeInputs",
  "LNodeOutputRef",
  "LNodeOutputs",
  "LNodeSpecNaming",
  "LNodeType",
  "Label",
  "Labels",
  "Line",
  "Log",
  "LogControl",
  "LogParameters",
  "LogParametersRef",
  "LogSettings",
  "MaxTime",
  "McSecurity",
  "MinRequestedSCDFile",
  "MinRequestedSCDFiles",
  "MinTime",
  "MultiAPPerSubNet",
  "NeutralPoint",
  "OptFields",
  "OutputVar",
  "OutputVarRef",
  "Outputs",
  "P",
  "PhysConn",
  "PowerSystemRelation",
  "PowerSystemRelationRef",
  "PowerSystemRelations",
  "PowerTransformer",
  "Private",
  "Process",
  "ProcessEcho",
  "ProcessResource",
  "ProcessResourceRef",
  "ProcessResources",
  "Project",
  "ProjectProcessReference",
  "ProtNs",
  "Protocol",
  "ReadWrite",
  "RedProt",
  "ReportControl",
  "ReportParameters",
  "ReportParametersRef",
  "ReportSettings",
  "Resource",
  "RptEnabled",
  "SCL",
  "SCSM",
  "SDI",
  "SDO",
  "SDS",
  "SGEdit",
  "SMV",
  "SMVParameters",
  "SMVParametersRef",
  "SMVSecurity",
  "SMVSettings",
  "SMVsc",
  "SVMcSecurity",
  "SampledValueControl",
  "SamplesPerSec",
  "SclFileReference",
  "SecPerSamples",
  "Security",
  "Server",
  "ServerAt",
  "ServiceSpecifications",
  "Services",
  "SetDataSetValue",
  "SettingControl",
  "SettingGroups",
  "SignalRole",
  "SmpRate",
  "SmvOpts",
  "SourceFiles",
  "SourceRef",
  "SubCategory",
  "SubCheckoutID",
  "SubEquipment",
  "SubFunction",
  "SubFunctionTemplate",
  "SubNetwork",
  "Subject",
  "SubscriberLNode",
  "Substation",
  "SupSubscription",
  "TapChanger",
  "Terminal",
  "Text",
  "TimeSyncProt",
  "TimerActivatedControl",
  "TransformerWinding",
  "TrgOps",
  "Val",
  "ValueHandling",
  "Variable",
  "VariableApplyTo",
  "VariableRef",
  "Voltage",
  "VoltageLevel"
], CL = {
  AccessControl: [],
  AccessPoint: ["name"],
  Address: [],
  AllocationRole: ["name"],
  AllocationRoleRef: [],
  AnalogueWiringParameters: ["id"],
  AnalogueWiringParametersRef: ["id"],
  Application: ["name"],
  ApplicationSclRef: [],
  Association: ["apRef", "iedName", "kind", "ldInst", "lnClass", "lnInst"],
  Authentication: [],
  BDA: ["bType", "name"],
  Bay: ["name"],
  BayType: [],
  BehaviorDescription: ["name"],
  BehaviorDescriptionRef: [],
  BehaviorReference: [],
  BinaryWiringParameters: ["id"],
  BinaryWiringParametersRef: ["id"],
  BitRate: [],
  CheckoutID: ["fileType", "revision", "version"],
  ClientLN: ["apRef", "iedName", "ldInst", "lnClass", "lnInst"],
  ClientServices: [],
  CommProt: [],
  Communication: [],
  CommunicationServiceSpecifications: [],
  ConductingEquipment: ["name", "type"],
  ConfDataSet: ["max"],
  ConfLNs: [],
  ConfLdName: [],
  ConfLogControl: ["max"],
  ConfReportControl: ["max"],
  ConfSG: [],
  ConfSigRef: ["max"],
  ConnectedAP: ["apName", "iedName"],
  ConnectivityNode: ["name", "pathName"],
  ControlRef: ["output"],
  ControllingLNode: ["outputName"],
  DA: ["bType", "fc", "name"],
  DAI: ["name"],
  DAS: ["name"],
  DAType: ["id"],
  DO: ["name", "type"],
  DOI: ["name"],
  DOS: ["name"],
  DOType: ["cdc", "id"],
  DataObjectDirectory: [],
  DataSet: ["name"],
  DataSetDirectory: [],
  DataTypeTemplates: [],
  DynAssociation: [],
  DynDataSet: ["max"],
  EnumType: ["id"],
  EnumVal: ["ord"],
  EqFunction: ["name"],
  EqSubFunction: ["name"],
  ExtCtrl: [],
  ExtRef: [],
  FCDA: ["fc"],
  FileHandling: [],
  Function: ["name"],
  FunctionCatRef: [],
  FunctionCategory: ["name"],
  FunctionCategoryRef: [],
  FunctionRef: [],
  FunctionRole: ["name"],
  FunctionRoleContent: [],
  FunctionSclRef: [],
  FunctionTemplate: ["name"],
  FunctionalSubVariant: ["name"],
  FunctionalVariant: ["name"],
  FunctionalVariantGroup: ["name"],
  FunctionalVariantRef: [],
  GOOSE: ["max"],
  GOOSEMcSecurity: [],
  GOOSESecurity: ["name", "serialNumber"],
  GSE: ["cbName", "ldInst"],
  GSEControl: ["appID", "name"],
  GSEDir: [],
  GSESettings: [],
  GSSE: ["max"],
  GeneralEquipment: ["name", "type"],
  GetCBValues: [],
  GetDataObjectDefinition: [],
  GetDataSetValue: [],
  GetDirectory: [],
  GooseParameters: ["id"],
  GooseParametersRef: ["id"],
  Header: ["id", "uuid"],
  History: [],
  Hitem: ["revision", "version", "when"],
  IED: ["name"],
  IEDName: ["apRef"],
  IEDSourceFiles: [],
  InputVar: ["varName"],
  InputVarRef: [],
  Inputs: [],
  IssuerName: ["commonName", "idHierarchy"],
  KDC: ["apName", "iedName"],
  L2CommParameters: [],
  L3IPv4CommParameters: [],
  L3IPv6CommParameters: [],
  LDevice: ["inst"],
  LN: ["inst", "lnClass", "lnType"],
  LN0: ["inst", "lnClass", "lnType"],
  LNode: ["lnClass"],
  LNodeDataRef: [],
  LNodeInputRef: [],
  LNodeInputs: [],
  LNodeOutputRef: [],
  LNodeOutputs: [],
  LNodeSpecNaming: [],
  LNodeType: ["id", "lnClass"],
  Label: ["lang"],
  Labels: [],
  Line: ["name"],
  Log: [],
  LogControl: ["logName", "name"],
  LogParameters: ["id"],
  LogParametersRef: ["id"],
  LogSettings: [],
  MaxTime: [],
  McSecurity: [],
  MinRequestedSCDFile: ["fileType", "revision", "version"],
  MinRequestedSCDFiles: [],
  MinTime: [],
  MultiAPPerSubNet: [],
  NeutralPoint: ["cNodeName", "connectivityNode"],
  OptFields: [],
  OutputVar: ["varName"],
  OutputVarRef: [],
  Outputs: [],
  P: ["type"],
  PhysConn: ["type"],
  PowerSystemRelation: ["name"],
  PowerSystemRelationRef: [],
  PowerSystemRelations: [],
  PowerTransformer: ["name", "type"],
  Private: ["type"],
  Process: ["name"],
  ProcessEcho: [],
  ProcessResource: ["name"],
  ProcessResourceRef: [],
  ProcessResources: [],
  Project: ["name"],
  ProjectProcessReference: [],
  ProtNs: [],
  Protocol: ["mustUnderstand"],
  ReadWrite: [],
  RedProt: [],
  ReportControl: ["confRev", "name"],
  ReportParameters: ["id"],
  ReportParametersRef: ["id"],
  ReportSettings: [],
  Resource: [],
  RptEnabled: [],
  SCL: ["release", "revision", "version"],
  SCSM: [],
  SDI: ["name"],
  SDO: ["name", "type"],
  SDS: ["name"],
  SGEdit: [],
  SMV: ["cbName", "ldInst"],
  SMVParameters: ["id"],
  SMVParametersRef: ["id"],
  SMVSecurity: ["name", "serialNumber"],
  SMVSettings: [],
  SMVsc: ["max"],
  SVMcSecurity: [],
  SampledValueControl: ["name", "nofASDU", "smpRate", "smvID"],
  SamplesPerSec: [],
  SclFileReference: ["fileType", "revision", "version"],
  SecPerSamples: [],
  Security: [],
  Server: [],
  ServerAt: ["apName"],
  ServiceSpecifications: [],
  Services: [],
  SetDataSetValue: [],
  SettingControl: ["numOfSGs"],
  SettingGroups: [],
  SignalRole: ["name"],
  SmpRate: [],
  SmvOpts: [],
  SourceFiles: [],
  SourceRef: ["input"],
  SubCategory: ["name"],
  SubCheckoutID: ["fileType", "revision", "version"],
  SubEquipment: ["name"],
  SubFunction: ["name"],
  SubFunctionTemplate: ["name"],
  SubNetwork: ["name"],
  Subject: ["commonName", "idHierarchy"],
  SubscriberLNode: ["inputName"],
  Substation: ["name"],
  SupSubscription: ["maxGo", "maxSv"],
  TapChanger: ["name", "type"],
  Terminal: ["cNodeName", "connectivityNode"],
  Text: [],
  TimeSyncProt: [],
  TimerActivatedControl: [],
  TransformerWinding: ["name", "type"],
  TrgOps: [],
  Val: [],
  ValueHandling: [],
  Variable: ["name"],
  VariableApplyTo: [],
  VariableRef: [],
  Voltage: ["unit"],
  VoltageLevel: ["name"]
}, TL = {
  AccessControl: {},
  AccessPoint: {
    clock: "",
    desc: "",
    kdc: "",
    name: "",
    router: "",
    templateUuid: "",
    uuid: ""
  },
  Address: {},
  AllocationRole: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  AllocationRoleRef: {
    allocationRole: "",
    allocationRoleUuid: "",
    desc: ""
  },
  AnalogueWiringParameters: {
    desc: "",
    dsgInp: "",
    fctInp: "",
    id: "",
    inpNam: "",
    inpRef: ""
  },
  AnalogueWiringParametersRef: {
    desc: "",
    id: ""
  },
  Application: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  ApplicationSclRef: {},
  Association: {
    apRef: "",
    associationID: "",
    desc: "",
    iedName: "",
    initiator: "",
    kind: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    prefix: ""
  },
  Authentication: {
    certificate: "",
    none: "",
    password: "",
    strong: "",
    weak: ""
  },
  BDA: {
    bType: "",
    count: "",
    desc: "",
    name: "",
    sAddr: "",
    type: "",
    valImport: "",
    valKind: ""
  },
  Bay: {
    desc: "",
    name: "",
    templateUuid: "",
    uuid: ""
  },
  BayType: {},
  BehaviorDescription: {
    desc: "",
    fileReference: "",
    format: "",
    isSimulation: "",
    isSpecification: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  BehaviorDescriptionRef: {
    behaviorDescription: "",
    behaviorDescriptionUuid: "",
    desc: ""
  },
  BehaviorReference: {
    behaviorReference: "",
    behaviorUuid: "",
    desc: ""
  },
  BinaryWiringParameters: {
    debTm: "",
    desc: "",
    fastOutput: "",
    id: "",
    inpNam: "",
    inpRef: "",
    outNam: "",
    outOffDl: "",
    outOnDl: "",
    outRef: "",
    outTyp: "",
    vInOff: "",
    vInOn: ""
  },
  BinaryWiringParametersRef: {
    desc: "",
    id: ""
  },
  BitRate: { multiplier: "", unit: "" },
  CheckoutID: {
    desc: "",
    engRight: "",
    fileName: "",
    fileType: "",
    fileUuid: "",
    headerId: "",
    revision: "",
    version: "",
    when: ""
  },
  ClientLN: {
    apRef: "",
    desc: "",
    iedName: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    prefix: ""
  },
  ClientServices: {
    acceptServerInitiatedAssociation: "",
    bufReport: "",
    goose: "",
    gsse: "",
    maxAttributes: "",
    maxGOOSE: "",
    maxReports: "",
    maxSMV: "",
    noIctBinding: "",
    rGOOSE: "",
    rSV: "",
    readLog: "",
    supportsLdName: "",
    sv: "",
    unbufReport: ""
  },
  CommProt: { ipv6: "" },
  Communication: { desc: "" },
  CommunicationServiceSpecifications: {
    desc: ""
  },
  ConductingEquipment: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  ConfDataSet: {
    max: "",
    maxAttributes: "",
    modify: ""
  },
  ConfLNs: { fixLnInst: "", fixPrefix: "" },
  ConfLdName: {},
  ConfLogControl: { max: "" },
  ConfReportControl: {
    bufConf: "",
    bufMode: "",
    max: "",
    maxBuf: ""
  },
  ConfSG: { resvTms: "" },
  ConfSigRef: { max: "" },
  ConnectedAP: {
    apName: "",
    apUuid: "",
    desc: "",
    iedName: "",
    redProt: ""
  },
  ConnectivityNode: {
    desc: "",
    name: "",
    pathName: "",
    templateUuid: "",
    uuid: ""
  },
  ControlRef: {
    controlled: "",
    controlledDoName: "",
    controlledLNodeUuid: "",
    desc: "",
    extCtrlAddr: "",
    extCtrlUuid: "",
    originUuid: "",
    output: "",
    outputInst: "",
    pDO: "",
    pLN: "",
    resourceName: "",
    resourceUuid: "",
    templateUuid: "",
    uuid: ""
  },
  ControllingLNode: {
    desc: "",
    outputName: "",
    pLN: "",
    resourceName: "",
    resourceUuid: ""
  },
  DA: {
    bType: "",
    count: "",
    dchg: "",
    desc: "",
    dupd: "",
    fc: "",
    name: "",
    qchg: "",
    sAddr: "",
    type: "",
    valImport: "",
    valKind: ""
  },
  DAI: {
    desc: "",
    ix: "",
    name: "",
    sAddr: "",
    valImport: "",
    valKind: ""
  },
  DAS: {
    desc: "",
    ix: "",
    mappedDaName: "",
    mappedLnUuid: "",
    name: "",
    valImport: "",
    valKind: ""
  },
  DAType: { desc: "", id: "", iedType: "" },
  DO: {
    accessControl: "",
    desc: "",
    name: "",
    transient: "",
    type: ""
  },
  DOI: {
    accessControl: "",
    desc: "",
    ix: "",
    name: ""
  },
  DOS: {
    desc: "",
    mappedDoName: "",
    mappedLnUuid: "",
    name: ""
  },
  DOType: {
    cdc: "",
    desc: "",
    id: "",
    iedType: ""
  },
  DataObjectDirectory: {},
  DataSet: {
    desc: "",
    name: "",
    templateUuid: "",
    uuid: ""
  },
  DataSetDirectory: {},
  DataTypeTemplates: {},
  DynAssociation: { max: "" },
  DynDataSet: { max: "", maxAttributes: "" },
  EnumType: { desc: "", id: "" },
  EnumVal: { desc: "", ord: "" },
  EqFunction: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  EqSubFunction: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  ExtCtrl: {
    apRef: "",
    checkInterlock: "",
    checkSynchrocheck: "",
    desc: "",
    doName: "",
    iedName: "",
    intAddr: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    pDO: "",
    pLN: "",
    prefix: "",
    templateUuid: "",
    uuid: ""
  },
  ExtRef: {
    daName: "",
    desc: "",
    doName: "",
    iedName: "",
    intAddr: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    pDA: "",
    pDO: "",
    pLN: "",
    pServT: "",
    prefix: "",
    serviceType: "",
    srcCBName: "",
    srcCBUuid: "",
    srcLDInst: "",
    srcLNClass: "",
    srcLNInst: "",
    srcPrefix: "",
    templateUuid: "",
    uuid: ""
  },
  FCDA: {
    daName: "",
    doName: "",
    fc: "",
    ix: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    prefix: ""
  },
  FileHandling: {
    ftp: "",
    ftps: "",
    mms: ""
  },
  Function: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  FunctionCatRef: {
    function: "",
    functionUuid: ""
  },
  FunctionCategory: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  FunctionCategoryRef: {
    desc: "",
    functionCategory: "",
    functionCategoryUuid: ""
  },
  FunctionRef: {
    desc: "",
    function: "",
    functionUuid: ""
  },
  FunctionRole: {
    cardinality: "",
    desc: "",
    max: "",
    name: "",
    originUuid: "",
    selector: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  FunctionRoleContent: { roleInst: "" },
  FunctionSclRef: {},
  FunctionTemplate: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  FunctionalSubVariant: {
    desc: "",
    isBaseline: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  FunctionalVariant: {
    desc: "",
    isBaseline: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  FunctionalVariantGroup: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  FunctionalVariantRef: {
    functionalVariant: "",
    functionalVariantUuid: "",
    update: ""
  },
  GOOSE: {
    fixedOffs: "",
    goose: "",
    max: "",
    rGOOSE: ""
  },
  GOOSEMcSecurity: {
    encryption: "",
    signature: ""
  },
  GOOSESecurity: {
    desc: "",
    name: "",
    serialNumber: "",
    templateUuid: "",
    uuid: "",
    xferNumber: ""
  },
  GSE: {
    cbName: "",
    cbUuid: "",
    desc: "",
    ldInst: ""
  },
  GSEControl: {
    appID: "",
    confRev: "",
    datSet: "",
    desc: "",
    fixedOffs: "",
    name: "",
    securityEnable: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  GSEDir: {},
  GSESettings: {
    appID: "",
    cbName: "",
    datSet: "",
    dataLabel: "",
    kdaParticipant: ""
  },
  GSSE: { max: "" },
  GeneralEquipment: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  GetCBValues: {},
  GetDataObjectDefinition: {},
  GetDataSetValue: {},
  GetDirectory: {},
  GooseParameters: {
    cbName: "",
    desc: "",
    dsName: "",
    goId: "",
    id: "",
    maxTime: "",
    minTime: "",
    securityEnabled: ""
  },
  GooseParametersRef: {
    desc: "",
    id: ""
  },
  Header: {
    baseUuid: "",
    fileType: "",
    id: "",
    nameStructure: "",
    revision: "",
    toolID: "",
    uuid: "",
    version: ""
  },
  History: {},
  Hitem: {
    revision: "",
    version: "",
    what: "",
    when: "",
    who: "",
    why: ""
  },
  IED: {
    configVersion: "",
    desc: "",
    engRight: "",
    manufacturer: "",
    name: "",
    originalSclRelease: "",
    originalSclRevision: "",
    originalSclVersion: "",
    owner: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  IEDName: {
    apRef: "",
    apUuid: "",
    ldInst: "",
    ldUuid: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    prefix: ""
  },
  IEDSourceFiles: {},
  InputVar: {
    daName: "",
    dataName: "",
    desc: "",
    doName: "",
    inputName: "",
    inputUuid: "",
    lnodeUuid: "",
    value: "",
    varName: ""
  },
  InputVarRef: {
    desc: "",
    value: "",
    variable: ""
  },
  Inputs: { desc: "" },
  IssuerName: { commonName: "", idHierarchy: "" },
  KDC: { apName: "", apUuid: "", iedName: "" },
  L2CommParameters: {
    appId: "",
    desc: "",
    macAddr: "",
    vlanId: "",
    vlanPriority: ""
  },
  L3IPv4CommParameters: {
    IPv4: "",
    "IPv4-IGMPv3Src": "",
    appId: "",
    desc: "",
    vlanId: "",
    vlanPriority: ""
  },
  L3IPv6CommParameters: {
    IPv6: "",
    "IPv6-IGMPv3Src": "",
    appId: "",
    desc: "",
    vlanId: "",
    vlanPriority: ""
  },
  LDevice: {
    desc: "",
    inst: "",
    ldName: "",
    templateUuid: "",
    uuid: ""
  },
  LN: {
    desc: "",
    inst: "",
    lnClass: "",
    lnType: "",
    prefix: "",
    templateUuid: "",
    uuid: ""
  },
  LN0: {
    desc: "",
    inst: "",
    lnClass: "",
    lnType: "",
    templateUuid: "",
    uuid: ""
  },
  LNode: {
    desc: "",
    iedName: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnType: "",
    lnUuid: "",
    prefix: "",
    templateUuid: "",
    uuid: ""
  },
  LNodeDataRef: {
    daName: "",
    data: "",
    desc: "",
    doName: "",
    lnodeUuid: ""
  },
  LNodeInputRef: {
    desc: "",
    sourceRef: "",
    sourceRefUuid: ""
  },
  LNodeInputs: { desc: "" },
  LNodeOutputRef: {
    controlRef: "",
    controlRefUuid: "",
    desc: ""
  },
  LNodeOutputs: { desc: "" },
  LNodeSpecNaming: {
    sIedName: "",
    sLdInst: "",
    sLnClass: "",
    sLnInst: "",
    sPrefix: ""
  },
  LNodeType: {
    desc: "",
    id: "",
    iedType: "",
    lnClass: ""
  },
  Label: { id: "", lang: "" },
  Labels: { desc: "" },
  Line: {
    desc: "",
    name: "",
    nomFreq: "",
    numPhases: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  Log: { desc: "", name: "" },
  LogControl: {
    bufTime: "",
    datSet: "",
    desc: "",
    intgPd: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    logEna: "",
    logName: "",
    name: "",
    prefix: "",
    reasonCode: "",
    templateUuid: "",
    uuid: ""
  },
  LogParameters: {
    cbName: "",
    desc: "",
    dsName: "",
    id: "",
    intgPd: "",
    logEna: "",
    logLdInst: "",
    logLnClass: "",
    logLnInst: "",
    logName: "",
    logPrefix: "",
    reasonCode: ""
  },
  LogParametersRef: { desc: "", id: "" },
  LogSettings: {
    cbName: "",
    datSet: "",
    intgPd: "",
    logEna: "",
    trgOps: ""
  },
  MaxTime: { multiplier: "", unit: "" },
  McSecurity: { encryption: "", signature: "" },
  MinRequestedSCDFile: {
    desc: "",
    fileName: "",
    fileType: "",
    fileUuid: "",
    revision: "",
    version: "",
    when: ""
  },
  MinRequestedSCDFiles: {},
  MinTime: { multiplier: "", unit: "" },
  MultiAPPerSubNet: {},
  NeutralPoint: {
    bayName: "",
    cNodeName: "",
    cNodeUuid: "",
    connectivityNode: "",
    desc: "",
    lineName: "",
    name: "",
    processName: "",
    substationName: "",
    voltageLevelName: ""
  },
  OptFields: {
    bufOvfl: "",
    configRef: "",
    dataRef: "",
    dataSet: "",
    entryID: "",
    reasonCode: "",
    seqNum: "",
    timeStamp: ""
  },
  OutputVar: {
    daName: "",
    dataName: "",
    desc: "",
    doName: "",
    lnodeUuid: "",
    outputName: "",
    outputUuid: "",
    value: "",
    varName: ""
  },
  OutputVarRef: {
    desc: "",
    value: "",
    variable: ""
  },
  Outputs: { desc: "" },
  P: { type: "" },
  PhysConn: { desc: "", type: "" },
  PowerSystemRelation: {
    desc: "",
    name: "",
    originUuid: "",
    relation: "",
    relationUuid: "",
    selector: "",
    templateUuid: "",
    uuid: ""
  },
  PowerSystemRelationRef: {
    desc: "",
    powerSystemRelation: "",
    powerSystemRelationUuid: ""
  },
  PowerSystemRelations: { desc: "" },
  PowerTransformer: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  Private: { source: "", type: "" },
  Process: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  ProcessEcho: {
    desc: "",
    source: "",
    sourceDaName: "",
    sourceDoName: "",
    sourceLNodeUuid: ""
  },
  ProcessResource: {
    cardinality: "",
    desc: "",
    max: "",
    name: "",
    originUuid: "",
    selector: "",
    templateUuid: "",
    uuid: ""
  },
  ProcessResourceRef: {
    desc: "",
    processResource: "",
    processResourceUuid: ""
  },
  ProcessResources: { desc: "" },
  Project: {
    desc: "",
    name: "",
    uuid: ""
  },
  ProjectProcessReference: {
    desc: "",
    processReference: "",
    processUuid: ""
  },
  ProtNs: { type: "" },
  Protocol: { mustUnderstand: "" },
  ReadWrite: {},
  RedProt: { hsr: "", prp: "", rstp: "" },
  ReportControl: {
    bufTime: "",
    buffered: "",
    confRev: "",
    datSet: "",
    desc: "",
    indexed: "",
    intgPd: "",
    name: "",
    rptID: "",
    templateUuid: "",
    uuid: ""
  },
  ReportParameters: {
    bufTime: "",
    buffered: "",
    cbName: "",
    desc: "",
    dsName: "",
    id: "",
    intgPd: ""
  },
  ReportParametersRef: {
    desc: "",
    id: ""
  },
  ReportSettings: {
    bufTime: "",
    cbName: "",
    datSet: "",
    intgPd: "",
    optFields: "",
    owner: "",
    resvTms: "",
    rptID: "",
    trgOps: ""
  },
  Resource: {
    resInst: "",
    source: "",
    sourceUuid: ""
  },
  RptEnabled: { desc: "", max: "" },
  SCL: {
    release: "",
    revision: "",
    version: ""
  },
  SCSM: {
    iec61850_8_1: "",
    iec61850_8_2: "",
    serverAssociationInitiation: ""
  },
  SDI: {
    desc: "",
    ix: "",
    name: "",
    sAddr: ""
  },
  SDO: {
    count: "",
    desc: "",
    name: "",
    type: ""
  },
  SDS: {
    desc: "",
    ix: "",
    mappedDoName: "",
    mappedLnUuid: "",
    name: ""
  },
  SGEdit: { resvTms: "" },
  SMV: {
    cbName: "",
    cbUuid: "",
    desc: "",
    ldInst: ""
  },
  SMVParameters: {
    cbName: "",
    desc: "",
    dsName: "",
    id: "",
    multicast: "",
    nofASDU: "",
    securityEnabled: "",
    smpMod: "",
    smpRate: "",
    smvId: ""
  },
  SMVParametersRef: { desc: "", id: "" },
  SMVSecurity: {
    desc: "",
    name: "",
    serialNumber: "",
    templateUuid: "",
    uuid: "",
    xferNumber: ""
  },
  SMVSettings: {
    cbName: "",
    datSet: "",
    kdaParticipant: "",
    nofASDU: "",
    optFields: "",
    pdcTimeStamp: "",
    samplesPerSec: "",
    smpRate: "",
    svID: "",
    synchSrcId: ""
  },
  SMVsc: {
    delivery: "",
    deliveryConf: "",
    max: "",
    rSV: "",
    sv: ""
  },
  SVMcSecurity: {
    encryption: "",
    signature: ""
  },
  SampledValueControl: {
    confRev: "",
    datSet: "",
    desc: "",
    multicast: "",
    name: "",
    nofASDU: "",
    securityEnable: "",
    smpMod: "",
    smpRate: "",
    smvID: "",
    templateUuid: "",
    uuid: ""
  },
  SamplesPerSec: {},
  SclFileReference: {
    desc: "",
    fileName: "",
    fileType: "",
    fileUuid: "",
    revision: "",
    version: "",
    when: ""
  },
  SecPerSamples: {},
  Security: {
    ACSEAuthentication: "",
    E2ESecurity: ""
  },
  Server: { desc: "", timeout: "" },
  ServerAt: {
    apName: "",
    apUuid: "",
    desc: ""
  },
  ServiceSpecifications: { desc: "" },
  Services: { nameLength: "" },
  SetDataSetValue: {},
  SettingControl: {
    actSG: "",
    desc: "",
    numOfSGs: "",
    resvTms: ""
  },
  SettingGroups: {},
  SignalRole: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  SmpRate: {},
  SmvOpts: {
    dataSet: "",
    refreshTime: "",
    sampleMode: "",
    sampleRate: "",
    sampleSynchronized: "",
    security: "",
    synchSourceId: "",
    timestamp: ""
  },
  SourceFiles: {},
  SourceRef: {
    desc: "",
    extRefAddr: "",
    extRefUuid: "",
    input: "",
    inputInst: "",
    originUuid: "",
    pDA: "",
    pDO: "",
    pLN: "",
    resourceName: "",
    resourceUuid: "",
    service: "",
    source: "",
    sourceDaName: "",
    sourceDoName: "",
    sourceLNodeUuid: "",
    templateUuid: "",
    uuid: ""
  },
  SubCategory: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  SubCheckoutID: {
    desc: "",
    engRight: "",
    fileName: "",
    fileType: "",
    fileUuid: "",
    headerId: "",
    revision: "",
    version: "",
    when: ""
  },
  SubEquipment: {
    desc: "",
    name: "",
    phase: "",
    templateUuid: "",
    uuid: "",
    virtual: ""
  },
  SubFunction: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  SubFunctionTemplate: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  SubNetwork: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  Subject: { commonName: "", idHierarchy: "" },
  SubscriberLNode: {
    desc: "",
    inputName: "",
    pLN: "",
    resourceName: "",
    resourceUuid: "",
    service: ""
  },
  Substation: {
    desc: "",
    name: "",
    templateUuid: "",
    uuid: ""
  },
  SupSubscription: { maxGo: "", maxSv: "" },
  TapChanger: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  Terminal: {
    bayName: "",
    cNodeName: "",
    cNodeUuid: "",
    connectivityNode: "",
    desc: "",
    lineName: "",
    name: "",
    processName: "",
    substationName: "",
    voltageLevelName: ""
  },
  Text: { source: "" },
  TimeSyncProt: {
    c37_238: "",
    iec61850_9_3: "",
    other: "",
    sntp: ""
  },
  TimerActivatedControl: {},
  TransformerWinding: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  TrgOps: {
    dchg: "",
    dupd: "",
    gi: "",
    period: "",
    qchg: ""
  },
  Val: { sGroup: "" },
  ValueHandling: { setToRO: "" },
  Variable: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: "",
    value: ""
  },
  VariableApplyTo: {
    attribute: "",
    daName: "",
    defaultValue: "",
    desc: "",
    doName: "",
    element: "",
    elementUuid: "",
    format: "",
    sGroup: ""
  },
  VariableRef: {
    desc: "",
    value: "",
    variable: "",
    variableUuid: ""
  },
  Voltage: { multiplier: "", unit: "" },
  VoltageLevel: {
    desc: "",
    name: "",
    nomFreq: "",
    numPhases: "",
    templateUuid: "",
    uuid: ""
  }
}, PL = {
  AccessControl: [],
  AccessPoint: [
    "Text",
    "Private",
    "Server",
    "LN",
    "ServerAt",
    "Services",
    "GOOSESecurity",
    "SMVSecurity",
    "Labels"
  ],
  Address: ["P"],
  AllocationRole: ["Text", "FunctionRef"],
  AllocationRoleRef: ["Text", "FunctionalVariantRef"],
  AnalogueWiringParameters: ["Text"],
  AnalogueWiringParametersRef: ["Text"],
  Application: [
    "Text",
    "FunctionRole",
    "FunctionalVariant",
    "FunctionalVariantGroup",
    "AllocationRoleRef",
    "ApplicationSclRef"
  ],
  ApplicationSclRef: ["Text", "SclFileReference"],
  Association: [],
  Authentication: [],
  BDA: ["Text", "Private", "Val", "Labels"],
  Bay: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "PowerTransformer",
    "GeneralEquipment",
    "ConductingEquipment",
    "ConnectivityNode",
    "Function"
  ],
  BayType: [],
  BehaviorDescription: ["Text", "InputVar", "OutputVar", "BehaviorReference"],
  BehaviorDescriptionRef: ["Text", "FunctionalVariantRef", "InputVarRef", "OutputVarRef"],
  BehaviorReference: ["Text"],
  BinaryWiringParameters: ["Text"],
  BinaryWiringParametersRef: ["Text"],
  BitRate: [],
  CheckoutID: ["SubCheckoutID"],
  ClientLN: [],
  ClientServices: ["TimeSyncProt", "GOOSEMcSecurity", "SVMcSecurity", "Security"],
  CommProt: [],
  Communication: ["Text", "Private", "SubNetwork"],
  CommunicationServiceSpecifications: [
    "Text",
    "GooseParameters",
    "SMVParameters",
    "ReportParameters"
  ],
  ConductingEquipment: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "Terminal",
    "SubEquipment",
    "EqFunction"
  ],
  ConfDataSet: [],
  ConfLNs: [],
  ConfLdName: [],
  ConfLogControl: [],
  ConfReportControl: [],
  ConfSG: [],
  ConfSigRef: [],
  ConnectedAP: ["Text", "Private", "Address", "GSE", "SMV", "PhysConn"],
  ConnectivityNode: ["Text", "Private", "Labels", "LNode"],
  ControlRef: ["Text", "BinaryWiringParametersRef", "AnalogueWiringParametersRef"],
  ControllingLNode: ["Text", "BinaryWiringParametersRef", "AnalogueWiringParametersRef"],
  DA: ["Text", "Private", "Val", "Labels", "ProtNs"],
  DAI: ["Text", "Private", "Val", "Labels"],
  DAS: [
    "Text",
    "SubscriberLNode",
    "ControllingLNode",
    "ProcessEcho",
    "LogParametersRef",
    "Val",
    "Labels"
  ],
  DAType: ["Text", "Private", "BDA", "ProtNs", "Labels"],
  DO: ["Text", "Private", "Labels"],
  DOI: ["Text", "Private", "SDI", "DAI", "Labels"],
  DOS: [
    "Text",
    "SDS",
    "DAS",
    "SubscriberLNode",
    "ControllingLNode",
    "ProcessEcho",
    "LogParametersRef",
    "Labels"
  ],
  DOType: ["Text", "Private", "SDO", "DA", "Labels"],
  DataObjectDirectory: [],
  DataSet: ["Text", "Private", "FCDA"],
  DataSetDirectory: [],
  DataTypeTemplates: ["LNodeType", "DOType", "DAType", "EnumType"],
  DynAssociation: [],
  DynDataSet: [],
  EnumType: ["Text", "Private", "EnumVal"],
  EnumVal: [],
  EqFunction: ["Text", "Private", "Labels", "LNode", "GeneralEquipment", "EqSubFunction"],
  EqSubFunction: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "GeneralEquipment",
    "EqSubFunction"
  ],
  ExtCtrl: ["Text", "Private"],
  ExtRef: ["Text", "Private"],
  FCDA: [],
  FileHandling: [],
  Function: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "SubFunction",
    "GeneralEquipment",
    "ConductingEquipment"
  ],
  FunctionCatRef: ["Text"],
  FunctionCategory: ["Text", "SubCategory", "FunctionCatRef"],
  FunctionCategoryRef: ["Text", "FunctionalVariantRef"],
  FunctionRef: ["Text", "FunctionalVariantRef", "SignalRole"],
  FunctionRole: ["Text", "FunctionalVariantRef", "FunctionRoleContent"],
  FunctionRoleContent: [
    "Text",
    "FunctionRef",
    "BehaviorDescriptionRef",
    "ProcessResourceRef",
    "VariableRef",
    "FunctionCategoryRef",
    "PowerSystemRelationRef"
  ],
  FunctionSclRef: ["Text", "SclFileReference"],
  FunctionTemplate: [
    "Text",
    "LNode",
    "SubFunctionTemplate",
    "GeneralEquipment",
    "ConductingEquipment"
  ],
  FunctionalSubVariant: ["Text", "FunctionalSubVariant", "VariableRef"],
  FunctionalVariant: ["Text", "FunctionalSubVariant", "VariableRef"],
  FunctionalVariantGroup: ["Text", "FunctionalVariant"],
  FunctionalVariantRef: ["Text"],
  GOOSE: [],
  GOOSEMcSecurity: [],
  GOOSESecurity: ["Text", "Private", "Labels", "Subject", "IssuerName"],
  GSE: ["Text", "Private", "Address", "MinTime", "MaxTime"],
  GSEControl: ["Text", "Private", "IEDName", "Protocol"],
  GSEDir: [],
  GSESettings: ["McSecurity"],
  GSSE: [],
  GeneralEquipment: ["Text", "Private", "Labels", "LNode", "EqFunction"],
  GetCBValues: [],
  GetDataObjectDefinition: [],
  GetDataSetValue: [],
  GetDirectory: [],
  GooseParameters: [
    "Text",
    "L2CommParameters",
    "L3IPv4CommParameters",
    "L3IPv6CommParameters"
  ],
  GooseParametersRef: ["Text"],
  Header: ["Text", "History", "SourceFiles"],
  History: ["Hitem"],
  Hitem: ["SourceFiles"],
  IED: [
    "Text",
    "Private",
    "Services",
    "AccessPoint",
    "KDC",
    "IEDSourceFiles",
    "MinRequestedSCDFiles",
    "Labels"
  ],
  IEDName: [],
  IEDSourceFiles: ["Text", "Private", "SclFileReference"],
  InputVar: ["Text"],
  InputVarRef: ["Text", "FunctionalVariantRef"],
  Inputs: ["Text", "Private", "ExtRef"],
  IssuerName: [],
  KDC: [],
  L2CommParameters: ["Text"],
  L3IPv4CommParameters: ["Text"],
  L3IPv6CommParameters: ["Text"],
  LDevice: ["Text", "Private", "LN0", "LN", "AccessControl", "Labels"],
  LN: [
    "Text",
    "Private",
    "DataSet",
    "ReportControl",
    "LogControl",
    "DOI",
    "Inputs",
    "Outputs",
    "Log",
    "Labels"
  ],
  LN0: [
    "Text",
    "Private",
    "DataSet",
    "ReportControl",
    "LogControl",
    "DOI",
    "Inputs",
    "Outputs",
    "Log",
    "Labels",
    "GSEControl",
    "SampledValueControl",
    "SettingControl"
  ],
  LNode: ["Text", "Private", "Labels"],
  LNodeDataRef: ["Text", "FunctionalVariantRef"],
  LNodeInputRef: ["Text", "FunctionalVariantRef"],
  LNodeInputs: ["Text", "SourceRef"],
  LNodeOutputRef: ["Text", "FunctionalVariantRef"],
  LNodeOutputs: ["Text", "ControlRef"],
  LNodeSpecNaming: ["Text"],
  LNodeType: ["Text", "Private", "DO", "Labels"],
  Label: [],
  Labels: ["Text", "Private", "Label"],
  Line: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "GeneralEquipment",
    "Function",
    "Voltage",
    "ConductingEquipment",
    "ConnectivityNode"
  ],
  Log: ["Text", "Private"],
  LogControl: ["Text", "Private", "TrgOps"],
  LogParameters: ["Text"],
  LogParametersRef: ["Text"],
  LogSettings: [],
  MaxTime: [],
  McSecurity: [],
  MinRequestedSCDFile: [],
  MinRequestedSCDFiles: ["Text", "Private", "MinRequestedSCDFile"],
  MinTime: [],
  MultiAPPerSubNet: [],
  NeutralPoint: ["Text", "Private"],
  OptFields: [],
  OutputVar: ["Text"],
  OutputVarRef: ["Text", "FunctionalVariantRef"],
  Outputs: ["Text", "Private", "ExtCtrl"],
  P: [],
  PhysConn: ["Text", "Private", "P"],
  PowerSystemRelation: ["Text"],
  PowerSystemRelationRef: ["Text", "FunctionalVariantRef"],
  PowerSystemRelations: ["Text", "PowerSystemRelation"],
  PowerTransformer: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "TransformerWinding",
    "SubEquipment",
    "EqFunction"
  ],
  Private: [],
  Process: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "GeneralEquipment",
    "Function",
    "ConductingEquipment",
    "Substation",
    "Line",
    "Process"
  ],
  ProcessEcho: ["Text"],
  ProcessResource: ["Text", "Resource"],
  ProcessResourceRef: ["Text", "FunctionalVariantRef"],
  ProcessResources: ["Text", "ProcessResource"],
  Project: ["Text", "ProjectProcessReference"],
  ProjectProcessReference: ["Text"],
  ProtNs: [],
  Protocol: [],
  ReadWrite: [],
  RedProt: [],
  ReportControl: ["Text", "Private", "TrgOps", "OptFields", "RptEnabled"],
  ReportParameters: ["Text"],
  ReportParametersRef: ["Text"],
  ReportSettings: [],
  Resource: [],
  RptEnabled: ["Text", "Private", "ClientLN"],
  SCL: [
    "Text",
    "Private",
    "Header",
    "Substation",
    "Communication",
    "IED",
    "DataTypeTemplates",
    "Line",
    "Process"
  ],
  SCSM: [],
  SDI: ["Text", "Private", "SDI", "DAI", "Labels"],
  SDO: ["Text", "Private", "Labels"],
  SDS: [
    "Text",
    "SDS",
    "DAS",
    "SubscriberLNode",
    "ControllingLNode",
    "ProcessEcho",
    "LogParametersRef",
    "Labels"
  ],
  SGEdit: [],
  SMV: ["Text", "Private", "Address"],
  SMVParameters: [
    "Text",
    "L2CommParameters",
    "L3IPv4CommParameters",
    "L3IPv6CommParameters"
  ],
  SMVParametersRef: ["Text"],
  SMVSecurity: ["Text", "Private", "Labels", "Subject", "IssuerName"],
  SMVSettings: ["SmpRate", "SamplesPerSec", "SecPerSamples", "McSecurity"],
  SMVsc: [],
  SVMcSecurity: [],
  SampledValueControl: ["Text", "Private", "IEDName", "SmvOpts", "Protocol"],
  SamplesPerSec: [],
  SclFileReference: ["Text", "Private"],
  SecPerSamples: [],
  Security: [],
  Server: ["Text", "Private", "Authentication", "LDevice", "Association"],
  ServerAt: ["Text", "Private"],
  ServiceSpecifications: [
    "Text",
    "GooseParameters",
    "SMVParameters",
    "ReportParameters",
    "BinaryWiringParameters",
    "AnalogueWiringParameters",
    "LogParameters"
  ],
  Services: [
    "DynAssociation",
    "SettingGroups",
    "GetDirectory",
    "GetDataObjectDefinition",
    "DataObjectDirectory",
    "GetDataSetValue",
    "SetDataSetValue",
    "DataSetDirectory",
    "ConfDataSet",
    "DynDataSet",
    "ReadWrite",
    "TimerActivatedControl",
    "ConfReportControl",
    "GetCBValues",
    "ConfLogControl",
    "ReportSettings",
    "LogSettings",
    "GSESettings",
    "SMVSettings",
    "GSEDir",
    "GOOSE",
    "GSSE",
    "SMVsc",
    "FileHandling",
    "ConfLNs",
    "ClientServices",
    "ConfLdName",
    "SupSubscription",
    "ConfSigRef",
    "ValueHandling",
    "RedProt",
    "TimeSyncProt",
    "CommProt",
    "SCSM",
    "Security",
    "MultiAPPerSubNet"
  ],
  SetDataSetValue: [],
  SettingControl: ["Text", "Private"],
  SettingGroups: ["SGEdit", "ConfSG"],
  SignalRole: [
    "Text",
    "FunctionalVariantRef",
    "LNodeInputRef",
    "LNodeOutputRef",
    "LNodeDataRef"
  ],
  SmpRate: [],
  SmvOpts: [],
  SourceFiles: ["Text", "Private", "SclFileReference"],
  SourceRef: [
    "Text",
    "GooseParametersRef",
    "SMVParametersRef",
    "ReportParametersRef",
    "BinaryWiringParametersRef",
    "AnalogueWiringParametersRef"
  ],
  SubCategory: ["Text", "SubCategory", "FunctionCatRef"],
  SubCheckoutID: ["SubCheckoutID"],
  SubEquipment: ["Text", "Private", "Labels", "LNode", "EqFunction"],
  SubFunction: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "GeneralEquipment",
    "ConductingEquipment",
    "SubFunction"
  ],
  SubFunctionTemplate: [
    "Text",
    "LNode",
    "GeneralEquipment",
    "ConductingEquipment",
    "SubFunctionTemplate"
  ],
  SubNetwork: ["Text", "Private", "Labels", "BitRate", "ConnectedAP"],
  Subject: [],
  SubscriberLNode: [
    "Text",
    "GooseParametersRef",
    "SMVParametersRef",
    "ReportParametersRef",
    "BinaryWiringParametersRef"
  ],
  Substation: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "PowerTransformer",
    "GeneralEquipment",
    "VoltageLevel",
    "Function"
  ],
  SupSubscription: [],
  TapChanger: ["Text", "Private", "Labels", "LNode", "SubEquipment", "EqFunction"],
  Terminal: ["Text", "Private"],
  Text: [],
  TimeSyncProt: [],
  TimerActivatedControl: [],
  TransformerWinding: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "Terminal",
    "SubEquipment",
    "TapChanger",
    "NeutralPoint",
    "EqFunction"
  ],
  TrgOps: [],
  Val: [],
  ValueHandling: [],
  Variable: ["Text", "VariableApplyTo"],
  VariableApplyTo: ["Text"],
  VariableRef: ["Text", "FunctionalVariantRef"],
  Voltage: [],
  VoltageLevel: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "PowerTransformer",
    "GeneralEquipment",
    "Voltage",
    "Bay",
    "Function"
  ]
}, qL = {
  AccessControl: ["LDevice"],
  AccessPoint: ["IED"],
  Address: ["ConnectedAP", "GSE", "SMV"],
  AllocationRole: [],
  AllocationRoleRef: ["Application"],
  AnalogueWiringParameters: ["ServiceSpecifications"],
  AnalogueWiringParametersRef: ["ControlRef", "ControllingLNode", "SourceRef"],
  Application: [],
  ApplicationSclRef: ["Application"],
  Association: ["Server"],
  Authentication: ["Server"],
  BDA: ["DAType"],
  Bay: ["VoltageLevel"],
  BayType: [],
  BehaviorDescription: [],
  BehaviorDescriptionRef: ["FunctionRoleContent"],
  BehaviorReference: ["BehaviorDescription"],
  BinaryWiringParameters: ["ServiceSpecifications"],
  BinaryWiringParametersRef: [
    "ControlRef",
    "ControllingLNode",
    "SourceRef",
    "SubscriberLNode"
  ],
  BitRate: ["SubNetwork"],
  CheckoutID: [],
  ClientLN: ["RptEnabled"],
  ClientServices: ["Services"],
  CommProt: ["Services"],
  Communication: ["SCL"],
  CommunicationServiceSpecifications: [],
  ConductingEquipment: [
    "Bay",
    "Function",
    "FunctionTemplate",
    "Line",
    "Process",
    "SubFunction",
    "SubFunctionTemplate"
  ],
  ConfDataSet: ["Services"],
  ConfLNs: ["Services"],
  ConfLdName: ["Services"],
  ConfLogControl: ["Services"],
  ConfReportControl: ["Services"],
  ConfSG: ["SettingGroups"],
  ConfSigRef: ["Services"],
  ConnectedAP: ["SubNetwork"],
  ConnectivityNode: ["Bay", "Line"],
  ControlRef: ["LNodeOutputs"],
  ControllingLNode: ["DAS", "DOS", "SDS"],
  DA: ["DOType"],
  DAI: ["DOI", "SDI"],
  DAS: ["DOS", "SDS"],
  DAType: ["DataTypeTemplates"],
  DO: ["LNodeType"],
  DOI: ["LN", "LN0"],
  DOS: [],
  DOType: ["DataTypeTemplates"],
  DataObjectDirectory: ["Services"],
  DataSet: ["LN", "LN0"],
  DataSetDirectory: ["Services"],
  DataTypeTemplates: ["SCL"],
  DynAssociation: ["Services"],
  DynDataSet: ["Services"],
  EnumType: ["DataTypeTemplates"],
  EnumVal: ["EnumType"],
  EqFunction: [
    "ConductingEquipment",
    "GeneralEquipment",
    "PowerTransformer",
    "SubEquipment",
    "TapChanger",
    "TransformerWinding"
  ],
  EqSubFunction: ["EqFunction", "EqSubFunction"],
  ExtCtrl: ["Outputs"],
  ExtRef: ["Inputs"],
  FCDA: ["DataSet"],
  FileHandling: ["Services"],
  Function: ["Bay", "Line", "Process", "Substation", "VoltageLevel"],
  FunctionCatRef: ["FunctionCategory", "SubCategory"],
  FunctionCategory: [],
  FunctionCategoryRef: ["FunctionRoleContent"],
  FunctionRef: ["AllocationRole", "FunctionRoleContent"],
  FunctionRole: ["Application"],
  FunctionRoleContent: ["FunctionRole"],
  FunctionSclRef: [],
  FunctionTemplate: [],
  FunctionalSubVariant: ["FunctionalSubVariant", "FunctionalVariant"],
  FunctionalVariant: ["Application", "FunctionalVariantGroup"],
  FunctionalVariantGroup: ["Application"],
  FunctionalVariantRef: [
    "AllocationRoleRef",
    "BehaviorDescriptionRef",
    "FunctionCategoryRef",
    "FunctionRef",
    "FunctionRole",
    "InputVarRef",
    "LNodeDataRef",
    "LNodeInputRef",
    "LNodeOutputRef",
    "OutputVarRef",
    "PowerSystemRelationRef",
    "ProcessResourceRef",
    "SignalRole",
    "VariableRef"
  ],
  GOOSE: ["Services"],
  GOOSEMcSecurity: ["ClientServices"],
  GOOSESecurity: ["AccessPoint"],
  GSE: ["ConnectedAP"],
  GSEControl: ["LN0"],
  GSEDir: ["Services"],
  GSESettings: ["Services"],
  GSSE: ["Services"],
  GeneralEquipment: [
    "Bay",
    "EqFunction",
    "EqSubFunction",
    "Function",
    "FunctionTemplate",
    "Line",
    "Process",
    "SubFunction",
    "SubFunctionTemplate",
    "Substation",
    "VoltageLevel"
  ],
  GetCBValues: ["Services"],
  GetDataObjectDefinition: ["Services"],
  GetDataSetValue: ["Services"],
  GetDirectory: ["Services"],
  GooseParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
  GooseParametersRef: ["SourceRef", "SubscriberLNode"],
  Header: ["SCL"],
  History: ["Header"],
  Hitem: ["History"],
  IED: ["SCL"],
  IEDName: ["GSEControl", "SampledValueControl"],
  IEDSourceFiles: ["IED"],
  InputVar: ["BehaviorDescription"],
  InputVarRef: ["BehaviorDescriptionRef"],
  Inputs: ["LN", "LN0"],
  IssuerName: ["GOOSESecurity", "SMVSecurity"],
  KDC: ["IED"],
  L2CommParameters: ["GooseParameters", "SMVParameters"],
  L3IPv4CommParameters: ["GooseParameters", "SMVParameters"],
  L3IPv6CommParameters: ["GooseParameters", "SMVParameters"],
  LDevice: ["Server"],
  LN: ["AccessPoint", "LDevice"],
  LN0: ["LDevice"],
  LNode: [
    "Bay",
    "ConductingEquipment",
    "ConnectivityNode",
    "EqFunction",
    "EqSubFunction",
    "Function",
    "FunctionTemplate",
    "GeneralEquipment",
    "Line",
    "PowerTransformer",
    "Process",
    "SubEquipment",
    "SubFunction",
    "SubFunctionTemplate",
    "Substation",
    "TapChanger",
    "TransformerWinding",
    "VoltageLevel"
  ],
  LNodeDataRef: ["SignalRole"],
  LNodeInputRef: ["SignalRole"],
  LNodeInputs: [],
  LNodeOutputRef: ["SignalRole"],
  LNodeOutputs: [],
  LNodeSpecNaming: [],
  LNodeType: ["DataTypeTemplates"],
  Label: ["Labels"],
  Labels: [
    "AccessPoint",
    "BDA",
    "Bay",
    "ConductingEquipment",
    "ConnectivityNode",
    "DA",
    "DAI",
    "DAS",
    "DAType",
    "DO",
    "DOI",
    "DOS",
    "DOType",
    "EqFunction",
    "EqSubFunction",
    "Function",
    "GOOSESecurity",
    "GeneralEquipment",
    "IED",
    "LDevice",
    "LN",
    "LN0",
    "LNode",
    "LNodeType",
    "Line",
    "PowerTransformer",
    "Process",
    "SDI",
    "SDO",
    "SDS",
    "SMVSecurity",
    "SubEquipment",
    "SubFunction",
    "SubNetwork",
    "Substation",
    "TapChanger",
    "TransformerWinding",
    "VoltageLevel"
  ],
  Line: ["Process", "SCL"],
  Log: ["LN", "LN0"],
  LogControl: ["LN", "LN0"],
  LogParameters: ["ServiceSpecifications"],
  LogParametersRef: ["DAS", "DOS", "SDS"],
  LogSettings: ["Services"],
  MaxTime: ["GSE"],
  McSecurity: ["GSESettings", "SMVSettings"],
  MinRequestedSCDFile: ["MinRequestedSCDFiles"],
  MinRequestedSCDFiles: ["IED"],
  MinTime: ["GSE"],
  MultiAPPerSubNet: ["Services"],
  NeutralPoint: ["TransformerWinding"],
  OptFields: ["ReportControl"],
  OutputVar: ["BehaviorDescription"],
  OutputVarRef: ["BehaviorDescriptionRef"],
  Outputs: ["LN", "LN0"],
  P: ["Address", "PhysConn"],
  PhysConn: ["ConnectedAP"],
  PowerSystemRelation: ["PowerSystemRelations"],
  PowerSystemRelationRef: ["FunctionRoleContent"],
  PowerSystemRelations: [],
  PowerTransformer: ["Bay", "Substation", "VoltageLevel"],
  Private: [
    "AccessPoint",
    "BDA",
    "Bay",
    "Communication",
    "ConductingEquipment",
    "ConnectedAP",
    "ConnectivityNode",
    "DA",
    "DAI",
    "DAType",
    "DO",
    "DOI",
    "DOType",
    "DataSet",
    "EnumType",
    "EqFunction",
    "EqSubFunction",
    "ExtCtrl",
    "ExtRef",
    "Function",
    "GOOSESecurity",
    "GSE",
    "GSEControl",
    "GeneralEquipment",
    "IED",
    "IEDSourceFiles",
    "Inputs",
    "LDevice",
    "LN",
    "LN0",
    "LNode",
    "LNodeType",
    "Labels",
    "Line",
    "Log",
    "LogControl",
    "MinRequestedSCDFiles",
    "NeutralPoint",
    "Outputs",
    "PhysConn",
    "PowerTransformer",
    "Process",
    "ReportControl",
    "RptEnabled",
    "SCL",
    "SDI",
    "SDO",
    "SMV",
    "SMVSecurity",
    "SampledValueControl",
    "SclFileReference",
    "Server",
    "ServerAt",
    "SettingControl",
    "SourceFiles",
    "SubEquipment",
    "SubFunction",
    "SubNetwork",
    "Substation",
    "TapChanger",
    "Terminal",
    "TransformerWinding",
    "VoltageLevel"
  ],
  Process: ["Process", "SCL"],
  ProcessEcho: ["DAS", "DOS", "SDS"],
  ProcessResource: ["ProcessResources"],
  ProcessResourceRef: ["FunctionRoleContent"],
  ProcessResources: [],
  Project: [],
  ProjectProcessReference: ["Project"],
  ProtNs: ["DA", "DAType"],
  Protocol: ["GSEControl", "SampledValueControl"],
  ReadWrite: ["Services"],
  RedProt: ["Services"],
  ReportControl: ["LN", "LN0"],
  ReportParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
  ReportParametersRef: ["SourceRef", "SubscriberLNode"],
  ReportSettings: ["Services"],
  Resource: ["ProcessResource"],
  RptEnabled: ["ReportControl"],
  SCL: [],
  SCSM: ["Services"],
  SDI: ["DOI", "SDI"],
  SDO: ["DOType"],
  SDS: ["DOS", "SDS"],
  SGEdit: ["SettingGroups"],
  SMV: ["ConnectedAP"],
  SMVParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
  SMVParametersRef: ["SourceRef", "SubscriberLNode"],
  SMVSecurity: ["AccessPoint"],
  SMVSettings: ["Services"],
  SMVsc: ["Services"],
  SVMcSecurity: ["ClientServices"],
  SampledValueControl: ["LN0"],
  SamplesPerSec: ["SMVSettings"],
  SclFileReference: [
    "ApplicationSclRef",
    "FunctionSclRef",
    "IEDSourceFiles",
    "SourceFiles"
  ],
  SecPerSamples: ["SMVSettings"],
  Security: ["ClientServices", "Services"],
  Server: ["AccessPoint"],
  ServerAt: ["AccessPoint"],
  ServiceSpecifications: [],
  Services: ["AccessPoint", "IED"],
  SetDataSetValue: ["Services"],
  SettingControl: ["LN0"],
  SettingGroups: ["Services"],
  SignalRole: ["FunctionRef"],
  SmpRate: ["SMVSettings"],
  SmvOpts: ["SampledValueControl"],
  SourceFiles: ["Header", "Hitem"],
  SourceRef: ["LNodeInputs"],
  SubCategory: ["FunctionCategory", "SubCategory"],
  SubCheckoutID: ["CheckoutID", "SubCheckoutID"],
  SubEquipment: [
    "ConductingEquipment",
    "PowerTransformer",
    "TapChanger",
    "TransformerWinding"
  ],
  SubFunction: ["Function", "SubFunction"],
  SubFunctionTemplate: ["FunctionTemplate", "SubFunctionTemplate"],
  SubNetwork: ["Communication"],
  Subject: ["GOOSESecurity", "SMVSecurity"],
  SubscriberLNode: ["DAS", "DOS", "SDS"],
  Substation: ["Process", "SCL"],
  SupSubscription: ["Services"],
  TapChanger: ["TransformerWinding"],
  Terminal: ["ConductingEquipment", "TransformerWinding"],
  Text: [
    "AccessPoint",
    "AllocationRole",
    "AllocationRoleRef",
    "AnalogueWiringParameters",
    "AnalogueWiringParametersRef",
    "Application",
    "ApplicationSclRef",
    "BDA",
    "Bay",
    "BehaviorDescription",
    "BehaviorDescriptionRef",
    "BehaviorReference",
    "BinaryWiringParameters",
    "BinaryWiringParametersRef",
    "Communication",
    "CommunicationServiceSpecifications",
    "ConductingEquipment",
    "ConnectedAP",
    "ConnectivityNode",
    "ControlRef",
    "ControllingLNode",
    "DA",
    "DAI",
    "DAS",
    "DAType",
    "DO",
    "DOI",
    "DOS",
    "DOType",
    "DataSet",
    "EnumType",
    "EqFunction",
    "EqSubFunction",
    "ExtCtrl",
    "ExtRef",
    "Function",
    "FunctionCatRef",
    "FunctionCategory",
    "FunctionCategoryRef",
    "FunctionRef",
    "FunctionRole",
    "FunctionRoleContent",
    "FunctionSclRef",
    "FunctionTemplate",
    "FunctionalSubVariant",
    "FunctionalVariant",
    "FunctionalVariantGroup",
    "FunctionalVariantRef",
    "GOOSESecurity",
    "GSE",
    "GSEControl",
    "GeneralEquipment",
    "GooseParameters",
    "GooseParametersRef",
    "Header",
    "IED",
    "IEDSourceFiles",
    "InputVar",
    "InputVarRef",
    "Inputs",
    "L2CommParameters",
    "L3IPv4CommParameters",
    "L3IPv6CommParameters",
    "LDevice",
    "LN",
    "LN0",
    "LNode",
    "LNodeDataRef",
    "LNodeInputRef",
    "LNodeInputs",
    "LNodeOutputRef",
    "LNodeOutputs",
    "LNodeSpecNaming",
    "LNodeType",
    "Labels",
    "Line",
    "Log",
    "LogControl",
    "LogParameters",
    "LogParametersRef",
    "MinRequestedSCDFiles",
    "NeutralPoint",
    "OutputVar",
    "OutputVarRef",
    "Outputs",
    "PhysConn",
    "PowerSystemRelation",
    "PowerSystemRelationRef",
    "PowerSystemRelations",
    "PowerTransformer",
    "Process",
    "ProcessEcho",
    "ProcessResource",
    "ProcessResourceRef",
    "ProcessResources",
    "Project",
    "ProjectProcessReference",
    "ReportControl",
    "ReportParameters",
    "ReportParametersRef",
    "RptEnabled",
    "SCL",
    "SDI",
    "SDO",
    "SDS",
    "SMV",
    "SMVParameters",
    "SMVParametersRef",
    "SMVSecurity",
    "SampledValueControl",
    "SclFileReference",
    "Server",
    "ServerAt",
    "ServiceSpecifications",
    "SettingControl",
    "SignalRole",
    "SourceFiles",
    "SourceRef",
    "SubCategory",
    "SubEquipment",
    "SubFunction",
    "SubFunctionTemplate",
    "SubNetwork",
    "SubscriberLNode",
    "Substation",
    "TapChanger",
    "Terminal",
    "TransformerWinding",
    "Variable",
    "VariableApplyTo",
    "VariableRef",
    "VoltageLevel"
  ],
  TimeSyncProt: ["ClientServices", "Services"],
  TimerActivatedControl: ["Services"],
  TransformerWinding: ["PowerTransformer"],
  TrgOps: ["LogControl", "ReportControl"],
  Val: ["BDA", "DA", "DAI", "DAS"],
  ValueHandling: ["Services"],
  Variable: [],
  VariableApplyTo: ["Variable"],
  VariableRef: ["FunctionRoleContent", "FunctionalSubVariant", "FunctionalVariant"],
  Voltage: ["Line", "VoltageLevel"],
  VoltageLevel: ["Substation"]
}, AL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ATTRIBUTES: TL,
  CHILDREN: PL,
  DEFINITION: wL,
  ELEMENT_NAMES: SL,
  PARENTS: qL,
  REQUIRED: CL
}, Symbol.toStringTag, { value: "Module" })), Ni = {
  v2019C1: AL
}, bm = {
  default: {
    prefix: "",
    uri: "http://www.iec.ch/61850/2003/SCL"
  }
};
function gf(e) {
  return e.reduce(
    (l, i) => {
      if (!i) return l;
      const a = i.tagName, s = l[a] ?? [];
      return s.push(i), l[a] = s, l;
    },
    {}
  );
}
function RL(e) {
  return typeof e == "object" && e !== null && "id" in e && "tagName" in e && "namespace" in e && "attributes" in e && "children" in e && !("treeChildren" in e) && !("status" in e);
}
function io(e) {
  return "treeChildren" in e && "status" in e;
}
function zu(e) {
  return io(e) ? e : {
    ...e,
    treeChildren: [],
    status: "unchanged"
  };
}
function Mi(e) {
  if (io(e)) {
    const { treeChildren: l, status: i, ...a } = e;
    return a;
  }
  return e;
}
function sa(e) {
  const { stagedOperations: l, id: i, tagName: a, throwOnDeleted: s = !0 } = e, o = [...l].reverse().find((d) => d.status === "created" || d.status === "updated" ? d.new.id === i : d.status === "deleted" ? d.old.id === i : !1);
  if (!o) return;
  if (o.status === "deleted") {
    const d = a ? ` ${a}` : "";
    if (s) throw new Error(`Element${d} with id ${i} has been deleted`);
  }
  const m = o.status === "deleted" ? o.old : o.new;
  if (m.tagName !== a)
    throw new Error(
      `Element tagName mismatch: expected ${a}, got ${m.tagName} for id ${i}`
    );
  return { record: m, status: o.status };
}
function Ua(e) {
  const { attributes: l, name: i } = e;
  return l.find((a) => a.name === i)?.value || "";
}
function Eg(e) {
  const { attributes: l } = e;
  return l.reduce(
    (i, a) => {
      const s = a.value || "";
      return i[a.name] = s, i;
    },
    {}
  );
}
const vf = ["DO", "SDO", "DA", "BDA", "EnumVal"], _g = {
  LNodeType: "id",
  DOType: "id",
  DAType: "id",
  EnumType: "id",
  DO: "name",
  SDO: "name",
  DA: "name",
  BDA: "name",
  EnumVal: "ord"
};
function xf(e) {
  return _g[e];
}
function yf(e) {
  const { source: l, targets: i } = e;
  let a;
  l.tagName === "LNode" || l.tagName === "LN" ? a = "lnType" : a = "type";
  const s = l.attributes, o = Ua({
    attributes: s,
    name: a
  });
  return i.find((m) => {
    const d = xf(m.tagName), h = m.attributes;
    return Ua({ attributes: h, name: d }) === o;
  });
}
function uc(e) {
  const { sources: l, targets: i } = e, a = [];
  for (const s of l) {
    const o = yf({
      source: s,
      targets: i
    });
    o && a.push(o);
  }
  return a;
}
function Ng(e) {
  const { version: l, records: i } = e;
  return i.length === 0 ? !0 : i.every((a) => {
    if (!io(a) || !Ni[l].CHILDREN.DataTypeTemplates.includes(a.tagName)) return !1;
    const s = Ni[l].CHILDREN[a.tagName];
    return a.treeChildren.every((o) => !!(vf.includes(o.tagName) || s && s.includes(o.tagName)));
  });
}
function EL(e) {
  const { version: l, records: i } = e;
  if (!Ng({ version: l, records: i }))
    throw new Error("Some records are not valid data model records.");
  return i;
}
function _L(e) {
  const { version: l, tagName: i, attributeName: a, value: s, elementId: o } = e, m = Ni[l].DEFINITION[i];
  if (!m || !m.attributes?.details) return;
  const d = m.attributes.details[a];
  if (!d?.validation?.enumeration) return;
  const h = d.validation.enumeration;
  if (!h.includes(s))
    throw new Error(
      `Invalid value '${s}' for attribute '${a}' on ${i}(element: ${o}). Expected one of: ${h.join(", ")}`
    );
}
const NL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DATA_MODEL_CHILDREN_TAG_NAMES: vf,
  DATA_MODEL_ROOT_ELEMENT_TO_ATTRIBUTE_KEY: _g,
  areDataModelRecords: Ng,
  filterDataModelRootElements: uc,
  getAttributeValueByName: Ua,
  getAttributesValuesByName: Eg,
  getDataModelRootElementKeyAttribute: xf,
  groupRecordsByTagName: gf,
  isDatabaseRecord: RL,
  isTreeRecord: io,
  resolveDataModelRootElementReference: yf,
  toDataModelRecords: EL,
  toDatabaseRecord: Mi,
  toTreeRecord: zu,
  validateAttributeValue: _L
}, Symbol.toStringTag, { value: "Module" }));
function FL(e) {
  const { childRecord: l, parentRecord: i, stagedOperations: a } = e;
  function s(y) {
    return sa({
      stagedOperations: a,
      id: y,
      tagName: "Private"
    });
  }
  function o(y) {
    const I = {
      ...l,
      parent: { id: y.id, tagName: "Private" }
    }, q = {
      ...y,
      children: [
        ...y.children,
        { id: l.id, tagName: l.tagName }
      ]
    };
    return { childRecord: I, privateRecord: q };
  }
  if (i.tagName === "Private") {
    const y = i, I = s(y.id), q = I && I.status !== "deleted" ? zu(I.record) : y, { childRecord: A, privateRecord: R } = o(q);
    return {
      childRecord: A,
      privateRecord: R,
      oldPrivateRecord: q,
      updatedParentRecord: R,
      isNewPrivateElement: !1
    };
  }
  const m = i.children.find((y) => y.tagName === "Private");
  if (m) {
    const y = s(m.id);
    if (y) {
      const I = zu(y.record);
      if (I.attributes.some(
        (q) => q.name === "type" && q.value === l.namespace.prefix
      )) {
        const { childRecord: q, privateRecord: A } = o(I);
        return {
          childRecord: q,
          privateRecord: A,
          oldPrivateRecord: I,
          updatedParentRecord: i,
          isNewPrivateElement: !1
        };
      }
    }
  }
  const d = {
    id: crypto.randomUUID(),
    tagName: "Private",
    namespace: { prefix: bm.default.prefix, uri: bm.default.uri },
    attributes: [
      {
        name: "type",
        value: l.namespace.prefix
      }
    ],
    value: "",
    parent: { id: i.id, tagName: i.tagName },
    children: [
      { id: l.id, tagName: l.tagName }
    ],
    status: "created",
    treeChildren: []
  }, h = {
    ...l,
    parent: { id: d.id, tagName: "Private" }
  }, x = {
    ...i,
    children: [...i.children, { id: d.id, tagName: "Private" }]
  };
  return {
    childRecord: h,
    privateRecord: d,
    updatedParentRecord: x,
    isNewPrivateElement: !0
    // Private element is new, no update needed
  };
}
function ML(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function(s) {
    const { tagName: o, attributes: m, namespace: d, value: h, setFocus: x = !1 } = s, y = crypto.randomUUID(), I = i.then((q) => {
      let A, R;
      if (Ni[q.version].DEFINITION.hasOwnProperty(o)) {
        R = Ni[q.version].DEFINITION[o].namespace;
        const U = Ni[q.version].DEFINITION[o].attributes.details;
        A = Array.isArray(m) ? m : Object.entries(m).map(([B, K]) => {
          const W = B, se = W === "uuid" ? crypto.randomUUID() : K;
          return {
            name: W,
            value: se,
            namespace: U[W]?.namespace
          };
        });
        const z = Object.keys(
          Ni[q.version].ATTRIBUTES[o]
        ).includes("uuid"), X = A.some((B) => B.name === "uuid");
        if (z && !X) {
          const B = "uuid";
          A.push({
            name: B,
            value: crypto.randomUUID(),
            namespace: U[B]?.namespace
          });
        }
      } else
        R = d ?? { prefix: "", uri: "" }, A = Array.isArray(m) ? m : [];
      const V = {
        id: y,
        tagName: o,
        namespace: R,
        attributes: A,
        value: h ?? "",
        parent: { id: q.currentFocus.id, tagName: q.currentFocus.tagName },
        children: [],
        status: "created",
        treeChildren: []
      };
      if (V.namespace.prefix !== bm.default.prefix) {
        const {
          childRecord: U,
          privateRecord: z,
          oldPrivateRecord: X,
          updatedParentRecord: B,
          isNewPrivateElement: K
        } = FL({
          childRecord: V,
          parentRecord: q.currentFocus,
          stagedOperations: q.stagedOperations
        });
        if (K && Di({ context: q, status: "created", record: z }), Di({ context: q, status: "created", record: U }), !K && X && Di({
          context: q,
          status: "updated",
          old: X,
          new: z
        }), Di({
          context: q,
          status: "updated",
          old: Mi(q.currentFocus),
          new: B
        }), x)
          return {
            ...q,
            currentFocus: U
          };
        {
          const W = {
            ...q.currentFocus,
            ...B
          };
          return {
            ...q,
            currentFocus: W
          };
        }
      } else {
        Di({ context: q, status: "created", record: V });
        const U = {
          ...q.currentFocus,
          children: [
            ...q.currentFocus.children,
            {
              id: V.id,
              tagName: V.tagName
            }
          ]
        };
        return Di({
          context: q,
          status: "updated",
          old: Mi(q.currentFocus),
          new: Mi(U)
        }), x ? {
          ...q,
          currentFocus: V
        } : {
          ...q,
          currentFocus: U
        };
      }
    });
    return l(x ? {
      contextPromise: I,
      extensions: a,
      tagName: o
    } : {
      contextPromise: I,
      extensions: a,
      tagName: o
    });
  };
}
function kL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function(s) {
    const { record: o, setFocus: m = !1 } = s, d = i.then(async (h) => {
      function x(R) {
        return 1 + R.treeChildren.reduce((V, U) => V + x(U), 0);
      }
      const y = x(o);
      let I = 0;
      function q(R, V) {
        const U = R.addChild({
          tagName: V.tagName,
          namespace: V.namespace,
          attributes: V.attributes,
          value: V.value,
          setFocus: !0
        });
        I++, h.onProgress && h.onProgress({
          current: I,
          total: y,
          message: `Cloning ${V.tagName}`,
          scope: "deepCloneChild"
        });
        let z = U;
        for (const X of V.treeChildren)
          z = q(z, X), z = z.goToParent();
        return z;
      }
      let A = l({
        contextPromise: Promise.resolve(h),
        extensions: a,
        tagName: h.currentFocus.tagName
      });
      return A = q(A, o), m || (A = A.goToParent()), await A.getContext();
    });
    return l(m ? {
      contextPromise: d,
      extensions: a,
      tagName: o.tagName
    } : {
      contextPromise: d,
      extensions: a,
      tagName: o.tagName
    });
  };
}
function VL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a, tagName: s } = e;
  return function(o) {
    const { attributes: m, value: d } = o, h = i.then(async (x) => {
      const y = [
        ...x.currentFocus.attributes
      ];
      if (m)
        for (const R of m) {
          const V = y.findIndex(
            (z) => z.name === R.name
          );
          if (R.value === "" || R.value === void 0 || R.value === null) {
            V >= 0 && y.splice(V, 1);
            continue;
          }
          const U = {
            name: R.name,
            value: String(R.value),
            ...R.namespace && { namespace: R.namespace }
          };
          V >= 0 ? y[V] = U : y.push(U);
        }
      const I = Ni[x.version].DEFINITION[x.currentFocus.tagName].namespace, q = x.currentFocus.namespace?.prefix === I.prefix, A = {
        ...x.currentFocus,
        namespace: I && !q ? I : x.currentFocus.namespace,
        attributes: m ? y : x.currentFocus.attributes,
        value: d ?? x.currentFocus.value
      };
      return Di({
        context: x,
        status: "updated",
        old: Mi(x.currentFocus),
        new: Mi(A)
      }), {
        ...x,
        currentFocus: A
      };
    });
    return l({
      contextPromise: h,
      extensions: a,
      tagName: s
    });
  };
}
function BL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function() {
    let s;
    const o = i.then(async (m) => {
      const d = m.currentFocus.id;
      Di({ context: m, status: "deleted", record: Mi(m.currentFocus) });
      const h = m.currentFocus.parent;
      if (!h) throw new Error("Cannot delete element without a parent");
      s = h.tagName, await x(m.currentFocus.children);
      async function x(A) {
        for (const R of A) {
          let V;
          const U = sa({
            stagedOperations: m.stagedOperations,
            id: R.id,
            tagName: R.tagName,
            throwOnDeleted: !1
          });
          if (!U)
            V = await m.databaseInstance.sclElements.get({
              id: R.id,
              tagName: R.tagName
            });
          else {
            if (U.status === "deleted")
              continue;
            V = U.record;
          }
          V && (V.children && V.children.length > 0 && await x(V.children), Di({
            context: m,
            status: "deleted",
            record: V
          }));
        }
      }
      const y = sa({
        stagedOperations: m.stagedOperations,
        id: h.id,
        tagName: h.tagName
      });
      let I;
      if (y ? I = y.record : I = await m.databaseInstance.sclElements.get({
        id: h.id,
        tagName: h.tagName
      }), !I) throw new Error("Parent record not found in staged operations or database");
      const q = {
        ...zu(I),
        children: I.children.filter((A) => A.id !== d)
      };
      return Di({
        context: m,
        status: "updated",
        old: Mi(I),
        new: Mi(q)
      }), {
        ...m,
        currentFocus: q
      };
    });
    return l({
      contextPromise: o,
      extensions: a,
      tagName: s
    });
  };
}
function Di(e) {
  const { context: l, status: i, record: a, old: s, new: o } = e;
  if (i === "created") {
    if (!a) throw new Error("record is required for created");
    l.stagedOperations.push({ status: i, old: void 0, new: a });
  } else if (i === "updated") {
    if (!s || !o) throw new Error("old and new are required for update");
    l.stagedOperations.push({ status: i, old: s, new: o });
  } else if (i === "deleted") {
    if (!a) throw new Error("record is required for deleted");
    l.stagedOperations.push({ status: i, old: a, new: void 0 });
  }
}
function ZL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  function s(o) {
    const { tagName: m, id: d } = o, h = i.then(async (x) => {
      let y;
      const I = m === "SCL" || m === "Header" || m === "Communication" || m === "DataTypeTemplates";
      if (d) {
        const A = sa({
          stagedOperations: x.stagedOperations,
          id: d,
          tagName: m
        });
        A && A.status !== "deleted" && (y = A.record);
      }
      if (!y)
        if (I && !d)
          y = await x.databaseInstance[Kl].where("tagName").equals(m).first();
        else if (d)
          y = await x.databaseInstance[Kl].get({ id: d, tagName: m });
        else throw new Error(`Element ${m} requires an id parameter`);
      if (!y) {
        const A = d ? ` with id ${d}` : "";
        throw new Error(`No element ${m}${A} found in database`);
      }
      if (y.tagName !== m) throw new Error("Element tagName mismatch");
      const q = zu(y);
      return {
        ...x,
        entrypoint: q,
        currentFocus: q
      };
    });
    return l({
      contextPromise: h,
      extensions: a,
      tagName: m
    });
  }
  return s;
}
function UL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function() {
    let s;
    const o = i.then(async (m) => {
      const d = m.currentFocus.parent;
      if (!d) throw new Error("No parent found");
      s = d.tagName;
      const h = sa({
        stagedOperations: m.stagedOperations,
        id: d.id,
        tagName: d.tagName
      });
      let x;
      if (h)
        x = h.record;
      else {
        const y = await m.databaseInstance[Kl].get({
          id: d.id,
          tagName: d.tagName
        });
        if (!y) throw new Error("Parent record not found in database");
        x = y;
      }
      return {
        ...m,
        currentFocus: zu(x)
      };
    });
    return l({
      contextPromise: o,
      extensions: a,
      tagName: s
    });
  };
}
function Fg(e) {
  const l = /* @__PURE__ */ new Map();
  if (!e) return l;
  for (const i of e)
    typeof i == "string" ? l.set(i, { withAllDescendants: !1 }) : typeof i == "object" && "tagName" in i && l.set(i.tagName, {
      withAllDescendants: !!i.withAllDescendants,
      attributes: i.attributes,
      nestedPick: i.pick,
      nestedExclude: i.exclude
    });
  return l;
}
function Mg(e) {
  const l = /* @__PURE__ */ new Map();
  if (!e) return l;
  for (const i of e)
    typeof i == "string" ? l.set(i, { withAllDescendants: !1 }) : typeof i == "object" && "tagName" in i && l.set(i.tagName, {
      withAllDescendants: !1,
      attributes: i.attributes
    });
  return l;
}
function wd(e, l) {
  if (!l || Object.keys(l).length === 0)
    return !0;
  for (const [i, a] of Object.entries(l)) {
    const s = Ua({
      attributes: e.attributes,
      name: i
    });
    if (s === "") return !1;
    if (Array.isArray(a)) {
      if (!a.some((o) => s === o))
        return !1;
    } else if (s !== a)
      return !1;
  }
  return !0;
}
function kg(e, l, i, a) {
  const { pickMap: s, excludeMap: o } = l, m = e.tagName;
  if (m === "Private" && !a)
    return { shouldInclude: !1, nextIncludeAllDescendants: !1 };
  const d = o.get(m);
  if (d && wd(e, d.attributes))
    return { shouldInclude: !1, nextIncludeAllDescendants: !1 };
  if (i)
    return { shouldInclude: !0, nextIncludeAllDescendants: !0 };
  if (s.size > 0) {
    const h = s.get(m);
    return h && wd(e, h.attributes) ? {
      shouldInclude: !0,
      nextIncludeAllDescendants: h.withAllDescendants,
      nestedPickMap: h.nestedPick ? Fg(h.nestedPick) : void 0,
      nestedExcludeMap: h.nestedExclude ? Mg(h.nestedExclude) : void 0
    } : { shouldInclude: !1, nextIncludeAllDescendants: !1 };
  }
  return { shouldInclude: !0, nextIncludeAllDescendants: !1 };
}
function Vg(e) {
  const l = /* @__PURE__ */ new Set();
  if (!e) return l;
  for (const i of e)
    if (typeof i == "string")
      l.add(i);
    else if (typeof i == "object" && "tagName" in i && (l.add(i.tagName), i.pick))
      for (const a of Vg(
        i.pick
      ))
        l.add(a);
  return l;
}
function KL(e) {
  const l = /* @__PURE__ */ new Map();
  for (const i of e) {
    const a = i.status === "deleted" ? i.old.id : i.status === "created" || i.status === "updated" ? i.new.id : null;
    a && !l.has(a) && l.set(a, i);
  }
  return l;
}
function GL(e, l) {
  return l.get(e)?.status ?? "unchanged";
}
function Sd(e, l) {
  const i = l ? GL(e.id, l) : "unchanged";
  return { ...e, status: i };
}
function zL(e) {
  const { currentFocus: l, stagedOperations: i } = e, a = sa({
    stagedOperations: i,
    id: l.id,
    tagName: l.tagName,
    throwOnDeleted: !1
  });
  return a?.status === "deleted" ? null : a ? a.record : l;
}
async function Bg(e, l) {
  const { depth: i, filter: a, withPrivate: s = !1, flatten: o = !1 } = l ?? {}, m = zL(e);
  if (!m)
    throw new Error("Current focus has been deleted");
  const d = KL(e.stagedOperations), h = {
    pickMap: Fg(a?.pick),
    excludeMap: Mg(a?.exclude)
  }, x = await wm({
    context: e,
    record: m,
    currentDepth: 0,
    stagedOperationsMap: d,
    filterMaps: h,
    includeAllDescendants: !1,
    depth: i,
    withPrivate: s
  });
  if (o && a?.pick) {
    const y = Vg(a.pick), I = Ug(x, y);
    return gf(I);
  }
  return x;
}
async function wm(e) {
  const {
    context: l,
    record: i,
    currentDepth: a,
    stagedOperationsMap: s,
    filterMaps: o,
    includeAllDescendants: m,
    depth: d,
    withPrivate: h
  } = e, x = await jL(l, i);
  if (d !== void 0 && a >= d && i.tagName !== "Private" && !h) {
    const q = {
      ...i,
      treeChildren: []
    };
    return Sd(q, s);
  }
  const y = [];
  for (const q of x) {
    const A = kg(
      q,
      o,
      m,
      h
    ), R = {
      pickMap: A.nestedPickMap ?? o.pickMap,
      excludeMap: A.nestedExcludeMap ?? o.excludeMap
    }, V = {
      context: l,
      record: q,
      currentDepth: a + 1,
      stagedOperationsMap: s,
      filterMaps: R,
      includeAllDescendants: A.nextIncludeAllDescendants,
      depth: d,
      withPrivate: h
    };
    if (A.shouldInclude) {
      const U = await wm(V);
      y.push(U);
    } else if (q.tagName === "Private" || o.pickMap.size > 0) {
      const U = await wm(V), z = Zg(U, o, h);
      y.push(...z);
    }
  }
  const I = {
    ...i,
    treeChildren: y
  };
  return Sd(I, s);
}
async function jL(e, l) {
  return (await Promise.all(
    l.children.map(async (i) => {
      const a = sa({
        stagedOperations: e.stagedOperations,
        id: i.id,
        tagName: i.tagName,
        throwOnDeleted: !1
      });
      return a?.status === "deleted" ? null : a ? a.record : e.databaseInstance[Kl].get({
        id: i.id,
        tagName: i.tagName
      });
    })
  )).filter(
    (i) => i !== null
  );
}
function Zg(e, l, i) {
  const a = [];
  for (const s of e.treeChildren) {
    const { shouldInclude: o } = kg(s, l, !1, i);
    o ? a.push(s) : a.push(...Zg(s, l, i));
  }
  return a;
}
function Ug(e, l) {
  const i = [];
  l.has(e.tagName) && i.push(e);
  for (const a of e.treeChildren)
    i.push(...Ug(a, l));
  return i;
}
function HL(e) {
  const { contextPromise: l } = e;
  return async function() {
    const i = await l;
    return Rg(
      () => i.databaseInstance[Kl].get(i.currentFocus.id)
    );
  };
}
function $L(e) {
  const { contextPromise: l } = e;
  return async function() {
    const i = await l;
    return await Bg(i);
  };
}
function WL(e) {
  const { contextPromise: l } = e;
  return async function() {
    return await l;
  };
}
function YL(e) {
  const { contextPromise: l } = e;
  return async function(i) {
    const { depth: a, filter: s, withPrivate: o, flatten: m } = i || {}, d = await l;
    return await Bg(d, { depth: a, filter: s, withPrivate: o, flatten: m });
  };
}
function XL(e) {
  const { contextPromise: l } = e;
  return async function() {
    const i = await l, a = i.stagedOperations.length;
    try {
      await i.databaseInstance.transaction(
        "rw",
        i.databaseInstance.tables,
        async () => {
          const s = i.stagedOperations.filter(
            (h) => h.status === "created"
          ), o = i.stagedOperations.filter(
            (h) => h.status === "updated"
          ), m = i.stagedOperations.filter(
            (h) => h.status === "deleted"
          );
          let d = 0;
          s.length > 0 && (i.onProgress?.({
            current: d,
            total: a,
            message: `Creating ${s.length} records`,
            scope: "commit"
          }), await i.databaseInstance[Kl].bulkAdd(
            s.map((h) => h.new)
          ), d += s.length, i.onProgress?.({
            current: d,
            total: a,
            message: `Created ${s.length} records`,
            scope: "commit"
          })), o.length > 0 && (i.onProgress?.({
            current: d,
            total: a,
            message: `Updating ${o.length} records`,
            scope: "commit"
          }), await i.databaseInstance[Kl].bulkPut(
            o.map((h) => h.new)
          ), d += o.length, i.onProgress?.({
            current: d,
            total: a,
            message: `Updated ${o.length} records`,
            scope: "commit"
          })), m.length > 0 && (i.onProgress?.({
            current: d,
            total: a,
            message: `Deleting ${m.length} records`,
            scope: "commit"
          }), await i.databaseInstance[Kl].bulkDelete(
            m.map((h) => h.old.id)
          ), d += m.length, i.onProgress?.({
            current: d,
            total: a,
            message: `Deleted ${m.length} records`,
            scope: "commit"
          }));
        }
      );
    } catch (s) {
      throw new Error("Transaction failed", { cause: s });
    }
  };
}
function Ai(e) {
  const { contextPromise: l, extensions: i, tagName: a } = e, s = {
    //== Crud methods
    addChild: ML({
      genericApiBuilder: Ai,
      contextPromise: l,
      extensions: i
    }),
    deepCloneChild: kL({
      genericApiBuilder: Ai,
      contextPromise: l,
      extensions: i
    }),
    update: VL({
      genericApiBuilder: Ai,
      contextPromise: l,
      extensions: i,
      tagName: a
    }),
    delete: a === "SCL" ? void 0 : BL({
      genericApiBuilder: Ai,
      contextPromise: l,
      extensions: i
    }),
    //== Navigation methods
    goToElement: ZL({
      genericApiBuilder: Ai,
      contextPromise: l,
      extensions: i
    }),
    goToParent: UL({
      genericApiBuilder: Ai,
      contextPromise: l,
      extensions: i
    }),
    //== Ending methods
    getObservable: HL({
      contextPromise: l
    }),
    getChildren: YL({
      contextPromise: l
    }),
    getSnapshot: $L({
      contextPromise: l
    }),
    getContext: WL({
      contextPromise: l
    }),
    commit: XL({
      contextPromise: l
    })
  };
  return QL({
    genericBuilder: s,
    extensions: i,
    tagName: a,
    contextPromise: l
  });
}
function QL(e) {
  const { genericBuilder: l, extensions: i, tagName: a, contextPromise: s } = e, o = l, m = i[a] || {};
  for (const [d, h] of Object.entries(m))
    typeof h == "function" && (o[d] = h({
      genericApiBuilder: Ai,
      contextPromise: s,
      extensions: i
    }));
  return o;
}
function JL(e) {
  const { databaseInstance: l, tagName: i } = e;
  return Rg(() => l[Kl].where({ tagName: i }).toArray());
}
function eD(e) {
  const { version: l, databaseInstance: i, extensions: a, tagName: s, id: o, onProgress: m } = e, d = Promise.resolve().then(async () => {
    const h = s === "SCL" || s === "Header" || s === "Communication" || s === "DataTypeTemplates";
    let x;
    if (h && !o)
      x = await i[Kl].where("tagName").equals(s).first();
    else if (o)
      x = await i[Kl].get({ id: o, tagName: s });
    else
      throw new Error(`Element ${s} requires an id parameter`);
    if (!x) {
      const I = o ? ` with id ${o}` : "";
      throw new Error(`No element ${s}${I} found in database`);
    }
    if (x.tagName !== s) throw new Error("Element tagName mismatch");
    const y = zu(x);
    return {
      version: l,
      databaseInstance: i,
      entrypoint: y,
      currentFocus: y,
      stagedOperations: [],
      onProgress: m
    };
  });
  return Ai({
    contextPromise: d,
    extensions: a,
    tagName: s
  });
}
function nD(e) {
  const { version: l, databaseInstance: i, extensions: a, onProgress: s } = e, o = Promise.resolve().then(async () => {
    const m = await i[Kl].where({
      tagName: "SCL"
    }).count();
    if (m === 0) throw new Error("No root SCL element found in database");
    if (m > 1)
      throw new Error("Multiple root SCL elements found in database, database is corrupted");
    const d = await i[Kl].get({ tagName: "SCL" });
    if (!d) throw new Error("No root SCL element found in database");
    const h = zu(d);
    return {
      version: l,
      databaseInstance: i,
      entrypoint: h,
      currentFocus: h,
      stagedOperations: [],
      onProgress: s
    };
  });
  return Ai({
    contextPromise: o,
    extensions: a,
    tagName: "SCL"
  });
}
async function Kg(e) {
  const { record: l, dataTypeTemplates: i } = e, {
    LNodeType: a = [],
    DOType: s = [],
    DAType: o = [],
    EnumType: m = []
  } = gf(i.treeChildren), d = yf({
    source: l,
    targets: a
  });
  if (!d)
    throw new Error(
      `LNodeType for ${l.tagName} ${l.attributes.find((I) => I.name === "lnType")?.value} not found`
    );
  const h = uc({
    sources: d.treeChildren.filter((I) => I.tagName === "DO"),
    targets: s
  }), x = uc({
    sources: h.flatMap(
      (I) => I.treeChildren.filter((q) => q.tagName === "DA")
    ),
    targets: o
  }), y = uc({
    sources: x.flatMap(
      (I) => I.treeChildren.filter((q) => q.tagName === "BDA")
    ),
    targets: m
  });
  return {
    ...l,
    treeChildren: [d, ...h, ...x, ...y],
    status: "unchanged"
  };
}
function lD(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function() {
    const s = i.then(async (o) => {
      const m = o.currentFocus, d = await l({
        contextPromise: Promise.resolve(o),
        extensions: a,
        tagName: o.currentFocus.tagName
      }).goToElement({ tagName: "DataTypeTemplates" }).getChildren(), h = await Kg({
        record: m,
        dataTypeTemplates: d
      });
      return {
        ...o,
        currentFocus: h
      };
    });
    return l({
      contextPromise: s,
      extensions: a,
      tagName: "LNode"
    });
  };
}
const tD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  resolveDataModel: lD
}, Symbol.toStringTag, { value: "Module" }));
function iD(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function(s) {
    const { subnetworkId: o } = s, m = i.then(async (d) => {
      const h = l({
        contextPromise: Promise.resolve(d),
        extensions: a,
        tagName: "IED"
      }), x = Ua({
        attributes: d.currentFocus.attributes,
        name: "name"
      }), { AccessPoint: y = [] } = await h.getChildren({
        filter: { pick: ["AccessPoint"] },
        flatten: !0
      });
      let I = h.goToElement({
        tagName: "SubNetwork",
        id: o
      });
      for (const A of y) {
        const R = Ua({
          attributes: A.attributes,
          name: "name"
        });
        I = I.addChild({
          tagName: "ConnectedAP",
          attributes: {
            iedName: x,
            apName: R
          }
        });
      }
      const q = (await I.getContext()).stagedOperations;
      return {
        ...d,
        stagedOperations: q
      };
    });
    return l({
      contextPromise: m,
      extensions: a,
      tagName: "IED"
    });
  };
}
const uD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attachAllAccessPointToSubNetwork: iD
}, Symbol.toStringTag, { value: "Module" }));
function aD(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function() {
    const s = i.then(async (o) => {
      const m = o.currentFocus, d = await l({
        contextPromise: Promise.resolve(o),
        extensions: a,
        tagName: o.currentFocus.tagName
      }).goToElement({ tagName: "DataTypeTemplates" }).getChildren(), h = await Kg({
        record: m,
        dataTypeTemplates: d
      });
      return {
        ...o,
        currentFocus: h
      };
    });
    return l({
      contextPromise: s,
      extensions: a,
      tagName: "LN"
    });
  };
}
const rD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  resolveDataModel: aD
}, Symbol.toStringTag, { value: "Module" }));
function sD(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function(s) {
    const { dataModel: o } = s, m = i.then(async (d) => {
      let h = l({
        contextPromise: Promise.resolve(d),
        extensions: a,
        tagName: "DataTypeTemplates"
      });
      for (const x of o) {
        if (await zg(h, x)) continue;
        h = Gg(h, x);
        const y = x.treeChildren.filter(
          (I) => vf.includes(I.tagName)
        );
        for (const I of y)
          h = await cD(h, I);
        h = h.goToParent();
      }
      return await h.getContext();
    });
    return l({
      contextPromise: m,
      extensions: a,
      tagName: "DataTypeTemplates"
    });
  };
}
async function cD(e, l) {
  return await zg(e, l) ? e : Gg(e, l).goToParent();
}
function Gg(e, l) {
  const i = Eg({
    attributes: l.attributes
  });
  return e.addChild({
    tagName: l.tagName,
    attributes: i,
    setFocus: !0
  });
}
async function zg(e, l) {
  const i = xf(l.tagName), a = l.attributes.find((s) => s.name === i)?.value;
  if (!a)
    throw new Error(`Key attribute "${i}" is missing in element attributes.`);
  return (await e.getChildren({ depth: 1 })).treeChildren.find(
    (s) => s.tagName === l.tagName && s.attributes.find((o) => o.name === i)?.value === a
  );
}
const oD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addToDataModel: sD
}, Symbol.toStringTag, { value: "Module" })), mD = {
  LNode: tD,
  IED: uD,
  LN: rD,
  DataTypeTemplates: oD
}, fD = {
  v2019C1: mD
};
function dD(e) {
  const { version: l, databaseInstance: i } = e, a = fD[l];
  return {
    // chainable methods
    fromRoot: (s) => nD({ version: l, databaseInstance: i, extensions: a, onProgress: s?.onProgress }),
    fromElement: (s) => eD({
      version: l,
      databaseInstance: i,
      extensions: a,
      tagName: s.tagName,
      id: s.id,
      onProgress: s?.onProgress
    }),
    // ending methods
    getObservable: (s) => JL({ databaseInstance: i, ...s }),
    getElement: async (s) => await i[Kl].get({
      tagName: s.tagName,
      id: s.id
    })
  };
}
function jg(e) {
  const { databaseName: l, version: i } = e, a = bL({
    databaseName: l
  });
  return {
    api: dD({ version: i, databaseInstance: a }),
    utils: NL,
    database: a,
    standard: Ni[i]
  };
}
const Tc = "v2019C1", Os = /* @__PURE__ */ to("s-ied-implementation/global", () => {
  const e = Fe(""), l = Re(
    () => e.value ? jg({ databaseName: e.value, version: Tc }) : null
  );
  async function i(a) {
    e.value = a;
  }
  return {
    // states
    activeFilename: e,
    // getters
    sdkInstance: l,
    // actions
    initApp: i
  };
});
function If(e, l) {
  return $i() ? (ma(e, l), !0) : !1;
}
// @__NO_SIDE_EFFECTS__
function Cd() {
  const e = /* @__PURE__ */ new Set(), l = (o) => {
    e.delete(o);
  };
  return {
    on: (o) => {
      e.add(o);
      const m = () => l(o);
      return If(m), { off: m };
    },
    off: l,
    trigger: (...o) => Promise.all(Array.from(e).map((m) => m(...o))),
    clear: () => {
      e.clear();
    }
  };
}
const Ao = /* @__PURE__ */ new WeakMap(), pD = /* @__NO_SIDE_EFFECTS__ */ (...e) => {
  var l;
  const i = e[0], a = (l = Xn()) === null || l === void 0 ? void 0 : l.proxy, s = a ?? $i();
  if (s == null && !Qc()) throw new Error("injectLocal must be called in setup");
  return s && Ao.has(s) && i in Ao.get(s) ? Ao.get(s)[i] : Fi(...e);
}, Lf = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const hD = Object.prototype.toString, gD = (e) => hD.call(e) === "[object Object]", Hg = () => {
}, vD = (e, l) => Object.prototype.hasOwnProperty.call(e, l);
function xD(...e) {
  if (e.length !== 1) return gs(...e);
  const l = e[0];
  return typeof l == "function" ? Bi(Wa(() => ({
    get: l,
    set: Hg
  }))) : Fe(l);
}
function yD(e, l) {
  function i(...a) {
    return new Promise((s, o) => {
      Promise.resolve(e(() => l.apply(this, a), {
        fn: l,
        thisArg: this,
        args: a
      })).then(s).catch(o);
    });
  }
  return i;
}
const $g = (e) => e();
function ID(e = $g, l = {}) {
  const { initialState: i = "active" } = l, a = xD(i === "active");
  function s() {
    a.value = !1;
  }
  function o() {
    a.value = !0;
  }
  const m = (...d) => {
    a.value && e(...d);
  };
  return {
    isActive: Bi(a),
    pause: s,
    resume: o,
    eventFilter: m
  };
}
function LD(e, l) {
  var i;
  if (typeof e == "number") return e + l;
  const a = ((i = e.match(/^-?\d+\.?\d*/)) === null || i === void 0 ? void 0 : i[0]) || "", s = e.slice(a.length), o = Number.parseFloat(a) + l;
  return Number.isNaN(o) ? e : o + s;
}
function Wr(e) {
  return e.endsWith("rem") ? Number.parseFloat(e) * 16 : Number.parseFloat(e);
}
function Ro(e) {
  return Array.isArray(e) ? e : [e];
}
function DD(e) {
  return Xn();
}
function Td(e) {
  let l = hn(e), i;
  const a = () => {
    l = hn(e), i();
  }, s = Wa((o, m) => (i = m, {
    get() {
      return o(), l;
    },
    set(d) {
      l = d, i();
    }
  }));
  return s.reset = a, s;
}
function OD(e, l, i = {}) {
  const { eventFilter: a = $g, ...s } = i;
  return Sn(e, yD(a, l), s);
}
function bD(e, l, i = {}) {
  const { eventFilter: a, initialState: s = "active", ...o } = i, { eventFilter: m, pause: d, resume: h, isActive: x } = ID(a, { initialState: s });
  return {
    stop: OD(e, l, {
      ...o,
      eventFilter: m
    }),
    pause: d,
    resume: h,
    isActive: x
  };
}
const wD = bD;
function Wg(e, l = !0, i) {
  DD() ? vl(e, i) : l ? e() : il(e);
}
function SD(e, l, i = {}) {
  const { immediate: a = !0, immediateCallback: s = !1 } = i, o = Fl(!1);
  let m;
  function d() {
    m && (clearTimeout(m), m = void 0);
  }
  function h() {
    o.value = !1, d();
  }
  function x(...y) {
    s && e(), d(), o.value = !0, m = setTimeout(() => {
      o.value = !1, m = void 0, e(...y);
    }, hn(l));
  }
  return a && (o.value = !0, Lf && x()), If(h), {
    isPending: Nu(o),
    start: x,
    stop: h
  };
}
function CD(e, l, i) {
  return Sn(e, l, {
    ...i,
    immediate: !0
  });
}
function TD(e, l, i) {
  var a;
  let s;
  Vn(i) ? s = { evaluating: i } : s = i || {};
  const { lazy: o = !1, flush: m = "sync", evaluating: d = void 0, shallow: h = !0, onError: x = (a = globalThis.reportError) !== null && a !== void 0 ? a : Hg } = s, y = Fl(!o), I = h ? Fl(l) : Fe(l);
  let q = 0;
  return Ml(async (A) => {
    if (!y.value) return;
    q++;
    const R = q;
    let V = !1;
    d && Promise.resolve().then(() => {
      d.value = !0;
    });
    try {
      const U = await e((z) => {
        A(() => {
          d && (d.value = !1), V || z();
        });
      });
      R === q && (I.value = U);
    } catch (U) {
      x(U);
    } finally {
      d && R === q && (d.value = !1), V = !0;
    }
  }, { flush: m }), o ? Re(() => (y.value = !0, I.value)) : I;
}
const la = Lf ? window : void 0, PD = Lf ? window.document : void 0;
function Yg(e) {
  var l;
  const i = hn(e);
  return (l = i?.$el) !== null && l !== void 0 ? l : i;
}
function Sm(...e) {
  const l = [], i = () => {
    l.forEach((d) => d()), l.length = 0;
  }, a = (d, h, x, y) => (d.addEventListener(h, x, y), () => d.removeEventListener(h, x, y)), s = Re(() => {
    const d = Ro(hn(e[0])).filter((h) => h != null);
    return d.every((h) => typeof h != "string") ? d : void 0;
  }), o = CD(() => {
    var d, h;
    return [
      (d = (h = s.value) === null || h === void 0 ? void 0 : h.map((x) => Yg(x))) !== null && d !== void 0 ? d : [la].filter((x) => x != null),
      Ro(hn(s.value ? e[1] : e[0])),
      Ro(le(s.value ? e[2] : e[1])),
      hn(s.value ? e[3] : e[2])
    ];
  }, ([d, h, x, y]) => {
    if (i(), !d?.length || !h?.length || !x?.length) return;
    const I = gD(y) ? { ...y } : y;
    l.push(...d.flatMap((q) => h.flatMap((A) => x.map((R) => a(q, A, R, I)))));
  }, { flush: "post" }), m = () => {
    o(), i();
  };
  return If(i), m;
}
// @__NO_SIDE_EFFECTS__
function qD() {
  const e = Fl(!1), l = Xn();
  return l && vl(() => {
    e.value = !0;
  }, l), e;
}
// @__NO_SIDE_EFFECTS__
function AD(e) {
  const l = /* @__PURE__ */ qD();
  return Re(() => (l.value, !!e()));
}
const RD = Symbol("vueuse-ssr-width");
// @__NO_SIDE_EFFECTS__
function Xg() {
  const e = Qc() ? /* @__PURE__ */ pD(RD, null) : null;
  return typeof e == "number" ? e : void 0;
}
function Tr(e, l = {}) {
  const { window: i = la, ssrWidth: a = /* @__PURE__ */ Xg() } = l, s = /* @__PURE__ */ AD(() => i && "matchMedia" in i && typeof i.matchMedia == "function"), o = Fl(typeof a == "number"), m = Fl(), d = Fl(!1), h = (x) => {
    d.value = x.matches;
  };
  return Ml(() => {
    if (o.value) {
      o.value = !s.value, d.value = hn(e).split(",").some((x) => {
        const y = x.includes("not all"), I = x.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/), q = x.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        let A = !!(I || q);
        return I && A && (A = a >= Wr(I[1])), q && A && (A = a <= Wr(q[1])), y ? !A : A;
      });
      return;
    }
    s.value && (m.value = i.matchMedia(hn(e)), d.value = m.value.matches);
  }), Sm(m, "change", h, { passive: !0 }), Re(() => d.value);
}
const ED = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536
};
// @__NO_SIDE_EFFECTS__
function _D(e, l = {}) {
  function i(A, R) {
    let V = hn(e[hn(A)]);
    return R != null && (V = LD(V, R)), typeof V == "number" && (V = `${V}px`), V;
  }
  const { window: a = la, strategy: s = "min-width", ssrWidth: o = /* @__PURE__ */ Xg() } = l, m = typeof o == "number", d = m ? Fl(!1) : { value: !0 };
  m && Wg(() => d.value = !!a);
  function h(A, R) {
    return !d.value && m ? A === "min" ? o >= Wr(R) : o <= Wr(R) : a ? a.matchMedia(`(${A}-width: ${R})`).matches : !1;
  }
  const x = (A) => Tr(() => `(min-width: ${i(A)})`, l), y = (A) => Tr(() => `(max-width: ${i(A)})`, l), I = Object.keys(e).reduce((A, R) => (Object.defineProperty(A, R, {
    get: () => s === "min-width" ? x(R) : y(R),
    enumerable: !0,
    configurable: !0
  }), A), {});
  function q() {
    const A = Object.keys(e).map((R) => [
      R,
      I[R],
      Wr(i(R))
    ]).sort((R, V) => R[2] - V[2]);
    return Re(() => A.filter(([, R]) => R.value).map(([R]) => R));
  }
  return Object.assign(I, {
    greaterOrEqual: x,
    smallerOrEqual: y,
    greater(A) {
      return Tr(() => `(min-width: ${i(A, 0.1)})`, l);
    },
    smaller(A) {
      return Tr(() => `(max-width: ${i(A, -0.1)})`, l);
    },
    between(A, R) {
      return Tr(() => `(min-width: ${i(A)}) and (max-width: ${i(R, -0.1)})`, l);
    },
    isGreater(A) {
      return h("min", i(A, 0.1));
    },
    isGreaterOrEqual(A) {
      return h("min", i(A));
    },
    isSmaller(A) {
      return h("max", i(A, -0.1));
    },
    isSmallerOrEqual(A) {
      return h("max", i(A));
    },
    isInBetween(A, R) {
      return h("min", i(A)) && h("max", i(R, -0.1));
    },
    current: q,
    active() {
      const A = q();
      return Re(() => A.value.length === 0 ? "" : A.value.at(s === "min-width" ? -1 : 0));
    }
  });
}
const Zs = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Us = "__vueuse_ssr_handlers__", ND = /* @__PURE__ */ FD();
function FD() {
  return Us in Zs || (Zs[Us] = Zs[Us] || {}), Zs[Us];
}
function MD(e, l) {
  return ND[e] || l;
}
function kD(e) {
  return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number";
}
const VD = {
  boolean: {
    read: (e) => e === "true",
    write: (e) => String(e)
  },
  object: {
    read: (e) => JSON.parse(e),
    write: (e) => JSON.stringify(e)
  },
  number: {
    read: (e) => Number.parseFloat(e),
    write: (e) => String(e)
  },
  any: {
    read: (e) => e,
    write: (e) => String(e)
  },
  string: {
    read: (e) => e,
    write: (e) => String(e)
  },
  map: {
    read: (e) => new Map(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e.entries()))
  },
  set: {
    read: (e) => new Set(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e))
  },
  date: {
    read: (e) => new Date(e),
    write: (e) => e.toISOString()
  }
}, Pd = "vueuse-storage";
function BD(e, l, i, a = {}) {
  var s;
  const { flush: o = "pre", deep: m = !0, listenToStorageChanges: d = !0, writeDefaults: h = !0, mergeDefaults: x = !1, shallow: y, window: I = la, eventFilter: q, onError: A = (ye) => {
    console.error(ye);
  }, initOnMounted: R } = a, V = (y ? Fl : Fe)(l), U = Re(() => hn(e));
  if (!i) try {
    i = MD("getDefaultStorage", () => la?.localStorage)();
  } catch (ye) {
    A(ye);
  }
  if (!i) return V;
  const z = hn(l), X = kD(z), B = (s = a.serializer) !== null && s !== void 0 ? s : VD[X], { pause: K, resume: W } = wD(V, (ye) => ce(ye), {
    flush: o,
    deep: m,
    eventFilter: q
  });
  Sn(U, () => ae(), { flush: o });
  let se = !1;
  const te = (ye) => {
    R && !se || ae(ye);
  }, me = (ye) => {
    R && !se || ve(ye);
  };
  I && d && (i instanceof Storage ? Sm(I, "storage", te, { passive: !0 }) : Sm(I, Pd, me)), R ? Wg(() => {
    se = !0, ae();
  }) : ae();
  function M(ye, Se) {
    if (I) {
      const ge = {
        key: U.value,
        oldValue: ye,
        newValue: Se,
        storageArea: i
      };
      I.dispatchEvent(i instanceof Storage ? new StorageEvent("storage", ge) : new CustomEvent(Pd, { detail: ge }));
    }
  }
  function ce(ye) {
    try {
      const Se = i.getItem(U.value);
      if (ye == null)
        M(Se, null), i.removeItem(U.value);
      else {
        const ge = B.write(ye);
        Se !== ge && (i.setItem(U.value, ge), M(Se, ge));
      }
    } catch (Se) {
      A(Se);
    }
  }
  function Ie(ye) {
    const Se = ye ? ye.newValue : i.getItem(U.value);
    if (Se == null)
      return h && z != null && i.setItem(U.value, B.write(z)), z;
    if (!ye && x) {
      const ge = B.read(Se);
      return typeof x == "function" ? x(ge, z) : X === "object" && !Array.isArray(ge) ? {
        ...z,
        ...ge
      } : ge;
    } else return typeof Se != "string" ? Se : B.read(Se);
  }
  function ae(ye) {
    if (!(ye && ye.storageArea !== i)) {
      if (ye && ye.key == null) {
        V.value = z;
        return;
      }
      if (!(ye && ye.key !== U.value)) {
        K();
        try {
          const Se = B.write(V.value);
          (ye === void 0 || ye?.newValue !== Se) && (V.value = Ie(ye));
        } catch (Se) {
          A(Se);
        } finally {
          ye ? il(W) : W();
        }
      }
    }
  }
  function ve(ye) {
    ae(ye.detail);
  }
  return V;
}
const ZD = {
  multiple: !0,
  accept: "*",
  reset: !1,
  directory: !1
};
function UD(e) {
  if (!e) return null;
  if (e instanceof FileList) return e;
  const l = new DataTransfer();
  for (const i of e) l.items.add(i);
  return l.files;
}
function KD(e = {}) {
  const { document: l = PD } = e, i = Fe(UD(e.initialFiles)), { on: a, trigger: s } = /* @__PURE__ */ Cd(), { on: o, trigger: m } = /* @__PURE__ */ Cd(), d = Re(() => {
    var I;
    const q = (I = Yg(e.input)) !== null && I !== void 0 ? I : l ? l.createElement("input") : void 0;
    return q && (q.type = "file", q.onchange = (A) => {
      i.value = A.target.files, s(i.value);
    }, q.oncancel = () => {
      m();
    }), q;
  }), h = () => {
    i.value = null, d.value && d.value.value && (d.value.value = "", s(null));
  }, x = (I) => {
    const q = d.value;
    q && (q.multiple = hn(I.multiple), q.accept = hn(I.accept), q.webkitdirectory = hn(I.directory), vD(I, "capture") && (q.capture = hn(I.capture)));
  }, y = (I) => {
    const q = d.value;
    if (!q) return;
    const A = {
      ...ZD,
      ...e,
      ...I
    };
    x(A), hn(A.reset) && h(), q.click();
  };
  return Ml(() => {
    x(e);
  }), {
    files: Bi(i),
    open: y,
    reset: h,
    onCancel: o,
    onChange: a
  };
}
function qd(e) {
  return typeof e == "string" ? `'${e}'` : new GD().serialize(e);
}
const GD = /* @__PURE__ */ function() {
  class e {
    #e = /* @__PURE__ */ new Map();
    compare(i, a) {
      const s = typeof i, o = typeof a;
      return s === "string" && o === "string" ? i.localeCompare(a) : s === "number" && o === "number" ? i - a : String.prototype.localeCompare.call(this.serialize(i, !0), this.serialize(a, !0));
    }
    serialize(i, a) {
      if (i === null) return "null";
      switch (typeof i) {
        case "string":
          return a ? i : `'${i}'`;
        case "bigint":
          return `${i}n`;
        case "object":
          return this.$object(i);
        case "function":
          return this.$function(i);
      }
      return String(i);
    }
    serializeObject(i) {
      const a = Object.prototype.toString.call(i);
      if (a !== "[object Object]") return this.serializeBuiltInType(a.length < 10 ? `unknown:${a}` : a.slice(8, -1), i);
      const s = i.constructor, o = s === Object || s === void 0 ? "" : s.name;
      if (o !== "" && globalThis[o] === s) return this.serializeBuiltInType(o, i);
      if (typeof i.toJSON == "function") {
        const m = i.toJSON();
        return o + (m !== null && typeof m == "object" ? this.$object(m) : `(${this.serialize(m)})`);
      }
      return this.serializeObjectEntries(o, Object.entries(i));
    }
    serializeBuiltInType(i, a) {
      const s = this["$" + i];
      if (s) return s.call(this, a);
      if (typeof a?.entries == "function") return this.serializeObjectEntries(i, a.entries());
      throw new Error(`Cannot serialize ${i}`);
    }
    serializeObjectEntries(i, a) {
      const s = Array.from(a).sort((m, d) => this.compare(m[0], d[0]));
      let o = `${i}{`;
      for (let m = 0; m < s.length; m++) {
        const [d, h] = s[m];
        o += `${this.serialize(d, !0)}:${this.serialize(h)}`, m < s.length - 1 && (o += ",");
      }
      return o + "}";
    }
    $object(i) {
      let a = this.#e.get(i);
      return a === void 0 && (this.#e.set(i, `#${this.#e.size}`), a = this.serializeObject(i), this.#e.set(i, a)), a;
    }
    $function(i) {
      const a = Function.prototype.toString.call(i);
      return a.slice(-15) === "[native code] }" ? `${i.name || ""}()[native]` : `${i.name}(${i.length})${a.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(i) {
      let a = "[";
      for (let s = 0; s < i.length; s++) a += this.serialize(i[s]), s < i.length - 1 && (a += ",");
      return a + "]";
    }
    $Date(i) {
      try {
        return `Date(${i.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(i) {
      return `ArrayBuffer[${new Uint8Array(i).join(",")}]`;
    }
    $Set(i) {
      return `Set${this.$Array(Array.from(i).sort((a, s) => this.compare(a, s)))}`;
    }
    $Map(i) {
      return this.serializeObjectEntries("Map", i.entries());
    }
  }
  for (const l of ["Error", "RegExp", "URL"]) e.prototype["$" + l] = function(i) {
    return `${l}(${i})`;
  };
  for (const l of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) e.prototype["$" + l] = function(i) {
    return `${l}[${i.join(",")}]`;
  };
  for (const l of ["BigInt64Array", "BigUint64Array"]) e.prototype["$" + l] = function(i) {
    return `${l}[${i.join("n,")}${i.length > 0 ? "n" : ""}]`;
  };
  return e;
}();
function Cm(e, l) {
  return e === l || qd(e) === qd(l);
}
function zD(e, l) {
  if (e.length !== l.length) return !1;
  for (let i = 0; i < e.length; i++) if (e[i] !== l[i]) return !1;
  return !0;
}
function ac(e, l, i) {
  const a = e.findIndex((d) => Cm(d, l)), s = e.findIndex((d) => Cm(d, i));
  if (a === -1 || s === -1) return [];
  const [o, m] = [a, s].sort((d, h) => d - h);
  return e.slice(o, m + 1);
}
const bs = typeof document < "u";
function vi(e, l) {
  const i = typeof e == "string" && !l ? `${e}Context` : l, a = Symbol(i);
  return [(m) => {
    const d = Fi(a, m);
    if (d || d === null) return d;
    throw new Error(`Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`);
  }, (m) => (Xc(a, m), m)];
}
function Ka() {
  let e = document.activeElement;
  if (e == null) return null;
  for (; e != null && e.shadowRoot != null && e.shadowRoot.activeElement != null; ) e = e.shadowRoot.activeElement;
  return e;
}
function ss(e, l, i) {
  const a = i.originalEvent.target, s = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: i
  });
  l && a.addEventListener(e, l, { once: !0 }), a.dispatchEvent(s);
}
function Df(e) {
  return e ? e.flatMap((l) => l.type === Mn ? Df(l.children) : [l]) : [];
}
const [uo, EC] = vi("ConfigProvider");
function jD(e, l) {
  var i;
  const a = Fl();
  return Ml(() => {
    a.value = e();
  }, {
    ...l,
    flush: (i = void 0) != null ? i : "sync"
  }), Bi(a);
}
function ao(e) {
  return $i() ? (ma(e), !0) : !1;
}
function Yr() {
  const e = /* @__PURE__ */ new Set(), l = (o) => {
    e.delete(o);
  };
  return {
    on: (o) => {
      e.add(o);
      const m = () => l(o);
      return ao(m), {
        off: m
      };
    },
    off: l,
    trigger: (...o) => Promise.all(Array.from(e).map((m) => m(...o))),
    clear: () => {
      e.clear();
    }
  };
}
function HD(e) {
  let l = 0, i, a;
  const s = () => {
    l -= 1, a && l <= 0 && (a.stop(), i = void 0, a = void 0);
  };
  return (...o) => (l += 1, a || (a = Zc(!0), i = a.run(() => e(...o))), ao(s), i);
}
const Xa = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const $D = (e) => typeof e < "u", WD = Object.prototype.toString, YD = (e) => WD.call(e) === "[object Object]", Ad = /* @__PURE__ */ XD();
function XD() {
  var e, l;
  return Xa && ((e = window?.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((l = window?.navigator) == null ? void 0 : l.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function QD(e) {
  return Xn();
}
function Eo(e) {
  return Array.isArray(e) ? e : [e];
}
function Qg(e, l = 1e4) {
  return Wa((i, a) => {
    let s = hn(e), o;
    const m = () => setTimeout(() => {
      s = hn(e), a();
    }, hn(l));
    return ao(() => {
      clearTimeout(o);
    }), {
      get() {
        return i(), s;
      },
      set(d) {
        s = d, a(), clearTimeout(o), o = m();
      }
    };
  });
}
const JD = hn;
function e0(e, l) {
  QD() && xs(e, l);
}
function n0(e, l, i) {
  return Sn(
    e,
    l,
    {
      ...i,
      immediate: !0
    }
  );
}
const Of = Xa ? window : void 0;
function da(e) {
  var l;
  const i = hn(e);
  return (l = i?.$el) != null ? l : i;
}
function Jg(...e) {
  const l = [], i = () => {
    l.forEach((d) => d()), l.length = 0;
  }, a = (d, h, x, y) => (d.addEventListener(h, x, y), () => d.removeEventListener(h, x, y)), s = Re(() => {
    const d = Eo(hn(e[0])).filter((h) => h != null);
    return d.every((h) => typeof h != "string") ? d : void 0;
  }), o = n0(
    () => {
      var d, h;
      return [
        (h = (d = s.value) == null ? void 0 : d.map((x) => da(x))) != null ? h : [Of].filter((x) => x != null),
        Eo(hn(s.value ? e[1] : e[0])),
        Eo(le(s.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        hn(s.value ? e[3] : e[2])
      ];
    },
    ([d, h, x, y]) => {
      if (i(), !d?.length || !h?.length || !x?.length)
        return;
      const I = YD(y) ? { ...y } : y;
      l.push(
        ...d.flatMap(
          (q) => h.flatMap(
            (A) => x.map((R) => a(q, A, R, I))
          )
        )
      );
    },
    { flush: "post" }
  ), m = () => {
    o(), i();
  };
  return ao(i), m;
}
function l0(e) {
  return typeof e == "function" ? e : typeof e == "string" ? (l) => l.key === e : Array.isArray(e) ? (l) => e.includes(l.key) : () => !0;
}
function t0(...e) {
  let l, i, a = {};
  e.length === 3 ? (l = e[0], i = e[1], a = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (l = !0, i = e[0], a = e[1]) : (l = e[0], i = e[1]) : (l = !0, i = e[0]);
  const {
    target: s = Of,
    eventName: o = "keydown",
    passive: m = !1,
    dedupe: d = !1
  } = a, h = l0(l);
  return Jg(s, o, (y) => {
    y.repeat && hn(d) || h(y) && i(y);
  }, m);
}
function i0(e) {
  return JSON.parse(JSON.stringify(e));
}
function ju(e, l, i, a = {}) {
  var s, o, m;
  const {
    clone: d = !1,
    passive: h = !1,
    eventName: x,
    deep: y = !1,
    defaultValue: I,
    shouldEmit: q
  } = a, A = Xn(), R = i || A?.emit || ((s = A?.$emit) == null ? void 0 : s.bind(A)) || ((m = (o = A?.proxy) == null ? void 0 : o.$emit) == null ? void 0 : m.bind(A?.proxy));
  let V = x;
  l || (l = "modelValue"), V = V || `update:${l.toString()}`;
  const U = (B) => d ? typeof d == "function" ? d(B) : i0(B) : B, z = () => $D(e[l]) ? U(e[l]) : I, X = (B) => {
    q ? q(B) && R(V, B) : R(V, B);
  };
  if (h) {
    const B = z(), K = Fe(B);
    let W = !1;
    return Sn(
      () => e[l],
      (se) => {
        W || (W = !0, K.value = U(se), il(() => W = !1));
      }
    ), Sn(
      K,
      (se) => {
        !W && (se !== e[l] || y) && X(se);
      },
      { deep: y }
    ), K;
  } else
    return Re({
      get() {
        return z();
      },
      set(B) {
        X(B);
      }
    });
}
function _o(e) {
  if (e === null || typeof e != "object")
    return !1;
  const l = Object.getPrototypeOf(e);
  return l !== null && l !== Object.prototype && Object.getPrototypeOf(l) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0;
}
function Tm(e, l, i = ".", a) {
  if (!_o(l))
    return Tm(e, {}, i, a);
  const s = Object.assign({}, l);
  for (const o in e) {
    if (o === "__proto__" || o === "constructor")
      continue;
    const m = e[o];
    m != null && (a && a(s, o, m, i) || (Array.isArray(m) && Array.isArray(s[o]) ? s[o] = [...m, ...s[o]] : _o(m) && _o(s[o]) ? s[o] = Tm(
      m,
      s[o],
      (i ? `${i}.` : "") + o.toString(),
      a
    ) : s[o] = m));
  }
  return s;
}
function u0(e) {
  return (...l) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    l.reduce((i, a) => Tm(i, a, "", e), {})
  );
}
const a0 = u0(), r0 = HD(() => {
  const e = Fe(/* @__PURE__ */ new Map()), l = Fe(), i = Re(() => {
    for (const m of e.value.values()) if (m) return !0;
    return !1;
  }), a = uo({ scrollBody: Fe(!0) });
  let s = null;
  const o = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.documentElement.style.removeProperty("--scrollbar-width"), document.body.style.overflow = l.value ?? "", Ad && s?.(), l.value = void 0;
  };
  return Sn(i, (m, d) => {
    if (!Xa) return;
    if (!m) {
      d && o();
      return;
    }
    l.value === void 0 && (l.value = document.body.style.overflow);
    const h = window.innerWidth - document.documentElement.clientWidth, x = {
      padding: h,
      margin: 0
    }, y = a.scrollBody?.value ? typeof a.scrollBody.value == "object" ? a0({
      padding: a.scrollBody.value.padding === !0 ? h : a.scrollBody.value.padding,
      margin: a.scrollBody.value.margin === !0 ? h : a.scrollBody.value.margin
    }, x) : x : {
      padding: 0,
      margin: 0
    };
    h > 0 && (document.body.style.paddingRight = typeof y.padding == "number" ? `${y.padding}px` : String(y.padding), document.body.style.marginRight = typeof y.margin == "number" ? `${y.margin}px` : String(y.margin), document.documentElement.style.setProperty("--scrollbar-width", `${h}px`), document.body.style.overflow = "hidden"), Ad && (s = Jg(document, "touchmove", (I) => c0(I), { passive: !1 })), il(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }, {
    immediate: !0,
    flush: "sync"
  }), e;
});
function s0(e) {
  const l = Math.random().toString(36).substring(2, 7), i = r0();
  i.value.set(l, e ?? !1);
  const a = Re({
    get: () => i.value.get(l) ?? !1,
    set: (s) => i.value.set(l, s)
  });
  return e0(() => {
    i.value.delete(l);
  }), a;
}
function ev(e) {
  const l = window.getComputedStyle(e);
  if (l.overflowX === "scroll" || l.overflowY === "scroll" || l.overflowX === "auto" && e.clientWidth < e.scrollWidth || l.overflowY === "auto" && e.clientHeight < e.scrollHeight) return !0;
  {
    const i = e.parentNode;
    return !(i instanceof Element) || i.tagName === "BODY" ? !1 : ev(i);
  }
}
function c0(e) {
  const l = e || window.event, i = l.target;
  return i instanceof Element && ev(i) ? !1 : l.touches.length > 1 ? !0 : (l.preventDefault && l.cancelable && l.preventDefault(), !1);
}
function ws(e) {
  const l = uo({ dir: Fe("ltr") });
  return Re(() => e?.value || l.dir?.value || "ltr");
}
function o0(e) {
  const l = Xn(), i = l?.type.emits, a = {};
  return i?.length || console.warn(`No emitted event found. Please check component: ${l?.type.__name}`), i?.forEach((s) => {
    a[Ra(gl(s))] = (...o) => e(s, ...o);
  }), a;
}
function m0(e) {
  const l = Re(() => le(e)), i = Re(() => new Intl.Collator("en", {
    usage: "search",
    ...l.value
  }));
  return {
    startsWith: (m, d) => d.length === 0 ? !0 : (m = m.normalize("NFC"), d = d.normalize("NFC"), i.value.compare(m.slice(0, d.length), d) === 0),
    endsWith: (m, d) => d.length === 0 ? !0 : (m = m.normalize("NFC"), d = d.normalize("NFC"), i.value.compare(m.slice(-d.length), d) === 0),
    contains: (m, d) => {
      if (d.length === 0) return !0;
      m = m.normalize("NFC"), d = d.normalize("NFC");
      let h = 0;
      const x = d.length;
      for (; h + x <= m.length; h++) {
        const y = m.slice(h, h + x);
        if (i.value.compare(d, y) === 0) return !0;
      }
      return !1;
    }
  };
}
function f0(e) {
  return Re(() => JD(e) ? !!da(e)?.closest("form") : !0);
}
function Tt() {
  const e = Xn(), l = Fe(), i = Re(() => ["#text", "#comment"].includes(l.value?.$el.nodeName) ? l.value?.$el.nextElementSibling : da(l)), a = Object.assign({}, e.exposed), s = {};
  for (const m in e.props) Object.defineProperty(s, m, {
    enumerable: !0,
    configurable: !0,
    get: () => e.props[m]
  });
  if (Object.keys(a).length > 0) for (const m in a) Object.defineProperty(s, m, {
    enumerable: !0,
    configurable: !0,
    get: () => a[m]
  });
  Object.defineProperty(s, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => e.vnode.el
  }), e.exposed = s;
  function o(m) {
    l.value = m, m && (Object.defineProperty(s, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => m instanceof Element ? m : m.$el
    }), e.exposed = s);
  }
  return {
    forwardRef: o,
    currentRef: l,
    currentElement: i
  };
}
function nv(e) {
  const l = Xn(), i = Object.keys(l?.type.props ?? {}).reduce((s, o) => {
    const m = (l?.type.props[o]).default;
    return m !== void 0 && (s[o] = m), s;
  }, {}), a = gs(e);
  return Re(() => {
    const s = {}, o = l?.vnode.props ?? {};
    return Object.keys(o).forEach((m) => {
      s[gl(m)] = o[m];
    }), Object.keys({
      ...i,
      ...s
    }).reduce((m, d) => (a.value[d] !== void 0 && (m[d] = a.value[d]), m), {});
  });
}
function d0(e, l) {
  const i = nv(e), a = l ? o0(l) : {};
  return Re(() => ({
    ...i.value,
    ...a
  }));
}
var p0 = function(e) {
  if (typeof document > "u")
    return null;
  var l = Array.isArray(e) ? e[0] : e;
  return l.ownerDocument.body;
}, La = /* @__PURE__ */ new WeakMap(), Ks = /* @__PURE__ */ new WeakMap(), Gs = {}, No = 0, lv = function(e) {
  return e && (e.host || lv(e.parentNode));
}, h0 = function(e, l) {
  return l.map(function(i) {
    if (e.contains(i))
      return i;
    var a = lv(i);
    return a && e.contains(a) ? a : (console.error("aria-hidden", i, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(i) {
    return !!i;
  });
}, g0 = function(e, l, i, a) {
  var s = h0(l, Array.isArray(e) ? e : [e]);
  Gs[i] || (Gs[i] = /* @__PURE__ */ new WeakMap());
  var o = Gs[i], m = [], d = /* @__PURE__ */ new Set(), h = new Set(s), x = function(I) {
    !I || d.has(I) || (d.add(I), x(I.parentNode));
  };
  s.forEach(x);
  var y = function(I) {
    !I || h.has(I) || Array.prototype.forEach.call(I.children, function(q) {
      if (d.has(q))
        y(q);
      else
        try {
          var A = q.getAttribute(a), R = A !== null && A !== "false", V = (La.get(q) || 0) + 1, U = (o.get(q) || 0) + 1;
          La.set(q, V), o.set(q, U), m.push(q), V === 1 && R && Ks.set(q, !0), U === 1 && q.setAttribute(i, "true"), R || q.setAttribute(a, "true");
        } catch (z) {
          console.error("aria-hidden: cannot operate on ", q, z);
        }
    });
  };
  return y(l), d.clear(), No++, function() {
    m.forEach(function(I) {
      var q = La.get(I) - 1, A = o.get(I) - 1;
      La.set(I, q), o.set(I, A), q || (Ks.has(I) || I.removeAttribute(a), Ks.delete(I)), A || I.removeAttribute(i);
    }), No--, No || (La = /* @__PURE__ */ new WeakMap(), La = /* @__PURE__ */ new WeakMap(), Ks = /* @__PURE__ */ new WeakMap(), Gs = {});
  };
}, v0 = function(e, l, i) {
  i === void 0 && (i = "data-aria-hidden");
  var a = Array.from(Array.isArray(e) ? e : [e]), s = p0(e);
  return s ? (a.push.apply(a, Array.from(s.querySelectorAll("[aria-live], script"))), g0(a, s, i, "aria-hidden")) : function() {
    return null;
  };
};
function x0(e) {
  let l;
  Sn(() => da(e), (i) => {
    i ? l = v0(i) : l && l();
  }), Dt(() => {
    l && l();
  });
}
let y0 = 0;
function pa(e, l = "reka") {
  if (e) return e;
  if ("useId" in mL) return `${l}-${dh?.()}`;
  const i = uo({ useId: void 0 });
  return i.useId ? `${l}-${i.useId()}` : `${l}-${++y0}`;
}
function I0() {
  return {
    ALT: "Alt",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    ARROW_UP: "ArrowUp",
    BACKSPACE: "Backspace",
    CAPS_LOCK: "CapsLock",
    CONTROL: "Control",
    DELETE: "Delete",
    END: "End",
    ENTER: "Enter",
    ESCAPE: "Escape",
    F1: "F1",
    F10: "F10",
    F11: "F11",
    F12: "F12",
    F2: "F2",
    F3: "F3",
    F4: "F4",
    F5: "F5",
    F6: "F6",
    F7: "F7",
    F8: "F8",
    F9: "F9",
    HOME: "Home",
    META: "Meta",
    PAGE_DOWN: "PageDown",
    PAGE_UP: "PageUp",
    SHIFT: "Shift",
    SPACE: " ",
    TAB: "Tab",
    CTRL: "Control",
    ASTERISK: "*",
    SPACE_CODE: "Space"
  };
}
function L0(e, l) {
  const i = Fe(), a = (o, m) => {
    if (l.multiple && Array.isArray(e.value)) if (l.selectionBehavior === "replace")
      e.value = [o], i.value = o;
    else {
      const d = e.value.findIndex((h) => m(h));
      d !== -1 ? e.value = e.value.filter((h, x) => x !== d) : e.value = [...e.value, o];
    }
    else l.selectionBehavior === "replace" ? e.value = { ...o } : !Array.isArray(e.value) && m(e.value) ? e.value = void 0 : e.value = { ...o };
    return e.value;
  };
  function s(o, m, d, h) {
    if (!i?.value || !l.multiple || !Array.isArray(e.value)) return;
    const y = d().filter((q) => q.ref.dataset.disabled !== "").find((q) => q.ref === m)?.value;
    if (!y) return;
    let I = null;
    switch (o) {
      case "prev":
      case "next": {
        I = ac(h, i.value, y);
        break;
      }
      case "first": {
        I = ac(h, i.value, h?.[0]);
        break;
      }
      case "last": {
        I = ac(h, i.value, h?.[h.length - 1]);
        break;
      }
    }
    e.value = I;
  }
  return {
    firstValue: i,
    onSelectItem: a,
    handleMultipleReplace: s
  };
}
function D0(e) {
  const l = Fe(), i = Re(() => l.value?.width ?? 0), a = Re(() => l.value?.height ?? 0);
  return vl(() => {
    const s = da(e);
    if (s) {
      l.value = {
        width: s.offsetWidth,
        height: s.offsetHeight
      };
      const o = new ResizeObserver((m) => {
        if (!Array.isArray(m) || !m.length) return;
        const d = m[0];
        let h, x;
        if ("borderBoxSize" in d) {
          const y = d.borderBoxSize, I = Array.isArray(y) ? y[0] : y;
          h = I.inlineSize, x = I.blockSize;
        } else
          h = s.offsetWidth, x = s.offsetHeight;
        l.value = {
          width: h,
          height: x
        };
      });
      return o.observe(s, { box: "border-box" }), () => o.unobserve(s);
    } else l.value = void 0;
  }), {
    width: i,
    height: a
  };
}
function O0(e, l) {
  const i = Fe(e);
  function a(o) {
    return l[i.value][o] ?? i.value;
  }
  return {
    state: i,
    dispatch: (o) => {
      i.value = a(o);
    }
  };
}
function tv(e) {
  const l = Qg("", 1e3);
  return {
    search: l,
    handleTypeaheadSearch: (s, o) => {
      l.value = l.value + s;
      {
        const m = Ka(), d = o.map((q) => ({
          ...q,
          textValue: q.value?.textValue ?? q.ref.textContent?.trim() ?? ""
        })), h = d.find((q) => q.ref === m), x = d.map((q) => q.textValue), y = w0(x, l.value, h?.textValue), I = d.find((q) => q.textValue === y);
        return I && I.ref.focus(), I?.ref;
      }
    },
    resetTypeahead: () => {
      l.value = "";
    }
  };
}
function b0(e, l) {
  return e.map((i, a) => e[(l + a) % e.length]);
}
function w0(e, l, i) {
  const s = l.length > 1 && Array.from(l).every((x) => x === l[0]) ? l[0] : l, o = i ? e.indexOf(i) : -1;
  let m = b0(e, Math.max(o, 0));
  s.length === 1 && (m = m.filter((x) => x !== i));
  const h = m.find((x) => x.toLowerCase().startsWith(s.toLowerCase()));
  return h !== i ? h : void 0;
}
function S0(e, l) {
  const i = Fe({}), a = Fe("none"), s = Fe(e), o = e.value ? "mounted" : "unmounted";
  let m;
  const d = l.value?.ownerDocument.defaultView ?? Of, { state: h, dispatch: x } = O0(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: { MOUNT: "mounted" }
  }), y = (U) => {
    if (Xa) {
      const z = new CustomEvent(U, {
        bubbles: !1,
        cancelable: !1
      });
      l.value?.dispatchEvent(z);
    }
  };
  Sn(e, async (U, z) => {
    const X = z !== U;
    if (await il(), X) {
      const B = a.value, K = zs(l.value);
      U ? (x("MOUNT"), y("enter"), K === "none" && y("after-enter")) : K === "none" || K === "undefined" || i.value?.display === "none" ? (x("UNMOUNT"), y("leave"), y("after-leave")) : z && B !== K ? (x("ANIMATION_OUT"), y("leave")) : (x("UNMOUNT"), y("after-leave"));
    }
  }, { immediate: !0 });
  const I = (U) => {
    const z = zs(l.value), X = z.includes(CSS.escape(U.animationName)), B = h.value === "mounted" ? "enter" : "leave";
    if (U.target === l.value && X && (y(`after-${B}`), x("ANIMATION_END"), !s.value)) {
      const K = l.value.style.animationFillMode;
      l.value.style.animationFillMode = "forwards", m = d?.setTimeout(() => {
        l.value?.style.animationFillMode === "forwards" && (l.value.style.animationFillMode = K);
      });
    }
    U.target === l.value && z === "none" && x("ANIMATION_END");
  }, q = (U) => {
    U.target === l.value && (a.value = zs(l.value));
  }, A = Sn(l, (U, z) => {
    U ? (i.value = getComputedStyle(U), U.addEventListener("animationstart", q), U.addEventListener("animationcancel", I), U.addEventListener("animationend", I)) : (x("ANIMATION_END"), m !== void 0 && d?.clearTimeout(m), z?.removeEventListener("animationstart", q), z?.removeEventListener("animationcancel", I), z?.removeEventListener("animationend", I));
  }, { immediate: !0 }), R = Sn(h, () => {
    const U = zs(l.value);
    a.value = h.value === "mounted" ? U : "none";
  });
  return Dt(() => {
    A(), R();
  }), { isPresent: Re(() => ["mounted", "unmountSuspended"].includes(h.value)) };
}
function zs(e) {
  return e && getComputedStyle(e).animationName || "none";
}
var C0 = /* @__PURE__ */ dn({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: { type: Boolean }
  },
  slots: {},
  setup(e, { slots: l, expose: i }) {
    const { present: a, forceMount: s } = St(e), o = Fe(), { isPresent: m } = S0(a, o);
    i({ present: m });
    let d = l.default({ present: m.value });
    d = Df(d || []);
    const h = Xn();
    if (d && d?.length > 1) {
      const x = h?.parent?.type.name ? `<${h.parent.type.name} />` : "component";
      throw new Error([
        `Detected an invalid children for \`${x}\` for  \`Presence\` component.`,
        "",
        "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
        "You can apply a few solutions:",
        ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map((y) => `  - ${y}`).join(`
`)
      ].join(`
`));
    }
    return () => s.value || a.value || m.value ? gt(l.default({ present: m.value })[0], { ref: (x) => {
      const y = da(x);
      return typeof y?.hasAttribute > "u" || (y?.hasAttribute("data-reka-popper-content-wrapper") ? o.value = y.firstElementChild : o.value = y), y;
    } }) : null;
  }
});
const Pm = /* @__PURE__ */ dn({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(e, { attrs: l, slots: i }) {
    return () => {
      if (!i.default) return null;
      const a = Df(i.default()), s = a.findIndex((h) => h.type !== ul);
      if (s === -1) return a;
      const o = a[s];
      delete o.props?.ref;
      const m = o.props ? pl(l, o.props) : l, d = di({
        ...o,
        props: {}
      }, m);
      return a.length === 1 ? d : (a[s] = d, a);
    };
  }
}), T0 = [
  "area",
  "img",
  "input"
], al = /* @__PURE__ */ dn({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(e, { attrs: l, slots: i }) {
    const a = e.asChild ? "template" : e.as;
    return typeof a == "string" && T0.includes(a) ? () => gt(a, l) : a !== "template" ? () => gt(e.as, l, { default: i.default }) : () => gt(Pm, l, { default: i.default });
  }
});
function Hu() {
  const e = Fe(), l = Re(() => ["#text", "#comment"].includes(e.value?.$el.nodeName) ? e.value?.$el.nextElementSibling : da(e));
  return {
    primitiveElement: e,
    currentElement: l
  };
}
const P0 = "dismissableLayer.pointerDownOutside", q0 = "dismissableLayer.focusOutside";
function iv(e, l) {
  const i = l.closest("[data-dismissable-layer]"), a = e.dataset.dismissableLayer === "" ? e : e.querySelector("[data-dismissable-layer]"), s = Array.from(e.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
  return !!(i && (a === i || s.indexOf(a) < s.indexOf(i)));
}
function A0(e, l, i = !0) {
  const a = l?.value?.ownerDocument ?? globalThis?.document, s = Fe(!1), o = Fe(() => {
  });
  return Ml((m) => {
    if (!Xa || !hn(i)) return;
    const d = async (x) => {
      const y = x.target;
      if (!(!l?.value || !y)) {
        if (iv(l.value, y)) {
          s.value = !1;
          return;
        }
        if (x.target && !s.value) {
          let q = function() {
            ss(P0, e, I);
          };
          const I = { originalEvent: x };
          x.pointerType === "touch" ? (a.removeEventListener("click", o.value), o.value = q, a.addEventListener("click", o.value, { once: !0 })) : q();
        } else a.removeEventListener("click", o.value);
        s.value = !1;
      }
    }, h = window.setTimeout(() => {
      a.addEventListener("pointerdown", d);
    }, 0);
    m(() => {
      window.clearTimeout(h), a.removeEventListener("pointerdown", d), a.removeEventListener("click", o.value);
    });
  }), { onPointerDownCapture: () => {
    hn(i) && (s.value = !0);
  } };
}
function R0(e, l, i = !0) {
  const a = l?.value?.ownerDocument ?? globalThis?.document, s = Fe(!1);
  return Ml((o) => {
    if (!Xa || !hn(i)) return;
    const m = async (d) => {
      if (!l?.value) return;
      await il(), await il();
      const h = d.target;
      !l.value || !h || iv(l.value, h) || d.target && !s.value && ss(q0, e, { originalEvent: d });
    };
    a.addEventListener("focusin", m), o(() => a.removeEventListener("focusin", m));
  }), {
    onFocusCapture: () => {
      hn(i) && (s.value = !0);
    },
    onBlurCapture: () => {
      hn(i) && (s.value = !1);
    }
  };
}
const Ti = Ha({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var E0 = /* @__PURE__ */ dn({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "dismiss"
  ],
  setup(e, { emit: l }) {
    const i = e, a = l, { forwardRef: s, currentElement: o } = Tt(), m = Re(() => o.value?.ownerDocument ?? globalThis.document), d = Re(() => Ti.layersRoot), h = Re(() => o.value ? Array.from(d.value).indexOf(o.value) : -1), x = Re(() => Ti.layersWithOutsidePointerEventsDisabled.size > 0), y = Re(() => {
      const R = Array.from(d.value), [V] = [...Ti.layersWithOutsidePointerEventsDisabled].slice(-1), U = R.indexOf(V);
      return h.value >= U;
    }), I = A0(async (R) => {
      const V = [...Ti.branches].some((U) => U?.contains(R.target));
      !y.value || V || (a("pointerDownOutside", R), a("interactOutside", R), await il(), R.defaultPrevented || a("dismiss"));
    }, o), q = R0((R) => {
      [...Ti.branches].some((U) => U?.contains(R.target)) || (a("focusOutside", R), a("interactOutside", R), R.defaultPrevented || a("dismiss"));
    }, o);
    t0("Escape", (R) => {
      h.value === d.value.size - 1 && (a("escapeKeyDown", R), R.defaultPrevented || a("dismiss"));
    });
    let A;
    return Ml((R) => {
      o.value && (i.disableOutsidePointerEvents && (Ti.layersWithOutsidePointerEventsDisabled.size === 0 && (A = m.value.body.style.pointerEvents, m.value.body.style.pointerEvents = "none"), Ti.layersWithOutsidePointerEventsDisabled.add(o.value)), d.value.add(o.value), R(() => {
        i.disableOutsidePointerEvents && Ti.layersWithOutsidePointerEventsDisabled.size === 1 && (m.value.body.style.pointerEvents = A);
      }));
    }), Ml((R) => {
      R(() => {
        o.value && (d.value.delete(o.value), Ti.layersWithOutsidePointerEventsDisabled.delete(o.value));
      });
    }), (R, V) => (We(), vn(le(al), {
      ref: le(s),
      "as-child": R.asChild,
      as: R.as,
      "data-dismissable-layer": "",
      style: Hi({ pointerEvents: x.value ? y.value ? "auto" : "none" : void 0 }),
      onFocusCapture: le(q).onFocusCapture,
      onBlurCapture: le(q).onBlurCapture,
      onPointerdownCapture: le(I).onPointerDownCapture
    }, {
      default: ln(() => [qn(R.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "style",
      "onFocusCapture",
      "onBlurCapture",
      "onPointerdownCapture"
    ]));
  }
}), _0 = E0;
const Rd = "data-reka-collection-item";
function Qa(e = {}) {
  const { key: l = "", isProvider: i = !1 } = e, a = `${l}CollectionProvider`;
  let s;
  if (i) {
    const y = Fe(/* @__PURE__ */ new Map());
    s = {
      collectionRef: Fe(),
      itemMap: y
    }, Xc(a, s);
  } else s = Fi(a);
  const o = (y = !1) => {
    const I = s.collectionRef.value;
    if (!I) return [];
    const q = Array.from(I.querySelectorAll(`[${Rd}]`)), R = Array.from(s.itemMap.value.values()).sort((V, U) => q.indexOf(V.ref) - q.indexOf(U.ref));
    return y ? R : R.filter((V) => V.ref.dataset.disabled !== "");
  }, m = /* @__PURE__ */ dn({
    name: "CollectionSlot",
    setup(y, { slots: I }) {
      const { primitiveElement: q, currentElement: A } = Hu();
      return Sn(A, () => {
        s.collectionRef.value = A.value;
      }), () => gt(Pm, { ref: q }, I);
    }
  }), d = /* @__PURE__ */ dn({
    name: "CollectionItem",
    inheritAttrs: !1,
    props: { value: { validator: () => !0 } },
    setup(y, { slots: I, attrs: q }) {
      const { primitiveElement: A, currentElement: R } = Hu();
      return Ml((V) => {
        if (R.value) {
          const U = $a(R.value);
          s.itemMap.value.set(U, {
            ref: R.value,
            value: y.value
          }), V(() => s.itemMap.value.delete(U));
        }
      }), () => gt(Pm, {
        ...q,
        [Rd]: "",
        ref: A
      }, I);
    }
  }), h = Re(() => Array.from(s.itemMap.value.values())), x = Re(() => s.itemMap.value.size);
  return {
    getItems: o,
    reactiveItems: h,
    itemMapSize: x,
    CollectionSlot: m,
    CollectionItem: d
  };
}
const N0 = "rovingFocusGroup.onEntryFocus", F0 = {
  bubbles: !1,
  cancelable: !0
}, uv = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function M0(e, l) {
  return l !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function av(e, l, i) {
  const a = M0(e.key, i);
  if (!(l === "vertical" && ["ArrowLeft", "ArrowRight"].includes(a)) && !(l === "horizontal" && ["ArrowUp", "ArrowDown"].includes(a)))
    return uv[a];
}
function rv(e, l = !1) {
  const i = Ka();
  for (const a of e)
    if (a === i || (a.focus({ preventScroll: l }), Ka() !== i)) return;
}
function k0(e, l) {
  return e.map((i, a) => e[(l + a) % e.length]);
}
const [V0, B0] = vi("RovingFocusGroup");
var Z0 = /* @__PURE__ */ dn({
  __name: "RovingFocusGroup",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    currentTabStopId: {
      type: [String, null],
      required: !1
    },
    defaultCurrentTabStopId: {
      type: String,
      required: !1
    },
    preventScrollOnEntryFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, { loop: o, orientation: m, dir: d } = St(a), h = ws(d), x = ju(a, "currentTabStopId", s, {
      defaultValue: a.defaultCurrentTabStopId,
      passive: a.currentTabStopId === void 0
    }), y = Fe(!1), I = Fe(!1), q = Fe(0), { getItems: A, CollectionSlot: R } = Qa({ isProvider: !0 });
    function V(z) {
      const X = !I.value;
      if (z.currentTarget && z.target === z.currentTarget && X && !y.value) {
        const B = new CustomEvent(N0, F0);
        if (z.currentTarget.dispatchEvent(B), s("entryFocus", B), !B.defaultPrevented) {
          const K = A().map((M) => M.ref).filter((M) => M.dataset.disabled !== ""), W = K.find((M) => M.getAttribute("data-active") === ""), se = K.find((M) => M.getAttribute("data-highlighted") === ""), te = K.find((M) => M.id === x.value), me = [
            W,
            se,
            te,
            ...K
          ].filter(Boolean);
          rv(me, a.preventScrollOnEntryFocus);
        }
      }
      I.value = !1;
    }
    function U() {
      setTimeout(() => {
        I.value = !1;
      }, 1);
    }
    return l({ getItems: A }), B0({
      loop: o,
      dir: h,
      orientation: m,
      currentTabStopId: x,
      onItemFocus: (z) => {
        x.value = z;
      },
      onItemShiftTab: () => {
        y.value = !0;
      },
      onFocusableItemAdd: () => {
        q.value++;
      },
      onFocusableItemRemove: () => {
        q.value--;
      }
    }), (z, X) => (We(), vn(le(R), null, {
      default: ln(() => [je(le(al), {
        tabindex: y.value || q.value === 0 ? -1 : 0,
        "data-orientation": le(m),
        as: z.as,
        "as-child": z.asChild,
        dir: le(h),
        style: { outline: "none" },
        onMousedown: X[0] || (X[0] = (B) => I.value = !0),
        onMouseup: U,
        onFocus: V,
        onBlur: X[1] || (X[1] = (B) => y.value = !1)
      }, {
        default: ln(() => [qn(z.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "as",
        "as-child",
        "dir"
      ])]),
      _: 3
    }));
  }
}), U0 = Z0, K0 = /* @__PURE__ */ dn({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {
      type: String,
      required: !1
    },
    focusable: {
      type: Boolean,
      required: !1,
      default: !0
    },
    active: {
      type: Boolean,
      required: !1
    },
    allowShiftKey: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const l = e, i = V0(), a = pa(), s = Re(() => l.tabStopId || a), o = Re(() => i.currentTabStopId.value === s.value), { getItems: m, CollectionItem: d } = Qa();
    vl(() => {
      l.focusable && i.onFocusableItemAdd();
    }), Dt(() => {
      l.focusable && i.onFocusableItemRemove();
    });
    function h(x) {
      if (x.key === "Tab" && x.shiftKey) {
        i.onItemShiftTab();
        return;
      }
      if (x.target !== x.currentTarget) return;
      const y = av(x, i.orientation.value, i.dir.value);
      if (y !== void 0) {
        if (x.metaKey || x.ctrlKey || x.altKey || !l.allowShiftKey && x.shiftKey) return;
        x.preventDefault();
        let I = [...m().map((q) => q.ref).filter((q) => q.dataset.disabled !== "")];
        if (y === "last") I.reverse();
        else if (y === "prev" || y === "next") {
          y === "prev" && I.reverse();
          const q = I.indexOf(x.currentTarget);
          I = i.loop.value ? k0(I, q + 1) : I.slice(q + 1);
        }
        il(() => rv(I));
      }
    }
    return (x, y) => (We(), vn(le(d), null, {
      default: ln(() => [je(le(al), {
        tabindex: o.value ? 0 : -1,
        "data-orientation": le(i).orientation.value,
        "data-active": x.active ? "" : void 0,
        "data-disabled": x.focusable ? void 0 : "",
        as: x.as,
        "as-child": x.asChild,
        onMousedown: y[0] || (y[0] = (I) => {
          x.focusable ? le(i).onItemFocus(s.value) : I.preventDefault();
        }),
        onFocus: y[1] || (y[1] = (I) => le(i).onItemFocus(s.value)),
        onKeydown: h
      }, {
        default: ln(() => [qn(x.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "data-active",
        "data-disabled",
        "as",
        "as-child"
      ])]),
      _: 3
    }));
  }
}), G0 = K0, z0 = /* @__PURE__ */ dn({
  __name: "VisuallyHidden",
  props: {
    feature: {
      type: String,
      required: !1,
      default: "focusable"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return (l, i) => (We(), vn(le(al), {
      as: l.as,
      "as-child": l.asChild,
      "aria-hidden": l.feature === "focusable" ? "true" : void 0,
      "data-hidden": l.feature === "fully-hidden" ? "" : void 0,
      tabindex: l.feature === "fully-hidden" ? "-1" : void 0,
      style: {
        position: "absolute",
        border: 0,
        width: "1px",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        clipPath: "inset(50%)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        top: "-1px",
        left: "-1px"
      }
    }, {
      default: ln(() => [qn(l.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-hidden",
      "data-hidden",
      "tabindex"
    ]));
  }
}), j0 = z0, H0 = /* @__PURE__ */ dn({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInputBubble",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const l = e, { primitiveElement: i, currentElement: a } = Hu(), s = Re(() => l.checked ?? l.value);
    return Sn(s, (o, m) => {
      if (!a.value) return;
      const d = a.value, h = window.HTMLInputElement.prototype, y = Object.getOwnPropertyDescriptor(h, "value").set;
      if (y && o !== m) {
        const I = new Event("input", { bubbles: !0 }), q = new Event("change", { bubbles: !0 });
        y.call(d, o), d.dispatchEvent(I), d.dispatchEvent(q);
      }
    }), (o, m) => (We(), vn(j0, pl({
      ref_key: "primitiveElement",
      ref: i
    }, {
      ...l,
      ...o.$attrs
    }, { as: "input" }), null, 16));
  }
}), Ed = H0, $0 = /* @__PURE__ */ dn({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInput",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const l = e, i = Re(() => typeof l.value == "object" && Array.isArray(l.value) && l.value.length === 0 && l.required), a = Re(() => typeof l.value == "string" || typeof l.value == "number" || typeof l.value == "boolean" || l.value === null || l.value === void 0 ? [{
      name: l.name,
      value: l.value
    }] : typeof l.value == "object" && Array.isArray(l.value) ? l.value.flatMap((s, o) => typeof s == "object" ? Object.entries(s).map(([m, d]) => ({
      name: `${l.name}[${o}][${m}]`,
      value: d
    })) : {
      name: `${l.name}[${o}]`,
      value: s
    }) : l.value !== null && typeof l.value == "object" && !Array.isArray(l.value) ? Object.entries(l.value).map(([s, o]) => ({
      name: `${l.name}[${s}]`,
      value: o
    })) : []);
    return (s, o) => (We(), Yn(Mn, null, [pi(" We render single input if it's required "), i.value ? (We(), vn(Ed, pl({ key: s.name }, {
      ...l,
      ...s.$attrs
    }, {
      name: s.name,
      value: s.value
    }), null, 16, ["name", "value"])) : (We(!0), Yn(Mn, { key: 1 }, Is(a.value, (m) => (We(), vn(Ed, pl({ key: m.name }, { ref_for: !0 }, {
      ...l,
      ...s.$attrs
    }, {
      name: m.name,
      value: m.value
    }), null, 16, ["name", "value"]))), 128))], 2112));
  }
}), W0 = $0;
const [sv, Y0] = vi("PopperRoot");
var X0 = /* @__PURE__ */ dn({
  inheritAttrs: !1,
  __name: "PopperRoot",
  setup(e) {
    const l = Fe();
    return Y0({
      anchor: l,
      onAnchorChange: (i) => l.value = i
    }), (i, a) => qn(i.$slots, "default");
  }
}), Q0 = X0, J0 = /* @__PURE__ */ dn({
  __name: "PopperAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const l = e, { forwardRef: i, currentElement: a } = Tt(), s = sv();
    return of(() => {
      s.onAnchorChange(l.reference ?? a.value);
    }), (o, m) => (We(), vn(le(al), {
      ref: le(i),
      as: o.as,
      "as-child": o.asChild
    }, {
      default: ln(() => [qn(o.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), eO = J0;
function nO(e) {
  return e !== null;
}
function lO(e) {
  return {
    name: "transformOrigin",
    options: e,
    fn(l) {
      const { placement: i, rects: a, middlewareData: s } = l, m = s.arrow?.centerOffset !== 0, d = m ? 0 : e.arrowWidth, h = m ? 0 : e.arrowHeight, [x, y] = qm(i), I = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[y], q = (s.arrow?.x ?? 0) + d / 2, A = (s.arrow?.y ?? 0) + h / 2;
      let R = "", V = "";
      return x === "bottom" ? (R = m ? I : `${q}px`, V = `${-h}px`) : x === "top" ? (R = m ? I : `${q}px`, V = `${a.floating.height + h}px`) : x === "right" ? (R = `${-h}px`, V = m ? I : `${A}px`) : x === "left" && (R = `${a.floating.width + h}px`, V = m ? I : `${A}px`), { data: {
        x: R,
        y: V
      } };
    }
  };
}
function qm(e) {
  const [l, i = "center"] = e.split("-");
  return [l, i];
}
const tO = ["top", "right", "bottom", "left"], $u = Math.min, xt = Math.max, Pc = Math.round, js = Math.floor, bi = (e) => ({
  x: e,
  y: e
}), iO = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, uO = {
  start: "end",
  end: "start"
};
function Am(e, l, i) {
  return xt(e, $u(l, i));
}
function zi(e, l) {
  return typeof e == "function" ? e(l) : e;
}
function ji(e) {
  return e.split("-")[0];
}
function Ja(e) {
  return e.split("-")[1];
}
function bf(e) {
  return e === "x" ? "y" : "x";
}
function wf(e) {
  return e === "y" ? "height" : "width";
}
const aO = /* @__PURE__ */ new Set(["top", "bottom"]);
function Oi(e) {
  return aO.has(ji(e)) ? "y" : "x";
}
function Sf(e) {
  return bf(Oi(e));
}
function rO(e, l, i) {
  i === void 0 && (i = !1);
  const a = Ja(e), s = Sf(e), o = wf(s);
  let m = s === "x" ? a === (i ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return l.reference[o] > l.floating[o] && (m = qc(m)), [m, qc(m)];
}
function sO(e) {
  const l = qc(e);
  return [Rm(e), l, Rm(l)];
}
function Rm(e) {
  return e.replace(/start|end/g, (l) => uO[l]);
}
const _d = ["left", "right"], Nd = ["right", "left"], cO = ["top", "bottom"], oO = ["bottom", "top"];
function mO(e, l, i) {
  switch (e) {
    case "top":
    case "bottom":
      return i ? l ? Nd : _d : l ? _d : Nd;
    case "left":
    case "right":
      return l ? cO : oO;
    default:
      return [];
  }
}
function fO(e, l, i, a) {
  const s = Ja(e);
  let o = mO(ji(e), i === "start", a);
  return s && (o = o.map((m) => m + "-" + s), l && (o = o.concat(o.map(Rm)))), o;
}
function qc(e) {
  return e.replace(/left|right|bottom|top/g, (l) => iO[l]);
}
function dO(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function cv(e) {
  return typeof e != "number" ? dO(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Ac(e) {
  const {
    x: l,
    y: i,
    width: a,
    height: s
  } = e;
  return {
    width: a,
    height: s,
    top: i,
    left: l,
    right: l + a,
    bottom: i + s,
    x: l,
    y: i
  };
}
function Fd(e, l, i) {
  let {
    reference: a,
    floating: s
  } = e;
  const o = Oi(l), m = Sf(l), d = wf(m), h = ji(l), x = o === "y", y = a.x + a.width / 2 - s.width / 2, I = a.y + a.height / 2 - s.height / 2, q = a[d] / 2 - s[d] / 2;
  let A;
  switch (h) {
    case "top":
      A = {
        x: y,
        y: a.y - s.height
      };
      break;
    case "bottom":
      A = {
        x: y,
        y: a.y + a.height
      };
      break;
    case "right":
      A = {
        x: a.x + a.width,
        y: I
      };
      break;
    case "left":
      A = {
        x: a.x - s.width,
        y: I
      };
      break;
    default:
      A = {
        x: a.x,
        y: a.y
      };
  }
  switch (Ja(l)) {
    case "start":
      A[m] -= q * (i && x ? -1 : 1);
      break;
    case "end":
      A[m] += q * (i && x ? -1 : 1);
      break;
  }
  return A;
}
const pO = async (e, l, i) => {
  const {
    placement: a = "bottom",
    strategy: s = "absolute",
    middleware: o = [],
    platform: m
  } = i, d = o.filter(Boolean), h = await (m.isRTL == null ? void 0 : m.isRTL(l));
  let x = await m.getElementRects({
    reference: e,
    floating: l,
    strategy: s
  }), {
    x: y,
    y: I
  } = Fd(x, a, h), q = a, A = {}, R = 0;
  for (let V = 0; V < d.length; V++) {
    const {
      name: U,
      fn: z
    } = d[V], {
      x: X,
      y: B,
      data: K,
      reset: W
    } = await z({
      x: y,
      y: I,
      initialPlacement: a,
      placement: q,
      strategy: s,
      middlewareData: A,
      rects: x,
      platform: m,
      elements: {
        reference: e,
        floating: l
      }
    });
    y = X ?? y, I = B ?? I, A = {
      ...A,
      [U]: {
        ...A[U],
        ...K
      }
    }, W && R <= 50 && (R++, typeof W == "object" && (W.placement && (q = W.placement), W.rects && (x = W.rects === !0 ? await m.getElementRects({
      reference: e,
      floating: l,
      strategy: s
    }) : W.rects), {
      x: y,
      y: I
    } = Fd(x, q, h)), V = -1);
  }
  return {
    x: y,
    y: I,
    placement: q,
    strategy: s,
    middlewareData: A
  };
};
async function cs(e, l) {
  var i;
  l === void 0 && (l = {});
  const {
    x: a,
    y: s,
    platform: o,
    rects: m,
    elements: d,
    strategy: h
  } = e, {
    boundary: x = "clippingAncestors",
    rootBoundary: y = "viewport",
    elementContext: I = "floating",
    altBoundary: q = !1,
    padding: A = 0
  } = zi(l, e), R = cv(A), U = d[q ? I === "floating" ? "reference" : "floating" : I], z = Ac(await o.getClippingRect({
    element: (i = await (o.isElement == null ? void 0 : o.isElement(U))) == null || i ? U : U.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(d.floating)),
    boundary: x,
    rootBoundary: y,
    strategy: h
  })), X = I === "floating" ? {
    x: a,
    y: s,
    width: m.floating.width,
    height: m.floating.height
  } : m.reference, B = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(d.floating)), K = await (o.isElement == null ? void 0 : o.isElement(B)) ? await (o.getScale == null ? void 0 : o.getScale(B)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, W = Ac(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: d,
    rect: X,
    offsetParent: B,
    strategy: h
  }) : X);
  return {
    top: (z.top - W.top + R.top) / K.y,
    bottom: (W.bottom - z.bottom + R.bottom) / K.y,
    left: (z.left - W.left + R.left) / K.x,
    right: (W.right - z.right + R.right) / K.x
  };
}
const hO = (e) => ({
  name: "arrow",
  options: e,
  async fn(l) {
    const {
      x: i,
      y: a,
      placement: s,
      rects: o,
      platform: m,
      elements: d,
      middlewareData: h
    } = l, {
      element: x,
      padding: y = 0
    } = zi(e, l) || {};
    if (x == null)
      return {};
    const I = cv(y), q = {
      x: i,
      y: a
    }, A = Sf(s), R = wf(A), V = await m.getDimensions(x), U = A === "y", z = U ? "top" : "left", X = U ? "bottom" : "right", B = U ? "clientHeight" : "clientWidth", K = o.reference[R] + o.reference[A] - q[A] - o.floating[R], W = q[A] - o.reference[A], se = await (m.getOffsetParent == null ? void 0 : m.getOffsetParent(x));
    let te = se ? se[B] : 0;
    (!te || !await (m.isElement == null ? void 0 : m.isElement(se))) && (te = d.floating[B] || o.floating[R]);
    const me = K / 2 - W / 2, M = te / 2 - V[R] / 2 - 1, ce = $u(I[z], M), Ie = $u(I[X], M), ae = ce, ve = te - V[R] - Ie, ye = te / 2 - V[R] / 2 + me, Se = Am(ae, ye, ve), ge = !h.arrow && Ja(s) != null && ye !== Se && o.reference[R] / 2 - (ye < ae ? ce : Ie) - V[R] / 2 < 0, oe = ge ? ye < ae ? ye - ae : ye - ve : 0;
    return {
      [A]: q[A] + oe,
      data: {
        [A]: Se,
        centerOffset: ye - Se - oe,
        ...ge && {
          alignmentOffset: oe
        }
      },
      reset: ge
    };
  }
}), gO = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(l) {
      var i, a;
      const {
        placement: s,
        middlewareData: o,
        rects: m,
        initialPlacement: d,
        platform: h,
        elements: x
      } = l, {
        mainAxis: y = !0,
        crossAxis: I = !0,
        fallbackPlacements: q,
        fallbackStrategy: A = "bestFit",
        fallbackAxisSideDirection: R = "none",
        flipAlignment: V = !0,
        ...U
      } = zi(e, l);
      if ((i = o.arrow) != null && i.alignmentOffset)
        return {};
      const z = ji(s), X = Oi(d), B = ji(d) === d, K = await (h.isRTL == null ? void 0 : h.isRTL(x.floating)), W = q || (B || !V ? [qc(d)] : sO(d)), se = R !== "none";
      !q && se && W.push(...fO(d, V, R, K));
      const te = [d, ...W], me = await cs(l, U), M = [];
      let ce = ((a = o.flip) == null ? void 0 : a.overflows) || [];
      if (y && M.push(me[z]), I) {
        const ye = rO(s, m, K);
        M.push(me[ye[0]], me[ye[1]]);
      }
      if (ce = [...ce, {
        placement: s,
        overflows: M
      }], !M.every((ye) => ye <= 0)) {
        var Ie, ae;
        const ye = (((Ie = o.flip) == null ? void 0 : Ie.index) || 0) + 1, Se = te[ye];
        if (Se && (!(I === "alignment" ? X !== Oi(Se) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        ce.every((de) => Oi(de.placement) === X ? de.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ye,
              overflows: ce
            },
            reset: {
              placement: Se
            }
          };
        let ge = (ae = ce.filter((oe) => oe.overflows[0] <= 0).sort((oe, de) => oe.overflows[1] - de.overflows[1])[0]) == null ? void 0 : ae.placement;
        if (!ge)
          switch (A) {
            case "bestFit": {
              var ve;
              const oe = (ve = ce.filter((de) => {
                if (se) {
                  const De = Oi(de.placement);
                  return De === X || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  De === "y";
                }
                return !0;
              }).map((de) => [de.placement, de.overflows.filter((De) => De > 0).reduce((De, Ee) => De + Ee, 0)]).sort((de, De) => de[1] - De[1])[0]) == null ? void 0 : ve[0];
              oe && (ge = oe);
              break;
            }
            case "initialPlacement":
              ge = d;
              break;
          }
        if (s !== ge)
          return {
            reset: {
              placement: ge
            }
          };
      }
      return {};
    }
  };
};
function Md(e, l) {
  return {
    top: e.top - l.height,
    right: e.right - l.width,
    bottom: e.bottom - l.height,
    left: e.left - l.width
  };
}
function kd(e) {
  return tO.some((l) => e[l] >= 0);
}
const vO = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(l) {
      const {
        rects: i
      } = l, {
        strategy: a = "referenceHidden",
        ...s
      } = zi(e, l);
      switch (a) {
        case "referenceHidden": {
          const o = await cs(l, {
            ...s,
            elementContext: "reference"
          }), m = Md(o, i.reference);
          return {
            data: {
              referenceHiddenOffsets: m,
              referenceHidden: kd(m)
            }
          };
        }
        case "escaped": {
          const o = await cs(l, {
            ...s,
            altBoundary: !0
          }), m = Md(o, i.floating);
          return {
            data: {
              escapedOffsets: m,
              escaped: kd(m)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, ov = /* @__PURE__ */ new Set(["left", "top"]);
async function xO(e, l) {
  const {
    placement: i,
    platform: a,
    elements: s
  } = e, o = await (a.isRTL == null ? void 0 : a.isRTL(s.floating)), m = ji(i), d = Ja(i), h = Oi(i) === "y", x = ov.has(m) ? -1 : 1, y = o && h ? -1 : 1, I = zi(l, e);
  let {
    mainAxis: q,
    crossAxis: A,
    alignmentAxis: R
  } = typeof I == "number" ? {
    mainAxis: I,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: I.mainAxis || 0,
    crossAxis: I.crossAxis || 0,
    alignmentAxis: I.alignmentAxis
  };
  return d && typeof R == "number" && (A = d === "end" ? R * -1 : R), h ? {
    x: A * y,
    y: q * x
  } : {
    x: q * x,
    y: A * y
  };
}
const yO = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(l) {
      var i, a;
      const {
        x: s,
        y: o,
        placement: m,
        middlewareData: d
      } = l, h = await xO(l, e);
      return m === ((i = d.offset) == null ? void 0 : i.placement) && (a = d.arrow) != null && a.alignmentOffset ? {} : {
        x: s + h.x,
        y: o + h.y,
        data: {
          ...h,
          placement: m
        }
      };
    }
  };
}, IO = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(l) {
      const {
        x: i,
        y: a,
        placement: s
      } = l, {
        mainAxis: o = !0,
        crossAxis: m = !1,
        limiter: d = {
          fn: (U) => {
            let {
              x: z,
              y: X
            } = U;
            return {
              x: z,
              y: X
            };
          }
        },
        ...h
      } = zi(e, l), x = {
        x: i,
        y: a
      }, y = await cs(l, h), I = Oi(ji(s)), q = bf(I);
      let A = x[q], R = x[I];
      if (o) {
        const U = q === "y" ? "top" : "left", z = q === "y" ? "bottom" : "right", X = A + y[U], B = A - y[z];
        A = Am(X, A, B);
      }
      if (m) {
        const U = I === "y" ? "top" : "left", z = I === "y" ? "bottom" : "right", X = R + y[U], B = R - y[z];
        R = Am(X, R, B);
      }
      const V = d.fn({
        ...l,
        [q]: A,
        [I]: R
      });
      return {
        ...V,
        data: {
          x: V.x - i,
          y: V.y - a,
          enabled: {
            [q]: o,
            [I]: m
          }
        }
      };
    }
  };
}, LO = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(l) {
      const {
        x: i,
        y: a,
        placement: s,
        rects: o,
        middlewareData: m
      } = l, {
        offset: d = 0,
        mainAxis: h = !0,
        crossAxis: x = !0
      } = zi(e, l), y = {
        x: i,
        y: a
      }, I = Oi(s), q = bf(I);
      let A = y[q], R = y[I];
      const V = zi(d, l), U = typeof V == "number" ? {
        mainAxis: V,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...V
      };
      if (h) {
        const B = q === "y" ? "height" : "width", K = o.reference[q] - o.floating[B] + U.mainAxis, W = o.reference[q] + o.reference[B] - U.mainAxis;
        A < K ? A = K : A > W && (A = W);
      }
      if (x) {
        var z, X;
        const B = q === "y" ? "width" : "height", K = ov.has(ji(s)), W = o.reference[I] - o.floating[B] + (K && ((z = m.offset) == null ? void 0 : z[I]) || 0) + (K ? 0 : U.crossAxis), se = o.reference[I] + o.reference[B] + (K ? 0 : ((X = m.offset) == null ? void 0 : X[I]) || 0) - (K ? U.crossAxis : 0);
        R < W ? R = W : R > se && (R = se);
      }
      return {
        [q]: A,
        [I]: R
      };
    }
  };
}, DO = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(l) {
      var i, a;
      const {
        placement: s,
        rects: o,
        platform: m,
        elements: d
      } = l, {
        apply: h = () => {
        },
        ...x
      } = zi(e, l), y = await cs(l, x), I = ji(s), q = Ja(s), A = Oi(s) === "y", {
        width: R,
        height: V
      } = o.floating;
      let U, z;
      I === "top" || I === "bottom" ? (U = I, z = q === (await (m.isRTL == null ? void 0 : m.isRTL(d.floating)) ? "start" : "end") ? "left" : "right") : (z = I, U = q === "end" ? "top" : "bottom");
      const X = V - y.top - y.bottom, B = R - y.left - y.right, K = $u(V - y[U], X), W = $u(R - y[z], B), se = !l.middlewareData.shift;
      let te = K, me = W;
      if ((i = l.middlewareData.shift) != null && i.enabled.x && (me = B), (a = l.middlewareData.shift) != null && a.enabled.y && (te = X), se && !q) {
        const ce = xt(y.left, 0), Ie = xt(y.right, 0), ae = xt(y.top, 0), ve = xt(y.bottom, 0);
        A ? me = R - 2 * (ce !== 0 || Ie !== 0 ? ce + Ie : xt(y.left, y.right)) : te = V - 2 * (ae !== 0 || ve !== 0 ? ae + ve : xt(y.top, y.bottom));
      }
      await h({
        ...l,
        availableWidth: me,
        availableHeight: te
      });
      const M = await m.getDimensions(d.floating);
      return R !== M.width || V !== M.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function ro() {
  return typeof window < "u";
}
function ha(e) {
  return Cf(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function It(e) {
  var l;
  return (e == null || (l = e.ownerDocument) == null ? void 0 : l.defaultView) || window;
}
function Si(e) {
  var l;
  return (l = (Cf(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : l.documentElement;
}
function Cf(e) {
  return ro() ? e instanceof Node || e instanceof It(e).Node : !1;
}
function hi(e) {
  return ro() ? e instanceof Element || e instanceof It(e).Element : !1;
}
function wi(e) {
  return ro() ? e instanceof HTMLElement || e instanceof It(e).HTMLElement : !1;
}
function Vd(e) {
  return !ro() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof It(e).ShadowRoot;
}
const OO = /* @__PURE__ */ new Set(["inline", "contents"]);
function Ss(e) {
  const {
    overflow: l,
    overflowX: i,
    overflowY: a,
    display: s
  } = gi(e);
  return /auto|scroll|overlay|hidden|clip/.test(l + a + i) && !OO.has(s);
}
const bO = /* @__PURE__ */ new Set(["table", "td", "th"]);
function wO(e) {
  return bO.has(ha(e));
}
const SO = [":popover-open", ":modal"];
function so(e) {
  return SO.some((l) => {
    try {
      return e.matches(l);
    } catch {
      return !1;
    }
  });
}
const CO = ["transform", "translate", "scale", "rotate", "perspective"], TO = ["transform", "translate", "scale", "rotate", "perspective", "filter"], PO = ["paint", "layout", "strict", "content"];
function Tf(e) {
  const l = Pf(), i = hi(e) ? gi(e) : e;
  return CO.some((a) => i[a] ? i[a] !== "none" : !1) || (i.containerType ? i.containerType !== "normal" : !1) || !l && (i.backdropFilter ? i.backdropFilter !== "none" : !1) || !l && (i.filter ? i.filter !== "none" : !1) || TO.some((a) => (i.willChange || "").includes(a)) || PO.some((a) => (i.contain || "").includes(a));
}
function qO(e) {
  let l = Wu(e);
  for (; wi(l) && !Ga(l); ) {
    if (Tf(l))
      return l;
    if (so(l))
      return null;
    l = Wu(l);
  }
  return null;
}
function Pf() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const AO = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Ga(e) {
  return AO.has(ha(e));
}
function gi(e) {
  return It(e).getComputedStyle(e);
}
function co(e) {
  return hi(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Wu(e) {
  if (ha(e) === "html")
    return e;
  const l = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Vd(e) && e.host || // Fallback.
    Si(e)
  );
  return Vd(l) ? l.host : l;
}
function mv(e) {
  const l = Wu(e);
  return Ga(l) ? e.ownerDocument ? e.ownerDocument.body : e.body : wi(l) && Ss(l) ? l : mv(l);
}
function os(e, l, i) {
  var a;
  l === void 0 && (l = []), i === void 0 && (i = !0);
  const s = mv(e), o = s === ((a = e.ownerDocument) == null ? void 0 : a.body), m = It(s);
  if (o) {
    const d = Em(m);
    return l.concat(m, m.visualViewport || [], Ss(s) ? s : [], d && i ? os(d) : []);
  }
  return l.concat(s, os(s, [], i));
}
function Em(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function fv(e) {
  const l = gi(e);
  let i = parseFloat(l.width) || 0, a = parseFloat(l.height) || 0;
  const s = wi(e), o = s ? e.offsetWidth : i, m = s ? e.offsetHeight : a, d = Pc(i) !== o || Pc(a) !== m;
  return d && (i = o, a = m), {
    width: i,
    height: a,
    $: d
  };
}
function qf(e) {
  return hi(e) ? e : e.contextElement;
}
function Ma(e) {
  const l = qf(e);
  if (!wi(l))
    return bi(1);
  const i = l.getBoundingClientRect(), {
    width: a,
    height: s,
    $: o
  } = fv(l);
  let m = (o ? Pc(i.width) : i.width) / a, d = (o ? Pc(i.height) : i.height) / s;
  return (!m || !Number.isFinite(m)) && (m = 1), (!d || !Number.isFinite(d)) && (d = 1), {
    x: m,
    y: d
  };
}
const RO = /* @__PURE__ */ bi(0);
function dv(e) {
  const l = It(e);
  return !Pf() || !l.visualViewport ? RO : {
    x: l.visualViewport.offsetLeft,
    y: l.visualViewport.offsetTop
  };
}
function EO(e, l, i) {
  return l === void 0 && (l = !1), !i || l && i !== It(e) ? !1 : l;
}
function ca(e, l, i, a) {
  l === void 0 && (l = !1), i === void 0 && (i = !1);
  const s = e.getBoundingClientRect(), o = qf(e);
  let m = bi(1);
  l && (a ? hi(a) && (m = Ma(a)) : m = Ma(e));
  const d = EO(o, i, a) ? dv(o) : bi(0);
  let h = (s.left + d.x) / m.x, x = (s.top + d.y) / m.y, y = s.width / m.x, I = s.height / m.y;
  if (o) {
    const q = It(o), A = a && hi(a) ? It(a) : a;
    let R = q, V = Em(R);
    for (; V && a && A !== R; ) {
      const U = Ma(V), z = V.getBoundingClientRect(), X = gi(V), B = z.left + (V.clientLeft + parseFloat(X.paddingLeft)) * U.x, K = z.top + (V.clientTop + parseFloat(X.paddingTop)) * U.y;
      h *= U.x, x *= U.y, y *= U.x, I *= U.y, h += B, x += K, R = It(V), V = Em(R);
    }
  }
  return Ac({
    width: y,
    height: I,
    x: h,
    y: x
  });
}
function oo(e, l) {
  const i = co(e).scrollLeft;
  return l ? l.left + i : ca(Si(e)).left + i;
}
function pv(e, l) {
  const i = e.getBoundingClientRect(), a = i.left + l.scrollLeft - oo(e, i), s = i.top + l.scrollTop;
  return {
    x: a,
    y: s
  };
}
function _O(e) {
  let {
    elements: l,
    rect: i,
    offsetParent: a,
    strategy: s
  } = e;
  const o = s === "fixed", m = Si(a), d = l ? so(l.floating) : !1;
  if (a === m || d && o)
    return i;
  let h = {
    scrollLeft: 0,
    scrollTop: 0
  }, x = bi(1);
  const y = bi(0), I = wi(a);
  if ((I || !I && !o) && ((ha(a) !== "body" || Ss(m)) && (h = co(a)), wi(a))) {
    const A = ca(a);
    x = Ma(a), y.x = A.x + a.clientLeft, y.y = A.y + a.clientTop;
  }
  const q = m && !I && !o ? pv(m, h) : bi(0);
  return {
    width: i.width * x.x,
    height: i.height * x.y,
    x: i.x * x.x - h.scrollLeft * x.x + y.x + q.x,
    y: i.y * x.y - h.scrollTop * x.y + y.y + q.y
  };
}
function NO(e) {
  return Array.from(e.getClientRects());
}
function FO(e) {
  const l = Si(e), i = co(e), a = e.ownerDocument.body, s = xt(l.scrollWidth, l.clientWidth, a.scrollWidth, a.clientWidth), o = xt(l.scrollHeight, l.clientHeight, a.scrollHeight, a.clientHeight);
  let m = -i.scrollLeft + oo(e);
  const d = -i.scrollTop;
  return gi(a).direction === "rtl" && (m += xt(l.clientWidth, a.clientWidth) - s), {
    width: s,
    height: o,
    x: m,
    y: d
  };
}
const Bd = 25;
function MO(e, l) {
  const i = It(e), a = Si(e), s = i.visualViewport;
  let o = a.clientWidth, m = a.clientHeight, d = 0, h = 0;
  if (s) {
    o = s.width, m = s.height;
    const y = Pf();
    (!y || y && l === "fixed") && (d = s.offsetLeft, h = s.offsetTop);
  }
  const x = oo(a);
  if (x <= 0) {
    const y = a.ownerDocument, I = y.body, q = getComputedStyle(I), A = y.compatMode === "CSS1Compat" && parseFloat(q.marginLeft) + parseFloat(q.marginRight) || 0, R = Math.abs(a.clientWidth - I.clientWidth - A);
    R <= Bd && (o -= R);
  } else x <= Bd && (o += x);
  return {
    width: o,
    height: m,
    x: d,
    y: h
  };
}
const kO = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function VO(e, l) {
  const i = ca(e, !0, l === "fixed"), a = i.top + e.clientTop, s = i.left + e.clientLeft, o = wi(e) ? Ma(e) : bi(1), m = e.clientWidth * o.x, d = e.clientHeight * o.y, h = s * o.x, x = a * o.y;
  return {
    width: m,
    height: d,
    x: h,
    y: x
  };
}
function Zd(e, l, i) {
  let a;
  if (l === "viewport")
    a = MO(e, i);
  else if (l === "document")
    a = FO(Si(e));
  else if (hi(l))
    a = VO(l, i);
  else {
    const s = dv(e);
    a = {
      x: l.x - s.x,
      y: l.y - s.y,
      width: l.width,
      height: l.height
    };
  }
  return Ac(a);
}
function hv(e, l) {
  const i = Wu(e);
  return i === l || !hi(i) || Ga(i) ? !1 : gi(i).position === "fixed" || hv(i, l);
}
function BO(e, l) {
  const i = l.get(e);
  if (i)
    return i;
  let a = os(e, [], !1).filter((d) => hi(d) && ha(d) !== "body"), s = null;
  const o = gi(e).position === "fixed";
  let m = o ? Wu(e) : e;
  for (; hi(m) && !Ga(m); ) {
    const d = gi(m), h = Tf(m);
    !h && d.position === "fixed" && (s = null), (o ? !h && !s : !h && d.position === "static" && !!s && kO.has(s.position) || Ss(m) && !h && hv(e, m)) ? a = a.filter((y) => y !== m) : s = d, m = Wu(m);
  }
  return l.set(e, a), a;
}
function ZO(e) {
  let {
    element: l,
    boundary: i,
    rootBoundary: a,
    strategy: s
  } = e;
  const m = [...i === "clippingAncestors" ? so(l) ? [] : BO(l, this._c) : [].concat(i), a], d = m[0], h = m.reduce((x, y) => {
    const I = Zd(l, y, s);
    return x.top = xt(I.top, x.top), x.right = $u(I.right, x.right), x.bottom = $u(I.bottom, x.bottom), x.left = xt(I.left, x.left), x;
  }, Zd(l, d, s));
  return {
    width: h.right - h.left,
    height: h.bottom - h.top,
    x: h.left,
    y: h.top
  };
}
function UO(e) {
  const {
    width: l,
    height: i
  } = fv(e);
  return {
    width: l,
    height: i
  };
}
function KO(e, l, i) {
  const a = wi(l), s = Si(l), o = i === "fixed", m = ca(e, !0, o, l);
  let d = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const h = bi(0);
  function x() {
    h.x = oo(s);
  }
  if (a || !a && !o)
    if ((ha(l) !== "body" || Ss(s)) && (d = co(l)), a) {
      const A = ca(l, !0, o, l);
      h.x = A.x + l.clientLeft, h.y = A.y + l.clientTop;
    } else s && x();
  o && !a && s && x();
  const y = s && !a && !o ? pv(s, d) : bi(0), I = m.left + d.scrollLeft - h.x - y.x, q = m.top + d.scrollTop - h.y - y.y;
  return {
    x: I,
    y: q,
    width: m.width,
    height: m.height
  };
}
function Fo(e) {
  return gi(e).position === "static";
}
function Ud(e, l) {
  if (!wi(e) || gi(e).position === "fixed")
    return null;
  if (l)
    return l(e);
  let i = e.offsetParent;
  return Si(e) === i && (i = i.ownerDocument.body), i;
}
function gv(e, l) {
  const i = It(e);
  if (so(e))
    return i;
  if (!wi(e)) {
    let s = Wu(e);
    for (; s && !Ga(s); ) {
      if (hi(s) && !Fo(s))
        return s;
      s = Wu(s);
    }
    return i;
  }
  let a = Ud(e, l);
  for (; a && wO(a) && Fo(a); )
    a = Ud(a, l);
  return a && Ga(a) && Fo(a) && !Tf(a) ? i : a || qO(e) || i;
}
const GO = async function(e) {
  const l = this.getOffsetParent || gv, i = this.getDimensions, a = await i(e.floating);
  return {
    reference: KO(e.reference, await l(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: a.width,
      height: a.height
    }
  };
};
function zO(e) {
  return gi(e).direction === "rtl";
}
const jO = {
  convertOffsetParentRelativeRectToViewportRelativeRect: _O,
  getDocumentElement: Si,
  getClippingRect: ZO,
  getOffsetParent: gv,
  getElementRects: GO,
  getClientRects: NO,
  getDimensions: UO,
  getScale: Ma,
  isElement: hi,
  isRTL: zO
};
function vv(e, l) {
  return e.x === l.x && e.y === l.y && e.width === l.width && e.height === l.height;
}
function HO(e, l) {
  let i = null, a;
  const s = Si(e);
  function o() {
    var d;
    clearTimeout(a), (d = i) == null || d.disconnect(), i = null;
  }
  function m(d, h) {
    d === void 0 && (d = !1), h === void 0 && (h = 1), o();
    const x = e.getBoundingClientRect(), {
      left: y,
      top: I,
      width: q,
      height: A
    } = x;
    if (d || l(), !q || !A)
      return;
    const R = js(I), V = js(s.clientWidth - (y + q)), U = js(s.clientHeight - (I + A)), z = js(y), B = {
      rootMargin: -R + "px " + -V + "px " + -U + "px " + -z + "px",
      threshold: xt(0, $u(1, h)) || 1
    };
    let K = !0;
    function W(se) {
      const te = se[0].intersectionRatio;
      if (te !== h) {
        if (!K)
          return m();
        te ? m(!1, te) : a = setTimeout(() => {
          m(!1, 1e-7);
        }, 1e3);
      }
      te === 1 && !vv(x, e.getBoundingClientRect()) && m(), K = !1;
    }
    try {
      i = new IntersectionObserver(W, {
        ...B,
        // Handle <iframe>s
        root: s.ownerDocument
      });
    } catch {
      i = new IntersectionObserver(W, B);
    }
    i.observe(e);
  }
  return m(!0), o;
}
function $O(e, l, i, a) {
  a === void 0 && (a = {});
  const {
    ancestorScroll: s = !0,
    ancestorResize: o = !0,
    elementResize: m = typeof ResizeObserver == "function",
    layoutShift: d = typeof IntersectionObserver == "function",
    animationFrame: h = !1
  } = a, x = qf(e), y = s || o ? [...x ? os(x) : [], ...os(l)] : [];
  y.forEach((z) => {
    s && z.addEventListener("scroll", i, {
      passive: !0
    }), o && z.addEventListener("resize", i);
  });
  const I = x && d ? HO(x, i) : null;
  let q = -1, A = null;
  m && (A = new ResizeObserver((z) => {
    let [X] = z;
    X && X.target === x && A && (A.unobserve(l), cancelAnimationFrame(q), q = requestAnimationFrame(() => {
      var B;
      (B = A) == null || B.observe(l);
    })), i();
  }), x && !h && A.observe(x), A.observe(l));
  let R, V = h ? ca(e) : null;
  h && U();
  function U() {
    const z = ca(e);
    V && !vv(V, z) && i(), V = z, R = requestAnimationFrame(U);
  }
  return i(), () => {
    var z;
    y.forEach((X) => {
      s && X.removeEventListener("scroll", i), o && X.removeEventListener("resize", i);
    }), I?.(), (z = A) == null || z.disconnect(), A = null, h && cancelAnimationFrame(R);
  };
}
const WO = yO, YO = IO, Kd = gO, XO = DO, QO = vO, JO = hO, eb = LO, nb = (e, l, i) => {
  const a = /* @__PURE__ */ new Map(), s = {
    platform: jO,
    ...i
  }, o = {
    ...s.platform,
    _c: a
  };
  return pO(e, l, {
    ...s,
    platform: o
  });
};
function lb(e) {
  return e != null && typeof e == "object" && "$el" in e;
}
function _m(e) {
  if (lb(e)) {
    const l = e.$el;
    return Cf(l) && ha(l) === "#comment" ? null : l;
  }
  return e;
}
function Sa(e) {
  return typeof e == "function" ? e() : le(e);
}
function tb(e) {
  return {
    name: "arrow",
    options: e,
    fn(l) {
      const i = _m(Sa(e.element));
      return i == null ? {} : JO({
        element: i,
        padding: e.padding
      }).fn(l);
    }
  };
}
function xv(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Gd(e, l) {
  const i = xv(e);
  return Math.round(l * i) / i;
}
function ib(e, l, i) {
  i === void 0 && (i = {});
  const a = i.whileElementsMounted, s = Re(() => {
    var te;
    return (te = Sa(i.open)) != null ? te : !0;
  }), o = Re(() => Sa(i.middleware)), m = Re(() => {
    var te;
    return (te = Sa(i.placement)) != null ? te : "bottom";
  }), d = Re(() => {
    var te;
    return (te = Sa(i.strategy)) != null ? te : "absolute";
  }), h = Re(() => {
    var te;
    return (te = Sa(i.transform)) != null ? te : !0;
  }), x = Re(() => _m(e.value)), y = Re(() => _m(l.value)), I = Fe(0), q = Fe(0), A = Fe(d.value), R = Fe(m.value), V = Fl({}), U = Fe(!1), z = Re(() => {
    const te = {
      position: A.value,
      left: "0",
      top: "0"
    };
    if (!y.value)
      return te;
    const me = Gd(y.value, I.value), M = Gd(y.value, q.value);
    return h.value ? {
      ...te,
      transform: "translate(" + me + "px, " + M + "px)",
      ...xv(y.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: A.value,
      left: me + "px",
      top: M + "px"
    };
  });
  let X;
  function B() {
    if (x.value == null || y.value == null)
      return;
    const te = s.value;
    nb(x.value, y.value, {
      middleware: o.value,
      placement: m.value,
      strategy: d.value
    }).then((me) => {
      I.value = me.x, q.value = me.y, A.value = me.strategy, R.value = me.placement, V.value = me.middlewareData, U.value = te !== !1;
    });
  }
  function K() {
    typeof X == "function" && (X(), X = void 0);
  }
  function W() {
    if (K(), a === void 0) {
      B();
      return;
    }
    if (x.value != null && y.value != null) {
      X = a(x.value, y.value, B);
      return;
    }
  }
  function se() {
    s.value || (U.value = !1);
  }
  return Sn([o, m, d, s], B, {
    flush: "sync"
  }), Sn([x, y], W, {
    flush: "sync"
  }), Sn(s, se, {
    flush: "sync"
  }), $i() && ma(K), {
    x: Nu(I),
    y: Nu(q),
    strategy: Nu(A),
    placement: Nu(R),
    middlewareData: Nu(V),
    isPositioned: Nu(U),
    floatingStyles: z,
    update: B
  };
}
const ub = {
  side: "bottom",
  sideOffset: 0,
  sideFlip: !0,
  align: "center",
  alignOffset: 0,
  alignFlip: !0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [_C, ab] = vi("PopperContent");
var rb = /* @__PURE__ */ dn({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ bh({
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ...ub }),
  emits: ["placed"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = sv(), { forwardRef: o, currentElement: m } = Tt(), d = Fe(), h = Fe(), { width: x, height: y } = D0(h), I = Re(() => i.side + (i.align !== "center" ? `-${i.align}` : "")), q = Re(() => typeof i.collisionPadding == "number" ? i.collisionPadding : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...i.collisionPadding
    }), A = Re(() => Array.isArray(i.collisionBoundary) ? i.collisionBoundary : [i.collisionBoundary]), R = Re(() => ({
      padding: q.value,
      boundary: A.value.filter(nO),
      altBoundary: A.value.length > 0
    })), V = Re(() => ({
      mainAxis: i.sideFlip,
      crossAxis: i.alignFlip
    })), U = jD(() => [
      WO({
        mainAxis: i.sideOffset + y.value,
        alignmentAxis: i.alignOffset
      }),
      i.prioritizePosition && i.avoidCollisions && Kd({
        ...R.value,
        ...V.value
      }),
      i.avoidCollisions && YO({
        mainAxis: !0,
        crossAxis: !!i.prioritizePosition,
        limiter: i.sticky === "partial" ? eb() : void 0,
        ...R.value
      }),
      !i.prioritizePosition && i.avoidCollisions && Kd({
        ...R.value,
        ...V.value
      }),
      XO({
        ...R.value,
        apply: ({ elements: ae, rects: ve, availableWidth: ye, availableHeight: Se }) => {
          const { width: ge, height: oe } = ve.reference, de = ae.floating.style;
          de.setProperty("--reka-popper-available-width", `${ye}px`), de.setProperty("--reka-popper-available-height", `${Se}px`), de.setProperty("--reka-popper-anchor-width", `${ge}px`), de.setProperty("--reka-popper-anchor-height", `${oe}px`);
        }
      }),
      h.value && tb({
        element: h.value,
        padding: i.arrowPadding
      }),
      lO({
        arrowWidth: x.value,
        arrowHeight: y.value
      }),
      i.hideWhenDetached && QO({
        strategy: "referenceHidden",
        ...R.value
      })
    ]), z = Re(() => i.reference ?? s.anchor.value), { floatingStyles: X, placement: B, isPositioned: K, middlewareData: W } = ib(z, d, {
      strategy: i.positionStrategy,
      placement: I,
      whileElementsMounted: (...ae) => $O(...ae, {
        layoutShift: !i.disableUpdateOnLayoutShift,
        animationFrame: i.updatePositionStrategy === "always"
      }),
      middleware: U
    }), se = Re(() => qm(B.value)[0]), te = Re(() => qm(B.value)[1]);
    of(() => {
      K.value && a("placed");
    });
    const me = Re(() => W.value.arrow?.centerOffset !== 0), M = Fe("");
    Ml(() => {
      m.value && (M.value = window.getComputedStyle(m.value).zIndex);
    });
    const ce = Re(() => W.value.arrow?.x ?? 0), Ie = Re(() => W.value.arrow?.y ?? 0);
    return ab({
      placedSide: se,
      onArrowChange: (ae) => h.value = ae,
      arrowX: ce,
      arrowY: Ie,
      shouldHideArrow: me
    }), (ae, ve) => (We(), Yn("div", {
      ref_key: "floatingRef",
      ref: d,
      "data-reka-popper-content-wrapper": "",
      style: Hi({
        ...le(X),
        transform: le(K) ? le(X).transform : "translate(0, -200%)",
        minWidth: "max-content",
        zIndex: M.value,
        "--reka-popper-transform-origin": [le(W).transformOrigin?.x, le(W).transformOrigin?.y].join(" "),
        ...le(W).hide?.referenceHidden && {
          visibility: "hidden",
          pointerEvents: "none"
        }
      })
    }, [je(le(al), pl({ ref: le(o) }, ae.$attrs, {
      "as-child": i.asChild,
      as: ae.as,
      "data-side": se.value,
      "data-align": te.value,
      style: { animation: le(K) ? void 0 : "none" }
    }), {
      default: ln(() => [qn(ae.$slots, "default")]),
      _: 3
    }, 16, [
      "as-child",
      "as",
      "data-side",
      "data-align",
      "style"
    ])], 4));
  }
}), sb = rb, cb = /* @__PURE__ */ dn({
  __name: "ComboboxAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { forwardRef: l } = Tt();
    return (i, a) => (We(), vn(le(eO), {
      "as-child": "",
      reference: i.reference
    }, {
      default: ln(() => [je(le(al), pl({
        ref: le(l),
        "as-child": i.asChild,
        as: i.as
      }, i.$attrs), {
        default: ln(() => [qn(i.$slots, "default")]),
        _: 3
      }, 16, ["as-child", "as"])]),
      _: 3
    }, 8, ["reference"]));
  }
}), ob = cb;
function mb(e, l, i) {
  return e === void 0 ? !1 : Array.isArray(e) ? e.some((a) => Xr(a, l, i)) : Xr(e, l, i);
}
function Xr(e, l, i) {
  return e === void 0 || l === void 0 ? !1 : typeof e == "string" ? e === l : typeof i == "function" ? i(e, l) : typeof i == "string" ? e?.[i] === l?.[i] : Cm(e, l);
}
const [mo, fb] = vi("ListboxRoot");
var db = /* @__PURE__ */ dn({
  __name: "ListboxRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    selectionBehavior: {
      type: String,
      required: !1,
      default: "toggle"
    },
    highlightOnHover: {
      type: Boolean,
      required: !1
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "entryFocus",
    "leave"
  ],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, { multiple: o, highlightOnHover: m, orientation: d, disabled: h, selectionBehavior: x, dir: y } = St(a), { getItems: I } = Qa({ isProvider: !0 }), { handleTypeaheadSearch: q } = tv(), { primitiveElement: A, currentElement: R } = Hu(), V = I0(), U = ws(y), z = f0(R), X = Fe(), B = Fe(!1), K = Fe(!0), W = ju(a, "modelValue", s, {
      defaultValue: a.defaultValue ?? (o.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    });
    function se(k) {
      if (B.value = !0, a.multiple) {
        const _ = Array.isArray(W.value) ? [...W.value] : [], Z = _.findIndex((ie) => Xr(ie, k, a.by));
        a.selectionBehavior === "toggle" ? (Z === -1 ? _.push(k) : _.splice(Z, 1), W.value = _) : (W.value = [k], X.value = k);
      } else a.selectionBehavior === "toggle" && Xr(W.value, k, a.by) ? W.value = void 0 : W.value = k;
      setTimeout(() => {
        B.value = !1;
      }, 1);
    }
    const te = Fe(null), me = Fe(null), M = Fe(!1), ce = Fe(!1), Ie = Yr(), ae = Yr(), ve = Yr();
    function ye() {
      return I().map((k) => k.ref).filter((k) => k.dataset.disabled !== "");
    }
    function Se(k, _ = !0) {
      if (!k) return;
      te.value = k, K.value && te.value.focus(), _ && te.value.scrollIntoView({ block: "nearest" });
      const Z = I().find((ie) => ie.ref === k);
      s("highlight", Z);
    }
    function ge(k) {
      if (M.value) ve.trigger(k);
      else {
        const _ = I().find((Z) => Xr(Z.value, k, a.by));
        _ && (te.value = _.ref, Se(_.ref));
      }
    }
    function oe(k) {
      te.value && te.value.isConnected && (k.preventDefault(), k.stopPropagation(), ce.value || te.value.click());
    }
    function de(k) {
      if (K.value) {
        if (B.value = !0, M.value) ae.trigger(k);
        else {
          const _ = k.altKey || k.ctrlKey || k.metaKey;
          if (_ && k.key === "a" && o.value) {
            const Z = I(), ie = Z.map((Qe) => Qe.value);
            W.value = [...ie], k.preventDefault(), Se(Z[Z.length - 1].ref);
          } else if (!_) {
            const Z = q(k.key, I());
            Z && Se(Z);
          }
        }
        setTimeout(() => {
          B.value = !1;
        }, 1);
      }
    }
    function De() {
      ce.value = !0;
    }
    function Ee() {
      il(() => {
        ce.value = !1;
      });
    }
    function Ye() {
      il(() => {
        const k = new KeyboardEvent("keydown", { key: "PageUp" });
        Pn(k);
      });
    }
    function ze(k) {
      const _ = te.value;
      _?.isConnected && (me.value = _), te.value = null, s("leave", k);
    }
    function un(k) {
      const _ = new CustomEvent("listbox.entryFocus", {
        bubbles: !1,
        cancelable: !0
      });
      if (k.currentTarget?.dispatchEvent(_), s("entryFocus", _), !_.defaultPrevented)
        if (me.value) Se(me.value);
        else {
          const Z = ye()?.[0];
          Se(Z);
        }
    }
    function Pn(k) {
      const _ = av(k, d.value, U.value);
      if (!_) return;
      let Z = ye();
      if (te.value) {
        if (_ === "last") Z.reverse();
        else if (_ === "prev" || _ === "next") {
          _ === "prev" && Z.reverse();
          const ie = Z.indexOf(te.value);
          Z = Z.slice(ie + 1);
        }
        xn(k, Z[0]);
      }
      if (Z.length) {
        const ie = !te.value && _ === "prev" ? Z.length - 1 : 0;
        Se(Z[ie]);
      }
      if (M.value) return ae.trigger(k);
    }
    function xn(k, _) {
      if (!(M.value || a.selectionBehavior !== "replace" || !o.value || !Array.isArray(W.value) || (k.altKey || k.ctrlKey || k.metaKey) && !k.shiftKey) && k.shiftKey) {
        const ie = I().filter((j) => j.ref.dataset.disabled !== "");
        let Qe = ie.find((j) => j.ref === _)?.value;
        if (k.key === V.END ? Qe = ie[ie.length - 1].value : k.key === V.HOME && (Qe = ie[0].value), !Qe || !X.value) return;
        const Oe = ac(ie.map((j) => j.value), X.value, Qe);
        W.value = Oe;
      }
    }
    async function tn(k) {
      if (await il(), M.value) Ie.trigger(k);
      else {
        const _ = ye(), Z = _.find((ie) => ie.dataset.state === "checked");
        Z ? Se(Z) : _.length && Se(_[0]);
      }
    }
    return Sn(W, () => {
      B.value || il(() => {
        tn();
      });
    }, {
      immediate: !0,
      deep: !0
    }), l({
      highlightedElement: te,
      highlightItem: ge,
      highlightFirstItem: Ye,
      highlightSelected: tn,
      getItems: I
    }), fb({
      modelValue: W,
      onValueChange: se,
      multiple: o,
      orientation: d,
      dir: U,
      disabled: h,
      highlightOnHover: m,
      highlightedElement: te,
      isVirtual: M,
      virtualFocusHook: Ie,
      virtualKeydownHook: ae,
      virtualHighlightHook: ve,
      by: a.by,
      firstValue: X,
      selectionBehavior: x,
      focusable: K,
      onLeave: ze,
      onEnter: un,
      changeHighlight: Se,
      onKeydownEnter: oe,
      onKeydownNavigation: Pn,
      onKeydownTypeAhead: de,
      onCompositionStart: De,
      onCompositionEnd: Ee,
      highlightFirstItem: Ye
    }), (k, _) => (We(), vn(le(al), {
      ref_key: "primitiveElement",
      ref: A,
      as: k.as,
      "as-child": k.asChild,
      dir: le(U),
      "data-disabled": le(h) ? "" : void 0,
      onPointerleave: ze,
      onFocusout: _[0] || (_[0] = async (Z) => {
        const ie = Z.relatedTarget || Z.target;
        await il(), te.value && le(R) && !le(R).contains(ie) && ze(Z);
      })
    }, {
      default: ln(() => [qn(k.$slots, "default", { modelValue: le(W) }), le(z) && k.name ? (We(), vn(le(W0), {
        key: 0,
        name: k.name,
        value: le(W),
        disabled: le(h),
        required: k.required
      }, null, 8, [
        "name",
        "value",
        "disabled",
        "required"
      ])) : pi("v-if", !0)]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "dir",
      "data-disabled"
    ]));
  }
}), pb = db, hb = /* @__PURE__ */ dn({
  __name: "ListboxContent",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { CollectionSlot: l } = Qa(), i = mo(), a = Qg(!1, 10);
    return (s, o) => (We(), vn(le(l), null, {
      default: ln(() => [je(le(al), {
        role: "listbox",
        as: s.as,
        "as-child": s.asChild,
        tabindex: le(i).focusable.value ? le(i).highlightedElement.value ? "-1" : "0" : void 0,
        "aria-orientation": le(i).orientation.value,
        "aria-multiselectable": !!le(i).multiple.value,
        "data-orientation": le(i).orientation.value,
        onMousedown: o[0] || (o[0] = si((m) => a.value = !0, ["left"])),
        onFocus: o[1] || (o[1] = (m) => {
          le(a) || le(i).onEnter(m);
        }),
        onKeydown: [
          o[2] || (o[2] = mi((m) => {
            le(i).orientation.value === "vertical" && (m.key === "ArrowLeft" || m.key === "ArrowRight") || le(i).orientation.value === "horizontal" && (m.key === "ArrowUp" || m.key === "ArrowDown") || (m.preventDefault(), le(i).focusable.value && le(i).onKeydownNavigation(m));
          }, [
            "down",
            "up",
            "left",
            "right",
            "home",
            "end"
          ])),
          mi(le(i).onKeydownEnter, ["enter"]),
          le(i).onKeydownTypeAhead
        ]
      }, {
        default: ln(() => [qn(s.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "tabindex",
        "aria-orientation",
        "aria-multiselectable",
        "data-orientation",
        "onKeydown"
      ])]),
      _: 3
    }));
  }
}), gb = hb, vb = /* @__PURE__ */ dn({
  __name: "ListboxFilter",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: l }) {
    const i = e, s = ju(i, "modelValue", l, {
      defaultValue: "",
      passive: i.modelValue === void 0
    }), o = mo(), { primitiveElement: m, currentElement: d } = Hu(), h = Re(() => i.disabled || o.disabled.value || !1), x = Fe();
    return mf(() => x.value = o.highlightedElement.value?.id), vl(() => {
      o.focusable.value = !1, setTimeout(() => {
        i.autoFocus && d.value?.focus();
      }, 1);
    }), Dt(() => {
      o.focusable.value = !0;
    }), (y, I) => (We(), vn(le(al), {
      ref_key: "primitiveElement",
      ref: m,
      as: y.as,
      "as-child": y.asChild,
      value: le(s),
      disabled: h.value ? "" : void 0,
      "data-disabled": h.value ? "" : void 0,
      "aria-disabled": h.value ?? void 0,
      "aria-activedescendant": x.value,
      type: "text",
      onKeydown: [mi(si(le(o).onKeydownNavigation, ["prevent"]), [
        "down",
        "up",
        "home",
        "end"
      ]), mi(le(o).onKeydownEnter, ["enter"])],
      onInput: I[0] || (I[0] = (q) => {
        s.value = q.target.value, le(o).highlightFirstItem();
      }),
      onCompositionstart: le(o).onCompositionStart,
      onCompositionend: le(o).onCompositionEnd
    }, {
      default: ln(() => [qn(y.$slots, "default", { modelValue: le(s) })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "value",
      "disabled",
      "data-disabled",
      "aria-disabled",
      "aria-activedescendant",
      "onKeydown",
      "onCompositionstart",
      "onCompositionend"
    ]));
  }
}), xb = vb;
const yb = "listbox.select", [Ib, Lb] = vi("ListboxItem");
var Db = /* @__PURE__ */ dn({
  __name: "ListboxItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: ["select"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = pa(void 0, "reka-listbox-item"), { CollectionItem: o } = Qa(), { forwardRef: m, currentElement: d } = Tt(), h = mo(), x = Re(() => d.value === h.highlightedElement.value), y = Re(() => mb(h.modelValue.value, i.value, h.by)), I = Re(() => h.disabled.value || i.disabled);
    async function q(R) {
      a("select", R), !R?.defaultPrevented && !I.value && R && (h.onValueChange(i.value), h.changeHighlight(d.value));
    }
    function A(R) {
      const V = {
        originalEvent: R,
        value: i.value
      };
      ss(yb, q, V);
    }
    return Lb({ isSelected: y }), (R, V) => (We(), vn(le(o), { value: R.value }, {
      default: ln(() => [ng([x.value, y.value], () => je(le(al), pl({ id: le(s) }, R.$attrs, {
        ref: le(m),
        role: "option",
        tabindex: le(h).focusable.value ? x.value ? "0" : "-1" : -1,
        "aria-selected": y.value,
        as: R.as,
        "as-child": R.asChild,
        disabled: I.value ? "" : void 0,
        "data-disabled": I.value ? "" : void 0,
        "data-highlighted": x.value ? "" : void 0,
        "data-state": y.value ? "checked" : "unchecked",
        onClick: A,
        onKeydown: mi(si(A, ["prevent"]), ["space"]),
        onPointermove: V[0] || (V[0] = (U) => {
          le(h).highlightedElement.value !== le(d) && (le(h).highlightOnHover.value ? le(h).changeHighlight(le(d), !1) : le(h).focusable.value || le(h).changeHighlight(le(d), !1));
        })
      }), {
        default: ln(() => [qn(R.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "tabindex",
        "aria-selected",
        "as",
        "as-child",
        "disabled",
        "data-disabled",
        "data-highlighted",
        "data-state",
        "onKeydown"
      ]), V, 1)]),
      _: 3
    }, 8, ["value"]));
  }
}), Ob = Db, bb = /* @__PURE__ */ dn({
  __name: "ListboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const l = e;
    Tt();
    const i = Ib();
    return (a, s) => le(i).isSelected.value ? (We(), vn(le(al), pl({
      key: 0,
      "aria-hidden": "true"
    }, l), {
      default: ln(() => [qn(a.$slots, "default")]),
      _: 3
    }, 16)) : pi("v-if", !0);
  }
}), wb = bb;
const [ga, Sb] = vi("ComboboxRoot");
var Cb = /* @__PURE__ */ dn({
  __name: "ComboboxRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    resetSearchTermOnBlur: {
      type: Boolean,
      required: !1,
      default: !0
    },
    resetSearchTermOnSelect: {
      type: Boolean,
      required: !1,
      default: !0
    },
    openOnFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    openOnClick: {
      type: Boolean,
      required: !1,
      default: !1
    },
    ignoreFilter: {
      type: Boolean,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    highlightOnHover: {
      type: Boolean,
      required: !1
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "update:open"
  ],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, { primitiveElement: o, currentElement: m } = Hu(), { multiple: d, disabled: h, ignoreFilter: x, resetSearchTermOnSelect: y, openOnFocus: I, openOnClick: q, dir: A } = St(a), R = ws(A), V = ju(a, "modelValue", s, {
      defaultValue: a.defaultValue ?? (d.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    }), U = ju(a, "open", s, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    });
    async function z(ye) {
      U.value = ye, Ie.value = "", ye ? (await il(), o.value?.highlightSelected(), B.value = !0) : B.value = !1, W.value?.focus(), setTimeout(() => {
        !ye && a.resetSearchTermOnBlur && X.trigger();
      }, 1);
    }
    const X = Yr(), B = Fe(!1), K = Fe(!1), W = Fe(), se = Fe(), te = Re(() => o.value?.highlightedElement ?? void 0), me = Fe(/* @__PURE__ */ new Map()), M = Fe(/* @__PURE__ */ new Map()), { contains: ce } = m0({ sensitivity: "base" }), Ie = Fe(""), ae = Re((ye) => {
      if (!Ie.value || a.ignoreFilter || K.value) return {
        count: me.value.size,
        items: ye?.items ?? /* @__PURE__ */ new Map(),
        groups: ye?.groups ?? new Set(M.value.keys())
      };
      let Se = 0;
      const ge = /* @__PURE__ */ new Map(), oe = /* @__PURE__ */ new Set();
      for (const [de, De] of me.value) {
        const Ee = ce(De, Ie.value);
        ge.set(de, Ee ? 1 : 0), Ee && Se++;
      }
      for (const [de, De] of M.value) for (const Ee of De) if (ge.get(Ee) > 0) {
        oe.add(de);
        break;
      }
      return {
        count: Se,
        items: ge,
        groups: oe
      };
    }), ve = Xn();
    return vl(() => {
      ve?.exposed && (ve.exposed.highlightItem = o.value?.highlightItem, ve.exposed.highlightFirstItem = o.value?.highlightFirstItem, ve.exposed.highlightSelected = o.value?.highlightSelected);
    }), l({
      filtered: ae,
      highlightedElement: te,
      highlightItem: o.value?.highlightItem,
      highlightFirstItem: o.value?.highlightFirstItem,
      highlightSelected: o.value?.highlightSelected
    }), Sb({
      modelValue: V,
      multiple: d,
      disabled: h,
      open: U,
      onOpenChange: z,
      contentId: "",
      isUserInputted: B,
      isVirtual: K,
      inputElement: W,
      highlightedElement: te,
      onInputElementChange: (ye) => W.value = ye,
      triggerElement: se,
      onTriggerElementChange: (ye) => se.value = ye,
      parentElement: m,
      resetSearchTermOnSelect: y,
      onResetSearchTerm: X.on,
      allItems: me,
      allGroups: M,
      filterSearch: Ie,
      filterState: ae,
      ignoreFilter: x,
      openOnFocus: I,
      openOnClick: q
    }), (ye, Se) => (We(), vn(le(Q0), null, {
      default: ln(() => [je(le(pb), pl({
        ref_key: "primitiveElement",
        ref: o
      }, ye.$attrs, {
        modelValue: le(V),
        "onUpdate:modelValue": Se[0] || (Se[0] = (ge) => Vn(V) ? V.value = ge : null),
        style: { pointerEvents: le(U) ? "auto" : void 0 },
        as: ye.as,
        "as-child": ye.asChild,
        dir: le(R),
        multiple: le(d),
        name: ye.name,
        required: ye.required,
        disabled: le(h),
        "highlight-on-hover": !0,
        by: a.by,
        onHighlight: Se[1] || (Se[1] = (ge) => s("highlight", ge))
      }), {
        default: ln(() => [qn(ye.$slots, "default", {
          open: le(U),
          modelValue: le(V)
        })]),
        _: 3
      }, 16, [
        "modelValue",
        "style",
        "as",
        "as-child",
        "dir",
        "multiple",
        "name",
        "required",
        "disabled",
        "by"
      ])]),
      _: 3
    }));
  }
}), Tb = Cb;
const [NC, Pb] = vi("ComboboxContent");
var qb = /* @__PURE__ */ dn({
  __name: "ComboboxContentImpl",
  props: {
    position: {
      type: String,
      required: !1,
      default: "inline"
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: l }) {
    const i = e, a = l, { position: s } = St(i), o = ga(), { forwardRef: m, currentElement: d } = Tt();
    s0(i.bodyLock), x0(o.parentElement);
    const h = Re(() => i.position === "popper" ? i : {}), x = nv(h.value), y = {
      boxSizing: "border-box",
      "--reka-combobox-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-combobox-content-available-width": "var(--reka-popper-available-width)",
      "--reka-combobox-content-available-height": "var(--reka-popper-available-height)",
      "--reka-combobox-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-combobox-trigger-height": "var(--reka-popper-anchor-height)"
    };
    Pb({ position: s });
    const I = Fe(!1);
    return vl(() => {
      o.inputElement.value && (I.value = d.value.contains(o.inputElement.value), I.value && o.inputElement.value.focus());
    }), Dt(() => {
      I.value && o.triggerElement.value?.focus();
    }), (q, A) => (We(), vn(le(gb), { "as-child": "" }, {
      default: ln(() => [je(le(_0), {
        "as-child": "",
        "disable-outside-pointer-events": q.disableOutsidePointerEvents,
        onDismiss: A[0] || (A[0] = (R) => le(o).onOpenChange(!1)),
        onFocusOutside: A[1] || (A[1] = (R) => {
          le(o).parentElement.value?.contains(R.target) && R.preventDefault(), a("focusOutside", R);
        }),
        onInteractOutside: A[2] || (A[2] = (R) => a("interactOutside", R)),
        onEscapeKeyDown: A[3] || (A[3] = (R) => a("escapeKeyDown", R)),
        onPointerDownOutside: A[4] || (A[4] = (R) => {
          le(o).parentElement.value?.contains(R.target) && R.preventDefault(), a("pointerDownOutside", R);
        })
      }, {
        default: ln(() => [(We(), vn(ys(le(s) === "popper" ? le(sb) : le(al)), pl({
          ...q.$attrs,
          ...le(x)
        }, {
          id: le(o).contentId,
          ref: le(m),
          "data-state": le(o).open.value ? "open" : "closed",
          style: {
            display: "flex",
            flexDirection: "column",
            outline: "none",
            ...le(s) === "popper" ? y : {}
          }
        }), {
          default: ln(() => [qn(q.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "data-state",
          "style"
        ]))]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }));
  }
}), Ab = qb, Rb = /* @__PURE__ */ dn({
  __name: "ComboboxContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    position: {
      type: String,
      required: !1
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: l }) {
    const s = d0(e, l), { forwardRef: o } = Tt(), m = ga();
    return m.contentId ||= pa(void 0, "reka-combobox-content"), (d, h) => (We(), vn(le(C0), { present: d.forceMount || le(m).open.value }, {
      default: ln(() => [je(Ab, pl({
        ...le(s),
        ...d.$attrs
      }, { ref: le(o) }), {
        default: ln(() => [qn(d.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"]));
  }
}), Eb = Rb, _b = /* @__PURE__ */ dn({
  __name: "ComboboxEmpty",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const l = e, i = ga(), a = Re(() => i.ignoreFilter.value ? i.allItems.value.size === 0 : i.filterState.value.count === 0);
    return (s, o) => a.value ? (We(), vn(le(al), Vc(pl({ key: 0 }, l)), {
      default: ln(() => [qn(s.$slots, "default", {}, () => [o[0] || (o[0] = Gi("No options"))])]),
      _: 3
    }, 16)) : pi("v-if", !0);
  }
}), Nb = _b;
const [Fb, FC] = vi("ComboboxGroup");
var Mb = /* @__PURE__ */ dn({
  __name: "ComboboxInput",
  props: {
    displayValue: {
      type: Function,
      required: !1
    },
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = ga(), o = mo(), { primitiveElement: m, currentElement: d } = Hu(), h = ju(i, "modelValue", a, { passive: i.modelValue === void 0 });
    vl(() => {
      d.value && s.onInputElementChange(d.value);
    });
    function x(R) {
      s.open.value || s.onOpenChange(!0);
    }
    function y(R) {
      const V = R.target;
      s.open.value ? s.filterSearch.value = V.value : (s.onOpenChange(!0), il(() => {
        V.value && (s.filterSearch.value = V.value, o.highlightFirstItem());
      }));
    }
    function I() {
      s.openOnFocus.value && !s.open.value && s.onOpenChange(!0);
    }
    function q() {
      s.openOnClick.value && !s.open.value && s.onOpenChange(!0);
    }
    function A() {
      const R = s.modelValue.value;
      i.displayValue ? h.value = i.displayValue(R) : !s.multiple.value && R && !Array.isArray(R) && typeof R != "object" ? h.value = R.toString() : h.value = "", il(() => {
        h.value = h.value;
      });
    }
    return s.onResetSearchTerm(() => {
      A();
    }), Sn(s.modelValue, async () => {
      !s.isUserInputted.value && s.resetSearchTermOnSelect.value && A();
    }, {
      immediate: !0,
      deep: !0
    }), Sn(s.filterState, () => {
      !s.isVirtual.value && !s.highlightedElement.value && o.highlightFirstItem();
    }), (R, V) => (We(), vn(le(xb), {
      ref_key: "primitiveElement",
      ref: m,
      modelValue: le(h),
      "onUpdate:modelValue": V[0] || (V[0] = (U) => Vn(h) ? h.value = U : null),
      as: R.as,
      "as-child": R.asChild,
      "auto-focus": R.autoFocus,
      disabled: R.disabled,
      "aria-expanded": le(s).open.value,
      "aria-controls": le(s).contentId,
      "aria-autocomplete": "list",
      role: "combobox",
      autocomplete: "off",
      onClick: q,
      onInput: y,
      onKeydown: mi(si(x, ["prevent"]), ["down", "up"]),
      onFocus: I
    }, {
      default: ln(() => [qn(R.$slots, "default")]),
      _: 3
    }, 8, [
      "modelValue",
      "as",
      "as-child",
      "auto-focus",
      "disabled",
      "aria-expanded",
      "aria-controls",
      "onKeydown"
    ]));
  }
}), kb = Mb, Vb = /* @__PURE__ */ dn({
  __name: "ComboboxItem",
  props: {
    textValue: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = pa(void 0, "reka-combobox-item"), o = ga(), m = Fb(null), { primitiveElement: d, currentElement: h } = Hu();
    if (i.value === "") throw new Error("A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.");
    const x = Re(() => {
      if (o.isVirtual.value || o.ignoreFilter.value || !o.filterSearch.value) return !0;
      {
        const y = o.filterState.value.items.get(s);
        return y === void 0 ? !0 : y > 0;
      }
    });
    return vl(() => {
      o.allItems.value.set(s, i.textValue || h.value.textContent || h.value.innerText);
      const y = m?.id;
      y && (o.allGroups.value.has(y) ? o.allGroups.value.get(y)?.add(s) : o.allGroups.value.set(y, /* @__PURE__ */ new Set([s])));
    }), Dt(() => {
      o.allItems.value.delete(s);
    }), (y, I) => x.value ? (We(), vn(le(Ob), pl({ key: 0 }, i, {
      id: le(s),
      ref_key: "primitiveElement",
      ref: d,
      disabled: le(o).disabled.value || y.disabled,
      onSelect: I[0] || (I[0] = (q) => {
        a("select", q), !q.defaultPrevented && !le(o).multiple.value && !y.disabled && !le(o).disabled.value && (q.preventDefault(), le(o).onOpenChange(!1), le(o).modelValue.value = i.value);
      })
    }), {
      default: ln(() => [qn(y.$slots, "default", {}, () => [Gi(Ul(y.value), 1)])]),
      _: 3
    }, 16, ["id", "disabled"])) : pi("v-if", !0);
  }
}), Bb = Vb, Zb = /* @__PURE__ */ dn({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const l = e;
    return (i, a) => (We(), vn(le(wb), Vc(ff(l)), {
      default: ln(() => [qn(i.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ub = Zb, Kb = /* @__PURE__ */ dn({
  __name: "ComboboxTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const l = e, { forwardRef: i, currentElement: a } = Tt(), s = ga(), o = Re(() => l.disabled || s.disabled.value || !1);
    return vl(() => {
      a.value && s.onTriggerElementChange(a.value);
    }), (m, d) => (We(), vn(le(al), pl(l, {
      ref: le(i),
      type: m.as === "button" ? "button" : void 0,
      tabindex: "-1",
      "aria-label": "Show popup",
      "aria-haspopup": "listbox",
      "aria-expanded": le(s).open.value,
      "aria-controls": le(s).contentId,
      "data-state": le(s).open.value ? "open" : "closed",
      disabled: o.value,
      "data-disabled": o.value ? "" : void 0,
      "aria-disabled": o.value ?? void 0,
      onClick: d[0] || (d[0] = (h) => le(s).onOpenChange(!le(s).open.value))
    }), {
      default: ln(() => [qn(m.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "aria-expanded",
      "aria-controls",
      "data-state",
      "disabled",
      "data-disabled",
      "aria-disabled"
    ]));
  }
}), Gb = Kb;
function yv(e) {
  const l = uo({ nonce: Fe() });
  return Re(() => e?.value || l.nonce?.value);
}
var zb = /* @__PURE__ */ dn({
  __name: "ComboboxViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const l = e, { forwardRef: i } = Tt(), { nonce: a } = St(l), s = yv(a), o = ga();
    return (m, d) => (We(), Yn(Mn, null, [je(le(al), pl({
      ...m.$attrs,
      ...l
    }, {
      ref: le(i),
      "data-reka-combobox-viewport": "",
      role: "presentation",
      style: {
        position: "relative",
        flex: le(o).isVirtual.value ? void 0 : 1,
        overflow: "auto"
      }
    }), {
      default: ln(() => [qn(m.$slots, "default")]),
      _: 3
    }, 16, ["style"]), je(le(al), {
      as: "style",
      nonce: le(s)
    }, {
      default: ln(() => d[0] || (d[0] = [Gi(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-combobox-viewport]::-webkit-scrollbar { display: none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), jb = zb;
function gn(e, l = "Assertion failed!") {
  if (!e)
    throw console.error(l), new Error(l);
}
function Iv(e, l = document) {
  if (!bs) return null;
  if (l instanceof HTMLElement && l?.dataset?.panelGroupId === e) return l;
  const i = l.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return i || null;
}
function fo(e, l = document) {
  if (!bs) return null;
  const i = l.querySelector(`[data-panel-resize-handle-id="${e}"]`);
  return i || null;
}
function Lv(e, l, i = document) {
  return bs ? ms(e, i).findIndex((o) => o.getAttribute("data-panel-resize-handle-id") === l) ?? null : null;
}
function ms(e, l = document) {
  return bs ? Array.from(l.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${e}"]`)) : [];
}
function Hb(e, l, i, a = document) {
  const s = fo(l, a), o = ms(e, a), m = s ? o.indexOf(s) : -1, d = i[m]?.id ?? null, h = i[m + 1]?.id ?? null;
  return [d, h];
}
function Dv(e) {
  return e.type === "keydown";
}
function Ov(e) {
  return e.type.startsWith("mouse");
}
function bv(e) {
  return e.type.startsWith("touch");
}
function po(e) {
  if (Ov(e)) return {
    x: e.clientX,
    y: e.clientY
  };
  if (bv(e)) {
    const l = e.touches[0];
    if (l && l.clientX && l.clientY) return {
      x: l.clientX,
      y: l.clientY
    };
  }
  return {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
  };
}
function wv(e, l) {
  const i = e === "horizontal", { x: a, y: s } = po(l);
  return i ? a : s;
}
function $b(e, l, i, a, s) {
  const o = i === "horizontal", m = fo(l, s);
  gn(m);
  const d = m.getAttribute("data-panel-group-id");
  gn(d);
  const { initialCursorPosition: h } = a, x = wv(i, e), y = Iv(d, s);
  gn(y);
  const I = y.getBoundingClientRect(), q = o ? I.width : I.height;
  return (x - h) / q * 100;
}
function Wb(e, l, i, a, s, o) {
  if (Dv(e)) {
    const m = i === "horizontal";
    let d = 0;
    e.shiftKey ? d = 100 : d = s ?? 10;
    let h = 0;
    switch (e.key) {
      case "ArrowDown":
        h = m ? 0 : d;
        break;
      case "ArrowLeft":
        h = m ? -d : 0;
        break;
      case "ArrowRight":
        h = m ? d : 0;
        break;
      case "ArrowUp":
        h = m ? 0 : -d;
        break;
      case "End":
        h = 100;
        break;
      case "Home":
        h = -100;
        break;
    }
    return h;
  } else
    return a == null ? 0 : $b(e, l, i, a, o);
}
function Yb({ layout: e, panelsArray: l, pivotIndices: i }) {
  let a = 0, s = 100, o = 0, m = 0;
  const d = i[0];
  gn(d != null), l.forEach((I, q) => {
    const { constraints: A } = I, { maxSize: R = 100, minSize: V = 0 } = A;
    q === d ? (a = V, s = R) : (o += V, m += R);
  });
  const h = Math.min(s, 100 - o), x = Math.max(a, 100 - m), y = e[d];
  return {
    valueMax: h,
    valueMin: x,
    valueNow: y
  };
}
function Xb({ panelDataArray: e }) {
  const l = Array.from({ length: e.length }), i = e.map((o) => o.constraints);
  let a = 0, s = 100;
  for (let o = 0; o < e.length; o++) {
    const m = i[o];
    gn(m);
    const { defaultSize: d } = m;
    d != null && (a++, l[o] = d, s -= d);
  }
  for (let o = 0; o < e.length; o++) {
    const m = i[o];
    gn(m);
    const { defaultSize: d } = m;
    if (d != null) continue;
    const h = e.length - a, x = s / h;
    a++, l[o] = x, s -= x;
  }
  return l;
}
function Pr(e, l, i) {
  l.forEach((a, s) => {
    const o = e[s];
    gn(o);
    const { callbacks: m, constraints: d, id: h } = o, { collapsedSize: x = 0, collapsible: y } = d, I = i[h];
    if (I == null || a !== I) {
      i[h] = a;
      const { onCollapse: q, onExpand: A, onResize: R } = m;
      R && R(a, I), y && (q || A) && (A && (I == null || I === x) && a !== x && A(), q && (I == null || I !== x) && a === x && q());
    }
  });
}
function Qb(e, l = 10) {
  let i = null;
  return (...s) => {
    i !== null && clearTimeout(i), i = setTimeout(() => {
      e(...s);
    }, l);
  };
}
const Af = 10;
function fs(e, l, i = Af) {
  e = Number.parseFloat(e.toFixed(i)), l = Number.parseFloat(l.toFixed(i));
  const a = e - l;
  return a === 0 ? 0 : a > 0 ? 1 : -1;
}
function vt(e, l, i) {
  return fs(e, l, i) === 0;
}
function Ta({ panelConstraints: e, panelIndex: l, size: i }) {
  const a = e[l];
  gn(a != null);
  const { collapsedSize: s = 0, collapsible: o, maxSize: m = 100, minSize: d = 0 } = a;
  if (fs(i, d) < 0) if (o) {
    const h = (s + d) / 2;
    fs(i, h) < 0 ? i = s : i = d;
  } else i = d;
  return i = Math.min(m, i), i = Number.parseFloat(i.toFixed(Af)), i;
}
function Hs(e, l) {
  if (e.length !== l.length) return !1;
  for (let i = 0; i < e.length; i++) if (e[i] !== l[i]) return !1;
  return !0;
}
function Br({ delta: e, layout: l, panelConstraints: i, pivotIndices: a, trigger: s }) {
  if (vt(e, 0)) return l;
  const o = [...l], [m, d] = a;
  gn(m != null), gn(d != null);
  let h = 0;
  if (s === "keyboard") {
    {
      const y = e < 0 ? d : m, I = i[y];
      if (gn(I), I.collapsible) {
        const q = l[y];
        gn(q != null);
        const A = i[y];
        gn(A);
        const { collapsedSize: R = 0, minSize: V = 0 } = A;
        if (vt(q, R)) {
          const U = V - q;
          fs(U, Math.abs(e)) > 0 && (e = e < 0 ? 0 - U : U);
        }
      }
    }
    {
      const y = e < 0 ? m : d, I = i[y];
      gn(I);
      const { collapsible: q } = I;
      if (q) {
        const A = l[y];
        gn(A != null);
        const R = i[y];
        gn(R);
        const { collapsedSize: V = 0, minSize: U = 0 } = R;
        if (vt(A, U)) {
          const z = A - V;
          fs(z, Math.abs(e)) > 0 && (e = e < 0 ? 0 - z : z);
        }
      }
    }
  }
  {
    const y = e < 0 ? 1 : -1;
    let I = e < 0 ? d : m, q = 0;
    for (; ; ) {
      const R = l[I];
      gn(R != null);
      const U = Ta({
        panelConstraints: i,
        panelIndex: I,
        size: 100
      }) - R;
      if (q += U, I += y, I < 0 || I >= i.length) break;
    }
    const A = Math.min(Math.abs(e), Math.abs(q));
    e = e < 0 ? 0 - A : A;
  }
  {
    let I = e < 0 ? m : d;
    for (; I >= 0 && I < i.length; ) {
      const q = Math.abs(e) - Math.abs(h), A = l[I];
      gn(A != null);
      const R = A - q, V = Ta({
        panelConstraints: i,
        panelIndex: I,
        size: R
      });
      if (!vt(A, V) && (h += A - V, o[I] = V, h.toPrecision(3).localeCompare(Math.abs(e).toPrecision(3), void 0, { numeric: !0 }) >= 0))
        break;
      e < 0 ? I-- : I++;
    }
  }
  if (vt(h, 0)) return l;
  {
    const y = e < 0 ? d : m, I = l[y];
    gn(I != null);
    const q = I + h, A = Ta({
      panelConstraints: i,
      panelIndex: y,
      size: q
    });
    if (o[y] = A, !vt(A, q)) {
      let R = q - A, U = e < 0 ? d : m;
      for (; U >= 0 && U < i.length; ) {
        const z = o[U];
        gn(z != null);
        const X = z + R, B = Ta({
          panelConstraints: i,
          panelIndex: U,
          size: X
        });
        if (vt(z, B) || (R -= B - z, o[U] = B), vt(R, 0)) break;
        e > 0 ? U-- : U++;
      }
    }
  }
  const x = o.reduce((y, I) => I + y, 0);
  return vt(x, 100) ? o : l;
}
function Sv(e, l, i) {
  const a = Lv(e, l, i);
  return a != null ? [a, a + 1] : [-1, -1];
}
function Jb(e, l, i) {
  return e.x < l.x + l.width && e.x + e.width > l.x && e.y < l.y + l.height && e.y + e.height > l.y;
}
function ew(e, l) {
  if (e === l) throw new Error("Cannot compare node with itself");
  const i = {
    a: Hd(e),
    b: Hd(l)
  };
  let a;
  for (; i.a.at(-1) === i.b.at(-1); )
    e = i.a.pop(), l = i.b.pop(), a = e;
  gn(a);
  const s = {
    a: jd(zd(i.a)),
    b: jd(zd(i.b))
  };
  if (s.a === s.b) {
    const o = a.childNodes, m = {
      a: i.a.at(-1),
      b: i.b.at(-1)
    };
    let d = o.length;
    for (; d--; ) {
      const h = o[d];
      if (h === m.a) return 1;
      if (h === m.b) return -1;
    }
  }
  return Math.sign(s.a - s.b);
}
const nw = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function lw(e) {
  const l = getComputedStyle(Cv(e)).display;
  return l === "flex" || l === "inline-flex";
}
function tw(e) {
  const l = getComputedStyle(e);
  return !!(l.position === "fixed" || l.zIndex !== "auto" && (l.position !== "static" || lw(e)) || +l.opacity < 1 || "transform" in l && l.transform !== "none" || "webkitTransform" in l && l.webkitTransform !== "none" || "mixBlendMode" in l && l.mixBlendMode !== "normal" || "filter" in l && l.filter !== "none" || "webkitFilter" in l && l.webkitFilter !== "none" || "isolation" in l && l.isolation === "isolate" || nw.test(l.willChange) || l.webkitOverflowScrolling === "touch");
}
function zd(e) {
  let l = e.length;
  for (; l--; ) {
    const i = e[l];
    if (gn(i), tw(i)) return i;
  }
  return null;
}
function jd(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function Hd(e) {
  const l = [];
  for (; e; )
    l.push(e), e = Cv(e);
  return l;
}
function Cv(e) {
  return e.parentNode instanceof DocumentFragment && e.parentNode?.host || e.parentNode;
}
const Tv = 1, Pv = 2, qv = 4, Av = 8;
function iw() {
  if (typeof matchMedia == "function") return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
const uw = iw() === "coarse", Yu = [];
let ho = !1;
const Vu = /* @__PURE__ */ new Map(), go = /* @__PURE__ */ new Map(), ds = /* @__PURE__ */ new Set();
function aw(e, l, i, a, s, o) {
  const { ownerDocument: m } = l, d = {
    direction: i,
    element: l,
    hitAreaMargins: a,
    nonce: s,
    setResizeHandlerState: o
  }, h = Vu.get(m) ?? 0;
  return Vu.set(m, h + 1), ds.add(d), Rc(), function() {
    go.delete(e), ds.delete(d);
    const y = Vu.get(m) ?? 1;
    Vu.set(m, y - 1), Rc(), Ev(), y === 1 && Vu.delete(m);
  };
}
function $s(e) {
  const { target: l } = e, { x: i, y: a } = po(e);
  ho = !0, Rf({
    target: l,
    x: i,
    y: a
  }), Rc(), Yu.length > 0 && (Ef("down", e), e.preventDefault());
}
function Pu(e) {
  const { x: l, y: i } = po(e);
  if (!ho) {
    const { target: a } = e;
    Rf({
      target: a,
      x: l,
      y: i
    });
  }
  Ef("move", e), Rv(), Yu.length > 0 && e.preventDefault();
}
function qu(e) {
  const { target: l } = e, { x: i, y: a } = po(e);
  go.clear(), ho = !1, Yu.length > 0 && e.preventDefault(), Ef("up", e), Rf({
    target: l,
    x: i,
    y: a
  }), Rv(), Rc();
}
function Rf({ target: e, x: l, y: i }) {
  Yu.splice(0);
  let a = null;
  e instanceof HTMLElement && (a = e), ds.forEach((s) => {
    const { element: o, hitAreaMargins: m } = s, d = o.getBoundingClientRect(), { bottom: h, left: x, right: y, top: I } = d, q = uw ? m.coarse : m.fine;
    if (l >= x - q && l <= y + q && i >= I - q && i <= h + q) {
      if (a !== null && o !== a && !o.contains(a) && !a.contains(o) && ew(a, o) > 0) {
        let R = a, V = !1;
        for (; R && !R.contains(o); ) {
          if (Jb(R.getBoundingClientRect(), d)) {
            V = !0;
            break;
          }
          R = R.parentElement;
        }
        if (V) return;
      }
      Yu.push(s);
    }
  });
}
function Mo(e, l) {
  go.set(e, l);
}
function Rv() {
  let e = !1, l = !1, i;
  Yu.forEach((s) => {
    const { direction: o, nonce: m } = s;
    o.value === "horizontal" ? e = !0 : l = !0, i = m.value;
  });
  let a = 0;
  go.forEach((s) => {
    a |= s;
  }), e && l ? ko("intersection", a, i) : e ? ko("horizontal", a, i) : l ? ko("vertical", a, i) : Ev();
}
function Rc() {
  Vu.forEach((e, l) => {
    const { body: i } = l;
    i.removeEventListener("contextmenu", qu), i.removeEventListener("mousedown", $s), i.removeEventListener("mouseleave", Pu), i.removeEventListener("mousemove", Pu), i.removeEventListener("touchmove", Pu), i.removeEventListener("touchstart", $s);
  }), window.removeEventListener("mouseup", qu), window.removeEventListener("touchcancel", qu), window.removeEventListener("touchend", qu), ds.size > 0 && (ho ? (Yu.length > 0 && Vu.forEach((e, l) => {
    const { body: i } = l;
    e > 0 && (i.addEventListener("contextmenu", qu), i.addEventListener("mouseleave", Pu), i.addEventListener("mousemove", Pu), i.addEventListener("touchmove", Pu, { passive: !1 }));
  }), window.addEventListener("mouseup", qu), window.addEventListener("touchcancel", qu), window.addEventListener("touchend", qu)) : Vu.forEach((e, l) => {
    const { body: i } = l;
    e > 0 && (i.addEventListener("mousedown", $s), i.addEventListener("mousemove", Pu), i.addEventListener("touchmove", Pu, { passive: !1 }), i.addEventListener("touchstart", $s));
  }));
}
function Ef(e, l) {
  ds.forEach((i) => {
    const { setResizeHandlerState: a } = i, s = Yu.includes(i);
    a(e, s, l);
  });
}
let Nm = null, Bu = null;
function rw(e, l) {
  if (l) {
    const i = (l & Tv) !== 0, a = (l & Pv) !== 0, s = (l & qv) !== 0, o = (l & Av) !== 0;
    if (i) return s ? "se-resize" : o ? "ne-resize" : "e-resize";
    if (a) return s ? "sw-resize" : o ? "nw-resize" : "w-resize";
    if (s) return "s-resize";
    if (o) return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function Ev() {
  Bu !== null && (document.head.removeChild(Bu), Nm = null, Bu = null);
}
function ko(e, l, i) {
  const a = rw(e, l);
  Nm !== a && (Nm = a, Bu === null && (Bu = document.createElement("style"), i && (Bu.nonce = i), document.head.appendChild(Bu)), Bu.innerHTML = `*{cursor: ${a}!important;}`);
}
function sw({ defaultSize: e, dragState: l, layout: i, panelData: a, panelIndex: s, precision: o = 3 }) {
  const m = i[s];
  let d;
  return m == null ? d = e !== void 0 ? e.toPrecision(o) : "1" : a.length === 1 ? d = "1" : d = m.toPrecision(o), {
    flexBasis: 0,
    flexGrow: d,
    flexShrink: 1,
    overflow: "hidden",
    pointerEvents: l !== null ? "none" : void 0
  };
}
function cw({ layout: e, panelConstraints: l }) {
  const i = [...e], a = i.reduce((o, m) => o + m, 0);
  if (i.length !== l.length) throw new Error(`Invalid ${l.length} panel layout: ${i.map((o) => `${o}%`).join(", ")}`);
  if (!vt(a, 100)) {
    console.warn(`WARNING: Invalid layout total size: ${i.map((o) => `${o}%`).join(", ")}. Layout normalization will be applied.`);
    for (let o = 0; o < l.length; o++) {
      const m = i[o];
      gn(m != null);
      const d = 100 / a * m;
      i[o] = d;
    }
  }
  let s = 0;
  for (let o = 0; o < l.length; o++) {
    const m = i[o];
    gn(m != null);
    const d = Ta({
      panelConstraints: l,
      panelIndex: o,
      size: m
    });
    m !== d && (s += m - d, i[o] = d);
  }
  if (!vt(s, 0)) for (let o = 0; o < l.length; o++) {
    const m = i[o];
    gn(m != null);
    const d = m + s, h = Ta({
      panelConstraints: l,
      panelIndex: o,
      size: d
    });
    if (m !== h && (s -= h - m, i[o] = h, vt(s, 0)))
      break;
  }
  return i;
}
function ow({ eagerValuesRef: e, groupId: l, layout: i, panelDataArray: a, panelGroupElement: s, setLayout: o }) {
  Ml((m) => {
    const d = s.value;
    if (!d) return;
    const h = ms(l, d);
    for (let x = 0; x < a.length - 1; x++) {
      const { valueMax: y, valueMin: I, valueNow: q } = Yb({
        layout: i.value,
        panelsArray: a,
        pivotIndices: [x, x + 1]
      }), A = h[x];
      if (A != null) {
        const R = a[x];
        gn(R), A.setAttribute("aria-controls", R.id), A.setAttribute("aria-valuemax", `${Math.round(y)}`), A.setAttribute("aria-valuemin", `${Math.round(I)}`), A.setAttribute("aria-valuenow", q != null ? `${Math.round(q)}` : "");
      }
    }
    m(() => {
      h.forEach((x) => {
        x.removeAttribute("aria-controls"), x.removeAttribute("aria-valuemax"), x.removeAttribute("aria-valuemin"), x.removeAttribute("aria-valuenow");
      });
    });
  }), Ml((m) => {
    const d = s.value;
    if (!d) return;
    const h = e.value;
    gn(h);
    const { panelDataArray: x } = h, y = Iv(l, d);
    gn(y != null, `No group found for id "${l}"`);
    const I = ms(l, d);
    gn(I);
    const q = I.map((A) => {
      const R = A.getAttribute("data-panel-resize-handle-id");
      gn(R);
      const [V, U] = Hb(l, R, x, d);
      if (V == null || U == null) return () => {
      };
      const z = (X) => {
        if (!X.defaultPrevented)
          switch (X.key) {
            case "Enter": {
              X.preventDefault();
              const B = x.findIndex((K) => K.id === V);
              if (B >= 0) {
                const K = x[B];
                gn(K);
                const W = i.value[B], { collapsedSize: se = 0, collapsible: te, minSize: me = 0 } = K.constraints;
                if (W != null && te) {
                  const M = Br({
                    delta: vt(W, se) ? me - se : se - W,
                    layout: i.value,
                    panelConstraints: x.map((ce) => ce.constraints),
                    pivotIndices: Sv(l, R, d),
                    trigger: "keyboard"
                  });
                  i.value !== M && o(M);
                }
              }
              break;
            }
          }
      };
      return A.addEventListener("keydown", z), () => {
        A.removeEventListener("keydown", z);
      };
    });
    m(() => {
      q.forEach((A) => A());
    });
  });
}
function $d(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (l) => localStorage.getItem(l), e.setItem = (l, i) => {
        localStorage.setItem(l, i);
      };
    else throw new TypeError("localStorage not supported in this environment");
  } catch (l) {
    console.error(l), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function _v(e) {
  return `reka:${e}`;
}
function Nv(e) {
  return e.map((l) => {
    const { constraints: i, id: a, idIsFromProps: s, order: o } = l;
    return s ? a : o ? `${o}:${JSON.stringify(i)}` : JSON.stringify(i);
  }).sort((l, i) => l.localeCompare(i)).join(",");
}
function Fv(e, l) {
  try {
    const i = _v(e), a = l.getItem(i);
    if (a) {
      const s = JSON.parse(a);
      if (typeof s == "object" && s != null) return s;
    }
  } catch {
  }
  return null;
}
function mw(e, l, i) {
  const a = Fv(e, i) ?? {}, s = Nv(l);
  return a[s] ?? null;
}
function fw(e, l, i, a, s) {
  const o = _v(e), m = Nv(l), d = Fv(e, s) ?? {};
  d[m] = {
    expandToSizes: Object.fromEntries(i.entries()),
    layout: a
  };
  try {
    s.setItem(o, JSON.stringify(d));
  } catch (h) {
    console.error(h);
  }
}
const dw = 100, Zr = {
  getItem: (e) => ($d(Zr), Zr.getItem(e)),
  setItem: (e, l) => {
    $d(Zr), Zr.setItem(e, l);
  }
}, [Mv, pw] = vi("PanelGroup");
var hw = /* @__PURE__ */ dn({
  __name: "SplitterGroup",
  props: {
    id: {
      type: [String, null],
      required: !1
    },
    autoSaveId: {
      type: [String, null],
      required: !1,
      default: null
    },
    direction: {
      type: String,
      required: !0
    },
    keyboardResizeBy: {
      type: [Number, null],
      required: !1,
      default: 10
    },
    storage: {
      type: Object,
      required: !1,
      default: () => Zr
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["layout"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = {}, { direction: o } = St(i), m = pa(i.id, "reka-splitter-group"), d = ws(), { forwardRef: h, currentElement: x } = Tt(), y = Fe(null), I = Fe([]), q = Fe({}), A = Fe(/* @__PURE__ */ new Map()), R = Fe(0), V = Re(() => ({
      autoSaveId: i.autoSaveId,
      direction: i.direction,
      dragState: y.value,
      id: m,
      keyboardResizeBy: i.keyboardResizeBy,
      storage: i.storage
    })), U = Fe({
      layout: I.value,
      panelDataArray: [],
      panelDataArrayChanged: !1
    }), z = (oe) => I.value = oe;
    ow({
      eagerValuesRef: U,
      groupId: m,
      layout: I,
      panelDataArray: U.value.panelDataArray,
      setLayout: z,
      panelGroupElement: x
    }), Ml(() => {
      const { panelDataArray: oe } = U.value, { autoSaveId: de } = i;
      if (de) {
        if (I.value.length === 0 || I.value.length !== oe.length) return;
        let De = s[de];
        De || (De = Qb(fw, dw), s[de] = De);
        const Ee = [...oe], Ye = new Map(A.value);
        De(de, Ee, Ye, I.value, i.storage);
      }
    });
    function X(oe, de) {
      const { panelDataArray: De } = U.value, Ee = Se(De, oe);
      return sw({
        defaultSize: de,
        dragState: y.value,
        layout: I.value,
        panelData: De,
        panelIndex: Ee
      });
    }
    function B(oe) {
      const { panelDataArray: de } = U.value;
      de.push(oe), de.sort((De, Ee) => {
        const Ye = De.order, ze = Ee.order;
        return Ye == null && ze == null ? 0 : Ye == null ? -1 : ze == null ? 1 : Ye - ze;
      }), U.value.panelDataArrayChanged = !0;
    }
    Sn(() => U.value.panelDataArrayChanged, () => {
      if (U.value.panelDataArrayChanged) {
        U.value.panelDataArrayChanged = !1;
        const { autoSaveId: oe, storage: de } = V.value, { layout: De, panelDataArray: Ee } = U.value;
        let Ye = null;
        if (oe) {
          const un = mw(oe, Ee, de);
          un && (A.value = new Map(Object.entries(un.expandToSizes)), Ye = un.layout);
        }
        Ye === null && (Ye = Xb({ panelDataArray: Ee }));
        const ze = cw({
          layout: Ye,
          panelConstraints: Ee.map((un) => un.constraints)
        });
        zD(De, ze) || (z(ze), U.value.layout = ze, a("layout", ze), Pr(Ee, ze, q.value));
      }
    });
    function K(oe) {
      return function(De) {
        De.preventDefault();
        const Ee = x.value;
        if (!Ee) return () => null;
        const { direction: Ye, dragState: ze, id: un, keyboardResizeBy: Pn } = V.value, { layout: xn, panelDataArray: tn } = U.value, { initialLayout: k } = ze ?? {}, _ = Sv(un, oe, Ee);
        let Z = Wb(De, oe, Ye, ze, Pn, Ee);
        if (Z === 0) return;
        const ie = Ye === "horizontal";
        d.value === "rtl" && ie && (Z = -Z);
        const Qe = tn.map((ue) => ue.constraints), Oe = Br({
          delta: Z,
          layout: k ?? xn,
          panelConstraints: Qe,
          pivotIndices: _,
          trigger: Dv(De) ? "keyboard" : "mouse-or-touch"
        }), j = !Hs(xn, Oe);
        (Ov(De) || bv(De)) && R.value !== Z && (R.value = Z, j ? Mo(oe, 0) : ie ? Mo(oe, Z < 0 ? Tv : Pv) : Mo(oe, Z < 0 ? qv : Av)), j && (z(Oe), U.value.layout = Oe, a("layout", Oe), Pr(tn, Oe, q.value));
      };
    }
    function W(oe, de) {
      const { layout: De, panelDataArray: Ee } = U.value, Ye = Ee.map((k) => k.constraints), { panelSize: ze, pivotIndices: un } = ge(Ee, oe, De);
      gn(ze != null);
      const xn = Se(Ee, oe) === Ee.length - 1 ? ze - de : de - ze, tn = Br({
        delta: xn,
        layout: De,
        panelConstraints: Ye,
        pivotIndices: un,
        trigger: "imperative-api"
      });
      Hs(De, tn) || (z(tn), U.value.layout = tn, a("layout", tn), Pr(Ee, tn, q.value));
    }
    function se(oe, de) {
      const { layout: De, panelDataArray: Ee } = U.value, Ye = Se(Ee, oe);
      Ee[Ye] = oe, U.value.panelDataArrayChanged = !0;
      const { collapsedSize: ze = 0, collapsible: un } = de, { collapsedSize: Pn = 0, collapsible: xn, maxSize: tn = 100, minSize: k = 0 } = oe.constraints, { panelSize: _ } = ge(Ee, oe, De);
      _ !== null && (un && xn && _ === ze ? ze !== Pn && W(oe, Pn) : _ < k ? W(oe, k) : _ > tn && W(oe, tn));
    }
    function te(oe, de) {
      const { direction: De } = V.value, { layout: Ee } = U.value;
      if (!x.value) return;
      const Ye = fo(oe, x.value);
      gn(Ye);
      const ze = wv(De, de);
      y.value = {
        dragHandleId: oe,
        dragHandleRect: Ye.getBoundingClientRect(),
        initialCursorPosition: ze,
        initialLayout: Ee
      };
    }
    function me() {
      y.value = null;
    }
    function M(oe) {
      const { panelDataArray: de } = U.value, De = Se(de, oe);
      De >= 0 && (de.splice(De, 1), delete q.value[oe.id], U.value.panelDataArrayChanged = !0);
    }
    function ce(oe) {
      const { layout: de, panelDataArray: De } = U.value;
      if (oe.constraints.collapsible) {
        const Ee = De.map((Pn) => Pn.constraints), { collapsedSize: Ye = 0, panelSize: ze, pivotIndices: un } = ge(De, oe, de);
        if (gn(ze != null, `Panel size not found for panel "${oe.id}"`), ze !== Ye) {
          A.value.set(oe.id, ze);
          const xn = Se(De, oe) === De.length - 1 ? ze - Ye : Ye - ze, tn = Br({
            delta: xn,
            layout: de,
            panelConstraints: Ee,
            pivotIndices: un,
            trigger: "imperative-api"
          });
          Hs(de, tn) || (z(tn), U.value.layout = tn, a("layout", tn), Pr(De, tn, q.value));
        }
      }
    }
    function Ie(oe) {
      const { layout: de, panelDataArray: De } = U.value;
      if (oe.constraints.collapsible) {
        const Ee = De.map((xn) => xn.constraints), { collapsedSize: Ye = 0, panelSize: ze, minSize: un = 0, pivotIndices: Pn } = ge(De, oe, de);
        if (ze === Ye) {
          const xn = A.value.get(oe.id), tn = xn != null && xn >= un ? xn : un, _ = Se(De, oe) === De.length - 1 ? ze - tn : tn - ze, Z = Br({
            delta: _,
            layout: de,
            panelConstraints: Ee,
            pivotIndices: Pn,
            trigger: "imperative-api"
          });
          Hs(de, Z) || (z(Z), U.value.layout = Z, a("layout", Z), Pr(De, Z, q.value));
        }
      }
    }
    function ae(oe) {
      const { layout: de, panelDataArray: De } = U.value, { panelSize: Ee } = ge(De, oe, de);
      return gn(Ee != null, `Panel size not found for panel "${oe.id}"`), Ee;
    }
    function ve(oe) {
      const { layout: de, panelDataArray: De } = U.value, { collapsedSize: Ee = 0, collapsible: Ye, panelSize: ze } = ge(De, oe, de);
      return Ye ? ze === void 0 ? oe.constraints.defaultSize === oe.constraints.collapsedSize : ze === Ee : !1;
    }
    function ye(oe) {
      const { layout: de, panelDataArray: De } = U.value, { collapsedSize: Ee = 0, collapsible: Ye, panelSize: ze } = ge(De, oe, de);
      return gn(ze != null, `Panel size not found for panel "${oe.id}"`), !Ye || ze > Ee;
    }
    pw({
      direction: o,
      dragState: y.value,
      groupId: m,
      reevaluatePanelConstraints: se,
      registerPanel: B,
      registerResizeHandle: K,
      resizePanel: W,
      startDragging: te,
      stopDragging: me,
      unregisterPanel: M,
      panelGroupElement: x,
      collapsePanel: ce,
      expandPanel: Ie,
      isPanelCollapsed: ve,
      isPanelExpanded: ye,
      getPanelSize: ae,
      getPanelStyle: X
    });
    function Se(oe, de) {
      return oe.findIndex((De) => De === de || De.id === de.id);
    }
    function ge(oe, de, De) {
      const Ee = Se(oe, de), ze = Ee === oe.length - 1 ? [Ee - 1, Ee] : [Ee, Ee + 1], un = De[Ee];
      return {
        ...de.constraints,
        panelSize: un,
        pivotIndices: ze
      };
    }
    return (oe, de) => (We(), vn(le(al), {
      ref: le(h),
      as: oe.as,
      "as-child": oe.asChild,
      style: Hi({
        display: "flex",
        flexDirection: le(o) === "horizontal" ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
      }),
      "data-panel-group": "",
      "data-orientation": le(o),
      "data-panel-group-id": le(m)
    }, {
      default: ln(() => [qn(oe.$slots, "default", { layout: I.value })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "style",
      "data-orientation",
      "data-panel-group-id"
    ]));
  }
}), gw = hw, vw = /* @__PURE__ */ dn({
  __name: "SplitterPanel",
  props: {
    collapsedSize: {
      type: Number,
      required: !1
    },
    collapsible: {
      type: Boolean,
      required: !1
    },
    defaultSize: {
      type: Number,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    maxSize: {
      type: Number,
      required: !1
    },
    minSize: {
      type: Number,
      required: !1
    },
    order: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "collapse",
    "expand",
    "resize"
  ],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, o = Mv();
    if (o === null) throw new Error("SplitterPanel components must be rendered within a SplitterGroup container");
    const { collapsePanel: m, expandPanel: d, getPanelSize: h, getPanelStyle: x, isPanelCollapsed: y, resizePanel: I, groupId: q, reevaluatePanelConstraints: A, registerPanel: R, unregisterPanel: V } = o, U = pa(a.id, "reka-splitter-panel"), z = Re(() => ({
      callbacks: {
        onCollapse: () => s("collapse"),
        onExpand: () => s("expand"),
        onResize: (...me) => s("resize", ...me)
      },
      constraints: {
        collapsedSize: a.collapsedSize && Number.parseFloat(a.collapsedSize.toFixed(Af)),
        collapsible: a.collapsible,
        defaultSize: a.defaultSize,
        maxSize: a.maxSize,
        minSize: a.minSize
      },
      id: U,
      idIsFromProps: a.id !== void 0,
      order: a.order
    }));
    Sn(() => z.value.constraints, (me, M) => {
      (M.collapsedSize !== me.collapsedSize || M.collapsible !== me.collapsible || M.maxSize !== me.maxSize || M.minSize !== me.minSize) && A(z.value, M);
    }, { deep: !0 }), vl(() => {
      R(z.value);
    }), Dt(() => {
      V(z.value);
    });
    const X = Re(() => x(z.value, a.defaultSize)), B = Re(() => y(z.value)), K = Re(() => !B.value);
    function W() {
      m(z.value);
    }
    function se() {
      d(z.value);
    }
    function te(me) {
      I(z.value, me);
    }
    return l({
      collapse: W,
      expand: se,
      getSize() {
        return h(z.value);
      },
      resize: te,
      isCollapsed: B,
      isExpanded: K
    }), (me, M) => (We(), vn(le(al), {
      id: le(U),
      style: Hi(X.value),
      as: me.as,
      "as-child": me.asChild,
      "data-panel": "",
      "data-panel-collapsible": me.collapsible || void 0,
      "data-panel-group-id": le(q),
      "data-panel-id": le(U),
      "data-panel-size": Number.parseFloat(`${X.value.flexGrow}`).toFixed(1),
      "data-state": me.collapsible ? B.value ? "collapsed" : "expanded" : void 0
    }, {
      default: ln(() => [qn(me.$slots, "default", {
        isCollapsed: B.value,
        isExpanded: K.value,
        expand: se,
        collapse: W,
        resize: te
      })]),
      _: 3
    }, 8, [
      "id",
      "style",
      "as",
      "as-child",
      "data-panel-collapsible",
      "data-panel-group-id",
      "data-panel-id",
      "data-panel-size",
      "data-state"
    ]));
  }
}), Wd = vw;
function xw({ disabled: e, handleId: l, resizeHandler: i, panelGroupElement: a }) {
  Ml((s) => {
    const o = a.value;
    if (e.value || i.value === null || o === null) return;
    const m = fo(l, o);
    if (m == null) return;
    const d = (h) => {
      if (!h.defaultPrevented)
        switch (h.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            h.preventDefault(), i.value?.(h);
            break;
          }
          case "F6": {
            h.preventDefault();
            const x = m.getAttribute("data-panel-group-id");
            gn(x);
            const y = ms(x, o), I = Lv(x, l, o);
            gn(I !== null);
            const q = h.shiftKey ? I > 0 ? I - 1 : y.length - 1 : I + 1 < y.length ? I + 1 : 0;
            y[q].focus();
            break;
          }
        }
    };
    m.addEventListener("keydown", d), s(() => {
      m.removeEventListener("keydown", d);
    });
  });
}
var yw = /* @__PURE__ */ dn({
  __name: "SplitterResizeHandle",
  props: {
    id: {
      type: String,
      required: !1
    },
    hitAreaMargins: {
      type: Object,
      required: !1
    },
    tabindex: {
      type: Number,
      required: !1,
      default: 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["dragging"],
  setup(e, { emit: l }) {
    const i = e, a = l, { forwardRef: s, currentElement: o } = Tt(), { disabled: m } = St(i), d = Mv();
    if (d === null) throw new Error("PanelResizeHandle components must be rendered within a PanelGroup container");
    const { direction: h, groupId: x, registerResizeHandle: y, startDragging: I, stopDragging: q, panelGroupElement: A } = d, R = pa(i.id, "reka-splitter-resize-handle"), V = Fe("inactive"), U = Fe(!1), z = Fe(null), { nonce: X } = St(i), B = yv(X);
    return Sn(m, () => {
      bs && (m.value ? z.value = null : z.value = y(R));
    }, { immediate: !0 }), Ml((K) => {
      if (m.value || z.value === null) return;
      const W = o.value;
      if (!W) return;
      gn(W);
      const se = (te, me, M) => {
        if (me) switch (te) {
          case "down": {
            V.value = "drag", I(R, M), a("dragging", !0);
            break;
          }
          case "move": {
            V.value !== "drag" && (V.value = "hover"), z.value?.(M);
            break;
          }
          case "up": {
            V.value = "hover", q(), a("dragging", !1);
            break;
          }
        }
        else V.value = "inactive";
      };
      K(aw(R, W, h, {
        coarse: i.hitAreaMargins?.coarse ?? 15,
        fine: i.hitAreaMargins?.fine ?? 5
      }, B, se));
    }), xw({
      disabled: m,
      resizeHandler: z,
      handleId: R,
      panelGroupElement: A
    }), (K, W) => (We(), vn(le(al), {
      id: le(R),
      ref: le(s),
      style: {
        touchAction: "none",
        userSelect: "none"
      },
      as: K.as,
      "as-child": K.asChild,
      role: "separator",
      "data-resize-handle": "",
      tabindex: K.tabindex,
      "data-state": V.value,
      "data-disabled": le(m) ? "" : void 0,
      "data-orientation": le(h),
      "data-panel-group-id": le(x),
      "data-resize-handle-active": V.value === "drag" ? "pointer" : U.value ? "keyboard" : void 0,
      "data-resize-handle-state": V.value,
      "data-panel-resize-handle-enabled": !le(m),
      "data-panel-resize-handle-id": le(R),
      onBlur: W[0] || (W[0] = (se) => U.value = !1),
      onFocus: W[1] || (W[1] = (se) => U.value = !1)
    }, {
      default: ln(() => [qn(K.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "tabindex",
      "data-state",
      "data-disabled",
      "data-orientation",
      "data-panel-group-id",
      "data-resize-handle-active",
      "data-resize-handle-state",
      "data-panel-resize-handle-enabled",
      "data-panel-resize-handle-id"
    ]));
  }
}), Iw = yw;
function Ec(e) {
  return e.reduce((l, i) => (l.push(i), i.children && l.push(...Ec(i.children)), l), []);
}
const [Lw, Dw] = vi("TreeRoot");
var Ow = /* @__PURE__ */ dn({
  __name: "TreeRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    items: {
      type: Array,
      required: !1
    },
    expanded: {
      type: Array,
      required: !1
    },
    defaultExpanded: {
      type: Array,
      required: !1
    },
    getKey: {
      type: Function,
      required: !0
    },
    getChildren: {
      type: Function,
      required: !1,
      default: (e) => e.children
    },
    selectionBehavior: {
      type: String,
      required: !1,
      default: "toggle"
    },
    multiple: {
      type: Boolean,
      required: !1,
      skipCheck: !0
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    propagateSelect: {
      type: Boolean,
      required: !1
    },
    bubbleSelect: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "ul"
    }
  },
  emits: ["update:modelValue", "update:expanded"],
  setup(e, { emit: l }) {
    const i = e, a = l, { items: s, multiple: o, disabled: m, propagateSelect: d, dir: h, bubbleSelect: x } = St(i), { handleTypeaheadSearch: y } = tv(), I = ws(h), q = Fe(), A = Fe(!1), R = Yr(), V = ju(i, "modelValue", a, {
      defaultValue: i.defaultValue ?? (o.value ? [] : void 0),
      passive: !0,
      deep: !0
    }), U = ju(i, "expanded", a, {
      defaultValue: i.defaultExpanded ?? [],
      passive: i.expanded === void 0,
      deep: !0
    }), { onSelectItem: z, handleMultipleReplace: X } = L0(V, i), B = Re(() => o.value && Array.isArray(V.value) ? V.value.map((M) => i.getKey(M)) : [i.getKey(V.value ?? {})]);
    function K(M, ce = 1, Ie) {
      return M.reduce((ae, ve, ye) => {
        const Se = i.getKey(ve), ge = i.getChildren(ve), oe = U.value.includes(Se), de = {
          _id: Se,
          value: ve,
          index: ye,
          level: ce,
          parentItem: Ie,
          hasChildren: !!ge,
          bind: {
            value: ve,
            level: ce,
            "aria-setsize": M.length,
            "aria-posinset": ye + 1
          }
        };
        return ae.push(de), ge && oe && ae.push(...K(ge, ce + 1, ve)), ae;
      }, []);
    }
    const W = Re(() => {
      const M = i.items;
      return U.value.map((ce) => ce), K(M ?? []);
    });
    function se(M) {
      if (A.value) R.trigger(M);
      else {
        const ce = q.value?.getItems() ?? [];
        y(M.key, ce);
      }
    }
    function te(M) {
      if (A.value) return;
      const ce = uv[M.key];
      il(() => {
        X(ce, Ka(), q.value?.getItems, W.value.map((Ie) => Ie.value));
      });
    }
    function me(M) {
      if (M.parentItem != null && Array.isArray(V.value) && i.multiple) {
        const ce = W.value.find((Ie) => M.parentItem != null && i.getKey(Ie.value) === i.getKey(M.parentItem));
        ce != null && (i.getChildren(ce.value)?.every((ae) => V.value.find((ve) => i.getKey(ve) === i.getKey(ae))) ? V.value = [...V.value, ce.value] : V.value = V.value.filter((ae) => i.getKey(ae) !== i.getKey(ce.value)), me(ce));
      }
    }
    return Dw({
      modelValue: V,
      selectedKeys: B,
      onSelect: (M) => {
        const ce = (ae) => i.getKey(ae ?? {}) === i.getKey(M), Ie = i.multiple && Array.isArray(V.value) ? V.value?.findIndex(ce) !== -1 : void 0;
        if (z(M, ce), i.bubbleSelect && i.multiple && Array.isArray(V.value)) {
          const ae = W.value.find((ve) => i.getKey(ve.value) === i.getKey(M));
          ae != null && me(ae);
        }
        if (i.propagateSelect && i.multiple && Array.isArray(V.value)) {
          const ae = Ec(i.getChildren(M) ?? []);
          Ie ? V.value = [...V.value].filter((ve) => !ae.some((ye) => i.getKey(ve ?? {}) === i.getKey(ye))) : V.value = [...V.value, ...ae];
        }
      },
      expanded: U,
      onToggle(M) {
        if (!(M ? i.getChildren(M) : void 0)) return;
        const Ie = i.getKey(M) ?? M;
        U.value.includes(Ie) ? U.value = U.value.filter((ae) => ae !== Ie) : U.value.push(Ie);
      },
      getKey: i.getKey,
      getChildren: i.getChildren,
      items: s,
      expandedItems: W,
      disabled: m,
      multiple: o,
      dir: I,
      propagateSelect: d,
      bubbleSelect: x,
      isVirtual: A,
      virtualKeydownHook: R,
      handleMultipleReplace: X
    }), (M, ce) => (We(), vn(le(U0), {
      ref_key: "rovingFocusGroupRef",
      ref: q,
      "as-child": "",
      orientation: "vertical",
      dir: le(I)
    }, {
      default: ln(() => [je(le(al), {
        role: "tree",
        as: M.as,
        "as-child": M.asChild,
        "aria-multiselectable": le(o) ? !0 : void 0,
        onKeydown: [se, mi(si(te, ["shift"]), ["up", "down"])]
      }, {
        default: ln(() => [qn(M.$slots, "default", {
          flattenItems: W.value,
          modelValue: le(V),
          expanded: le(U)
        })]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-multiselectable",
        "onKeydown"
      ])]),
      _: 3
    }, 8, ["dir"]));
  }
}), bw = Ow;
const ww = "tree.select", Sw = "tree.toggle";
var Cw = /* @__PURE__ */ dn({
  inheritAttrs: !1,
  __name: "TreeItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    level: {
      type: Number,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "li"
    }
  },
  emits: ["select", "toggle"],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, o = Lw(), { getItems: m } = Qa(), d = Re(() => !!o.getChildren(a.value)), h = Re(() => {
      const z = o.getKey(a.value);
      return o.expanded.value.includes(z);
    }), x = Re(() => {
      const z = o.getKey(a.value);
      return o.selectedKeys.value.includes(z);
    }), y = Re(() => {
      if (o.bubbleSelect.value && d.value && Array.isArray(o.modelValue.value)) {
        const z = Ec(o.getChildren(a.value) || []);
        return z.some((X) => o.modelValue.value.find((B) => o.getKey(B) === o.getKey(X))) && !z.every((X) => o.modelValue.value.find((B) => o.getKey(B) === o.getKey(X)));
      } else return o.propagateSelect.value && x.value && d.value && Array.isArray(o.modelValue.value) ? !Ec(o.getChildren(a.value) || []).every((X) => o.modelValue.value.find((B) => o.getKey(B) === o.getKey(X))) : void 0;
    });
    function I(z) {
      if (d.value)
        if (h.value) {
          const X = m().map((te) => te.ref), B = Ka(), K = X.indexOf(B), se = [...X].slice(K).find((te) => Number(te.getAttribute("data-indent")) === a.level + 1);
          se && se.focus();
        } else U(z);
    }
    function q(z) {
      if (h.value) U(z);
      else {
        const X = m().map((te) => te.ref), B = Ka(), K = X.indexOf(B), se = [...X].slice(0, K).reverse().find((te) => Number(te.getAttribute("data-indent")) === a.level - 1);
        se && se.focus();
      }
    }
    async function A(z) {
      s("select", z), !z?.defaultPrevented && o.onSelect(a.value);
    }
    async function R(z) {
      s("toggle", z), !z?.defaultPrevented && o.onToggle(a.value);
    }
    async function V(z) {
      if (!z) return;
      const X = {
        originalEvent: z,
        value: a.value,
        isExpanded: h.value,
        isSelected: x.value
      };
      ss(ww, A, X);
    }
    async function U(z) {
      if (!z) return;
      const X = {
        originalEvent: z,
        value: a.value,
        isExpanded: h.value,
        isSelected: x.value
      };
      ss(Sw, R, X);
    }
    return l({
      isExpanded: h,
      isSelected: x,
      isIndeterminate: y,
      handleToggle: () => o.onToggle(a.value),
      handleSelect: () => o.onSelect(a.value)
    }), (z, X) => (We(), vn(le(G0), {
      "as-child": "",
      value: z.value,
      "allow-shift-key": ""
    }, {
      default: ln(() => [je(le(al), pl(z.$attrs, {
        role: "treeitem",
        as: z.as,
        "as-child": z.asChild,
        "aria-selected": x.value,
        "aria-expanded": d.value ? h.value : void 0,
        "aria-level": z.level,
        "data-indent": z.level,
        "data-selected": x.value ? "" : void 0,
        "data-expanded": h.value ? "" : void 0,
        onKeydown: [
          mi(si(V, ["self", "prevent"]), ["enter", "space"]),
          X[0] || (X[0] = mi(si((B) => le(o).dir.value === "ltr" ? I(B) : q(B), ["prevent"]), ["right"])),
          X[1] || (X[1] = mi(si((B) => le(o).dir.value === "ltr" ? q(B) : I(B), ["prevent"]), ["left"]))
        ],
        onClick: X[2] || (X[2] = si((B) => {
          V(B), U(B);
        }, ["stop"]))
      }), {
        default: ln(() => [qn(z.$slots, "default", {
          isExpanded: h.value,
          isSelected: x.value,
          isIndeterminate: y.value,
          handleSelect: () => le(o).onSelect(z.value),
          handleToggle: () => le(o).onToggle(z.value)
        })]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "aria-selected",
        "aria-expanded",
        "aria-level",
        "data-indent",
        "data-selected",
        "data-expanded",
        "onKeydown"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), Tw = Cw;
const Pw = { class: "layout w-screen h-screen" }, qw = { class: "w-screen h-screen overflow-hidden" }, Aw = /* @__PURE__ */ dn({
  __name: "app-layout",
  setup(e) {
    const l = /* @__PURE__ */ _D(ED), i = Re(() => l.greater("2xl").value ? 20 : l.greater("xl").value ? 25 : l.greater("lg").value ? 30 : l.greater("md").value ? 35 : 0);
    return (a, s) => (We(), Yn("div", Pw, [
      fn("div", qw, [
        je(le(gw), {
          direction: "horizontal",
          class: "h-full"
        }, {
          default: ln(() => [
            je(le(Wd), {
              class: "border-e h-full",
              "default-size": i.value
            }, {
              default: ln(() => [
                qn(a.$slots, "primary-sidebar", {}, void 0, !0)
              ]),
              _: 3
            }, 8, ["default-size"]),
            je(le(Iw), { class: "w-1" }),
            je(le(Wd), { class: "h-full" }, {
              default: ln(() => [
                qn(a.$slots, "main-area", {}, void 0, !0)
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ])
    ]));
  }
}), va = (e, l) => {
  const i = e.__vccOpts || e;
  for (const [a, s] of l)
    i[a] = s;
  return i;
}, Rw = /* @__PURE__ */ va(Aw, [["__scopeId", "data-v-30346480"]]);
var Ew = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function _w(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Nw(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var l = e.default;
  if (typeof l == "function") {
    var i = function a() {
      var s = !1;
      try {
        s = this instanceof a;
      } catch {
      }
      return s ? Reflect.construct(l, arguments, this.constructor) : l.apply(this, arguments);
    };
    i.prototype = l.prototype;
  } else i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(e).forEach(function(a) {
    var s = Object.getOwnPropertyDescriptor(e, a);
    Object.defineProperty(i, a, s.get ? s : {
      enumerable: !0,
      get: function() {
        return e[a];
      }
    });
  }), i;
}
var Yd = {};
const Fw = {}, Mw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Fw
}, Symbol.toStringTag, { value: "Module" })), Xd = /* @__PURE__ */ Nw(Mw);
var Qd;
function kw() {
  return Qd || (Qd = 1, function(e) {
    (function(l) {
      l.parser = function(k, _) {
        return new a(k, _);
      }, l.SAXParser = a, l.SAXStream = y, l.createStream = x, l.MAX_BUFFER_LENGTH = 64 * 1024;
      var i = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      l.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function a(k, _) {
        if (!(this instanceof a))
          return new a(k, _);
        var Z = this;
        o(Z), Z.q = Z.c = "", Z.bufferCheckPosition = l.MAX_BUFFER_LENGTH, Z.opt = _ || {}, Z.opt.lowercase = Z.opt.lowercase || Z.opt.lowercasetags, Z.looseCase = Z.opt.lowercase ? "toLowerCase" : "toUpperCase", Z.tags = [], Z.closed = Z.closedRoot = Z.sawRoot = !1, Z.tag = Z.error = null, Z.strict = !!k, Z.noscript = !!(k || Z.opt.noscript), Z.state = M.BEGIN, Z.strictEntities = Z.opt.strictEntities, Z.ENTITIES = Z.strictEntities ? Object.create(l.XML_ENTITIES) : Object.create(l.ENTITIES), Z.attribList = [], Z.opt.xmlns && (Z.ns = Object.create(V)), Z.opt.unquotedAttributeValues === void 0 && (Z.opt.unquotedAttributeValues = !k), Z.trackPosition = Z.opt.position !== !1, Z.trackPosition && (Z.position = Z.line = Z.column = 0), Ie(Z, "onready");
      }
      Object.create || (Object.create = function(k) {
        function _() {
        }
        _.prototype = k;
        var Z = new _();
        return Z;
      }), Object.keys || (Object.keys = function(k) {
        var _ = [];
        for (var Z in k) k.hasOwnProperty(Z) && _.push(Z);
        return _;
      });
      function s(k) {
        for (var _ = Math.max(l.MAX_BUFFER_LENGTH, 10), Z = 0, ie = 0, Qe = i.length; ie < Qe; ie++) {
          var Oe = k[i[ie]].length;
          if (Oe > _)
            switch (i[ie]) {
              case "textNode":
                ve(k);
                break;
              case "cdata":
                ae(k, "oncdata", k.cdata), k.cdata = "";
                break;
              case "script":
                ae(k, "onscript", k.script), k.script = "";
                break;
              default:
                Se(k, "Max buffer length exceeded: " + i[ie]);
            }
          Z = Math.max(Z, Oe);
        }
        var j = l.MAX_BUFFER_LENGTH - Z;
        k.bufferCheckPosition = j + k.position;
      }
      function o(k) {
        for (var _ = 0, Z = i.length; _ < Z; _++)
          k[i[_]] = "";
      }
      function m(k) {
        ve(k), k.cdata !== "" && (ae(k, "oncdata", k.cdata), k.cdata = ""), k.script !== "" && (ae(k, "onscript", k.script), k.script = "");
      }
      a.prototype = {
        end: function() {
          ge(this);
        },
        write: tn,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          m(this);
        }
      };
      var d;
      try {
        d = Xd.Stream;
      } catch {
        d = function() {
        };
      }
      d || (d = function() {
      });
      var h = l.EVENTS.filter(function(k) {
        return k !== "error" && k !== "end";
      });
      function x(k, _) {
        return new y(k, _);
      }
      function y(k, _) {
        if (!(this instanceof y))
          return new y(k, _);
        d.apply(this), this._parser = new a(k, _), this.writable = !0, this.readable = !0;
        var Z = this;
        this._parser.onend = function() {
          Z.emit("end");
        }, this._parser.onerror = function(ie) {
          Z.emit("error", ie), Z._parser.error = null;
        }, this._decoder = null, h.forEach(function(ie) {
          Object.defineProperty(Z, "on" + ie, {
            get: function() {
              return Z._parser["on" + ie];
            },
            set: function(Qe) {
              if (!Qe)
                return Z.removeAllListeners(ie), Z._parser["on" + ie] = Qe, Qe;
              Z.on(ie, Qe);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      y.prototype = Object.create(d.prototype, {
        constructor: {
          value: y
        }
      }), y.prototype.write = function(k) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(k)) {
          if (!this._decoder) {
            var _ = Xd.StringDecoder;
            this._decoder = new _("utf8");
          }
          k = this._decoder.write(k);
        }
        return this._parser.write(k.toString()), this.emit("data", k), !0;
      }, y.prototype.end = function(k) {
        return k && k.length && this.write(k), this._parser.end(), !0;
      }, y.prototype.on = function(k, _) {
        var Z = this;
        return !Z._parser["on" + k] && h.indexOf(k) !== -1 && (Z._parser["on" + k] = function() {
          var ie = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          ie.splice(0, 0, k), Z.emit.apply(Z, ie);
        }), d.prototype.on.call(Z, k, _);
      };
      var I = "[CDATA[", q = "DOCTYPE", A = "http://www.w3.org/XML/1998/namespace", R = "http://www.w3.org/2000/xmlns/", V = { xml: A, xmlns: R }, U = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, z = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, X = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, B = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function K(k) {
        return k === " " || k === `
` || k === "\r" || k === "	";
      }
      function W(k) {
        return k === '"' || k === "'";
      }
      function se(k) {
        return k === ">" || K(k);
      }
      function te(k, _) {
        return k.test(_);
      }
      function me(k, _) {
        return !te(k, _);
      }
      var M = 0;
      l.STATE = {
        BEGIN: M++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: M++,
        // leading whitespace
        TEXT: M++,
        // general stuff
        TEXT_ENTITY: M++,
        // &amp and such.
        OPEN_WAKA: M++,
        // <
        SGML_DECL: M++,
        // <!BLARG
        SGML_DECL_QUOTED: M++,
        // <!BLARG foo "bar
        DOCTYPE: M++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: M++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: M++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: M++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: M++,
        // <!-
        COMMENT: M++,
        // <!--
        COMMENT_ENDING: M++,
        // <!-- blah -
        COMMENT_ENDED: M++,
        // <!-- blah --
        CDATA: M++,
        // <![CDATA[ something
        CDATA_ENDING: M++,
        // ]
        CDATA_ENDING_2: M++,
        // ]]
        PROC_INST: M++,
        // <?hi
        PROC_INST_BODY: M++,
        // <?hi there
        PROC_INST_ENDING: M++,
        // <?hi "there" ?
        OPEN_TAG: M++,
        // <strong
        OPEN_TAG_SLASH: M++,
        // <strong /
        ATTRIB: M++,
        // <a
        ATTRIB_NAME: M++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: M++,
        // <a foo _
        ATTRIB_VALUE: M++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: M++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: M++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: M++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: M++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: M++,
        // <foo bar=&quot
        CLOSE_TAG: M++,
        // </a
        CLOSE_TAG_SAW_WHITE: M++,
        // </a   >
        SCRIPT: M++,
        // <script> ...
        SCRIPT_ENDING: M++
        // <script> ... <
      }, l.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, l.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(l.ENTITIES).forEach(function(k) {
        var _ = l.ENTITIES[k], Z = typeof _ == "number" ? String.fromCharCode(_) : _;
        l.ENTITIES[k] = Z;
      });
      for (var ce in l.STATE)
        l.STATE[l.STATE[ce]] = ce;
      M = l.STATE;
      function Ie(k, _, Z) {
        k[_] && k[_](Z);
      }
      function ae(k, _, Z) {
        k.textNode && ve(k), Ie(k, _, Z);
      }
      function ve(k) {
        k.textNode = ye(k.opt, k.textNode), k.textNode && Ie(k, "ontext", k.textNode), k.textNode = "";
      }
      function ye(k, _) {
        return k.trim && (_ = _.trim()), k.normalize && (_ = _.replace(/\s+/g, " ")), _;
      }
      function Se(k, _) {
        return ve(k), k.trackPosition && (_ += `
Line: ` + k.line + `
Column: ` + k.column + `
Char: ` + k.c), _ = new Error(_), k.error = _, Ie(k, "onerror", _), k;
      }
      function ge(k) {
        return k.sawRoot && !k.closedRoot && oe(k, "Unclosed root tag"), k.state !== M.BEGIN && k.state !== M.BEGIN_WHITESPACE && k.state !== M.TEXT && Se(k, "Unexpected end"), ve(k), k.c = "", k.closed = !0, Ie(k, "onend"), a.call(k, k.strict, k.opt), k;
      }
      function oe(k, _) {
        if (typeof k != "object" || !(k instanceof a))
          throw new Error("bad call to strictFail");
        k.strict && Se(k, _);
      }
      function de(k) {
        k.strict || (k.tagName = k.tagName[k.looseCase]());
        var _ = k.tags[k.tags.length - 1] || k, Z = k.tag = { name: k.tagName, attributes: {} };
        k.opt.xmlns && (Z.ns = _.ns), k.attribList.length = 0, ae(k, "onopentagstart", Z);
      }
      function De(k, _) {
        var Z = k.indexOf(":"), ie = Z < 0 ? ["", k] : k.split(":"), Qe = ie[0], Oe = ie[1];
        return _ && k === "xmlns" && (Qe = "xmlns", Oe = ""), { prefix: Qe, local: Oe };
      }
      function Ee(k) {
        if (k.strict || (k.attribName = k.attribName[k.looseCase]()), k.attribList.indexOf(k.attribName) !== -1 || k.tag.attributes.hasOwnProperty(k.attribName)) {
          k.attribName = k.attribValue = "";
          return;
        }
        if (k.opt.xmlns) {
          var _ = De(k.attribName, !0), Z = _.prefix, ie = _.local;
          if (Z === "xmlns")
            if (ie === "xml" && k.attribValue !== A)
              oe(
                k,
                "xml: prefix must be bound to " + A + `
Actual: ` + k.attribValue
              );
            else if (ie === "xmlns" && k.attribValue !== R)
              oe(
                k,
                "xmlns: prefix must be bound to " + R + `
Actual: ` + k.attribValue
              );
            else {
              var Qe = k.tag, Oe = k.tags[k.tags.length - 1] || k;
              Qe.ns === Oe.ns && (Qe.ns = Object.create(Oe.ns)), Qe.ns[ie] = k.attribValue;
            }
          k.attribList.push([k.attribName, k.attribValue]);
        } else
          k.tag.attributes[k.attribName] = k.attribValue, ae(k, "onattribute", {
            name: k.attribName,
            value: k.attribValue
          });
        k.attribName = k.attribValue = "";
      }
      function Ye(k, _) {
        if (k.opt.xmlns) {
          var Z = k.tag, ie = De(k.tagName);
          Z.prefix = ie.prefix, Z.local = ie.local, Z.uri = Z.ns[ie.prefix] || "", Z.prefix && !Z.uri && (oe(k, "Unbound namespace prefix: " + JSON.stringify(k.tagName)), Z.uri = ie.prefix);
          var Qe = k.tags[k.tags.length - 1] || k;
          Z.ns && Qe.ns !== Z.ns && Object.keys(Z.ns).forEach(function(Pe) {
            ae(k, "onopennamespace", {
              prefix: Pe,
              uri: Z.ns[Pe]
            });
          });
          for (var Oe = 0, j = k.attribList.length; Oe < j; Oe++) {
            var ue = k.attribList[Oe], fe = ue[0], Te = ue[1], Le = De(fe, !0), we = Le.prefix, Ne = Le.local, _e = we === "" ? "" : Z.ns[we] || "", be = {
              name: fe,
              value: Te,
              prefix: we,
              local: Ne,
              uri: _e
            };
            we && we !== "xmlns" && !_e && (oe(k, "Unbound namespace prefix: " + JSON.stringify(we)), be.uri = we), k.tag.attributes[fe] = be, ae(k, "onattribute", be);
          }
          k.attribList.length = 0;
        }
        k.tag.isSelfClosing = !!_, k.sawRoot = !0, k.tags.push(k.tag), ae(k, "onopentag", k.tag), _ || (!k.noscript && k.tagName.toLowerCase() === "script" ? k.state = M.SCRIPT : k.state = M.TEXT, k.tag = null, k.tagName = ""), k.attribName = k.attribValue = "", k.attribList.length = 0;
      }
      function ze(k) {
        if (!k.tagName) {
          oe(k, "Weird empty close tag."), k.textNode += "</>", k.state = M.TEXT;
          return;
        }
        if (k.script) {
          if (k.tagName !== "script") {
            k.script += "</" + k.tagName + ">", k.tagName = "", k.state = M.SCRIPT;
            return;
          }
          ae(k, "onscript", k.script), k.script = "";
        }
        var _ = k.tags.length, Z = k.tagName;
        k.strict || (Z = Z[k.looseCase]());
        for (var ie = Z; _--; ) {
          var Qe = k.tags[_];
          if (Qe.name !== ie)
            oe(k, "Unexpected close tag");
          else
            break;
        }
        if (_ < 0) {
          oe(k, "Unmatched closing tag: " + k.tagName), k.textNode += "</" + k.tagName + ">", k.state = M.TEXT;
          return;
        }
        k.tagName = Z;
        for (var Oe = k.tags.length; Oe-- > _; ) {
          var j = k.tag = k.tags.pop();
          k.tagName = k.tag.name, ae(k, "onclosetag", k.tagName);
          var ue = {};
          for (var fe in j.ns)
            ue[fe] = j.ns[fe];
          var Te = k.tags[k.tags.length - 1] || k;
          k.opt.xmlns && j.ns !== Te.ns && Object.keys(j.ns).forEach(function(Le) {
            var we = j.ns[Le];
            ae(k, "onclosenamespace", { prefix: Le, uri: we });
          });
        }
        _ === 0 && (k.closedRoot = !0), k.tagName = k.attribValue = k.attribName = "", k.attribList.length = 0, k.state = M.TEXT;
      }
      function un(k) {
        var _ = k.entity, Z = _.toLowerCase(), ie, Qe = "";
        return k.ENTITIES[_] ? k.ENTITIES[_] : k.ENTITIES[Z] ? k.ENTITIES[Z] : (_ = Z, _.charAt(0) === "#" && (_.charAt(1) === "x" ? (_ = _.slice(2), ie = parseInt(_, 16), Qe = ie.toString(16)) : (_ = _.slice(1), ie = parseInt(_, 10), Qe = ie.toString(10))), _ = _.replace(/^0+/, ""), isNaN(ie) || Qe.toLowerCase() !== _ ? (oe(k, "Invalid character entity"), "&" + k.entity + ";") : String.fromCodePoint(ie));
      }
      function Pn(k, _) {
        _ === "<" ? (k.state = M.OPEN_WAKA, k.startTagPosition = k.position) : K(_) || (oe(k, "Non-whitespace before first tag."), k.textNode = _, k.state = M.TEXT);
      }
      function xn(k, _) {
        var Z = "";
        return _ < k.length && (Z = k.charAt(_)), Z;
      }
      function tn(k) {
        var _ = this;
        if (this.error)
          throw this.error;
        if (_.closed)
          return Se(
            _,
            "Cannot write after close. Assign an onready handler."
          );
        if (k === null)
          return ge(_);
        typeof k == "object" && (k = k.toString());
        for (var Z = 0, ie = ""; ie = xn(k, Z++), _.c = ie, !!ie; )
          switch (_.trackPosition && (_.position++, ie === `
` ? (_.line++, _.column = 0) : _.column++), _.state) {
            case M.BEGIN:
              if (_.state = M.BEGIN_WHITESPACE, ie === "\uFEFF")
                continue;
              Pn(_, ie);
              continue;
            case M.BEGIN_WHITESPACE:
              Pn(_, ie);
              continue;
            case M.TEXT:
              if (_.sawRoot && !_.closedRoot) {
                for (var Qe = Z - 1; ie && ie !== "<" && ie !== "&"; )
                  ie = xn(k, Z++), ie && _.trackPosition && (_.position++, ie === `
` ? (_.line++, _.column = 0) : _.column++);
                _.textNode += k.substring(Qe, Z - 1);
              }
              ie === "<" && !(_.sawRoot && _.closedRoot && !_.strict) ? (_.state = M.OPEN_WAKA, _.startTagPosition = _.position) : (!K(ie) && (!_.sawRoot || _.closedRoot) && oe(_, "Text data outside of root node."), ie === "&" ? _.state = M.TEXT_ENTITY : _.textNode += ie);
              continue;
            case M.SCRIPT:
              ie === "<" ? _.state = M.SCRIPT_ENDING : _.script += ie;
              continue;
            case M.SCRIPT_ENDING:
              ie === "/" ? _.state = M.CLOSE_TAG : (_.script += "<" + ie, _.state = M.SCRIPT);
              continue;
            case M.OPEN_WAKA:
              if (ie === "!")
                _.state = M.SGML_DECL, _.sgmlDecl = "";
              else if (!K(ie)) if (te(U, ie))
                _.state = M.OPEN_TAG, _.tagName = ie;
              else if (ie === "/")
                _.state = M.CLOSE_TAG, _.tagName = "";
              else if (ie === "?")
                _.state = M.PROC_INST, _.procInstName = _.procInstBody = "";
              else {
                if (oe(_, "Unencoded <"), _.startTagPosition + 1 < _.position) {
                  var Oe = _.position - _.startTagPosition;
                  ie = new Array(Oe).join(" ") + ie;
                }
                _.textNode += "<" + ie, _.state = M.TEXT;
              }
              continue;
            case M.SGML_DECL:
              if (_.sgmlDecl + ie === "--") {
                _.state = M.COMMENT, _.comment = "", _.sgmlDecl = "";
                continue;
              }
              _.doctype && _.doctype !== !0 && _.sgmlDecl ? (_.state = M.DOCTYPE_DTD, _.doctype += "<!" + _.sgmlDecl + ie, _.sgmlDecl = "") : (_.sgmlDecl + ie).toUpperCase() === I ? (ae(_, "onopencdata"), _.state = M.CDATA, _.sgmlDecl = "", _.cdata = "") : (_.sgmlDecl + ie).toUpperCase() === q ? (_.state = M.DOCTYPE, (_.doctype || _.sawRoot) && oe(
                _,
                "Inappropriately located doctype declaration"
              ), _.doctype = "", _.sgmlDecl = "") : ie === ">" ? (ae(_, "onsgmldeclaration", _.sgmlDecl), _.sgmlDecl = "", _.state = M.TEXT) : (W(ie) && (_.state = M.SGML_DECL_QUOTED), _.sgmlDecl += ie);
              continue;
            case M.SGML_DECL_QUOTED:
              ie === _.q && (_.state = M.SGML_DECL, _.q = ""), _.sgmlDecl += ie;
              continue;
            case M.DOCTYPE:
              ie === ">" ? (_.state = M.TEXT, ae(_, "ondoctype", _.doctype), _.doctype = !0) : (_.doctype += ie, ie === "[" ? _.state = M.DOCTYPE_DTD : W(ie) && (_.state = M.DOCTYPE_QUOTED, _.q = ie));
              continue;
            case M.DOCTYPE_QUOTED:
              _.doctype += ie, ie === _.q && (_.q = "", _.state = M.DOCTYPE);
              continue;
            case M.DOCTYPE_DTD:
              ie === "]" ? (_.doctype += ie, _.state = M.DOCTYPE) : ie === "<" ? (_.state = M.OPEN_WAKA, _.startTagPosition = _.position) : W(ie) ? (_.doctype += ie, _.state = M.DOCTYPE_DTD_QUOTED, _.q = ie) : _.doctype += ie;
              continue;
            case M.DOCTYPE_DTD_QUOTED:
              _.doctype += ie, ie === _.q && (_.state = M.DOCTYPE_DTD, _.q = "");
              continue;
            case M.COMMENT:
              ie === "-" ? _.state = M.COMMENT_ENDING : _.comment += ie;
              continue;
            case M.COMMENT_ENDING:
              ie === "-" ? (_.state = M.COMMENT_ENDED, _.comment = ye(_.opt, _.comment), _.comment && ae(_, "oncomment", _.comment), _.comment = "") : (_.comment += "-" + ie, _.state = M.COMMENT);
              continue;
            case M.COMMENT_ENDED:
              ie !== ">" ? (oe(_, "Malformed comment"), _.comment += "--" + ie, _.state = M.COMMENT) : _.doctype && _.doctype !== !0 ? _.state = M.DOCTYPE_DTD : _.state = M.TEXT;
              continue;
            case M.CDATA:
              ie === "]" ? _.state = M.CDATA_ENDING : _.cdata += ie;
              continue;
            case M.CDATA_ENDING:
              ie === "]" ? _.state = M.CDATA_ENDING_2 : (_.cdata += "]" + ie, _.state = M.CDATA);
              continue;
            case M.CDATA_ENDING_2:
              ie === ">" ? (_.cdata && ae(_, "oncdata", _.cdata), ae(_, "onclosecdata"), _.cdata = "", _.state = M.TEXT) : ie === "]" ? _.cdata += "]" : (_.cdata += "]]" + ie, _.state = M.CDATA);
              continue;
            case M.PROC_INST:
              ie === "?" ? _.state = M.PROC_INST_ENDING : K(ie) ? _.state = M.PROC_INST_BODY : _.procInstName += ie;
              continue;
            case M.PROC_INST_BODY:
              if (!_.procInstBody && K(ie))
                continue;
              ie === "?" ? _.state = M.PROC_INST_ENDING : _.procInstBody += ie;
              continue;
            case M.PROC_INST_ENDING:
              ie === ">" ? (ae(_, "onprocessinginstruction", {
                name: _.procInstName,
                body: _.procInstBody
              }), _.procInstName = _.procInstBody = "", _.state = M.TEXT) : (_.procInstBody += "?" + ie, _.state = M.PROC_INST_BODY);
              continue;
            case M.OPEN_TAG:
              te(z, ie) ? _.tagName += ie : (de(_), ie === ">" ? Ye(_) : ie === "/" ? _.state = M.OPEN_TAG_SLASH : (K(ie) || oe(_, "Invalid character in tag name"), _.state = M.ATTRIB));
              continue;
            case M.OPEN_TAG_SLASH:
              ie === ">" ? (Ye(_, !0), ze(_)) : (oe(_, "Forward-slash in opening tag not followed by >"), _.state = M.ATTRIB);
              continue;
            case M.ATTRIB:
              if (K(ie))
                continue;
              ie === ">" ? Ye(_) : ie === "/" ? _.state = M.OPEN_TAG_SLASH : te(U, ie) ? (_.attribName = ie, _.attribValue = "", _.state = M.ATTRIB_NAME) : oe(_, "Invalid attribute name");
              continue;
            case M.ATTRIB_NAME:
              ie === "=" ? _.state = M.ATTRIB_VALUE : ie === ">" ? (oe(_, "Attribute without value"), _.attribValue = _.attribName, Ee(_), Ye(_)) : K(ie) ? _.state = M.ATTRIB_NAME_SAW_WHITE : te(z, ie) ? _.attribName += ie : oe(_, "Invalid attribute name");
              continue;
            case M.ATTRIB_NAME_SAW_WHITE:
              if (ie === "=")
                _.state = M.ATTRIB_VALUE;
              else {
                if (K(ie))
                  continue;
                oe(_, "Attribute without value"), _.tag.attributes[_.attribName] = "", _.attribValue = "", ae(_, "onattribute", {
                  name: _.attribName,
                  value: ""
                }), _.attribName = "", ie === ">" ? Ye(_) : te(U, ie) ? (_.attribName = ie, _.state = M.ATTRIB_NAME) : (oe(_, "Invalid attribute name"), _.state = M.ATTRIB);
              }
              continue;
            case M.ATTRIB_VALUE:
              if (K(ie))
                continue;
              W(ie) ? (_.q = ie, _.state = M.ATTRIB_VALUE_QUOTED) : (_.opt.unquotedAttributeValues || Se(_, "Unquoted attribute value"), _.state = M.ATTRIB_VALUE_UNQUOTED, _.attribValue = ie);
              continue;
            case M.ATTRIB_VALUE_QUOTED:
              if (ie !== _.q) {
                ie === "&" ? _.state = M.ATTRIB_VALUE_ENTITY_Q : _.attribValue += ie;
                continue;
              }
              Ee(_), _.q = "", _.state = M.ATTRIB_VALUE_CLOSED;
              continue;
            case M.ATTRIB_VALUE_CLOSED:
              K(ie) ? _.state = M.ATTRIB : ie === ">" ? Ye(_) : ie === "/" ? _.state = M.OPEN_TAG_SLASH : te(U, ie) ? (oe(_, "No whitespace between attributes"), _.attribName = ie, _.attribValue = "", _.state = M.ATTRIB_NAME) : oe(_, "Invalid attribute name");
              continue;
            case M.ATTRIB_VALUE_UNQUOTED:
              if (!se(ie)) {
                ie === "&" ? _.state = M.ATTRIB_VALUE_ENTITY_U : _.attribValue += ie;
                continue;
              }
              Ee(_), ie === ">" ? Ye(_) : _.state = M.ATTRIB;
              continue;
            case M.CLOSE_TAG:
              if (_.tagName)
                ie === ">" ? ze(_) : te(z, ie) ? _.tagName += ie : _.script ? (_.script += "</" + _.tagName, _.tagName = "", _.state = M.SCRIPT) : (K(ie) || oe(_, "Invalid tagname in closing tag"), _.state = M.CLOSE_TAG_SAW_WHITE);
              else {
                if (K(ie))
                  continue;
                me(U, ie) ? _.script ? (_.script += "</" + ie, _.state = M.SCRIPT) : oe(_, "Invalid tagname in closing tag.") : _.tagName = ie;
              }
              continue;
            case M.CLOSE_TAG_SAW_WHITE:
              if (K(ie))
                continue;
              ie === ">" ? ze(_) : oe(_, "Invalid characters in closing tag");
              continue;
            case M.TEXT_ENTITY:
            case M.ATTRIB_VALUE_ENTITY_Q:
            case M.ATTRIB_VALUE_ENTITY_U:
              var j, ue;
              switch (_.state) {
                case M.TEXT_ENTITY:
                  j = M.TEXT, ue = "textNode";
                  break;
                case M.ATTRIB_VALUE_ENTITY_Q:
                  j = M.ATTRIB_VALUE_QUOTED, ue = "attribValue";
                  break;
                case M.ATTRIB_VALUE_ENTITY_U:
                  j = M.ATTRIB_VALUE_UNQUOTED, ue = "attribValue";
                  break;
              }
              if (ie === ";") {
                var fe = un(_);
                _.opt.unparsedEntities && !Object.values(l.XML_ENTITIES).includes(fe) ? (_.entity = "", _.state = j, _.write(fe)) : (_[ue] += fe, _.entity = "", _.state = j);
              } else te(_.entity.length ? B : X, ie) ? _.entity += ie : (oe(_, "Invalid character in entity name"), _[ue] += "&" + _.entity + ie, _.entity = "", _.state = j);
              continue;
            default:
              throw new Error(_, "Unknown state: " + _.state);
          }
        return _.position >= _.bufferCheckPosition && s(_), _;
      }
      String.fromCodePoint || function() {
        var k = String.fromCharCode, _ = Math.floor, Z = function() {
          var ie = 16384, Qe = [], Oe, j, ue = -1, fe = arguments.length;
          if (!fe)
            return "";
          for (var Te = ""; ++ue < fe; ) {
            var Le = Number(arguments[ue]);
            if (!isFinite(Le) || // `NaN`, `+Infinity`, or `-Infinity`
            Le < 0 || // not a valid Unicode code point
            Le > 1114111 || // not a valid Unicode code point
            _(Le) !== Le)
              throw RangeError("Invalid code point: " + Le);
            Le <= 65535 ? Qe.push(Le) : (Le -= 65536, Oe = (Le >> 10) + 55296, j = Le % 1024 + 56320, Qe.push(Oe, j)), (ue + 1 === fe || Qe.length > ie) && (Te += k.apply(null, Qe), Qe.length = 0);
          }
          return Te;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: Z,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = Z;
      }();
    })(e);
  }(Yd)), Yd;
}
var Vw = kw();
const Qr = {};
function Bw(e) {
  const { parentId: l, child: i } = e;
  Qr[l] || (Qr[l] = []);
  const a = {
    id: i.id,
    tagName: i.tagName
  };
  Qr[l].push(a);
}
function Zw(e) {
  const { currentBatch: l } = e, i = [...l];
  for (const [a, s] of i.entries()) {
    const o = Qr[s.id] || [];
    o.length > 0 && (i[a].children.push(...o), Uw({
      parentId: s.id
    }));
  }
  return i;
}
function Uw(e) {
  const { parentId: l } = e;
  delete Qr[l];
}
function Kw(e) {
  return "prefix" in e && "uri" in e && !!e.prefix && !!e.uri;
}
const Gw = [
  ".fsd",
  ".asd",
  ".ssd",
  ".scd",
  ".isd",
  ".icd",
  ".xml"
], rc = "sclElements", Vo = "id, tagName, &attributes.uuid, &attributes.id, attributes.name, parent.id, parent.tagName, *children.id, *children.tagName", Bo = "attachedFiles", Jd = "id, filename, file", zw = {
  default: {
    prefix: "",
    uri: "http://www.iec.ch/61850/2003/SCL"
  }
};
function jw() {
  let e = {
    defaultNamespace: null,
    stack: [],
    recordsBatch: []
  };
  const l = Vw.parser(
    !0,
    // strict mode
    {
      lowercase: !1,
      // Preserve case
      trim: !0,
      // Trim text nodes
      normalize: !0,
      // Normalize whitespace
      position: !1,
      // Don't track position (performance boost)
      xmlns: !0
      // Enable namespace handling
    }
  );
  l.onopentag = (s) => e = Hw({ node: s, state: e }), l.ontext = (s) => e = $w({ text: s, state: e }), l.onclosetag = () => ({ updatedState: e } = Ww({
    state: e
  })), l.onerror = Yw;
  function i() {
    const s = e.recordsBatch;
    return e.recordsBatch = [], s;
  }
  function a() {
    return e.recordsBatch.length;
  }
  return {
    parser: l,
    drainBatch: i,
    getSize: a
  };
}
function Hw(e) {
  const { node: l, state: i } = e, a = { ...i }, s = Xw(l);
  a.defaultNamespace || (a.defaultNamespace = Qw(l));
  const o = Jw(l, a.defaultNamespace), m = eS(l.attributes), d = nS(i.stack), h = {
    id: crypto.randomUUID(),
    tagName: s,
    namespace: o,
    attributes: m,
    value: "",
    parent: d,
    children: []
  };
  return a.stack.push(h), a;
}
function $w(e) {
  const { text: l, state: i } = e;
  return l && i.stack.length > 0 && (i.stack[i.stack.length - 1].value += l), i;
}
function Ww(e) {
  const { state: l } = e, i = l.stack.at(-1);
  let a = l.stack.slice(0, -1);
  const s = [...l.recordsBatch];
  if (i) {
    if (a.length) {
      const o = a.length - 1;
      a = a.map(
        (m, d) => d === o ? {
          ...m,
          children: [
            ...m.children,
            { id: i.id, tagName: i.tagName }
          ]
        } : m
      );
    } else i.parent && Bw({
      parentId: i.parent.id,
      child: { id: i.id, tagName: i.tagName }
    });
    s.push(i);
  }
  return {
    updatedState: {
      defaultNamespace: l.defaultNamespace,
      stack: a,
      recordsBatch: s
    }
  };
}
function Yw(e) {
  return new Error(`XML parsing error: ${e}`);
}
function Xw(e) {
  return e.local || null;
}
function Qw(e) {
  if (e.name !== "SCL") throw new Error("Default namespace can only be set on SCL element");
  return e.attributes?.xmlns?.value ? {
    prefix: "",
    uri: e.attributes.xmlns.value
  } : zw.default;
}
function Jw(e, l) {
  return Kw(e) ? {
    prefix: e.prefix,
    uri: e.uri
  } : l;
}
function eS(e) {
  return Object.values(e).map((l) => {
    const i = l.prefix && l.uri ? {
      prefix: l.prefix,
      uri: l.uri
    } : void 0;
    return {
      name: i ? l.local : l.name,
      value: l.value,
      ...i && { namespace: i }
    };
  });
}
function nS(e) {
  if (e.length === 0) return null;
  const l = e[e.length - 1];
  return l ? { id: l.id, tagName: l.tagName } : null;
}
var Fm = { exports: {} }, lS = Fm.exports, ep;
function tS() {
  return ep || (ep = 1, function(e, l) {
    (function(i, a) {
      e.exports = a();
    })(lS, function() {
      var i = function(n, t) {
        return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(u, r) {
          u.__proto__ = r;
        } || function(u, r) {
          for (var c in r) Object.prototype.hasOwnProperty.call(r, c) && (u[c] = r[c]);
        })(n, t);
      }, a = function() {
        return (a = Object.assign || function(n) {
          for (var t, u = 1, r = arguments.length; u < r; u++) for (var c in t = arguments[u]) Object.prototype.hasOwnProperty.call(t, c) && (n[c] = t[c]);
          return n;
        }).apply(this, arguments);
      };
      function s(n, t, u) {
        for (var r, c = 0, f = t.length; c < f; c++) !r && c in t || ((r = r || Array.prototype.slice.call(t, 0, c))[c] = t[c]);
        return n.concat(r || Array.prototype.slice.call(t));
      }
      var o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Ew, m = Object.keys, d = Array.isArray;
      function h(n, t) {
        return typeof t != "object" || m(t).forEach(function(u) {
          n[u] = t[u];
        }), n;
      }
      typeof Promise > "u" || o.Promise || (o.Promise = Promise);
      var x = Object.getPrototypeOf, y = {}.hasOwnProperty;
      function I(n, t) {
        return y.call(n, t);
      }
      function q(n, t) {
        typeof t == "function" && (t = t(x(n))), (typeof Reflect > "u" ? m : Reflect.ownKeys)(t).forEach(function(u) {
          R(n, u, t[u]);
        });
      }
      var A = Object.defineProperty;
      function R(n, t, u, r) {
        A(n, t, h(u && I(u, "get") && typeof u.get == "function" ? { get: u.get, set: u.set, configurable: !0 } : { value: u, configurable: !0, writable: !0 }, r));
      }
      function V(n) {
        return { from: function(t) {
          return n.prototype = Object.create(t.prototype), R(n.prototype, "constructor", n), { extend: q.bind(null, n.prototype) };
        } };
      }
      var U = Object.getOwnPropertyDescriptor, z = [].slice;
      function X(n, t, u) {
        return z.call(n, t, u);
      }
      function B(n, t) {
        return t(n);
      }
      function K(n) {
        if (!n) throw new Error("Assertion Failed");
      }
      function W(n) {
        o.setImmediate ? setImmediate(n) : setTimeout(n, 0);
      }
      function se(n, t) {
        if (typeof t == "string" && I(n, t)) return n[t];
        if (!t) return n;
        if (typeof t != "string") {
          for (var u = [], r = 0, c = t.length; r < c; ++r) {
            var f = se(n, t[r]);
            u.push(f);
          }
          return u;
        }
        var p = t.indexOf(".");
        if (p !== -1) {
          var g = n[t.substr(0, p)];
          return g == null ? void 0 : se(g, t.substr(p + 1));
        }
      }
      function te(n, t, u) {
        if (n && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(n))) if (typeof t != "string" && "length" in t) {
          K(typeof u != "string" && "length" in u);
          for (var r = 0, c = t.length; r < c; ++r) te(n, t[r], u[r]);
        } else {
          var f, p, g = t.indexOf(".");
          g !== -1 ? (f = t.substr(0, g), (p = t.substr(g + 1)) === "" ? u === void 0 ? d(n) && !isNaN(parseInt(f)) ? n.splice(f, 1) : delete n[f] : n[f] = u : te(g = !(g = n[f]) || !I(n, f) ? n[f] = {} : g, p, u)) : u === void 0 ? d(n) && !isNaN(parseInt(t)) ? n.splice(t, 1) : delete n[t] : n[t] = u;
        }
      }
      function me(n) {
        var t, u = {};
        for (t in n) I(n, t) && (u[t] = n[t]);
        return u;
      }
      var M = [].concat;
      function ce(n) {
        return M.apply([], n);
      }
      var Ue = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(ce([8, 16, 32, 64].map(function(n) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + n + "Array";
        });
      }))).filter(function(n) {
        return o[n];
      }), Ie = new Set(Ue.map(function(n) {
        return o[n];
      })), ae = null;
      function ve(n) {
        return ae = /* @__PURE__ */ new WeakMap(), n = function t(u) {
          if (!u || typeof u != "object") return u;
          var r = ae.get(u);
          if (r) return r;
          if (d(u)) {
            r = [], ae.set(u, r);
            for (var c = 0, f = u.length; c < f; ++c) r.push(t(u[c]));
          } else if (Ie.has(u.constructor)) r = u;
          else {
            var p, g = x(u);
            for (p in r = g === Object.prototype ? {} : Object.create(g), ae.set(u, r), u) I(u, p) && (r[p] = t(u[p]));
          }
          return r;
        }(n), ae = null, n;
      }
      var ye = {}.toString;
      function Se(n) {
        return ye.call(n).slice(8, -1);
      }
      var ge = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", oe = typeof ge == "symbol" ? function(n) {
        var t;
        return n != null && (t = n[ge]) && t.apply(n);
      } : function() {
        return null;
      };
      function de(n, t) {
        return t = n.indexOf(t), 0 <= t && n.splice(t, 1), 0 <= t;
      }
      var De = {};
      function Ee(n) {
        var t, u, r, c;
        if (arguments.length === 1) {
          if (d(n)) return n.slice();
          if (this === De && typeof n == "string") return [n];
          if (c = oe(n)) {
            for (u = []; !(r = c.next()).done; ) u.push(r.value);
            return u;
          }
          if (n == null) return [n];
          if (typeof (t = n.length) != "number") return [n];
          for (u = new Array(t); t--; ) u[t] = n[t];
          return u;
        }
        for (t = arguments.length, u = new Array(t); t--; ) u[t] = arguments[t];
        return u;
      }
      var Ye = typeof Symbol < "u" ? function(n) {
        return n[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ze = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], In = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ze), ze = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function un(n, t) {
        this.name = n, this.message = t;
      }
      function Pn(n, t) {
        return n + ". Errors: " + Object.keys(t).map(function(u) {
          return t[u].toString();
        }).filter(function(u, r, c) {
          return c.indexOf(u) === r;
        }).join(`
`);
      }
      function xn(n, t, u, r) {
        this.failures = t, this.failedKeys = r, this.successCount = u, this.message = Pn(n, t);
      }
      function tn(n, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(u) {
          return t[u];
        }), this.failuresByPos = t, this.message = Pn(n, this.failures);
      }
      V(un).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), V(xn).from(un), V(tn).from(un);
      var k = In.reduce(function(n, t) {
        return n[t] = t + "Error", n;
      }, {}), _ = un, Z = In.reduce(function(n, t) {
        var u = t + "Error";
        function r(c, f) {
          this.name = u, c ? typeof c == "string" ? (this.message = "".concat(c).concat(f ? `
 ` + f : ""), this.inner = f || null) : typeof c == "object" && (this.message = "".concat(c.name, " ").concat(c.message), this.inner = c) : (this.message = ze[t] || u, this.inner = null);
        }
        return V(r).from(_), n[t] = r, n;
      }, {});
      Z.Syntax = SyntaxError, Z.Type = TypeError, Z.Range = RangeError;
      var ie = Ze.reduce(function(n, t) {
        return n[t + "Error"] = Z[t], n;
      }, {}), Qe = In.reduce(function(n, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (n[t + "Error"] = Z[t]), n;
      }, {});
      function Oe() {
      }
      function j(n) {
        return n;
      }
      function ue(n, t) {
        return n == null || n === j ? t : function(u) {
          return t(n(u));
        };
      }
      function fe(n, t) {
        return function() {
          n.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function Te(n, t) {
        return n === Oe ? t : function() {
          var u = n.apply(this, arguments);
          u !== void 0 && (arguments[0] = u);
          var r = this.onsuccess, c = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var f = t.apply(this, arguments);
          return r && (this.onsuccess = this.onsuccess ? fe(r, this.onsuccess) : r), c && (this.onerror = this.onerror ? fe(c, this.onerror) : c), f !== void 0 ? f : u;
        };
      }
      function Le(n, t) {
        return n === Oe ? t : function() {
          n.apply(this, arguments);
          var u = this.onsuccess, r = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), u && (this.onsuccess = this.onsuccess ? fe(u, this.onsuccess) : u), r && (this.onerror = this.onerror ? fe(r, this.onerror) : r);
        };
      }
      function we(n, t) {
        return n === Oe ? t : function(u) {
          var r = n.apply(this, arguments);
          h(u, r);
          var c = this.onsuccess, f = this.onerror;
          return this.onsuccess = null, this.onerror = null, u = t.apply(this, arguments), c && (this.onsuccess = this.onsuccess ? fe(c, this.onsuccess) : c), f && (this.onerror = this.onerror ? fe(f, this.onerror) : f), r === void 0 ? u === void 0 ? void 0 : u : h(r, u);
        };
      }
      function Ne(n, t) {
        return n === Oe ? t : function() {
          return t.apply(this, arguments) !== !1 && n.apply(this, arguments);
        };
      }
      function _e(n, t) {
        return n === Oe ? t : function() {
          var u = n.apply(this, arguments);
          if (u && typeof u.then == "function") {
            for (var r = this, c = arguments.length, f = new Array(c); c--; ) f[c] = arguments[c];
            return u.then(function() {
              return t.apply(r, f);
            });
          }
          return t.apply(this, arguments);
        };
      }
      Qe.ModifyError = xn, Qe.DexieError = un, Qe.BulkError = tn;
      var be = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function Pe(n) {
        be = n;
      }
      var Ke = {}, ke = 100, Ue = typeof Promise > "u" ? [] : function() {
        var n = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [n, x(n), n];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, x(t), n];
      }(), Ze = Ue[0], In = Ue[1], Ue = Ue[2], In = In && In.then, Je = Ze && Ze.constructor, yn = !!Ue, on = function(n, t) {
        Fn.push([n, t]), Cn && (queueMicrotask(nr), Cn = !1);
      }, Bn = !0, Cn = !0, Dn = [], Nn = [], yl = j, An = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: Oe, pgp: !1, env: {}, finalize: Oe }, re = An, Fn = [], Zn = 0, Il = [];
      function ee(n) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = re;
        if (typeof n != "function") {
          if (n !== Ke) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && qt(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function u(r, c) {
          try {
            c(function(f) {
              if (r._state === null) {
                if (f === r) throw new TypeError("A promise cannot be resolved with itself.");
                var p = r._lib && rl();
                f && typeof f.then == "function" ? u(r, function(g, L) {
                  f instanceof ee ? f._then(g, L) : f.then(g, L);
                }) : (r._state = !0, r._value = f, Xi(r)), p && sl();
              }
            }, qt.bind(null, r));
          } catch (f) {
            qt(r, f);
          }
        }(this, n);
      }
      var Pt = { get: function() {
        var n = re, t = Hl;
        function u(r, c) {
          var f = this, p = !n.global && (n !== re || t !== Hl), g = p && !Kn(), L = new ee(function(O, w) {
            At(f, new Yi(Ji(r, n, p, g), Ji(c, n, p, g), O, w, n));
          });
          return this._consoleTask && (L._consoleTask = this._consoleTask), L;
        }
        return u.prototype = Ke, u;
      }, set: function(n) {
        R(this, "then", n && n.prototype === Ke ? Pt : { get: function() {
          return n;
        }, set: Pt.set });
      } };
      function Yi(n, t, u, r, c) {
        this.onFulfilled = typeof n == "function" ? n : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = u, this.reject = r, this.psd = c;
      }
      function qt(n, t) {
        var u, r;
        Nn.push(t), n._state === null && (u = n._lib && rl(), t = yl(t), n._state = !1, n._value = t, r = n, Dn.some(function(c) {
          return c._value === r._value;
        }) || Dn.push(r), Xi(n), u && sl());
      }
      function Xi(n) {
        var t = n._listeners;
        n._listeners = [];
        for (var u = 0, r = t.length; u < r; ++u) At(n, t[u]);
        var c = n._PSD;
        --c.ref || c.finalize(), Zn === 0 && (++Zn, on(function() {
          --Zn == 0 && Rt();
        }, []));
      }
      function At(n, t) {
        if (n._state !== null) {
          var u = n._state ? t.onFulfilled : t.onRejected;
          if (u === null) return (n._state ? t.resolve : t.reject)(n._value);
          ++t.psd.ref, ++Zn, on(er, [u, n, t]);
        } else n._listeners.push(t);
      }
      function er(n, t, u) {
        try {
          var r, c = t._value;
          !t._state && Nn.length && (Nn = []), r = be && t._consoleTask ? t._consoleTask.run(function() {
            return n(c);
          }) : n(c), t._state || Nn.indexOf(c) !== -1 || function(f) {
            for (var p = Dn.length; p; ) if (Dn[--p]._value === f._value) return Dn.splice(p, 1);
          }(t), u.resolve(r);
        } catch (f) {
          u.reject(f);
        } finally {
          --Zn == 0 && Rt(), --u.psd.ref || u.psd.finalize();
        }
      }
      function nr() {
        Qn(An, function() {
          rl() && sl();
        });
      }
      function rl() {
        var n = Bn;
        return Cn = Bn = !1, n;
      }
      function sl() {
        var n, t, u;
        do
          for (; 0 < Fn.length; ) for (n = Fn, Fn = [], u = n.length, t = 0; t < u; ++t) {
            var r = n[t];
            r[0].apply(null, r[1]);
          }
        while (0 < Fn.length);
        Cn = Bn = !0;
      }
      function Rt() {
        var n = Dn;
        Dn = [], n.forEach(function(r) {
          r._PSD.onunhandled.call(null, r._value, r);
        });
        for (var t = Il.slice(0), u = t.length; u; ) t[--u]();
      }
      function Gl(n) {
        return new ee(Ke, !1, n);
      }
      function Be(n, t) {
        var u = re;
        return function() {
          var r = rl(), c = re;
          try {
            return Gn(u, !0), n.apply(this, arguments);
          } catch (f) {
            t && t(f);
          } finally {
            Gn(c, !1), r && sl();
          }
        };
      }
      q(ee.prototype, { then: Pt, _then: function(n, t) {
        At(this, new Yi(null, null, n, t, re));
      }, catch: function(n) {
        if (arguments.length === 1) return this.then(null, n);
        var t = n, u = arguments[1];
        return typeof t == "function" ? this.then(null, function(r) {
          return (r instanceof t ? u : Gl)(r);
        }) : this.then(null, function(r) {
          return (r && r.name === t ? u : Gl)(r);
        });
      }, finally: function(n) {
        return this.then(function(t) {
          return ee.resolve(n()).then(function() {
            return t;
          });
        }, function(t) {
          return ee.resolve(n()).then(function() {
            return Gl(t);
          });
        });
      }, timeout: function(n, t) {
        var u = this;
        return n < 1 / 0 ? new ee(function(r, c) {
          var f = setTimeout(function() {
            return c(new Z.Timeout(t));
          }, n);
          u.then(r, c).finally(clearTimeout.bind(null, f));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && R(ee.prototype, Symbol.toStringTag, "Dexie.Promise"), An.env = Qi(), q(ee, { all: function() {
        var n = Ee.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.length === 0 && t([]);
          var r = n.length;
          n.forEach(function(c, f) {
            return ee.resolve(c).then(function(p) {
              n[f] = p, --r || t(n);
            }, u);
          });
        });
      }, resolve: function(n) {
        return n instanceof ee ? n : n && typeof n.then == "function" ? new ee(function(t, u) {
          n.then(t, u);
        }) : new ee(Ke, !0, n);
      }, reject: Gl, race: function() {
        var n = Ee.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.map(function(r) {
            return ee.resolve(r).then(t, u);
          });
        });
      }, PSD: { get: function() {
        return re;
      }, set: function(n) {
        return re = n;
      } }, totalEchoes: { get: function() {
        return Hl;
      } }, newPSD: Un, usePSD: Qn, scheduler: { get: function() {
        return on;
      }, set: function(n) {
        on = n;
      } }, rejectionMapper: { get: function() {
        return yl;
      }, set: function(n) {
        yl = n;
      } }, follow: function(n, t) {
        return new ee(function(u, r) {
          return Un(function(c, f) {
            var p = re;
            p.unhandleds = [], p.onunhandled = f, p.finalize = fe(function() {
              var g, L = this;
              g = function() {
                L.unhandleds.length === 0 ? c() : f(L.unhandleds[0]);
              }, Il.push(function O() {
                g(), Il.splice(Il.indexOf(O), 1);
              }), ++Zn, on(function() {
                --Zn == 0 && Rt();
              }, []);
            }, p.finalize), n();
          }, t, u, r);
        });
      } }), Je && (Je.allSettled && R(ee, "allSettled", function() {
        var n = Ee.apply(null, arguments).map($l);
        return new ee(function(t) {
          n.length === 0 && t([]);
          var u = n.length, r = new Array(u);
          n.forEach(function(c, f) {
            return ee.resolve(c).then(function(p) {
              return r[f] = { status: "fulfilled", value: p };
            }, function(p) {
              return r[f] = { status: "rejected", reason: p };
            }).then(function() {
              return --u || t(r);
            });
          });
        });
      }), Je.any && typeof AggregateError < "u" && R(ee, "any", function() {
        var n = Ee.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.length === 0 && u(new AggregateError([]));
          var r = n.length, c = new Array(r);
          n.forEach(function(f, p) {
            return ee.resolve(f).then(function(g) {
              return t(g);
            }, function(g) {
              c[p] = g, --r || u(new AggregateError(c));
            });
          });
        });
      }), Je.withResolvers && (ee.withResolvers = Je.withResolvers));
      var en = { awaits: 0, echoes: 0, id: 0 }, lr = 0, zl = [], jl = 0, Hl = 0, tr = 0;
      function Un(n, t, u, r) {
        var c = re, f = Object.create(c);
        return f.parent = c, f.ref = 0, f.global = !1, f.id = ++tr, An.env, f.env = yn ? { Promise: ee, PromiseProp: { value: ee, configurable: !0, writable: !0 }, all: ee.all, race: ee.race, allSettled: ee.allSettled, any: ee.any, resolve: ee.resolve, reject: ee.reject } : {}, t && h(f, t), ++c.ref, f.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, r = Qn(f, n, u, r), f.ref === 0 && f.finalize(), r;
      }
      function cl() {
        return en.id || (en.id = ++lr), ++en.awaits, en.echoes += ke, en.id;
      }
      function Kn() {
        return !!en.awaits && (--en.awaits == 0 && (en.id = 0), en.echoes = en.awaits * ke, !0);
      }
      function $l(n) {
        return en.echoes && n && n.constructor === Je ? (cl(), n.then(function(t) {
          return Kn(), t;
        }, function(t) {
          return Kn(), He(t);
        })) : n;
      }
      function ir() {
        var n = zl[zl.length - 1];
        zl.pop(), Gn(n, !1);
      }
      function Gn(n, t) {
        var u, r = re;
        (t ? !en.echoes || jl++ && n === re : !jl || --jl && n === re) || queueMicrotask(t ? (function(c) {
          ++Hl, en.echoes && --en.echoes != 0 || (en.echoes = en.awaits = en.id = 0), zl.push(re), Gn(c, !0);
        }).bind(null, n) : ir), n !== re && (re = n, r === An && (An.env = Qi()), yn && (u = An.env.Promise, t = n.env, (r.global || n.global) && (Object.defineProperty(o, "Promise", t.PromiseProp), u.all = t.all, u.race = t.race, u.resolve = t.resolve, u.reject = t.reject, t.allSettled && (u.allSettled = t.allSettled), t.any && (u.any = t.any))));
      }
      function Qi() {
        var n = o.Promise;
        return yn ? { Promise: n, PromiseProp: Object.getOwnPropertyDescriptor(o, "Promise"), all: n.all, race: n.race, allSettled: n.allSettled, any: n.any, resolve: n.resolve, reject: n.reject } : {};
      }
      function Qn(n, t, u, r, c) {
        var f = re;
        try {
          return Gn(n, !0), t(u, r, c);
        } finally {
          Gn(f, !1);
        }
      }
      function Ji(n, t, u, r) {
        return typeof n != "function" ? n : function() {
          var c = re;
          u && cl(), Gn(t, !0);
          try {
            return n.apply(this, arguments);
          } finally {
            Gn(c, !1), r && queueMicrotask(Kn);
          }
        };
      }
      function Et(n) {
        Promise === Je && en.echoes === 0 ? jl === 0 ? n() : enqueueNativeMicroTask(n) : setTimeout(n, 0);
      }
      ("" + In).indexOf("[native code]") === -1 && (cl = Kn = Oe);
      var He = ee.reject, Jn = "", Rn = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", eu = "String expected.", ol = [], Wl = "__dbnames", _t = "readonly", Nt = "readwrite";
      function el(n, t) {
        return n ? t ? function() {
          return n.apply(this, arguments) && t.apply(this, arguments);
        } : n : t;
      }
      var nu = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Yl(n) {
        return typeof n != "string" || /\./.test(n) ? function(t) {
          return t;
        } : function(t) {
          return t[n] === void 0 && n in t && delete (t = ve(t))[n], t;
        };
      }
      function lu() {
        throw Z.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Ce(n, t) {
        try {
          var u = tu(n), r = tu(t);
          if (u !== r) return u === "Array" ? 1 : r === "Array" ? -1 : u === "binary" ? 1 : r === "binary" ? -1 : u === "string" ? 1 : r === "string" ? -1 : u === "Date" ? 1 : r !== "Date" ? NaN : -1;
          switch (u) {
            case "number":
            case "Date":
            case "string":
              return t < n ? 1 : n < t ? -1 : 0;
            case "binary":
              return function(c, f) {
                for (var p = c.length, g = f.length, L = p < g ? p : g, O = 0; O < L; ++O) if (c[O] !== f[O]) return c[O] < f[O] ? -1 : 1;
                return p === g ? 0 : p < g ? -1 : 1;
              }(iu(n), iu(t));
            case "Array":
              return function(c, f) {
                for (var p = c.length, g = f.length, L = p < g ? p : g, O = 0; O < L; ++O) {
                  var w = Ce(c[O], f[O]);
                  if (w !== 0) return w;
                }
                return p === g ? 0 : p < g ? -1 : 1;
              }(n, t);
          }
        } catch {
        }
        return NaN;
      }
      function tu(n) {
        var t = typeof n;
        return t != "object" ? t : ArrayBuffer.isView(n) ? "binary" : (n = Se(n), n === "ArrayBuffer" ? "binary" : n);
      }
      function iu(n) {
        return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n);
      }
      function Xl(n, t, u) {
        var r = n.schema.yProps;
        return r ? (t && 0 < u.numFailures && (t = t.filter(function(c, f) {
          return !u.failures[f];
        })), Promise.all(r.map(function(c) {
          return c = c.updatesTable, t ? n.db.table(c).where("k").anyOf(t).delete() : n.db.table(c).clear();
        })).then(function() {
          return u;
        })) : u;
      }
      var uu = (Ve.prototype._trans = function(n, t, u) {
        var r = this._tx || re.trans, c = this.name, f = be && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(n === "readonly" ? "read" : "write", " ").concat(this.name));
        function p(O, w, v) {
          if (!v.schema[c]) throw new Z.NotFound("Table " + c + " not part of transaction");
          return t(v.idbtrans, v);
        }
        var g = rl();
        try {
          var L = r && r.db._novip === this.db._novip ? r === re.trans ? r._promise(n, p, u) : Un(function() {
            return r._promise(n, p, u);
          }, { trans: r, transless: re.transless || re }) : function O(w, v, T, D) {
            if (w.idbdb && (w._state.openComplete || re.letThrough || w._vip)) {
              var b = w._createTransaction(v, T, w._dbSchema);
              try {
                b.create(), w._state.PR1398_maxLoop = 3;
              } catch (C) {
                return C.name === k.InvalidState && w.isOpen() && 0 < --w._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), w.close({ disableAutoOpen: !1 }), w.open().then(function() {
                  return O(w, v, T, D);
                })) : He(C);
              }
              return b._promise(v, function(C, S) {
                return Un(function() {
                  return re.trans = b, D(C, S, b);
                });
              }).then(function(C) {
                if (v === "readwrite") try {
                  b.idbtrans.commit();
                } catch {
                }
                return v === "readonly" ? C : b._completion.then(function() {
                  return C;
                });
              });
            }
            if (w._state.openComplete) return He(new Z.DatabaseClosed(w._state.dbOpenError));
            if (!w._state.isBeingOpened) {
              if (!w._state.autoOpen) return He(new Z.DatabaseClosed());
              w.open().catch(Oe);
            }
            return w._state.dbReadyPromise.then(function() {
              return O(w, v, T, D);
            });
          }(this.db, n, [this.name], p);
          return f && (L._consoleTask = f, L = L.catch(function(O) {
            return console.trace(O), He(O);
          })), L;
        } finally {
          g && sl();
        }
      }, Ve.prototype.get = function(n, t) {
        var u = this;
        return n && n.constructor === Object ? this.where(n).first(t) : n == null ? He(new Z.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(r) {
          return u.core.get({ trans: r, key: n }).then(function(c) {
            return u.hook.reading.fire(c);
          });
        }).then(t);
      }, Ve.prototype.where = function(n) {
        if (typeof n == "string") return new this.db.WhereClause(this, n);
        if (d(n)) return new this.db.WhereClause(this, "[".concat(n.join("+"), "]"));
        var t = m(n);
        if (t.length === 1) return this.where(t[0]).equals(n[t[0]]);
        var u = this.schema.indexes.concat(this.schema.primKey).filter(function(g) {
          if (g.compound && t.every(function(O) {
            return 0 <= g.keyPath.indexOf(O);
          })) {
            for (var L = 0; L < t.length; ++L) if (t.indexOf(g.keyPath[L]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(g, L) {
          return g.keyPath.length - L.keyPath.length;
        })[0];
        if (u && this.db._maxKey !== Jn) {
          var f = u.keyPath.slice(0, t.length);
          return this.where(f).equals(f.map(function(L) {
            return n[L];
          }));
        }
        !u && be && console.warn("The query ".concat(JSON.stringify(n), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var r = this.schema.idxByName;
        function c(g, L) {
          return Ce(g, L) === 0;
        }
        var p = t.reduce(function(v, L) {
          var O = v[0], w = v[1], v = r[L], T = n[L];
          return [O || v, O || !v ? el(w, v && v.multi ? function(D) {
            return D = se(D, L), d(D) && D.some(function(b) {
              return c(T, b);
            });
          } : function(D) {
            return c(T, se(D, L));
          }) : w];
        }, [null, null]), f = p[0], p = p[1];
        return f ? this.where(f.name).equals(n[f.keyPath]).filter(p) : u ? this.filter(p) : this.where(t).equals("");
      }, Ve.prototype.filter = function(n) {
        return this.toCollection().and(n);
      }, Ve.prototype.count = function(n) {
        return this.toCollection().count(n);
      }, Ve.prototype.offset = function(n) {
        return this.toCollection().offset(n);
      }, Ve.prototype.limit = function(n) {
        return this.toCollection().limit(n);
      }, Ve.prototype.each = function(n) {
        return this.toCollection().each(n);
      }, Ve.prototype.toArray = function(n) {
        return this.toCollection().toArray(n);
      }, Ve.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ve.prototype.orderBy = function(n) {
        return new this.db.Collection(new this.db.WhereClause(this, d(n) ? "[".concat(n.join("+"), "]") : n));
      }, Ve.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ve.prototype.mapToClass = function(n) {
        var t, u = this.db, r = this.name;
        function c() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = n).prototype instanceof lu && (function(L, O) {
          if (typeof O != "function" && O !== null) throw new TypeError("Class extends value " + String(O) + " is not a constructor or null");
          function w() {
            this.constructor = L;
          }
          i(L, O), L.prototype = O === null ? Object.create(O) : (w.prototype = O.prototype, new w());
        }(c, t = n), Object.defineProperty(c.prototype, "db", { get: function() {
          return u;
        }, enumerable: !1, configurable: !0 }), c.prototype.table = function() {
          return r;
        }, n = c);
        for (var f = /* @__PURE__ */ new Set(), p = n.prototype; p; p = x(p)) Object.getOwnPropertyNames(p).forEach(function(L) {
          return f.add(L);
        });
        function g(L) {
          if (!L) return L;
          var O, w = Object.create(n.prototype);
          for (O in L) if (!f.has(O)) try {
            w[O] = L[O];
          } catch {
          }
          return w;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = g, this.hook("reading", g), n;
      }, Ve.prototype.defineClass = function() {
        return this.mapToClass(function(n) {
          h(this, n);
        });
      }, Ve.prototype.add = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, f = r.keyPath, p = n;
        return f && c && (p = Yl(f)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "add", keys: t != null ? [t] : null, values: [p] });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (f) try {
            te(n, f, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.update = function(n, t) {
        return typeof n != "object" || d(n) ? this.where(":id").equals(n).modify(t) : (n = se(n, this.schema.primKey.keyPath), n === void 0 ? He(new Z.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(n).modify(t));
      }, Ve.prototype.put = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, f = r.keyPath, p = n;
        return f && c && (p = Yl(f)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "put", values: [p], keys: t != null ? [t] : null });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (f) try {
            te(n, f, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.delete = function(n) {
        var t = this;
        return this._trans("readwrite", function(u) {
          return t.core.mutate({ trans: u, type: "delete", keys: [n] }).then(function(r) {
            return Xl(t, [n], r);
          }).then(function(r) {
            return r.numFailures ? ee.reject(r.failures[0]) : void 0;
          });
        });
      }, Ve.prototype.clear = function() {
        var n = this;
        return this._trans("readwrite", function(t) {
          return n.core.mutate({ trans: t, type: "deleteRange", range: nu }).then(function(u) {
            return Xl(n, null, u);
          });
        }).then(function(t) {
          return t.numFailures ? ee.reject(t.failures[0]) : void 0;
        });
      }, Ve.prototype.bulkGet = function(n) {
        var t = this;
        return this._trans("readonly", function(u) {
          return t.core.getMany({ keys: n, trans: u }).then(function(r) {
            return r.map(function(c) {
              return t.hook.reading.fire(c);
            });
          });
        });
      }, Ve.prototype.bulkAdd = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, f = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new Z.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new Z.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Yl(O)) : n;
          return r.core.mutate({ trans: p, type: "add", keys: c, values: O, wantResults: f }).then(function(b) {
            var v = b.numFailures, T = b.results, D = b.lastResult, b = b.failures;
            if (v === 0) return f ? T : D;
            throw new tn("".concat(r.name, ".bulkAdd(): ").concat(v, " of ").concat(L, " operations failed"), b);
          });
        });
      }, Ve.prototype.bulkPut = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, f = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new Z.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new Z.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Yl(O)) : n;
          return r.core.mutate({ trans: p, type: "put", keys: c, values: O, wantResults: f }).then(function(b) {
            var v = b.numFailures, T = b.results, D = b.lastResult, b = b.failures;
            if (v === 0) return f ? T : D;
            throw new tn("".concat(r.name, ".bulkPut(): ").concat(v, " of ").concat(L, " operations failed"), b);
          });
        });
      }, Ve.prototype.bulkUpdate = function(n) {
        var t = this, u = this.core, r = n.map(function(p) {
          return p.key;
        }), c = n.map(function(p) {
          return p.changes;
        }), f = [];
        return this._trans("readwrite", function(p) {
          return u.getMany({ trans: p, keys: r, cache: "clone" }).then(function(g) {
            var L = [], O = [];
            n.forEach(function(v, T) {
              var D = v.key, b = v.changes, C = g[T];
              if (C) {
                for (var S = 0, P = Object.keys(b); S < P.length; S++) {
                  var E = P[S], N = b[E];
                  if (E === t.schema.primKey.keyPath) {
                    if (Ce(N, D) !== 0) throw new Z.Constraint("Cannot update primary key in bulkUpdate()");
                  } else te(C, E, N);
                }
                f.push(T), L.push(D), O.push(C);
              }
            });
            var w = L.length;
            return u.mutate({ trans: p, type: "put", keys: L, values: O, updates: { keys: r, changeSpecs: c } }).then(function(v) {
              var T = v.numFailures, D = v.failures;
              if (T === 0) return w;
              for (var b = 0, C = Object.keys(D); b < C.length; b++) {
                var S, P = C[b], E = f[Number(P)];
                E != null && (S = D[P], delete D[P], D[E] = S);
              }
              throw new tn("".concat(t.name, ".bulkUpdate(): ").concat(T, " of ").concat(w, " operations failed"), D);
            });
          });
        });
      }, Ve.prototype.bulkDelete = function(n) {
        var t = this, u = n.length;
        return this._trans("readwrite", function(r) {
          return t.core.mutate({ trans: r, type: "delete", keys: n }).then(function(c) {
            return Xl(t, n, c);
          });
        }).then(function(p) {
          var c = p.numFailures, f = p.lastResult, p = p.failures;
          if (c === 0) return f;
          throw new tn("".concat(t.name, ".bulkDelete(): ").concat(c, " of ").concat(u, " operations failed"), p);
        });
      }, Ve);
      function Ve() {
      }
      function Ll(n) {
        function t(p, g) {
          if (g) {
            for (var L = arguments.length, O = new Array(L - 1); --L; ) O[L - 1] = arguments[L];
            return u[p].subscribe.apply(null, O), n;
          }
          if (typeof p == "string") return u[p];
        }
        var u = {};
        t.addEventType = f;
        for (var r = 1, c = arguments.length; r < c; ++r) f(arguments[r]);
        return t;
        function f(p, g, L) {
          if (typeof p != "object") {
            var O;
            g = g || Ne;
            var w = { subscribers: [], fire: L = L || Oe, subscribe: function(v) {
              w.subscribers.indexOf(v) === -1 && (w.subscribers.push(v), w.fire = g(w.fire, v));
            }, unsubscribe: function(v) {
              w.subscribers = w.subscribers.filter(function(T) {
                return T !== v;
              }), w.fire = w.subscribers.reduce(g, L);
            } };
            return u[p] = t[p] = w;
          }
          m(O = p).forEach(function(v) {
            var T = O[v];
            if (d(T)) f(v, O[v][0], O[v][1]);
            else {
              if (T !== "asap") throw new Z.InvalidArgument("Invalid event config");
              var D = f(v, j, function() {
                for (var b = arguments.length, C = new Array(b); b--; ) C[b] = arguments[b];
                D.subscribers.forEach(function(S) {
                  W(function() {
                    S.apply(null, C);
                  });
                });
              });
            }
          });
        }
      }
      function Dl(n, t) {
        return V(t).from({ prototype: n }), t;
      }
      function ml(n, t) {
        return !(n.filter || n.algorithm || n.or) && (t ? n.justLimit : !n.replayFilter);
      }
      function Ft(n, t) {
        n.filter = el(n.filter, t);
      }
      function Mt(n, t, u) {
        var r = n.replayFilter;
        n.replayFilter = r ? function() {
          return el(r(), t());
        } : t, n.justLimit = u && !r;
      }
      function Ql(n, t) {
        if (n.isPrimKey) return t.primaryKey;
        var u = t.getIndexByKeyPath(n.index);
        if (!u) throw new Z.Schema("KeyPath " + n.index + " on object store " + t.name + " is not indexed");
        return u;
      }
      function au(n, t, u) {
        var r = Ql(n, t.schema);
        return t.openCursor({ trans: u, values: !n.keysOnly, reverse: n.dir === "prev", unique: !!n.unique, query: { index: r, range: n.range } });
      }
      function Jl(n, t, u, r) {
        var c = n.replayFilter ? el(n.filter, n.replayFilter()) : n.filter;
        if (n.or) {
          var f = {}, p = function(g, L, O) {
            var w, v;
            c && !c(L, O, function(T) {
              return L.stop(T);
            }, function(T) {
              return L.fail(T);
            }) || ((v = "" + (w = L.primaryKey)) == "[object ArrayBuffer]" && (v = "" + new Uint8Array(w)), I(f, v) || (f[v] = !0, t(g, L, O)));
          };
          return Promise.all([n.or._iterate(p, u), ru(au(n, r, u), n.algorithm, p, !n.keysOnly && n.valueMapper)]);
        }
        return ru(au(n, r, u), el(n.algorithm, c), t, !n.keysOnly && n.valueMapper);
      }
      function ru(n, t, u, r) {
        var c = Be(r ? function(f, p, g) {
          return u(r(f), p, g);
        } : u);
        return n.then(function(f) {
          if (f) return f.start(function() {
            var p = function() {
              return f.continue();
            };
            t && !t(f, function(g) {
              return p = g;
            }, function(g) {
              f.stop(g), p = Oe;
            }, function(g) {
              f.fail(g), p = Oe;
            }) || c(f.value, f, function(g) {
              return p = g;
            }), p();
          });
        });
      }
      var Ol = (su.prototype.execute = function(n) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var u = t.add;
          if (d(u)) return s(s([], d(n) ? n : [], !0), u).sort();
          if (typeof u == "number") return (Number(n) || 0) + u;
          if (typeof u == "bigint") try {
            return BigInt(n) + u;
          } catch {
            return BigInt(0) + u;
          }
          throw new TypeError("Invalid term ".concat(u));
        }
        if (t.remove !== void 0) {
          var r = t.remove;
          if (d(r)) return d(n) ? n.filter(function(c) {
            return !r.includes(c);
          }).sort() : [];
          if (typeof r == "number") return Number(n) - r;
          if (typeof r == "bigint") try {
            return BigInt(n) - r;
          } catch {
            return BigInt(0) - r;
          }
          throw new TypeError("Invalid subtrahend ".concat(r));
        }
        return u = (u = t.replacePrefix) === null || u === void 0 ? void 0 : u[0], u && typeof n == "string" && n.startsWith(u) ? t.replacePrefix[1] + n.substring(u.length) : n;
      }, su);
      function su(n) {
        this["@@propmod"] = n;
      }
      var ur = (Ae.prototype._read = function(n, t) {
        var u = this._ctx;
        return u.error ? u.table._trans(null, He.bind(null, u.error)) : u.table._trans("readonly", n).then(t);
      }, Ae.prototype._write = function(n) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, He.bind(null, t.error)) : t.table._trans("readwrite", n, "locked");
      }, Ae.prototype._addAlgorithm = function(n) {
        var t = this._ctx;
        t.algorithm = el(t.algorithm, n);
      }, Ae.prototype._iterate = function(n, t) {
        return Jl(this._ctx, n, t, this._ctx.table.core);
      }, Ae.prototype.clone = function(n) {
        var t = Object.create(this.constructor.prototype), u = Object.create(this._ctx);
        return n && h(u, n), t._ctx = u, t;
      }, Ae.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Ae.prototype.each = function(n) {
        var t = this._ctx;
        return this._read(function(u) {
          return Jl(t, n, u, t.table.core);
        });
      }, Ae.prototype.count = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx, c = r.table.core;
          if (ml(r, !0)) return c.count({ trans: u, query: { index: Ql(r, c.schema), range: r.range } }).then(function(p) {
            return Math.min(p, r.limit);
          });
          var f = 0;
          return Jl(r, function() {
            return ++f, !1;
          }, u, c).then(function() {
            return f;
          });
        }).then(n);
      }, Ae.prototype.sortBy = function(n, t) {
        var u = n.split(".").reverse(), r = u[0], c = u.length - 1;
        function f(L, O) {
          return O ? f(L[u[O]], O - 1) : L[r];
        }
        var p = this._ctx.dir === "next" ? 1 : -1;
        function g(L, O) {
          return Ce(f(L, c), f(O, c)) * p;
        }
        return this.toArray(function(L) {
          return L.sort(g);
        }).then(t);
      }, Ae.prototype.toArray = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx;
          if (r.dir === "next" && ml(r, !0) && 0 < r.limit) {
            var c = r.valueMapper, f = Ql(r, r.table.core.schema);
            return r.table.core.query({ trans: u, limit: r.limit, values: !0, query: { index: f, range: r.range } }).then(function(g) {
              return g = g.result, c ? g.map(c) : g;
            });
          }
          var p = [];
          return Jl(r, function(g) {
            return p.push(g);
          }, u, r.table.core).then(function() {
            return p;
          });
        }, n);
      }, Ae.prototype.offset = function(n) {
        var t = this._ctx;
        return n <= 0 || (t.offset += n, ml(t) ? Mt(t, function() {
          var u = n;
          return function(r, c) {
            return u === 0 || (u === 1 ? --u : c(function() {
              r.advance(u), u = 0;
            }), !1);
          };
        }) : Mt(t, function() {
          var u = n;
          return function() {
            return --u < 0;
          };
        })), this;
      }, Ae.prototype.limit = function(n) {
        return this._ctx.limit = Math.min(this._ctx.limit, n), Mt(this._ctx, function() {
          var t = n;
          return function(u, r, c) {
            return --t <= 0 && r(c), 0 <= t;
          };
        }, !0), this;
      }, Ae.prototype.until = function(n, t) {
        return Ft(this._ctx, function(u, r, c) {
          return !n(u.value) || (r(c), t);
        }), this;
      }, Ae.prototype.first = function(n) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(n);
      }, Ae.prototype.last = function(n) {
        return this.reverse().first(n);
      }, Ae.prototype.filter = function(n) {
        var t;
        return Ft(this._ctx, function(u) {
          return n(u.value);
        }), (t = this._ctx).isMatch = el(t.isMatch, n), this;
      }, Ae.prototype.and = function(n) {
        return this.filter(n);
      }, Ae.prototype.or = function(n) {
        return new this.db.WhereClause(this._ctx.table, n, this);
      }, Ae.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Ae.prototype.desc = function() {
        return this.reverse();
      }, Ae.prototype.eachKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.key, r);
        });
      }, Ae.prototype.eachUniqueKey = function(n) {
        return this._ctx.unique = "unique", this.eachKey(n);
      }, Ae.prototype.eachPrimaryKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.primaryKey, r);
        });
      }, Ae.prototype.keys = function(n) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.key);
        }).then(function() {
          return u;
        }).then(n);
      }, Ae.prototype.primaryKeys = function(n) {
        var t = this._ctx;
        if (t.dir === "next" && ml(t, !0) && 0 < t.limit) return this._read(function(r) {
          var c = Ql(t, t.table.core.schema);
          return t.table.core.query({ trans: r, values: !1, limit: t.limit, query: { index: c, range: t.range } });
        }).then(function(r) {
          return r.result;
        }).then(n);
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.primaryKey);
        }).then(function() {
          return u;
        }).then(n);
      }, Ae.prototype.uniqueKeys = function(n) {
        return this._ctx.unique = "unique", this.keys(n);
      }, Ae.prototype.firstKey = function(n) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(n);
      }, Ae.prototype.lastKey = function(n) {
        return this.reverse().firstKey(n);
      }, Ae.prototype.distinct = function() {
        var n = this._ctx, n = n.index && n.table.schema.idxByName[n.index];
        if (!n || !n.multi) return this;
        var t = {};
        return Ft(this._ctx, function(c) {
          var r = c.primaryKey.toString(), c = I(t, r);
          return t[r] = !0, !c;
        }), this;
      }, Ae.prototype.modify = function(n) {
        var t = this, u = this._ctx;
        return this._write(function(r) {
          var c, f, p;
          p = typeof n == "function" ? n : (c = m(n), f = c.length, function(P) {
            for (var E = !1, N = 0; N < f; ++N) {
              var F = c[N], G = n[F], Y = se(P, F);
              G instanceof Ol ? (te(P, F, G.execute(Y)), E = !0) : Y !== G && (te(P, F, G), E = !0);
            }
            return E;
          });
          var g = u.table.core, v = g.schema.primaryKey, L = v.outbound, O = v.extractKey, w = 200, v = t.db._options.modifyChunkSize;
          v && (w = typeof v == "object" ? v[g.name] || v["*"] || 200 : v);
          function T(P, F) {
            var N = F.failures, F = F.numFailures;
            b += P - F;
            for (var G = 0, Y = m(N); G < Y.length; G++) {
              var H = Y[G];
              D.push(N[H]);
            }
          }
          var D = [], b = 0, C = [], S = n === cu;
          return t.clone().primaryKeys().then(function(P) {
            function E(F) {
              var G = Math.min(w, P.length - F), Y = P.slice(F, F + G);
              return (S ? Promise.resolve([]) : g.getMany({ trans: r, keys: Y, cache: "immutable" })).then(function(H) {
                var $ = [], J = [], Q = L ? [] : null, ne = S ? Y : [];
                if (!S) for (var xe = 0; xe < G; ++xe) {
                  var qe = H[xe], he = { value: ve(qe), primKey: P[F + xe] };
                  p.call(he, he.value, he) !== !1 && (he.value == null ? ne.push(P[F + xe]) : L || Ce(O(qe), O(he.value)) === 0 ? (J.push(he.value), L && Q.push(P[F + xe])) : (ne.push(P[F + xe]), $.push(he.value)));
                }
                return Promise.resolve(0 < $.length && g.mutate({ trans: r, type: "add", values: $ }).then(function(Ge) {
                  for (var pe in Ge.failures) ne.splice(parseInt(pe), 1);
                  T($.length, Ge);
                })).then(function() {
                  return (0 < J.length || N && typeof n == "object") && g.mutate({ trans: r, type: "put", keys: Q, values: J, criteria: N, changeSpec: typeof n != "function" && n, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return T(J.length, Ge);
                  });
                }).then(function() {
                  return (0 < ne.length || N && S) && g.mutate({ trans: r, type: "delete", keys: ne, criteria: N, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return Xl(u.table, ne, Ge);
                  }).then(function(Ge) {
                    return T(ne.length, Ge);
                  });
                }).then(function() {
                  return P.length > F + G && E(F + w);
                });
              });
            }
            var N = ml(u) && u.limit === 1 / 0 && (typeof n != "function" || S) && { index: u.index, range: u.range };
            return E(0).then(function() {
              if (0 < D.length) throw new xn("Error modifying one or more objects", D, b, C);
              return P.length;
            });
          });
        });
      }, Ae.prototype.delete = function() {
        var n = this._ctx, t = n.range;
        return !ml(n) || n.table.schema.yProps || !n.isPrimKey && t.type !== 3 ? this.modify(cu) : this._write(function(u) {
          var r = n.table.core.schema.primaryKey, c = t;
          return n.table.core.count({ trans: u, query: { index: r, range: c } }).then(function(f) {
            return n.table.core.mutate({ trans: u, type: "deleteRange", range: c }).then(function(L) {
              var g = L.failures, L = L.numFailures;
              if (L) throw new xn("Could not delete some values", Object.keys(g).map(function(O) {
                return g[O];
              }), f - L);
              return f - L;
            });
          });
        });
      }, Ae);
      function Ae() {
      }
      var cu = function(n, t) {
        return t.value = null;
      };
      function ar(n, t) {
        return n < t ? -1 : n === t ? 0 : 1;
      }
      function rr(n, t) {
        return t < n ? -1 : n === t ? 0 : 1;
      }
      function pn(n, t, u) {
        return n = n instanceof mu ? new n.Collection(n) : n, n._ctx.error = new (u || TypeError)(t), n;
      }
      function fl(n) {
        return new n.Collection(n, function() {
          return ou("");
        }).limit(0);
      }
      function et(n, t, u, r) {
        var c, f, p, g, L, O, w, v = u.length;
        if (!u.every(function(b) {
          return typeof b == "string";
        })) return pn(n, eu);
        function T(b) {
          c = b === "next" ? function(S) {
            return S.toUpperCase();
          } : function(S) {
            return S.toLowerCase();
          }, f = b === "next" ? function(S) {
            return S.toLowerCase();
          } : function(S) {
            return S.toUpperCase();
          }, p = b === "next" ? ar : rr;
          var C = u.map(function(S) {
            return { lower: f(S), upper: c(S) };
          }).sort(function(S, P) {
            return p(S.lower, P.lower);
          });
          g = C.map(function(S) {
            return S.upper;
          }), L = C.map(function(S) {
            return S.lower;
          }), w = (O = b) === "next" ? "" : r;
        }
        T("next"), n = new n.Collection(n, function() {
          return zn(g[0], L[v - 1] + r);
        }), n._ondirectionchange = function(b) {
          T(b);
        };
        var D = 0;
        return n._addAlgorithm(function(b, C, S) {
          var P = b.key;
          if (typeof P != "string") return !1;
          var E = f(P);
          if (t(E, L, D)) return !0;
          for (var N = null, F = D; F < v; ++F) {
            var G = function(Y, H, $, J, Q, ne) {
              for (var xe = Math.min(Y.length, J.length), qe = -1, he = 0; he < xe; ++he) {
                var Ge = H[he];
                if (Ge !== J[he]) return Q(Y[he], $[he]) < 0 ? Y.substr(0, he) + $[he] + $.substr(he + 1) : Q(Y[he], J[he]) < 0 ? Y.substr(0, he) + J[he] + $.substr(he + 1) : 0 <= qe ? Y.substr(0, qe) + H[qe] + $.substr(qe + 1) : null;
                Q(Y[he], Ge) < 0 && (qe = he);
              }
              return xe < J.length && ne === "next" ? Y + $.substr(Y.length) : xe < Y.length && ne === "prev" ? Y.substr(0, $.length) : qe < 0 ? null : Y.substr(0, qe) + J[qe] + $.substr(qe + 1);
            }(P, E, g[F], L[F], p, O);
            G === null && N === null ? D = F + 1 : (N === null || 0 < p(N, G)) && (N = G);
          }
          return C(N !== null ? function() {
            b.continue(N + w);
          } : S), !1;
        }), n;
      }
      function zn(n, t, u, r) {
        return { type: 2, lower: n, upper: t, lowerOpen: u, upperOpen: r };
      }
      function ou(n) {
        return { type: 1, lower: n, upper: n };
      }
      var mu = (Object.defineProperty(nn.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), nn.prototype.between = function(n, t, u, r) {
        u = u !== !1, r = r === !0;
        try {
          return 0 < this._cmp(n, t) || this._cmp(n, t) === 0 && (u || r) && (!u || !r) ? fl(this) : new this.Collection(this, function() {
            return zn(n, t, !u, !r);
          });
        } catch {
          return pn(this, Rn);
        }
      }, nn.prototype.equals = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return ou(n);
        });
      }, nn.prototype.above = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return zn(n, void 0, !0);
        });
      }, nn.prototype.aboveOrEqual = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return zn(n, void 0, !1);
        });
      }, nn.prototype.below = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return zn(void 0, n, !1, !0);
        });
      }, nn.prototype.belowOrEqual = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return zn(void 0, n);
        });
      }, nn.prototype.startsWith = function(n) {
        return typeof n != "string" ? pn(this, eu) : this.between(n, n + Jn, !0, !0);
      }, nn.prototype.startsWithIgnoreCase = function(n) {
        return n === "" ? this.startsWith(n) : et(this, function(t, u) {
          return t.indexOf(u[0]) === 0;
        }, [n], Jn);
      }, nn.prototype.equalsIgnoreCase = function(n) {
        return et(this, function(t, u) {
          return t === u[0];
        }, [n], "");
      }, nn.prototype.anyOfIgnoreCase = function() {
        var n = Ee.apply(De, arguments);
        return n.length === 0 ? fl(this) : et(this, function(t, u) {
          return u.indexOf(t) !== -1;
        }, n, "");
      }, nn.prototype.startsWithAnyOfIgnoreCase = function() {
        var n = Ee.apply(De, arguments);
        return n.length === 0 ? fl(this) : et(this, function(t, u) {
          return u.some(function(r) {
            return t.indexOf(r) === 0;
          });
        }, n, Jn);
      }, nn.prototype.anyOf = function() {
        var n = this, t = Ee.apply(De, arguments), u = this._cmp;
        try {
          t.sort(u);
        } catch {
          return pn(this, Rn);
        }
        if (t.length === 0) return fl(this);
        var r = new this.Collection(this, function() {
          return zn(t[0], t[t.length - 1]);
        });
        r._ondirectionchange = function(f) {
          u = f === "next" ? n._ascending : n._descending, t.sort(u);
        };
        var c = 0;
        return r._addAlgorithm(function(f, p, g) {
          for (var L = f.key; 0 < u(L, t[c]); ) if (++c === t.length) return p(g), !1;
          return u(L, t[c]) === 0 || (p(function() {
            f.continue(t[c]);
          }), !1);
        }), r;
      }, nn.prototype.notEqual = function(n) {
        return this.inAnyRange([[-1 / 0, n], [n, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, nn.prototype.noneOf = function() {
        var n = Ee.apply(De, arguments);
        if (n.length === 0) return new this.Collection(this);
        try {
          n.sort(this._ascending);
        } catch {
          return pn(this, Rn);
        }
        var t = n.reduce(function(u, r) {
          return u ? u.concat([[u[u.length - 1][1], r]]) : [[-1 / 0, r]];
        }, null);
        return t.push([n[n.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, nn.prototype.inAnyRange = function(P, t) {
        var u = this, r = this._cmp, c = this._ascending, f = this._descending, p = this._min, g = this._max;
        if (P.length === 0) return fl(this);
        if (!P.every(function(E) {
          return E[0] !== void 0 && E[1] !== void 0 && c(E[0], E[1]) <= 0;
        })) return pn(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Z.InvalidArgument);
        var L = !t || t.includeLowers !== !1, O = t && t.includeUppers === !0, w, v = c;
        function T(E, N) {
          return v(E[0], N[0]);
        }
        try {
          (w = P.reduce(function(E, N) {
            for (var F = 0, G = E.length; F < G; ++F) {
              var Y = E[F];
              if (r(N[0], Y[1]) < 0 && 0 < r(N[1], Y[0])) {
                Y[0] = p(Y[0], N[0]), Y[1] = g(Y[1], N[1]);
                break;
              }
            }
            return F === G && E.push(N), E;
          }, [])).sort(T);
        } catch {
          return pn(this, Rn);
        }
        var D = 0, b = O ? function(E) {
          return 0 < c(E, w[D][1]);
        } : function(E) {
          return 0 <= c(E, w[D][1]);
        }, C = L ? function(E) {
          return 0 < f(E, w[D][0]);
        } : function(E) {
          return 0 <= f(E, w[D][0]);
        }, S = b, P = new this.Collection(this, function() {
          return zn(w[0][0], w[w.length - 1][1], !L, !O);
        });
        return P._ondirectionchange = function(E) {
          v = E === "next" ? (S = b, c) : (S = C, f), w.sort(T);
        }, P._addAlgorithm(function(E, N, F) {
          for (var G, Y = E.key; S(Y); ) if (++D === w.length) return N(F), !1;
          return !b(G = Y) && !C(G) || (u._cmp(Y, w[D][1]) === 0 || u._cmp(Y, w[D][0]) === 0 || N(function() {
            v === c ? E.continue(w[D][0]) : E.continue(w[D][1]);
          }), !1);
        }), P;
      }, nn.prototype.startsWithAnyOf = function() {
        var n = Ee.apply(De, arguments);
        return n.every(function(t) {
          return typeof t == "string";
        }) ? n.length === 0 ? fl(this) : this.inAnyRange(n.map(function(t) {
          return [t, t + Jn];
        })) : pn(this, "startsWithAnyOf() only works with strings");
      }, nn);
      function nn() {
      }
      function bn(n) {
        return Be(function(t) {
          return bl(t), n(t.target.error), !1;
        });
      }
      function bl(n) {
        n.stopPropagation && n.stopPropagation(), n.preventDefault && n.preventDefault();
      }
      var wl = "storagemutated", kt = "x-storagemutated-1", jn = Ll(null, wl), sr = (wn.prototype._lock = function() {
        return K(!re.global), ++this._reculock, this._reculock !== 1 || re.global || (re.lockOwnerFor = this), this;
      }, wn.prototype._unlock = function() {
        if (K(!re.global), --this._reculock == 0) for (re.global || (re.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var n = this._blockedFuncs.shift();
          try {
            Qn(n[1], n[0]);
          } catch {
          }
        }
        return this;
      }, wn.prototype._locked = function() {
        return this._reculock && re.lockOwnerFor !== this;
      }, wn.prototype.create = function(n) {
        var t = this;
        if (!this.mode) return this;
        var u = this.db.idbdb, r = this.db._state.dbOpenError;
        if (K(!this.idbtrans), !n && !u) switch (r && r.name) {
          case "DatabaseClosedError":
            throw new Z.DatabaseClosed(r);
          case "MissingAPIError":
            throw new Z.MissingAPI(r.message, r);
          default:
            throw new Z.OpenFailed(r);
        }
        if (!this.active) throw new Z.TransactionInactive();
        return K(this._completion._state === null), (n = this.idbtrans = n || (this.db.core || u).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Be(function(c) {
          bl(c), t._reject(n.error);
        }), n.onabort = Be(function(c) {
          bl(c), t.active && t._reject(new Z.Abort(n.error)), t.active = !1, t.on("abort").fire(c);
        }), n.oncomplete = Be(function() {
          t.active = !1, t._resolve(), "mutatedParts" in n && jn.storagemutated.fire(n.mutatedParts);
        }), this;
      }, wn.prototype._promise = function(n, t, u) {
        var r = this;
        if (n === "readwrite" && this.mode !== "readwrite") return He(new Z.ReadOnly("Transaction is readonly"));
        if (!this.active) return He(new Z.TransactionInactive());
        if (this._locked()) return new ee(function(f, p) {
          r._blockedFuncs.push([function() {
            r._promise(n, t, u).then(f, p);
          }, re]);
        });
        if (u) return Un(function() {
          var f = new ee(function(p, g) {
            r._lock();
            var L = t(p, g, r);
            L && L.then && L.then(p, g);
          });
          return f.finally(function() {
            return r._unlock();
          }), f._lib = !0, f;
        });
        var c = new ee(function(f, p) {
          var g = t(f, p, r);
          g && g.then && g.then(f, p);
        });
        return c._lib = !0, c;
      }, wn.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, wn.prototype.waitFor = function(n) {
        var t, u = this._root(), r = ee.resolve(n);
        u._waitingFor ? u._waitingFor = u._waitingFor.then(function() {
          return r;
        }) : (u._waitingFor = r, u._waitingQueue = [], t = u.idbtrans.objectStore(u.storeNames[0]), function f() {
          for (++u._spinCount; u._waitingQueue.length; ) u._waitingQueue.shift()();
          u._waitingFor && (t.get(-1 / 0).onsuccess = f);
        }());
        var c = u._waitingFor;
        return new ee(function(f, p) {
          r.then(function(g) {
            return u._waitingQueue.push(Be(f.bind(null, g)));
          }, function(g) {
            return u._waitingQueue.push(Be(p.bind(null, g)));
          }).finally(function() {
            u._waitingFor === c && (u._waitingFor = null);
          });
        });
      }, wn.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new Z.Abort()));
      }, wn.prototype.table = function(n) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (I(t, n)) return t[n];
        var u = this.schema[n];
        if (!u) throw new Z.NotFound("Table " + n + " not part of transaction");
        return u = new this.db.Table(n, u, this), u.core = this.db.core.table(n), t[n] = u;
      }, wn);
      function wn() {
      }
      function Vt(n, t, u, r, c, f, p, g) {
        return { name: n, keyPath: t, unique: u, multi: r, auto: c, compound: f, src: (u && !p ? "&" : "") + (r ? "*" : "") + (c ? "++" : "") + fu(t), type: g };
      }
      function fu(n) {
        return typeof n == "string" ? n : n ? "[" + [].join.call(n, "+") + "]" : "";
      }
      function Bt(n, t, u) {
        return { name: n, primKey: t, indexes: u, mappedClass: null, idxByName: (r = function(c) {
          return [c.name, c];
        }, u.reduce(function(c, f, p) {
          return p = r(f, p), p && (c[p[0]] = p[1]), c;
        }, {})) };
        var r;
      }
      var Sl = function(n) {
        try {
          return n.only([[]]), Sl = function() {
            return [[]];
          }, [[]];
        } catch {
          return Sl = function() {
            return Jn;
          }, Jn;
        }
      };
      function Zt(n) {
        return n == null ? function() {
        } : typeof n == "string" ? (t = n).split(".").length === 1 ? function(u) {
          return u[t];
        } : function(u) {
          return se(u, t);
        } : function(u) {
          return se(u, n);
        };
        var t;
      }
      function du(n) {
        return [].slice.call(n);
      }
      var cr = 0;
      function Cl(n) {
        return n == null ? ":id" : typeof n == "string" ? n : "[".concat(n.join("+"), "]");
      }
      function or(n, t, L) {
        function r(S) {
          if (S.type === 3) return null;
          if (S.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var D = S.lower, b = S.upper, C = S.lowerOpen, S = S.upperOpen;
          return D === void 0 ? b === void 0 ? null : t.upperBound(b, !!S) : b === void 0 ? t.lowerBound(D, !!C) : t.bound(D, b, !!C, !!S);
        }
        function c(T) {
          var D, b = T.name;
          return { name: b, schema: T, mutate: function(C) {
            var S = C.trans, P = C.type, E = C.keys, N = C.values, F = C.range;
            return new Promise(function(G, Y) {
              G = Be(G);
              var H = S.objectStore(b), $ = H.keyPath == null, J = P === "put" || P === "add";
              if (!J && P !== "delete" && P !== "deleteRange") throw new Error("Invalid operation type: " + P);
              var Q, ne = (E || N || { length: 1 }).length;
              if (E && N && E.length !== N.length) throw new Error("Given keys array must have same length as given values array.");
              if (ne === 0) return G({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function xe(mn) {
                ++Ge, bl(mn);
              }
              var qe = [], he = [], Ge = 0;
              if (P === "deleteRange") {
                if (F.type === 4) return G({ numFailures: Ge, failures: he, results: [], lastResult: void 0 });
                F.type === 3 ? qe.push(Q = H.clear()) : qe.push(Q = H.delete(r(F)));
              } else {
                var $ = J ? $ ? [N, E] : [N, null] : [E, null], pe = $[0], rn = $[1];
                if (J) for (var sn = 0; sn < ne; ++sn) qe.push(Q = rn && rn[sn] !== void 0 ? H[P](pe[sn], rn[sn]) : H[P](pe[sn])), Q.onerror = xe;
                else for (sn = 0; sn < ne; ++sn) qe.push(Q = H[P](pe[sn])), Q.onerror = xe;
              }
              function ft(mn) {
                mn = mn.target.result, qe.forEach(function(tl, ui) {
                  return tl.error != null && (he[ui] = tl.error);
                }), G({ numFailures: Ge, failures: he, results: P === "delete" ? E : qe.map(function(tl) {
                  return tl.result;
                }), lastResult: mn });
              }
              Q.onerror = function(mn) {
                xe(mn), ft(mn);
              }, Q.onsuccess = ft;
            });
          }, getMany: function(C) {
            var S = C.trans, P = C.keys;
            return new Promise(function(E, N) {
              E = Be(E);
              for (var F, G = S.objectStore(b), Y = P.length, H = new Array(Y), $ = 0, J = 0, Q = function(qe) {
                qe = qe.target, H[qe._pos] = qe.result, ++J === $ && E(H);
              }, ne = bn(N), xe = 0; xe < Y; ++xe) P[xe] != null && ((F = G.get(P[xe]))._pos = xe, F.onsuccess = Q, F.onerror = ne, ++$);
              $ === 0 && E(H);
            });
          }, get: function(C) {
            var S = C.trans, P = C.key;
            return new Promise(function(E, N) {
              E = Be(E);
              var F = S.objectStore(b).get(P);
              F.onsuccess = function(G) {
                return E(G.target.result);
              }, F.onerror = bn(N);
            });
          }, query: (D = O, function(C) {
            return new Promise(function(S, P) {
              S = Be(S);
              var E, N, F, $ = C.trans, G = C.values, Y = C.limit, Q = C.query, H = Y === 1 / 0 ? void 0 : Y, J = Q.index, Q = Q.range, $ = $.objectStore(b), J = J.isPrimaryKey ? $ : $.index(J.name), Q = r(Q);
              if (Y === 0) return S({ result: [] });
              D ? ((H = G ? J.getAll(Q, H) : J.getAllKeys(Q, H)).onsuccess = function(ne) {
                return S({ result: ne.target.result });
              }, H.onerror = bn(P)) : (E = 0, N = !G && "openKeyCursor" in J ? J.openKeyCursor(Q) : J.openCursor(Q), F = [], N.onsuccess = function(ne) {
                var xe = N.result;
                return xe ? (F.push(G ? xe.value : xe.primaryKey), ++E === Y ? S({ result: F }) : void xe.continue()) : S({ result: F });
              }, N.onerror = bn(P));
            });
          }), openCursor: function(C) {
            var S = C.trans, P = C.values, E = C.query, N = C.reverse, F = C.unique;
            return new Promise(function(G, Y) {
              G = Be(G);
              var J = E.index, H = E.range, $ = S.objectStore(b), $ = J.isPrimaryKey ? $ : $.index(J.name), J = N ? F ? "prevunique" : "prev" : F ? "nextunique" : "next", Q = !P && "openKeyCursor" in $ ? $.openKeyCursor(r(H), J) : $.openCursor(r(H), J);
              Q.onerror = bn(Y), Q.onsuccess = Be(function(ne) {
                var xe, qe, he, Ge, pe = Q.result;
                pe ? (pe.___id = ++cr, pe.done = !1, xe = pe.continue.bind(pe), qe = (qe = pe.continuePrimaryKey) && qe.bind(pe), he = pe.advance.bind(pe), Ge = function() {
                  throw new Error("Cursor not stopped");
                }, pe.trans = S, pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = function() {
                  throw new Error("Cursor not started");
                }, pe.fail = Be(Y), pe.next = function() {
                  var rn = this, sn = 1;
                  return this.start(function() {
                    return sn-- ? rn.continue() : rn.stop();
                  }).then(function() {
                    return rn;
                  });
                }, pe.start = function(rn) {
                  function sn() {
                    if (Q.result) try {
                      rn();
                    } catch (mn) {
                      pe.fail(mn);
                    }
                    else pe.done = !0, pe.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, pe.stop();
                  }
                  var ft = new Promise(function(mn, tl) {
                    mn = Be(mn), Q.onerror = bn(tl), pe.fail = tl, pe.stop = function(ui) {
                      pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = Ge, mn(ui);
                    };
                  });
                  return Q.onsuccess = Be(function(mn) {
                    Q.onsuccess = sn, sn();
                  }), pe.continue = xe, pe.continuePrimaryKey = qe, pe.advance = he, sn(), ft;
                }, G(pe)) : G(null);
              }, Y);
            });
          }, count: function(C) {
            var S = C.query, P = C.trans, E = S.index, N = S.range;
            return new Promise(function(F, G) {
              var Y = P.objectStore(b), H = E.isPrimaryKey ? Y : Y.index(E.name), Y = r(N), H = Y ? H.count(Y) : H.count();
              H.onsuccess = Be(function($) {
                return F($.target.result);
              }), H.onerror = bn(G);
            });
          } };
        }
        var f, p, g, w = (p = L, g = du((f = n).objectStoreNames), { schema: { name: f.name, tables: g.map(function(T) {
          return p.objectStore(T);
        }).map(function(T) {
          var D = T.keyPath, S = T.autoIncrement, b = d(D), C = {}, S = { name: T.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: D == null, compound: b, keyPath: D, autoIncrement: S, unique: !0, extractKey: Zt(D) }, indexes: du(T.indexNames).map(function(P) {
            return T.index(P);
          }).map(function(F) {
            var E = F.name, N = F.unique, G = F.multiEntry, F = F.keyPath, G = { name: E, compound: d(F), keyPath: F, unique: N, multiEntry: G, extractKey: Zt(F) };
            return C[Cl(F)] = G;
          }), getIndexByKeyPath: function(P) {
            return C[Cl(P)];
          } };
          return C[":id"] = S.primaryKey, D != null && (C[Cl(D)] = S.primaryKey), S;
        }) }, hasGetAll: 0 < g.length && "getAll" in p.objectStore(g[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), L = w.schema, O = w.hasGetAll, w = L.tables.map(c), v = {};
        return w.forEach(function(T) {
          return v[T.name] = T;
        }), { stack: "dbcore", transaction: n.transaction.bind(n), table: function(T) {
          if (!v[T]) throw new Error("Table '".concat(T, "' not found"));
          return v[T];
        }, MIN_KEY: -1 / 0, MAX_KEY: Sl(t), schema: L };
      }
      function mr(n, t, u, r) {
        var c = u.IDBKeyRange;
        return u.indexedDB, { dbcore: (r = or(t, c, r), n.dbcore.reduce(function(f, p) {
          return p = p.create, a(a({}, f), p(f));
        }, r)) };
      }
      function nt(n, r) {
        var u = r.db, r = mr(n._middlewares, u, n._deps, r);
        n.core = r.dbcore, n.tables.forEach(function(c) {
          var f = c.name;
          n.core.schema.tables.some(function(p) {
            return p.name === f;
          }) && (c.core = n.core.table(f), n[f] instanceof n.Table && (n[f].core = c.core));
        });
      }
      function lt(n, t, u, r) {
        u.forEach(function(c) {
          var f = r[c];
          t.forEach(function(p) {
            var g = function L(O, w) {
              return U(O, w) || (O = x(O)) && L(O, w);
            }(p, c);
            (!g || "value" in g && g.value === void 0) && (p === n.Transaction.prototype || p instanceof n.Transaction ? R(p, c, { get: function() {
              return this.table(c);
            }, set: function(L) {
              A(this, c, { value: L, writable: !0, configurable: !0, enumerable: !0 });
            } }) : p[c] = new n.Table(c, f));
          });
        });
      }
      function Ut(n, t) {
        t.forEach(function(u) {
          for (var r in u) u[r] instanceof n.Table && delete u[r];
        });
      }
      function fr(n, t) {
        return n._cfg.version - t._cfg.version;
      }
      function dr(n, t, u, r) {
        var c = n._dbSchema;
        u.objectStoreNames.contains("$meta") && !c.$meta && (c.$meta = Bt("$meta", hu("")[0], []), n._storeNames.push("$meta"));
        var f = n._createTransaction("readwrite", n._storeNames, c);
        f.create(u), f._completion.catch(r);
        var p = f._reject.bind(f), g = re.transless || re;
        Un(function() {
          return re.trans = f, re.transless = g, t !== 0 ? (nt(n, u), O = t, ((L = f).storeNames.includes("$meta") ? L.table("$meta").get("version").then(function(w) {
            return w ?? O;
          }) : ee.resolve(O)).then(function(w) {
            return T = w, D = f, b = u, C = [], w = (v = n)._versions, S = v._dbSchema = it(0, v.idbdb, b), (w = w.filter(function(P) {
              return P._cfg.version >= T;
            })).length !== 0 ? (w.forEach(function(P) {
              C.push(function() {
                var E = S, N = P._cfg.dbschema;
                ut(v, E, b), ut(v, N, b), S = v._dbSchema = N;
                var F = Kt(E, N);
                F.add.forEach(function(J) {
                  Gt(b, J[0], J[1].primKey, J[1].indexes);
                }), F.change.forEach(function(J) {
                  if (J.recreate) throw new Z.Upgrade("Not yet support for changing primary key");
                  var Q = b.objectStore(J.name);
                  J.add.forEach(function(ne) {
                    return tt(Q, ne);
                  }), J.change.forEach(function(ne) {
                    Q.deleteIndex(ne.name), tt(Q, ne);
                  }), J.del.forEach(function(ne) {
                    return Q.deleteIndex(ne);
                  });
                });
                var G = P._cfg.contentUpgrade;
                if (G && P._cfg.version > T) {
                  nt(v, b), D._memoizedTables = {};
                  var Y = me(N);
                  F.del.forEach(function(J) {
                    Y[J] = E[J];
                  }), Ut(v, [v.Transaction.prototype]), lt(v, [v.Transaction.prototype], m(Y), Y), D.schema = Y;
                  var H, $ = Ye(G);
                  return $ && cl(), F = ee.follow(function() {
                    var J;
                    (H = G(D)) && $ && (J = Kn.bind(null, null), H.then(J, J));
                  }), H && typeof H.then == "function" ? ee.resolve(H) : F.then(function() {
                    return H;
                  });
                }
              }), C.push(function(E) {
                var N, F, G = P._cfg.dbschema;
                N = G, F = E, [].slice.call(F.db.objectStoreNames).forEach(function(Y) {
                  return N[Y] == null && F.db.deleteObjectStore(Y);
                }), Ut(v, [v.Transaction.prototype]), lt(v, [v.Transaction.prototype], v._storeNames, v._dbSchema), D.schema = v._dbSchema;
              }), C.push(function(E) {
                v.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(v.idbdb.version / 10) === P._cfg.version ? (v.idbdb.deleteObjectStore("$meta"), delete v._dbSchema.$meta, v._storeNames = v._storeNames.filter(function(N) {
                  return N !== "$meta";
                })) : E.objectStore("$meta").put(P._cfg.version, "version"));
              });
            }), function P() {
              return C.length ? ee.resolve(C.shift()(D.idbtrans)).then(P) : ee.resolve();
            }().then(function() {
              pu(S, b);
            })) : ee.resolve();
            var v, T, D, b, C, S;
          }).catch(p)) : (m(c).forEach(function(w) {
            Gt(u, w, c[w].primKey, c[w].indexes);
          }), nt(n, u), void ee.follow(function() {
            return n.on.populate.fire(f);
          }).catch(p));
          var L, O;
        });
      }
      function pr(n, t) {
        pu(n._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var u = it(0, n.idbdb, t);
        ut(n, n._dbSchema, t);
        for (var r = 0, c = Kt(u, n._dbSchema).change; r < c.length; r++) {
          var f = function(p) {
            if (p.change.length || p.recreate) return console.warn("Unable to patch indexes of table ".concat(p.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var g = t.objectStore(p.name);
            p.add.forEach(function(L) {
              be && console.debug("Dexie upgrade patch: Creating missing index ".concat(p.name, ".").concat(L.src)), tt(g, L);
            });
          }(c[r]);
          if (typeof f == "object") return f.value;
        }
      }
      function Kt(n, t) {
        var u, r = { del: [], add: [], change: [] };
        for (u in n) t[u] || r.del.push(u);
        for (u in t) {
          var c = n[u], f = t[u];
          if (c) {
            var p = { name: u, def: f, recreate: !1, del: [], add: [], change: [] };
            if ("" + (c.primKey.keyPath || "") != "" + (f.primKey.keyPath || "") || c.primKey.auto !== f.primKey.auto) p.recreate = !0, r.change.push(p);
            else {
              var g = c.idxByName, L = f.idxByName, O = void 0;
              for (O in g) L[O] || p.del.push(O);
              for (O in L) {
                var w = g[O], v = L[O];
                w ? w.src !== v.src && p.change.push(v) : p.add.push(v);
              }
              (0 < p.del.length || 0 < p.add.length || 0 < p.change.length) && r.change.push(p);
            }
          } else r.add.push([u, f]);
        }
        return r;
      }
      function Gt(n, t, u, r) {
        var c = n.db.createObjectStore(t, u.keyPath ? { keyPath: u.keyPath, autoIncrement: u.auto } : { autoIncrement: u.auto });
        return r.forEach(function(f) {
          return tt(c, f);
        }), c;
      }
      function pu(n, t) {
        m(n).forEach(function(u) {
          t.db.objectStoreNames.contains(u) || (be && console.debug("Dexie: Creating missing table", u), Gt(t, u, n[u].primKey, n[u].indexes));
        });
      }
      function tt(n, t) {
        n.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function it(n, t, u) {
        var r = {};
        return X(t.objectStoreNames, 0).forEach(function(c) {
          for (var f = u.objectStore(c), p = Vt(fu(O = f.keyPath), O || "", !0, !1, !!f.autoIncrement, O && typeof O != "string", !0), g = [], L = 0; L < f.indexNames.length; ++L) {
            var w = f.index(f.indexNames[L]), O = w.keyPath, w = Vt(w.name, O, !!w.unique, !!w.multiEntry, !1, O && typeof O != "string", !1);
            g.push(w);
          }
          r[c] = Bt(c, p, g);
        }), r;
      }
      function ut(n, t, u) {
        for (var r = u.db.objectStoreNames, c = 0; c < r.length; ++c) {
          var f = r[c], p = u.objectStore(f);
          n._hasGetAll = "getAll" in p;
          for (var g = 0; g < p.indexNames.length; ++g) {
            var L = p.indexNames[g], O = p.index(L).keyPath, w = typeof O == "string" ? O : "[" + X(O).join("+") + "]";
            !t[f] || (O = t[f].idxByName[w]) && (O.name = L, delete t[f].idxByName[w], t[f].idxByName[L] = O);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && o.WorkerGlobalScope && o instanceof o.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1);
      }
      function hu(n) {
        return n.split(",").map(function(t, u) {
          var f = t.split(":"), r = (c = f[1]) === null || c === void 0 ? void 0 : c.trim(), c = (t = f[0].trim()).replace(/([&*]|\+\+)/g, ""), f = /^\[/.test(c) ? c.match(/^\[(.*)\]$/)[1].split("+") : c;
          return Vt(c, f || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), d(f), u === 0, r);
        });
      }
      var hr = (dl.prototype._createTableSchema = Bt, dl.prototype._parseIndexSyntax = hu, dl.prototype._parseStoresSpec = function(n, t) {
        var u = this;
        m(n).forEach(function(r) {
          if (n[r] !== null) {
            var c = u._parseIndexSyntax(n[r]), f = c.shift();
            if (!f) throw new Z.Schema("Invalid schema for table " + r + ": " + n[r]);
            if (f.unique = !0, f.multi) throw new Z.Schema("Primary key cannot be multiEntry*");
            c.forEach(function(p) {
              if (p.auto) throw new Z.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!p.keyPath) throw new Z.Schema("Index must have a name and cannot be an empty string");
            }), c = u._createTableSchema(r, f, c), t[r] = c;
          }
        });
      }, dl.prototype.stores = function(u) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? h(this._cfg.storesSource, u) : u;
        var u = t._versions, r = {}, c = {};
        return u.forEach(function(f) {
          h(r, f._cfg.storesSource), c = f._cfg.dbschema = {}, f._parseStoresSpec(r, c);
        }), t._dbSchema = c, Ut(t, [t._allTables, t, t.Transaction.prototype]), lt(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], m(c), c), t._storeNames = m(c), this;
      }, dl.prototype.upgrade = function(n) {
        return this._cfg.contentUpgrade = _e(this._cfg.contentUpgrade || Oe, n), this;
      }, dl);
      function dl() {
      }
      function zt(n, t) {
        var u = n._dbNamesDB;
        return u || (u = n._dbNamesDB = new En(Wl, { addons: [], indexedDB: n, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), u.table("dbnames");
      }
      function jt(n) {
        return n && typeof n.databases == "function";
      }
      function Ht(n) {
        return Un(function() {
          return re.letThrough = !0, n();
        });
      }
      function $t(n) {
        return !("from" in n);
      }
      var an = function(n, t) {
        if (!this) {
          var u = new an();
          return n && "d" in n && h(u, n), u;
        }
        h(this, arguments.length ? { d: 1, from: n, to: 1 < arguments.length ? t : n } : { d: 0 });
      };
      function Tl(n, t, u) {
        var r = Ce(t, u);
        if (!isNaN(r)) {
          if (0 < r) throw RangeError();
          if ($t(n)) return h(n, { from: t, to: u, d: 1 });
          var c = n.l, r = n.r;
          if (Ce(u, n.from) < 0) return c ? Tl(c, t, u) : n.l = { from: t, to: u, d: 1, l: null, r: null }, vu(n);
          if (0 < Ce(t, n.to)) return r ? Tl(r, t, u) : n.r = { from: t, to: u, d: 1, l: null, r: null }, vu(n);
          Ce(t, n.from) < 0 && (n.from = t, n.l = null, n.d = r ? r.d + 1 : 1), 0 < Ce(u, n.to) && (n.to = u, n.r = null, n.d = n.l ? n.l.d + 1 : 1), u = !n.r, c && !n.l && Pl(n, c), r && u && Pl(n, r);
        }
      }
      function Pl(n, t) {
        $t(t) || function u(r, L) {
          var f = L.from, p = L.to, g = L.l, L = L.r;
          Tl(r, f, p), g && u(r, g), L && u(r, L);
        }(n, t);
      }
      function gu(n, t) {
        var u = at(t), r = u.next();
        if (r.done) return !1;
        for (var c = r.value, f = at(n), p = f.next(c.from), g = p.value; !r.done && !p.done; ) {
          if (Ce(g.from, c.to) <= 0 && 0 <= Ce(g.to, c.from)) return !0;
          Ce(c.from, g.from) < 0 ? c = (r = u.next(g.from)).value : g = (p = f.next(c.from)).value;
        }
        return !1;
      }
      function at(n) {
        var t = $t(n) ? null : { s: 0, n };
        return { next: function(u) {
          for (var r = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, r) for (; t.n.l && Ce(u, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !r || Ce(u, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function vu(n) {
        var t, u, r = (((t = n.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((u = n.l) === null || u === void 0 ? void 0 : u.d) || 0), c = 1 < r ? "r" : r < -1 ? "l" : "";
        c && (t = c == "r" ? "l" : "r", u = a({}, n), r = n[c], n.from = r.from, n.to = r.to, n[c] = r[c], u[c] = r[t], (n[t] = u).d = xu(u)), n.d = xu(n);
      }
      function xu(u) {
        var t = u.r, u = u.l;
        return (t ? u ? Math.max(t.d, u.d) : t.d : u ? u.d : 0) + 1;
      }
      function rt(n, t) {
        return m(t).forEach(function(u) {
          n[u] ? Pl(n[u], t[u]) : n[u] = function r(c) {
            var f, p, g = {};
            for (f in c) I(c, f) && (p = c[f], g[f] = !p || typeof p != "object" || Ie.has(p.constructor) ? p : r(p));
            return g;
          }(t[u]);
        }), n;
      }
      function Wt(n, t) {
        return n.all || t.all || Object.keys(n).some(function(u) {
          return t[u] && gu(t[u], n[u]);
        });
      }
      q(an.prototype, ((In = { add: function(n) {
        return Pl(this, n), this;
      }, addKey: function(n) {
        return Tl(this, n, n), this;
      }, addKeys: function(n) {
        var t = this;
        return n.forEach(function(u) {
          return Tl(t, u, u);
        }), this;
      }, hasKey: function(n) {
        var t = at(this).next(n).value;
        return t && Ce(t.from, n) <= 0 && 0 <= Ce(t.to, n);
      } })[ge] = function() {
        return at(this);
      }, In));
      var nl = {}, Yt = {}, Xt = !1;
      function st(n) {
        rt(Yt, n), Xt || (Xt = !0, setTimeout(function() {
          Xt = !1, Qt(Yt, !(Yt = {}));
        }, 0));
      }
      function Qt(n, t) {
        t === void 0 && (t = !1);
        var u = /* @__PURE__ */ new Set();
        if (n.all) for (var r = 0, c = Object.values(nl); r < c.length; r++) yu(p = c[r], n, u, t);
        else for (var f in n) {
          var p, g = /^idb\:\/\/(.*)\/(.*)\//.exec(f);
          g && (f = g[1], g = g[2], (p = nl["idb://".concat(f, "/").concat(g)]) && yu(p, n, u, t));
        }
        u.forEach(function(L) {
          return L();
        });
      }
      function yu(n, t, u, r) {
        for (var c = [], f = 0, p = Object.entries(n.queries.query); f < p.length; f++) {
          for (var g = p[f], L = g[0], O = [], w = 0, v = g[1]; w < v.length; w++) {
            var T = v[w];
            Wt(t, T.obsSet) ? T.subscribers.forEach(function(S) {
              return u.add(S);
            }) : r && O.push(T);
          }
          r && c.push([L, O]);
        }
        if (r) for (var D = 0, b = c; D < b.length; D++) {
          var C = b[D], L = C[0], O = C[1];
          n.queries.query[L] = O;
        }
      }
      function gr(n) {
        var t = n._state, u = n._deps.indexedDB;
        if (t.isBeingOpened || n.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? He(t.dbOpenError) : n;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var r = t.openCanceller, c = Math.round(10 * n.verno), f = !1;
        function p() {
          if (t.openCanceller !== r) throw new Z.DatabaseClosed("db.open() was cancelled");
        }
        function g() {
          return new ee(function(T, D) {
            if (p(), !u) throw new Z.MissingAPI();
            var b = n.name, C = t.autoSchema || !c ? u.open(b) : u.open(b, c);
            if (!C) throw new Z.MissingAPI();
            C.onerror = bn(D), C.onblocked = Be(n._fireOnBlocked), C.onupgradeneeded = Be(function(S) {
              var P;
              w = C.transaction, t.autoSchema && !n._options.allowEmptyDB ? (C.onerror = bl, w.abort(), C.result.close(), (P = u.deleteDatabase(b)).onsuccess = P.onerror = Be(function() {
                D(new Z.NoSuchDatabase("Database ".concat(b, " doesnt exist")));
              })) : (w.onerror = bn(D), S = S.oldVersion > Math.pow(2, 62) ? 0 : S.oldVersion, v = S < 1, n.idbdb = C.result, f && pr(n, w), dr(n, S / 10, w, D));
            }, D), C.onsuccess = Be(function() {
              w = null;
              var S, P, E, N, F, G = n.idbdb = C.result, Y = X(G.objectStoreNames);
              if (0 < Y.length) try {
                var H = G.transaction((N = Y).length === 1 ? N[0] : N, "readonly");
                if (t.autoSchema) P = G, E = H, (S = n).verno = P.version / 10, E = S._dbSchema = it(0, P, E), S._storeNames = X(P.objectStoreNames, 0), lt(S, [S._allTables], m(E), E);
                else if (ut(n, n._dbSchema, H), ((F = Kt(it(0, (F = n).idbdb, H), F._dbSchema)).add.length || F.change.some(function($) {
                  return $.add.length || $.change.length;
                })) && !f) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), G.close(), c = G.version + 1, f = !0, T(g());
                nt(n, H);
              } catch {
              }
              ol.push(n), G.onversionchange = Be(function($) {
                t.vcFired = !0, n.on("versionchange").fire($);
              }), G.onclose = Be(function($) {
                n.on("close").fire($);
              }), v && (F = n._deps, H = b, G = F.indexedDB, F = F.IDBKeyRange, jt(G) || H === Wl || zt(G, F).put({ name: H }).catch(Oe)), T();
            }, D);
          }).catch(function(T) {
            switch (T?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), g();
                break;
              case "VersionError":
                if (0 < c) return c = 0, g();
            }
            return ee.reject(T);
          });
        }
        var L, O = t.dbReadyResolve, w = null, v = !1;
        return ee.race([r, (typeof navigator > "u" ? ee.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(T) {
          function D() {
            return indexedDB.databases().finally(T);
          }
          L = setInterval(D, 100), D();
        }).finally(function() {
          return clearInterval(L);
        }) : Promise.resolve()).then(g)]).then(function() {
          return p(), t.onReadyBeingFired = [], ee.resolve(Ht(function() {
            return n.on.ready.fire(n.vip);
          })).then(function T() {
            if (0 < t.onReadyBeingFired.length) {
              var D = t.onReadyBeingFired.reduce(_e, Oe);
              return t.onReadyBeingFired = [], ee.resolve(Ht(function() {
                return D(n.vip);
              })).then(T);
            }
          });
        }).finally(function() {
          t.openCanceller === r && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(T) {
          t.dbOpenError = T;
          try {
            w && w.abort();
          } catch {
          }
          return r === t.openCanceller && n._close(), He(T);
        }).finally(function() {
          t.openComplete = !0, O();
        }).then(function() {
          var T;
          return v && (T = {}, n.tables.forEach(function(D) {
            D.schema.indexes.forEach(function(b) {
              b.name && (T["idb://".concat(n.name, "/").concat(D.name, "/").concat(b.name)] = new an(-1 / 0, [[[]]]));
            }), T["idb://".concat(n.name, "/").concat(D.name, "/")] = T["idb://".concat(n.name, "/").concat(D.name, "/:dels")] = new an(-1 / 0, [[[]]]);
          }), jn(wl).fire(T), Qt(T, !0)), n;
        });
      }
      function Jt(n) {
        function t(f) {
          return n.next(f);
        }
        var u = c(t), r = c(function(f) {
          return n.throw(f);
        });
        function c(f) {
          return function(L) {
            var g = f(L), L = g.value;
            return g.done ? L : L && typeof L.then == "function" ? L.then(u, r) : d(L) ? Promise.all(L).then(u, r) : u(L);
          };
        }
        return c(t)();
      }
      function ct(n, t, u) {
        for (var r = d(n) ? n.slice() : [n], c = 0; c < u; ++c) r.push(t);
        return r;
      }
      var vr = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema, c = {}, f = [];
          function p(v, T, D) {
            var b = Cl(v), C = c[b] = c[b] || [], S = v == null ? 0 : typeof v == "string" ? 1 : v.length, P = 0 < T, P = a(a({}, D), { name: P ? "".concat(b, "(virtual-from:").concat(D.name, ")") : D.name, lowLevelIndex: D, isVirtual: P, keyTail: T, keyLength: S, extractKey: Zt(v), unique: !P && D.unique });
            return C.push(P), P.isPrimaryKey || f.push(P), 1 < S && p(S === 2 ? v[0] : v.slice(0, S - 1), T + 1, D), C.sort(function(E, N) {
              return E.keyTail - N.keyTail;
            }), P;
          }
          t = p(r.primaryKey.keyPath, 0, r.primaryKey), c[":id"] = [t];
          for (var g = 0, L = r.indexes; g < L.length; g++) {
            var O = L[g];
            p(O.keyPath, 0, O);
          }
          function w(v) {
            var T, D = v.query.index;
            return D.isVirtual ? a(a({}, v), { query: { index: D.lowLevelIndex, range: (T = v.query.range, D = D.keyTail, { type: T.type === 1 ? 2 : T.type, lower: ct(T.lower, T.lowerOpen ? n.MAX_KEY : n.MIN_KEY, D), lowerOpen: !0, upper: ct(T.upper, T.upperOpen ? n.MIN_KEY : n.MAX_KEY, D), upperOpen: !0 }) } }) : v;
          }
          return a(a({}, u), { schema: a(a({}, r), { primaryKey: t, indexes: f, getIndexByKeyPath: function(v) {
            return (v = c[Cl(v)]) && v[0];
          } }), count: function(v) {
            return u.count(w(v));
          }, query: function(v) {
            return u.query(w(v));
          }, openCursor: function(v) {
            var T = v.query.index, D = T.keyTail, b = T.isVirtual, C = T.keyLength;
            return b ? u.openCursor(w(v)).then(function(P) {
              return P && S(P);
            }) : u.openCursor(v);
            function S(P) {
              return Object.create(P, { continue: { value: function(E) {
                E != null ? P.continue(ct(E, v.reverse ? n.MAX_KEY : n.MIN_KEY, D)) : v.unique ? P.continue(P.key.slice(0, C).concat(v.reverse ? n.MIN_KEY : n.MAX_KEY, D)) : P.continue();
              } }, continuePrimaryKey: { value: function(E, N) {
                P.continuePrimaryKey(ct(E, n.MAX_KEY, D), N);
              } }, primaryKey: { get: function() {
                return P.primaryKey;
              } }, key: { get: function() {
                var E = P.key;
                return C === 1 ? E[0] : E.slice(0, C);
              } }, value: { get: function() {
                return P.value;
              } } });
            }
          } });
        } });
      } };
      function ei(n, t, u, r) {
        return u = u || {}, r = r || "", m(n).forEach(function(c) {
          var f, p, g;
          I(t, c) ? (f = n[c], p = t[c], typeof f == "object" && typeof p == "object" && f && p ? (g = Se(f)) !== Se(p) ? u[r + c] = t[c] : g === "Object" ? ei(f, p, u, r + c + ".") : f !== p && (u[r + c] = t[c]) : f !== p && (u[r + c] = t[c])) : u[r + c] = void 0;
        }), m(t).forEach(function(c) {
          I(n, c) || (u[r + c] = t[c]);
        }), u;
      }
      function ni(n, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(n.extractKey);
      }
      var xr = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema.primaryKey;
          return a(a({}, u), { mutate: function(c) {
            var f = re.trans, p = f.table(t).hook, g = p.deleting, L = p.creating, O = p.updating;
            switch (c.type) {
              case "add":
                if (L.fire === Oe) break;
                return f._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "put":
                if (L.fire === Oe && O.fire === Oe) break;
                return f._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "delete":
                if (g.fire === Oe) break;
                return f._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "deleteRange":
                if (g.fire === Oe) break;
                return f._promise("readwrite", function() {
                  return function v(T, D, b) {
                    return u.query({ trans: T, values: !1, query: { index: r, range: D }, limit: b }).then(function(C) {
                      var S = C.result;
                      return w({ type: "delete", keys: S, trans: T }).then(function(P) {
                        return 0 < P.numFailures ? Promise.reject(P.failures[0]) : S.length < b ? { failures: [], numFailures: 0, lastResult: void 0 } : v(T, a(a({}, D), { lower: S[S.length - 1], lowerOpen: !0 }), b);
                      });
                    });
                  }(c.trans, c.range, 1e4);
                }, !0);
            }
            return u.mutate(c);
            function w(v) {
              var T, D, b, C = re.trans, S = v.keys || ni(r, v);
              if (!S) throw new Error("Keys missing");
              return (v = v.type === "add" || v.type === "put" ? a(a({}, v), { keys: S }) : a({}, v)).type !== "delete" && (v.values = s([], v.values)), v.keys && (v.keys = s([], v.keys)), T = u, b = S, ((D = v).type === "add" ? Promise.resolve([]) : T.getMany({ trans: D.trans, keys: b, cache: "immutable" })).then(function(P) {
                var E = S.map(function(N, F) {
                  var G, Y, H, $ = P[F], J = { onerror: null, onsuccess: null };
                  return v.type === "delete" ? g.fire.call(J, N, $, C) : v.type === "add" || $ === void 0 ? (G = L.fire.call(J, N, v.values[F], C), N == null && G != null && (v.keys[F] = N = G, r.outbound || te(v.values[F], r.keyPath, N))) : (G = ei($, v.values[F]), (Y = O.fire.call(J, G, N, $, C)) && (H = v.values[F], Object.keys(Y).forEach(function(Q) {
                    I(H, Q) ? H[Q] = Y[Q] : te(H, Q, Y[Q]);
                  }))), J;
                });
                return u.mutate(v).then(function(N) {
                  for (var F = N.failures, G = N.results, Y = N.numFailures, N = N.lastResult, H = 0; H < S.length; ++H) {
                    var $ = (G || S)[H], J = E[H];
                    $ == null ? J.onerror && J.onerror(F[H]) : J.onsuccess && J.onsuccess(v.type === "put" && P[H] ? v.values[H] : $);
                  }
                  return { failures: F, results: G, numFailures: Y, lastResult: N };
                }).catch(function(N) {
                  return E.forEach(function(F) {
                    return F.onerror && F.onerror(N);
                  }), Promise.reject(N);
                });
              });
            }
          } });
        } });
      } };
      function Iu(n, t, u) {
        try {
          if (!t || t.keys.length < n.length) return null;
          for (var r = [], c = 0, f = 0; c < t.keys.length && f < n.length; ++c) Ce(t.keys[c], n[f]) === 0 && (r.push(u ? ve(t.values[c]) : t.values[c]), ++f);
          return r.length === n.length ? r : null;
        } catch {
          return null;
        }
      }
      var yr = { stack: "dbcore", level: -1, create: function(n) {
        return { table: function(t) {
          var u = n.table(t);
          return a(a({}, u), { getMany: function(r) {
            if (!r.cache) return u.getMany(r);
            var c = Iu(r.keys, r.trans._cache, r.cache === "clone");
            return c ? ee.resolve(c) : u.getMany(r).then(function(f) {
              return r.trans._cache = { keys: r.keys, values: r.cache === "clone" ? ve(f) : f }, f;
            });
          }, mutate: function(r) {
            return r.type !== "add" && (r.trans._cache = null), u.mutate(r);
          } });
        } };
      } };
      function Lu(n, t) {
        return n.trans.mode === "readonly" && !!n.subscr && !n.trans.explicit && n.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function Du(n, t) {
        switch (n) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var Ir = { stack: "dbcore", level: 0, name: "Observability", create: function(n) {
        var t = n.schema.name, u = new an(n.MIN_KEY, n.MAX_KEY);
        return a(a({}, n), { transaction: function(r, c, f) {
          if (re.subscr && c !== "readonly") throw new Z.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(re.querier));
          return n.transaction(r, c, f);
        }, table: function(r) {
          var c = n.table(r), f = c.schema, p = f.primaryKey, v = f.indexes, g = p.extractKey, L = p.outbound, O = p.autoIncrement && v.filter(function(D) {
            return D.compound && D.keyPath.includes(p.keyPath);
          }), w = a(a({}, c), { mutate: function(D) {
            function b(Q) {
              return Q = "idb://".concat(t, "/").concat(r, "/").concat(Q), N[Q] || (N[Q] = new an());
            }
            var C, S, P, E = D.trans, N = D.mutatedParts || (D.mutatedParts = {}), F = b(""), G = b(":dels"), Y = D.type, J = D.type === "deleteRange" ? [D.range] : D.type === "delete" ? [D.keys] : D.values.length < 50 ? [ni(p, D).filter(function(Q) {
              return Q;
            }), D.values] : [], H = J[0], $ = J[1], J = D.trans._cache;
            return d(H) ? (F.addKeys(H), (J = Y === "delete" || H.length === $.length ? Iu(H, J) : null) || G.addKeys(H), (J || $) && (C = b, S = J, P = $, f.indexes.forEach(function(Q) {
              var ne = C(Q.name || "");
              function xe(he) {
                return he != null ? Q.extractKey(he) : null;
              }
              function qe(he) {
                return Q.multiEntry && d(he) ? he.forEach(function(Ge) {
                  return ne.addKey(Ge);
                }) : ne.addKey(he);
              }
              (S || P).forEach(function(he, rn) {
                var pe = S && xe(S[rn]), rn = P && xe(P[rn]);
                Ce(pe, rn) !== 0 && (pe != null && qe(pe), rn != null && qe(rn));
              });
            }))) : H ? ($ = { from: ($ = H.lower) !== null && $ !== void 0 ? $ : n.MIN_KEY, to: ($ = H.upper) !== null && $ !== void 0 ? $ : n.MAX_KEY }, G.add($), F.add($)) : (F.add(u), G.add(u), f.indexes.forEach(function(Q) {
              return b(Q.name).add(u);
            })), c.mutate(D).then(function(Q) {
              return !H || D.type !== "add" && D.type !== "put" || (F.addKeys(Q.results), O && O.forEach(function(ne) {
                for (var xe = D.values.map(function(pe) {
                  return ne.extractKey(pe);
                }), qe = ne.keyPath.findIndex(function(pe) {
                  return pe === p.keyPath;
                }), he = 0, Ge = Q.results.length; he < Ge; ++he) xe[he][qe] = Q.results[he];
                b(ne.name).addKeys(xe);
              })), E.mutatedParts = rt(E.mutatedParts || {}, N), Q;
            });
          } }), v = function(b) {
            var C = b.query, b = C.index, C = C.range;
            return [b, new an((b = C.lower) !== null && b !== void 0 ? b : n.MIN_KEY, (C = C.upper) !== null && C !== void 0 ? C : n.MAX_KEY)];
          }, T = { get: function(D) {
            return [p, new an(D.key)];
          }, getMany: function(D) {
            return [p, new an().addKeys(D.keys)];
          }, count: v, query: v, openCursor: v };
          return m(T).forEach(function(D) {
            w[D] = function(b) {
              var C = re.subscr, S = !!C, P = Lu(re, c) && Du(D, b) ? b.obsSet = {} : C;
              if (S) {
                var E = function($) {
                  return $ = "idb://".concat(t, "/").concat(r, "/").concat($), P[$] || (P[$] = new an());
                }, N = E(""), F = E(":dels"), C = T[D](b), S = C[0], C = C[1];
                if ((D === "query" && S.isPrimaryKey && !b.values ? F : E(S.name || "")).add(C), !S.isPrimaryKey) {
                  if (D !== "count") {
                    var G = D === "query" && L && b.values && c.query(a(a({}, b), { values: !1 }));
                    return c[D].apply(this, arguments).then(function($) {
                      if (D === "query") {
                        if (L && b.values) return G.then(function(xe) {
                          return xe = xe.result, N.addKeys(xe), $;
                        });
                        var J = b.values ? $.result.map(g) : $.result;
                        (b.values ? N : F).addKeys(J);
                      } else if (D === "openCursor") {
                        var Q = $, ne = b.values;
                        return Q && Object.create(Q, { key: { get: function() {
                          return F.addKey(Q.primaryKey), Q.key;
                        } }, primaryKey: { get: function() {
                          var xe = Q.primaryKey;
                          return F.addKey(xe), xe;
                        } }, value: { get: function() {
                          return ne && N.addKey(Q.primaryKey), Q.value;
                        } } });
                      }
                      return $;
                    });
                  }
                  F.add(u);
                }
              }
              return c[D].apply(this, arguments);
            };
          }), w;
        } });
      } };
      function Ou(n, t, u) {
        if (u.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var r = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return u.numFailures === r ? null : (t = a({}, t), d(t.keys) && (t.keys = t.keys.filter(function(c, f) {
          return !(f in u.failures);
        })), "values" in t && d(t.values) && (t.values = t.values.filter(function(c, f) {
          return !(f in u.failures);
        })), t);
      }
      function li(n, t) {
        return u = n, ((r = t).lower === void 0 || (r.lowerOpen ? 0 < Ce(u, r.lower) : 0 <= Ce(u, r.lower))) && (n = n, (t = t).upper === void 0 || (t.upperOpen ? Ce(n, t.upper) < 0 : Ce(n, t.upper) <= 0));
        var u, r;
      }
      function bu(n, t, T, r, c, f) {
        if (!T || T.length === 0) return n;
        var p = t.query.index, g = p.multiEntry, L = t.query.range, O = r.schema.primaryKey.extractKey, w = p.extractKey, v = (p.lowLevelIndex || p).extractKey, T = T.reduce(function(D, b) {
          var C = D, S = [];
          if (b.type === "add" || b.type === "put") for (var P = new an(), E = b.values.length - 1; 0 <= E; --E) {
            var N, F = b.values[E], G = O(F);
            P.hasKey(G) || (N = w(F), (g && d(N) ? N.some(function(Q) {
              return li(Q, L);
            }) : li(N, L)) && (P.addKey(G), S.push(F)));
          }
          switch (b.type) {
            case "add":
              var Y = new an().addKeys(t.values ? D.map(function(ne) {
                return O(ne);
              }) : D), C = D.concat(t.values ? S.filter(function(ne) {
                return ne = O(ne), !Y.hasKey(ne) && (Y.addKey(ne), !0);
              }) : S.map(function(ne) {
                return O(ne);
              }).filter(function(ne) {
                return !Y.hasKey(ne) && (Y.addKey(ne), !0);
              }));
              break;
            case "put":
              var H = new an().addKeys(b.values.map(function(ne) {
                return O(ne);
              }));
              C = D.filter(function(ne) {
                return !H.hasKey(t.values ? O(ne) : ne);
              }).concat(t.values ? S : S.map(function(ne) {
                return O(ne);
              }));
              break;
            case "delete":
              var $ = new an().addKeys(b.keys);
              C = D.filter(function(ne) {
                return !$.hasKey(t.values ? O(ne) : ne);
              });
              break;
            case "deleteRange":
              var J = b.range;
              C = D.filter(function(ne) {
                return !li(O(ne), J);
              });
          }
          return C;
        }, n);
        return T === n ? n : (T.sort(function(D, b) {
          return Ce(v(D), v(b)) || Ce(O(D), O(b));
        }), t.limit && t.limit < 1 / 0 && (T.length > t.limit ? T.length = t.limit : n.length === t.limit && T.length < t.limit && (c.dirty = !0)), f ? Object.freeze(T) : T);
      }
      function wu(n, t) {
        return Ce(n.lower, t.lower) === 0 && Ce(n.upper, t.upper) === 0 && !!n.lowerOpen == !!t.lowerOpen && !!n.upperOpen == !!t.upperOpen;
      }
      function Lr(n, t) {
        return function(u, r, c, f) {
          if (u === void 0) return r !== void 0 ? -1 : 0;
          if (r === void 0) return 1;
          if ((r = Ce(u, r)) === 0) {
            if (c && f) return 0;
            if (c) return 1;
            if (f) return -1;
          }
          return r;
        }(n.lower, t.lower, n.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(u, r, c, f) {
          if (u === void 0) return r !== void 0 ? 1 : 0;
          if (r === void 0) return -1;
          if ((r = Ce(u, r)) === 0) {
            if (c && f) return 0;
            if (c) return -1;
            if (f) return 1;
          }
          return r;
        }(n.upper, t.upper, n.upperOpen, t.upperOpen);
      }
      function Dr(n, t, u, r) {
        n.subscribers.add(u), r.addEventListener("abort", function() {
          var c, f;
          n.subscribers.delete(u), n.subscribers.size === 0 && (c = n, f = t, setTimeout(function() {
            c.subscribers.size === 0 && de(f, c);
          }, 3e3));
        });
      }
      var Or = { stack: "dbcore", level: 0, name: "Cache", create: function(n) {
        var t = n.schema.name;
        return a(a({}, n), { transaction: function(u, r, c) {
          var f, p, g = n.transaction(u, r, c);
          return r === "readwrite" && (p = (f = new AbortController()).signal, c = function(L) {
            return function() {
              if (f.abort(), r === "readwrite") {
                for (var O = /* @__PURE__ */ new Set(), w = 0, v = u; w < v.length; w++) {
                  var T = v[w], D = nl["idb://".concat(t, "/").concat(T)];
                  if (D) {
                    var b = n.table(T), C = D.optimisticOps.filter(function(ne) {
                      return ne.trans === g;
                    });
                    if (g._explicit && L && g.mutatedParts) for (var S = 0, P = Object.values(D.queries.query); S < P.length; S++) for (var E = 0, N = (Y = P[S]).slice(); E < N.length; E++) Wt((H = N[E]).obsSet, g.mutatedParts) && (de(Y, H), H.subscribers.forEach(function(ne) {
                      return O.add(ne);
                    }));
                    else if (0 < C.length) {
                      D.optimisticOps = D.optimisticOps.filter(function(ne) {
                        return ne.trans !== g;
                      });
                      for (var F = 0, G = Object.values(D.queries.query); F < G.length; F++) for (var Y, H, $, J = 0, Q = (Y = G[F]).slice(); J < Q.length; J++) (H = Q[J]).res != null && g.mutatedParts && (L && !H.dirty ? ($ = Object.isFrozen(H.res), $ = bu(H.res, H.req, C, b, H, $), H.dirty ? (de(Y, H), H.subscribers.forEach(function(ne) {
                        return O.add(ne);
                      })) : $ !== H.res && (H.res = $, H.promise = ee.resolve({ result: $ }))) : (H.dirty && de(Y, H), H.subscribers.forEach(function(ne) {
                        return O.add(ne);
                      })));
                    }
                  }
                }
                O.forEach(function(ne) {
                  return ne();
                });
              }
            };
          }, g.addEventListener("abort", c(!1), { signal: p }), g.addEventListener("error", c(!1), { signal: p }), g.addEventListener("complete", c(!0), { signal: p })), g;
        }, table: function(u) {
          var r = n.table(u), c = r.schema.primaryKey;
          return a(a({}, r), { mutate: function(f) {
            var p = re.trans;
            if (c.outbound || p.db._options.cache === "disabled" || p.explicit || p.idbtrans.mode !== "readwrite") return r.mutate(f);
            var g = nl["idb://".concat(t, "/").concat(u)];
            return g ? (p = r.mutate(f), f.type !== "add" && f.type !== "put" || !(50 <= f.values.length || ni(c, f).some(function(L) {
              return L == null;
            })) ? (g.optimisticOps.push(f), f.mutatedParts && st(f.mutatedParts), p.then(function(L) {
              0 < L.numFailures && (de(g.optimisticOps, f), (L = Ou(0, f, L)) && g.optimisticOps.push(L), f.mutatedParts && st(f.mutatedParts));
            }), p.catch(function() {
              de(g.optimisticOps, f), f.mutatedParts && st(f.mutatedParts);
            })) : p.then(function(L) {
              var O = Ou(0, a(a({}, f), { values: f.values.map(function(w, v) {
                var T;
                return L.failures[v] || (w = (T = c.keyPath) !== null && T !== void 0 && T.includes(".") ? ve(w) : a({}, w), te(w, c.keyPath, L.results[v])), w;
              }) }), L);
              g.optimisticOps.push(O), queueMicrotask(function() {
                return f.mutatedParts && st(f.mutatedParts);
              });
            }), p) : r.mutate(f);
          }, query: function(f) {
            if (!Lu(re, r) || !Du("query", f)) return r.query(f);
            var p = ((O = re.trans) === null || O === void 0 ? void 0 : O.db._options.cache) === "immutable", v = re, g = v.requery, L = v.signal, O = function(b, C, S, P) {
              var E = nl["idb://".concat(b, "/").concat(C)];
              if (!E) return [];
              if (!(C = E.queries[S])) return [null, !1, E, null];
              var N = C[(P.query ? P.query.index.name : null) || ""];
              if (!N) return [null, !1, E, null];
              switch (S) {
                case "query":
                  var F = N.find(function(G) {
                    return G.req.limit === P.limit && G.req.values === P.values && wu(G.req.query.range, P.query.range);
                  });
                  return F ? [F, !0, E, N] : [N.find(function(G) {
                    return ("limit" in G.req ? G.req.limit : 1 / 0) >= P.limit && (!P.values || G.req.values) && Lr(G.req.query.range, P.query.range);
                  }), !1, E, N];
                case "count":
                  return F = N.find(function(G) {
                    return wu(G.req.query.range, P.query.range);
                  }), [F, !!F, E, N];
              }
            }(t, u, "query", f), w = O[0], v = O[1], T = O[2], D = O[3];
            return w && v ? w.obsSet = f.obsSet : (v = r.query(f).then(function(b) {
              var C = b.result;
              if (w && (w.res = C), p) {
                for (var S = 0, P = C.length; S < P; ++S) Object.freeze(C[S]);
                Object.freeze(C);
              } else b.result = ve(C);
              return b;
            }).catch(function(b) {
              return D && w && de(D, w), Promise.reject(b);
            }), w = { obsSet: f.obsSet, promise: v, subscribers: /* @__PURE__ */ new Set(), type: "query", req: f, dirty: !1 }, D ? D.push(w) : (D = [w], (T = T || (nl["idb://".concat(t, "/").concat(u)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[f.query.index.name || ""] = D)), Dr(w, D, g, L), w.promise.then(function(b) {
              return { result: bu(b.result, f, T?.optimisticOps, r, w, p) };
            });
          } });
        } });
      } };
      function ot(n, t) {
        return new Proxy(n, { get: function(u, r, c) {
          return r === "db" ? t : Reflect.get(u, r, c);
        } });
      }
      var En = ($e.prototype.version = function(n) {
        if (isNaN(n) || n < 0.1) throw new Z.Type("Given version is not a positive number");
        if (n = Math.round(10 * n) / 10, this.idbdb || this._state.isBeingOpened) throw new Z.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, n);
        var t = this._versions, u = t.filter(function(r) {
          return r._cfg.version === n;
        })[0];
        return u || (u = new this.Version(n), t.push(u), t.sort(fr), u.stores({}), this._state.autoSchema = !1, u);
      }, $e.prototype._whenReady = function(n) {
        var t = this;
        return this.idbdb && (this._state.openComplete || re.letThrough || this._vip) ? n() : new ee(function(u, r) {
          if (t._state.openComplete) return r(new Z.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void r(new Z.DatabaseClosed());
            t.open().catch(Oe);
          }
          t._state.dbReadyPromise.then(u, r);
        }).then(n);
      }, $e.prototype.use = function(n) {
        var t = n.stack, u = n.create, r = n.level, c = n.name;
        return c && this.unuse({ stack: t, name: c }), n = this._middlewares[t] || (this._middlewares[t] = []), n.push({ stack: t, create: u, level: r ?? 10, name: c }), n.sort(function(f, p) {
          return f.level - p.level;
        }), this;
      }, $e.prototype.unuse = function(n) {
        var t = n.stack, u = n.name, r = n.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(c) {
          return r ? c.create !== r : !!u && c.name !== u;
        })), this;
      }, $e.prototype.open = function() {
        var n = this;
        return Qn(An, function() {
          return gr(n);
        });
      }, $e.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var n = this._state, t = ol.indexOf(this);
        if (0 <= t && ol.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        n.isBeingOpened || (n.dbReadyPromise = new ee(function(u) {
          n.dbReadyResolve = u;
        }), n.openCanceller = new ee(function(u, r) {
          n.cancelOpen = r;
        }));
      }, $e.prototype.close = function(u) {
        var t = (u === void 0 ? { disableAutoOpen: !0 } : u).disableAutoOpen, u = this._state;
        t ? (u.isBeingOpened && u.cancelOpen(new Z.DatabaseClosed()), this._close(), u.autoOpen = !1, u.dbOpenError = new Z.DatabaseClosed()) : (this._close(), u.autoOpen = this._options.autoOpen || u.isBeingOpened, u.openComplete = !1, u.dbOpenError = null);
      }, $e.prototype.delete = function(n) {
        var t = this;
        n === void 0 && (n = { disableAutoOpen: !0 });
        var u = 0 < arguments.length && typeof arguments[0] != "object", r = this._state;
        return new ee(function(c, f) {
          function p() {
            t.close(n);
            var g = t._deps.indexedDB.deleteDatabase(t.name);
            g.onsuccess = Be(function() {
              var L, O, w;
              L = t._deps, O = t.name, w = L.indexedDB, L = L.IDBKeyRange, jt(w) || O === Wl || zt(w, L).delete(O).catch(Oe), c();
            }), g.onerror = bn(f), g.onblocked = t._fireOnBlocked;
          }
          if (u) throw new Z.InvalidArgument("Invalid closeOptions argument to db.delete()");
          r.isBeingOpened ? r.dbReadyPromise.then(p) : p();
        });
      }, $e.prototype.backendDB = function() {
        return this.idbdb;
      }, $e.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, $e.prototype.hasBeenClosed = function() {
        var n = this._state.dbOpenError;
        return n && n.name === "DatabaseClosed";
      }, $e.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, $e.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty($e.prototype, "tables", { get: function() {
        var n = this;
        return m(this._allTables).map(function(t) {
          return n._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), $e.prototype.transaction = function() {
        var n = (function(t, u, r) {
          var c = arguments.length;
          if (c < 2) throw new Z.InvalidArgument("Too few arguments");
          for (var f = new Array(c - 1); --c; ) f[c - 1] = arguments[c];
          return r = f.pop(), [t, ce(f), r];
        }).apply(this, arguments);
        return this._transaction.apply(this, n);
      }, $e.prototype._transaction = function(n, t, u) {
        var r = this, c = re.trans;
        c && c.db === this && n.indexOf("!") === -1 || (c = null);
        var f, p, g = n.indexOf("?") !== -1;
        n = n.replace("!", "").replace("?", "");
        try {
          if (p = t.map(function(O) {
            if (O = O instanceof r.Table ? O.name : O, typeof O != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return O;
          }), n == "r" || n === _t) f = _t;
          else {
            if (n != "rw" && n != Nt) throw new Z.InvalidArgument("Invalid transaction mode: " + n);
            f = Nt;
          }
          if (c) {
            if (c.mode === _t && f === Nt) {
              if (!g) throw new Z.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              c = null;
            }
            c && p.forEach(function(O) {
              if (c && c.storeNames.indexOf(O) === -1) {
                if (!g) throw new Z.SubTransaction("Table " + O + " not included in parent transaction.");
                c = null;
              }
            }), g && c && !c.active && (c = null);
          }
        } catch (O) {
          return c ? c._promise(null, function(w, v) {
            v(O);
          }) : He(O);
        }
        var L = (function O(w, v, T, D, b) {
          return ee.resolve().then(function() {
            var C = re.transless || re, S = w._createTransaction(v, T, w._dbSchema, D);
            if (S.explicit = !0, C = { trans: S, transless: C }, D) S.idbtrans = D.idbtrans;
            else try {
              S.create(), S.idbtrans._explicit = !0, w._state.PR1398_maxLoop = 3;
            } catch (N) {
              return N.name === k.InvalidState && w.isOpen() && 0 < --w._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), w.close({ disableAutoOpen: !1 }), w.open().then(function() {
                return O(w, v, T, null, b);
              })) : He(N);
            }
            var P, E = Ye(b);
            return E && cl(), C = ee.follow(function() {
              var N;
              (P = b.call(S, S)) && (E ? (N = Kn.bind(null, null), P.then(N, N)) : typeof P.next == "function" && typeof P.throw == "function" && (P = Jt(P)));
            }, C), (P && typeof P.then == "function" ? ee.resolve(P).then(function(N) {
              return S.active ? N : He(new Z.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : C.then(function() {
              return P;
            })).then(function(N) {
              return D && S._resolve(), S._completion.then(function() {
                return N;
              });
            }).catch(function(N) {
              return S._reject(N), He(N);
            });
          });
        }).bind(null, this, f, p, c, u);
        return c ? c._promise(f, L, "lock") : re.trans ? Qn(re.transless, function() {
          return r._whenReady(L);
        }) : this._whenReady(L);
      }, $e.prototype.table = function(n) {
        if (!I(this._allTables, n)) throw new Z.InvalidTable("Table ".concat(n, " does not exist"));
        return this._allTables[n];
      }, $e);
      function $e(n, t) {
        var u = this;
        this._middlewares = {}, this.verno = 0;
        var r = $e.dependencies;
        this._options = t = a({ addons: $e.addons, autoOpen: !0, indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, r = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var c, f, p, g, L, O = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: Oe, dbReadyPromise: null, cancelOpen: Oe, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        O.dbReadyPromise = new ee(function(v) {
          O.dbReadyResolve = v;
        }), O.openCanceller = new ee(function(v, T) {
          O.cancelOpen = T;
        }), this._state = O, this.name = n, this.on = Ll(this, "populate", "blocked", "versionchange", "close", { ready: [_e, Oe] }), this.once = function(v, T) {
          var D = function() {
            for (var b = [], C = 0; C < arguments.length; C++) b[C] = arguments[C];
            u.on(v).unsubscribe(D), T.apply(u, b);
          };
          return u.on(v, D);
        }, this.on.ready.subscribe = B(this.on.ready.subscribe, function(v) {
          return function(T, D) {
            $e.vip(function() {
              var b, C = u._state;
              C.openComplete ? (C.dbOpenError || ee.resolve().then(T), D && v(T)) : C.onReadyBeingFired ? (C.onReadyBeingFired.push(T), D && v(T)) : (v(T), b = u, D || v(function S() {
                b.on.ready.unsubscribe(T), b.on.ready.unsubscribe(S);
              }));
            });
          };
        }), this.Collection = (c = this, Dl(ur.prototype, function(P, S) {
          this.db = c;
          var D = nu, b = null;
          if (S) try {
            D = S();
          } catch (E) {
            b = E;
          }
          var C = P._ctx, S = C.table, P = S.hook.reading.fire;
          this._ctx = { table: S, index: C.index, isPrimKey: !C.index || S.schema.primKey.keyPath && C.index === S.schema.primKey.name, range: D, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: b, or: C.or, valueMapper: P !== j ? P : null };
        })), this.Table = (f = this, Dl(uu.prototype, function(v, T, D) {
          this.db = f, this._tx = D, this.name = v, this.schema = T, this.hook = f._allTables[v] ? f._allTables[v].hook : Ll(null, { creating: [Te, Oe], reading: [ue, j], updating: [we, Oe], deleting: [Le, Oe] });
        })), this.Transaction = (p = this, Dl(sr.prototype, function(v, T, D, b, C) {
          var S = this;
          v !== "readonly" && T.forEach(function(P) {
            P = (P = D[P]) === null || P === void 0 ? void 0 : P.yProps, P && (T = T.concat(P.map(function(E) {
              return E.updatesTable;
            })));
          }), this.db = p, this.mode = v, this.storeNames = T, this.schema = D, this.chromeTransactionDurability = b, this.idbtrans = null, this.on = Ll(this, "complete", "error", "abort"), this.parent = C || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ee(function(P, E) {
            S._resolve = P, S._reject = E;
          }), this._completion.then(function() {
            S.active = !1, S.on.complete.fire();
          }, function(P) {
            var E = S.active;
            return S.active = !1, S.on.error.fire(P), S.parent ? S.parent._reject(P) : E && S.idbtrans && S.idbtrans.abort(), He(P);
          });
        })), this.Version = (g = this, Dl(hr.prototype, function(v) {
          this.db = g, this._cfg = { version: v, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (L = this, Dl(mu.prototype, function(v, T, D) {
          if (this.db = L, this._ctx = { table: v, index: T === ":id" ? null : T, or: D }, this._cmp = this._ascending = Ce, this._descending = function(b, C) {
            return Ce(C, b);
          }, this._max = function(b, C) {
            return 0 < Ce(b, C) ? b : C;
          }, this._min = function(b, C) {
            return Ce(b, C) < 0 ? b : C;
          }, this._IDBKeyRange = L._deps.IDBKeyRange, !this._IDBKeyRange) throw new Z.MissingAPI();
        })), this.on("versionchange", function(v) {
          0 < v.newVersion ? console.warn("Another connection wants to upgrade database '".concat(u.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(u.name, "'. Closing db now to resume the delete request.")), u.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(v) {
          !v.newVersion || v.newVersion < v.oldVersion ? console.warn("Dexie.delete('".concat(u.name, "') was blocked")) : console.warn("Upgrade '".concat(u.name, "' blocked by other connection holding version ").concat(v.oldVersion / 10));
        }), this._maxKey = Sl(t.IDBKeyRange), this._createTransaction = function(v, T, D, b) {
          return new u.Transaction(v, T, D, u._options.chromeTransactionDurability, b);
        }, this._fireOnBlocked = function(v) {
          u.on("blocked").fire(v), ol.filter(function(T) {
            return T.name === u.name && T !== u && !T._state.vcFired;
          }).map(function(T) {
            return T.on("versionchange").fire(v);
          });
        }, this.use(yr), this.use(Or), this.use(Ir), this.use(vr), this.use(xr);
        var w = new Proxy(this, { get: function(v, T, D) {
          if (T === "_vip") return !0;
          if (T === "table") return function(C) {
            return ot(u.table(C), w);
          };
          var b = Reflect.get(v, T, D);
          return b instanceof uu ? ot(b, w) : T === "tables" ? b.map(function(C) {
            return ot(C, w);
          }) : T === "_createTransaction" ? function() {
            return ot(b.apply(this, arguments), w);
          } : b;
        } });
        this.vip = w, r.forEach(function(v) {
          return v(u);
        });
      }
      var mt, In = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", br = (ti.prototype.subscribe = function(n, t, u) {
        return this._subscribe(n && typeof n != "function" ? n : { next: n, error: t, complete: u });
      }, ti.prototype[In] = function() {
        return this;
      }, ti);
      function ti(n) {
        this._subscribe = n;
      }
      try {
        mt = { indexedDB: o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB, IDBKeyRange: o.IDBKeyRange || o.webkitIDBKeyRange };
      } catch {
        mt = { indexedDB: null, IDBKeyRange: null };
      }
      function Su(n) {
        var t, u = !1, r = new br(function(c) {
          var f = Ye(n), p, g = !1, L = {}, O = {}, w = { get closed() {
            return g;
          }, unsubscribe: function() {
            g || (g = !0, p && p.abort(), v && jn.storagemutated.unsubscribe(D));
          } };
          c.start && c.start(w);
          var v = !1, T = function() {
            return Et(b);
          }, D = function(C) {
            rt(L, C), Wt(O, L) && T();
          }, b = function() {
            var C, S, P;
            !g && mt.indexedDB && (L = {}, C = {}, p && p.abort(), p = new AbortController(), P = function(E) {
              var N = rl();
              try {
                f && cl();
                var F = Un(n, E);
                return F = f ? F.finally(Kn) : F;
              } finally {
                N && sl();
              }
            }(S = { subscr: C, signal: p.signal, requery: T, querier: n, trans: null }), Promise.resolve(P).then(function(E) {
              u = !0, t = E, g || S.signal.aborted || (L = {}, function(N) {
                for (var F in N) if (I(N, F)) return;
                return 1;
              }(O = C) || v || (jn(wl, D), v = !0), Et(function() {
                return !g && c.next && c.next(E);
              }));
            }, function(E) {
              u = !1, ["DatabaseClosedError", "AbortError"].includes(E?.name) || g || Et(function() {
                g || c.error && c.error(E);
              });
            }));
          };
          return setTimeout(T, 0), w;
        });
        return r.hasValue = function() {
          return u;
        }, r.getValue = function() {
          return t;
        }, r;
      }
      var ll = En;
      function ii(n) {
        var t = Hn;
        try {
          Hn = !0, jn.storagemutated.fire(n), Qt(n, !0);
        } finally {
          Hn = t;
        }
      }
      q(ll, a(a({}, Qe), { delete: function(n) {
        return new ll(n, { addons: [] }).delete();
      }, exists: function(n) {
        return new ll(n, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(n) {
        try {
          return t = ll.dependencies, u = t.indexedDB, t = t.IDBKeyRange, (jt(u) ? Promise.resolve(u.databases()).then(function(r) {
            return r.map(function(c) {
              return c.name;
            }).filter(function(c) {
              return c !== Wl;
            });
          }) : zt(u, t).toCollection().primaryKeys()).then(n);
        } catch {
          return He(new Z.MissingAPI());
        }
        var t, u;
      }, defineClass: function() {
        return function(n) {
          h(this, n);
        };
      }, ignoreTransaction: function(n) {
        return re.trans ? Qn(re.transless, n) : n();
      }, vip: Ht, async: function(n) {
        return function() {
          try {
            var t = Jt(n.apply(this, arguments));
            return t && typeof t.then == "function" ? t : ee.resolve(t);
          } catch (u) {
            return He(u);
          }
        };
      }, spawn: function(n, t, u) {
        try {
          var r = Jt(n.apply(u, t || []));
          return r && typeof r.then == "function" ? r : ee.resolve(r);
        } catch (c) {
          return He(c);
        }
      }, currentTransaction: { get: function() {
        return re.trans || null;
      } }, waitFor: function(n, t) {
        return t = ee.resolve(typeof n == "function" ? ll.ignoreTransaction(n) : n).timeout(t || 6e4), re.trans ? re.trans.waitFor(t) : t;
      }, Promise: ee, debug: { get: function() {
        return be;
      }, set: function(n) {
        Pe(n);
      } }, derive: V, extend: h, props: q, override: B, Events: Ll, on: jn, liveQuery: Su, extendObservabilitySet: rt, getByKeyPath: se, setByKeyPath: te, delByKeyPath: function(n, t) {
        typeof t == "string" ? te(n, t, void 0) : "length" in t && [].map.call(t, function(u) {
          te(n, u, void 0);
        });
      }, shallowClone: me, deepClone: ve, getObjectDiff: ei, cmp: Ce, asap: W, minKey: -1 / 0, addons: [], connections: ol, errnames: k, dependencies: mt, cache: nl, semVer: "4.2.0", version: "4.2.0".split(".").map(function(n) {
        return parseInt(n);
      }).reduce(function(n, t, u) {
        return n + t / Math.pow(10, 2 * u);
      }) })), ll.maxKey = Sl(ll.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (jn(wl, function(n) {
        Hn || (n = new CustomEvent(kt, { detail: n }), Hn = !0, dispatchEvent(n), Hn = !1);
      }), addEventListener(kt, function(n) {
        n = n.detail, Hn || ii(n);
      }));
      var xl, Hn = !1, Cu = function() {
      };
      return typeof BroadcastChannel < "u" && ((Cu = function() {
        (xl = new BroadcastChannel(kt)).onmessage = function(n) {
          return n.data && ii(n.data);
        };
      })(), typeof xl.unref == "function" && xl.unref(), jn(wl, function(n) {
        Hn || xl.postMessage(n);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(n) {
        if (!En.disableBfCache && n.persisted) {
          be && console.debug("Dexie: handling persisted pagehide"), xl?.close();
          for (var t = 0, u = ol; t < u.length; t++) u[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(n) {
        !En.disableBfCache && n.persisted && (be && console.debug("Dexie: handling persisted pageshow"), Cu(), ii({ all: new an(-1 / 0, [[]]) }));
      })), ee.rejectionMapper = function(n, t) {
        return !n || n instanceof un || n instanceof TypeError || n instanceof SyntaxError || !n.name || !ie[n.name] ? n : (t = new ie[n.name](t || n.message, n), "stack" in n && R(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, Pe(be), a(En, Object.freeze({ __proto__: null, Dexie: En, liveQuery: Su, Entity: lu, cmp: Ce, PropModification: Ol, replacePrefix: function(n, t) {
        return new Ol({ replacePrefix: [n, t] });
      }, add: function(n) {
        return new Ol({ add: n });
      }, remove: function(n) {
        return new Ol({ remove: n });
      }, default: En, RangeSet: an, mergeRanges: Pl, rangesOverlap: gu }), { default: En }), En;
    });
  }(Fm)), Fm.exports;
}
var iS = tS();
const Mm = /* @__PURE__ */ _w(iS), np = Symbol.for("Dexie"), za = globalThis[np] || (globalThis[np] = Mm);
if (Mm.semVer !== za.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Mm.semVer} and ${za.semVer}`);
const {
  liveQuery: MC,
  mergeRanges: kC,
  rangesOverlap: VC,
  RangeSet: BC,
  cmp: ZC,
  Entity: UC,
  PropModification: KC,
  replacePrefix: GC,
  add: zC,
  remove: jC,
  DexieYProvider: HC
} = za;
class uS extends za {
  /**
   * @param {ConstructorParameters<DexieConstructor>[0]} databaseName - Name of the database
   * @param {ConstructorParameters<DexieConstructor>[1]} options - Options for Dexie
   */
  constructor(...l) {
    super(...l), this.upgrade();
  }
  async upgrade() {
    if (this.isOpen()) {
      this.close(), lp(this), await this.open();
      return;
    }
    lp(this);
  }
}
function lp(e) {
  return e.version(1).stores({
    [rc]: Vo
  }), e.version(2).stores({
    [rc]: Vo,
    [Bo]: Jd
  }), e.version(2.1).stores({
    [rc]: Vo,
    [Bo]: Jd
  }).upgrade((l) => {
    l.table(Bo).toCollection().modify((i) => {
      typeof i.file == "string" && (i.file = new Blob([i.file], { type: "text/xml" }));
    });
  }), e;
}
async function aS(e) {
  const { databaseInstance: l, records: i } = e, a = l.table(rc);
  await l.transaction("rw", a, () => a.bulkAdd(i));
}
async function rS(e) {
  if (await za.exists(e))
    return await za.delete(e);
}
const sS = {
  useBrowserApi: !0,
  chunkSize: 32 * 1024,
  // 32KB
  batchSize: 2e3
};
async function cS({
  files: e,
  options: l = sS
}) {
  const i = [];
  if (e.length === 0) throw new Error("No files provided for import.");
  for (const a of e) {
    if (!oS(a)) {
      console.error(`Unsupported file type: ${a.name}`);
      continue;
    }
    a.size === 0 && console.warn(`File is empty: ${a.name}`);
    const s = await fS({ file: a, options: l });
    i.push(s);
  }
  return i;
}
function oS(e) {
  return Gw.some((l) => e.name.toLowerCase().endsWith(l));
}
function mS(e) {
  return e.name.replace(/\.[^.]+$/, "");
}
async function fS(e) {
  const { file: l, options: i } = e;
  try {
    const a = mS(l);
    await rS(a);
    const s = new uS(a);
    return i.useBrowserApi && l.size !== 0 && await dS({
      file: l,
      databaseInstance: s,
      options: {
        chunkSize: i.chunkSize,
        batchSize: i.batchSize
      }
    }), a;
  } catch (a) {
    throw console.error(`Error importing file ${l.name}:`, a), a;
  }
}
async function dS(e) {
  const { file: l, databaseInstance: i, options: a } = e, s = l.stream().getReader(), o = jw(), m = new TextDecoder(), d = new Uint8Array(0);
  return await km({ databaseInstance: i, reader: s, sax: o, textDecoder: m, buffer: d, options: a });
}
async function km(e) {
  const { databaseInstance: l, reader: i, sax: a, textDecoder: s, buffer: o, options: m } = e, { chunkSize: d, batchSize: h } = m, { done: x, value: y } = await i.read();
  if (x) {
    if (o.length > 0) {
      const q = s.decode(o);
      a.parser.write(q);
    }
    return a.parser.close(), await tp({
      databaseInstance: l,
      sax: a,
      batchSize: 0
    });
  }
  if (!y)
    return await km(e);
  let I = new Uint8Array(o.length + y.length);
  for (I.set(o), I.set(y, o.length); I.length >= d; ) {
    const q = I.slice(0, d);
    I = I.slice(d);
    const A = s.decode(q, { stream: !0 });
    a.parser.write(A), await tp({
      databaseInstance: l,
      sax: a,
      batchSize: h
    });
  }
  return await km({ ...e, buffer: I });
}
async function tp(e) {
  const { databaseInstance: l, sax: i, batchSize: a } = e;
  if (i.getSize() >= a) {
    const s = i.drainBatch(), o = Zw({
      currentBatch: s
    });
    await aS({
      databaseInstance: l,
      records: o
    });
  }
}
var pS = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function hS(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var sc = { exports: {} }, gS = sc.exports, ip;
function vS() {
  return ip || (ip = 1, function(e, l) {
    (function(i, a) {
      e.exports = a();
    })(gS, function() {
      var i = function(n, t) {
        return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(u, r) {
          u.__proto__ = r;
        } || function(u, r) {
          for (var c in r) Object.prototype.hasOwnProperty.call(r, c) && (u[c] = r[c]);
        })(n, t);
      }, a = function() {
        return (a = Object.assign || function(n) {
          for (var t, u = 1, r = arguments.length; u < r; u++) for (var c in t = arguments[u]) Object.prototype.hasOwnProperty.call(t, c) && (n[c] = t[c]);
          return n;
        }).apply(this, arguments);
      };
      function s(n, t, u) {
        for (var r, c = 0, f = t.length; c < f; c++) !r && c in t || ((r = r || Array.prototype.slice.call(t, 0, c))[c] = t[c]);
        return n.concat(r || Array.prototype.slice.call(t));
      }
      var o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : pS, m = Object.keys, d = Array.isArray;
      function h(n, t) {
        return typeof t != "object" || m(t).forEach(function(u) {
          n[u] = t[u];
        }), n;
      }
      typeof Promise > "u" || o.Promise || (o.Promise = Promise);
      var x = Object.getPrototypeOf, y = {}.hasOwnProperty;
      function I(n, t) {
        return y.call(n, t);
      }
      function q(n, t) {
        typeof t == "function" && (t = t(x(n))), (typeof Reflect > "u" ? m : Reflect.ownKeys)(t).forEach(function(u) {
          R(n, u, t[u]);
        });
      }
      var A = Object.defineProperty;
      function R(n, t, u, r) {
        A(n, t, h(u && I(u, "get") && typeof u.get == "function" ? { get: u.get, set: u.set, configurable: !0 } : { value: u, configurable: !0, writable: !0 }, r));
      }
      function V(n) {
        return { from: function(t) {
          return n.prototype = Object.create(t.prototype), R(n.prototype, "constructor", n), { extend: q.bind(null, n.prototype) };
        } };
      }
      var U = Object.getOwnPropertyDescriptor, z = [].slice;
      function X(n, t, u) {
        return z.call(n, t, u);
      }
      function B(n, t) {
        return t(n);
      }
      function K(n) {
        if (!n) throw new Error("Assertion Failed");
      }
      function W(n) {
        o.setImmediate ? setImmediate(n) : setTimeout(n, 0);
      }
      function se(n, t) {
        if (typeof t == "string" && I(n, t)) return n[t];
        if (!t) return n;
        if (typeof t != "string") {
          for (var u = [], r = 0, c = t.length; r < c; ++r) {
            var f = se(n, t[r]);
            u.push(f);
          }
          return u;
        }
        var p = t.indexOf(".");
        if (p !== -1) {
          var g = n[t.substr(0, p)];
          return g == null ? void 0 : se(g, t.substr(p + 1));
        }
      }
      function te(n, t, u) {
        if (n && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(n))) if (typeof t != "string" && "length" in t) {
          K(typeof u != "string" && "length" in u);
          for (var r = 0, c = t.length; r < c; ++r) te(n, t[r], u[r]);
        } else {
          var f, p, g = t.indexOf(".");
          g !== -1 ? (f = t.substr(0, g), (p = t.substr(g + 1)) === "" ? u === void 0 ? d(n) && !isNaN(parseInt(f)) ? n.splice(f, 1) : delete n[f] : n[f] = u : te(g = !(g = n[f]) || !I(n, f) ? n[f] = {} : g, p, u)) : u === void 0 ? d(n) && !isNaN(parseInt(t)) ? n.splice(t, 1) : delete n[t] : n[t] = u;
        }
      }
      function me(n) {
        var t, u = {};
        for (t in n) I(n, t) && (u[t] = n[t]);
        return u;
      }
      var M = [].concat;
      function ce(n) {
        return M.apply([], n);
      }
      var Ue = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(ce([8, 16, 32, 64].map(function(n) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + n + "Array";
        });
      }))).filter(function(n) {
        return o[n];
      }), Ie = new Set(Ue.map(function(n) {
        return o[n];
      })), ae = null;
      function ve(n) {
        return ae = /* @__PURE__ */ new WeakMap(), n = function t(u) {
          if (!u || typeof u != "object") return u;
          var r = ae.get(u);
          if (r) return r;
          if (d(u)) {
            r = [], ae.set(u, r);
            for (var c = 0, f = u.length; c < f; ++c) r.push(t(u[c]));
          } else if (Ie.has(u.constructor)) r = u;
          else {
            var p, g = x(u);
            for (p in r = g === Object.prototype ? {} : Object.create(g), ae.set(u, r), u) I(u, p) && (r[p] = t(u[p]));
          }
          return r;
        }(n), ae = null, n;
      }
      var ye = {}.toString;
      function Se(n) {
        return ye.call(n).slice(8, -1);
      }
      var ge = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", oe = typeof ge == "symbol" ? function(n) {
        var t;
        return n != null && (t = n[ge]) && t.apply(n);
      } : function() {
        return null;
      };
      function de(n, t) {
        return t = n.indexOf(t), 0 <= t && n.splice(t, 1), 0 <= t;
      }
      var De = {};
      function Ee(n) {
        var t, u, r, c;
        if (arguments.length === 1) {
          if (d(n)) return n.slice();
          if (this === De && typeof n == "string") return [n];
          if (c = oe(n)) {
            for (u = []; !(r = c.next()).done; ) u.push(r.value);
            return u;
          }
          if (n == null) return [n];
          if (typeof (t = n.length) != "number") return [n];
          for (u = new Array(t); t--; ) u[t] = n[t];
          return u;
        }
        for (t = arguments.length, u = new Array(t); t--; ) u[t] = arguments[t];
        return u;
      }
      var Ye = typeof Symbol < "u" ? function(n) {
        return n[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ze = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], In = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ze), ze = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function un(n, t) {
        this.name = n, this.message = t;
      }
      function Pn(n, t) {
        return n + ". Errors: " + Object.keys(t).map(function(u) {
          return t[u].toString();
        }).filter(function(u, r, c) {
          return c.indexOf(u) === r;
        }).join(`
`);
      }
      function xn(n, t, u, r) {
        this.failures = t, this.failedKeys = r, this.successCount = u, this.message = Pn(n, t);
      }
      function tn(n, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(u) {
          return t[u];
        }), this.failuresByPos = t, this.message = Pn(n, this.failures);
      }
      V(un).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), V(xn).from(un), V(tn).from(un);
      var k = In.reduce(function(n, t) {
        return n[t] = t + "Error", n;
      }, {}), _ = un, Z = In.reduce(function(n, t) {
        var u = t + "Error";
        function r(c, f) {
          this.name = u, c ? typeof c == "string" ? (this.message = "".concat(c).concat(f ? `
 ` + f : ""), this.inner = f || null) : typeof c == "object" && (this.message = "".concat(c.name, " ").concat(c.message), this.inner = c) : (this.message = ze[t] || u, this.inner = null);
        }
        return V(r).from(_), n[t] = r, n;
      }, {});
      Z.Syntax = SyntaxError, Z.Type = TypeError, Z.Range = RangeError;
      var ie = Ze.reduce(function(n, t) {
        return n[t + "Error"] = Z[t], n;
      }, {}), Qe = In.reduce(function(n, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (n[t + "Error"] = Z[t]), n;
      }, {});
      function Oe() {
      }
      function j(n) {
        return n;
      }
      function ue(n, t) {
        return n == null || n === j ? t : function(u) {
          return t(n(u));
        };
      }
      function fe(n, t) {
        return function() {
          n.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function Te(n, t) {
        return n === Oe ? t : function() {
          var u = n.apply(this, arguments);
          u !== void 0 && (arguments[0] = u);
          var r = this.onsuccess, c = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var f = t.apply(this, arguments);
          return r && (this.onsuccess = this.onsuccess ? fe(r, this.onsuccess) : r), c && (this.onerror = this.onerror ? fe(c, this.onerror) : c), f !== void 0 ? f : u;
        };
      }
      function Le(n, t) {
        return n === Oe ? t : function() {
          n.apply(this, arguments);
          var u = this.onsuccess, r = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), u && (this.onsuccess = this.onsuccess ? fe(u, this.onsuccess) : u), r && (this.onerror = this.onerror ? fe(r, this.onerror) : r);
        };
      }
      function we(n, t) {
        return n === Oe ? t : function(u) {
          var r = n.apply(this, arguments);
          h(u, r);
          var c = this.onsuccess, f = this.onerror;
          return this.onsuccess = null, this.onerror = null, u = t.apply(this, arguments), c && (this.onsuccess = this.onsuccess ? fe(c, this.onsuccess) : c), f && (this.onerror = this.onerror ? fe(f, this.onerror) : f), r === void 0 ? u === void 0 ? void 0 : u : h(r, u);
        };
      }
      function Ne(n, t) {
        return n === Oe ? t : function() {
          return t.apply(this, arguments) !== !1 && n.apply(this, arguments);
        };
      }
      function _e(n, t) {
        return n === Oe ? t : function() {
          var u = n.apply(this, arguments);
          if (u && typeof u.then == "function") {
            for (var r = this, c = arguments.length, f = new Array(c); c--; ) f[c] = arguments[c];
            return u.then(function() {
              return t.apply(r, f);
            });
          }
          return t.apply(this, arguments);
        };
      }
      Qe.ModifyError = xn, Qe.DexieError = un, Qe.BulkError = tn;
      var be = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function Pe(n) {
        be = n;
      }
      var Ke = {}, ke = 100, Ue = typeof Promise > "u" ? [] : function() {
        var n = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [n, x(n), n];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, x(t), n];
      }(), Ze = Ue[0], In = Ue[1], Ue = Ue[2], In = In && In.then, Je = Ze && Ze.constructor, yn = !!Ue, on = function(n, t) {
        Fn.push([n, t]), Cn && (queueMicrotask(nr), Cn = !1);
      }, Bn = !0, Cn = !0, Dn = [], Nn = [], yl = j, An = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: Oe, pgp: !1, env: {}, finalize: Oe }, re = An, Fn = [], Zn = 0, Il = [];
      function ee(n) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = re;
        if (typeof n != "function") {
          if (n !== Ke) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && qt(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function u(r, c) {
          try {
            c(function(f) {
              if (r._state === null) {
                if (f === r) throw new TypeError("A promise cannot be resolved with itself.");
                var p = r._lib && rl();
                f && typeof f.then == "function" ? u(r, function(g, L) {
                  f instanceof ee ? f._then(g, L) : f.then(g, L);
                }) : (r._state = !0, r._value = f, Xi(r)), p && sl();
              }
            }, qt.bind(null, r));
          } catch (f) {
            qt(r, f);
          }
        }(this, n);
      }
      var Pt = { get: function() {
        var n = re, t = Hl;
        function u(r, c) {
          var f = this, p = !n.global && (n !== re || t !== Hl), g = p && !Kn(), L = new ee(function(O, w) {
            At(f, new Yi(Ji(r, n, p, g), Ji(c, n, p, g), O, w, n));
          });
          return this._consoleTask && (L._consoleTask = this._consoleTask), L;
        }
        return u.prototype = Ke, u;
      }, set: function(n) {
        R(this, "then", n && n.prototype === Ke ? Pt : { get: function() {
          return n;
        }, set: Pt.set });
      } };
      function Yi(n, t, u, r, c) {
        this.onFulfilled = typeof n == "function" ? n : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = u, this.reject = r, this.psd = c;
      }
      function qt(n, t) {
        var u, r;
        Nn.push(t), n._state === null && (u = n._lib && rl(), t = yl(t), n._state = !1, n._value = t, r = n, Dn.some(function(c) {
          return c._value === r._value;
        }) || Dn.push(r), Xi(n), u && sl());
      }
      function Xi(n) {
        var t = n._listeners;
        n._listeners = [];
        for (var u = 0, r = t.length; u < r; ++u) At(n, t[u]);
        var c = n._PSD;
        --c.ref || c.finalize(), Zn === 0 && (++Zn, on(function() {
          --Zn == 0 && Rt();
        }, []));
      }
      function At(n, t) {
        if (n._state !== null) {
          var u = n._state ? t.onFulfilled : t.onRejected;
          if (u === null) return (n._state ? t.resolve : t.reject)(n._value);
          ++t.psd.ref, ++Zn, on(er, [u, n, t]);
        } else n._listeners.push(t);
      }
      function er(n, t, u) {
        try {
          var r, c = t._value;
          !t._state && Nn.length && (Nn = []), r = be && t._consoleTask ? t._consoleTask.run(function() {
            return n(c);
          }) : n(c), t._state || Nn.indexOf(c) !== -1 || function(f) {
            for (var p = Dn.length; p; ) if (Dn[--p]._value === f._value) return Dn.splice(p, 1);
          }(t), u.resolve(r);
        } catch (f) {
          u.reject(f);
        } finally {
          --Zn == 0 && Rt(), --u.psd.ref || u.psd.finalize();
        }
      }
      function nr() {
        Qn(An, function() {
          rl() && sl();
        });
      }
      function rl() {
        var n = Bn;
        return Cn = Bn = !1, n;
      }
      function sl() {
        var n, t, u;
        do
          for (; 0 < Fn.length; ) for (n = Fn, Fn = [], u = n.length, t = 0; t < u; ++t) {
            var r = n[t];
            r[0].apply(null, r[1]);
          }
        while (0 < Fn.length);
        Cn = Bn = !0;
      }
      function Rt() {
        var n = Dn;
        Dn = [], n.forEach(function(r) {
          r._PSD.onunhandled.call(null, r._value, r);
        });
        for (var t = Il.slice(0), u = t.length; u; ) t[--u]();
      }
      function Gl(n) {
        return new ee(Ke, !1, n);
      }
      function Be(n, t) {
        var u = re;
        return function() {
          var r = rl(), c = re;
          try {
            return Gn(u, !0), n.apply(this, arguments);
          } catch (f) {
            t && t(f);
          } finally {
            Gn(c, !1), r && sl();
          }
        };
      }
      q(ee.prototype, { then: Pt, _then: function(n, t) {
        At(this, new Yi(null, null, n, t, re));
      }, catch: function(n) {
        if (arguments.length === 1) return this.then(null, n);
        var t = n, u = arguments[1];
        return typeof t == "function" ? this.then(null, function(r) {
          return (r instanceof t ? u : Gl)(r);
        }) : this.then(null, function(r) {
          return (r && r.name === t ? u : Gl)(r);
        });
      }, finally: function(n) {
        return this.then(function(t) {
          return ee.resolve(n()).then(function() {
            return t;
          });
        }, function(t) {
          return ee.resolve(n()).then(function() {
            return Gl(t);
          });
        });
      }, timeout: function(n, t) {
        var u = this;
        return n < 1 / 0 ? new ee(function(r, c) {
          var f = setTimeout(function() {
            return c(new Z.Timeout(t));
          }, n);
          u.then(r, c).finally(clearTimeout.bind(null, f));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && R(ee.prototype, Symbol.toStringTag, "Dexie.Promise"), An.env = Qi(), q(ee, { all: function() {
        var n = Ee.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.length === 0 && t([]);
          var r = n.length;
          n.forEach(function(c, f) {
            return ee.resolve(c).then(function(p) {
              n[f] = p, --r || t(n);
            }, u);
          });
        });
      }, resolve: function(n) {
        return n instanceof ee ? n : n && typeof n.then == "function" ? new ee(function(t, u) {
          n.then(t, u);
        }) : new ee(Ke, !0, n);
      }, reject: Gl, race: function() {
        var n = Ee.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.map(function(r) {
            return ee.resolve(r).then(t, u);
          });
        });
      }, PSD: { get: function() {
        return re;
      }, set: function(n) {
        return re = n;
      } }, totalEchoes: { get: function() {
        return Hl;
      } }, newPSD: Un, usePSD: Qn, scheduler: { get: function() {
        return on;
      }, set: function(n) {
        on = n;
      } }, rejectionMapper: { get: function() {
        return yl;
      }, set: function(n) {
        yl = n;
      } }, follow: function(n, t) {
        return new ee(function(u, r) {
          return Un(function(c, f) {
            var p = re;
            p.unhandleds = [], p.onunhandled = f, p.finalize = fe(function() {
              var g, L = this;
              g = function() {
                L.unhandleds.length === 0 ? c() : f(L.unhandleds[0]);
              }, Il.push(function O() {
                g(), Il.splice(Il.indexOf(O), 1);
              }), ++Zn, on(function() {
                --Zn == 0 && Rt();
              }, []);
            }, p.finalize), n();
          }, t, u, r);
        });
      } }), Je && (Je.allSettled && R(ee, "allSettled", function() {
        var n = Ee.apply(null, arguments).map($l);
        return new ee(function(t) {
          n.length === 0 && t([]);
          var u = n.length, r = new Array(u);
          n.forEach(function(c, f) {
            return ee.resolve(c).then(function(p) {
              return r[f] = { status: "fulfilled", value: p };
            }, function(p) {
              return r[f] = { status: "rejected", reason: p };
            }).then(function() {
              return --u || t(r);
            });
          });
        });
      }), Je.any && typeof AggregateError < "u" && R(ee, "any", function() {
        var n = Ee.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.length === 0 && u(new AggregateError([]));
          var r = n.length, c = new Array(r);
          n.forEach(function(f, p) {
            return ee.resolve(f).then(function(g) {
              return t(g);
            }, function(g) {
              c[p] = g, --r || u(new AggregateError(c));
            });
          });
        });
      }), Je.withResolvers && (ee.withResolvers = Je.withResolvers));
      var en = { awaits: 0, echoes: 0, id: 0 }, lr = 0, zl = [], jl = 0, Hl = 0, tr = 0;
      function Un(n, t, u, r) {
        var c = re, f = Object.create(c);
        return f.parent = c, f.ref = 0, f.global = !1, f.id = ++tr, An.env, f.env = yn ? { Promise: ee, PromiseProp: { value: ee, configurable: !0, writable: !0 }, all: ee.all, race: ee.race, allSettled: ee.allSettled, any: ee.any, resolve: ee.resolve, reject: ee.reject } : {}, t && h(f, t), ++c.ref, f.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, r = Qn(f, n, u, r), f.ref === 0 && f.finalize(), r;
      }
      function cl() {
        return en.id || (en.id = ++lr), ++en.awaits, en.echoes += ke, en.id;
      }
      function Kn() {
        return !!en.awaits && (--en.awaits == 0 && (en.id = 0), en.echoes = en.awaits * ke, !0);
      }
      function $l(n) {
        return en.echoes && n && n.constructor === Je ? (cl(), n.then(function(t) {
          return Kn(), t;
        }, function(t) {
          return Kn(), He(t);
        })) : n;
      }
      function ir() {
        var n = zl[zl.length - 1];
        zl.pop(), Gn(n, !1);
      }
      function Gn(n, t) {
        var u, r = re;
        (t ? !en.echoes || jl++ && n === re : !jl || --jl && n === re) || queueMicrotask(t ? (function(c) {
          ++Hl, en.echoes && --en.echoes != 0 || (en.echoes = en.awaits = en.id = 0), zl.push(re), Gn(c, !0);
        }).bind(null, n) : ir), n !== re && (re = n, r === An && (An.env = Qi()), yn && (u = An.env.Promise, t = n.env, (r.global || n.global) && (Object.defineProperty(o, "Promise", t.PromiseProp), u.all = t.all, u.race = t.race, u.resolve = t.resolve, u.reject = t.reject, t.allSettled && (u.allSettled = t.allSettled), t.any && (u.any = t.any))));
      }
      function Qi() {
        var n = o.Promise;
        return yn ? { Promise: n, PromiseProp: Object.getOwnPropertyDescriptor(o, "Promise"), all: n.all, race: n.race, allSettled: n.allSettled, any: n.any, resolve: n.resolve, reject: n.reject } : {};
      }
      function Qn(n, t, u, r, c) {
        var f = re;
        try {
          return Gn(n, !0), t(u, r, c);
        } finally {
          Gn(f, !1);
        }
      }
      function Ji(n, t, u, r) {
        return typeof n != "function" ? n : function() {
          var c = re;
          u && cl(), Gn(t, !0);
          try {
            return n.apply(this, arguments);
          } finally {
            Gn(c, !1), r && queueMicrotask(Kn);
          }
        };
      }
      function Et(n) {
        Promise === Je && en.echoes === 0 ? jl === 0 ? n() : enqueueNativeMicroTask(n) : setTimeout(n, 0);
      }
      ("" + In).indexOf("[native code]") === -1 && (cl = Kn = Oe);
      var He = ee.reject, Jn = "", Rn = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", eu = "String expected.", ol = [], Wl = "__dbnames", _t = "readonly", Nt = "readwrite";
      function el(n, t) {
        return n ? t ? function() {
          return n.apply(this, arguments) && t.apply(this, arguments);
        } : n : t;
      }
      var nu = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Yl(n) {
        return typeof n != "string" || /\./.test(n) ? function(t) {
          return t;
        } : function(t) {
          return t[n] === void 0 && n in t && delete (t = ve(t))[n], t;
        };
      }
      function lu() {
        throw Z.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Ce(n, t) {
        try {
          var u = tu(n), r = tu(t);
          if (u !== r) return u === "Array" ? 1 : r === "Array" ? -1 : u === "binary" ? 1 : r === "binary" ? -1 : u === "string" ? 1 : r === "string" ? -1 : u === "Date" ? 1 : r !== "Date" ? NaN : -1;
          switch (u) {
            case "number":
            case "Date":
            case "string":
              return t < n ? 1 : n < t ? -1 : 0;
            case "binary":
              return function(c, f) {
                for (var p = c.length, g = f.length, L = p < g ? p : g, O = 0; O < L; ++O) if (c[O] !== f[O]) return c[O] < f[O] ? -1 : 1;
                return p === g ? 0 : p < g ? -1 : 1;
              }(iu(n), iu(t));
            case "Array":
              return function(c, f) {
                for (var p = c.length, g = f.length, L = p < g ? p : g, O = 0; O < L; ++O) {
                  var w = Ce(c[O], f[O]);
                  if (w !== 0) return w;
                }
                return p === g ? 0 : p < g ? -1 : 1;
              }(n, t);
          }
        } catch {
        }
        return NaN;
      }
      function tu(n) {
        var t = typeof n;
        return t != "object" ? t : ArrayBuffer.isView(n) ? "binary" : (n = Se(n), n === "ArrayBuffer" ? "binary" : n);
      }
      function iu(n) {
        return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n);
      }
      function Xl(n, t, u) {
        var r = n.schema.yProps;
        return r ? (t && 0 < u.numFailures && (t = t.filter(function(c, f) {
          return !u.failures[f];
        })), Promise.all(r.map(function(c) {
          return c = c.updatesTable, t ? n.db.table(c).where("k").anyOf(t).delete() : n.db.table(c).clear();
        })).then(function() {
          return u;
        })) : u;
      }
      var uu = (Ve.prototype._trans = function(n, t, u) {
        var r = this._tx || re.trans, c = this.name, f = be && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(n === "readonly" ? "read" : "write", " ").concat(this.name));
        function p(O, w, v) {
          if (!v.schema[c]) throw new Z.NotFound("Table " + c + " not part of transaction");
          return t(v.idbtrans, v);
        }
        var g = rl();
        try {
          var L = r && r.db._novip === this.db._novip ? r === re.trans ? r._promise(n, p, u) : Un(function() {
            return r._promise(n, p, u);
          }, { trans: r, transless: re.transless || re }) : function O(w, v, T, D) {
            if (w.idbdb && (w._state.openComplete || re.letThrough || w._vip)) {
              var b = w._createTransaction(v, T, w._dbSchema);
              try {
                b.create(), w._state.PR1398_maxLoop = 3;
              } catch (C) {
                return C.name === k.InvalidState && w.isOpen() && 0 < --w._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), w.close({ disableAutoOpen: !1 }), w.open().then(function() {
                  return O(w, v, T, D);
                })) : He(C);
              }
              return b._promise(v, function(C, S) {
                return Un(function() {
                  return re.trans = b, D(C, S, b);
                });
              }).then(function(C) {
                if (v === "readwrite") try {
                  b.idbtrans.commit();
                } catch {
                }
                return v === "readonly" ? C : b._completion.then(function() {
                  return C;
                });
              });
            }
            if (w._state.openComplete) return He(new Z.DatabaseClosed(w._state.dbOpenError));
            if (!w._state.isBeingOpened) {
              if (!w._state.autoOpen) return He(new Z.DatabaseClosed());
              w.open().catch(Oe);
            }
            return w._state.dbReadyPromise.then(function() {
              return O(w, v, T, D);
            });
          }(this.db, n, [this.name], p);
          return f && (L._consoleTask = f, L = L.catch(function(O) {
            return console.trace(O), He(O);
          })), L;
        } finally {
          g && sl();
        }
      }, Ve.prototype.get = function(n, t) {
        var u = this;
        return n && n.constructor === Object ? this.where(n).first(t) : n == null ? He(new Z.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(r) {
          return u.core.get({ trans: r, key: n }).then(function(c) {
            return u.hook.reading.fire(c);
          });
        }).then(t);
      }, Ve.prototype.where = function(n) {
        if (typeof n == "string") return new this.db.WhereClause(this, n);
        if (d(n)) return new this.db.WhereClause(this, "[".concat(n.join("+"), "]"));
        var t = m(n);
        if (t.length === 1) return this.where(t[0]).equals(n[t[0]]);
        var u = this.schema.indexes.concat(this.schema.primKey).filter(function(g) {
          if (g.compound && t.every(function(O) {
            return 0 <= g.keyPath.indexOf(O);
          })) {
            for (var L = 0; L < t.length; ++L) if (t.indexOf(g.keyPath[L]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(g, L) {
          return g.keyPath.length - L.keyPath.length;
        })[0];
        if (u && this.db._maxKey !== Jn) {
          var f = u.keyPath.slice(0, t.length);
          return this.where(f).equals(f.map(function(L) {
            return n[L];
          }));
        }
        !u && be && console.warn("The query ".concat(JSON.stringify(n), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var r = this.schema.idxByName;
        function c(g, L) {
          return Ce(g, L) === 0;
        }
        var p = t.reduce(function(v, L) {
          var O = v[0], w = v[1], v = r[L], T = n[L];
          return [O || v, O || !v ? el(w, v && v.multi ? function(D) {
            return D = se(D, L), d(D) && D.some(function(b) {
              return c(T, b);
            });
          } : function(D) {
            return c(T, se(D, L));
          }) : w];
        }, [null, null]), f = p[0], p = p[1];
        return f ? this.where(f.name).equals(n[f.keyPath]).filter(p) : u ? this.filter(p) : this.where(t).equals("");
      }, Ve.prototype.filter = function(n) {
        return this.toCollection().and(n);
      }, Ve.prototype.count = function(n) {
        return this.toCollection().count(n);
      }, Ve.prototype.offset = function(n) {
        return this.toCollection().offset(n);
      }, Ve.prototype.limit = function(n) {
        return this.toCollection().limit(n);
      }, Ve.prototype.each = function(n) {
        return this.toCollection().each(n);
      }, Ve.prototype.toArray = function(n) {
        return this.toCollection().toArray(n);
      }, Ve.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ve.prototype.orderBy = function(n) {
        return new this.db.Collection(new this.db.WhereClause(this, d(n) ? "[".concat(n.join("+"), "]") : n));
      }, Ve.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ve.prototype.mapToClass = function(n) {
        var t, u = this.db, r = this.name;
        function c() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = n).prototype instanceof lu && (function(L, O) {
          if (typeof O != "function" && O !== null) throw new TypeError("Class extends value " + String(O) + " is not a constructor or null");
          function w() {
            this.constructor = L;
          }
          i(L, O), L.prototype = O === null ? Object.create(O) : (w.prototype = O.prototype, new w());
        }(c, t = n), Object.defineProperty(c.prototype, "db", { get: function() {
          return u;
        }, enumerable: !1, configurable: !0 }), c.prototype.table = function() {
          return r;
        }, n = c);
        for (var f = /* @__PURE__ */ new Set(), p = n.prototype; p; p = x(p)) Object.getOwnPropertyNames(p).forEach(function(L) {
          return f.add(L);
        });
        function g(L) {
          if (!L) return L;
          var O, w = Object.create(n.prototype);
          for (O in L) if (!f.has(O)) try {
            w[O] = L[O];
          } catch {
          }
          return w;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = g, this.hook("reading", g), n;
      }, Ve.prototype.defineClass = function() {
        return this.mapToClass(function(n) {
          h(this, n);
        });
      }, Ve.prototype.add = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, f = r.keyPath, p = n;
        return f && c && (p = Yl(f)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "add", keys: t != null ? [t] : null, values: [p] });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (f) try {
            te(n, f, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.update = function(n, t) {
        return typeof n != "object" || d(n) ? this.where(":id").equals(n).modify(t) : (n = se(n, this.schema.primKey.keyPath), n === void 0 ? He(new Z.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(n).modify(t));
      }, Ve.prototype.put = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, f = r.keyPath, p = n;
        return f && c && (p = Yl(f)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "put", values: [p], keys: t != null ? [t] : null });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (f) try {
            te(n, f, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.delete = function(n) {
        var t = this;
        return this._trans("readwrite", function(u) {
          return t.core.mutate({ trans: u, type: "delete", keys: [n] }).then(function(r) {
            return Xl(t, [n], r);
          }).then(function(r) {
            return r.numFailures ? ee.reject(r.failures[0]) : void 0;
          });
        });
      }, Ve.prototype.clear = function() {
        var n = this;
        return this._trans("readwrite", function(t) {
          return n.core.mutate({ trans: t, type: "deleteRange", range: nu }).then(function(u) {
            return Xl(n, null, u);
          });
        }).then(function(t) {
          return t.numFailures ? ee.reject(t.failures[0]) : void 0;
        });
      }, Ve.prototype.bulkGet = function(n) {
        var t = this;
        return this._trans("readonly", function(u) {
          return t.core.getMany({ keys: n, trans: u }).then(function(r) {
            return r.map(function(c) {
              return t.hook.reading.fire(c);
            });
          });
        });
      }, Ve.prototype.bulkAdd = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, f = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new Z.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new Z.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Yl(O)) : n;
          return r.core.mutate({ trans: p, type: "add", keys: c, values: O, wantResults: f }).then(function(b) {
            var v = b.numFailures, T = b.results, D = b.lastResult, b = b.failures;
            if (v === 0) return f ? T : D;
            throw new tn("".concat(r.name, ".bulkAdd(): ").concat(v, " of ").concat(L, " operations failed"), b);
          });
        });
      }, Ve.prototype.bulkPut = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, f = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new Z.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new Z.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Yl(O)) : n;
          return r.core.mutate({ trans: p, type: "put", keys: c, values: O, wantResults: f }).then(function(b) {
            var v = b.numFailures, T = b.results, D = b.lastResult, b = b.failures;
            if (v === 0) return f ? T : D;
            throw new tn("".concat(r.name, ".bulkPut(): ").concat(v, " of ").concat(L, " operations failed"), b);
          });
        });
      }, Ve.prototype.bulkUpdate = function(n) {
        var t = this, u = this.core, r = n.map(function(p) {
          return p.key;
        }), c = n.map(function(p) {
          return p.changes;
        }), f = [];
        return this._trans("readwrite", function(p) {
          return u.getMany({ trans: p, keys: r, cache: "clone" }).then(function(g) {
            var L = [], O = [];
            n.forEach(function(v, T) {
              var D = v.key, b = v.changes, C = g[T];
              if (C) {
                for (var S = 0, P = Object.keys(b); S < P.length; S++) {
                  var E = P[S], N = b[E];
                  if (E === t.schema.primKey.keyPath) {
                    if (Ce(N, D) !== 0) throw new Z.Constraint("Cannot update primary key in bulkUpdate()");
                  } else te(C, E, N);
                }
                f.push(T), L.push(D), O.push(C);
              }
            });
            var w = L.length;
            return u.mutate({ trans: p, type: "put", keys: L, values: O, updates: { keys: r, changeSpecs: c } }).then(function(v) {
              var T = v.numFailures, D = v.failures;
              if (T === 0) return w;
              for (var b = 0, C = Object.keys(D); b < C.length; b++) {
                var S, P = C[b], E = f[Number(P)];
                E != null && (S = D[P], delete D[P], D[E] = S);
              }
              throw new tn("".concat(t.name, ".bulkUpdate(): ").concat(T, " of ").concat(w, " operations failed"), D);
            });
          });
        });
      }, Ve.prototype.bulkDelete = function(n) {
        var t = this, u = n.length;
        return this._trans("readwrite", function(r) {
          return t.core.mutate({ trans: r, type: "delete", keys: n }).then(function(c) {
            return Xl(t, n, c);
          });
        }).then(function(p) {
          var c = p.numFailures, f = p.lastResult, p = p.failures;
          if (c === 0) return f;
          throw new tn("".concat(t.name, ".bulkDelete(): ").concat(c, " of ").concat(u, " operations failed"), p);
        });
      }, Ve);
      function Ve() {
      }
      function Ll(n) {
        function t(p, g) {
          if (g) {
            for (var L = arguments.length, O = new Array(L - 1); --L; ) O[L - 1] = arguments[L];
            return u[p].subscribe.apply(null, O), n;
          }
          if (typeof p == "string") return u[p];
        }
        var u = {};
        t.addEventType = f;
        for (var r = 1, c = arguments.length; r < c; ++r) f(arguments[r]);
        return t;
        function f(p, g, L) {
          if (typeof p != "object") {
            var O;
            g = g || Ne;
            var w = { subscribers: [], fire: L = L || Oe, subscribe: function(v) {
              w.subscribers.indexOf(v) === -1 && (w.subscribers.push(v), w.fire = g(w.fire, v));
            }, unsubscribe: function(v) {
              w.subscribers = w.subscribers.filter(function(T) {
                return T !== v;
              }), w.fire = w.subscribers.reduce(g, L);
            } };
            return u[p] = t[p] = w;
          }
          m(O = p).forEach(function(v) {
            var T = O[v];
            if (d(T)) f(v, O[v][0], O[v][1]);
            else {
              if (T !== "asap") throw new Z.InvalidArgument("Invalid event config");
              var D = f(v, j, function() {
                for (var b = arguments.length, C = new Array(b); b--; ) C[b] = arguments[b];
                D.subscribers.forEach(function(S) {
                  W(function() {
                    S.apply(null, C);
                  });
                });
              });
            }
          });
        }
      }
      function Dl(n, t) {
        return V(t).from({ prototype: n }), t;
      }
      function ml(n, t) {
        return !(n.filter || n.algorithm || n.or) && (t ? n.justLimit : !n.replayFilter);
      }
      function Ft(n, t) {
        n.filter = el(n.filter, t);
      }
      function Mt(n, t, u) {
        var r = n.replayFilter;
        n.replayFilter = r ? function() {
          return el(r(), t());
        } : t, n.justLimit = u && !r;
      }
      function Ql(n, t) {
        if (n.isPrimKey) return t.primaryKey;
        var u = t.getIndexByKeyPath(n.index);
        if (!u) throw new Z.Schema("KeyPath " + n.index + " on object store " + t.name + " is not indexed");
        return u;
      }
      function au(n, t, u) {
        var r = Ql(n, t.schema);
        return t.openCursor({ trans: u, values: !n.keysOnly, reverse: n.dir === "prev", unique: !!n.unique, query: { index: r, range: n.range } });
      }
      function Jl(n, t, u, r) {
        var c = n.replayFilter ? el(n.filter, n.replayFilter()) : n.filter;
        if (n.or) {
          var f = {}, p = function(g, L, O) {
            var w, v;
            c && !c(L, O, function(T) {
              return L.stop(T);
            }, function(T) {
              return L.fail(T);
            }) || ((v = "" + (w = L.primaryKey)) == "[object ArrayBuffer]" && (v = "" + new Uint8Array(w)), I(f, v) || (f[v] = !0, t(g, L, O)));
          };
          return Promise.all([n.or._iterate(p, u), ru(au(n, r, u), n.algorithm, p, !n.keysOnly && n.valueMapper)]);
        }
        return ru(au(n, r, u), el(n.algorithm, c), t, !n.keysOnly && n.valueMapper);
      }
      function ru(n, t, u, r) {
        var c = Be(r ? function(f, p, g) {
          return u(r(f), p, g);
        } : u);
        return n.then(function(f) {
          if (f) return f.start(function() {
            var p = function() {
              return f.continue();
            };
            t && !t(f, function(g) {
              return p = g;
            }, function(g) {
              f.stop(g), p = Oe;
            }, function(g) {
              f.fail(g), p = Oe;
            }) || c(f.value, f, function(g) {
              return p = g;
            }), p();
          });
        });
      }
      var Ol = (su.prototype.execute = function(n) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var u = t.add;
          if (d(u)) return s(s([], d(n) ? n : [], !0), u).sort();
          if (typeof u == "number") return (Number(n) || 0) + u;
          if (typeof u == "bigint") try {
            return BigInt(n) + u;
          } catch {
            return BigInt(0) + u;
          }
          throw new TypeError("Invalid term ".concat(u));
        }
        if (t.remove !== void 0) {
          var r = t.remove;
          if (d(r)) return d(n) ? n.filter(function(c) {
            return !r.includes(c);
          }).sort() : [];
          if (typeof r == "number") return Number(n) - r;
          if (typeof r == "bigint") try {
            return BigInt(n) - r;
          } catch {
            return BigInt(0) - r;
          }
          throw new TypeError("Invalid subtrahend ".concat(r));
        }
        return u = (u = t.replacePrefix) === null || u === void 0 ? void 0 : u[0], u && typeof n == "string" && n.startsWith(u) ? t.replacePrefix[1] + n.substring(u.length) : n;
      }, su);
      function su(n) {
        this["@@propmod"] = n;
      }
      var ur = (Ae.prototype._read = function(n, t) {
        var u = this._ctx;
        return u.error ? u.table._trans(null, He.bind(null, u.error)) : u.table._trans("readonly", n).then(t);
      }, Ae.prototype._write = function(n) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, He.bind(null, t.error)) : t.table._trans("readwrite", n, "locked");
      }, Ae.prototype._addAlgorithm = function(n) {
        var t = this._ctx;
        t.algorithm = el(t.algorithm, n);
      }, Ae.prototype._iterate = function(n, t) {
        return Jl(this._ctx, n, t, this._ctx.table.core);
      }, Ae.prototype.clone = function(n) {
        var t = Object.create(this.constructor.prototype), u = Object.create(this._ctx);
        return n && h(u, n), t._ctx = u, t;
      }, Ae.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Ae.prototype.each = function(n) {
        var t = this._ctx;
        return this._read(function(u) {
          return Jl(t, n, u, t.table.core);
        });
      }, Ae.prototype.count = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx, c = r.table.core;
          if (ml(r, !0)) return c.count({ trans: u, query: { index: Ql(r, c.schema), range: r.range } }).then(function(p) {
            return Math.min(p, r.limit);
          });
          var f = 0;
          return Jl(r, function() {
            return ++f, !1;
          }, u, c).then(function() {
            return f;
          });
        }).then(n);
      }, Ae.prototype.sortBy = function(n, t) {
        var u = n.split(".").reverse(), r = u[0], c = u.length - 1;
        function f(L, O) {
          return O ? f(L[u[O]], O - 1) : L[r];
        }
        var p = this._ctx.dir === "next" ? 1 : -1;
        function g(L, O) {
          return Ce(f(L, c), f(O, c)) * p;
        }
        return this.toArray(function(L) {
          return L.sort(g);
        }).then(t);
      }, Ae.prototype.toArray = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx;
          if (r.dir === "next" && ml(r, !0) && 0 < r.limit) {
            var c = r.valueMapper, f = Ql(r, r.table.core.schema);
            return r.table.core.query({ trans: u, limit: r.limit, values: !0, query: { index: f, range: r.range } }).then(function(g) {
              return g = g.result, c ? g.map(c) : g;
            });
          }
          var p = [];
          return Jl(r, function(g) {
            return p.push(g);
          }, u, r.table.core).then(function() {
            return p;
          });
        }, n);
      }, Ae.prototype.offset = function(n) {
        var t = this._ctx;
        return n <= 0 || (t.offset += n, ml(t) ? Mt(t, function() {
          var u = n;
          return function(r, c) {
            return u === 0 || (u === 1 ? --u : c(function() {
              r.advance(u), u = 0;
            }), !1);
          };
        }) : Mt(t, function() {
          var u = n;
          return function() {
            return --u < 0;
          };
        })), this;
      }, Ae.prototype.limit = function(n) {
        return this._ctx.limit = Math.min(this._ctx.limit, n), Mt(this._ctx, function() {
          var t = n;
          return function(u, r, c) {
            return --t <= 0 && r(c), 0 <= t;
          };
        }, !0), this;
      }, Ae.prototype.until = function(n, t) {
        return Ft(this._ctx, function(u, r, c) {
          return !n(u.value) || (r(c), t);
        }), this;
      }, Ae.prototype.first = function(n) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(n);
      }, Ae.prototype.last = function(n) {
        return this.reverse().first(n);
      }, Ae.prototype.filter = function(n) {
        var t;
        return Ft(this._ctx, function(u) {
          return n(u.value);
        }), (t = this._ctx).isMatch = el(t.isMatch, n), this;
      }, Ae.prototype.and = function(n) {
        return this.filter(n);
      }, Ae.prototype.or = function(n) {
        return new this.db.WhereClause(this._ctx.table, n, this);
      }, Ae.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Ae.prototype.desc = function() {
        return this.reverse();
      }, Ae.prototype.eachKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.key, r);
        });
      }, Ae.prototype.eachUniqueKey = function(n) {
        return this._ctx.unique = "unique", this.eachKey(n);
      }, Ae.prototype.eachPrimaryKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.primaryKey, r);
        });
      }, Ae.prototype.keys = function(n) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.key);
        }).then(function() {
          return u;
        }).then(n);
      }, Ae.prototype.primaryKeys = function(n) {
        var t = this._ctx;
        if (t.dir === "next" && ml(t, !0) && 0 < t.limit) return this._read(function(r) {
          var c = Ql(t, t.table.core.schema);
          return t.table.core.query({ trans: r, values: !1, limit: t.limit, query: { index: c, range: t.range } });
        }).then(function(r) {
          return r.result;
        }).then(n);
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.primaryKey);
        }).then(function() {
          return u;
        }).then(n);
      }, Ae.prototype.uniqueKeys = function(n) {
        return this._ctx.unique = "unique", this.keys(n);
      }, Ae.prototype.firstKey = function(n) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(n);
      }, Ae.prototype.lastKey = function(n) {
        return this.reverse().firstKey(n);
      }, Ae.prototype.distinct = function() {
        var n = this._ctx, n = n.index && n.table.schema.idxByName[n.index];
        if (!n || !n.multi) return this;
        var t = {};
        return Ft(this._ctx, function(c) {
          var r = c.primaryKey.toString(), c = I(t, r);
          return t[r] = !0, !c;
        }), this;
      }, Ae.prototype.modify = function(n) {
        var t = this, u = this._ctx;
        return this._write(function(r) {
          var c, f, p;
          p = typeof n == "function" ? n : (c = m(n), f = c.length, function(P) {
            for (var E = !1, N = 0; N < f; ++N) {
              var F = c[N], G = n[F], Y = se(P, F);
              G instanceof Ol ? (te(P, F, G.execute(Y)), E = !0) : Y !== G && (te(P, F, G), E = !0);
            }
            return E;
          });
          var g = u.table.core, v = g.schema.primaryKey, L = v.outbound, O = v.extractKey, w = 200, v = t.db._options.modifyChunkSize;
          v && (w = typeof v == "object" ? v[g.name] || v["*"] || 200 : v);
          function T(P, F) {
            var N = F.failures, F = F.numFailures;
            b += P - F;
            for (var G = 0, Y = m(N); G < Y.length; G++) {
              var H = Y[G];
              D.push(N[H]);
            }
          }
          var D = [], b = 0, C = [], S = n === cu;
          return t.clone().primaryKeys().then(function(P) {
            function E(F) {
              var G = Math.min(w, P.length - F), Y = P.slice(F, F + G);
              return (S ? Promise.resolve([]) : g.getMany({ trans: r, keys: Y, cache: "immutable" })).then(function(H) {
                var $ = [], J = [], Q = L ? [] : null, ne = S ? Y : [];
                if (!S) for (var xe = 0; xe < G; ++xe) {
                  var qe = H[xe], he = { value: ve(qe), primKey: P[F + xe] };
                  p.call(he, he.value, he) !== !1 && (he.value == null ? ne.push(P[F + xe]) : L || Ce(O(qe), O(he.value)) === 0 ? (J.push(he.value), L && Q.push(P[F + xe])) : (ne.push(P[F + xe]), $.push(he.value)));
                }
                return Promise.resolve(0 < $.length && g.mutate({ trans: r, type: "add", values: $ }).then(function(Ge) {
                  for (var pe in Ge.failures) ne.splice(parseInt(pe), 1);
                  T($.length, Ge);
                })).then(function() {
                  return (0 < J.length || N && typeof n == "object") && g.mutate({ trans: r, type: "put", keys: Q, values: J, criteria: N, changeSpec: typeof n != "function" && n, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return T(J.length, Ge);
                  });
                }).then(function() {
                  return (0 < ne.length || N && S) && g.mutate({ trans: r, type: "delete", keys: ne, criteria: N, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return Xl(u.table, ne, Ge);
                  }).then(function(Ge) {
                    return T(ne.length, Ge);
                  });
                }).then(function() {
                  return P.length > F + G && E(F + w);
                });
              });
            }
            var N = ml(u) && u.limit === 1 / 0 && (typeof n != "function" || S) && { index: u.index, range: u.range };
            return E(0).then(function() {
              if (0 < D.length) throw new xn("Error modifying one or more objects", D, b, C);
              return P.length;
            });
          });
        });
      }, Ae.prototype.delete = function() {
        var n = this._ctx, t = n.range;
        return !ml(n) || n.table.schema.yProps || !n.isPrimKey && t.type !== 3 ? this.modify(cu) : this._write(function(u) {
          var r = n.table.core.schema.primaryKey, c = t;
          return n.table.core.count({ trans: u, query: { index: r, range: c } }).then(function(f) {
            return n.table.core.mutate({ trans: u, type: "deleteRange", range: c }).then(function(L) {
              var g = L.failures, L = L.numFailures;
              if (L) throw new xn("Could not delete some values", Object.keys(g).map(function(O) {
                return g[O];
              }), f - L);
              return f - L;
            });
          });
        });
      }, Ae);
      function Ae() {
      }
      var cu = function(n, t) {
        return t.value = null;
      };
      function ar(n, t) {
        return n < t ? -1 : n === t ? 0 : 1;
      }
      function rr(n, t) {
        return t < n ? -1 : n === t ? 0 : 1;
      }
      function pn(n, t, u) {
        return n = n instanceof mu ? new n.Collection(n) : n, n._ctx.error = new (u || TypeError)(t), n;
      }
      function fl(n) {
        return new n.Collection(n, function() {
          return ou("");
        }).limit(0);
      }
      function et(n, t, u, r) {
        var c, f, p, g, L, O, w, v = u.length;
        if (!u.every(function(b) {
          return typeof b == "string";
        })) return pn(n, eu);
        function T(b) {
          c = b === "next" ? function(S) {
            return S.toUpperCase();
          } : function(S) {
            return S.toLowerCase();
          }, f = b === "next" ? function(S) {
            return S.toLowerCase();
          } : function(S) {
            return S.toUpperCase();
          }, p = b === "next" ? ar : rr;
          var C = u.map(function(S) {
            return { lower: f(S), upper: c(S) };
          }).sort(function(S, P) {
            return p(S.lower, P.lower);
          });
          g = C.map(function(S) {
            return S.upper;
          }), L = C.map(function(S) {
            return S.lower;
          }), w = (O = b) === "next" ? "" : r;
        }
        T("next"), n = new n.Collection(n, function() {
          return zn(g[0], L[v - 1] + r);
        }), n._ondirectionchange = function(b) {
          T(b);
        };
        var D = 0;
        return n._addAlgorithm(function(b, C, S) {
          var P = b.key;
          if (typeof P != "string") return !1;
          var E = f(P);
          if (t(E, L, D)) return !0;
          for (var N = null, F = D; F < v; ++F) {
            var G = function(Y, H, $, J, Q, ne) {
              for (var xe = Math.min(Y.length, J.length), qe = -1, he = 0; he < xe; ++he) {
                var Ge = H[he];
                if (Ge !== J[he]) return Q(Y[he], $[he]) < 0 ? Y.substr(0, he) + $[he] + $.substr(he + 1) : Q(Y[he], J[he]) < 0 ? Y.substr(0, he) + J[he] + $.substr(he + 1) : 0 <= qe ? Y.substr(0, qe) + H[qe] + $.substr(qe + 1) : null;
                Q(Y[he], Ge) < 0 && (qe = he);
              }
              return xe < J.length && ne === "next" ? Y + $.substr(Y.length) : xe < Y.length && ne === "prev" ? Y.substr(0, $.length) : qe < 0 ? null : Y.substr(0, qe) + J[qe] + $.substr(qe + 1);
            }(P, E, g[F], L[F], p, O);
            G === null && N === null ? D = F + 1 : (N === null || 0 < p(N, G)) && (N = G);
          }
          return C(N !== null ? function() {
            b.continue(N + w);
          } : S), !1;
        }), n;
      }
      function zn(n, t, u, r) {
        return { type: 2, lower: n, upper: t, lowerOpen: u, upperOpen: r };
      }
      function ou(n) {
        return { type: 1, lower: n, upper: n };
      }
      var mu = (Object.defineProperty(nn.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), nn.prototype.between = function(n, t, u, r) {
        u = u !== !1, r = r === !0;
        try {
          return 0 < this._cmp(n, t) || this._cmp(n, t) === 0 && (u || r) && (!u || !r) ? fl(this) : new this.Collection(this, function() {
            return zn(n, t, !u, !r);
          });
        } catch {
          return pn(this, Rn);
        }
      }, nn.prototype.equals = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return ou(n);
        });
      }, nn.prototype.above = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return zn(n, void 0, !0);
        });
      }, nn.prototype.aboveOrEqual = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return zn(n, void 0, !1);
        });
      }, nn.prototype.below = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return zn(void 0, n, !1, !0);
        });
      }, nn.prototype.belowOrEqual = function(n) {
        return n == null ? pn(this, Rn) : new this.Collection(this, function() {
          return zn(void 0, n);
        });
      }, nn.prototype.startsWith = function(n) {
        return typeof n != "string" ? pn(this, eu) : this.between(n, n + Jn, !0, !0);
      }, nn.prototype.startsWithIgnoreCase = function(n) {
        return n === "" ? this.startsWith(n) : et(this, function(t, u) {
          return t.indexOf(u[0]) === 0;
        }, [n], Jn);
      }, nn.prototype.equalsIgnoreCase = function(n) {
        return et(this, function(t, u) {
          return t === u[0];
        }, [n], "");
      }, nn.prototype.anyOfIgnoreCase = function() {
        var n = Ee.apply(De, arguments);
        return n.length === 0 ? fl(this) : et(this, function(t, u) {
          return u.indexOf(t) !== -1;
        }, n, "");
      }, nn.prototype.startsWithAnyOfIgnoreCase = function() {
        var n = Ee.apply(De, arguments);
        return n.length === 0 ? fl(this) : et(this, function(t, u) {
          return u.some(function(r) {
            return t.indexOf(r) === 0;
          });
        }, n, Jn);
      }, nn.prototype.anyOf = function() {
        var n = this, t = Ee.apply(De, arguments), u = this._cmp;
        try {
          t.sort(u);
        } catch {
          return pn(this, Rn);
        }
        if (t.length === 0) return fl(this);
        var r = new this.Collection(this, function() {
          return zn(t[0], t[t.length - 1]);
        });
        r._ondirectionchange = function(f) {
          u = f === "next" ? n._ascending : n._descending, t.sort(u);
        };
        var c = 0;
        return r._addAlgorithm(function(f, p, g) {
          for (var L = f.key; 0 < u(L, t[c]); ) if (++c === t.length) return p(g), !1;
          return u(L, t[c]) === 0 || (p(function() {
            f.continue(t[c]);
          }), !1);
        }), r;
      }, nn.prototype.notEqual = function(n) {
        return this.inAnyRange([[-1 / 0, n], [n, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, nn.prototype.noneOf = function() {
        var n = Ee.apply(De, arguments);
        if (n.length === 0) return new this.Collection(this);
        try {
          n.sort(this._ascending);
        } catch {
          return pn(this, Rn);
        }
        var t = n.reduce(function(u, r) {
          return u ? u.concat([[u[u.length - 1][1], r]]) : [[-1 / 0, r]];
        }, null);
        return t.push([n[n.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, nn.prototype.inAnyRange = function(P, t) {
        var u = this, r = this._cmp, c = this._ascending, f = this._descending, p = this._min, g = this._max;
        if (P.length === 0) return fl(this);
        if (!P.every(function(E) {
          return E[0] !== void 0 && E[1] !== void 0 && c(E[0], E[1]) <= 0;
        })) return pn(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Z.InvalidArgument);
        var L = !t || t.includeLowers !== !1, O = t && t.includeUppers === !0, w, v = c;
        function T(E, N) {
          return v(E[0], N[0]);
        }
        try {
          (w = P.reduce(function(E, N) {
            for (var F = 0, G = E.length; F < G; ++F) {
              var Y = E[F];
              if (r(N[0], Y[1]) < 0 && 0 < r(N[1], Y[0])) {
                Y[0] = p(Y[0], N[0]), Y[1] = g(Y[1], N[1]);
                break;
              }
            }
            return F === G && E.push(N), E;
          }, [])).sort(T);
        } catch {
          return pn(this, Rn);
        }
        var D = 0, b = O ? function(E) {
          return 0 < c(E, w[D][1]);
        } : function(E) {
          return 0 <= c(E, w[D][1]);
        }, C = L ? function(E) {
          return 0 < f(E, w[D][0]);
        } : function(E) {
          return 0 <= f(E, w[D][0]);
        }, S = b, P = new this.Collection(this, function() {
          return zn(w[0][0], w[w.length - 1][1], !L, !O);
        });
        return P._ondirectionchange = function(E) {
          v = E === "next" ? (S = b, c) : (S = C, f), w.sort(T);
        }, P._addAlgorithm(function(E, N, F) {
          for (var G, Y = E.key; S(Y); ) if (++D === w.length) return N(F), !1;
          return !b(G = Y) && !C(G) || (u._cmp(Y, w[D][1]) === 0 || u._cmp(Y, w[D][0]) === 0 || N(function() {
            v === c ? E.continue(w[D][0]) : E.continue(w[D][1]);
          }), !1);
        }), P;
      }, nn.prototype.startsWithAnyOf = function() {
        var n = Ee.apply(De, arguments);
        return n.every(function(t) {
          return typeof t == "string";
        }) ? n.length === 0 ? fl(this) : this.inAnyRange(n.map(function(t) {
          return [t, t + Jn];
        })) : pn(this, "startsWithAnyOf() only works with strings");
      }, nn);
      function nn() {
      }
      function bn(n) {
        return Be(function(t) {
          return bl(t), n(t.target.error), !1;
        });
      }
      function bl(n) {
        n.stopPropagation && n.stopPropagation(), n.preventDefault && n.preventDefault();
      }
      var wl = "storagemutated", kt = "x-storagemutated-1", jn = Ll(null, wl), sr = (wn.prototype._lock = function() {
        return K(!re.global), ++this._reculock, this._reculock !== 1 || re.global || (re.lockOwnerFor = this), this;
      }, wn.prototype._unlock = function() {
        if (K(!re.global), --this._reculock == 0) for (re.global || (re.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var n = this._blockedFuncs.shift();
          try {
            Qn(n[1], n[0]);
          } catch {
          }
        }
        return this;
      }, wn.prototype._locked = function() {
        return this._reculock && re.lockOwnerFor !== this;
      }, wn.prototype.create = function(n) {
        var t = this;
        if (!this.mode) return this;
        var u = this.db.idbdb, r = this.db._state.dbOpenError;
        if (K(!this.idbtrans), !n && !u) switch (r && r.name) {
          case "DatabaseClosedError":
            throw new Z.DatabaseClosed(r);
          case "MissingAPIError":
            throw new Z.MissingAPI(r.message, r);
          default:
            throw new Z.OpenFailed(r);
        }
        if (!this.active) throw new Z.TransactionInactive();
        return K(this._completion._state === null), (n = this.idbtrans = n || (this.db.core || u).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Be(function(c) {
          bl(c), t._reject(n.error);
        }), n.onabort = Be(function(c) {
          bl(c), t.active && t._reject(new Z.Abort(n.error)), t.active = !1, t.on("abort").fire(c);
        }), n.oncomplete = Be(function() {
          t.active = !1, t._resolve(), "mutatedParts" in n && jn.storagemutated.fire(n.mutatedParts);
        }), this;
      }, wn.prototype._promise = function(n, t, u) {
        var r = this;
        if (n === "readwrite" && this.mode !== "readwrite") return He(new Z.ReadOnly("Transaction is readonly"));
        if (!this.active) return He(new Z.TransactionInactive());
        if (this._locked()) return new ee(function(f, p) {
          r._blockedFuncs.push([function() {
            r._promise(n, t, u).then(f, p);
          }, re]);
        });
        if (u) return Un(function() {
          var f = new ee(function(p, g) {
            r._lock();
            var L = t(p, g, r);
            L && L.then && L.then(p, g);
          });
          return f.finally(function() {
            return r._unlock();
          }), f._lib = !0, f;
        });
        var c = new ee(function(f, p) {
          var g = t(f, p, r);
          g && g.then && g.then(f, p);
        });
        return c._lib = !0, c;
      }, wn.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, wn.prototype.waitFor = function(n) {
        var t, u = this._root(), r = ee.resolve(n);
        u._waitingFor ? u._waitingFor = u._waitingFor.then(function() {
          return r;
        }) : (u._waitingFor = r, u._waitingQueue = [], t = u.idbtrans.objectStore(u.storeNames[0]), function f() {
          for (++u._spinCount; u._waitingQueue.length; ) u._waitingQueue.shift()();
          u._waitingFor && (t.get(-1 / 0).onsuccess = f);
        }());
        var c = u._waitingFor;
        return new ee(function(f, p) {
          r.then(function(g) {
            return u._waitingQueue.push(Be(f.bind(null, g)));
          }, function(g) {
            return u._waitingQueue.push(Be(p.bind(null, g)));
          }).finally(function() {
            u._waitingFor === c && (u._waitingFor = null);
          });
        });
      }, wn.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new Z.Abort()));
      }, wn.prototype.table = function(n) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (I(t, n)) return t[n];
        var u = this.schema[n];
        if (!u) throw new Z.NotFound("Table " + n + " not part of transaction");
        return u = new this.db.Table(n, u, this), u.core = this.db.core.table(n), t[n] = u;
      }, wn);
      function wn() {
      }
      function Vt(n, t, u, r, c, f, p, g) {
        return { name: n, keyPath: t, unique: u, multi: r, auto: c, compound: f, src: (u && !p ? "&" : "") + (r ? "*" : "") + (c ? "++" : "") + fu(t), type: g };
      }
      function fu(n) {
        return typeof n == "string" ? n : n ? "[" + [].join.call(n, "+") + "]" : "";
      }
      function Bt(n, t, u) {
        return { name: n, primKey: t, indexes: u, mappedClass: null, idxByName: (r = function(c) {
          return [c.name, c];
        }, u.reduce(function(c, f, p) {
          return p = r(f, p), p && (c[p[0]] = p[1]), c;
        }, {})) };
        var r;
      }
      var Sl = function(n) {
        try {
          return n.only([[]]), Sl = function() {
            return [[]];
          }, [[]];
        } catch {
          return Sl = function() {
            return Jn;
          }, Jn;
        }
      };
      function Zt(n) {
        return n == null ? function() {
        } : typeof n == "string" ? (t = n).split(".").length === 1 ? function(u) {
          return u[t];
        } : function(u) {
          return se(u, t);
        } : function(u) {
          return se(u, n);
        };
        var t;
      }
      function du(n) {
        return [].slice.call(n);
      }
      var cr = 0;
      function Cl(n) {
        return n == null ? ":id" : typeof n == "string" ? n : "[".concat(n.join("+"), "]");
      }
      function or(n, t, L) {
        function r(S) {
          if (S.type === 3) return null;
          if (S.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var D = S.lower, b = S.upper, C = S.lowerOpen, S = S.upperOpen;
          return D === void 0 ? b === void 0 ? null : t.upperBound(b, !!S) : b === void 0 ? t.lowerBound(D, !!C) : t.bound(D, b, !!C, !!S);
        }
        function c(T) {
          var D, b = T.name;
          return { name: b, schema: T, mutate: function(C) {
            var S = C.trans, P = C.type, E = C.keys, N = C.values, F = C.range;
            return new Promise(function(G, Y) {
              G = Be(G);
              var H = S.objectStore(b), $ = H.keyPath == null, J = P === "put" || P === "add";
              if (!J && P !== "delete" && P !== "deleteRange") throw new Error("Invalid operation type: " + P);
              var Q, ne = (E || N || { length: 1 }).length;
              if (E && N && E.length !== N.length) throw new Error("Given keys array must have same length as given values array.");
              if (ne === 0) return G({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function xe(mn) {
                ++Ge, bl(mn);
              }
              var qe = [], he = [], Ge = 0;
              if (P === "deleteRange") {
                if (F.type === 4) return G({ numFailures: Ge, failures: he, results: [], lastResult: void 0 });
                F.type === 3 ? qe.push(Q = H.clear()) : qe.push(Q = H.delete(r(F)));
              } else {
                var $ = J ? $ ? [N, E] : [N, null] : [E, null], pe = $[0], rn = $[1];
                if (J) for (var sn = 0; sn < ne; ++sn) qe.push(Q = rn && rn[sn] !== void 0 ? H[P](pe[sn], rn[sn]) : H[P](pe[sn])), Q.onerror = xe;
                else for (sn = 0; sn < ne; ++sn) qe.push(Q = H[P](pe[sn])), Q.onerror = xe;
              }
              function ft(mn) {
                mn = mn.target.result, qe.forEach(function(tl, ui) {
                  return tl.error != null && (he[ui] = tl.error);
                }), G({ numFailures: Ge, failures: he, results: P === "delete" ? E : qe.map(function(tl) {
                  return tl.result;
                }), lastResult: mn });
              }
              Q.onerror = function(mn) {
                xe(mn), ft(mn);
              }, Q.onsuccess = ft;
            });
          }, getMany: function(C) {
            var S = C.trans, P = C.keys;
            return new Promise(function(E, N) {
              E = Be(E);
              for (var F, G = S.objectStore(b), Y = P.length, H = new Array(Y), $ = 0, J = 0, Q = function(qe) {
                qe = qe.target, H[qe._pos] = qe.result, ++J === $ && E(H);
              }, ne = bn(N), xe = 0; xe < Y; ++xe) P[xe] != null && ((F = G.get(P[xe]))._pos = xe, F.onsuccess = Q, F.onerror = ne, ++$);
              $ === 0 && E(H);
            });
          }, get: function(C) {
            var S = C.trans, P = C.key;
            return new Promise(function(E, N) {
              E = Be(E);
              var F = S.objectStore(b).get(P);
              F.onsuccess = function(G) {
                return E(G.target.result);
              }, F.onerror = bn(N);
            });
          }, query: (D = O, function(C) {
            return new Promise(function(S, P) {
              S = Be(S);
              var E, N, F, $ = C.trans, G = C.values, Y = C.limit, Q = C.query, H = Y === 1 / 0 ? void 0 : Y, J = Q.index, Q = Q.range, $ = $.objectStore(b), J = J.isPrimaryKey ? $ : $.index(J.name), Q = r(Q);
              if (Y === 0) return S({ result: [] });
              D ? ((H = G ? J.getAll(Q, H) : J.getAllKeys(Q, H)).onsuccess = function(ne) {
                return S({ result: ne.target.result });
              }, H.onerror = bn(P)) : (E = 0, N = !G && "openKeyCursor" in J ? J.openKeyCursor(Q) : J.openCursor(Q), F = [], N.onsuccess = function(ne) {
                var xe = N.result;
                return xe ? (F.push(G ? xe.value : xe.primaryKey), ++E === Y ? S({ result: F }) : void xe.continue()) : S({ result: F });
              }, N.onerror = bn(P));
            });
          }), openCursor: function(C) {
            var S = C.trans, P = C.values, E = C.query, N = C.reverse, F = C.unique;
            return new Promise(function(G, Y) {
              G = Be(G);
              var J = E.index, H = E.range, $ = S.objectStore(b), $ = J.isPrimaryKey ? $ : $.index(J.name), J = N ? F ? "prevunique" : "prev" : F ? "nextunique" : "next", Q = !P && "openKeyCursor" in $ ? $.openKeyCursor(r(H), J) : $.openCursor(r(H), J);
              Q.onerror = bn(Y), Q.onsuccess = Be(function(ne) {
                var xe, qe, he, Ge, pe = Q.result;
                pe ? (pe.___id = ++cr, pe.done = !1, xe = pe.continue.bind(pe), qe = (qe = pe.continuePrimaryKey) && qe.bind(pe), he = pe.advance.bind(pe), Ge = function() {
                  throw new Error("Cursor not stopped");
                }, pe.trans = S, pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = function() {
                  throw new Error("Cursor not started");
                }, pe.fail = Be(Y), pe.next = function() {
                  var rn = this, sn = 1;
                  return this.start(function() {
                    return sn-- ? rn.continue() : rn.stop();
                  }).then(function() {
                    return rn;
                  });
                }, pe.start = function(rn) {
                  function sn() {
                    if (Q.result) try {
                      rn();
                    } catch (mn) {
                      pe.fail(mn);
                    }
                    else pe.done = !0, pe.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, pe.stop();
                  }
                  var ft = new Promise(function(mn, tl) {
                    mn = Be(mn), Q.onerror = bn(tl), pe.fail = tl, pe.stop = function(ui) {
                      pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = Ge, mn(ui);
                    };
                  });
                  return Q.onsuccess = Be(function(mn) {
                    Q.onsuccess = sn, sn();
                  }), pe.continue = xe, pe.continuePrimaryKey = qe, pe.advance = he, sn(), ft;
                }, G(pe)) : G(null);
              }, Y);
            });
          }, count: function(C) {
            var S = C.query, P = C.trans, E = S.index, N = S.range;
            return new Promise(function(F, G) {
              var Y = P.objectStore(b), H = E.isPrimaryKey ? Y : Y.index(E.name), Y = r(N), H = Y ? H.count(Y) : H.count();
              H.onsuccess = Be(function($) {
                return F($.target.result);
              }), H.onerror = bn(G);
            });
          } };
        }
        var f, p, g, w = (p = L, g = du((f = n).objectStoreNames), { schema: { name: f.name, tables: g.map(function(T) {
          return p.objectStore(T);
        }).map(function(T) {
          var D = T.keyPath, S = T.autoIncrement, b = d(D), C = {}, S = { name: T.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: D == null, compound: b, keyPath: D, autoIncrement: S, unique: !0, extractKey: Zt(D) }, indexes: du(T.indexNames).map(function(P) {
            return T.index(P);
          }).map(function(F) {
            var E = F.name, N = F.unique, G = F.multiEntry, F = F.keyPath, G = { name: E, compound: d(F), keyPath: F, unique: N, multiEntry: G, extractKey: Zt(F) };
            return C[Cl(F)] = G;
          }), getIndexByKeyPath: function(P) {
            return C[Cl(P)];
          } };
          return C[":id"] = S.primaryKey, D != null && (C[Cl(D)] = S.primaryKey), S;
        }) }, hasGetAll: 0 < g.length && "getAll" in p.objectStore(g[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), L = w.schema, O = w.hasGetAll, w = L.tables.map(c), v = {};
        return w.forEach(function(T) {
          return v[T.name] = T;
        }), { stack: "dbcore", transaction: n.transaction.bind(n), table: function(T) {
          if (!v[T]) throw new Error("Table '".concat(T, "' not found"));
          return v[T];
        }, MIN_KEY: -1 / 0, MAX_KEY: Sl(t), schema: L };
      }
      function mr(n, t, u, r) {
        var c = u.IDBKeyRange;
        return u.indexedDB, { dbcore: (r = or(t, c, r), n.dbcore.reduce(function(f, p) {
          return p = p.create, a(a({}, f), p(f));
        }, r)) };
      }
      function nt(n, r) {
        var u = r.db, r = mr(n._middlewares, u, n._deps, r);
        n.core = r.dbcore, n.tables.forEach(function(c) {
          var f = c.name;
          n.core.schema.tables.some(function(p) {
            return p.name === f;
          }) && (c.core = n.core.table(f), n[f] instanceof n.Table && (n[f].core = c.core));
        });
      }
      function lt(n, t, u, r) {
        u.forEach(function(c) {
          var f = r[c];
          t.forEach(function(p) {
            var g = function L(O, w) {
              return U(O, w) || (O = x(O)) && L(O, w);
            }(p, c);
            (!g || "value" in g && g.value === void 0) && (p === n.Transaction.prototype || p instanceof n.Transaction ? R(p, c, { get: function() {
              return this.table(c);
            }, set: function(L) {
              A(this, c, { value: L, writable: !0, configurable: !0, enumerable: !0 });
            } }) : p[c] = new n.Table(c, f));
          });
        });
      }
      function Ut(n, t) {
        t.forEach(function(u) {
          for (var r in u) u[r] instanceof n.Table && delete u[r];
        });
      }
      function fr(n, t) {
        return n._cfg.version - t._cfg.version;
      }
      function dr(n, t, u, r) {
        var c = n._dbSchema;
        u.objectStoreNames.contains("$meta") && !c.$meta && (c.$meta = Bt("$meta", hu("")[0], []), n._storeNames.push("$meta"));
        var f = n._createTransaction("readwrite", n._storeNames, c);
        f.create(u), f._completion.catch(r);
        var p = f._reject.bind(f), g = re.transless || re;
        Un(function() {
          return re.trans = f, re.transless = g, t !== 0 ? (nt(n, u), O = t, ((L = f).storeNames.includes("$meta") ? L.table("$meta").get("version").then(function(w) {
            return w ?? O;
          }) : ee.resolve(O)).then(function(w) {
            return T = w, D = f, b = u, C = [], w = (v = n)._versions, S = v._dbSchema = it(0, v.idbdb, b), (w = w.filter(function(P) {
              return P._cfg.version >= T;
            })).length !== 0 ? (w.forEach(function(P) {
              C.push(function() {
                var E = S, N = P._cfg.dbschema;
                ut(v, E, b), ut(v, N, b), S = v._dbSchema = N;
                var F = Kt(E, N);
                F.add.forEach(function(J) {
                  Gt(b, J[0], J[1].primKey, J[1].indexes);
                }), F.change.forEach(function(J) {
                  if (J.recreate) throw new Z.Upgrade("Not yet support for changing primary key");
                  var Q = b.objectStore(J.name);
                  J.add.forEach(function(ne) {
                    return tt(Q, ne);
                  }), J.change.forEach(function(ne) {
                    Q.deleteIndex(ne.name), tt(Q, ne);
                  }), J.del.forEach(function(ne) {
                    return Q.deleteIndex(ne);
                  });
                });
                var G = P._cfg.contentUpgrade;
                if (G && P._cfg.version > T) {
                  nt(v, b), D._memoizedTables = {};
                  var Y = me(N);
                  F.del.forEach(function(J) {
                    Y[J] = E[J];
                  }), Ut(v, [v.Transaction.prototype]), lt(v, [v.Transaction.prototype], m(Y), Y), D.schema = Y;
                  var H, $ = Ye(G);
                  return $ && cl(), F = ee.follow(function() {
                    var J;
                    (H = G(D)) && $ && (J = Kn.bind(null, null), H.then(J, J));
                  }), H && typeof H.then == "function" ? ee.resolve(H) : F.then(function() {
                    return H;
                  });
                }
              }), C.push(function(E) {
                var N, F, G = P._cfg.dbschema;
                N = G, F = E, [].slice.call(F.db.objectStoreNames).forEach(function(Y) {
                  return N[Y] == null && F.db.deleteObjectStore(Y);
                }), Ut(v, [v.Transaction.prototype]), lt(v, [v.Transaction.prototype], v._storeNames, v._dbSchema), D.schema = v._dbSchema;
              }), C.push(function(E) {
                v.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(v.idbdb.version / 10) === P._cfg.version ? (v.idbdb.deleteObjectStore("$meta"), delete v._dbSchema.$meta, v._storeNames = v._storeNames.filter(function(N) {
                  return N !== "$meta";
                })) : E.objectStore("$meta").put(P._cfg.version, "version"));
              });
            }), function P() {
              return C.length ? ee.resolve(C.shift()(D.idbtrans)).then(P) : ee.resolve();
            }().then(function() {
              pu(S, b);
            })) : ee.resolve();
            var v, T, D, b, C, S;
          }).catch(p)) : (m(c).forEach(function(w) {
            Gt(u, w, c[w].primKey, c[w].indexes);
          }), nt(n, u), void ee.follow(function() {
            return n.on.populate.fire(f);
          }).catch(p));
          var L, O;
        });
      }
      function pr(n, t) {
        pu(n._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var u = it(0, n.idbdb, t);
        ut(n, n._dbSchema, t);
        for (var r = 0, c = Kt(u, n._dbSchema).change; r < c.length; r++) {
          var f = function(p) {
            if (p.change.length || p.recreate) return console.warn("Unable to patch indexes of table ".concat(p.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var g = t.objectStore(p.name);
            p.add.forEach(function(L) {
              be && console.debug("Dexie upgrade patch: Creating missing index ".concat(p.name, ".").concat(L.src)), tt(g, L);
            });
          }(c[r]);
          if (typeof f == "object") return f.value;
        }
      }
      function Kt(n, t) {
        var u, r = { del: [], add: [], change: [] };
        for (u in n) t[u] || r.del.push(u);
        for (u in t) {
          var c = n[u], f = t[u];
          if (c) {
            var p = { name: u, def: f, recreate: !1, del: [], add: [], change: [] };
            if ("" + (c.primKey.keyPath || "") != "" + (f.primKey.keyPath || "") || c.primKey.auto !== f.primKey.auto) p.recreate = !0, r.change.push(p);
            else {
              var g = c.idxByName, L = f.idxByName, O = void 0;
              for (O in g) L[O] || p.del.push(O);
              for (O in L) {
                var w = g[O], v = L[O];
                w ? w.src !== v.src && p.change.push(v) : p.add.push(v);
              }
              (0 < p.del.length || 0 < p.add.length || 0 < p.change.length) && r.change.push(p);
            }
          } else r.add.push([u, f]);
        }
        return r;
      }
      function Gt(n, t, u, r) {
        var c = n.db.createObjectStore(t, u.keyPath ? { keyPath: u.keyPath, autoIncrement: u.auto } : { autoIncrement: u.auto });
        return r.forEach(function(f) {
          return tt(c, f);
        }), c;
      }
      function pu(n, t) {
        m(n).forEach(function(u) {
          t.db.objectStoreNames.contains(u) || (be && console.debug("Dexie: Creating missing table", u), Gt(t, u, n[u].primKey, n[u].indexes));
        });
      }
      function tt(n, t) {
        n.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function it(n, t, u) {
        var r = {};
        return X(t.objectStoreNames, 0).forEach(function(c) {
          for (var f = u.objectStore(c), p = Vt(fu(O = f.keyPath), O || "", !0, !1, !!f.autoIncrement, O && typeof O != "string", !0), g = [], L = 0; L < f.indexNames.length; ++L) {
            var w = f.index(f.indexNames[L]), O = w.keyPath, w = Vt(w.name, O, !!w.unique, !!w.multiEntry, !1, O && typeof O != "string", !1);
            g.push(w);
          }
          r[c] = Bt(c, p, g);
        }), r;
      }
      function ut(n, t, u) {
        for (var r = u.db.objectStoreNames, c = 0; c < r.length; ++c) {
          var f = r[c], p = u.objectStore(f);
          n._hasGetAll = "getAll" in p;
          for (var g = 0; g < p.indexNames.length; ++g) {
            var L = p.indexNames[g], O = p.index(L).keyPath, w = typeof O == "string" ? O : "[" + X(O).join("+") + "]";
            !t[f] || (O = t[f].idxByName[w]) && (O.name = L, delete t[f].idxByName[w], t[f].idxByName[L] = O);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && o.WorkerGlobalScope && o instanceof o.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1);
      }
      function hu(n) {
        return n.split(",").map(function(t, u) {
          var f = t.split(":"), r = (c = f[1]) === null || c === void 0 ? void 0 : c.trim(), c = (t = f[0].trim()).replace(/([&*]|\+\+)/g, ""), f = /^\[/.test(c) ? c.match(/^\[(.*)\]$/)[1].split("+") : c;
          return Vt(c, f || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), d(f), u === 0, r);
        });
      }
      var hr = (dl.prototype._createTableSchema = Bt, dl.prototype._parseIndexSyntax = hu, dl.prototype._parseStoresSpec = function(n, t) {
        var u = this;
        m(n).forEach(function(r) {
          if (n[r] !== null) {
            var c = u._parseIndexSyntax(n[r]), f = c.shift();
            if (!f) throw new Z.Schema("Invalid schema for table " + r + ": " + n[r]);
            if (f.unique = !0, f.multi) throw new Z.Schema("Primary key cannot be multiEntry*");
            c.forEach(function(p) {
              if (p.auto) throw new Z.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!p.keyPath) throw new Z.Schema("Index must have a name and cannot be an empty string");
            }), c = u._createTableSchema(r, f, c), t[r] = c;
          }
        });
      }, dl.prototype.stores = function(u) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? h(this._cfg.storesSource, u) : u;
        var u = t._versions, r = {}, c = {};
        return u.forEach(function(f) {
          h(r, f._cfg.storesSource), c = f._cfg.dbschema = {}, f._parseStoresSpec(r, c);
        }), t._dbSchema = c, Ut(t, [t._allTables, t, t.Transaction.prototype]), lt(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], m(c), c), t._storeNames = m(c), this;
      }, dl.prototype.upgrade = function(n) {
        return this._cfg.contentUpgrade = _e(this._cfg.contentUpgrade || Oe, n), this;
      }, dl);
      function dl() {
      }
      function zt(n, t) {
        var u = n._dbNamesDB;
        return u || (u = n._dbNamesDB = new En(Wl, { addons: [], indexedDB: n, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), u.table("dbnames");
      }
      function jt(n) {
        return n && typeof n.databases == "function";
      }
      function Ht(n) {
        return Un(function() {
          return re.letThrough = !0, n();
        });
      }
      function $t(n) {
        return !("from" in n);
      }
      var an = function(n, t) {
        if (!this) {
          var u = new an();
          return n && "d" in n && h(u, n), u;
        }
        h(this, arguments.length ? { d: 1, from: n, to: 1 < arguments.length ? t : n } : { d: 0 });
      };
      function Tl(n, t, u) {
        var r = Ce(t, u);
        if (!isNaN(r)) {
          if (0 < r) throw RangeError();
          if ($t(n)) return h(n, { from: t, to: u, d: 1 });
          var c = n.l, r = n.r;
          if (Ce(u, n.from) < 0) return c ? Tl(c, t, u) : n.l = { from: t, to: u, d: 1, l: null, r: null }, vu(n);
          if (0 < Ce(t, n.to)) return r ? Tl(r, t, u) : n.r = { from: t, to: u, d: 1, l: null, r: null }, vu(n);
          Ce(t, n.from) < 0 && (n.from = t, n.l = null, n.d = r ? r.d + 1 : 1), 0 < Ce(u, n.to) && (n.to = u, n.r = null, n.d = n.l ? n.l.d + 1 : 1), u = !n.r, c && !n.l && Pl(n, c), r && u && Pl(n, r);
        }
      }
      function Pl(n, t) {
        $t(t) || function u(r, L) {
          var f = L.from, p = L.to, g = L.l, L = L.r;
          Tl(r, f, p), g && u(r, g), L && u(r, L);
        }(n, t);
      }
      function gu(n, t) {
        var u = at(t), r = u.next();
        if (r.done) return !1;
        for (var c = r.value, f = at(n), p = f.next(c.from), g = p.value; !r.done && !p.done; ) {
          if (Ce(g.from, c.to) <= 0 && 0 <= Ce(g.to, c.from)) return !0;
          Ce(c.from, g.from) < 0 ? c = (r = u.next(g.from)).value : g = (p = f.next(c.from)).value;
        }
        return !1;
      }
      function at(n) {
        var t = $t(n) ? null : { s: 0, n };
        return { next: function(u) {
          for (var r = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, r) for (; t.n.l && Ce(u, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !r || Ce(u, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function vu(n) {
        var t, u, r = (((t = n.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((u = n.l) === null || u === void 0 ? void 0 : u.d) || 0), c = 1 < r ? "r" : r < -1 ? "l" : "";
        c && (t = c == "r" ? "l" : "r", u = a({}, n), r = n[c], n.from = r.from, n.to = r.to, n[c] = r[c], u[c] = r[t], (n[t] = u).d = xu(u)), n.d = xu(n);
      }
      function xu(u) {
        var t = u.r, u = u.l;
        return (t ? u ? Math.max(t.d, u.d) : t.d : u ? u.d : 0) + 1;
      }
      function rt(n, t) {
        return m(t).forEach(function(u) {
          n[u] ? Pl(n[u], t[u]) : n[u] = function r(c) {
            var f, p, g = {};
            for (f in c) I(c, f) && (p = c[f], g[f] = !p || typeof p != "object" || Ie.has(p.constructor) ? p : r(p));
            return g;
          }(t[u]);
        }), n;
      }
      function Wt(n, t) {
        return n.all || t.all || Object.keys(n).some(function(u) {
          return t[u] && gu(t[u], n[u]);
        });
      }
      q(an.prototype, ((In = { add: function(n) {
        return Pl(this, n), this;
      }, addKey: function(n) {
        return Tl(this, n, n), this;
      }, addKeys: function(n) {
        var t = this;
        return n.forEach(function(u) {
          return Tl(t, u, u);
        }), this;
      }, hasKey: function(n) {
        var t = at(this).next(n).value;
        return t && Ce(t.from, n) <= 0 && 0 <= Ce(t.to, n);
      } })[ge] = function() {
        return at(this);
      }, In));
      var nl = {}, Yt = {}, Xt = !1;
      function st(n) {
        rt(Yt, n), Xt || (Xt = !0, setTimeout(function() {
          Xt = !1, Qt(Yt, !(Yt = {}));
        }, 0));
      }
      function Qt(n, t) {
        t === void 0 && (t = !1);
        var u = /* @__PURE__ */ new Set();
        if (n.all) for (var r = 0, c = Object.values(nl); r < c.length; r++) yu(p = c[r], n, u, t);
        else for (var f in n) {
          var p, g = /^idb\:\/\/(.*)\/(.*)\//.exec(f);
          g && (f = g[1], g = g[2], (p = nl["idb://".concat(f, "/").concat(g)]) && yu(p, n, u, t));
        }
        u.forEach(function(L) {
          return L();
        });
      }
      function yu(n, t, u, r) {
        for (var c = [], f = 0, p = Object.entries(n.queries.query); f < p.length; f++) {
          for (var g = p[f], L = g[0], O = [], w = 0, v = g[1]; w < v.length; w++) {
            var T = v[w];
            Wt(t, T.obsSet) ? T.subscribers.forEach(function(S) {
              return u.add(S);
            }) : r && O.push(T);
          }
          r && c.push([L, O]);
        }
        if (r) for (var D = 0, b = c; D < b.length; D++) {
          var C = b[D], L = C[0], O = C[1];
          n.queries.query[L] = O;
        }
      }
      function gr(n) {
        var t = n._state, u = n._deps.indexedDB;
        if (t.isBeingOpened || n.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? He(t.dbOpenError) : n;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var r = t.openCanceller, c = Math.round(10 * n.verno), f = !1;
        function p() {
          if (t.openCanceller !== r) throw new Z.DatabaseClosed("db.open() was cancelled");
        }
        function g() {
          return new ee(function(T, D) {
            if (p(), !u) throw new Z.MissingAPI();
            var b = n.name, C = t.autoSchema || !c ? u.open(b) : u.open(b, c);
            if (!C) throw new Z.MissingAPI();
            C.onerror = bn(D), C.onblocked = Be(n._fireOnBlocked), C.onupgradeneeded = Be(function(S) {
              var P;
              w = C.transaction, t.autoSchema && !n._options.allowEmptyDB ? (C.onerror = bl, w.abort(), C.result.close(), (P = u.deleteDatabase(b)).onsuccess = P.onerror = Be(function() {
                D(new Z.NoSuchDatabase("Database ".concat(b, " doesnt exist")));
              })) : (w.onerror = bn(D), S = S.oldVersion > Math.pow(2, 62) ? 0 : S.oldVersion, v = S < 1, n.idbdb = C.result, f && pr(n, w), dr(n, S / 10, w, D));
            }, D), C.onsuccess = Be(function() {
              w = null;
              var S, P, E, N, F, G = n.idbdb = C.result, Y = X(G.objectStoreNames);
              if (0 < Y.length) try {
                var H = G.transaction((N = Y).length === 1 ? N[0] : N, "readonly");
                if (t.autoSchema) P = G, E = H, (S = n).verno = P.version / 10, E = S._dbSchema = it(0, P, E), S._storeNames = X(P.objectStoreNames, 0), lt(S, [S._allTables], m(E), E);
                else if (ut(n, n._dbSchema, H), ((F = Kt(it(0, (F = n).idbdb, H), F._dbSchema)).add.length || F.change.some(function($) {
                  return $.add.length || $.change.length;
                })) && !f) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), G.close(), c = G.version + 1, f = !0, T(g());
                nt(n, H);
              } catch {
              }
              ol.push(n), G.onversionchange = Be(function($) {
                t.vcFired = !0, n.on("versionchange").fire($);
              }), G.onclose = Be(function($) {
                n.on("close").fire($);
              }), v && (F = n._deps, H = b, G = F.indexedDB, F = F.IDBKeyRange, jt(G) || H === Wl || zt(G, F).put({ name: H }).catch(Oe)), T();
            }, D);
          }).catch(function(T) {
            switch (T?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), g();
                break;
              case "VersionError":
                if (0 < c) return c = 0, g();
            }
            return ee.reject(T);
          });
        }
        var L, O = t.dbReadyResolve, w = null, v = !1;
        return ee.race([r, (typeof navigator > "u" ? ee.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(T) {
          function D() {
            return indexedDB.databases().finally(T);
          }
          L = setInterval(D, 100), D();
        }).finally(function() {
          return clearInterval(L);
        }) : Promise.resolve()).then(g)]).then(function() {
          return p(), t.onReadyBeingFired = [], ee.resolve(Ht(function() {
            return n.on.ready.fire(n.vip);
          })).then(function T() {
            if (0 < t.onReadyBeingFired.length) {
              var D = t.onReadyBeingFired.reduce(_e, Oe);
              return t.onReadyBeingFired = [], ee.resolve(Ht(function() {
                return D(n.vip);
              })).then(T);
            }
          });
        }).finally(function() {
          t.openCanceller === r && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(T) {
          t.dbOpenError = T;
          try {
            w && w.abort();
          } catch {
          }
          return r === t.openCanceller && n._close(), He(T);
        }).finally(function() {
          t.openComplete = !0, O();
        }).then(function() {
          var T;
          return v && (T = {}, n.tables.forEach(function(D) {
            D.schema.indexes.forEach(function(b) {
              b.name && (T["idb://".concat(n.name, "/").concat(D.name, "/").concat(b.name)] = new an(-1 / 0, [[[]]]));
            }), T["idb://".concat(n.name, "/").concat(D.name, "/")] = T["idb://".concat(n.name, "/").concat(D.name, "/:dels")] = new an(-1 / 0, [[[]]]);
          }), jn(wl).fire(T), Qt(T, !0)), n;
        });
      }
      function Jt(n) {
        function t(f) {
          return n.next(f);
        }
        var u = c(t), r = c(function(f) {
          return n.throw(f);
        });
        function c(f) {
          return function(L) {
            var g = f(L), L = g.value;
            return g.done ? L : L && typeof L.then == "function" ? L.then(u, r) : d(L) ? Promise.all(L).then(u, r) : u(L);
          };
        }
        return c(t)();
      }
      function ct(n, t, u) {
        for (var r = d(n) ? n.slice() : [n], c = 0; c < u; ++c) r.push(t);
        return r;
      }
      var vr = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema, c = {}, f = [];
          function p(v, T, D) {
            var b = Cl(v), C = c[b] = c[b] || [], S = v == null ? 0 : typeof v == "string" ? 1 : v.length, P = 0 < T, P = a(a({}, D), { name: P ? "".concat(b, "(virtual-from:").concat(D.name, ")") : D.name, lowLevelIndex: D, isVirtual: P, keyTail: T, keyLength: S, extractKey: Zt(v), unique: !P && D.unique });
            return C.push(P), P.isPrimaryKey || f.push(P), 1 < S && p(S === 2 ? v[0] : v.slice(0, S - 1), T + 1, D), C.sort(function(E, N) {
              return E.keyTail - N.keyTail;
            }), P;
          }
          t = p(r.primaryKey.keyPath, 0, r.primaryKey), c[":id"] = [t];
          for (var g = 0, L = r.indexes; g < L.length; g++) {
            var O = L[g];
            p(O.keyPath, 0, O);
          }
          function w(v) {
            var T, D = v.query.index;
            return D.isVirtual ? a(a({}, v), { query: { index: D.lowLevelIndex, range: (T = v.query.range, D = D.keyTail, { type: T.type === 1 ? 2 : T.type, lower: ct(T.lower, T.lowerOpen ? n.MAX_KEY : n.MIN_KEY, D), lowerOpen: !0, upper: ct(T.upper, T.upperOpen ? n.MIN_KEY : n.MAX_KEY, D), upperOpen: !0 }) } }) : v;
          }
          return a(a({}, u), { schema: a(a({}, r), { primaryKey: t, indexes: f, getIndexByKeyPath: function(v) {
            return (v = c[Cl(v)]) && v[0];
          } }), count: function(v) {
            return u.count(w(v));
          }, query: function(v) {
            return u.query(w(v));
          }, openCursor: function(v) {
            var T = v.query.index, D = T.keyTail, b = T.isVirtual, C = T.keyLength;
            return b ? u.openCursor(w(v)).then(function(P) {
              return P && S(P);
            }) : u.openCursor(v);
            function S(P) {
              return Object.create(P, { continue: { value: function(E) {
                E != null ? P.continue(ct(E, v.reverse ? n.MAX_KEY : n.MIN_KEY, D)) : v.unique ? P.continue(P.key.slice(0, C).concat(v.reverse ? n.MIN_KEY : n.MAX_KEY, D)) : P.continue();
              } }, continuePrimaryKey: { value: function(E, N) {
                P.continuePrimaryKey(ct(E, n.MAX_KEY, D), N);
              } }, primaryKey: { get: function() {
                return P.primaryKey;
              } }, key: { get: function() {
                var E = P.key;
                return C === 1 ? E[0] : E.slice(0, C);
              } }, value: { get: function() {
                return P.value;
              } } });
            }
          } });
        } });
      } };
      function ei(n, t, u, r) {
        return u = u || {}, r = r || "", m(n).forEach(function(c) {
          var f, p, g;
          I(t, c) ? (f = n[c], p = t[c], typeof f == "object" && typeof p == "object" && f && p ? (g = Se(f)) !== Se(p) ? u[r + c] = t[c] : g === "Object" ? ei(f, p, u, r + c + ".") : f !== p && (u[r + c] = t[c]) : f !== p && (u[r + c] = t[c])) : u[r + c] = void 0;
        }), m(t).forEach(function(c) {
          I(n, c) || (u[r + c] = t[c]);
        }), u;
      }
      function ni(n, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(n.extractKey);
      }
      var xr = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema.primaryKey;
          return a(a({}, u), { mutate: function(c) {
            var f = re.trans, p = f.table(t).hook, g = p.deleting, L = p.creating, O = p.updating;
            switch (c.type) {
              case "add":
                if (L.fire === Oe) break;
                return f._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "put":
                if (L.fire === Oe && O.fire === Oe) break;
                return f._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "delete":
                if (g.fire === Oe) break;
                return f._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "deleteRange":
                if (g.fire === Oe) break;
                return f._promise("readwrite", function() {
                  return function v(T, D, b) {
                    return u.query({ trans: T, values: !1, query: { index: r, range: D }, limit: b }).then(function(C) {
                      var S = C.result;
                      return w({ type: "delete", keys: S, trans: T }).then(function(P) {
                        return 0 < P.numFailures ? Promise.reject(P.failures[0]) : S.length < b ? { failures: [], numFailures: 0, lastResult: void 0 } : v(T, a(a({}, D), { lower: S[S.length - 1], lowerOpen: !0 }), b);
                      });
                    });
                  }(c.trans, c.range, 1e4);
                }, !0);
            }
            return u.mutate(c);
            function w(v) {
              var T, D, b, C = re.trans, S = v.keys || ni(r, v);
              if (!S) throw new Error("Keys missing");
              return (v = v.type === "add" || v.type === "put" ? a(a({}, v), { keys: S }) : a({}, v)).type !== "delete" && (v.values = s([], v.values)), v.keys && (v.keys = s([], v.keys)), T = u, b = S, ((D = v).type === "add" ? Promise.resolve([]) : T.getMany({ trans: D.trans, keys: b, cache: "immutable" })).then(function(P) {
                var E = S.map(function(N, F) {
                  var G, Y, H, $ = P[F], J = { onerror: null, onsuccess: null };
                  return v.type === "delete" ? g.fire.call(J, N, $, C) : v.type === "add" || $ === void 0 ? (G = L.fire.call(J, N, v.values[F], C), N == null && G != null && (v.keys[F] = N = G, r.outbound || te(v.values[F], r.keyPath, N))) : (G = ei($, v.values[F]), (Y = O.fire.call(J, G, N, $, C)) && (H = v.values[F], Object.keys(Y).forEach(function(Q) {
                    I(H, Q) ? H[Q] = Y[Q] : te(H, Q, Y[Q]);
                  }))), J;
                });
                return u.mutate(v).then(function(N) {
                  for (var F = N.failures, G = N.results, Y = N.numFailures, N = N.lastResult, H = 0; H < S.length; ++H) {
                    var $ = (G || S)[H], J = E[H];
                    $ == null ? J.onerror && J.onerror(F[H]) : J.onsuccess && J.onsuccess(v.type === "put" && P[H] ? v.values[H] : $);
                  }
                  return { failures: F, results: G, numFailures: Y, lastResult: N };
                }).catch(function(N) {
                  return E.forEach(function(F) {
                    return F.onerror && F.onerror(N);
                  }), Promise.reject(N);
                });
              });
            }
          } });
        } });
      } };
      function Iu(n, t, u) {
        try {
          if (!t || t.keys.length < n.length) return null;
          for (var r = [], c = 0, f = 0; c < t.keys.length && f < n.length; ++c) Ce(t.keys[c], n[f]) === 0 && (r.push(u ? ve(t.values[c]) : t.values[c]), ++f);
          return r.length === n.length ? r : null;
        } catch {
          return null;
        }
      }
      var yr = { stack: "dbcore", level: -1, create: function(n) {
        return { table: function(t) {
          var u = n.table(t);
          return a(a({}, u), { getMany: function(r) {
            if (!r.cache) return u.getMany(r);
            var c = Iu(r.keys, r.trans._cache, r.cache === "clone");
            return c ? ee.resolve(c) : u.getMany(r).then(function(f) {
              return r.trans._cache = { keys: r.keys, values: r.cache === "clone" ? ve(f) : f }, f;
            });
          }, mutate: function(r) {
            return r.type !== "add" && (r.trans._cache = null), u.mutate(r);
          } });
        } };
      } };
      function Lu(n, t) {
        return n.trans.mode === "readonly" && !!n.subscr && !n.trans.explicit && n.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function Du(n, t) {
        switch (n) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var Ir = { stack: "dbcore", level: 0, name: "Observability", create: function(n) {
        var t = n.schema.name, u = new an(n.MIN_KEY, n.MAX_KEY);
        return a(a({}, n), { transaction: function(r, c, f) {
          if (re.subscr && c !== "readonly") throw new Z.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(re.querier));
          return n.transaction(r, c, f);
        }, table: function(r) {
          var c = n.table(r), f = c.schema, p = f.primaryKey, v = f.indexes, g = p.extractKey, L = p.outbound, O = p.autoIncrement && v.filter(function(D) {
            return D.compound && D.keyPath.includes(p.keyPath);
          }), w = a(a({}, c), { mutate: function(D) {
            function b(Q) {
              return Q = "idb://".concat(t, "/").concat(r, "/").concat(Q), N[Q] || (N[Q] = new an());
            }
            var C, S, P, E = D.trans, N = D.mutatedParts || (D.mutatedParts = {}), F = b(""), G = b(":dels"), Y = D.type, J = D.type === "deleteRange" ? [D.range] : D.type === "delete" ? [D.keys] : D.values.length < 50 ? [ni(p, D).filter(function(Q) {
              return Q;
            }), D.values] : [], H = J[0], $ = J[1], J = D.trans._cache;
            return d(H) ? (F.addKeys(H), (J = Y === "delete" || H.length === $.length ? Iu(H, J) : null) || G.addKeys(H), (J || $) && (C = b, S = J, P = $, f.indexes.forEach(function(Q) {
              var ne = C(Q.name || "");
              function xe(he) {
                return he != null ? Q.extractKey(he) : null;
              }
              function qe(he) {
                return Q.multiEntry && d(he) ? he.forEach(function(Ge) {
                  return ne.addKey(Ge);
                }) : ne.addKey(he);
              }
              (S || P).forEach(function(he, rn) {
                var pe = S && xe(S[rn]), rn = P && xe(P[rn]);
                Ce(pe, rn) !== 0 && (pe != null && qe(pe), rn != null && qe(rn));
              });
            }))) : H ? ($ = { from: ($ = H.lower) !== null && $ !== void 0 ? $ : n.MIN_KEY, to: ($ = H.upper) !== null && $ !== void 0 ? $ : n.MAX_KEY }, G.add($), F.add($)) : (F.add(u), G.add(u), f.indexes.forEach(function(Q) {
              return b(Q.name).add(u);
            })), c.mutate(D).then(function(Q) {
              return !H || D.type !== "add" && D.type !== "put" || (F.addKeys(Q.results), O && O.forEach(function(ne) {
                for (var xe = D.values.map(function(pe) {
                  return ne.extractKey(pe);
                }), qe = ne.keyPath.findIndex(function(pe) {
                  return pe === p.keyPath;
                }), he = 0, Ge = Q.results.length; he < Ge; ++he) xe[he][qe] = Q.results[he];
                b(ne.name).addKeys(xe);
              })), E.mutatedParts = rt(E.mutatedParts || {}, N), Q;
            });
          } }), v = function(b) {
            var C = b.query, b = C.index, C = C.range;
            return [b, new an((b = C.lower) !== null && b !== void 0 ? b : n.MIN_KEY, (C = C.upper) !== null && C !== void 0 ? C : n.MAX_KEY)];
          }, T = { get: function(D) {
            return [p, new an(D.key)];
          }, getMany: function(D) {
            return [p, new an().addKeys(D.keys)];
          }, count: v, query: v, openCursor: v };
          return m(T).forEach(function(D) {
            w[D] = function(b) {
              var C = re.subscr, S = !!C, P = Lu(re, c) && Du(D, b) ? b.obsSet = {} : C;
              if (S) {
                var E = function($) {
                  return $ = "idb://".concat(t, "/").concat(r, "/").concat($), P[$] || (P[$] = new an());
                }, N = E(""), F = E(":dels"), C = T[D](b), S = C[0], C = C[1];
                if ((D === "query" && S.isPrimaryKey && !b.values ? F : E(S.name || "")).add(C), !S.isPrimaryKey) {
                  if (D !== "count") {
                    var G = D === "query" && L && b.values && c.query(a(a({}, b), { values: !1 }));
                    return c[D].apply(this, arguments).then(function($) {
                      if (D === "query") {
                        if (L && b.values) return G.then(function(xe) {
                          return xe = xe.result, N.addKeys(xe), $;
                        });
                        var J = b.values ? $.result.map(g) : $.result;
                        (b.values ? N : F).addKeys(J);
                      } else if (D === "openCursor") {
                        var Q = $, ne = b.values;
                        return Q && Object.create(Q, { key: { get: function() {
                          return F.addKey(Q.primaryKey), Q.key;
                        } }, primaryKey: { get: function() {
                          var xe = Q.primaryKey;
                          return F.addKey(xe), xe;
                        } }, value: { get: function() {
                          return ne && N.addKey(Q.primaryKey), Q.value;
                        } } });
                      }
                      return $;
                    });
                  }
                  F.add(u);
                }
              }
              return c[D].apply(this, arguments);
            };
          }), w;
        } });
      } };
      function Ou(n, t, u) {
        if (u.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var r = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return u.numFailures === r ? null : (t = a({}, t), d(t.keys) && (t.keys = t.keys.filter(function(c, f) {
          return !(f in u.failures);
        })), "values" in t && d(t.values) && (t.values = t.values.filter(function(c, f) {
          return !(f in u.failures);
        })), t);
      }
      function li(n, t) {
        return u = n, ((r = t).lower === void 0 || (r.lowerOpen ? 0 < Ce(u, r.lower) : 0 <= Ce(u, r.lower))) && (n = n, (t = t).upper === void 0 || (t.upperOpen ? Ce(n, t.upper) < 0 : Ce(n, t.upper) <= 0));
        var u, r;
      }
      function bu(n, t, T, r, c, f) {
        if (!T || T.length === 0) return n;
        var p = t.query.index, g = p.multiEntry, L = t.query.range, O = r.schema.primaryKey.extractKey, w = p.extractKey, v = (p.lowLevelIndex || p).extractKey, T = T.reduce(function(D, b) {
          var C = D, S = [];
          if (b.type === "add" || b.type === "put") for (var P = new an(), E = b.values.length - 1; 0 <= E; --E) {
            var N, F = b.values[E], G = O(F);
            P.hasKey(G) || (N = w(F), (g && d(N) ? N.some(function(Q) {
              return li(Q, L);
            }) : li(N, L)) && (P.addKey(G), S.push(F)));
          }
          switch (b.type) {
            case "add":
              var Y = new an().addKeys(t.values ? D.map(function(ne) {
                return O(ne);
              }) : D), C = D.concat(t.values ? S.filter(function(ne) {
                return ne = O(ne), !Y.hasKey(ne) && (Y.addKey(ne), !0);
              }) : S.map(function(ne) {
                return O(ne);
              }).filter(function(ne) {
                return !Y.hasKey(ne) && (Y.addKey(ne), !0);
              }));
              break;
            case "put":
              var H = new an().addKeys(b.values.map(function(ne) {
                return O(ne);
              }));
              C = D.filter(function(ne) {
                return !H.hasKey(t.values ? O(ne) : ne);
              }).concat(t.values ? S : S.map(function(ne) {
                return O(ne);
              }));
              break;
            case "delete":
              var $ = new an().addKeys(b.keys);
              C = D.filter(function(ne) {
                return !$.hasKey(t.values ? O(ne) : ne);
              });
              break;
            case "deleteRange":
              var J = b.range;
              C = D.filter(function(ne) {
                return !li(O(ne), J);
              });
          }
          return C;
        }, n);
        return T === n ? n : (T.sort(function(D, b) {
          return Ce(v(D), v(b)) || Ce(O(D), O(b));
        }), t.limit && t.limit < 1 / 0 && (T.length > t.limit ? T.length = t.limit : n.length === t.limit && T.length < t.limit && (c.dirty = !0)), f ? Object.freeze(T) : T);
      }
      function wu(n, t) {
        return Ce(n.lower, t.lower) === 0 && Ce(n.upper, t.upper) === 0 && !!n.lowerOpen == !!t.lowerOpen && !!n.upperOpen == !!t.upperOpen;
      }
      function Lr(n, t) {
        return function(u, r, c, f) {
          if (u === void 0) return r !== void 0 ? -1 : 0;
          if (r === void 0) return 1;
          if ((r = Ce(u, r)) === 0) {
            if (c && f) return 0;
            if (c) return 1;
            if (f) return -1;
          }
          return r;
        }(n.lower, t.lower, n.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(u, r, c, f) {
          if (u === void 0) return r !== void 0 ? 1 : 0;
          if (r === void 0) return -1;
          if ((r = Ce(u, r)) === 0) {
            if (c && f) return 0;
            if (c) return -1;
            if (f) return 1;
          }
          return r;
        }(n.upper, t.upper, n.upperOpen, t.upperOpen);
      }
      function Dr(n, t, u, r) {
        n.subscribers.add(u), r.addEventListener("abort", function() {
          var c, f;
          n.subscribers.delete(u), n.subscribers.size === 0 && (c = n, f = t, setTimeout(function() {
            c.subscribers.size === 0 && de(f, c);
          }, 3e3));
        });
      }
      var Or = { stack: "dbcore", level: 0, name: "Cache", create: function(n) {
        var t = n.schema.name;
        return a(a({}, n), { transaction: function(u, r, c) {
          var f, p, g = n.transaction(u, r, c);
          return r === "readwrite" && (p = (f = new AbortController()).signal, c = function(L) {
            return function() {
              if (f.abort(), r === "readwrite") {
                for (var O = /* @__PURE__ */ new Set(), w = 0, v = u; w < v.length; w++) {
                  var T = v[w], D = nl["idb://".concat(t, "/").concat(T)];
                  if (D) {
                    var b = n.table(T), C = D.optimisticOps.filter(function(ne) {
                      return ne.trans === g;
                    });
                    if (g._explicit && L && g.mutatedParts) for (var S = 0, P = Object.values(D.queries.query); S < P.length; S++) for (var E = 0, N = (Y = P[S]).slice(); E < N.length; E++) Wt((H = N[E]).obsSet, g.mutatedParts) && (de(Y, H), H.subscribers.forEach(function(ne) {
                      return O.add(ne);
                    }));
                    else if (0 < C.length) {
                      D.optimisticOps = D.optimisticOps.filter(function(ne) {
                        return ne.trans !== g;
                      });
                      for (var F = 0, G = Object.values(D.queries.query); F < G.length; F++) for (var Y, H, $, J = 0, Q = (Y = G[F]).slice(); J < Q.length; J++) (H = Q[J]).res != null && g.mutatedParts && (L && !H.dirty ? ($ = Object.isFrozen(H.res), $ = bu(H.res, H.req, C, b, H, $), H.dirty ? (de(Y, H), H.subscribers.forEach(function(ne) {
                        return O.add(ne);
                      })) : $ !== H.res && (H.res = $, H.promise = ee.resolve({ result: $ }))) : (H.dirty && de(Y, H), H.subscribers.forEach(function(ne) {
                        return O.add(ne);
                      })));
                    }
                  }
                }
                O.forEach(function(ne) {
                  return ne();
                });
              }
            };
          }, g.addEventListener("abort", c(!1), { signal: p }), g.addEventListener("error", c(!1), { signal: p }), g.addEventListener("complete", c(!0), { signal: p })), g;
        }, table: function(u) {
          var r = n.table(u), c = r.schema.primaryKey;
          return a(a({}, r), { mutate: function(f) {
            var p = re.trans;
            if (c.outbound || p.db._options.cache === "disabled" || p.explicit || p.idbtrans.mode !== "readwrite") return r.mutate(f);
            var g = nl["idb://".concat(t, "/").concat(u)];
            return g ? (p = r.mutate(f), f.type !== "add" && f.type !== "put" || !(50 <= f.values.length || ni(c, f).some(function(L) {
              return L == null;
            })) ? (g.optimisticOps.push(f), f.mutatedParts && st(f.mutatedParts), p.then(function(L) {
              0 < L.numFailures && (de(g.optimisticOps, f), (L = Ou(0, f, L)) && g.optimisticOps.push(L), f.mutatedParts && st(f.mutatedParts));
            }), p.catch(function() {
              de(g.optimisticOps, f), f.mutatedParts && st(f.mutatedParts);
            })) : p.then(function(L) {
              var O = Ou(0, a(a({}, f), { values: f.values.map(function(w, v) {
                var T;
                return L.failures[v] ? w : (w = (T = c.keyPath) !== null && T !== void 0 && T.includes(".") ? ve(w) : a({}, w), te(w, c.keyPath, L.results[v]), w);
              }) }), L);
              g.optimisticOps.push(O), queueMicrotask(function() {
                return f.mutatedParts && st(f.mutatedParts);
              });
            }), p) : r.mutate(f);
          }, query: function(f) {
            if (!Lu(re, r) || !Du("query", f)) return r.query(f);
            var p = ((O = re.trans) === null || O === void 0 ? void 0 : O.db._options.cache) === "immutable", v = re, g = v.requery, L = v.signal, O = function(b, C, S, P) {
              var E = nl["idb://".concat(b, "/").concat(C)];
              if (!E) return [];
              if (!(C = E.queries[S])) return [null, !1, E, null];
              var N = C[(P.query ? P.query.index.name : null) || ""];
              if (!N) return [null, !1, E, null];
              switch (S) {
                case "query":
                  var F = N.find(function(G) {
                    return G.req.limit === P.limit && G.req.values === P.values && wu(G.req.query.range, P.query.range);
                  });
                  return F ? [F, !0, E, N] : [N.find(function(G) {
                    return ("limit" in G.req ? G.req.limit : 1 / 0) >= P.limit && (!P.values || G.req.values) && Lr(G.req.query.range, P.query.range);
                  }), !1, E, N];
                case "count":
                  return F = N.find(function(G) {
                    return wu(G.req.query.range, P.query.range);
                  }), [F, !!F, E, N];
              }
            }(t, u, "query", f), w = O[0], v = O[1], T = O[2], D = O[3];
            return w && v ? w.obsSet = f.obsSet : (v = r.query(f).then(function(b) {
              var C = b.result;
              if (w && (w.res = C), p) {
                for (var S = 0, P = C.length; S < P; ++S) Object.freeze(C[S]);
                Object.freeze(C);
              } else b.result = ve(C);
              return b;
            }).catch(function(b) {
              return D && w && de(D, w), Promise.reject(b);
            }), w = { obsSet: f.obsSet, promise: v, subscribers: /* @__PURE__ */ new Set(), type: "query", req: f, dirty: !1 }, D ? D.push(w) : (D = [w], (T = T || (nl["idb://".concat(t, "/").concat(u)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[f.query.index.name || ""] = D)), Dr(w, D, g, L), w.promise.then(function(b) {
              return { result: bu(b.result, f, T?.optimisticOps, r, w, p) };
            });
          } });
        } });
      } };
      function ot(n, t) {
        return new Proxy(n, { get: function(u, r, c) {
          return r === "db" ? t : Reflect.get(u, r, c);
        } });
      }
      var En = ($e.prototype.version = function(n) {
        if (isNaN(n) || n < 0.1) throw new Z.Type("Given version is not a positive number");
        if (n = Math.round(10 * n) / 10, this.idbdb || this._state.isBeingOpened) throw new Z.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, n);
        var t = this._versions, u = t.filter(function(r) {
          return r._cfg.version === n;
        })[0];
        return u || (u = new this.Version(n), t.push(u), t.sort(fr), u.stores({}), this._state.autoSchema = !1, u);
      }, $e.prototype._whenReady = function(n) {
        var t = this;
        return this.idbdb && (this._state.openComplete || re.letThrough || this._vip) ? n() : new ee(function(u, r) {
          if (t._state.openComplete) return r(new Z.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void r(new Z.DatabaseClosed());
            t.open().catch(Oe);
          }
          t._state.dbReadyPromise.then(u, r);
        }).then(n);
      }, $e.prototype.use = function(n) {
        var t = n.stack, u = n.create, r = n.level, c = n.name;
        return c && this.unuse({ stack: t, name: c }), n = this._middlewares[t] || (this._middlewares[t] = []), n.push({ stack: t, create: u, level: r ?? 10, name: c }), n.sort(function(f, p) {
          return f.level - p.level;
        }), this;
      }, $e.prototype.unuse = function(n) {
        var t = n.stack, u = n.name, r = n.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(c) {
          return r ? c.create !== r : !!u && c.name !== u;
        })), this;
      }, $e.prototype.open = function() {
        var n = this;
        return Qn(An, function() {
          return gr(n);
        });
      }, $e.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var n = this._state, t = ol.indexOf(this);
        if (0 <= t && ol.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        n.isBeingOpened || (n.dbReadyPromise = new ee(function(u) {
          n.dbReadyResolve = u;
        }), n.openCanceller = new ee(function(u, r) {
          n.cancelOpen = r;
        }));
      }, $e.prototype.close = function(u) {
        var t = (u === void 0 ? { disableAutoOpen: !0 } : u).disableAutoOpen, u = this._state;
        t ? (u.isBeingOpened && u.cancelOpen(new Z.DatabaseClosed()), this._close(), u.autoOpen = !1, u.dbOpenError = new Z.DatabaseClosed()) : (this._close(), u.autoOpen = this._options.autoOpen || u.isBeingOpened, u.openComplete = !1, u.dbOpenError = null);
      }, $e.prototype.delete = function(n) {
        var t = this;
        n === void 0 && (n = { disableAutoOpen: !0 });
        var u = 0 < arguments.length && typeof arguments[0] != "object", r = this._state;
        return new ee(function(c, f) {
          function p() {
            t.close(n);
            var g = t._deps.indexedDB.deleteDatabase(t.name);
            g.onsuccess = Be(function() {
              var L, O, w;
              L = t._deps, O = t.name, w = L.indexedDB, L = L.IDBKeyRange, jt(w) || O === Wl || zt(w, L).delete(O).catch(Oe), c();
            }), g.onerror = bn(f), g.onblocked = t._fireOnBlocked;
          }
          if (u) throw new Z.InvalidArgument("Invalid closeOptions argument to db.delete()");
          r.isBeingOpened ? r.dbReadyPromise.then(p) : p();
        });
      }, $e.prototype.backendDB = function() {
        return this.idbdb;
      }, $e.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, $e.prototype.hasBeenClosed = function() {
        var n = this._state.dbOpenError;
        return n && n.name === "DatabaseClosed";
      }, $e.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, $e.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty($e.prototype, "tables", { get: function() {
        var n = this;
        return m(this._allTables).map(function(t) {
          return n._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), $e.prototype.transaction = function() {
        var n = (function(t, u, r) {
          var c = arguments.length;
          if (c < 2) throw new Z.InvalidArgument("Too few arguments");
          for (var f = new Array(c - 1); --c; ) f[c - 1] = arguments[c];
          return r = f.pop(), [t, ce(f), r];
        }).apply(this, arguments);
        return this._transaction.apply(this, n);
      }, $e.prototype._transaction = function(n, t, u) {
        var r = this, c = re.trans;
        c && c.db === this && n.indexOf("!") === -1 || (c = null);
        var f, p, g = n.indexOf("?") !== -1;
        n = n.replace("!", "").replace("?", "");
        try {
          if (p = t.map(function(O) {
            if (O = O instanceof r.Table ? O.name : O, typeof O != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return O;
          }), n == "r" || n === _t) f = _t;
          else {
            if (n != "rw" && n != Nt) throw new Z.InvalidArgument("Invalid transaction mode: " + n);
            f = Nt;
          }
          if (c) {
            if (c.mode === _t && f === Nt) {
              if (!g) throw new Z.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              c = null;
            }
            c && p.forEach(function(O) {
              if (c && c.storeNames.indexOf(O) === -1) {
                if (!g) throw new Z.SubTransaction("Table " + O + " not included in parent transaction.");
                c = null;
              }
            }), g && c && !c.active && (c = null);
          }
        } catch (O) {
          return c ? c._promise(null, function(w, v) {
            v(O);
          }) : He(O);
        }
        var L = (function O(w, v, T, D, b) {
          return ee.resolve().then(function() {
            var C = re.transless || re, S = w._createTransaction(v, T, w._dbSchema, D);
            if (S.explicit = !0, C = { trans: S, transless: C }, D) S.idbtrans = D.idbtrans;
            else try {
              S.create(), S.idbtrans._explicit = !0, w._state.PR1398_maxLoop = 3;
            } catch (N) {
              return N.name === k.InvalidState && w.isOpen() && 0 < --w._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), w.close({ disableAutoOpen: !1 }), w.open().then(function() {
                return O(w, v, T, null, b);
              })) : He(N);
            }
            var P, E = Ye(b);
            return E && cl(), C = ee.follow(function() {
              var N;
              (P = b.call(S, S)) && (E ? (N = Kn.bind(null, null), P.then(N, N)) : typeof P.next == "function" && typeof P.throw == "function" && (P = Jt(P)));
            }, C), (P && typeof P.then == "function" ? ee.resolve(P).then(function(N) {
              return S.active ? N : He(new Z.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : C.then(function() {
              return P;
            })).then(function(N) {
              return D && S._resolve(), S._completion.then(function() {
                return N;
              });
            }).catch(function(N) {
              return S._reject(N), He(N);
            });
          });
        }).bind(null, this, f, p, c, u);
        return c ? c._promise(f, L, "lock") : re.trans ? Qn(re.transless, function() {
          return r._whenReady(L);
        }) : this._whenReady(L);
      }, $e.prototype.table = function(n) {
        if (!I(this._allTables, n)) throw new Z.InvalidTable("Table ".concat(n, " does not exist"));
        return this._allTables[n];
      }, $e);
      function $e(n, t) {
        var u = this;
        this._middlewares = {}, this.verno = 0;
        var r = $e.dependencies;
        this._options = t = a({ addons: $e.addons, autoOpen: !0, indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, r = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var c, f, p, g, L, O = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: Oe, dbReadyPromise: null, cancelOpen: Oe, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        O.dbReadyPromise = new ee(function(v) {
          O.dbReadyResolve = v;
        }), O.openCanceller = new ee(function(v, T) {
          O.cancelOpen = T;
        }), this._state = O, this.name = n, this.on = Ll(this, "populate", "blocked", "versionchange", "close", { ready: [_e, Oe] }), this.once = function(v, T) {
          var D = function() {
            for (var b = [], C = 0; C < arguments.length; C++) b[C] = arguments[C];
            u.on(v).unsubscribe(D), T.apply(u, b);
          };
          return u.on(v, D);
        }, this.on.ready.subscribe = B(this.on.ready.subscribe, function(v) {
          return function(T, D) {
            $e.vip(function() {
              var b, C = u._state;
              C.openComplete ? (C.dbOpenError || ee.resolve().then(T), D && v(T)) : C.onReadyBeingFired ? (C.onReadyBeingFired.push(T), D && v(T)) : (v(T), b = u, D || v(function S() {
                b.on.ready.unsubscribe(T), b.on.ready.unsubscribe(S);
              }));
            });
          };
        }), this.Collection = (c = this, Dl(ur.prototype, function(P, S) {
          this.db = c;
          var D = nu, b = null;
          if (S) try {
            D = S();
          } catch (E) {
            b = E;
          }
          var C = P._ctx, S = C.table, P = S.hook.reading.fire;
          this._ctx = { table: S, index: C.index, isPrimKey: !C.index || S.schema.primKey.keyPath && C.index === S.schema.primKey.name, range: D, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: b, or: C.or, valueMapper: P !== j ? P : null };
        })), this.Table = (f = this, Dl(uu.prototype, function(v, T, D) {
          this.db = f, this._tx = D, this.name = v, this.schema = T, this.hook = f._allTables[v] ? f._allTables[v].hook : Ll(null, { creating: [Te, Oe], reading: [ue, j], updating: [we, Oe], deleting: [Le, Oe] });
        })), this.Transaction = (p = this, Dl(sr.prototype, function(v, T, D, b, C) {
          var S = this;
          v !== "readonly" && T.forEach(function(P) {
            P = (P = D[P]) === null || P === void 0 ? void 0 : P.yProps, P && (T = T.concat(P.map(function(E) {
              return E.updatesTable;
            })));
          }), this.db = p, this.mode = v, this.storeNames = T, this.schema = D, this.chromeTransactionDurability = b, this.idbtrans = null, this.on = Ll(this, "complete", "error", "abort"), this.parent = C || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ee(function(P, E) {
            S._resolve = P, S._reject = E;
          }), this._completion.then(function() {
            S.active = !1, S.on.complete.fire();
          }, function(P) {
            var E = S.active;
            return S.active = !1, S.on.error.fire(P), S.parent ? S.parent._reject(P) : E && S.idbtrans && S.idbtrans.abort(), He(P);
          });
        })), this.Version = (g = this, Dl(hr.prototype, function(v) {
          this.db = g, this._cfg = { version: v, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (L = this, Dl(mu.prototype, function(v, T, D) {
          if (this.db = L, this._ctx = { table: v, index: T === ":id" ? null : T, or: D }, this._cmp = this._ascending = Ce, this._descending = function(b, C) {
            return Ce(C, b);
          }, this._max = function(b, C) {
            return 0 < Ce(b, C) ? b : C;
          }, this._min = function(b, C) {
            return Ce(b, C) < 0 ? b : C;
          }, this._IDBKeyRange = L._deps.IDBKeyRange, !this._IDBKeyRange) throw new Z.MissingAPI();
        })), this.on("versionchange", function(v) {
          0 < v.newVersion ? console.warn("Another connection wants to upgrade database '".concat(u.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(u.name, "'. Closing db now to resume the delete request.")), u.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(v) {
          !v.newVersion || v.newVersion < v.oldVersion ? console.warn("Dexie.delete('".concat(u.name, "') was blocked")) : console.warn("Upgrade '".concat(u.name, "' blocked by other connection holding version ").concat(v.oldVersion / 10));
        }), this._maxKey = Sl(t.IDBKeyRange), this._createTransaction = function(v, T, D, b) {
          return new u.Transaction(v, T, D, u._options.chromeTransactionDurability, b);
        }, this._fireOnBlocked = function(v) {
          u.on("blocked").fire(v), ol.filter(function(T) {
            return T.name === u.name && T !== u && !T._state.vcFired;
          }).map(function(T) {
            return T.on("versionchange").fire(v);
          });
        }, this.use(yr), this.use(Or), this.use(Ir), this.use(vr), this.use(xr);
        var w = new Proxy(this, { get: function(v, T, D) {
          if (T === "_vip") return !0;
          if (T === "table") return function(C) {
            return ot(u.table(C), w);
          };
          var b = Reflect.get(v, T, D);
          return b instanceof uu ? ot(b, w) : T === "tables" ? b.map(function(C) {
            return ot(C, w);
          }) : T === "_createTransaction" ? function() {
            return ot(b.apply(this, arguments), w);
          } : b;
        } });
        this.vip = w, r.forEach(function(v) {
          return v(u);
        });
      }
      var mt, In = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", br = (ti.prototype.subscribe = function(n, t, u) {
        return this._subscribe(n && typeof n != "function" ? n : { next: n, error: t, complete: u });
      }, ti.prototype[In] = function() {
        return this;
      }, ti);
      function ti(n) {
        this._subscribe = n;
      }
      try {
        mt = { indexedDB: o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB, IDBKeyRange: o.IDBKeyRange || o.webkitIDBKeyRange };
      } catch {
        mt = { indexedDB: null, IDBKeyRange: null };
      }
      function Su(n) {
        var t, u = !1, r = new br(function(c) {
          var f = Ye(n), p, g = !1, L = {}, O = {}, w = { get closed() {
            return g;
          }, unsubscribe: function() {
            g || (g = !0, p && p.abort(), v && jn.storagemutated.unsubscribe(D));
          } };
          c.start && c.start(w);
          var v = !1, T = function() {
            return Et(b);
          }, D = function(C) {
            rt(L, C), Wt(O, L) && T();
          }, b = function() {
            var C, S, P;
            !g && mt.indexedDB && (L = {}, C = {}, p && p.abort(), p = new AbortController(), P = function(E) {
              var N = rl();
              try {
                f && cl();
                var F = Un(n, E);
                return F = f ? F.finally(Kn) : F;
              } finally {
                N && sl();
              }
            }(S = { subscr: C, signal: p.signal, requery: T, querier: n, trans: null }), Promise.resolve(P).then(function(E) {
              u = !0, t = E, g || S.signal.aborted || (L = {}, function(N) {
                for (var F in N) if (I(N, F)) return;
                return 1;
              }(O = C) || v || (jn(wl, D), v = !0), Et(function() {
                return !g && c.next && c.next(E);
              }));
            }, function(E) {
              u = !1, ["DatabaseClosedError", "AbortError"].includes(E?.name) || g || Et(function() {
                g || c.error && c.error(E);
              });
            }));
          };
          return setTimeout(T, 0), w;
        });
        return r.hasValue = function() {
          return u;
        }, r.getValue = function() {
          return t;
        }, r;
      }
      var ll = En;
      function ii(n) {
        var t = Hn;
        try {
          Hn = !0, jn.storagemutated.fire(n), Qt(n, !0);
        } finally {
          Hn = t;
        }
      }
      q(ll, a(a({}, Qe), { delete: function(n) {
        return new ll(n, { addons: [] }).delete();
      }, exists: function(n) {
        return new ll(n, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(n) {
        try {
          return t = ll.dependencies, u = t.indexedDB, t = t.IDBKeyRange, (jt(u) ? Promise.resolve(u.databases()).then(function(r) {
            return r.map(function(c) {
              return c.name;
            }).filter(function(c) {
              return c !== Wl;
            });
          }) : zt(u, t).toCollection().primaryKeys()).then(n);
        } catch {
          return He(new Z.MissingAPI());
        }
        var t, u;
      }, defineClass: function() {
        return function(n) {
          h(this, n);
        };
      }, ignoreTransaction: function(n) {
        return re.trans ? Qn(re.transless, n) : n();
      }, vip: Ht, async: function(n) {
        return function() {
          try {
            var t = Jt(n.apply(this, arguments));
            return t && typeof t.then == "function" ? t : ee.resolve(t);
          } catch (u) {
            return He(u);
          }
        };
      }, spawn: function(n, t, u) {
        try {
          var r = Jt(n.apply(u, t || []));
          return r && typeof r.then == "function" ? r : ee.resolve(r);
        } catch (c) {
          return He(c);
        }
      }, currentTransaction: { get: function() {
        return re.trans || null;
      } }, waitFor: function(n, t) {
        return t = ee.resolve(typeof n == "function" ? ll.ignoreTransaction(n) : n).timeout(t || 6e4), re.trans ? re.trans.waitFor(t) : t;
      }, Promise: ee, debug: { get: function() {
        return be;
      }, set: function(n) {
        Pe(n);
      } }, derive: V, extend: h, props: q, override: B, Events: Ll, on: jn, liveQuery: Su, extendObservabilitySet: rt, getByKeyPath: se, setByKeyPath: te, delByKeyPath: function(n, t) {
        typeof t == "string" ? te(n, t, void 0) : "length" in t && [].map.call(t, function(u) {
          te(n, u, void 0);
        });
      }, shallowClone: me, deepClone: ve, getObjectDiff: ei, cmp: Ce, asap: W, minKey: -1 / 0, addons: [], connections: ol, errnames: k, dependencies: mt, cache: nl, semVer: "4.2.0", version: "4.2.0".split(".").map(function(n) {
        return parseInt(n);
      }).reduce(function(n, t, u) {
        return n + t / Math.pow(10, 2 * u);
      }) })), ll.maxKey = Sl(ll.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (jn(wl, function(n) {
        Hn || (n = new CustomEvent(kt, { detail: n }), Hn = !0, dispatchEvent(n), Hn = !1);
      }), addEventListener(kt, function(n) {
        n = n.detail, Hn || ii(n);
      }));
      var xl, Hn = !1, Cu = function() {
      };
      return typeof BroadcastChannel < "u" && ((Cu = function() {
        (xl = new BroadcastChannel(kt)).onmessage = function(n) {
          return n.data && ii(n.data);
        };
      })(), typeof xl.unref == "function" && xl.unref(), jn(wl, function(n) {
        Hn || xl.postMessage(n);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(n) {
        if (!En.disableBfCache && n.persisted) {
          be && console.debug("Dexie: handling persisted pagehide"), xl?.close();
          for (var t = 0, u = ol; t < u.length; t++) u[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(n) {
        !En.disableBfCache && n.persisted && (be && console.debug("Dexie: handling persisted pageshow"), Cu(), ii({ all: new an(-1 / 0, [[]]) }));
      })), ee.rejectionMapper = function(n, t) {
        return !n || n instanceof un || n instanceof TypeError || n instanceof SyntaxError || !n.name || !ie[n.name] ? n : (t = new ie[n.name](t || n.message, n), "stack" in n && R(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, Pe(be), a(En, Object.freeze({ __proto__: null, Dexie: En, liveQuery: Su, Entity: lu, cmp: Ce, PropModification: Ol, replacePrefix: function(n, t) {
        return new Ol({ replacePrefix: [n, t] });
      }, add: function(n) {
        return new Ol({ add: n });
      }, remove: function(n) {
        return new Ol({ remove: n });
      }, default: En, RangeSet: an, mergeRanges: Pl, rangesOverlap: gu }), { default: En }), En;
    });
  }(sc)), sc.exports;
}
var xS = vS();
const Vm = /* @__PURE__ */ hS(xS), up = Symbol.for("Dexie"), _c = globalThis[up] || (globalThis[up] = Vm);
if (Vm.semVer !== _c.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Vm.semVer} and ${_c.semVer}`);
const {
  liveQuery: yS,
  mergeRanges: $C,
  rangesOverlap: WC,
  RangeSet: YC,
  cmp: XC,
  Entity: QC,
  PropModification: JC,
  replacePrefix: eT,
  add: nT,
  remove: lT,
  DexieYProvider: tT
} = _c, vo = /* @__PURE__ */ to("s-ied-implementation/primary-sidebar", () => {
  const e = BD(
    "currentActiveIcdDatabaseName",
    "",
    localStorage
  ), l = Fe(null), i = Fe(""), a = Fe(), s = Re(() => {
    const I = Os(), { sdkInstance: q } = Lt(I);
    return q.value?.utils.getAttributeValueByName({
      attributes: l.value?.attributes || [],
      name: "name"
    }) || "";
  }), o = Re(() => e.value ? jg({ databaseName: e.value, version: Tc }) : null);
  function m(I) {
    const { onChange: q, reset: A } = KD({
      multiple: !1,
      accept: ".icd",
      input: I
    });
    q(async (R) => {
      const V = R?.[0];
      if (!V) return;
      const U = await cS({ files: [V] });
      e.value = U[0];
    }), a.value = A;
  }
  async function d() {
    e.value && x();
  }
  async function h(I) {
    if (!e.value) return;
    const q = new File([], e.value + ".icd", {
      type: "application/xml"
    }), A = new DataTransfer();
    A.items.add(q), I.files = A.files;
  }
  async function x() {
    await _c.delete(e.value), e.value = "", a.value?.();
  }
  async function y() {
    l.value = null, i.value = "", await x();
  }
  return {
    // states
    currentActiveIcdDatabaseName: e,
    selectedSied: l,
    selectedLnodeId: i,
    // getters
    selectedSiedName: s,
    icdSdkInstance: o,
    // actions
    importIcdFile: d,
    resetSelection: y,
    setupFileDialog: m,
    loadIcdFileInMemory: h
  };
});
function Au(e, l) {
  if (!e)
    throw new Error("Unexpected Error!");
}
const Cs = /* @__PURE__ */ to("s-ied-implementation/dialog", () => {
  const e = {
    component: void 0,
    props: void 0,
    isLoading: void 0
  }, l = Fe(), i = Fl(e);
  function a() {
    i.value = e;
  }
  function s() {
    l.value?.close(), SD(() => {
      a();
    }, 300);
  }
  function o(m) {
    const { component: d, props: h, isLoading: x } = m;
    if (!d) throw new Error("Dialog component is undefined");
    i.value = {
      component: $a(d),
      props: h,
      isLoading: x
    }, l.value?.showModal();
  }
  return {
    // states
    dialogRef: l,
    currentDialog: i,
    // actions
    hardReset: a,
    handleClose: s,
    setCurrentDialog: o
  };
});
function Ts(e) {
  const { attributes: l, keys: i } = e, a = [];
  for (const s of i) a.push(l[s]);
  return a.join(".");
}
function Ws(e) {
  const { sdkInstance: l, records: i, keyAttributes: a } = e, s = /* @__PURE__ */ new Map();
  for (const o of i) {
    const m = Ts({
      attributes: l.utils.getAttributesValuesByName({
        attributes: o.attributes
      }),
      keys: a
    });
    m && !s.has(m) && s.set(m, o);
  }
  return s;
}
function IS(e) {
  const { sdkInstance: l, localLnode: i, icdLNodeSpecNamingMap: a } = e, s = i.treeChildren.find(
    (d) => d.tagName === "LNodeSpecNaming"
  );
  if (!s) return;
  const o = Ts({
    attributes: l.utils.getAttributesValuesByName({
      attributes: s.attributes
    }),
    keys: ["sLdInst", "sPrefix", "sLnClass", "sLnInst"]
  });
  if (!o)
    return {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    };
  const m = a.get(o);
  return {
    total: 1,
    perfectMatches: m ? [{ local: s, icd: m }] : [],
    manualMatches: [],
    noMatches: m ? [] : [s]
  };
}
function LS(e) {
  const { localLnode: l, matchingIcdLn: i } = e;
  return {
    total: 1,
    perfectMatches: i ? [{ local: l, icd: i }] : [],
    manualMatches: [],
    noMatches: i ? [] : [l]
  };
}
function DS(e) {
  const { sdkInstance: l, localLnode: i, icdSourceRefMap: a } = e, s = [], o = i.treeChildren.filter(
    (m) => m.tagName === "SourceRef"
  );
  for (const m of o) {
    const d = Ts({
      attributes: l.utils.getAttributesValuesByName({
        attributes: m.attributes
      }),
      keys: ["input", "inputInst", "pDA"]
    });
    if (!d) {
      s.push({
        total: 0,
        perfectMatches: [],
        manualMatches: [],
        noMatches: []
      });
      continue;
    }
    const h = a.get(d);
    s.push({
      total: 1,
      perfectMatches: h ? [{ local: m, icd: h }] : [],
      manualMatches: [],
      noMatches: h ? [] : [m]
    });
  }
  return s;
}
function OS(e) {
  const { sdkInstance: l, localLnode: i, icdControlRefMap: a } = e, s = [], o = i.treeChildren.filter(
    (m) => m.tagName === "ControlRef"
  );
  for (const m of o) {
    const d = Ts({
      attributes: l.utils.getAttributesValuesByName({
        attributes: m.attributes
      }),
      keys: ["output", "outputInst"]
    });
    if (!d) {
      s.push({
        total: 0,
        perfectMatches: [],
        manualMatches: [],
        noMatches: []
      });
      continue;
    }
    const h = a.get(d);
    s.push({
      total: 1,
      perfectMatches: h ? [{ local: m, icd: h }] : [],
      manualMatches: [],
      noMatches: h ? [] : [m]
    });
  }
  return s;
}
function bS(e) {
  const { sdkInstance: l, localDataModel: i, icdDataModel: a } = e, s = {
    total: 0,
    perfectMatches: [],
    manualMatches: [],
    noMatches: []
  }, o = [], { LNodeType: m = [], DOType: d = [] } = l.utils.groupRecordsByTagName(i), { LNodeType: h = [], DOType: x = [] } = l.utils.groupRecordsByTagName(a), y = m[0];
  if (!y) throw new Error("No LNodeType found in local data model");
  const I = h[0];
  if (!I) throw new Error("No LNodeType found in ICD data model");
  const q = y.treeChildren.filter(
    (V) => V.tagName === "DO"
  ), A = I.treeChildren.filter((V) => V.tagName === "DO");
  for (const V of q) {
    s.total++;
    const U = l.utils.getAttributeValueByName({
      attributes: V.attributes,
      name: "name"
    }), z = A.find(
      (B) => l.utils.getAttributeValueByName({
        attributes: B.attributes,
        name: "name"
      }) === U
    );
    z ? s.perfectMatches.push({
      local: V,
      icd: z
    }) : s.noMatches.push(V);
    const X = wS({
      sdkInstance: l,
      localDo: V,
      matchingIcdDo: z,
      localDoTypes: d,
      icdDoTypes: x
    });
    o.push(X);
  }
  const R = {
    total: o.reduce((V, U) => V + U.total, 0),
    perfectMatches: o.flatMap((V) => V.perfectMatches),
    manualMatches: o.flatMap((V) => V.manualMatches),
    noMatches: o.flatMap((V) => V.noMatches)
  };
  return { doMetrics: s, daMetrics: R };
}
function wS(e) {
  const { sdkInstance: l, localDo: i, matchingIcdDo: a, localDoTypes: s, icdDoTypes: o } = e, m = {
    total: 0,
    perfectMatches: [],
    manualMatches: [],
    noMatches: []
  }, d = l.utils.resolveDataModelRootElementReference({
    source: i,
    targets: s
  });
  if (!d) return m;
  const h = d.treeChildren.filter((y) => y.tagName === "DA");
  let x = [];
  if (a) {
    const y = l.utils.resolveDataModelRootElementReference({
      source: a,
      targets: o
    });
    y && (x = y.treeChildren.filter((I) => I.tagName === "DA"));
  }
  for (const y of h) {
    m.total++;
    const I = l.utils.getAttributeValueByName({
      attributes: y.attributes,
      name: "name"
    }), q = x.find(
      (A) => l.utils.getAttributeValueByName({
        attributes: A.attributes,
        name: "name"
      }) === I
    );
    q ? m.perfectMatches.push({
      local: y,
      icd: q
    }) : m.noMatches.push(y);
  }
  return m;
}
function SS(e) {
  const { sdkInstance: l, localDataModel: i } = e, a = i.filter((y) => y.tagName === "LNodeType");
  let s = 0, o = 0;
  const m = [], d = [];
  for (const y of a) {
    const I = y.treeChildren.filter((q) => q.tagName === "DO");
    s += I.length, m.push(...I);
    for (const q of I) {
      const A = l.utils.resolveDataModelRootElementReference({
        source: q,
        targets: i.filter((R) => R.tagName === "DOType")
      });
      if (A) {
        const R = A.treeChildren.filter((V) => V.tagName === "DA");
        o += R.length, d.push(...R);
      }
    }
  }
  return { doMetrics: {
    total: s,
    perfectMatches: [],
    manualMatches: [],
    noMatches: m
  }, daMetrics: {
    total: o,
    perfectMatches: [],
    manualMatches: [],
    noMatches: d
  } };
}
function Da(e) {
  return {
    total: e.reduce((l, i) => l + i.total, 0),
    perfectMatches: e.flatMap((l) => l.perfectMatches),
    manualMatches: e.flatMap((l) => l.manualMatches),
    noMatches: e.flatMap((l) => l.noMatches)
  };
}
const ap = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), CS = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (l, i, a) => a ? a.toUpperCase() : i.toLowerCase()
), TS = (e) => {
  const l = CS(e);
  return l.charAt(0).toUpperCase() + l.slice(1);
}, PS = (...e) => e.filter((l, i, a) => !!l && l.trim() !== "" && a.indexOf(l) === i).join(" ").trim(), rp = (e) => e === "";
var qr = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
const qS = ({
  name: e,
  iconNode: l,
  absoluteStrokeWidth: i,
  "absolute-stroke-width": a,
  strokeWidth: s,
  "stroke-width": o,
  size: m = qr.width,
  color: d = qr.stroke,
  ...h
}, { slots: x }) => gt(
  "svg",
  {
    ...qr,
    ...h,
    width: m,
    height: m,
    stroke: d,
    "stroke-width": rp(i) || rp(a) || i === !0 || a === !0 ? Number(s || o || qr["stroke-width"]) * 24 / Number(m) : s || o || qr["stroke-width"],
    class: PS(
      "lucide",
      h.class,
      ...e ? [`lucide-${ap(TS(e))}-icon`, `lucide-${ap(e)}`] : ["lucide-icon"]
    )
  },
  [...l.map((y) => gt(...y)), ...x.default ? [x.default()] : []]
);
const Ps = (e, l) => (i, { slots: a, attrs: s }) => gt(
  qS,
  {
    ...s,
    ...i,
    iconNode: l,
    name: e
  },
  a
);
const sp = Ps("check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
const AS = Ps("chevron-down", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
const kv = Ps("circle-x", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
  ["path", { d: "m9 9 6 6", key: "z0biqf" }]
]);
const RS = Ps("trash-2", [
  ["path", { d: "M10 11v6", key: "nco0om" }],
  ["path", { d: "M14 11v6", key: "outv1u" }],
  ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6", key: "miytrc" }],
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2", key: "e791ji" }]
]);
const ES = Ps("x", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), _S = { class: "flex flex-col gap-5" }, NS = {
  key: 0,
  role: "alert",
  class: "alert alert-error alert-soft"
}, FS = /* @__PURE__ */ dn({
  __name: "mapping-error",
  setup(e) {
    const l = Cs(), i = qs(), { error: a } = Lt(i);
    function s() {
      a.value = null, l.handleClose();
    }
    return (o, m) => (We(), Yn("div", _S, [
      le(a) ? (We(), Yn("div", NS, [
        je(le(kv)),
        fn("span", null, Ul(le(a)), 1)
      ])) : pi("", !0),
      fn("button", {
        class: "btn-close self-end",
        onClick: s
      }, "Close")
    ]));
  }
}), MS = /* @__PURE__ */ va(FS, [["__scopeId", "data-v-dadc7e4b"]]), kS = { class: "flex flex-col items-center gap-4 w-full justify-center mt-24" }, VS = {
  key: 0,
  class: "progress progress-primary w-56"
}, BS = ["value"], ZS = { class: "font-bold" }, US = { class: "mt-10 w-full" }, KS = { class: "modal-action" }, GS = ["disabled"], zS = /* @__PURE__ */ dn({
  __name: "mapping-loader",
  setup(e) {
    const l = qs(), i = Cs(), { progress: a, isLoading: s } = Lt(l), o = Re(() => a.value.total === 0 ? 0 : Math.round(a.value.current / a.value.total * 100)), m = Re(() => o.value === 100 && a.value.scope === "commit");
    function d() {
      i.handleClose(), s.value = !1;
    }
    return (h, x) => (We(), Yn("div", kS, [
      o.value === 0 || le(a).scope !== "commit" ? (We(), Yn("progress", VS)) : (We(), Yn("progress", {
        key: 1,
        class: "progress progress-primary w-56",
        value: o.value,
        max: "100"
      }, null, 8, BS)),
      fn("span", ZS, Ul(m.value ? "Mapping applied successfully!" : le(a).message), 1),
      fn("footer", US, [
        fn("div", KS, [
          fn("button", {
            class: "btn-close",
            onClick: d,
            disabled: !m.value
          }, [
            fn("span", {
              class: Bl([{ "loading loading-spinner": !m.value }])
            }, null, 2),
            x[0] || (x[0] = Gi(" Close ", -1))
          ], 8, GS)
        ])
      ])
    ]));
  }
}), jS = /* @__PURE__ */ va(zS, [["__scopeId", "data-v-50475871"]]);
function Vv(e) {
  return $i() ? (ma(e), !0) : !1;
}
const Bv = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const HS = Object.prototype.toString, $S = (e) => HS.call(e) === "[object Object]", WS = () => {
}, cp = /* @__PURE__ */ YS();
function YS() {
  var e, l;
  return Bv && ((e = window?.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((l = window?.navigator) == null ? void 0 : l.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function XS(...e) {
  if (e.length !== 1)
    return gs(...e);
  const l = e[0];
  return typeof l == "function" ? Bi(Wa(() => ({ get: l, set: WS }))) : Fe(l);
}
function Zo(e) {
  return Array.isArray(e) ? e : [e];
}
function QS(e, l, i) {
  return Sn(
    e,
    l,
    {
      ...i,
      immediate: !0
    }
  );
}
const JS = Bv ? window : void 0;
function e1(e) {
  var l;
  const i = hn(e);
  return (l = i?.$el) != null ? l : i;
}
function n1(...e) {
  const l = [], i = () => {
    l.forEach((d) => d()), l.length = 0;
  }, a = (d, h, x, y) => (d.addEventListener(h, x, y), () => d.removeEventListener(h, x, y)), s = Re(() => {
    const d = Zo(hn(e[0])).filter((h) => h != null);
    return d.every((h) => typeof h != "string") ? d : void 0;
  }), o = QS(
    () => {
      var d, h;
      return [
        (h = (d = s.value) == null ? void 0 : d.map((x) => e1(x))) != null ? h : [JS].filter((x) => x != null),
        Zo(hn(s.value ? e[1] : e[0])),
        Zo(le(s.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        hn(s.value ? e[3] : e[2])
      ];
    },
    ([d, h, x, y]) => {
      if (i(), !d?.length || !h?.length || !x?.length)
        return;
      const I = $S(y) ? { ...y } : y;
      l.push(
        ...d.flatMap(
          (q) => h.flatMap(
            (A) => x.map((R) => a(q, A, R, I))
          )
        )
      );
    },
    { flush: "post" }
  ), m = () => {
    o(), i();
  };
  return Vv(i), m;
}
function Uo(e) {
  return typeof Window < "u" && e instanceof Window ? e.document.documentElement : typeof Document < "u" && e instanceof Document ? e.documentElement : e;
}
function Zv(e) {
  const l = window.getComputedStyle(e);
  if (l.overflowX === "scroll" || l.overflowY === "scroll" || l.overflowX === "auto" && e.clientWidth < e.scrollWidth || l.overflowY === "auto" && e.clientHeight < e.scrollHeight)
    return !0;
  {
    const i = e.parentNode;
    return !i || i.tagName === "BODY" ? !1 : Zv(i);
  }
}
function l1(e) {
  const l = e || window.event, i = l.target;
  return Zv(i) ? !1 : l.touches.length > 1 ? !0 : (l.preventDefault && l.preventDefault(), !1);
}
const Ko = /* @__PURE__ */ new WeakMap();
function t1(e, l = !1) {
  const i = Fl(l);
  let a = null, s = "";
  Sn(XS(e), (d) => {
    const h = Uo(hn(d));
    if (h) {
      const x = h;
      if (Ko.get(x) || Ko.set(x, x.style.overflow), x.style.overflow !== "hidden" && (s = x.style.overflow), x.style.overflow === "hidden")
        return i.value = !0;
      if (i.value)
        return x.style.overflow = "hidden";
    }
  }, {
    immediate: !0
  });
  const o = () => {
    const d = Uo(hn(e));
    !d || i.value || (cp && (a = n1(
      d,
      "touchmove",
      (h) => {
        l1(h);
      },
      { passive: !1 }
    )), d.style.overflow = "hidden", i.value = !0);
  }, m = () => {
    const d = Uo(hn(e));
    !d || !i.value || (cp && a?.(), d.style.overflow = s, Ko.delete(d), i.value = !1);
  };
  return Vv(m), Re({
    get() {
      return i.value;
    },
    set(d) {
      d ? o() : m();
    }
  });
}
function i1() {
  let e = !1;
  const l = Fl(!1);
  return (i, a) => {
    if (l.value = a.value, e)
      return;
    e = !0;
    const s = t1(i, a.value);
    Sn(l, (o) => s.value = o);
  };
}
i1();
const op = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), u1 = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (l, i, a) => a ? a.toUpperCase() : i.toLowerCase()
), a1 = (e) => {
  const l = u1(e);
  return l.charAt(0).toUpperCase() + l.slice(1);
}, r1 = (...e) => e.filter((l, i, a) => !!l && l.trim() !== "" && a.indexOf(l) === i).join(" ").trim(), mp = (e) => e === "";
var Ar = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
const s1 = ({
  name: e,
  iconNode: l,
  absoluteStrokeWidth: i,
  "absolute-stroke-width": a,
  strokeWidth: s,
  "stroke-width": o,
  size: m = Ar.width,
  color: d = Ar.stroke,
  ...h
}, { slots: x }) => gt(
  "svg",
  {
    ...Ar,
    ...h,
    width: m,
    height: m,
    stroke: d,
    "stroke-width": mp(i) || mp(a) || i === !0 || a === !0 ? Number(s || o || Ar["stroke-width"]) * 24 / Number(m) : s || o || Ar["stroke-width"],
    class: r1(
      "lucide",
      h.class,
      ...e ? [`lucide-${op(a1(e))}-icon`, `lucide-${op(e)}`] : ["lucide-icon"]
    )
  },
  [...l.map((y) => gt(...y)), ...x.default ? [x.default()] : []]
);
const Me = (e, l) => (i, { slots: a, attrs: s }) => gt(
  s1,
  {
    ...s,
    ...i,
    iconNode: l,
    name: e
  },
  a
);
const Go = Me("activity", [
  [
    "path",
    {
      d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",
      key: "169zse"
    }
  ]
]);
const zo = Me("zap", [
  [
    "path",
    {
      d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
      key: "1xq2db"
    }
  ]
]);
const xi = Me("arrow-right", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);
const c1 = Me("variable", [
  ["path", { d: "M8 21s-4-3-4-9 4-9 4-9", key: "uto9ud" }],
  ["path", { d: "M16 3s4 3 4 9-4 9-4 9", key: "4w2vsq" }],
  ["line", { x1: "15", x2: "9", y1: "9", y2: "15", key: "f7djnv" }],
  ["line", { x1: "9", x2: "15", y1: "9", y2: "15", key: "1shsy8" }]
]);
const jo = Me("square-pen", [
  ["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7", key: "1m0v6g" }],
  [
    "path",
    {
      d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",
      key: "ohrbg2"
    }
  ]
]);
const o1 = Me("hash", [
  ["line", { x1: "4", x2: "20", y1: "9", y2: "9", key: "4lhtct" }],
  ["line", { x1: "4", x2: "20", y1: "15", y2: "15", key: "vyu0kd" }],
  ["line", { x1: "10", x2: "8", y1: "3", y2: "21", key: "1ggp8o" }],
  ["line", { x1: "16", x2: "14", y1: "3", y2: "21", key: "weycgp" }]
]);
const m1 = Me("rotate-cw", [
  ["path", { d: "M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8", key: "1p45f6" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }]
]);
const f1 = Me("timer", [
  ["line", { x1: "10", x2: "14", y1: "2", y2: "2", key: "14vaq8" }],
  ["line", { x1: "12", x2: "15", y1: "14", y2: "11", key: "17fdiu" }],
  ["circle", { cx: "12", cy: "14", r: "8", key: "1e1u0o" }]
]);
const Rr = Me("clock", [
  ["path", { d: "M12 6v6l4 2", key: "mmk7yg" }],
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
]);
const fp = Me("type", [
  ["path", { d: "M12 4v16", key: "1654pz" }],
  ["path", { d: "M4 7V5a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v2", key: "e0r10z" }],
  ["path", { d: "M9 20h6", key: "s66wpe" }]
]);
const d1 = Me("terminal", [
  ["path", { d: "M12 19h8", key: "baeox8" }],
  ["path", { d: "m4 17 6-6-6-6", key: "1yngyt" }]
]);
const dp = Me("toggle-right", [
  ["circle", { cx: "15", cy: "12", r: "3", key: "1afu0r" }],
  ["rect", { width: "20", height: "14", x: "2", y: "5", rx: "7", key: "g7kal2" }]
]);
const pp = Me("users", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["path", { d: "M16 3.128a4 4 0 0 1 0 7.744", key: "16gr8j" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
]);
const p1 = Me("building", [
  ["path", { d: "M12 10h.01", key: "1nrarc" }],
  ["path", { d: "M12 14h.01", key: "1etili" }],
  ["path", { d: "M12 6h.01", key: "1vi96p" }],
  ["path", { d: "M16 10h.01", key: "1m94wz" }],
  ["path", { d: "M16 14h.01", key: "1gbofw" }],
  ["path", { d: "M16 6h.01", key: "1x0f13" }],
  ["path", { d: "M8 10h.01", key: "19clt8" }],
  ["path", { d: "M8 14h.01", key: "6423bh" }],
  ["path", { d: "M8 6h.01", key: "1dz90k" }],
  ["path", { d: "M9 22v-3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3", key: "cabbwy" }],
  ["rect", { x: "4", y: "2", width: "16", height: "20", rx: "2", key: "1uxh74" }]
]);
const hp = Me("user-check", [
  ["path", { d: "m16 11 2 2 4-4", key: "9rsbq5" }],
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
]);
const Ho = Me("user", [
  ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
  ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]
]);
const Er = Me("network", [
  ["rect", { x: "16", y: "16", width: "6", height: "6", rx: "1", key: "4q2zg0" }],
  ["rect", { x: "2", y: "16", width: "6", height: "6", rx: "1", key: "8cvhb9" }],
  ["rect", { x: "9", y: "2", width: "6", height: "6", rx: "1", key: "1egb70" }],
  ["path", { d: "M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3", key: "1jsf9p" }],
  ["path", { d: "M12 12V8", key: "2874zd" }]
]);
const _r = Me("file-text", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
]);
const Ys = Me("square", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }]
]);
const Xs = Me("cpu", [
  ["path", { d: "M12 20v2", key: "1lh1kg" }],
  ["path", { d: "M12 2v2", key: "tus03m" }],
  ["path", { d: "M17 20v2", key: "1rnc9c" }],
  ["path", { d: "M17 2v2", key: "11trls" }],
  ["path", { d: "M2 12h2", key: "1t8f8n" }],
  ["path", { d: "M2 17h2", key: "7oei6x" }],
  ["path", { d: "M2 7h2", key: "asdhe0" }],
  ["path", { d: "M20 12h2", key: "1q8mjw" }],
  ["path", { d: "M20 17h2", key: "1fpfkl" }],
  ["path", { d: "M20 7h2", key: "1o8tra" }],
  ["path", { d: "M7 20v2", key: "4gnj0m" }],
  ["path", { d: "M7 2v2", key: "1i4yhu" }],
  ["rect", { x: "4", y: "4", width: "16", height: "16", rx: "2", key: "1vbyd7" }],
  ["rect", { x: "8", y: "8", width: "8", height: "8", rx: "1", key: "z9xiuo" }]
]);
const gp = Me("circle-check-big", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
const Ju = Me("tag", [
  [
    "path",
    {
      d: "M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z",
      key: "vktsd0"
    }
  ],
  ["circle", { cx: "7.5", cy: "7.5", r: ".5", fill: "currentColor", key: "kqv944" }]
]);
const $o = Me("files", [
  [
    "path",
    {
      d: "M15 2a2 2 0 0 1 1.414.586l4 4A2 2 0 0 1 21 8v7a2 2 0 0 1-2 2h-8a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z",
      key: "1vo8kb"
    }
  ],
  ["path", { d: "M15 2v4a2 2 0 0 0 2 2h4", key: "sud9ri" }],
  ["path", { d: "M5 7a2 2 0 0 0-2 2v11a2 2 0 0 0 2 2h8a2 2 0 0 0 1.732-1", key: "l4dndm" }]
]);
const vp = Me("square-check-big", [
  [
    "path",
    { d: "M21 10.656V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h12.344", key: "2acyp4" }
  ],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
const Wo = Me("gauge", [
  ["path", { d: "m12 14 4-4", key: "9kzdfg" }],
  ["path", { d: "M3.34 19a10 10 0 1 1 17.32 0", key: "19p75a" }]
]);
const h1 = Me("radio", [
  ["path", { d: "M16.247 7.761a6 6 0 0 1 0 8.478", key: "1fwjs5" }],
  ["path", { d: "M19.075 4.933a10 10 0 0 1 0 14.134", key: "ehdyv1" }],
  ["path", { d: "M4.925 19.067a10 10 0 0 1 0-14.134", key: "1q22gi" }],
  ["path", { d: "M7.753 16.239a6 6 0 0 1 0-8.478", key: "r2q7qm" }],
  ["circle", { cx: "12", cy: "12", r: "2", key: "1c9p78" }]
]);
const xp = Me("group", [
  ["path", { d: "M3 7V5c0-1.1.9-2 2-2h2", key: "adw53z" }],
  ["path", { d: "M17 3h2c1.1 0 2 .9 2 2v2", key: "an4l38" }],
  ["path", { d: "M21 17v2c0 1.1-.9 2-2 2h-2", key: "144t0e" }],
  ["path", { d: "M7 21H5c-1.1 0-2-.9-2-2v-2", key: "rtnfgi" }],
  ["rect", { width: "7", height: "5", x: "7", y: "7", rx: "1", key: "1eyiv7" }],
  ["rect", { width: "7", height: "5", x: "10", y: "12", rx: "1", key: "1qlmkx" }]
]);
const Oa = Me("gamepad-2", [
  ["line", { x1: "6", x2: "10", y1: "11", y2: "11", key: "1gktln" }],
  ["line", { x1: "8", x2: "8", y1: "9", y2: "13", key: "qnk9ow" }],
  ["line", { x1: "15", x2: "15.01", y1: "12", y2: "12", key: "krot7o" }],
  ["line", { x1: "18", x2: "18.01", y1: "10", y2: "10", key: "1lcuu1" }],
  [
    "path",
    {
      d: "M17.32 5H6.68a4 4 0 0 0-3.978 3.59c-.006.052-.01.101-.017.152C2.604 9.416 2 14.456 2 16a3 3 0 0 0 3 3c1 0 1.5-.5 2-1l1.414-1.414A2 2 0 0 1 9.828 16h4.344a2 2 0 0 1 1.414.586L17 18c.5.5 1 1 2 1a3 3 0 0 0 3-3c0-1.545-.604-6.584-.685-7.258-.007-.05-.011-.1-.017-.151A4 4 0 0 0 17.32 5z",
      key: "mfqc10"
    }
  ]
]);
const Qs = Me("upload", [
  ["path", { d: "M12 3v12", key: "1x0j5s" }],
  ["path", { d: "m17 8-5-5-5 5", key: "7q97r8" }],
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }]
]);
const g1 = Me("hand-platter", [
  ["path", { d: "M12 3V2", key: "ar7q03" }],
  [
    "path",
    {
      d: "m15.4 17.4 3.2-2.8a2 2 0 1 1 2.8 2.9l-3.6 3.3c-.7.8-1.7 1.2-2.8 1.2h-4c-1.1 0-2.1-.4-2.8-1.2l-1.302-1.464A1 1 0 0 0 6.151 19H5",
      key: "n2g93r"
    }
  ],
  ["path", { d: "M2 14h12a2 2 0 0 1 0 4h-2", key: "1o2jem" }],
  ["path", { d: "M4 10h16", key: "img6z1" }],
  ["path", { d: "M5 10a7 7 0 0 1 14 0", key: "1ega1o" }],
  ["path", { d: "M5 14v6a1 1 0 0 1-1 1H2", key: "1hescx" }]
]);
const yp = Me("list", [
  ["path", { d: "M3 5h.01", key: "18ugdj" }],
  ["path", { d: "M3 12h.01", key: "nlz23k" }],
  ["path", { d: "M3 19h.01", key: "noohij" }],
  ["path", { d: "M8 5h13", key: "1pao27" }],
  ["path", { d: "M8 12h13", key: "1za7za" }],
  ["path", { d: "M8 19h13", key: "m83p4d" }]
]);
const Yo = Me("server", [
  ["rect", { width: "20", height: "8", x: "2", y: "2", rx: "2", ry: "2", key: "ngkwjq" }],
  ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2", ry: "2", key: "iecqi9" }],
  ["line", { x1: "6", x2: "6.01", y1: "6", y2: "6", key: "16zg32" }],
  ["line", { x1: "6", x2: "6.01", y1: "18", y2: "18", key: "nzw8ys" }]
]);
const ea = Me("shield", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ]
]);
const Js = Me("external-link", [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
]);
const Xo = Me("shield-check", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ],
  ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
]);
const Nr = Me("send", [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
]);
const ai = Me("settings", [
  [
    "path",
    {
      d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
      key: "1i5ecw"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
const Ru = Me("sliders-vertical", [
  ["path", { d: "M10 8h4", key: "1sr2af" }],
  ["path", { d: "M12 21v-9", key: "17s77i" }],
  ["path", { d: "M12 8V3", key: "13r4qs" }],
  ["path", { d: "M17 16h4", key: "h1uq16" }],
  ["path", { d: "M19 12V3", key: "o1uvq1" }],
  ["path", { d: "M19 21v-5", key: "qua636" }],
  ["path", { d: "M3 14h4", key: "bcjad9" }],
  ["path", { d: "M5 10V3", key: "cb8scm" }],
  ["path", { d: "M5 21v-7", key: "1w1uti" }]
]);
const na = Me("database", [
  ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3", key: "msslwz" }],
  ["path", { d: "M3 5V19A9 3 0 0 0 21 19V5", key: "1wlel7" }],
  ["path", { d: "M3 12A9 3 0 0 0 21 12", key: "mv7ke4" }]
]);
const Fr = Me("box", [
  [
    "path",
    {
      d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",
      key: "hh9hay"
    }
  ],
  ["path", { d: "m3.3 7 8.7 5 8.7-5", key: "g66t2b" }],
  ["path", { d: "M12 22V12", key: "d0xqtd" }]
]);
const v1 = Me("file-code", [
  ["path", { d: "M10 12.5 8 15l2 2.5", key: "1tg20x" }],
  ["path", { d: "m14 12.5 2 2.5-2 2.5", key: "yinavb" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z", key: "1mlx9k" }]
]);
const x1 = Me("package", [
  [
    "path",
    {
      d: "M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z",
      key: "1a0edw"
    }
  ],
  ["path", { d: "M12 22V12", key: "d0xqtd" }],
  ["polyline", { points: "3.29 7 12 12 20.71 7", key: "ousv84" }],
  ["path", { d: "m7.5 4.27 9 5.15", key: "1c824w" }]
]);
const y1 = Me("shield-alert", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ],
  ["path", { d: "M12 8v4", key: "1got3b" }],
  ["path", { d: "M12 16h.01", key: "1drbdi" }]
]);
const Qo = Me("folder-open", [
  [
    "path",
    {
      d: "m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2",
      key: "usdka0"
    }
  ]
]);
const ec = Me("layers", [
  [
    "path",
    {
      d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",
      key: "zw3jo"
    }
  ],
  [
    "path",
    {
      d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",
      key: "1wduqc"
    }
  ],
  [
    "path",
    {
      d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",
      key: "kqbvx6"
    }
  ]
]);
const I1 = Me("repeat", [
  ["path", { d: "m17 2 4 4-4 4", key: "nntrym" }],
  ["path", { d: "M3 11v-1a4 4 0 0 1 4-4h14", key: "84bu3i" }],
  ["path", { d: "m7 22-4-4 4-4", key: "1wqhfi" }],
  ["path", { d: "M21 13v1a4 4 0 0 1-4 4H3", key: "1rx37r" }]
]);
const L1 = Me("play", [
  [
    "path",
    {
      d: "M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z",
      key: "10ikf1"
    }
  ]
]);
const D1 = Me("lock", [
  ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
  ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]
]);
const O1 = Me("battery-charging", [
  ["path", { d: "m11 7-3 5h4l-3 5", key: "b4a64w" }],
  ["path", { d: "M14.856 6H16a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.935", key: "lre1cr" }],
  ["path", { d: "M22 14v-4", key: "14q9d5" }],
  ["path", { d: "M5.14 18H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h2.936", key: "13q5k0" }]
]);
const Ip = Me("link-2", [
  ["path", { d: "M9 17H7A5 5 0 0 1 7 7h2", key: "8i5ue5" }],
  ["path", { d: "M15 7h2a5 5 0 1 1 0 10h-2", key: "1b9ql8" }],
  ["line", { x1: "8", x2: "16", y1: "12", y2: "12", key: "1jonct" }]
]);
const Lp = Me("link", [
  ["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71", key: "1cjeqo" }],
  ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71", key: "19qd67" }]
]);
const b1 = Me("cable", [
  [
    "path",
    { d: "M17 19a1 1 0 0 1-1-1v-2a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2a1 1 0 0 1-1 1z", key: "trhst0" }
  ],
  ["path", { d: "M17 21v-2", key: "ds4u3f" }],
  ["path", { d: "M19 14V6.5a1 1 0 0 0-7 0v11a1 1 0 0 1-7 0V10", key: "1mo9zo" }],
  ["path", { d: "M21 21v-2", key: "eo0ou" }],
  ["path", { d: "M3 5V3", key: "1k5hjh" }],
  [
    "path",
    { d: "M4 10a2 2 0 0 1-2-2V6a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2a2 2 0 0 1-2 2z", key: "1dd30t" }
  ],
  ["path", { d: "M7 5V3", key: "1t1388" }]
]);
const Jo = Me("arrow-up", [
  ["path", { d: "m5 12 7-7 7 7", key: "hav0vg" }],
  ["path", { d: "M12 19V5", key: "x0mq9r" }]
]);
const Mr = Me("arrow-up-right", [
  ["path", { d: "M7 7h10v10", key: "1tivn9" }],
  ["path", { d: "M7 17 17 7", key: "1vkiza" }]
]);
const Dp = Me("file", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }]
]);
const w1 = Me("minus", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
const S1 = Me("tags", [
  [
    "path",
    {
      d: "M13.172 2a2 2 0 0 1 1.414.586l6.71 6.71a2.4 2.4 0 0 1 0 3.408l-4.592 4.592a2.4 2.4 0 0 1-3.408 0l-6.71-6.71A2 2 0 0 1 6 9.172V3a1 1 0 0 1 1-1z",
      key: "16rjxf"
    }
  ],
  [
    "path",
    { d: "M2 7v6.172a2 2 0 0 0 .586 1.414l6.71 6.71a2.4 2.4 0 0 0 3.191.193", key: "178nd4" }
  ],
  ["circle", { cx: "10.5", cy: "6.5", r: ".5", fill: "currentColor", key: "12ikhr" }]
]);
const em = Me("arrow-down", [
  ["path", { d: "M12 5v14", key: "s699le" }],
  ["path", { d: "m19 12-7 7-7-7", key: "1idqje" }]
]);
const nm = Me("git-branch", [
  ["line", { x1: "6", x2: "6", y1: "3", y2: "15", key: "17qcm7" }],
  ["circle", { cx: "18", cy: "6", r: "3", key: "1h7g24" }],
  ["circle", { cx: "6", cy: "18", r: "3", key: "fqmcym" }],
  ["path", { d: "M18 9a9 9 0 0 1-9 9", key: "n2h4wq" }]
]);
const C1 = Me("hard-drive", [
  ["line", { x1: "22", x2: "2", y1: "12", y2: "12", key: "1y58io" }],
  [
    "path",
    {
      d: "M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z",
      key: "oot6mr"
    }
  ],
  ["line", { x1: "6", x2: "6.01", y1: "16", y2: "16", key: "sgf278" }],
  ["line", { x1: "10", x2: "10.01", y1: "16", y2: "16", key: "1l4acy" }]
]);
const Op = Me("globe", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }],
  ["path", { d: "M2 12h20", key: "9i4pu4" }]
]);
const bp = Me("key", [
  ["path", { d: "m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4", key: "g0fldk" }],
  ["path", { d: "m21 2-9.6 9.6", key: "1j0ho8" }],
  ["circle", { cx: "7.5", cy: "15.5", r: "5.5", key: "yqb3hr" }]
]);
const T1 = Me("history", [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
  ["path", { d: "M12 7v5l4 2", key: "1fdv2h" }]
]);
const P1 = Me("heading", [
  ["path", { d: "M6 12h12", key: "8npq4p" }],
  ["path", { d: "M6 20V4", key: "1w1bmo" }],
  ["path", { d: "M18 20V4", key: "o2hl4u" }]
]);
const wp = Me("folder", [
  [
    "path",
    {
      d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z",
      key: "1kt360"
    }
  ]
]);
const q1 = Me("git-fork", [
  ["circle", { cx: "12", cy: "18", r: "3", key: "1mpf1b" }],
  ["circle", { cx: "6", cy: "6", r: "3", key: "1lh9wr" }],
  ["circle", { cx: "18", cy: "6", r: "3", key: "1h7g24" }],
  ["path", { d: "M18 9v2c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V9", key: "1uq4wg" }],
  ["path", { d: "M12 12v3", key: "158kv8" }]
]);
const Sp = Me("user-cog", [
  ["path", { d: "M10 15H6a4 4 0 0 0-4 4v2", key: "1nfge6" }],
  ["path", { d: "m14.305 16.53.923-.382", key: "1itpsq" }],
  ["path", { d: "m15.228 13.852-.923-.383", key: "eplpkm" }],
  ["path", { d: "m16.852 12.228-.383-.923", key: "13v3q0" }],
  ["path", { d: "m16.852 17.772-.383.924", key: "1i8mnm" }],
  ["path", { d: "m19.148 12.228.383-.923", key: "1q8j1v" }],
  ["path", { d: "m19.53 18.696-.382-.924", key: "vk1qj3" }],
  ["path", { d: "m20.772 13.852.924-.383", key: "n880s0" }],
  ["path", { d: "m20.772 16.148.924.383", key: "1g6xey" }],
  ["circle", { cx: "18", cy: "15", r: "3", key: "gjjjvw" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
]);
const Cp = Me("square-function", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["path", { d: "M9 17c2 0 2.8-1 2.8-2.8V10c0-2 1-3.3 3.2-3", key: "m1af9g" }],
  ["path", { d: "M9 11.2h5.7", key: "3zgcl2" }]
]);
const A1 = Me("list-ordered", [
  ["path", { d: "M11 5h10", key: "1cz7ny" }],
  ["path", { d: "M11 12h10", key: "1438ji" }],
  ["path", { d: "M11 19h10", key: "11t30w" }],
  ["path", { d: "M4 4h1v5", key: "10yrso" }],
  ["path", { d: "M4 9h2", key: "r1h2o0" }],
  ["path", { d: "M6.5 20H3.4c0-1 2.6-1.925 2.6-3.5a1.5 1.5 0 0 0-2.6-1.02", key: "xtkcd5" }]
]);
const R1 = Me("table-2", [
  [
    "path",
    {
      d: "M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18",
      key: "gugj83"
    }
  ]
]);
const E1 = Me("layout-template", [
  ["rect", { width: "18", height: "7", x: "3", y: "3", rx: "1", key: "f1a2em" }],
  ["rect", { width: "9", height: "7", x: "3", y: "14", rx: "1", key: "jqznyg" }],
  ["rect", { width: "5", height: "7", x: "16", y: "14", rx: "1", key: "q5h2i8" }]
]);
const _1 = Me("table", [
  ["path", { d: "M12 3v18", key: "108xh3" }],
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M3 9h18", key: "1pudct" }],
  ["path", { d: "M3 15h18", key: "5xshup" }]
]);
const N1 = Me("gamepad", [
  ["line", { x1: "6", x2: "10", y1: "12", y2: "12", key: "161bw2" }],
  ["line", { x1: "8", x2: "8", y1: "10", y2: "14", key: "1i6ji0" }],
  ["line", { x1: "15", x2: "15.01", y1: "13", y2: "13", key: "dqpgro" }],
  ["line", { x1: "18", x2: "18.01", y1: "11", y2: "11", key: "meh2c" }],
  ["rect", { width: "20", height: "12", x: "2", y: "6", rx: "2", key: "9lu3g6" }]
]);
const F1 = Me("plug-zap", [
  [
    "path",
    { d: "M6.3 20.3a2.4 2.4 0 0 0 3.4 0L12 18l-6-6-2.3 2.3a2.4 2.4 0 0 0 0 3.4Z", key: "goz73y" }
  ],
  ["path", { d: "m2 22 3-3", key: "19mgm9" }],
  ["path", { d: "M7.5 13.5 10 11", key: "7xgeeb" }],
  ["path", { d: "M10.5 16.5 13 14", key: "10btkg" }],
  ["path", { d: "m18 3-4 4h6l-4 4", key: "16psg9" }]
]);
const M1 = Me("wifi", [
  ["path", { d: "M12 20h.01", key: "zekei9" }],
  ["path", { d: "M2 8.82a15 15 0 0 1 20 0", key: "dnpr2z" }],
  ["path", { d: "M5 12.859a10 10 0 0 1 14 0", key: "1x1e6c" }],
  ["path", { d: "M8.5 16.429a5 5 0 0 1 7 0", key: "1bycff" }]
]);
const Tp = Me("binary", [
  ["rect", { x: "14", y: "14", width: "4", height: "6", rx: "2", key: "p02svl" }],
  ["rect", { x: "6", y: "4", width: "4", height: "6", rx: "2", key: "xm4xkj" }],
  ["path", { d: "M6 20h4", key: "1i6q5t" }],
  ["path", { d: "M14 10h4", key: "ru81e7" }],
  ["path", { d: "M6 14h2v6", key: "16z9wg" }],
  ["path", { d: "M14 4h2v6", key: "1idq9u" }]
]);
const k1 = Me("layout-grid", [
  ["rect", { width: "7", height: "7", x: "3", y: "3", rx: "1", key: "1g98yp" }],
  ["rect", { width: "7", height: "7", x: "14", y: "3", rx: "1", key: "6d4xhi" }],
  ["rect", { width: "7", height: "7", x: "14", y: "14", rx: "1", key: "nxv5o0" }],
  ["rect", { width: "7", height: "7", x: "3", y: "14", rx: "1", key: "1bb6yr" }]
]);
const V1 = Me("columns-2", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M12 3v18", key: "108xh3" }]
]);
const B1 = Me("app-window", [
  ["rect", { x: "2", y: "4", width: "20", height: "16", rx: "2", key: "izxlao" }],
  ["path", { d: "M10 4v4", key: "pp8u80" }],
  ["path", { d: "M2 8h20", key: "d11cs7" }],
  ["path", { d: "M6 4v4", key: "1svtjw" }]
]);
const Z1 = Me("map-pin", [
  [
    "path",
    {
      d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
      key: "1r0f0z"
    }
  ],
  ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]
]);
const U1 = Me("plug", [
  ["path", { d: "M12 22v-5", key: "1ega77" }],
  ["path", { d: "M9 8V2", key: "14iosj" }],
  ["path", { d: "M15 8V2", key: "18g5xt" }],
  ["path", { d: "M18 8v5a4 4 0 0 1-4 4h-4a4 4 0 0 1-4-4V8Z", key: "osxo6l" }]
]), Bm = {
  AccessControl: Xo,
  AccessPoint: U1,
  Address: Z1,
  AllocationRole: Sp,
  AllocationRoleRef: hp,
  AnalogueWiringParameters: Go,
  AnalogueWiringParametersRef: Go,
  Application: B1,
  ApplicationSclRef: Js,
  Association: Lp,
  Authentication: bp,
  BDA: na,
  Bay: V1,
  BayType: k1,
  BehaviorDescription: _r,
  BehaviorDescriptionRef: _r,
  BehaviorReference: xi,
  BinaryWiringParameters: Tp,
  BinaryWiringParametersRef: Tp,
  BitRate: Wo,
  CheckoutID: gp,
  ClientLN: pp,
  ClientServices: Yo,
  CommProt: ea,
  Communication: M1,
  CommunicationServiceSpecifications: Er,
  ConductingEquipment: zo,
  ConfDataSet: ai,
  ConfLNs: ai,
  ConfLdName: ai,
  ConfLogControl: ai,
  ConfReportControl: ai,
  ConfSG: ai,
  ConfSigRef: ai,
  ConnectedAP: F1,
  ConnectivityNode: nm,
  ControlRef: Oa,
  ControllingLNode: N1,
  DA: na,
  DAI: na,
  DAS: na,
  DAType: ec,
  DO: Fr,
  DOI: Fr,
  DOS: Fr,
  DOType: ec,
  DataObjectDirectory: wp,
  DataSet: _1,
  DataSetDirectory: Qo,
  DataTypeTemplates: E1,
  DynAssociation: Ip,
  DynDataSet: R1,
  EnumType: yp,
  EnumVal: A1,
  EqFunction: Cp,
  EqSubFunction: Ys,
  ExtCtrl: Js,
  ExtRef: Mr,
  FCDA: na,
  FileHandling: Dp,
  Function: Cp,
  FunctionCatRef: Ju,
  FunctionCategory: Ju,
  FunctionCategoryRef: Ju,
  FunctionRef: xi,
  FunctionRole: Sp,
  FunctionRoleContent: Ho,
  FunctionSclRef: Js,
  FunctionTemplate: _r,
  FunctionalSubVariant: nm,
  FunctionalVariant: q1,
  FunctionalVariantGroup: xp,
  FunctionalVariantRef: xi,
  GOOSE: Nr,
  GOOSEMcSecurity: Xo,
  GOOSESecurity: ea,
  GSE: Nr,
  GSEControl: Oa,
  GSEDir: wp,
  GSESettings: ai,
  GSSE: Nr,
  GeneralEquipment: Xs,
  GetCBValues: Qs,
  GetDataObjectDefinition: Qs,
  GetDataSetValue: Qs,
  GetDirectory: Qo,
  GooseParameters: Ru,
  GooseParametersRef: Ru,
  Header: P1,
  History: T1,
  Hitem: Rr,
  IED: Xs,
  IEDName: Ju,
  IEDSourceFiles: $o,
  InputVar: em,
  InputVarRef: Mr,
  Inputs: em,
  IssuerName: Ho,
  KDC: bp,
  L2CommParameters: Er,
  L3IPv4CommParameters: Op,
  L3IPv6CommParameters: Op,
  LDevice: C1,
  LN: Fr,
  LN0: Ys,
  LNode: nm,
  LNodeDataRef: xi,
  LNodeInputRef: Mr,
  LNodeInputs: em,
  LNodeOutputRef: Mr,
  LNodeOutputs: Jo,
  LNodeSpecNaming: Ju,
  LNodeType: ec,
  Label: Ju,
  Labels: S1,
  Line: w1,
  Log: _r,
  LogControl: Oa,
  LogParameters: Ru,
  LogParametersRef: Ru,
  LogSettings: ai,
  MaxTime: Rr,
  McSecurity: ea,
  MinRequestedSCDFile: Dp,
  MinRequestedSCDFiles: $o,
  MinTime: Rr,
  MultiAPPerSubNet: Er,
  NeutralPoint: Ys,
  OptFields: vp,
  OutputVar: Jo,
  OutputVarRef: Mr,
  Outputs: Jo,
  P: fp,
  PhysConn: b1,
  PowerSystemRelation: Lp,
  PowerSystemRelationRef: xi,
  PowerSystemRelations: Ip,
  PowerTransformer: O1,
  Private: D1,
  Process: L1,
  ProcessEcho: I1,
  ProcessResource: Xs,
  ProcessResourceRef: xi,
  ProcessResources: ec,
  Project: Qo,
  ProjectProcessReference: xi,
  ProtNs: ea,
  Protocol: Er,
  ReadWrite: jo,
  RedProt: y1,
  ReportControl: Oa,
  ReportParameters: Ru,
  ReportParametersRef: Ru,
  ReportSettings: ai,
  Resource: x1,
  RptEnabled: dp,
  SCL: v1,
  SCSM: ea,
  SDI: na,
  SDO: Fr,
  SDS: na,
  SGEdit: jo,
  SMV: Nr,
  SMVParameters: Ru,
  SMVParametersRef: Ru,
  SMVSecurity: ea,
  SMVSettings: ai,
  SMVsc: Nr,
  SVMcSecurity: Xo,
  SampledValueControl: Oa,
  SamplesPerSec: Wo,
  SclFileReference: Js,
  SecPerSamples: Rr,
  Security: ea,
  Server: Yo,
  ServerAt: Yo,
  ServiceSpecifications: yp,
  Services: g1,
  SetDataSetValue: Qs,
  SettingControl: Oa,
  SettingGroups: xp,
  SignalRole: h1,
  SmpRate: Wo,
  SmvOpts: vp,
  SourceFiles: $o,
  SourceRef: xi,
  SubCategory: Ju,
  SubCheckoutID: gp,
  SubEquipment: Xs,
  SubFunction: Ys,
  SubFunctionTemplate: _r,
  SubNetwork: Er,
  Subject: Ho,
  SubscriberLNode: hp,
  Substation: p1,
  SupSubscription: pp,
  TapChanger: dp,
  Terminal: d1,
  Text: fp,
  TimeSyncProt: Rr,
  TimerActivatedControl: f1,
  TransformerWinding: m1,
  TrgOps: zo,
  Val: o1,
  ValueHandling: jo,
  Variable: c1,
  VariableApplyTo: xi,
  VariableRef: xi,
  Voltage: zo,
  VoltageLevel: Go
}, K1 = { class: "list-row items-center" }, G1 = { class: "avatar avatar-placeholder hidden sm:block" }, z1 = { class: "flex gap-2 mt-2" }, j1 = { class: "mt-10" }, H1 = {
  key: 0,
  role: "alert",
  class: "alert alert-error alert-soft mt-10"
}, $1 = { class: "modal-action" }, W1 = ["disabled"], Y1 = /* @__PURE__ */ dn({
  __name: "mapping-metrics",
  setup(e) {
    const l = qs(), i = Cs(), { metrics: a } = Lt(l), s = Re(() => {
      const d = a.value.LNodeSpecNaming.total === a.value.LNodeSpecNaming.perfectMatches.length, h = a.value.LNode.total === a.value.LNode.perfectMatches.length;
      return d && h;
    });
    async function o() {
      await l.applyMapping();
    }
    function m(d) {
      return d.total === d.perfectMatches.length;
    }
    return (d, h) => (We(), Yn(Mn, null, [
      (We(!0), Yn(Mn, null, Is(le(a), (x, y) => (We(), Yn("ul", {
        key: y,
        class: "list"
      }, [
        fn("li", K1, [
          fn("div", G1, [
            fn("div", {
              class: Bl(["w-12 rounded-full", {
                "bg-base-300 text-base-content": m(x),
                "bg-red-100 bg-soft text-error": !m(x)
              }])
            }, [
              (We(), vn(ys(le(Bm)[y]), { class: "size-6" }))
            ], 2)
          ]),
          fn("div", null, [
            fn("span", {
              class: Bl(["font-bold", {
                "text-error": !m(x)
              }])
            }, Ul(y) + " matches: ", 3),
            fn("div", z1, [
              fn("span", {
                class: Bl(["badge badge-neutral w-max", {
                  "badge-soft": m(x),
                  "text-neutral-content": !m(x)
                }])
              }, " Total: " + Ul(x.total), 3),
              fn("span", {
                class: Bl(["badge badge-primary w-max", {
                  "text-primary-content": m(x),
                  "badge-soft": !m(x)
                }])
              }, " Perfect: " + Ul(x.perfectMatches.length), 3),
              fn("span", {
                class: Bl(["badge badge-warning w-max", {
                  "text-warning-content": !m(x) && x.manualMatches.length,
                  "badge-soft": m(x) || !x.manualMatches.length
                }])
              }, " Manual: " + Ul(x.manualMatches.length), 3),
              fn("span", {
                class: Bl(["badge badge-error w-max", {
                  "text-error-content": !m(x) && x.noMatches.length,
                  "badge-soft": m(x) || !x.noMatches.length
                }])
              }, " None: " + Ul(x.noMatches.length), 3)
            ])
          ])
        ])
      ]))), 128)),
      fn("footer", j1, [
        h[2] || (h[2] = fn("span", null, "Do you want to proceed with the mapping?", -1)),
        s.value ? pi("", !0) : (We(), Yn("div", H1, [
          je(le(kv)),
          h[1] || (h[1] = fn("span", null, "Only perfect matches on LNodeSpecNaming and LNode/LN are supported for now.", -1))
        ])),
        fn("div", $1, [
          fn("button", {
            class: "btn-no",
            onClick: h[0] || (h[0] = //@ts-ignore
            (...x) => le(i).handleClose && le(i).handleClose(...x))
          }, "No"),
          fn("button", {
            class: "btn-yes",
            onClick: o,
            disabled: !s.value
          }, "Yes", 8, W1)
        ])
      ])
    ], 64));
  }
}), X1 = /* @__PURE__ */ va(Y1, [["__scopeId", "data-v-6ff5041e"]]), Q1 = { key: 0 }, J1 = { key: 1 }, eC = { key: "loader" }, nC = /* @__PURE__ */ dn({
  __name: "mapping-validation-dialog",
  setup(e) {
    const l = qs(), { isLoading: i, error: a } = Lt(l);
    return (s, o) => (We(), Yn(Mn, null, [
      o[0] || (o[0] = fn("h1", { class: "text-2xl font-black mb-5" }, "Mapping Validation", -1)),
      je(rg, {
        name: "fade-slide",
        mode: "out-in"
      }, {
        default: ln(() => [
          !le(i) && le(a) ? (We(), Yn("div", Q1, [
            je(MS)
          ])) : !le(i) && !le(a) ? (We(), Yn("div", J1, [
            je(X1)
          ])) : (We(), Yn("div", eC, [
            je(jS)
          ]))
        ]),
        _: 1
      })
    ], 64));
  }
}), lC = /* @__PURE__ */ va(nC, [["__scopeId", "data-v-d327a7a1"]]), qs = /* @__PURE__ */ to("s-ied-implementation/mapping", () => {
  const e = Os(), { sdkInstance: l } = Lt(e), i = vo(), { icdSdkInstance: a, selectedSied: s, selectedSiedName: o } = Lt(i), m = Td({
    LNodeSpecNaming: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    LNode: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    DO: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    DA: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    SourceRef: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    ControlRef: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    }
  }), d = Fe([]), h = Fe(!1), x = Fe(null), y = Td({
    current: 0,
    total: 0,
    message: "Building...",
    scope: void 0
  });
  function I(U) {
    const { current: z, total: X, message: B, scope: K } = U;
    y.value = {
      current: z,
      total: X,
      message: `${B} (${z} / ${X})`,
      scope: K
    };
  }
  async function q() {
    if (!l.value || !a.value)
      throw new Error("SDK instance is not initialized");
    const U = Cs();
    m.reset(), m.value = await A({
      sdkInstance: l.value,
      icdSdkInstance: a.value,
      selectedSied: s.value
    }), U.setCurrentDialog({
      component: lC,
      props: {},
      isLoading: Re(() => h.value)
    });
  }
  async function A(U) {
    const { sdkInstance: z, icdSdkInstance: X, selectedSied: B } = U;
    Au(B);
    const K = (await z.api.fromRoot().getChildren({
      filter: {
        pick: ["LNode", "LNodeSpecNaming", "SourceRef", "ControlRef"]
      }
    })).treeChildren, W = (await X.api.fromRoot().getChildren({
      filter: {
        pick: ["LN", "LNode", "LNodeSpecNaming", "SourceRef", "ControlRef"]
      }
    })).treeChildren, { LNode: se = [] } = z.utils.groupRecordsByTagName(K), { LN: te = [], LNode: me = [] } = X.utils.groupRecordsByTagName(W), M = await R({
      sdkInstance: z,
      icdSdkInstance: X,
      localLnodes: se,
      icdLns: te,
      icdLnodes: me
    });
    return {
      LNodeSpecNaming: M.lNodeSpecNamingMetrics,
      LNode: M.lNodeToLnMetrics,
      DO: M.doMetrics,
      DA: M.daMetrics,
      SourceRef: M.sourceRefMetrics,
      ControlRef: M.controlRefMetrics
    };
  }
  async function R(U) {
    const { sdkInstance: z, icdSdkInstance: X, localLnodes: B, icdLns: K, icdLnodes: W } = U, {
      SourceRef: se = [],
      ControlRef: te = [],
      LNodeSpecNaming: me = []
    } = X.utils.groupRecordsByTagName(W.flatMap((De) => De.treeChildren)), M = Ws({
      sdkInstance: z,
      records: me,
      keyAttributes: ["sLdInst", "sPrefix", "sLnClass", "sLnInst"]
    }), ce = Ws({
      sdkInstance: z,
      records: K,
      keyAttributes: ["prefix", "lnClass", "inst"]
    }), Ie = Ws({
      sdkInstance: z,
      records: se,
      keyAttributes: ["input", "inputInst", "pDA"]
    }), ae = Ws({
      sdkInstance: z,
      records: te,
      keyAttributes: ["output", "outputInst"]
    }), ve = [], ye = [], Se = [], ge = [], oe = [], de = [];
    for (const De of B) {
      if (!(z.utils.getAttributeValueByName({
        attributes: De.attributes,
        name: "iedName"
      }) === o.value)) continue;
      const ze = Ts({
        attributes: z.utils.getAttributesValuesByName({
          attributes: De.attributes
        }),
        keys: ["prefix", "lnClass", "lnInst"]
      }), un = ze ? ce.get(ze) : void 0, Pn = IS({
        sdkInstance: z,
        localLnode: De,
        icdLNodeSpecNamingMap: M
      });
      Pn && ve.push(Pn);
      const xn = LS({
        localLnode: De,
        matchingIcdLn: un
      });
      ye.push(xn);
      const k = (await z.api.fromElement({ tagName: "LNode", id: De.id }).resolveDataModel().getContext()).currentFocus, _ = z.utils.toDataModelRecords({
        version: Tc,
        records: k.treeChildren
      });
      if (Au(
        _.length > 0,
        `Local LNode with id ${De.id} has no resolved data model`
      ), un) {
        const Oe = (await X.api.fromElement({ tagName: "LN", id: un.id }).resolveDataModel().getContext()).currentFocus, j = X.utils.toDataModelRecords({
          version: Tc,
          records: Oe.treeChildren
        });
        if (!j.length)
          throw new Error(`ICD LN with id ${un.id} has no resolved data model`);
        d.value.push(...j);
        const { doMetrics: ue, daMetrics: fe } = bS({
          sdkInstance: z,
          localDataModel: _,
          icdDataModel: j
        });
        Se.push(ue), ge.push(fe);
      } else {
        const { doMetrics: Qe, daMetrics: Oe } = SS({
          sdkInstance: z,
          localDataModel: _
        });
        Se.push(Qe), ge.push(Oe);
        continue;
      }
      const Z = DS({
        sdkInstance: z,
        localLnode: De,
        icdSourceRefMap: Ie
      });
      oe.push(...Z);
      const ie = OS({
        sdkInstance: z,
        localLnode: De,
        icdControlRefMap: ae
      });
      de.push(...ie);
    }
    return {
      lNodeSpecNamingMetrics: Da(ve),
      lNodeToLnMetrics: Da(ye),
      doMetrics: Da(Se),
      daMetrics: Da(ge),
      sourceRefMetrics: Da(oe),
      controlRefMetrics: Da(de)
    };
  }
  async function V() {
    try {
      h.value = !0, x.value = null, y.reset(), Au(l.value, "Local SDK instance is not initialized"), Au(a.value, "ICD SDK instance is not initialized"), Au(s.value, "Selected SIED is not initialized");
      let U = l.value.api.fromRoot({
        onProgress: ({ current: me, total: M, message: ce, scope: Ie }) => I({
          current: me,
          total: M,
          message: `${ce}`,
          scope: Ie
        })
      });
      if (!(m.value.LNodeSpecNaming.total === m.value.LNodeSpecNaming.perfectMatches.length)) {
        x.value = "LNodeSpecNaming has unmatched items - not supported yet";
        return;
      }
      for (const me of m.value.LNode.perfectMatches) {
        const { local: M, icd: ce } = me;
        Au(ce.parent, "ICD LN has no parent LDevice");
        const Ie = await a.value.api.getElement({
          tagName: "LDevice",
          id: ce.parent.id
        });
        if (!Ie) throw new Error("ICD LDevice not found");
        const ae = a.value.utils.getAttributeValueByName({
          attributes: Ie.attributes,
          name: "inst"
        }), ve = a.value.utils.getAttributesValuesByName({
          attributes: ce.attributes
        });
        U = U.goToElement({
          tagName: "LNode",
          id: M.id
        }).update({
          attributes: [
            { name: "ldInst", value: ae },
            { name: "lnClass", value: ve.lnClass },
            { name: "prefix", value: ve.prefix },
            { name: "lnInst", value: ve.inst }
          ]
        }).goToElement({ tagName: "SCL" });
      }
      for (const me of m.value.SourceRef.perfectMatches) {
        const { local: M, icd: ce } = me;
        U = U.goToElement({
          tagName: "SourceRef",
          id: M.id
        }).update({
          attributes: [
            {
              name: "extRefAddr",
              value: ce.attributes.find((Ie) => Ie.name === "extRefAddr")?.value
            }
            // will be implemente later
            // {
            // 	name: 'extRefUuid',
            // 	value: icd.attributes.find((a) => a.name === 'extRefUuid')?.value,
            // },
          ]
        }).goToElement({ tagName: "SCL" });
      }
      for (const me of m.value.ControlRef.perfectMatches) {
        const { local: M, icd: ce } = me;
        U = U.goToElement({
          tagName: "ControlRef",
          id: M.id
        }).update({
          attributes: [
            {
              name: "extCtrlAddr",
              value: ce.attributes.find((Ie) => Ie.name === "extCtrlAddr")?.value
            }
            // wil be implemented later
            // {
            // 	name: 'extCtrlUuid',
            // 	value: icd.attributes.find((a) => a.name === 'extCtrlUuid')?.value,
            // },
          ]
        }).goToElement({ tagName: "SCL" });
      }
      const { IED: X = [] } = await a.value.api.fromRoot().getChildren({
        withPrivate: !0,
        // we clone the element with its Private content
        filter: { pick: [{ tagName: "IED", withAllDescendants: !0 }] },
        flatten: !0
      }), B = X[0];
      Au(B, "ICD should have one IED to clone");
      const { SubNetwork: K = [], ConnectedAP: W = [] } = await l.value.api.fromElement({ tagName: "Communication" }).getChildren({
        filter: {
          pick: [
            {
              tagName: "SubNetwork",
              attributes: { name: "Default_Subnet" },
              pick: [{ tagName: "ConnectedAP", attributes: { iedName: o.value } }]
            }
          ]
        },
        flatten: !0
      }), se = K?.[0]?.id;
      Au(se, "Default_Subnet SubNetwork not found in Communication");
      for (const me of W)
        U = U.goToElement({ tagName: "ConnectedAP", id: me.id }).delete().goToElement({ tagName: "SCL" });
      await U.deepCloneChild({
        record: B,
        setFocus: !0
      }).update({
        attributes: [
          {
            name: "name",
            value: o.value
          }
        ]
      }).attachAllAccessPointToSubNetwork({ subnetworkId: se }).goToElement({
        tagName: "DataTypeTemplates"
      }).addToDataModel({
        dataModel: d.value
      }).goToElement({
        tagName: "IED",
        id: s.value.id
      }).delete().commit(), i.resetSelection();
    } catch (U) {
      throw h.value = !1, x.value = U instanceof Error ? U.message : String(U), console.error("Error during applyMapping:", U), U;
    }
  }
  return {
    // states
    metrics: m,
    icdLnodeTypes: d,
    isLoading: h,
    error: x,
    progress: y,
    // actions
    openDialogToValidateMapping: q,
    gatherMetrics: A,
    calculateLNodeNestedMetrics: R,
    applyMapping: V
  };
});
function tC(e) {
  return $i() ? (ma(e), !0) : !1;
}
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
function iC(e, l) {
  const i = Fe(void 0), a = e.subscribe({
    next: (s) => i.value = s,
    error: void 0
  });
  return tC(() => {
    a.unsubscribe();
  }), i;
}
const uC = { class: "pl-2" }, aC = /* @__PURE__ */ dn({
  __name: "element-tree",
  setup(e) {
    const l = Os(), i = vo(), { sdkInstance: a } = Lt(l), { selectedLnodeId: s } = Lt(i), o = TD(async () => {
      if (!a.value) return [];
      const h = await a.value.api.fromRoot().getChildren({
        filter: {
          pick: ["Substation", "VoltageLevel", "Bay", "Function", "SubFunction", "LNode"]
        }
      });
      function x(y) {
        return {
          tag: y.tagName,
          id: y.id,
          ...y.treeChildren.length && {
            children: y.treeChildren.map((I) => x(I))
          }
        };
      }
      return [x(h)];
    }), m = Re(() => o.value?.find((h) => h.tag === "SCL")?.id);
    function d(h) {
      h.value.tag === "LNode" && (s.value = h.value.id);
    }
    return (h, x) => m.value ? (We(), vn(le(bw), {
      key: 0,
      class: "list-none select-none w-full text-stone-700 p-2 text-sm font-medium",
      items: le(o),
      "get-key": (y) => y.id,
      "default-expanded": [m.value],
      "propagate-select": ""
    }, {
      default: ln(({ flattenItems: y }) => [
        (We(!0), Yn(Mn, null, Is(y, (I) => (We(), vn(le(Tw), pl({
          key: I.value.id,
          style: { "padding-left": `${I.level - 0.5}rem` }
        }, { ref_for: !0 }, I.bind, {
          class: "flex items-center py-1 px-2 my-0.5 rounded outline-none focus:ring-primary focus:ring-2 data-[selected]:bg-primary/20",
          onSelect: (q) => d(I)
        }), {
          default: ln(() => [
            le(Bm)[I.value.tag] ? (We(), vn(ys(le(Bm)[I.value.tag]), {
              key: 0,
              class: "h-4 w-4"
            })) : pi("", !0),
            fn("div", uC, Ul(I.value.tag), 1)
          ]),
          _: 2
        }, 1040, ["style", "onSelect"]))), 128))
      ]),
      _: 1
    }, 8, ["items", "get-key", "default-expanded"])) : pi("", !0);
  }
}), rC = { class: "h-full overflow-auto" }, sC = { class: "p-2 space-y-5" }, cC = { class: "flex items-center text-sm font-medium" }, oC = { class: "flex items-center justify-between text-sm font-medium" }, mC = { class: "flex gap-2" }, fC = {
  class: "btn btn-primary text-primary-content flex-2/3",
  type: "submit"
}, dC = { class: "pb-20" }, pC = /* @__PURE__ */ dn({
  __name: "custom-sidebar",
  setup(e) {
    const l = Os(), i = vo(), a = qs(), { sdkInstance: s } = Lt(l), { selectedSied: o } = Lt(i), m = ef("icdInputRef"), d = yS(() => s.value ? s.value.database.sclElements.where("tagName").equals("IED").toArray() : []), h = iC(d), x = Re(() => h.value ? h.value?.filter(
      (q) => q.attributes.some(
        (A) => A.name === "manufacturer" && A.value === "S_IED"
      )
    ) || [] : []);
    function y(I) {
      return I?.attributes.find((q) => q.name === "name")?.value || "";
    }
    return vl(() => {
      m.value && (i.setupFileDialog(m.value), i.loadIcdFileInMemory(m.value));
    }), Dt(() => {
      i.resetSelection();
    }), (I, q) => (We(), Yn("aside", rC, [
      fn("form", {
        class: "sticky top-0 bg-base-100 pb-2",
        method: "dialog",
        onSubmit: q[3] || (q[3] = si(
          //@ts-ignore
          (...A) => le(a).openDialogToValidateMapping && le(a).openDialogToValidateMapping(...A),
          ["stop"]
        ))
      }, [
        fn("div", sC, [
          fn("div", cC, [
            q[4] || (q[4] = fn("label", {
              class: "min-w-fit mr-5",
              for: "selected-ied-name"
            }, "S-IED Name", -1)),
            je(le(Tb), {
              class: "dropdown w-full",
              modelValue: le(o),
              "onUpdate:modelValue": q[0] || (q[0] = (A) => Vn(o) ? o.value = A : null)
            }, {
              default: ln(() => [
                je(le(ob), { class: "combobox-anchor" }, {
                  default: ln(() => [
                    je(le(kb), {
                      required: "",
                      id: "selected-ied-name",
                      name: "selectedIedName",
                      class: "input-ghost outline-none",
                      placeholder: "Search by name...",
                      "display-value": (A) => y(A)
                    }, null, 8, ["display-value"]),
                    je(le(Gb), null, {
                      default: ln(() => [
                        je(le(AS), { class: "h-4 w-4 text-primary cursor-pointer" })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                je(le(Eb), { class: "dropdown-content mt-2 bg-base-100 rounded-box w-full shadow-sm" }, {
                  default: ln(() => [
                    je(le(jb), { class: "p-[5px]" }, {
                      default: ln(() => [
                        je(le(Nb), { class: "text-base-content text-xs font-medium text-center py-2" }),
                        (We(!0), Yn(Mn, null, Is(x.value, (A) => (We(), vn(le(Bb), {
                          key: A.id,
                          value: A,
                          class: "combobox-item"
                        }, {
                          default: ln(() => [
                            je(le(Ub), { class: "absolute left-0 w-[25px] inline-flex items-center justify-center" }, {
                              default: ln(() => [
                                je(le(sp), { class: "h-3 w-3" })
                              ]),
                              _: 1
                            }),
                            fn("span", null, Ul(y(A)), 1)
                          ]),
                          _: 2
                        }, 1032, ["value"]))), 128))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["modelValue"])
          ]),
          fn("div", oC, [
            q[5] || (q[5] = fn("label", {
              class: "min-w-fit mr-5",
              for: "selected-icd-file"
            }, "ICD", -1)),
            fn("input", {
              required: "",
              id: "selected-icd-file",
              name: "selectedIcdFile",
              ref_key: "icdInputRef",
              ref: m,
              type: "file",
              class: "file-input file-input-primary w-full",
              onClick: q[1] || (q[1] = (A) => le(i).importIcdFile())
            }, null, 512)
          ]),
          fn("div", mC, [
            fn("button", {
              class: "btn-remove-reset",
              type: "reset",
              onClick: q[2] || (q[2] = //@ts-ignore
              (...A) => le(i).resetSelection && le(i).resetSelection(...A))
            }, [
              je(le(RS), { class: "h-4 w-4" }),
              q[6] || (q[6] = Gi(" Reset ", -1))
            ]),
            fn("button", fC, [
              je(le(sp), { class: "h-4 w-4" }),
              q[7] || (q[7] = Gi(" Validate mapping ", -1))
            ])
          ])
        ]),
        q[8] || (q[8] = fn("div", { class: "border-b mt-2" }, null, -1))
      ], 32),
      fn("div", dC, [
        je(aC)
      ])
    ]));
  }
}), hC = /* @__PURE__ */ va(pC, [["__scopeId", "data-v-ee976485"]]), gC = { class: "flex flex-col gap-2 p-4" }, vC = /* @__PURE__ */ dn({
  __name: "main-area",
  setup(e) {
    const l = vo(), { selectedLnodeId: i, selectedSiedName: a, currentActiveIcdDatabaseName: s } = Lt(l), o = Re(() => s.value || "None"), m = Re(() => i.value || "None");
    return (d, h) => (We(), Yn("div", gC, [
      fn("span", {
        class: Bl(le(a) === "None" ? "text-error" : "")
      }, " Selected S-IED: " + Ul(le(a)), 3),
      fn("span", {
        class: Bl(o.value === "None" ? "text-error" : "")
      }, " Selected ICD: " + Ul(o.value), 3),
      fn("span", {
        class: Bl(m.value === "None" ? "text-error" : "")
      }, " Selected LNode: " + Ul(m.value), 3)
    ]));
  }
}), xC = { class: "modal-box max-w-136" }, yC = ["disabled"], IC = /* @__PURE__ */ dn({
  __name: "dialog-container",
  setup(e) {
    const l = Cs(), { currentDialog: i } = Lt(l), a = ef("dialogRef");
    return vl(() => {
      a.value && (l.dialogRef = a.value);
    }), (s, o) => (We(), Yn("dialog", {
      class: "modal",
      ref: "dialogRef",
      onCancel: o[1] || (o[1] = (m) => le(i).isLoading?.value ? m.preventDefault() : null)
    }, [
      fn("div", xC, [
        fn("button", {
          class: "dialog-button",
          onClick: o[0] || (o[0] = //@ts-ignore
          (...m) => le(l).handleClose && le(l).handleClose(...m)),
          disabled: le(i).isLoading?.value
        }, [
          je(le(ES), { class: "h-4 w-4" })
        ], 8, yC),
        le(i).component ? (We(), vn(ys(le(i).component), Vc(pl({ key: 0 }, le(i).props)), null, 16)) : pi("", !0)
      ])
    ], 544));
  }
}), LC = /* @__PURE__ */ va(IC, [["__scopeId", "data-v-0ea1d8af"]]), DC = /* @__PURE__ */ dn({
  __name: "app",
  props: {
    api: {}
  },
  setup(e) {
    const l = e, i = Os(), a = Fe();
    return vl(() => {
      a.value = l.api.activeFileName.subscribe(
        (s) => {
          s && i.initApp(s);
        }
      ), l.api.activeFileName.value && i.initApp(l.api.activeFileName.value);
    }), Dt(() => {
      a.value?.();
    }), (s, o) => (We(), Yn(Mn, null, [
      je(Rw, null, {
        "primary-sidebar": ln(() => [
          je(hC)
        ]),
        "main-area": ln(() => [
          je(vC)
        ]),
        _: 1
      }),
      je(LC)
    ], 64));
  }
});
function iT(e, l) {
  if (!document.getElementById(e)) {
    console.error({ msg: "could not found root element", rootId: e });
    return;
  }
  const a = Sc(DC, { api: l });
  return a.use(fL()), a.mount(`#${e}`), a.unmount;
}
export {
  iT as default
};
