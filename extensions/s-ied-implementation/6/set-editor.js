(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode(`.layout[data-v-30346480]{display:grid;height:100vh;grid-template-rows:auto 1fr;grid-template-columns:4rem 1fr}.menubar[data-v-30346480]{grid-column-start:1;grid-column-end:5}.activity-bar[data-v-30346480]{padding:.5rem}@layer daisyui.component{:where(.btn-close[data-v-dadc7e4b]){width:unset}.btn-close[data-v-dadc7e4b]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-close[data-v-dadc7e4b]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-close[data-v-dadc7e4b]{--btn-noise:var(--fx-noise)}.prose .btn-close[data-v-dadc7e4b]{text-decoration-line:none}@media (hover:hover){.btn-close[data-v-dadc7e4b]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-close[data-v-dadc7e4b]:focus-visible,.btn-close[data-v-dadc7e4b]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-close[data-v-dadc7e4b]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-close[data-v-dadc7e4b]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-close[data-v-dadc7e4b]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-close[data-v-dadc7e4b]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-close[data-v-dadc7e4b]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-close[data-v-dadc7e4b]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}}@layer daisyui.modifier{.btn-close[data-v-dadc7e4b]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-close[data-v-dadc7e4b]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-close[data-v-dadc7e4b]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-close[data-v-dadc7e4b]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-close[data-v-dadc7e4b]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-dadc7e4b]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-close[disabled][data-v-dadc7e4b]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-dadc7e4b]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-close[disabled][data-v-dadc7e4b]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-close[disabled][data-v-dadc7e4b]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-dadc7e4b]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-close[disabled][data-v-dadc7e4b]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-dadc7e4b]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-close[disabled][data-v-dadc7e4b]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-dadc7e4b]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-close[data-v-dadc7e4b]{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}}@layer daisyui.component{:where(.btn-close[data-v-154446ae]){width:unset}.btn-close[data-v-154446ae]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-154446ae]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-close[data-v-154446ae]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-154446ae]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-close[data-v-154446ae]{--btn-noise:var(--fx-noise)}.prose .btn-close[data-v-154446ae]{text-decoration-line:none}@media (hover:hover){.btn-close[data-v-154446ae]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-154446ae]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-close[data-v-154446ae]:focus-visible,.btn-close[data-v-154446ae]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-close[data-v-154446ae]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-154446ae]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-close[data-v-154446ae]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-154446ae]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-close[data-v-154446ae]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-close[data-v-154446ae]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-close[data-v-154446ae]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-close[data-v-154446ae]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}}@layer daisyui.modifier{.btn-close[data-v-154446ae]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-154446ae]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-close[data-v-154446ae]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-close[data-v-154446ae]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-154446ae]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-close[data-v-154446ae]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-154446ae]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-close[data-v-154446ae]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[data-v-154446ae]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-close[disabled][data-v-154446ae]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-154446ae]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-close[disabled][data-v-154446ae]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-close[disabled][data-v-154446ae]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-154446ae]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-close[disabled][data-v-154446ae]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-154446ae]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-close[disabled][data-v-154446ae]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-close[disabled][data-v-154446ae]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-close[data-v-154446ae]{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}}@layer daisyui.component{:where(.btn-no[data-v-6ff5041e]){width:unset}.btn-no[data-v-6ff5041e]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-no[data-v-6ff5041e]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-no[data-v-6ff5041e]{--btn-noise:var(--fx-noise)}.prose .btn-no[data-v-6ff5041e]{text-decoration-line:none}@media (hover:hover){.btn-no[data-v-6ff5041e]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-no[data-v-6ff5041e]:focus-visible,.btn-no[data-v-6ff5041e]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-no[data-v-6ff5041e]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-no[data-v-6ff5041e]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-no[data-v-6ff5041e]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-no[data-v-6ff5041e]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-no[data-v-6ff5041e]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-no[data-v-6ff5041e]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}:where(.btn-yes[data-v-6ff5041e]){width:unset}.btn-yes[data-v-6ff5041e]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-yes[data-v-6ff5041e]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-yes[data-v-6ff5041e]{--btn-noise:var(--fx-noise)}.prose .btn-yes[data-v-6ff5041e]{text-decoration-line:none}@media (hover:hover){.btn-yes[data-v-6ff5041e]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-yes[data-v-6ff5041e]:focus-visible,.btn-yes[data-v-6ff5041e]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-yes[data-v-6ff5041e]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-yes[data-v-6ff5041e]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-yes[data-v-6ff5041e]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-yes[data-v-6ff5041e]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-yes[data-v-6ff5041e]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-yes[data-v-6ff5041e]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}}@layer daisyui.modifier{.btn-no[data-v-6ff5041e]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-no[data-v-6ff5041e]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-no[data-v-6ff5041e]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-no[data-v-6ff5041e]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-no[data-v-6ff5041e]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-6ff5041e]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-no[disabled][data-v-6ff5041e]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[disabled][data-v-6ff5041e]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-no[disabled][data-v-6ff5041e]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-no[disabled][data-v-6ff5041e]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[disabled][data-v-6ff5041e]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-no[disabled][data-v-6ff5041e]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-no[disabled][data-v-6ff5041e]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-no[disabled][data-v-6ff5041e]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[disabled][data-v-6ff5041e]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-no[data-v-6ff5041e]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}@media (hover:none){.btn-no[data-v-6ff5041e]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}}.btn-no[data-v-6ff5041e]{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.btn-yes[data-v-6ff5041e]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-yes[data-v-6ff5041e]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-yes[data-v-6ff5041e]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-yes[data-v-6ff5041e]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-yes[data-v-6ff5041e]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-6ff5041e]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-yes[disabled][data-v-6ff5041e]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[disabled][data-v-6ff5041e]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-yes[disabled][data-v-6ff5041e]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-yes[disabled][data-v-6ff5041e]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[disabled][data-v-6ff5041e]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-yes[disabled][data-v-6ff5041e]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-yes[disabled][data-v-6ff5041e]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-yes[disabled][data-v-6ff5041e]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[disabled][data-v-6ff5041e]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-yes[data-v-6ff5041e]{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.badge-soft[data-v-6ff5041e]{color:var(--badge-color,var(--color-base-content));background-color:var(--badge-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.badge-soft[data-v-6ff5041e]{background-color:color-mix(in oklab,var(--badge-color,var(--color-base-content))8%,var(--color-base-100))}}.badge-soft[data-v-6ff5041e]{border-color:var(--badge-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.badge-soft[data-v-6ff5041e]{border-color:color-mix(in oklab,var(--badge-color,var(--color-base-content))10%,var(--color-base-100))}}.badge-soft[data-v-6ff5041e]{background-image:none}.badge-warn[data-v-6ff5041e]{--badge-color:var(--color-neutral);--badge-fg:var(--color-neutral-content)}}.fade-slide-enter-from[data-v-d327a7a1],.fade-slide-leave-to[data-v-d327a7a1]{opacity:0;transform:translateY(16px)}.fade-slide-enter-active[data-v-d327a7a1]{transition:opacity .6s ease-out,transform .6s ease-out}.fade-slide-leave-active[data-v-d327a7a1]{transition:opacity .45s ease-in,transform .45s ease-in}.fade-slide-enter-to[data-v-d327a7a1],.fade-slide-leave-from[data-v-d327a7a1]{opacity:1;transform:translateY(0)}@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){[data-v-ee976485],[data-v-ee976485]:before,[data-v-ee976485]:after,[data-v-ee976485]::backdrop{--tw-leading:initial}}}@layer daisyui.component{.combobox-anchor[data-v-ee976485]{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);font-size:max(var(--font-size,.875rem),.875rem);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.combobox-anchor[data-v-ee976485]{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.combobox-anchor[data-v-ee976485]{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.combobox-anchor[data-v-ee976485]{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.combobox-anchor[data-v-ee976485]:where(input){display:inline-flex}.combobox-anchor[data-v-ee976485] :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.combobox-anchor[data-v-ee976485] :where(input):focus,.combobox-anchor[data-v-ee976485] :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.combobox-anchor[data-v-ee976485] :where(input):focus,.combobox-anchor[data-v-ee976485] :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.combobox-anchor[data-v-ee976485] :where(input[type=url]),.combobox-anchor[data-v-ee976485] :where(input[type=email]){direction:ltr}.combobox-anchor[data-v-ee976485] :where(input[type=date]){display:inline-flex}.combobox-anchor[data-v-ee976485]:focus,.combobox-anchor[data-v-ee976485]:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.combobox-anchor[data-v-ee976485]:focus,.combobox-anchor[data-v-ee976485]:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.combobox-anchor[data-v-ee976485]:focus,.combobox-anchor[data-v-ee976485]:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}@media (pointer:coarse){@supports (-webkit-touch-callout:none){.combobox-anchor[data-v-ee976485]:focus,.combobox-anchor[data-v-ee976485]:focus-within{--font-size:1rem}}}.combobox-anchor[data-v-ee976485]:has(>input[disabled]),.combobox-anchor[data-v-ee976485]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ee976485]{cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.combobox-anchor[data-v-ee976485]:has(>input[disabled]),.combobox-anchor[data-v-ee976485]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ee976485]{color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.combobox-anchor[data-v-ee976485]:has(>input[disabled]),.combobox-anchor[data-v-ee976485]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ee976485])::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.combobox-anchor[data-v-ee976485]:has(>input[disabled]),.combobox-anchor[data-v-ee976485]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ee976485])::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.combobox-anchor[data-v-ee976485]:has(>input[disabled]),.combobox-anchor[data-v-ee976485]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ee976485]{box-shadow:none}.combobox-anchor:has(>input[disabled])>input[disabled][data-v-ee976485]{cursor:not-allowed}.combobox-anchor[data-v-ee976485]::-webkit-date-and-time-value{text-align:inherit}.combobox-anchor[type=number][data-v-ee976485]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.combobox-anchor[data-v-ee976485]::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.combobox-anchor[data-v-ee976485]:has(>input[type=date]) :where(input[type=date]){webkit-appearance:none;appearance:none;display:inline-flex}.combobox-anchor:has(>input[type=date]) input[type=date][data-v-ee976485]::-webkit-calendar-picker-indicator{cursor:pointer;width:1em;height:1em;position:absolute;inset-inline-end:.75em}:where(.btn-remove-reset[data-v-ee976485]){width:unset}.btn-remove-reset[data-v-ee976485]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-remove-reset[data-v-ee976485]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-remove-reset[data-v-ee976485]{--btn-noise:var(--fx-noise)}.prose .btn-remove-reset[data-v-ee976485]{text-decoration-line:none}@media (hover:hover){.btn-remove-reset[data-v-ee976485]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-remove-reset[data-v-ee976485]:focus-visible,.btn-remove-reset[data-v-ee976485]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-remove-reset[data-v-ee976485]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-remove-reset[data-v-ee976485]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-remove-reset[data-v-ee976485]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-remove-reset[data-v-ee976485]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-remove-reset[data-v-ee976485]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-remove-reset[data-v-ee976485]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}:where(.btn-import-icd[data-v-ee976485]){width:unset}.btn-import-icd[data-v-ee976485]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-import-icd[data-v-ee976485]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-import-icd[data-v-ee976485]{--btn-noise:var(--fx-noise)}.prose .btn-import-icd[data-v-ee976485]{text-decoration-line:none}@media (hover:hover){.btn-import-icd[data-v-ee976485]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-import-icd[data-v-ee976485]:focus-visible,.btn-import-icd[data-v-ee976485]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-import-icd[data-v-ee976485]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-import-icd[data-v-ee976485]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-import-icd[data-v-ee976485]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-import-icd[data-v-ee976485]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-import-icd[data-v-ee976485]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-import-icd[data-v-ee976485]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}}.combobox-anchor[data-v-ee976485]{width:100%}@layer daisyui.modifier{.combobox-anchor[data-v-ee976485],.combobox-anchor[data-v-ee976485]:focus,.combobox-anchor[data-v-ee976485]:focus-within{--input-color:var(--color-primary)}.btn-remove-reset[data-v-ee976485]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-remove-reset[data-v-ee976485]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-remove-reset[data-v-ee976485]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-remove-reset[data-v-ee976485]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-remove-reset[data-v-ee976485]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ee976485]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-remove-reset[disabled][data-v-ee976485]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[disabled][data-v-ee976485]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-remove-reset[disabled][data-v-ee976485]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-remove-reset[disabled][data-v-ee976485]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[disabled][data-v-ee976485]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-remove-reset[disabled][data-v-ee976485]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[disabled][data-v-ee976485]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-remove-reset[disabled][data-v-ee976485]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[disabled][data-v-ee976485]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-remove-reset[data-v-ee976485]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}@media (hover:none){.btn-remove-reset[data-v-ee976485]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}}.btn-remove-reset[data-v-ee976485]{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.btn-import-icd[data-v-ee976485]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-import-icd[data-v-ee976485]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-import-icd[data-v-ee976485]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-import-icd[data-v-ee976485]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-import-icd[data-v-ee976485]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ee976485]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-import-icd[disabled][data-v-ee976485]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[disabled][data-v-ee976485]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-import-icd[disabled][data-v-ee976485]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-import-icd[disabled][data-v-ee976485]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[disabled][data-v-ee976485]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-import-icd[disabled][data-v-ee976485]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[disabled][data-v-ee976485]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-import-icd[disabled][data-v-ee976485]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[disabled][data-v-ee976485]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-import-icd[data-v-ee976485]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}@media (hover:none){.btn-import-icd[data-v-ee976485]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}}.btn-import-icd[data-v-ee976485]{--fontsize:.75rem;--btn-p:.75rem;--size:calc(var(--size-field,.25rem)*8);--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}}.combobox-item[data-v-ee976485]{cursor:pointer;height:25px;font-size:var(--text-xs,.75rem);line-height:var(--tw-leading,var(--text-xs--line-height,calc(1/.75)));--tw-leading:1;-webkit-user-select:none;user-select:none;border-radius:3px;justify-content:space-between;align-items:center;padding-left:25px;padding-right:35px;line-height:1;display:flex;position:relative}.combobox-item[data-disabled][data-v-ee976485]{pointer-events:none;color:var(--color-base-content)}.combobox-item[data-highlighted][data-v-ee976485]{background-color:var(--color-primary);color:var(--color-primary-content);--tw-outline-style:none;outline-style:none}.btn-remove-reset[data-v-ee976485]{flex:33.3333%}@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){[data-v-0ea1d8af],[data-v-0ea1d8af]:before,[data-v-0ea1d8af]:after,[data-v-0ea1d8af]::backdrop{--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000}}}@layer daisyui.component{:where(.dialog-button[data-v-0ea1d8af]){width:unset}.dialog-button[data-v-0ea1d8af]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.dialog-button[data-v-0ea1d8af]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.dialog-button[data-v-0ea1d8af]{--btn-noise:var(--fx-noise)}.prose .dialog-button[data-v-0ea1d8af]{text-decoration-line:none}@media (hover:hover){.dialog-button[data-v-0ea1d8af]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.dialog-button[data-v-0ea1d8af]:focus-visible,.dialog-button[data-v-0ea1d8af]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.dialog-button[data-v-0ea1d8af]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.dialog-button[data-v-0ea1d8af]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.dialog-button[data-v-0ea1d8af]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.dialog-button[data-v-0ea1d8af]:is(input[type=checkbox],input[type=radio]){appearance:none}.dialog-button[data-v-0ea1d8af]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.dialog-button[data-v-0ea1d8af]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}}@layer daisyui.modifier{.dialog-button[data-v-0ea1d8af]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.dialog-button[data-v-0ea1d8af]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.dialog-button[data-v-0ea1d8af]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.dialog-button[data-v-0ea1d8af]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.dialog-button[data-v-0ea1d8af]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.dialog-button[disabled][data-v-0ea1d8af]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[disabled][data-v-0ea1d8af]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.dialog-button[disabled][data-v-0ea1d8af]:not(.btn-link,.btn-ghost){box-shadow:none}.dialog-button[disabled][data-v-0ea1d8af]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[disabled][data-v-0ea1d8af]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.dialog-button[disabled][data-v-0ea1d8af]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.dialog-button[disabled][data-v-0ea1d8af]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.dialog-button[disabled][data-v-0ea1d8af]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[disabled][data-v-0ea1d8af]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.dialog-button[data-v-0ea1d8af]{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.dialog-button[data-v-0ea1d8af]:not(.btn-active,:hover,:active:focus,:focus-visible){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none}.dialog-button[data-v-0ea1d8af]:not(.btn-active,:hover,:active:focus,:focus-visible):not(:disabled,[disabled],.btn-disabled){--btn-fg:currentColor;outline-color:currentColor}@media (hover:none){.dialog-button[data-v-0ea1d8af]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none;--btn-fg:currentColor}}.dialog-button[data-v-0ea1d8af]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-fg:var(--btn-color,var(--color-base-content));--btn-bg:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-content))8%,var(--color-base-100))}}.dialog-button[data-v-0ea1d8af]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-content))10%,var(--color-base-100))}}.dialog-button[data-v-0ea1d8af]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-noise:none}@media (hover:none){.dialog-button[data-v-0ea1d8af]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-fg:var(--btn-color,var(--color-base-content));--btn-bg:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-content))8%,var(--color-base-100))}}.dialog-button[data-v-0ea1d8af]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-0ea1d8af]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-content))10%,var(--color-base-100))}}.dialog-button[data-v-0ea1d8af]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-noise:none}}.dialog-button[data-v-0ea1d8af]{--fontsize:.75rem;--btn-p:.75rem;--size:calc(var(--size-field,.25rem)*8);--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}}.dialog-button[data-v-0ea1d8af]{top:calc(var(--spacing,.25rem)*2);right:calc(var(--spacing,.25rem)*2);--tw-shadow:0 0 #0000;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow);position:absolute}@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-y-reverse:0;--tw-border-style:solid;--tw-leading:initial;--tw-font-weight:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-100:oklch(93.6% .032 17.717);--color-stone-700:oklch(37.4% .01 67.558);--color-black:#000;--spacing:.25rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--font-weight-medium:500;--font-weight-bold:700;--font-weight-black:900;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E");scrollbar-color:currentColor #0000}@supports (color:color-mix(in lab,red,red)){:root{scrollbar-color:color-mix(in oklch,currentColor 35%,#0000)#0000}}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),oklch(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}@supports (width:if(else: 1px)) and (animation-timeline:scroll()){:root{animation:forwards set-page-has-scroll;animation-timeline:scroll()}@keyframes set-page-has-scroll{0%,to{--page-has-scroll:1}}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:if(style(--page-has-scroll: 1): stable; else: unset)}}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:where(:root),:root:has(input.theme-controller[value=ocean-light]:checked),[data-theme=ocean-light]{color-scheme:light;--color-base-100:oklch(98% 0 0);--color-base-200:oklch(97% 0 0);--color-base-300:oklch(92% 0 0);--color-base-content:oklch(37% 0 0);--color-primary:oklch(58.13% .0903 209.8);--color-primary-content:oklch(100% 0 0);--color-secondary:oklch(65.24% .0821 207.95);--color-secondary-content:oklch(100% 0 0);--color-accent:oklch(60% .118 184.704);--color-accent-content:oklch(98% .001 106.423);--color-neutral:oklch(55% .013 58.071);--color-neutral-content:oklch(98% .031 120.757);--color-info:oklch(70% .165 254.624);--color-info-content:oklch(98% .001 106.423);--color-success:oklch(72% .219 149.579);--color-success-content:oklch(98% .001 106.423);--color-warning:oklch(87% .169 91.605);--color-warning-content:oklch(98% .001 106.423);--color-error:oklch(63% .237 25.331);--color-error-content:oklch(98% .001 106.423);--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-300)}}@layer components;@layer utilities{@layer daisyui.component{.modal{pointer-events:none;visibility:hidden;width:100%;max-width:none;height:100%;max-height:none;color:inherit;transition:visibility .3s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;overscroll-behavior:contain;z-index:999;scrollbar-gutter:auto;background-color:#0000;place-items:center;margin:0;padding:0;display:grid;position:fixed;inset:0;overflow:clip}.modal::backdrop{display:none}.dropdown{position-area:var(--anchor-v,bottom)var(--anchor-h,span-right);display:inline-block;position:relative}.dropdown>:not(summary):focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.dropdown>:not(summary):focus{outline-offset:2px;outline:2px solid #0000}}.dropdown .dropdown-content{position:absolute}.dropdown:not(details,.dropdown-open,.dropdown-hover:hover,:focus-within) .dropdown-content,.dropdown.dropdown-hover:not(:hover) [tabindex]:first-child:focus:not(:focus-visible)~.dropdown-content{transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover],.dropdown .dropdown-content{z-index:999}@media (prefers-reduced-motion:no-preference){.dropdown[popover],.dropdown .dropdown-content{transition-behavior:allow-discrete;transition-property:opacity,scale,display;transition-duration:.2s;transition-timing-function:cubic-bezier(.4,0,.2,1);animation:.2s dropdown}}@starting-style{.dropdown[popover],.dropdown .dropdown-content{opacity:0;scale:95%}}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within)>[tabindex]:first-child{pointer-events:none}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within) .dropdown-content{opacity:1}.dropdown.dropdown-hover:hover .dropdown-content{opacity:1;scale:100%}.dropdown:is(details) summary::-webkit-details-marker{display:none}:is(.dropdown.dropdown-open,.dropdown:focus,.dropdown:focus-within) .dropdown-content{scale:100%}.dropdown:where([popover]){background:0 0}.dropdown[popover]{color:inherit;position:fixed}@supports not (position-area:bottom){.dropdown[popover]{margin:auto}.dropdown[popover].dropdown-open:not(:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover]::backdrop{background-color:oklab(0% none none/.3)}}.dropdown[popover]:not(.dropdown-open,:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}:where(.btn){width:unset}.btn{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn{--btn-noise:var(--fx-noise)}.prose .btn{text-decoration-line:none}@media (hover:hover){.btn:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn:focus-visible,.btn:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn:is(input[type=checkbox],input[type=radio]){appearance:none}.btn:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.loading{pointer-events:none;aspect-ratio:1;vertical-align:middle;width:calc(var(--size-selector,.25rem)*6);background-color:currentColor;display:inline-block;-webkit-mask-image:url("data:image/svg+xml,%3Csvg width='24' height='24' stroke='black' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cg transform-origin='center'%3E%3Ccircle cx='12' cy='12' r='9.5' fill='none' stroke-width='3' stroke-linecap='round'%3E%3CanimateTransform attributeName='transform' type='rotate' from='0 12 12' to='360 12 12' dur='2s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dasharray' values='0,150;42,150;42,150' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dashoffset' values='0;-16;-59' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E");mask-image:url("data:image/svg+xml,%3Csvg width='24' height='24' stroke='black' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cg transform-origin='center'%3E%3Ccircle cx='12' cy='12' r='9.5' fill='none' stroke-width='3' stroke-linecap='round'%3E%3CanimateTransform attributeName='transform' type='rotate' from='0 12 12' to='360 12 12' dur='2s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dasharray' values='0,150;42,150;42,150' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dashoffset' values='0;-16;-59' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E");-webkit-mask-position:50%;mask-position:50%;-webkit-mask-size:100%;mask-size:100%;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat}.list{flex-direction:column;font-size:.875rem;display:flex}.list .list-row{--list-grid-cols:minmax(0,auto)1fr;border-radius:var(--radius-box);word-break:break-word;grid-auto-flow:column;grid-template-columns:var(--list-grid-cols);gap:1rem;padding:1rem;display:grid;position:relative}:is(.list>:not(:last-child).list-row,.list>:not(:last-child) .list-row):after{content:"";border-bottom:var(--border)solid;inset-inline:var(--radius-box);border-color:var(--color-base-content);position:absolute;bottom:0}@supports (color:color-mix(in lab,red,red)){:is(.list>:not(:last-child).list-row,.list>:not(:last-child) .list-row):after{border-color:color-mix(in oklab,var(--color-base-content)5%,transparent)}}.input{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);font-size:max(var(--font-size,.875rem),.875rem);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.input:where(input){display:inline-flex}.input :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.input :where(input):focus,.input :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.input :where(input):focus,.input :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.input :where(input[type=url]),.input :where(input[type=email]){direction:ltr}.input :where(input[type=date]){display:inline-flex}.input:focus,.input:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.input:focus,.input:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.input:focus,.input:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}@media (pointer:coarse){@supports (-webkit-touch-callout:none){.input:focus,.input:focus-within{--font-size:1rem}}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input{cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input{color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input)::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input)::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input{box-shadow:none}.input:has(>input[disabled])>input[disabled]{cursor:not-allowed}.input::-webkit-date-and-time-value{text-align:inherit}.input[type=number]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.input::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.input:has(>input[type=date]) :where(input[type=date]){webkit-appearance:none;appearance:none;display:inline-flex}.input:has(>input[type=date]) input[type=date]::-webkit-calendar-picker-indicator{cursor:pointer;width:1em;height:1em;position:absolute;inset-inline-end:.75em}.avatar{vertical-align:middle;display:inline-flex;position:relative}.avatar>div{aspect-ratio:1;display:block;overflow:hidden}.avatar img{object-fit:cover;width:100%;height:100%}.progress{appearance:none;border-radius:var(--radius-box);background-color:currentColor;width:100%;height:.5rem;position:relative;overflow:hidden}@supports (color:color-mix(in lab,red,red)){.progress{background-color:color-mix(in oklab,currentcolor 20%,transparent)}}.progress{color:var(--color-base-content)}.progress:indeterminate{background-image:repeating-linear-gradient(90deg,currentColor -1% 10%,#0000 10% 90%);background-position-x:15%;background-size:200%}@media (prefers-reduced-motion:no-preference){.progress:indeterminate{animation:5s ease-in-out infinite progress}}@supports ((-moz-appearance:none)){.progress:indeterminate::-moz-progress-bar{background-color:#0000}@media (prefers-reduced-motion:no-preference){.progress:indeterminate::-moz-progress-bar{background-image:repeating-linear-gradient(90deg,currentColor -1% 10%,#0000 10% 90%);background-position-x:15%;background-size:200%;animation:5s ease-in-out infinite progress}}.progress::-moz-progress-bar{border-radius:var(--radius-box);background-color:currentColor}}@supports ((-webkit-appearance:none)){.progress::-webkit-progress-bar{border-radius:var(--radius-box);background-color:#0000}.progress::-webkit-progress-value{border-radius:var(--radius-box);background-color:currentColor}}.file-input{cursor:pointer;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;webkit-user-select:none;-webkit-user-select:none;user-select:none;width:clamp(3rem,20rem,100%);height:var(--size);border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));align-items:center;padding-inline-end:.75rem;font-size:.875rem;line-height:2;display:inline-flex}@supports (color:color-mix(in lab,red,red)){.file-input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.file-input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.file-input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.file-input::file-selector-button{cursor:pointer;webkit-user-select:none;-webkit-user-select:none;user-select:none;height:calc(100% + var(--border)*2);margin-inline-end:1rem;margin-block:calc(var(--border)*-1);color:var(--btn-fg);border-width:var(--border);border-style:solid;border-color:var(--btn-border);background-color:var(--btn-bg);background-size:calc(var(--noise)*100%);background-image:var(--btn-noise);text-shadow:0 .5px oklch(1 0 0/calc(var(--depth)*.15));box-shadow:0 .5px 0 .5px #fff inset,var(--btn-shadow);border-start-start-radius:calc(var(--join-ss,var(--radius-field) - var(--border)));border-end-start-radius:calc(var(--join-es,var(--radius-field) - var(--border)));margin-inline-start:calc(var(--border)*-1);padding-inline:1rem;font-size:.875rem;font-weight:600}@supports (color:color-mix(in lab,red,red)){.file-input::file-selector-button{box-shadow:0 .5px 0 .5px color-mix(in oklab,color-mix(in oklab,white 30%,var(--btn-bg))calc(var(--depth)*20%),#0000) inset,var(--btn-shadow)}}.file-input::file-selector-button{--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-border:var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.file-input::file-selector-button{--btn-border:color-mix(in oklab,var(--btn-bg),#000 5%)}}.file-input::file-selector-button{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.file-input::file-selector-button{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)30%,#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)30%,#0000)}}.file-input::file-selector-button{--btn-noise:var(--fx-noise)}.file-input:focus{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.file-input:focus{box-shadow:0 1px color-mix(in oklab,var(--input-color)10%,#0000)}}.file-input:focus{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate}.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200)}:is(.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]){box-shadow:none;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]){color:color-mix(in oklch,var(--color-base-content)20%,#0000)}}:is(.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]))::file-selector-button{cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]))::file-selector-button{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}.modal-box{background-color:var(--color-base-100);border-top-left-radius:var(--modal-tl,var(--radius-box));border-top-right-radius:var(--modal-tr,var(--radius-box));border-bottom-left-radius:var(--modal-bl,var(--radius-box));border-bottom-right-radius:var(--modal-br,var(--radius-box));opacity:0;overscroll-behavior:contain;grid-row-start:1;grid-column-start:1;width:91.6667%;max-width:32rem;max-height:100vh;padding:1.5rem;transition:translate .3s ease-out,scale .3s ease-out,opacity .2s ease-out 50ms,box-shadow .3s ease-out;overflow-y:auto;scale:95%;box-shadow:0 25px 50px -12px #00000040}.filter{flex-wrap:wrap;display:flex}.filter input[type=radio]{width:auto}.filter input{opacity:1;transition:margin .1s,opacity .3s,padding .3s,border-width .1s;overflow:hidden;scale:1}.filter input:not(:last-child){margin-inline-end:.25rem}.filter input.filter-reset{aspect-ratio:1}.filter input.filter-reset:after{content:""}.filter:not(:has(input:checked:not(.filter-reset))) .filter-reset,.filter:not(:has(input:checked:not(.filter-reset))) input[type=reset],.filter:has(input:checked:not(.filter-reset)) input:not(:checked,.filter-reset,input[type=reset]){opacity:0;border-width:0;width:0;margin-inline:0;padding-inline:0;scale:0}.modal-action{justify-content:flex-end;gap:.5rem;margin-top:1.5rem;display:flex}.status{aspect-ratio:1;border-radius:var(--radius-selector);background-color:var(--color-base-content);width:.5rem;height:.5rem;display:inline-block}@supports (color:color-mix(in lab,red,red)){.status{background-color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.status{vertical-align:middle;color:#0000004d;background-position:50%;background-repeat:no-repeat}@supports (color:color-mix(in lab,red,red)){.status{color:color-mix(in oklab,var(--color-black)30%,transparent)}}.status{background-image:radial-gradient(circle at 35% 30%,oklch(1 0 0/calc(var(--depth)*.5)),#0000);box-shadow:0 2px 3px -1px}@supports (color:color-mix(in lab,red,red)){.status{box-shadow:0 2px 3px -1px color-mix(in oklab,currentColor calc(var(--depth)*100%),#0000)}}.badge{border-radius:var(--radius-selector);vertical-align:middle;color:var(--badge-fg);border:var(--border)solid var(--badge-color,var(--color-base-200));width:fit-content;padding-inline:calc(.25rem*3 - var(--border));background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);background-color:var(--badge-bg);--badge-bg:var(--badge-color,var(--color-base-100));--badge-fg:var(--color-base-content);--size:calc(var(--size-selector,.25rem)*6);height:var(--size);justify-content:center;align-items:center;gap:.5rem;font-size:.875rem;display:inline-flex}.alert{--alert-border-color:var(--color-base-200);border-radius:var(--radius-box);color:var(--color-base-content);background-color:var(--alert-color,var(--color-base-200));text-align:start;background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px #000,0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08));border-style:solid;grid-template-columns:auto;grid-auto-flow:column;justify-content:start;place-items:center start;gap:1rem;padding-block:.75rem;padding-inline:1rem;font-size:.875rem;line-height:1.25rem;display:grid}@supports (color:color-mix(in lab,red,red)){.alert{box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px color-mix(in oklab,color-mix(in oklab,#000 20%,var(--alert-color,var(--color-base-200)))calc(var(--depth)*20%),#0000),0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08))}}.alert:has(:nth-child(2)){grid-template-columns:auto minmax(auto,1fr)}}@layer daisyui.modifier{.modal.modal-open,.modal[open],.modal:target,.modal-toggle:checked+.modal{pointer-events:auto;visibility:visible;opacity:1;transition:visibility 0s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;background-color:#0006}:is(.modal.modal-open,.modal[open],.modal:target,.modal-toggle:checked+.modal) .modal-box{opacity:1;translate:0;scale:1}@starting-style{.modal.modal-open,.modal[open],.modal:target,.modal-toggle:checked+.modal{opacity:0}}.btn:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn[disabled]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn[disabled]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn[disabled]:not(.btn-link,.btn-ghost){box-shadow:none}.btn[disabled]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn[disabled]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn[disabled]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn[disabled]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn[disabled]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn[disabled]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.list .list-row:has(.list-col-grow:first-child){--list-grid-cols:1fr}.list .list-row:has(.list-col-grow:nth-child(2)){--list-grid-cols:minmax(0,auto)1fr}.list .list-row:has(.list-col-grow:nth-child(3)){--list-grid-cols:minmax(0,auto)minmax(0,auto)1fr}.list .list-row:has(.list-col-grow:nth-child(4)){--list-grid-cols:minmax(0,auto)minmax(0,auto)minmax(0,auto)1fr}.list .list-row:has(.list-col-grow:nth-child(5)){--list-grid-cols:minmax(0,auto)minmax(0,auto)minmax(0,auto)minmax(0,auto)1fr}.list .list-row:has(.list-col-grow:nth-child(6)){--list-grid-cols:minmax(0,auto)minmax(0,auto)minmax(0,auto)minmax(0,auto)minmax(0,auto)1fr}.list .list-row :not(.list-col-wrap){grid-row-start:1}.avatar-placeholder>div{justify-content:center;align-items:center;display:flex}.btn-circle{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.badge-soft{color:var(--badge-color,var(--color-base-content));background-color:var(--badge-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.badge-soft{background-color:color-mix(in oklab,var(--badge-color,var(--color-base-content))8%,var(--color-base-100))}}.badge-soft{border-color:var(--badge-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.badge-soft{border-color:color-mix(in oklab,var(--badge-color,var(--color-base-content))10%,var(--color-base-100))}}.badge-soft{background-image:none}.input-ghost{box-shadow:none;background-color:#0000;border-color:#0000}.input-ghost:focus,.input-ghost:focus-within{background-color:var(--color-base-100);color:var(--color-base-content);box-shadow:none;border-color:#0000}.loading-spinner{-webkit-mask-image:url("data:image/svg+xml,%3Csvg width='24' height='24' stroke='black' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cg transform-origin='center'%3E%3Ccircle cx='12' cy='12' r='9.5' fill='none' stroke-width='3' stroke-linecap='round'%3E%3CanimateTransform attributeName='transform' type='rotate' from='0 12 12' to='360 12 12' dur='2s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dasharray' values='0,150;42,150;42,150' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dashoffset' values='0;-16;-59' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E");mask-image:url("data:image/svg+xml,%3Csvg width='24' height='24' stroke='black' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cg transform-origin='center'%3E%3Ccircle cx='12' cy='12' r='9.5' fill='none' stroke-width='3' stroke-linecap='round'%3E%3CanimateTransform attributeName='transform' type='rotate' from='0 12 12' to='360 12 12' dur='2s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dasharray' values='0,150;42,150;42,150' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dashoffset' values='0;-16;-59' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E")}.alert-error{color:var(--color-error-content);--alert-border-color:var(--color-error);--alert-color:var(--color-error)}.file-input-primary{--btn-color:var(--color-primary)}.file-input-primary::file-selector-button{color:var(--color-primary-content)}.file-input-primary,.file-input-primary:focus,.file-input-primary:focus-within{--input-color:var(--color-primary)}.progress-primary{color:var(--color-primary)}.btn-ghost:not(.btn-active,:hover,:active:focus,:focus-visible){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none}.btn-ghost:not(.btn-active,:hover,:active:focus,:focus-visible):not(:disabled,[disabled],.btn-disabled){--btn-fg:currentColor;outline-color:currentColor}@media (hover:none){.btn-ghost:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none;--btn-fg:currentColor}}.btn-outline:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}@media (hover:none){.btn-outline:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}}.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-fg:var(--btn-color,var(--color-base-content));--btn-bg:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-content))8%,var(--color-base-100))}}.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-content))10%,var(--color-base-100))}}.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-noise:none}@media (hover:none){.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-fg:var(--btn-color,var(--color-base-content));--btn-bg:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-content))8%,var(--color-base-100))}}.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-content))10%,var(--color-base-100))}}.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-noise:none}}.btn-sm{--fontsize:.75rem;--btn-p:.75rem;--size:calc(var(--size-field,.25rem)*8)}.badge-error{--badge-color:var(--color-error);--badge-fg:var(--color-error-content)}.badge-neutral{--badge-color:var(--color-neutral);--badge-fg:var(--color-neutral-content)}.badge-primary{--badge-color:var(--color-primary);--badge-fg:var(--color-primary-content)}.badge-warning{--badge-color:var(--color-warning);--badge-fg:var(--color-warning-content)}.btn-primary{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.input-primary,.input-primary:focus,.input-primary:focus-within{--input-color:var(--color-primary)}}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.top-0{top:calc(var(--spacing)*0)}.top-2{top:calc(var(--spacing)*2)}.right-2{right:calc(var(--spacing)*2)}.left-0{left:calc(var(--spacing)*0)}.my-0\\.5{margin-block:calc(var(--spacing)*.5)}.mt-2{margin-top:calc(var(--spacing)*2)}.mt-10{margin-top:calc(var(--spacing)*10)}.mt-24{margin-top:calc(var(--spacing)*24)}.mr-5{margin-right:calc(var(--spacing)*5)}.mb-5{margin-bottom:calc(var(--spacing)*5)}.alert{border-width:var(--border);border-color:var(--alert-border-color,var(--color-base-200))}.flex{display:flex}.hidden{display:none}.inline-flex{display:inline-flex}.size-6{width:calc(var(--spacing)*6);height:calc(var(--spacing)*6)}.h-3{height:calc(var(--spacing)*3)}.h-4{height:calc(var(--spacing)*4)}.h-\\[25px\\]{height:25px}.h-full{height:100%}.h-screen{height:100vh}.w-1{width:calc(var(--spacing)*1)}.w-3{width:calc(var(--spacing)*3)}.w-4{width:calc(var(--spacing)*4)}.w-12{width:calc(var(--spacing)*12)}.w-56{width:calc(var(--spacing)*56)}.w-\\[25px\\]{width:25px}.w-full{width:100%}.w-max{width:max-content}.w-screen{width:100vw}.max-w-136{max-width:calc(var(--spacing)*136)}.min-w-fit{min-width:fit-content}.flex-2\\/3{flex:66.6667%}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.cursor-pointer{cursor:pointer}.list-none{list-style-type:none}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.gap-2{gap:calc(var(--spacing)*2)}.gap-4{gap:calc(var(--spacing)*4)}.gap-5{gap:calc(var(--spacing)*5)}:where(.space-y-5>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*5)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*5)*calc(1 - var(--tw-space-y-reverse)))}.self-end{align-self:flex-end}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.rounded{border-radius:.25rem}.rounded-\\[3px\\]{border-radius:3px}.rounded-box{border-radius:var(--radius-box)}.rounded-full{border-radius:3.40282e38px}.border-e{border-inline-end-style:var(--tw-border-style);border-inline-end-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.bg-base-100{background-color:var(--color-base-100)}.bg-base-300{background-color:var(--color-base-300)}.bg-red-100{background-color:var(--color-red-100)}@layer daisyui.style{.alert-soft{color:var(--alert-color,var(--color-base-content));background:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert-soft{background:color-mix(in oklab,var(--alert-color,var(--color-base-content))8%,var(--color-base-100))}}.alert-soft{--alert-border-color:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert-soft{--alert-border-color:color-mix(in oklab,var(--alert-color,var(--color-base-content))10%,var(--color-base-100))}}.alert-soft{box-shadow:none;background-image:none}}.p-2{padding:calc(var(--spacing)*2)}.p-4{padding:calc(var(--spacing)*4)}.p-\\[5px\\]{padding:5px}.px-2{padding-inline:calc(var(--spacing)*2)}.py-1{padding-block:calc(var(--spacing)*1)}.py-2{padding-block:calc(var(--spacing)*2)}.pr-\\[35px\\]{padding-right:35px}.pb-2{padding-bottom:calc(var(--spacing)*2)}.pb-20{padding-bottom:calc(var(--spacing)*20)}.pl-2{padding-left:calc(var(--spacing)*2)}.pl-\\[25px\\]{padding-left:25px}.text-center{text-align:center}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.leading-none{--tw-leading:1;line-height:1}.font-black{--tw-font-weight:var(--font-weight-black);font-weight:var(--font-weight-black)}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.text-base-content{color:var(--color-base-content)}.text-error{color:var(--color-error)}.text-error-content{color:var(--color-error-content)}.text-neutral-content{color:var(--color-neutral-content)}.text-primary{color:var(--color-primary)}.text-primary-content{color:var(--color-primary-content)}.text-stone-700{color:var(--color-stone-700)}.text-warning-content{color:var(--color-warning-content)}.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.outline-none{--tw-outline-style:none;outline-style:none}.select-none{-webkit-user-select:none;user-select:none}.focus\\:ring-2:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\\:ring-primary:focus{--tw-ring-color:var(--color-primary)}.data-\\[disabled\\]\\:pointer-events-none[data-disabled]{pointer-events:none}.data-\\[disabled\\]\\:text-base-content[data-disabled]{color:var(--color-base-content)}.data-\\[highlighted\\]\\:bg-primary[data-highlighted]{background-color:var(--color-primary)}.data-\\[highlighted\\]\\:outline-none[data-highlighted]{--tw-outline-style:none;outline-style:none}.data-\\[selected\\]\\:bg-primary\\/20[data-selected]{background-color:var(--color-primary)}@supports (color:color-mix(in lab,red,red)){.data-\\[selected\\]\\:bg-primary\\/20[data-selected]{background-color:color-mix(in oklab,var(--color-primary)20%,transparent)}}@media (min-width:40rem){.sm\\:block{display:block}}}:root{--color-ocean-gray-00:#fff;--color-ocean-gray-25:#fafbfb;--color-ocean-gray-50:#f5f6f7;--color-ocean-gray-75:#eaeeef;--color-ocean-gray-100:#e1e4e6;--color-ocean-gray-150:#c6ced1;--color-ocean-gray-200:#bac1c4;--color-ocean-gray-250:#9fadb2;--color-ocean-gray-300:#889499;--color-ocean-gray-350:#72858c;--color-ocean-gray-400:#617177;--color-ocean-gray-450:#3f555e;--color-ocean-gray-500:#394d55;--color-ocean-gray-550:#34464d;--color-ocean-gray-600:#2e3e44;--color-ocean-gray-650:#27353b;--color-ocean-gray-700:#222e33;--color-ocean-gray-750:#1f272b;--color-ocean-gray-800:#171f22;--color-ocean-gray-850:#11171a;--color-ocean-gray-900:#0b0f11;--color-chart-1:#f7931e;--color-chart-2:#40535b;--color-chart-3:#2798aa;--color-chart-4:#6da89c;--color-chart-5:#a4cadd;--color-chart-6:#97b42d;--color-chart-7:#ffcb05;--color-chart-8:#ee652e;--color-chart-9:#528694;--color-chart-10:#a10f3b}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes progress{50%{background-position-x:-115%}}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}`)),document.head.appendChild(o)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
// @__NO_SIDE_EFFECTS__
function _c(e) {
  const l = /* @__PURE__ */ Object.create(null);
  for (const i of e.split(",")) l[i] = 1;
  return (i) => i in l;
}
const On = {}, Ca = [], bt = () => {
}, Cp = () => !1, ds = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // uppercase letter
(e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Bm = (e) => e.startsWith("onUpdate:"), kn = Object.assign, Zm = (e, l) => {
  const i = e.indexOf(l);
  i > -1 && e.splice(i, 1);
}, Fv = Object.prototype.hasOwnProperty, Pn = (e, l) => Fv.call(e, l), Xe = Array.isArray, Ta = (e) => Ka(e) === "[object Map]", sa = (e) => Ka(e) === "[object Set]", Af = (e) => Ka(e) === "[object Date]", Mv = (e) => Ka(e) === "[object RegExp]", sn = (e) => typeof e == "function", Wn = (e) => typeof e == "string", fi = (e) => typeof e == "symbol", _n = (e) => e !== null && typeof e == "object", Um = (e) => (_n(e) || sn(e)) && sn(e.then) && sn(e.catch), Tp = Object.prototype.toString, Ka = (e) => Tp.call(e), kv = (e) => Ka(e).slice(8, -1), Nc = (e) => Ka(e) === "[object Object]", Km = (e) => Wn(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Pa = /* @__PURE__ */ _c(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Fc = (e) => {
  const l = /* @__PURE__ */ Object.create(null);
  return (i) => l[i] || (l[i] = e(i));
}, Vv = /-\w/g, gl = Fc(
  (e) => e.replace(Vv, (l) => l.slice(1).toUpperCase())
), Bv = /\B([A-Z])/g, ht = Fc(
  (e) => e.replace(Bv, "-$1").toLowerCase()
), ps = Fc((e) => e.charAt(0).toUpperCase() + e.slice(1)), qa = Fc(
  (e) => e ? `on${ps(e)}` : ""
), Vl = (e, l) => !Object.is(e, l), Ra = (e, ...l) => {
  for (let i = 0; i < e.length; i++)
    e[i](...l);
}, Pp = (e, l, i, a = !1) => {
  Object.defineProperty(e, l, {
    configurable: !0,
    enumerable: !1,
    writable: a,
    value: i
  });
}, sc = (e) => {
  const l = parseFloat(e);
  return isNaN(l) ? e : l;
}, cc = (e) => {
  const l = Wn(e) ? Number(e) : NaN;
  return isNaN(l) ? e : l;
};
let Ef;
const Mc = () => Ef || (Ef = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}), Zv = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol", Uv = /* @__PURE__ */ _c(Zv);
function Hi(e) {
  if (Xe(e)) {
    const l = {};
    for (let i = 0; i < e.length; i++) {
      const a = e[i], s = Wn(a) ? jv(a) : Hi(a);
      if (s)
        for (const o in s)
          l[o] = s[o];
    }
    return l;
  } else if (Wn(e) || _n(e))
    return e;
}
const Kv = /;(?![^(]*\))/g, Gv = /:([^]+)/, zv = /\/\*[^]*?\*\//g;
function jv(e) {
  const l = {};
  return e.replace(zv, "").split(Kv).forEach((i) => {
    if (i) {
      const a = i.split(Gv);
      a.length > 1 && (l[a[0].trim()] = a[1].trim());
    }
  }), l;
}
function Bl(e) {
  let l = "";
  if (Wn(e))
    l = e;
  else if (Xe(e))
    for (let i = 0; i < e.length; i++) {
      const a = Bl(e[i]);
      a && (l += a + " ");
    }
  else if (_n(e))
    for (const i in e)
      e[i] && (l += i + " ");
  return l.trim();
}
function kc(e) {
  if (!e) return null;
  let { class: l, style: i } = e;
  return l && !Wn(l) && (e.class = Bl(l)), i && (e.style = Hi(i)), e;
}
const Hv = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", $v = /* @__PURE__ */ _c(Hv);
function qp(e) {
  return !!e || e === "";
}
function Wv(e, l) {
  if (e.length !== l.length) return !1;
  let i = !0;
  for (let a = 0; i && a < e.length; a++)
    i = Uu(e[a], l[a]);
  return i;
}
function Uu(e, l) {
  if (e === l) return !0;
  let i = Af(e), a = Af(l);
  if (i || a)
    return i && a ? e.getTime() === l.getTime() : !1;
  if (i = fi(e), a = fi(l), i || a)
    return e === l;
  if (i = Xe(e), a = Xe(l), i || a)
    return i && a ? Wv(e, l) : !1;
  if (i = _n(e), a = _n(l), i || a) {
    if (!i || !a)
      return !1;
    const s = Object.keys(e).length, o = Object.keys(l).length;
    if (s !== o)
      return !1;
    for (const f in e) {
      const d = e.hasOwnProperty(f), h = l.hasOwnProperty(f);
      if (d && !h || !d && h || !Uu(e[f], l[f]))
        return !1;
    }
  }
  return String(e) === String(l);
}
function Vc(e, l) {
  return e.findIndex((i) => Uu(i, l));
}
const Rp = (e) => !!(e && e.__v_isRef === !0), Ul = (e) => Wn(e) ? e : e == null ? "" : Xe(e) || _n(e) && (e.toString === Tp || !sn(e.toString)) ? Rp(e) ? Ul(e.value) : JSON.stringify(e, Ap, 2) : String(e), Ap = (e, l) => Rp(l) ? Ap(e, l.value) : Ta(l) ? {
  [`Map(${l.size})`]: [...l.entries()].reduce(
    (i, [a, s], o) => (i[vo(a, o) + " =>"] = s, i),
    {}
  )
} : sa(l) ? {
  [`Set(${l.size})`]: [...l.values()].map((i) => vo(i))
} : fi(l) ? vo(l) : _n(l) && !Xe(l) && !Nc(l) ? String(l) : l, vo = (e, l = "") => {
  var i;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    fi(e) ? `Symbol(${(i = e.description) != null ? i : l})` : e
  );
};
function Yv(e) {
  return e == null ? "initial" : typeof e == "string" ? e === "" ? " " : e : String(e);
}
let El;
class Gm {
  constructor(l = !1) {
    this.detached = l, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = El, !l && El && (this.index = (El.scopes || (El.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let l, i;
      if (this.scopes)
        for (l = 0, i = this.scopes.length; l < i; l++)
          this.scopes[l].pause();
      for (l = 0, i = this.effects.length; l < i; l++)
        this.effects[l].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let l, i;
      if (this.scopes)
        for (l = 0, i = this.scopes.length; l < i; l++)
          this.scopes[l].resume();
      for (l = 0, i = this.effects.length; l < i; l++)
        this.effects[l].resume();
    }
  }
  run(l) {
    if (this._active) {
      const i = El;
      try {
        return El = this, l();
      } finally {
        El = i;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = El, El = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (El = this.prevScope, this.prevScope = void 0);
  }
  stop(l) {
    if (this._active) {
      this._active = !1;
      let i, a;
      for (i = 0, a = this.effects.length; i < a; i++)
        this.effects[i].stop();
      for (this.effects.length = 0, i = 0, a = this.cleanups.length; i < a; i++)
        this.cleanups[i]();
      if (this.cleanups.length = 0, this.scopes) {
        for (i = 0, a = this.scopes.length; i < a; i++)
          this.scopes[i].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !l) {
        const s = this.parent.scopes.pop();
        s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Bc(e) {
  return new Gm(e);
}
function $i() {
  return El;
}
function ca(e, l = !1) {
  El && El.cleanups.push(e);
}
let $n;
const xo = /* @__PURE__ */ new WeakSet();
class Xr {
  constructor(l) {
    this.fn = l, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, El && El.active && El.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, xo.has(this) && (xo.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || _p(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, _f(this), Np(this);
    const l = $n, i = ci;
    $n = this, ci = !0;
    try {
      return this.fn();
    } finally {
      Fp(this), $n = l, ci = i, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let l = this.deps; l; l = l.nextDep)
        Hm(l);
      this.deps = this.depsTail = void 0, _f(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? xo.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    nm(this) && this.run();
  }
  get dirty() {
    return nm(this);
  }
}
let Ep = 0, Br, Zr;
function _p(e, l = !1) {
  if (e.flags |= 8, l) {
    e.next = Zr, Zr = e;
    return;
  }
  e.next = Br, Br = e;
}
function zm() {
  Ep++;
}
function jm() {
  if (--Ep > 0)
    return;
  if (Zr) {
    let l = Zr;
    for (Zr = void 0; l; ) {
      const i = l.next;
      l.next = void 0, l.flags &= -9, l = i;
    }
  }
  let e;
  for (; Br; ) {
    let l = Br;
    for (Br = void 0; l; ) {
      const i = l.next;
      if (l.next = void 0, l.flags &= -9, l.flags & 1)
        try {
          l.trigger();
        } catch (a) {
          e || (e = a);
        }
      l = i;
    }
  }
  if (e) throw e;
}
function Np(e) {
  for (let l = e.deps; l; l = l.nextDep)
    l.version = -1, l.prevActiveLink = l.dep.activeLink, l.dep.activeLink = l;
}
function Fp(e) {
  let l, i = e.depsTail, a = i;
  for (; a; ) {
    const s = a.prevDep;
    a.version === -1 ? (a === i && (i = s), Hm(a), Xv(a)) : l = a, a.dep.activeLink = a.prevActiveLink, a.prevActiveLink = void 0, a = s;
  }
  e.deps = l, e.depsTail = i;
}
function nm(e) {
  for (let l = e.deps; l; l = l.nextDep)
    if (l.dep.version !== l.version || l.dep.computed && (Mp(l.dep.computed) || l.dep.version !== l.version))
      return !0;
  return !!e._dirty;
}
function Mp(e) {
  if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === Qr) || (e.globalVersion = Qr, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !nm(e))))
    return;
  e.flags |= 2;
  const l = e.dep, i = $n, a = ci;
  $n = e, ci = !0;
  try {
    Np(e);
    const s = e.fn(e._value);
    (l.version === 0 || Vl(s, e._value)) && (e.flags |= 128, e._value = s, l.version++);
  } catch (s) {
    throw l.version++, s;
  } finally {
    $n = i, ci = a, Fp(e), e.flags &= -3;
  }
}
function Hm(e, l = !1) {
  const { dep: i, prevSub: a, nextSub: s } = e;
  if (a && (a.nextSub = s, e.prevSub = void 0), s && (s.prevSub = a, e.nextSub = void 0), i.subs === e && (i.subs = a, !a && i.computed)) {
    i.computed.flags &= -5;
    for (let o = i.computed.deps; o; o = o.nextDep)
      Hm(o, !0);
  }
  !l && !--i.sc && i.map && i.map.delete(i.key);
}
function Xv(e) {
  const { prevDep: l, nextDep: i } = e;
  l && (l.nextDep = i, e.prevDep = void 0), i && (i.prevDep = l, e.nextDep = void 0);
}
function Qv(e, l) {
  e.effect instanceof Xr && (e = e.effect.fn);
  const i = new Xr(e);
  l && kn(i, l);
  try {
    i.run();
  } catch (s) {
    throw i.stop(), s;
  }
  const a = i.run.bind(i);
  return a.effect = i, a;
}
function Jv(e) {
  e.effect.stop();
}
let ci = !0;
const kp = [];
function ki() {
  kp.push(ci), ci = !1;
}
function Vi() {
  const e = kp.pop();
  ci = e === void 0 ? !0 : e;
}
function _f(e) {
  const { cleanup: l } = e;
  if (e.cleanup = void 0, l) {
    const i = $n;
    $n = void 0;
    try {
      l();
    } finally {
      $n = i;
    }
  }
}
let Qr = 0;
class ex {
  constructor(l, i) {
    this.sub = l, this.dep = i, this.version = i.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Zc {
  // TODO isolatedDeclarations "__v_skip"
  constructor(l) {
    this.computed = l, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(l) {
    if (!$n || !ci || $n === this.computed)
      return;
    let i = this.activeLink;
    if (i === void 0 || i.sub !== $n)
      i = this.activeLink = new ex($n, this), $n.deps ? (i.prevDep = $n.depsTail, $n.depsTail.nextDep = i, $n.depsTail = i) : $n.deps = $n.depsTail = i, Vp(i);
    else if (i.version === -1 && (i.version = this.version, i.nextDep)) {
      const a = i.nextDep;
      a.prevDep = i.prevDep, i.prevDep && (i.prevDep.nextDep = a), i.prevDep = $n.depsTail, i.nextDep = void 0, $n.depsTail.nextDep = i, $n.depsTail = i, $n.deps === i && ($n.deps = a);
    }
    return i;
  }
  trigger(l) {
    this.version++, Qr++, this.notify(l);
  }
  notify(l) {
    zm();
    try {
      for (let i = this.subs; i; i = i.prevSub)
        i.sub.notify() && i.sub.dep.notify();
    } finally {
      jm();
    }
  }
}
function Vp(e) {
  if (e.dep.sc++, e.sub.flags & 4) {
    const l = e.dep.computed;
    if (l && !e.dep.subs) {
      l.flags |= 20;
      for (let a = l.deps; a; a = a.nextDep)
        Vp(a);
    }
    const i = e.dep.subs;
    i !== e && (e.prevSub = i, i && (i.nextSub = e)), e.dep.subs = e;
  }
}
const oc = /* @__PURE__ */ new WeakMap(), la = Symbol(
  ""
), lm = Symbol(
  ""
), Jr = Symbol(
  ""
);
function _l(e, l, i) {
  if (ci && $n) {
    let a = oc.get(e);
    a || oc.set(e, a = /* @__PURE__ */ new Map());
    let s = a.get(i);
    s || (a.set(i, s = new Zc()), s.map = a, s.key = i), s.track();
  }
}
function Ai(e, l, i, a, s, o) {
  const f = oc.get(e);
  if (!f) {
    Qr++;
    return;
  }
  const d = (h) => {
    h && h.trigger();
  };
  if (zm(), l === "clear")
    f.forEach(d);
  else {
    const h = Xe(e), x = h && Km(i);
    if (h && i === "length") {
      const y = Number(a);
      f.forEach((I, q) => {
        (q === "length" || q === Jr || !fi(q) && q >= y) && d(I);
      });
    } else
      switch ((i !== void 0 || f.has(void 0)) && d(f.get(i)), x && d(f.get(Jr)), l) {
        case "add":
          h ? x && d(f.get("length")) : (d(f.get(la)), Ta(e) && d(f.get(lm)));
          break;
        case "delete":
          h || (d(f.get(la)), Ta(e) && d(f.get(lm)));
          break;
        case "set":
          Ta(e) && d(f.get(la));
          break;
      }
  }
  jm();
}
function nx(e, l) {
  const i = oc.get(e);
  return i && i.get(l);
}
function ga(e) {
  const l = Ln(e);
  return l === e ? l : (_l(l, "iterate", Jr), yt(e) ? l : l.map(ql));
}
function Uc(e) {
  return _l(e = Ln(e), "iterate", Jr), e;
}
const lx = {
  __proto__: null,
  [Symbol.iterator]() {
    return yo(this, Symbol.iterator, ql);
  },
  concat(...e) {
    return ga(this).concat(
      ...e.map((l) => Xe(l) ? ga(l) : l)
    );
  },
  entries() {
    return yo(this, "entries", (e) => (e[1] = ql(e[1]), e));
  },
  every(e, l) {
    return Ci(this, "every", e, l, void 0, arguments);
  },
  filter(e, l) {
    return Ci(this, "filter", e, l, (i) => i.map(ql), arguments);
  },
  find(e, l) {
    return Ci(this, "find", e, l, ql, arguments);
  },
  findIndex(e, l) {
    return Ci(this, "findIndex", e, l, void 0, arguments);
  },
  findLast(e, l) {
    return Ci(this, "findLast", e, l, ql, arguments);
  },
  findLastIndex(e, l) {
    return Ci(this, "findLastIndex", e, l, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(e, l) {
    return Ci(this, "forEach", e, l, void 0, arguments);
  },
  includes(...e) {
    return Io(this, "includes", e);
  },
  indexOf(...e) {
    return Io(this, "indexOf", e);
  },
  join(e) {
    return ga(this).join(e);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...e) {
    return Io(this, "lastIndexOf", e);
  },
  map(e, l) {
    return Ci(this, "map", e, l, void 0, arguments);
  },
  pop() {
    return Or(this, "pop");
  },
  push(...e) {
    return Or(this, "push", e);
  },
  reduce(e, ...l) {
    return Nf(this, "reduce", e, l);
  },
  reduceRight(e, ...l) {
    return Nf(this, "reduceRight", e, l);
  },
  shift() {
    return Or(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(e, l) {
    return Ci(this, "some", e, l, void 0, arguments);
  },
  splice(...e) {
    return Or(this, "splice", e);
  },
  toReversed() {
    return ga(this).toReversed();
  },
  toSorted(e) {
    return ga(this).toSorted(e);
  },
  toSpliced(...e) {
    return ga(this).toSpliced(...e);
  },
  unshift(...e) {
    return Or(this, "unshift", e);
  },
  values() {
    return yo(this, "values", ql);
  }
};
function yo(e, l, i) {
  const a = Uc(e), s = a[l]();
  return a !== e && !yt(e) && (s._next = s.next, s.next = () => {
    const o = s._next();
    return o.done || (o.value = i(o.value)), o;
  }), s;
}
const tx = Array.prototype;
function Ci(e, l, i, a, s, o) {
  const f = Uc(e), d = f !== e && !yt(e), h = f[l];
  if (h !== tx[l]) {
    const I = h.apply(e, o);
    return d ? ql(I) : I;
  }
  let x = i;
  f !== e && (d ? x = function(I, q) {
    return i.call(this, ql(I), q, e);
  } : i.length > 2 && (x = function(I, q) {
    return i.call(this, I, q, e);
  }));
  const y = h.call(f, x, a);
  return d && s ? s(y) : y;
}
function Nf(e, l, i, a) {
  const s = Uc(e);
  let o = i;
  return s !== e && (yt(e) ? i.length > 3 && (o = function(f, d, h) {
    return i.call(this, f, d, h, e);
  }) : o = function(f, d, h) {
    return i.call(this, f, ql(d), h, e);
  }), s[l](o, ...a);
}
function Io(e, l, i) {
  const a = Ln(e);
  _l(a, "iterate", Jr);
  const s = a[l](...i);
  return (s === -1 || s === !1) && zc(i[0]) ? (i[0] = Ln(i[0]), a[l](...i)) : s;
}
function Or(e, l, i = []) {
  ki(), zm();
  const a = Ln(e)[l].apply(e, i);
  return jm(), Vi(), a;
}
const ix = /* @__PURE__ */ _c("__proto__,__v_isRef,__isVue"), Bp = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(fi)
);
function ux(e) {
  fi(e) || (e = String(e));
  const l = Ln(this);
  return _l(l, "has", e), l.hasOwnProperty(e);
}
class Zp {
  constructor(l = !1, i = !1) {
    this._isReadonly = l, this._isShallow = i;
  }
  get(l, i, a) {
    if (i === "__v_skip") return l.__v_skip;
    const s = this._isReadonly, o = this._isShallow;
    if (i === "__v_isReactive")
      return !s;
    if (i === "__v_isReadonly")
      return s;
    if (i === "__v_isShallow")
      return o;
    if (i === "__v_raw")
      return a === (s ? o ? Hp : jp : o ? zp : Gp).get(l) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(l) === Object.getPrototypeOf(a) ? l : void 0;
    const f = Xe(l);
    if (!s) {
      let h;
      if (f && (h = lx[i]))
        return h;
      if (i === "hasOwnProperty")
        return ux;
    }
    const d = Reflect.get(
      l,
      i,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      Vn(l) ? l : a
    );
    if ((fi(i) ? Bp.has(i) : ix(i)) || (s || _l(l, "get", i), o))
      return d;
    if (Vn(d)) {
      const h = f && Km(i) ? d : d.value;
      return s && _n(h) ? Bi(h) : h;
    }
    return _n(d) ? s ? Bi(d) : Ga(d) : d;
  }
}
class Up extends Zp {
  constructor(l = !1) {
    super(!1, l);
  }
  set(l, i, a, s) {
    let o = l[i];
    if (!this._isShallow) {
      const h = Zi(o);
      if (!yt(a) && !Zi(a) && (o = Ln(o), a = Ln(a)), !Xe(l) && Vn(o) && !Vn(a))
        return h || (o.value = a), !0;
    }
    const f = Xe(l) && Km(i) ? Number(i) < l.length : Pn(l, i), d = Reflect.set(
      l,
      i,
      a,
      Vn(l) ? l : s
    );
    return l === Ln(s) && (f ? Vl(a, o) && Ai(l, "set", i, a) : Ai(l, "add", i, a)), d;
  }
  deleteProperty(l, i) {
    const a = Pn(l, i);
    l[i];
    const s = Reflect.deleteProperty(l, i);
    return s && a && Ai(l, "delete", i, void 0), s;
  }
  has(l, i) {
    const a = Reflect.has(l, i);
    return (!fi(i) || !Bp.has(i)) && _l(l, "has", i), a;
  }
  ownKeys(l) {
    return _l(
      l,
      "iterate",
      Xe(l) ? "length" : la
    ), Reflect.ownKeys(l);
  }
}
class Kp extends Zp {
  constructor(l = !1) {
    super(!0, l);
  }
  set(l, i) {
    return !0;
  }
  deleteProperty(l, i) {
    return !0;
  }
}
const ax = /* @__PURE__ */ new Up(), rx = /* @__PURE__ */ new Kp(), sx = /* @__PURE__ */ new Up(!0), cx = /* @__PURE__ */ new Kp(!0), tm = (e) => e, qs = (e) => Reflect.getPrototypeOf(e);
function ox(e, l, i) {
  return function(...a) {
    const s = this.__v_raw, o = Ln(s), f = Ta(o), d = e === "entries" || e === Symbol.iterator && f, h = e === "keys" && f, x = s[e](...a), y = i ? tm : l ? mc : ql;
    return !l && _l(
      o,
      "iterate",
      h ? lm : la
    ), {
      // iterator protocol
      next() {
        const { value: I, done: q } = x.next();
        return q ? { value: I, done: q } : {
          value: d ? [y(I[0]), y(I[1])] : y(I),
          done: q
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Rs(e) {
  return function(...l) {
    return e === "delete" ? !1 : e === "clear" ? void 0 : this;
  };
}
function mx(e, l) {
  const i = {
    get(s) {
      const o = this.__v_raw, f = Ln(o), d = Ln(s);
      e || (Vl(s, d) && _l(f, "get", s), _l(f, "get", d));
      const { has: h } = qs(f), x = l ? tm : e ? mc : ql;
      if (h.call(f, s))
        return x(o.get(s));
      if (h.call(f, d))
        return x(o.get(d));
      o !== f && o.get(s);
    },
    get size() {
      const s = this.__v_raw;
      return !e && _l(Ln(s), "iterate", la), s.size;
    },
    has(s) {
      const o = this.__v_raw, f = Ln(o), d = Ln(s);
      return e || (Vl(s, d) && _l(f, "has", s), _l(f, "has", d)), s === d ? o.has(s) : o.has(s) || o.has(d);
    },
    forEach(s, o) {
      const f = this, d = f.__v_raw, h = Ln(d), x = l ? tm : e ? mc : ql;
      return !e && _l(h, "iterate", la), d.forEach((y, I) => s.call(o, x(y), x(I), f));
    }
  };
  return kn(
    i,
    e ? {
      add: Rs("add"),
      set: Rs("set"),
      delete: Rs("delete"),
      clear: Rs("clear")
    } : {
      add(s) {
        !l && !yt(s) && !Zi(s) && (s = Ln(s));
        const o = Ln(this);
        return qs(o).has.call(o, s) || (o.add(s), Ai(o, "add", s, s)), this;
      },
      set(s, o) {
        !l && !yt(o) && !Zi(o) && (o = Ln(o));
        const f = Ln(this), { has: d, get: h } = qs(f);
        let x = d.call(f, s);
        x || (s = Ln(s), x = d.call(f, s));
        const y = h.call(f, s);
        return f.set(s, o), x ? Vl(o, y) && Ai(f, "set", s, o) : Ai(f, "add", s, o), this;
      },
      delete(s) {
        const o = Ln(this), { has: f, get: d } = qs(o);
        let h = f.call(o, s);
        h || (s = Ln(s), h = f.call(o, s)), d && d.call(o, s);
        const x = o.delete(s);
        return h && Ai(o, "delete", s, void 0), x;
      },
      clear() {
        const s = Ln(this), o = s.size !== 0, f = s.clear();
        return o && Ai(
          s,
          "clear",
          void 0,
          void 0
        ), f;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((s) => {
    i[s] = ox(s, e, l);
  }), i;
}
function Kc(e, l) {
  const i = mx(e, l);
  return (a, s, o) => s === "__v_isReactive" ? !e : s === "__v_isReadonly" ? e : s === "__v_raw" ? a : Reflect.get(
    Pn(i, s) && s in a ? i : a,
    s,
    o
  );
}
const fx = {
  get: /* @__PURE__ */ Kc(!1, !1)
}, dx = {
  get: /* @__PURE__ */ Kc(!1, !0)
}, px = {
  get: /* @__PURE__ */ Kc(!0, !1)
}, hx = {
  get: /* @__PURE__ */ Kc(!0, !0)
}, Gp = /* @__PURE__ */ new WeakMap(), zp = /* @__PURE__ */ new WeakMap(), jp = /* @__PURE__ */ new WeakMap(), Hp = /* @__PURE__ */ new WeakMap();
function gx(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function vx(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : gx(kv(e));
}
function Ga(e) {
  return Zi(e) ? e : Gc(
    e,
    !1,
    ax,
    fx,
    Gp
  );
}
function $p(e) {
  return Gc(
    e,
    !1,
    sx,
    dx,
    zp
  );
}
function Bi(e) {
  return Gc(
    e,
    !0,
    rx,
    px,
    jp
  );
}
function _u(e) {
  return Gc(
    e,
    !0,
    cx,
    hx,
    Hp
  );
}
function Gc(e, l, i, a, s) {
  if (!_n(e) || e.__v_raw && !(l && e.__v_isReactive))
    return e;
  const o = vx(e);
  if (o === 0)
    return e;
  const f = s.get(e);
  if (f)
    return f;
  const d = new Proxy(
    e,
    o === 2 ? a : i
  );
  return s.set(e, d), d;
}
function oi(e) {
  return Zi(e) ? oi(e.__v_raw) : !!(e && e.__v_isReactive);
}
function Zi(e) {
  return !!(e && e.__v_isReadonly);
}
function yt(e) {
  return !!(e && e.__v_isShallow);
}
function zc(e) {
  return e ? !!e.__v_raw : !1;
}
function Ln(e) {
  const l = e && e.__v_raw;
  return l ? Ln(l) : e;
}
function za(e) {
  return !Pn(e, "__v_skip") && Object.isExtensible(e) && Pp(e, "__v_skip", !0), e;
}
const ql = (e) => _n(e) ? Ga(e) : e, mc = (e) => _n(e) ? Bi(e) : e;
function Vn(e) {
  return e ? e.__v_isRef === !0 : !1;
}
function Fe(e) {
  return Wp(e, !1);
}
function Fl(e) {
  return Wp(e, !0);
}
function Wp(e, l) {
  return Vn(e) ? e : new xx(e, l);
}
class xx {
  constructor(l, i) {
    this.dep = new Zc(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = i ? l : Ln(l), this._value = i ? l : ql(l), this.__v_isShallow = i;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(l) {
    const i = this._rawValue, a = this.__v_isShallow || yt(l) || Zi(l);
    l = a ? l : Ln(l), Vl(l, i) && (this._rawValue = l, this._value = a ? l : ql(l), this.dep.trigger());
  }
}
function yx(e) {
  e.dep && e.dep.trigger();
}
function te(e) {
  return Vn(e) ? e.value : e;
}
function hn(e) {
  return sn(e) ? e() : te(e);
}
const Ix = {
  get: (e, l, i) => l === "__v_raw" ? e : te(Reflect.get(e, l, i)),
  set: (e, l, i, a) => {
    const s = e[l];
    return Vn(s) && !Vn(i) ? (s.value = i, !0) : Reflect.set(e, l, i, a);
  }
};
function $m(e) {
  return oi(e) ? e : new Proxy(e, Ix);
}
class Lx {
  constructor(l) {
    this.__v_isRef = !0, this._value = void 0;
    const i = this.dep = new Zc(), { get: a, set: s } = l(i.track.bind(i), i.trigger.bind(i));
    this._get = a, this._set = s;
  }
  get value() {
    return this._value = this._get();
  }
  set value(l) {
    this._set(l);
  }
}
function ja(e) {
  return new Lx(e);
}
function St(e) {
  const l = Xe(e) ? new Array(e.length) : {};
  for (const i in e)
    l[i] = Yp(e, i);
  return l;
}
class Dx {
  constructor(l, i, a) {
    this._object = l, this._key = i, this._defaultValue = a, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const l = this._object[this._key];
    return this._value = l === void 0 ? this._defaultValue : l;
  }
  set value(l) {
    this._object[this._key] = l;
  }
  get dep() {
    return nx(Ln(this._object), this._key);
  }
}
class Ox {
  constructor(l) {
    this._getter = l, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function hs(e, l, i) {
  return Vn(e) ? e : sn(e) ? new Ox(e) : _n(e) && arguments.length > 1 ? Yp(e, l, i) : Fe(e);
}
function Yp(e, l, i) {
  const a = e[l];
  return Vn(a) ? a : new Dx(e, l, i);
}
class bx {
  constructor(l, i, a) {
    this.fn = l, this.setter = i, this._value = void 0, this.dep = new Zc(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Qr - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !i, this.isSSR = a;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    $n !== this)
      return _p(this, !0), !0;
  }
  get value() {
    const l = this.dep.track();
    return Mp(this), l && (l.version = this.dep.version), this._value;
  }
  set value(l) {
    this.setter && this.setter(l);
  }
}
function wx(e, l, i = !1) {
  let a, s;
  return sn(e) ? a = e : (a = e.get, s = e.set), new bx(a, s, i);
}
const Sx = {
  GET: "get",
  HAS: "has",
  ITERATE: "iterate"
}, Cx = {
  SET: "set",
  ADD: "add",
  DELETE: "delete",
  CLEAR: "clear"
}, As = {}, fc = /* @__PURE__ */ new WeakMap();
let Nu;
function Tx() {
  return Nu;
}
function Xp(e, l = !1, i = Nu) {
  if (i) {
    let a = fc.get(i);
    a || fc.set(i, a = []), a.push(e);
  }
}
function Px(e, l, i = On) {
  const { immediate: a, deep: s, once: o, scheduler: f, augmentJob: d, call: h } = i, x = (K) => s ? K : yt(K) || s === !1 || s === 0 ? Ei(K, 1) : Ei(K);
  let y, I, q, R, E = !1, M = !1;
  if (Vn(e) ? (I = () => e.value, E = yt(e)) : oi(e) ? (I = () => x(e), E = !0) : Xe(e) ? (M = !0, E = e.some((K) => oi(K) || yt(K)), I = () => e.map((K) => {
    if (Vn(K))
      return K.value;
    if (oi(K))
      return x(K);
    if (sn(K))
      return h ? h(K, 2) : K();
  })) : sn(e) ? l ? I = h ? () => h(e, 2) : e : I = () => {
    if (q) {
      ki();
      try {
        q();
      } finally {
        Vi();
      }
    }
    const K = Nu;
    Nu = y;
    try {
      return h ? h(e, 3, [R]) : e(R);
    } finally {
      Nu = K;
    }
  } : I = bt, l && s) {
    const K = I, W = s === !0 ? 1 / 0 : s;
    I = () => Ei(K(), W);
  }
  const U = $i(), z = () => {
    y.stop(), U && U.active && Zm(U.effects, y);
  };
  if (o && l) {
    const K = l;
    l = (...W) => {
      K(...W), z();
    };
  }
  let X = M ? new Array(e.length).fill(As) : As;
  const B = (K) => {
    if (!(!(y.flags & 1) || !y.dirty && !K))
      if (l) {
        const W = y.run();
        if (s || E || (M ? W.some((ae, ne) => Vl(ae, X[ne])) : Vl(W, X))) {
          q && q();
          const ae = Nu;
          Nu = y;
          try {
            const ne = [
              W,
              // pass undefined as the old value when it's changed for the first time
              X === As ? void 0 : M && X[0] === As ? [] : X,
              R
            ];
            X = W, h ? h(l, 3, ne) : (
              // @ts-expect-error
              l(...ne)
            );
          } finally {
            Nu = ae;
          }
        }
      } else
        y.run();
  };
  return d && d(B), y = new Xr(I), y.scheduler = f ? () => f(B, !1) : B, R = (K) => Xp(K, !1, y), q = y.onStop = () => {
    const K = fc.get(y);
    if (K) {
      if (h)
        h(K, 4);
      else
        for (const W of K) W();
      fc.delete(y);
    }
  }, l ? a ? B(!0) : X = y.run() : f ? f(B.bind(null, !0), !0) : y.run(), z.pause = y.pause.bind(y), z.resume = y.resume.bind(y), z.stop = z, z;
}
function Ei(e, l = 1 / 0, i) {
  if (l <= 0 || !_n(e) || e.__v_skip || (i = i || /* @__PURE__ */ new Map(), (i.get(e) || 0) >= l))
    return e;
  if (i.set(e, l), l--, Vn(e))
    Ei(e.value, l, i);
  else if (Xe(e))
    for (let a = 0; a < e.length; a++)
      Ei(e[a], l, i);
  else if (sa(e) || Ta(e))
    e.forEach((a) => {
      Ei(a, l, i);
    });
  else if (Nc(e)) {
    for (const a in e)
      Ei(e[a], l, i);
    for (const a of Object.getOwnPropertySymbols(e))
      Object.prototype.propertyIsEnumerable.call(e, a) && Ei(e[a], l, i);
  }
  return e;
}
const Qp = [];
function qx(e) {
  Qp.push(e);
}
function Rx() {
  Qp.pop();
}
function Ax(e, l) {
}
const Ex = {
  SETUP_FUNCTION: 0,
  0: "SETUP_FUNCTION",
  RENDER_FUNCTION: 1,
  1: "RENDER_FUNCTION",
  NATIVE_EVENT_HANDLER: 5,
  5: "NATIVE_EVENT_HANDLER",
  COMPONENT_EVENT_HANDLER: 6,
  6: "COMPONENT_EVENT_HANDLER",
  VNODE_HOOK: 7,
  7: "VNODE_HOOK",
  DIRECTIVE_HOOK: 8,
  8: "DIRECTIVE_HOOK",
  TRANSITION_HOOK: 9,
  9: "TRANSITION_HOOK",
  APP_ERROR_HANDLER: 10,
  10: "APP_ERROR_HANDLER",
  APP_WARN_HANDLER: 11,
  11: "APP_WARN_HANDLER",
  FUNCTION_REF: 12,
  12: "FUNCTION_REF",
  ASYNC_COMPONENT_LOADER: 13,
  13: "ASYNC_COMPONENT_LOADER",
  SCHEDULER: 14,
  14: "SCHEDULER",
  COMPONENT_UPDATE: 15,
  15: "COMPONENT_UPDATE",
  APP_UNMOUNT_CLEANUP: 16,
  16: "APP_UNMOUNT_CLEANUP"
}, _x = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function"
};
function Ha(e, l, i, a) {
  try {
    return a ? e(...a) : e();
  } catch (s) {
    oa(s, l, i);
  }
}
function Ct(e, l, i, a) {
  if (sn(e)) {
    const s = Ha(e, l, i, a);
    return s && Um(s) && s.catch((o) => {
      oa(o, l, i);
    }), s;
  }
  if (Xe(e)) {
    const s = [];
    for (let o = 0; o < e.length; o++)
      s.push(Ct(e[o], l, i, a));
    return s;
  }
}
function oa(e, l, i, a = !0) {
  const s = l ? l.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: f } = l && l.appContext.config || On;
  if (l) {
    let d = l.parent;
    const h = l.proxy, x = `https://vuejs.org/error-reference/#runtime-${i}`;
    for (; d; ) {
      const y = d.ec;
      if (y) {
        for (let I = 0; I < y.length; I++)
          if (y[I](e, h, x) === !1)
            return;
      }
      d = d.parent;
    }
    if (o) {
      ki(), Ha(o, null, 10, [
        e,
        h,
        x
      ]), Vi();
      return;
    }
  }
  Nx(e, i, s, a, f);
}
function Nx(e, l, i, a = !0, s = !1) {
  if (s)
    throw e;
  console.error(e);
}
const Zl = [];
let Ii = -1;
const Aa = [];
let Fu = null, Da = 0;
const Jp = /* @__PURE__ */ Promise.resolve();
let dc = null;
function il(e) {
  const l = dc || Jp;
  return e ? l.then(this ? e.bind(this) : e) : l;
}
function Fx(e) {
  let l = Ii + 1, i = Zl.length;
  for (; l < i; ) {
    const a = l + i >>> 1, s = Zl[a], o = ns(s);
    o < e || o === e && s.flags & 2 ? l = a + 1 : i = a;
  }
  return l;
}
function Wm(e) {
  if (!(e.flags & 1)) {
    const l = ns(e), i = Zl[Zl.length - 1];
    !i || // fast path when the job id is larger than the tail
    !(e.flags & 2) && l >= ns(i) ? Zl.push(e) : Zl.splice(Fx(l), 0, e), e.flags |= 1, eh();
  }
}
function eh() {
  dc || (dc = Jp.then(nh));
}
function es(e) {
  Xe(e) ? Aa.push(...e) : Fu && e.id === -1 ? Fu.splice(Da + 1, 0, e) : e.flags & 1 || (Aa.push(e), e.flags |= 1), eh();
}
function Ff(e, l, i = Ii + 1) {
  for (; i < Zl.length; i++) {
    const a = Zl[i];
    if (a && a.flags & 2) {
      if (e && a.id !== e.uid)
        continue;
      Zl.splice(i, 1), i--, a.flags & 4 && (a.flags &= -2), a(), a.flags & 4 || (a.flags &= -2);
    }
  }
}
function pc(e) {
  if (Aa.length) {
    const l = [...new Set(Aa)].sort(
      (i, a) => ns(i) - ns(a)
    );
    if (Aa.length = 0, Fu) {
      Fu.push(...l);
      return;
    }
    for (Fu = l, Da = 0; Da < Fu.length; Da++) {
      const i = Fu[Da];
      i.flags & 4 && (i.flags &= -2), i.flags & 8 || i(), i.flags &= -2;
    }
    Fu = null, Da = 0;
  }
}
const ns = (e) => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;
function nh(e) {
  try {
    for (Ii = 0; Ii < Zl.length; Ii++) {
      const l = Zl[Ii];
      l && !(l.flags & 8) && (l.flags & 4 && (l.flags &= -2), Ha(
        l,
        l.i,
        l.i ? 15 : 14
      ), l.flags & 4 || (l.flags &= -2));
    }
  } finally {
    for (; Ii < Zl.length; Ii++) {
      const l = Zl[Ii];
      l && (l.flags &= -2);
    }
    Ii = -1, Zl.length = 0, pc(), dc = null, (Zl.length || Aa.length) && nh();
  }
}
let Oa, Es = [];
function lh(e, l) {
  var i, a;
  Oa = e, Oa ? (Oa.enabled = !0, Es.forEach(({ event: s, args: o }) => Oa.emit(s, ...o)), Es = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((a = (i = window.navigator) == null ? void 0 : i.userAgent) != null && a.includes("jsdom")) ? ((l.__VUE_DEVTOOLS_HOOK_REPLAY__ = l.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((o) => {
    lh(o, l);
  }), setTimeout(() => {
    Oa || (l.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Es = []);
  }, 3e3)) : Es = [];
}
let Al = null, jc = null;
function ls(e) {
  const l = Al;
  return Al = e, jc = e && e.type.__scopeId || null, l;
}
function Mx(e) {
  jc = e;
}
function kx() {
  jc = null;
}
const Vx = (e) => ln;
function ln(e, l = Al, i) {
  if (!l || e._n)
    return e;
  const a = (...s) => {
    a._d && us(-1);
    const o = ls(l);
    let f;
    try {
      f = e(...s);
    } finally {
      ls(o), a._d && us(1);
    }
    return f;
  };
  return a._n = !0, a._c = !0, a._d = !0, a;
}
function Bx(e, l) {
  if (Al === null)
    return e;
  const i = Ls(Al), a = e.dirs || (e.dirs = []);
  for (let s = 0; s < l.length; s++) {
    let [o, f, d, h = On] = l[s];
    o && (sn(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Ei(f), a.push({
      dir: o,
      instance: i,
      value: f,
      oldValue: void 0,
      arg: d,
      modifiers: h
    }));
  }
  return e;
}
function Li(e, l, i, a) {
  const s = e.dirs, o = l && l.dirs;
  for (let f = 0; f < s.length; f++) {
    const d = s[f];
    o && (d.oldValue = o[f].value);
    let h = d.dir[a];
    h && (ki(), Ct(h, i, 8, [
      e.el,
      d,
      e,
      l
    ]), Vi());
  }
}
const th = Symbol("_vte"), ih = (e) => e.__isTeleport, Ur = (e) => e && (e.disabled || e.disabled === ""), Mf = (e) => e && (e.defer || e.defer === ""), kf = (e) => typeof SVGElement < "u" && e instanceof SVGElement, Vf = (e) => typeof MathMLElement == "function" && e instanceof MathMLElement, im = (e, l) => {
  const i = e && e.to;
  return Wn(i) ? l ? l(i) : null : i;
}, uh = {
  name: "Teleport",
  __isTeleport: !0,
  process(e, l, i, a, s, o, f, d, h, x) {
    const {
      mc: y,
      pc: I,
      pbc: q,
      o: { insert: R, querySelector: E, createText: M, createComment: U }
    } = x, z = Ur(l.props);
    let { shapeFlag: X, children: B, dynamicChildren: K } = l;
    if (e == null) {
      const W = l.el = M(""), ae = l.anchor = M("");
      R(W, i, a), R(ae, i, a);
      const ne = (k, me) => {
        X & 16 && y(
          B,
          k,
          me,
          s,
          o,
          f,
          d,
          h
        );
      }, oe = () => {
        const k = l.target = im(l.props, E), me = ah(k, l, M, R);
        k && (f !== "svg" && kf(k) ? f = "svg" : f !== "mathml" && Vf(k) && (f = "mathml"), s && s.isCE && (s.ce._teleportTargets || (s.ce._teleportTargets = /* @__PURE__ */ new Set())).add(k), z || (ne(k, me), ec(l, !1)));
      };
      z && (ne(i, ae), ec(l, !0)), Mf(l.props) ? (l.el.__isMounted = !1, hl(() => {
        oe(), delete l.el.__isMounted;
      }, o)) : oe();
    } else {
      if (Mf(l.props) && e.el.__isMounted === !1) {
        hl(() => {
          uh.process(
            e,
            l,
            i,
            a,
            s,
            o,
            f,
            d,
            h,
            x
          );
        }, o);
        return;
      }
      l.el = e.el, l.targetStart = e.targetStart;
      const W = l.anchor = e.anchor, ae = l.target = e.target, ne = l.targetAnchor = e.targetAnchor, oe = Ur(e.props), k = oe ? i : ae, me = oe ? W : ne;
      if (f === "svg" || kf(ae) ? f = "svg" : (f === "mathml" || Vf(ae)) && (f = "mathml"), K ? (q(
        e.dynamicChildren,
        K,
        k,
        s,
        o,
        f,
        d
      ), sf(e, l, !0)) : h || I(
        e,
        l,
        k,
        me,
        s,
        o,
        f,
        d,
        !1
      ), z)
        oe ? l.props && e.props && l.props.to !== e.props.to && (l.props.to = e.props.to) : _s(
          l,
          i,
          W,
          x,
          1
        );
      else if ((l.props && l.props.to) !== (e.props && e.props.to)) {
        const be = l.target = im(
          l.props,
          E
        );
        be && _s(
          l,
          be,
          null,
          x,
          0
        );
      } else oe && _s(
        l,
        ae,
        ne,
        x,
        1
      );
      ec(l, z);
    }
  },
  remove(e, l, i, { um: a, o: { remove: s } }, o) {
    const {
      shapeFlag: f,
      children: d,
      anchor: h,
      targetStart: x,
      targetAnchor: y,
      target: I,
      props: q
    } = e;
    if (I && (s(x), s(y)), o && s(h), f & 16) {
      const R = o || !Ur(q);
      for (let E = 0; E < d.length; E++) {
        const M = d[E];
        a(
          M,
          l,
          i,
          R,
          !!M.dynamicChildren
        );
      }
    }
  },
  move: _s,
  hydrate: Zx
};
function _s(e, l, i, { o: { insert: a }, m: s }, o = 2) {
  o === 0 && a(e.targetAnchor, l, i);
  const { el: f, anchor: d, shapeFlag: h, children: x, props: y } = e, I = o === 2;
  if (I && a(f, l, i), (!I || Ur(y)) && h & 16)
    for (let q = 0; q < x.length; q++)
      s(
        x[q],
        l,
        i,
        2
      );
  I && a(d, l, i);
}
function Zx(e, l, i, a, s, o, {
  o: { nextSibling: f, parentNode: d, querySelector: h, insert: x, createText: y }
}, I) {
  function q(M, U, z, X) {
    U.anchor = I(
      f(M),
      U,
      d(M),
      i,
      a,
      s,
      o
    ), U.targetStart = z, U.targetAnchor = X;
  }
  const R = l.target = im(
    l.props,
    h
  ), E = Ur(l.props);
  if (R) {
    const M = R._lpa || R.firstChild;
    if (l.shapeFlag & 16)
      if (E)
        q(
          e,
          l,
          M,
          M && f(M)
        );
      else {
        l.anchor = f(e);
        let U = M;
        for (; U; ) {
          if (U && U.nodeType === 8) {
            if (U.data === "teleport start anchor")
              l.targetStart = U;
            else if (U.data === "teleport anchor") {
              l.targetAnchor = U, R._lpa = l.targetAnchor && f(l.targetAnchor);
              break;
            }
          }
          U = f(U);
        }
        l.targetAnchor || ah(R, l, y, x), I(
          M && f(M),
          l,
          R,
          i,
          a,
          s,
          o
        );
      }
    ec(l, E);
  } else E && l.shapeFlag & 16 && q(e, l, e, f(e));
  return l.anchor && f(l.anchor);
}
const Ux = uh;
function ec(e, l) {
  const i = e.ctx;
  if (i && i.ut) {
    let a, s;
    for (l ? (a = e.el, s = e.anchor) : (a = e.targetStart, s = e.targetAnchor); a && a !== s; )
      a.nodeType === 1 && a.setAttribute("data-v-owner", i.uid), a = a.nextSibling;
    i.ut();
  }
}
function ah(e, l, i, a) {
  const s = l.targetStart = i(""), o = l.targetAnchor = i("");
  return s[th] = o, e && (a(s, e), a(o, e)), o;
}
const qi = Symbol("_leaveCb"), Ns = Symbol("_enterCb");
function Ym() {
  const e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return vl(() => {
    e.isMounted = !0;
  }), vs(() => {
    e.isUnmounting = !0;
  }), e;
}
const Ot = [Function, Array], Xm = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: Ot,
  onEnter: Ot,
  onAfterEnter: Ot,
  onEnterCancelled: Ot,
  // leave
  onBeforeLeave: Ot,
  onLeave: Ot,
  onAfterLeave: Ot,
  onLeaveCancelled: Ot,
  // appear
  onBeforeAppear: Ot,
  onAppear: Ot,
  onAfterAppear: Ot,
  onAppearCancelled: Ot
}, rh = (e) => {
  const l = e.subTree;
  return l.component ? rh(l.component) : l;
}, Kx = {
  name: "BaseTransition",
  props: Xm,
  setup(e, { slots: l }) {
    const i = Xn(), a = Ym();
    return () => {
      const s = l.default && Hc(l.default(), !0);
      if (!s || !s.length)
        return;
      const o = sh(s), f = Ln(e), { mode: d } = f;
      if (a.isLeaving)
        return Lo(o);
      const h = Bf(o);
      if (!h)
        return Lo(o);
      let x = Fa(
        h,
        f,
        a,
        i,
        // #11061, ensure enterHooks is fresh after clone
        (I) => x = I
      );
      h.type !== ul && Ui(h, x);
      let y = i.subTree && Bf(i.subTree);
      if (y && y.type !== ul && !ri(y, h) && rh(i).type !== ul) {
        let I = Fa(
          y,
          f,
          a,
          i
        );
        if (Ui(y, I), d === "out-in" && h.type !== ul)
          return a.isLeaving = !0, I.afterLeave = () => {
            a.isLeaving = !1, i.job.flags & 8 || i.update(), delete I.afterLeave, y = void 0;
          }, Lo(o);
        d === "in-out" && h.type !== ul ? I.delayLeave = (q, R, E) => {
          const M = oh(
            a,
            y
          );
          M[String(y.key)] = y, q[qi] = () => {
            R(), q[qi] = void 0, delete x.delayedLeave, y = void 0;
          }, x.delayedLeave = () => {
            E(), delete x.delayedLeave, y = void 0;
          };
        } : y = void 0;
      } else y && (y = void 0);
      return o;
    };
  }
};
function sh(e) {
  let l = e[0];
  if (e.length > 1) {
    for (const i of e)
      if (i.type !== ul) {
        l = i;
        break;
      }
  }
  return l;
}
const ch = Kx;
function oh(e, l) {
  const { leavingVNodes: i } = e;
  let a = i.get(l.type);
  return a || (a = /* @__PURE__ */ Object.create(null), i.set(l.type, a)), a;
}
function Fa(e, l, i, a, s) {
  const {
    appear: o,
    mode: f,
    persisted: d = !1,
    onBeforeEnter: h,
    onEnter: x,
    onAfterEnter: y,
    onEnterCancelled: I,
    onBeforeLeave: q,
    onLeave: R,
    onAfterLeave: E,
    onLeaveCancelled: M,
    onBeforeAppear: U,
    onAppear: z,
    onAfterAppear: X,
    onAppearCancelled: B
  } = l, K = String(e.key), W = oh(i, e), ae = (k, me) => {
    k && Ct(
      k,
      a,
      9,
      me
    );
  }, ne = (k, me) => {
    const be = me[1];
    ae(k, me), Xe(k) ? k.every((re) => re.length <= 1) && be() : k.length <= 1 && be();
  }, oe = {
    mode: f,
    persisted: d,
    beforeEnter(k) {
      let me = h;
      if (!i.isMounted)
        if (o)
          me = U || h;
        else
          return;
      k[qi] && k[qi](
        !0
        /* cancelled */
      );
      const be = W[K];
      be && ri(e, be) && be.el[qi] && be.el[qi](), ae(me, [k]);
    },
    enter(k) {
      let me = x, be = y, re = I;
      if (!i.isMounted)
        if (o)
          me = z || x, be = X || y, re = B || I;
        else
          return;
      let ye = !1;
      const xe = k[Ns] = (Se) => {
        ye || (ye = !0, Se ? ae(re, [k]) : ae(be, [k]), oe.delayedLeave && oe.delayedLeave(), k[Ns] = void 0);
      };
      me ? ne(me, [k, xe]) : xe();
    },
    leave(k, me) {
      const be = String(e.key);
      if (k[Ns] && k[Ns](
        !0
        /* cancelled */
      ), i.isUnmounting)
        return me();
      ae(q, [k]);
      let re = !1;
      const ye = k[qi] = (xe) => {
        re || (re = !0, me(), xe ? ae(M, [k]) : ae(E, [k]), k[qi] = void 0, W[be] === e && delete W[be]);
      };
      W[be] = e, R ? ne(R, [k, ye]) : ye();
    },
    clone(k) {
      const me = Fa(
        k,
        l,
        i,
        a,
        s
      );
      return s && s(me), me;
    }
  };
  return oe;
}
function Lo(e) {
  if (gs(e))
    return e = di(e), e.children = null, e;
}
function Bf(e) {
  if (!gs(e))
    return ih(e.type) && e.children ? sh(e.children) : e;
  if (e.component)
    return e.component.subTree;
  const { shapeFlag: l, children: i } = e;
  if (i) {
    if (l & 16)
      return i[0];
    if (l & 32 && sn(i.default))
      return i.default();
  }
}
function Ui(e, l) {
  e.shapeFlag & 6 && e.component ? (e.transition = l, Ui(e.component.subTree, l)) : e.shapeFlag & 128 ? (e.ssContent.transition = l.clone(e.ssContent), e.ssFallback.transition = l.clone(e.ssFallback)) : e.transition = l;
}
function Hc(e, l = !1, i) {
  let a = [], s = 0;
  for (let o = 0; o < e.length; o++) {
    let f = e[o];
    const d = i == null ? f.key : String(i) + String(f.key != null ? f.key : o);
    f.type === Mn ? (f.patchFlag & 128 && s++, a = a.concat(
      Hc(f.children, l, d)
    )) : (l || f.type !== ul) && a.push(d != null ? di(f, { key: d }) : f);
  }
  if (s > 1)
    for (let o = 0; o < a.length; o++)
      a[o].patchFlag = -2;
  return a;
}
// @__NO_SIDE_EFFECTS__
function dn(e, l) {
  return sn(e) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    kn({ name: e.name }, l, { setup: e })
  ) : e;
}
function mh() {
  const e = Xn();
  return e ? (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++ : "";
}
function Qm(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
}
function Jm(e) {
  const l = Xn(), i = Fl(null);
  if (l) {
    const s = l.refs === On ? l.refs = {} : l.refs;
    Object.defineProperty(s, e, {
      enumerable: !0,
      get: () => i.value,
      set: (o) => i.value = o
    });
  }
  return i;
}
const hc = /* @__PURE__ */ new WeakMap();
function Ea(e, l, i, a, s = !1) {
  if (Xe(e)) {
    e.forEach(
      (E, M) => Ea(
        E,
        l && (Xe(l) ? l[M] : l),
        i,
        a,
        s
      )
    );
    return;
  }
  if (Bu(a) && !s) {
    a.shapeFlag & 512 && a.type.__asyncResolved && a.component.subTree.component && Ea(e, l, i, a.component.subTree);
    return;
  }
  const o = a.shapeFlag & 4 ? Ls(a.component) : a.el, f = s ? null : o, { i: d, r: h } = e, x = l && l.r, y = d.refs === On ? d.refs = {} : d.refs, I = d.setupState, q = Ln(I), R = I === On ? Cp : (E) => Pn(q, E);
  if (x != null && x !== h) {
    if (Zf(l), Wn(x))
      y[x] = null, R(x) && (I[x] = null);
    else if (Vn(x)) {
      x.value = null;
      const E = l;
      E.k && (y[E.k] = null);
    }
  }
  if (sn(h))
    Ha(h, d, 12, [f, y]);
  else {
    const E = Wn(h), M = Vn(h);
    if (E || M) {
      const U = () => {
        if (e.f) {
          const z = E ? R(h) ? I[h] : y[h] : h.value;
          if (s)
            Xe(z) && Zm(z, o);
          else if (Xe(z))
            z.includes(o) || z.push(o);
          else if (E)
            y[h] = [o], R(h) && (I[h] = y[h]);
          else {
            const X = [o];
            h.value = X, e.k && (y[e.k] = X);
          }
        } else E ? (y[h] = f, R(h) && (I[h] = f)) : M && (h.value = f, e.k && (y[e.k] = f));
      };
      if (f) {
        const z = () => {
          U(), hc.delete(e);
        };
        z.id = -1, hc.set(e, z), hl(z, i);
      } else
        Zf(e), U();
    }
  }
}
function Zf(e) {
  const l = hc.get(e);
  l && (l.flags |= 8, hc.delete(e));
}
let Uf = !1;
const va = () => {
  Uf || (console.error("Hydration completed but contains mismatches."), Uf = !0);
}, Gx = (e) => e.namespaceURI.includes("svg") && e.tagName !== "foreignObject", zx = (e) => e.namespaceURI.includes("MathML"), Fs = (e) => {
  if (e.nodeType === 1) {
    if (Gx(e)) return "svg";
    if (zx(e)) return "mathml";
  }
}, wa = (e) => e.nodeType === 8;
function jx(e) {
  const {
    mt: l,
    p: i,
    o: {
      patchProp: a,
      createText: s,
      nextSibling: o,
      parentNode: f,
      remove: d,
      insert: h,
      createComment: x
    }
  } = e, y = (B, K) => {
    if (!K.hasChildNodes()) {
      i(null, B, K), pc(), K._vnode = B;
      return;
    }
    I(K.firstChild, B, null, null, null), pc(), K._vnode = B;
  }, I = (B, K, W, ae, ne, oe = !1) => {
    oe = oe || !!K.dynamicChildren;
    const k = wa(B) && B.data === "[", me = () => M(
      B,
      K,
      W,
      ae,
      ne,
      k
    ), { type: be, ref: re, shapeFlag: ye, patchFlag: xe } = K;
    let Se = B.nodeType;
    K.el = B, xe === -2 && (oe = !1, K.dynamicChildren = null);
    let ge = null;
    switch (be) {
      case Zu:
        Se !== 3 ? K.children === "" ? (h(K.el = s(""), f(B), B), ge = B) : ge = me() : (B.data !== K.children && (va(), B.data = K.children), ge = o(B));
        break;
      case ul:
        X(B) ? (ge = o(B), z(
          K.el = B.content.firstChild,
          B,
          W
        )) : Se !== 8 || k ? ge = me() : ge = o(B);
        break;
      case ia:
        if (k && (B = o(B), Se = B.nodeType), Se === 1 || Se === 3) {
          ge = B;
          const ce = !K.children.length;
          for (let de = 0; de < K.staticCount; de++)
            ce && (K.children += ge.nodeType === 1 ? ge.outerHTML : ge.data), de === K.staticCount - 1 && (K.anchor = ge), ge = o(ge);
          return k ? o(ge) : ge;
        } else
          me();
        break;
      case Mn:
        k ? ge = E(
          B,
          K,
          W,
          ae,
          ne,
          oe
        ) : ge = me();
        break;
      default:
        if (ye & 1)
          (Se !== 1 || K.type.toLowerCase() !== B.tagName.toLowerCase()) && !X(B) ? ge = me() : ge = q(
            B,
            K,
            W,
            ae,
            ne,
            oe
          );
        else if (ye & 6) {
          K.slotScopeIds = ne;
          const ce = f(B);
          if (k ? ge = U(B) : wa(B) && B.data === "teleport start" ? ge = U(B, B.data, "teleport end") : ge = o(B), l(
            K,
            ce,
            null,
            W,
            ae,
            Fs(ce),
            oe
          ), Bu(K) && !K.type.__asyncResolved) {
            let de;
            k ? (de = ze(Mn), de.anchor = ge ? ge.previousSibling : ce.lastChild) : de = B.nodeType === 3 ? Gi("") : ze("div"), de.el = B, K.component.subTree = de;
          }
        } else ye & 64 ? Se !== 8 ? ge = me() : ge = K.type.hydrate(
          B,
          K,
          W,
          ae,
          ne,
          oe,
          e,
          R
        ) : ye & 128 && (ge = K.type.hydrate(
          B,
          K,
          W,
          ae,
          Fs(f(B)),
          ne,
          oe,
          e,
          I
        ));
    }
    return re != null && Ea(re, null, ae, K), ge;
  }, q = (B, K, W, ae, ne, oe) => {
    oe = oe || !!K.dynamicChildren;
    const { type: k, props: me, patchFlag: be, shapeFlag: re, dirs: ye, transition: xe } = K, Se = k === "input" || k === "option";
    if (Se || be !== -1) {
      ye && Li(K, null, W, "created");
      let ge = !1;
      if (X(B)) {
        ge = Fh(
          null,
          // no need check parentSuspense in hydration
          xe
        ) && W && W.vnode.props && W.vnode.props.appear;
        const de = B.content.firstChild;
        if (ge) {
          const Le = de.getAttribute("class");
          Le && (de.$cls = Le), xe.beforeEnter(de);
        }
        z(de, B, W), K.el = B = de;
      }
      if (re & 16 && // skip if element has innerHTML / textContent
      !(me && (me.innerHTML || me.textContent))) {
        let de = R(
          B.firstChild,
          K,
          B,
          W,
          ae,
          ne,
          oe
        );
        for (; de; ) {
          Ms(
            B,
            1
            /* CHILDREN */
          ) || va();
          const Le = de;
          de = de.nextSibling, d(Le);
        }
      } else if (re & 8) {
        let de = K.children;
        de[0] === `
` && (B.tagName === "PRE" || B.tagName === "TEXTAREA") && (de = de.slice(1)), B.textContent !== de && (Ms(
          B,
          0
          /* TEXT */
        ) || va(), B.textContent = K.children);
      }
      if (me) {
        if (Se || !oe || be & 48) {
          const de = B.tagName.includes("-");
          for (const Le in me)
            (Se && (Le.endsWith("value") || Le === "indeterminate") || ds(Le) && !Pa(Le) || // force hydrate v-bind with .prop modifiers
            Le[0] === "." || de) && a(B, Le, null, me[Le], void 0, W);
        } else if (me.onClick)
          a(
            B,
            "onClick",
            null,
            me.onClick,
            void 0,
            W
          );
        else if (be & 4 && oi(me.style))
          for (const de in me.style) me.style[de];
      }
      let ce;
      (ce = me && me.onVnodeBeforeMount) && dt(ce, W, K), ye && Li(K, null, W, "beforeMount"), ((ce = me && me.onVnodeMounted) || ye || ge) && Gh(() => {
        ce && dt(ce, W, K), ge && xe.enter(B), ye && Li(K, null, W, "mounted");
      }, ae);
    }
    return B.nextSibling;
  }, R = (B, K, W, ae, ne, oe, k) => {
    k = k || !!K.dynamicChildren;
    const me = K.children, be = me.length;
    for (let re = 0; re < be; re++) {
      const ye = k ? me[re] : me[re] = pt(me[re]), xe = ye.type === Zu;
      B ? (xe && !k && re + 1 < be && pt(me[re + 1]).type === Zu && (h(
        s(
          B.data.slice(ye.children.length)
        ),
        W,
        o(B)
      ), B.data = ye.children), B = I(
        B,
        ye,
        ae,
        ne,
        oe,
        k
      )) : xe && !ye.children ? h(ye.el = s(""), W) : (Ms(
        W,
        1
        /* CHILDREN */
      ) || va(), i(
        null,
        ye,
        W,
        null,
        ae,
        ne,
        Fs(W),
        oe
      ));
    }
    return B;
  }, E = (B, K, W, ae, ne, oe) => {
    const { slotScopeIds: k } = K;
    k && (ne = ne ? ne.concat(k) : k);
    const me = f(B), be = R(
      o(B),
      K,
      me,
      W,
      ae,
      ne,
      oe
    );
    return be && wa(be) && be.data === "]" ? o(K.anchor = be) : (va(), h(K.anchor = x("]"), me, be), be);
  }, M = (B, K, W, ae, ne, oe) => {
    if (Ms(
      B.parentElement,
      1
      /* CHILDREN */
    ) || va(), K.el = null, oe) {
      const be = U(B);
      for (; ; ) {
        const re = o(B);
        if (re && re !== be)
          d(re);
        else
          break;
      }
    }
    const k = o(B), me = f(B);
    return d(B), i(
      null,
      K,
      me,
      k,
      W,
      ae,
      Fs(me),
      ne
    ), W && (W.vnode.el = K.el, Jc(W, K.el)), k;
  }, U = (B, K = "[", W = "]") => {
    let ae = 0;
    for (; B; )
      if (B = o(B), B && wa(B) && (B.data === K && ae++, B.data === W)) {
        if (ae === 0)
          return o(B);
        ae--;
      }
    return B;
  }, z = (B, K, W) => {
    const ae = K.parentNode;
    ae && ae.replaceChild(B, K);
    let ne = W;
    for (; ne; )
      ne.vnode.el === K && (ne.vnode.el = ne.subTree.el = B), ne = ne.parent;
  }, X = (B) => B.nodeType === 1 && B.tagName === "TEMPLATE";
  return [y, I];
}
const Kf = "data-allow-mismatch", Hx = {
  0: "text",
  1: "children",
  2: "class",
  3: "style",
  4: "attribute"
};
function Ms(e, l) {
  if (l === 0 || l === 1)
    for (; e && !e.hasAttribute(Kf); )
      e = e.parentElement;
  const i = e && e.getAttribute(Kf);
  if (i == null)
    return !1;
  if (i === "")
    return !0;
  {
    const a = i.split(",");
    return l === 0 && a.includes("children") ? !0 : a.includes(Hx[l]);
  }
}
const $x = Mc().requestIdleCallback || ((e) => setTimeout(e, 1)), Wx = Mc().cancelIdleCallback || ((e) => clearTimeout(e)), Yx = (e = 1e4) => (l) => {
  const i = $x(l, { timeout: e });
  return () => Wx(i);
};
function Xx(e) {
  const { top: l, left: i, bottom: a, right: s } = e.getBoundingClientRect(), { innerHeight: o, innerWidth: f } = window;
  return (l > 0 && l < o || a > 0 && a < o) && (i > 0 && i < f || s > 0 && s < f);
}
const Qx = (e) => (l, i) => {
  const a = new IntersectionObserver((s) => {
    for (const o of s)
      if (o.isIntersecting) {
        a.disconnect(), l();
        break;
      }
  }, e);
  return i((s) => {
    if (s instanceof Element) {
      if (Xx(s))
        return l(), a.disconnect(), !1;
      a.observe(s);
    }
  }), () => a.disconnect();
}, Jx = (e) => (l) => {
  if (e) {
    const i = matchMedia(e);
    if (i.matches)
      l();
    else
      return i.addEventListener("change", l, { once: !0 }), () => i.removeEventListener("change", l);
  }
}, ey = (e = []) => (l, i) => {
  Wn(e) && (e = [e]);
  let a = !1;
  const s = (f) => {
    a || (a = !0, o(), l(), f.target.dispatchEvent(new f.constructor(f.type, f)));
  }, o = () => {
    i((f) => {
      for (const d of e)
        f.removeEventListener(d, s);
    });
  };
  return i((f) => {
    for (const d of e)
      f.addEventListener(d, s, { once: !0 });
  }), o;
};
function ny(e, l) {
  if (wa(e) && e.data === "[") {
    let i = 1, a = e.nextSibling;
    for (; a; ) {
      if (a.nodeType === 1) {
        if (l(a) === !1)
          break;
      } else if (wa(a))
        if (a.data === "]") {
          if (--i === 0) break;
        } else a.data === "[" && i++;
      a = a.nextSibling;
    }
  } else
    l(e);
}
const Bu = (e) => !!e.type.__asyncLoader;
// @__NO_SIDE_EFFECTS__
function ly(e) {
  sn(e) && (e = { loader: e });
  const {
    loader: l,
    loadingComponent: i,
    errorComponent: a,
    delay: s = 200,
    hydrate: o,
    timeout: f,
    // undefined = never times out
    suspensible: d = !0,
    onError: h
  } = e;
  let x = null, y, I = 0;
  const q = () => (I++, x = null, R()), R = () => {
    let E;
    return x || (E = x = l().catch((M) => {
      if (M = M instanceof Error ? M : new Error(String(M)), h)
        return new Promise((U, z) => {
          h(M, () => U(q()), () => z(M), I + 1);
        });
      throw M;
    }).then((M) => E !== x && x ? x : (M && (M.__esModule || M[Symbol.toStringTag] === "Module") && (M = M.default), y = M, M)));
  };
  return /* @__PURE__ */ dn({
    name: "AsyncComponentWrapper",
    __asyncLoader: R,
    __asyncHydrate(E, M, U) {
      let z = !1;
      (M.bu || (M.bu = [])).push(() => z = !0);
      const X = () => {
        z || U();
      }, B = o ? () => {
        const K = o(
          X,
          (W) => ny(E, W)
        );
        K && (M.bum || (M.bum = [])).push(K);
      } : X;
      y ? B() : R().then(() => !M.isUnmounted && B());
    },
    get __asyncResolved() {
      return y;
    },
    setup() {
      const E = Rl;
      if (Qm(E), y)
        return () => Do(y, E);
      const M = (B) => {
        x = null, oa(
          B,
          E,
          13,
          !a
        );
      };
      if (d && E.suspense || Ma)
        return R().then((B) => () => Do(B, E)).catch((B) => (M(B), () => a ? ze(a, {
          error: B
        }) : null));
      const U = Fe(!1), z = Fe(), X = Fe(!!s);
      return s && setTimeout(() => {
        X.value = !1;
      }, s), f != null && setTimeout(() => {
        if (!U.value && !z.value) {
          const B = new Error(
            `Async component timed out after ${f}ms.`
          );
          M(B), z.value = B;
        }
      }, f), R().then(() => {
        U.value = !0, E.parent && gs(E.parent.vnode) && E.parent.update();
      }).catch((B) => {
        M(B), z.value = B;
      }), () => {
        if (U.value && y)
          return Do(y, E);
        if (z.value && a)
          return ze(a, {
            error: z.value
          });
        if (i && !X.value)
          return ze(i);
      };
    }
  });
}
function Do(e, l) {
  const { ref: i, props: a, children: s, ce: o } = l.vnode, f = ze(e, a, s);
  return f.ref = i, f.ce = o, delete l.vnode.ce, f;
}
const gs = (e) => e.type.__isKeepAlive, ty = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: !0,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(e, { slots: l }) {
    const i = Xn(), a = i.ctx;
    if (!a.renderer)
      return () => {
        const X = l.default && l.default();
        return X && X.length === 1 ? X[0] : X;
      };
    const s = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Set();
    let f = null;
    const d = i.suspense, {
      renderer: {
        p: h,
        m: x,
        um: y,
        o: { createElement: I }
      }
    } = a, q = I("div");
    a.activate = (X, B, K, W, ae) => {
      const ne = X.component;
      x(X, B, K, 0, d), h(
        ne.vnode,
        X,
        B,
        K,
        ne,
        d,
        W,
        X.slotScopeIds,
        ae
      ), hl(() => {
        ne.isDeactivated = !1, ne.a && Ra(ne.a);
        const oe = X.props && X.props.onVnodeMounted;
        oe && dt(oe, ne.parent, X);
      }, d);
    }, a.deactivate = (X) => {
      const B = X.component;
      vc(B.m), vc(B.a), x(X, q, null, 1, d), hl(() => {
        B.da && Ra(B.da);
        const K = X.props && X.props.onVnodeUnmounted;
        K && dt(K, B.parent, X), B.isDeactivated = !0;
      }, d);
    };
    function R(X) {
      Oo(X), y(X, i, d, !0);
    }
    function E(X) {
      s.forEach((B, K) => {
        const W = hm(B.type);
        W && !X(W) && M(K);
      });
    }
    function M(X) {
      const B = s.get(X);
      B && (!f || !ri(B, f)) ? R(B) : f && Oo(f), s.delete(X), o.delete(X);
    }
    Cn(
      () => [e.include, e.exclude],
      ([X, B]) => {
        X && E((K) => Fr(X, K)), B && E((K) => !Fr(B, K));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: !0 }
    );
    let U = null;
    const z = () => {
      U != null && (xc(i.subTree.type) ? hl(() => {
        s.set(U, ks(i.subTree));
      }, i.subTree.suspense) : s.set(U, ks(i.subTree)));
    };
    return vl(z), Wc(z), vs(() => {
      s.forEach((X) => {
        const { subTree: B, suspense: K } = i, W = ks(B);
        if (X.type === W.type && X.key === W.key) {
          Oo(W);
          const ae = W.component.da;
          ae && hl(ae, K);
          return;
        }
        R(X);
      });
    }), () => {
      if (U = null, !l.default)
        return f = null;
      const X = l.default(), B = X[0];
      if (X.length > 1)
        return f = null, X;
      if (!Ki(B) || !(B.shapeFlag & 4) && !(B.shapeFlag & 128))
        return f = null, B;
      let K = ks(B);
      if (K.type === ul)
        return f = null, K;
      const W = K.type, ae = hm(
        Bu(K) ? K.type.__asyncResolved || {} : W
      ), { include: ne, exclude: oe, max: k } = e;
      if (ne && (!ae || !Fr(ne, ae)) || oe && ae && Fr(oe, ae))
        return K.shapeFlag &= -257, f = K, B;
      const me = K.key == null ? W : K.key, be = s.get(me);
      return K.el && (K = di(K), B.shapeFlag & 128 && (B.ssContent = K)), U = me, be ? (K.el = be.el, K.component = be.component, K.transition && Ui(K, K.transition), K.shapeFlag |= 512, o.delete(me), o.add(me)) : (o.add(me), k && o.size > parseInt(k, 10) && M(o.values().next().value)), K.shapeFlag |= 256, f = K, xc(B.type) ? B : K;
    };
  }
}, iy = ty;
function Fr(e, l) {
  return Xe(e) ? e.some((i) => Fr(i, l)) : Wn(e) ? e.split(",").includes(l) : Mv(e) ? (e.lastIndex = 0, e.test(l)) : !1;
}
function fh(e, l) {
  ph(e, "a", l);
}
function dh(e, l) {
  ph(e, "da", l);
}
function ph(e, l, i = Rl) {
  const a = e.__wdc || (e.__wdc = () => {
    let s = i;
    for (; s; ) {
      if (s.isDeactivated)
        return;
      s = s.parent;
    }
    return e();
  });
  if ($c(l, a, i), i) {
    let s = i.parent;
    for (; s && s.parent; )
      gs(s.parent.vnode) && uy(a, l, i, s), s = s.parent;
  }
}
function uy(e, l, i, a) {
  const s = $c(
    l,
    e,
    a,
    !0
    /* prepend */
  );
  Dt(() => {
    Zm(a[l], s);
  }, i);
}
function Oo(e) {
  e.shapeFlag &= -257, e.shapeFlag &= -513;
}
function ks(e) {
  return e.shapeFlag & 128 ? e.ssContent : e;
}
function $c(e, l, i = Rl, a = !1) {
  if (i) {
    const s = i[e] || (i[e] = []), o = l.__weh || (l.__weh = (...f) => {
      ki();
      const d = aa(i), h = Ct(l, i, e, f);
      return d(), Vi(), h;
    });
    return a ? s.unshift(o) : s.push(o), o;
  }
}
const Wi = (e) => (l, i = Rl) => {
  (!Ma || e === "sp") && $c(e, (...a) => l(...a), i);
}, hh = Wi("bm"), vl = Wi("m"), ef = Wi(
  "bu"
), Wc = Wi("u"), vs = Wi(
  "bum"
), Dt = Wi("um"), gh = Wi(
  "sp"
), vh = Wi("rtg"), xh = Wi("rtc");
function yh(e, l = Rl) {
  $c("ec", e, l);
}
const nf = "components", ay = "directives";
function ry(e, l) {
  return lf(nf, e, !0, l) || e;
}
const Ih = Symbol.for("v-ndc");
function xs(e) {
  return Wn(e) ? lf(nf, e, !1) || e : e || Ih;
}
function sy(e) {
  return lf(ay, e);
}
function lf(e, l, i = !0, a = !1) {
  const s = Al || Rl;
  if (s) {
    const o = s.type;
    if (e === nf) {
      const d = hm(
        o,
        !1
      );
      if (d && (d === l || d === gl(l) || d === ps(gl(l))))
        return o;
    }
    const f = (
      // local registration
      // check instance[type] first which is resolved for options API
      Gf(s[e] || o[e], l) || // global registration
      Gf(s.appContext[e], l)
    );
    return !f && a ? o : f;
  }
}
function Gf(e, l) {
  return e && (e[l] || e[gl(l)] || e[ps(gl(l))]);
}
function ys(e, l, i, a) {
  let s;
  const o = i && i[a], f = Xe(e);
  if (f || Wn(e)) {
    const d = f && oi(e);
    let h = !1, x = !1;
    d && (h = !yt(e), x = Zi(e), e = Uc(e)), s = new Array(e.length);
    for (let y = 0, I = e.length; y < I; y++)
      s[y] = l(
        h ? x ? mc(ql(e[y])) : ql(e[y]) : e[y],
        y,
        void 0,
        o && o[y]
      );
  } else if (typeof e == "number") {
    s = new Array(e);
    for (let d = 0; d < e; d++)
      s[d] = l(d + 1, d, void 0, o && o[d]);
  } else if (_n(e))
    if (e[Symbol.iterator])
      s = Array.from(
        e,
        (d, h) => l(d, h, void 0, o && o[h])
      );
    else {
      const d = Object.keys(e);
      s = new Array(d.length);
      for (let h = 0, x = d.length; h < x; h++) {
        const y = d[h];
        s[h] = l(e[y], y, h, o && o[h]);
      }
    }
  else
    s = [];
  return i && (i[a] = s), s;
}
function cy(e, l) {
  for (let i = 0; i < l.length; i++) {
    const a = l[i];
    if (Xe(a))
      for (let s = 0; s < a.length; s++)
        e[a[s].name] = a[s].fn;
    else a && (e[a.name] = a.key ? (...s) => {
      const o = a.fn(...s);
      return o && (o.key = a.key), o;
    } : a.fn);
  }
  return e;
}
function qn(e, l, i = {}, a, s) {
  if (Al.ce || Al.parent && Bu(Al.parent) && Al.parent.ce) {
    const x = Object.keys(i).length > 0;
    return l !== "default" && (i.name = l), Ye(), xn(
      Mn,
      null,
      [ze("slot", i, a && a())],
      x ? -2 : 64
    );
  }
  let o = e[l];
  o && o._c && (o._d = !1), Ye();
  const f = o && tf(o(i)), d = i.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  f && f.key, h = xn(
    Mn,
    {
      key: (d && !fi(d) ? d : `_${l}`) + // #7256 force differentiate fallback content from actual content
      (!f && a ? "_fb" : "")
    },
    f || (a ? a() : []),
    f && e._ === 1 ? 64 : -2
  );
  return !s && h.scopeId && (h.slotScopeIds = [h.scopeId + "-s"]), o && o._c && (o._d = !0), h;
}
function tf(e) {
  return e.some((l) => Ki(l) ? !(l.type === ul || l.type === Mn && !tf(l.children)) : !0) ? e : null;
}
function oy(e, l) {
  const i = {};
  for (const a in e)
    i[l && /[A-Z]/.test(a) ? `on:${a}` : qa(a)] = e[a];
  return i;
}
const um = (e) => e ? Wh(e) ? Ls(e) : um(e.parent) : null, Kr = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ kn(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => e.props,
    $attrs: (e) => e.attrs,
    $slots: (e) => e.slots,
    $refs: (e) => e.refs,
    $parent: (e) => um(e.parent),
    $root: (e) => um(e.root),
    $host: (e) => e.ce,
    $emit: (e) => e.emit,
    $options: (e) => uf(e),
    $forceUpdate: (e) => e.f || (e.f = () => {
      Wm(e.update);
    }),
    $nextTick: (e) => e.n || (e.n = il.bind(e.proxy)),
    $watch: (e) => ky.bind(e)
  })
), bo = (e, l) => e !== On && !e.__isScriptSetup && Pn(e, l), am = {
  get({ _: e }, l) {
    if (l === "__v_skip")
      return !0;
    const { ctx: i, setupState: a, data: s, props: o, accessCache: f, type: d, appContext: h } = e;
    let x;
    if (l[0] !== "$") {
      const R = f[l];
      if (R !== void 0)
        switch (R) {
          case 1:
            return a[l];
          case 2:
            return s[l];
          case 4:
            return i[l];
          case 3:
            return o[l];
        }
      else {
        if (bo(a, l))
          return f[l] = 1, a[l];
        if (s !== On && Pn(s, l))
          return f[l] = 2, s[l];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (x = e.propsOptions[0]) && Pn(x, l)
        )
          return f[l] = 3, o[l];
        if (i !== On && Pn(i, l))
          return f[l] = 4, i[l];
        rm && (f[l] = 0);
      }
    }
    const y = Kr[l];
    let I, q;
    if (y)
      return l === "$attrs" && _l(e.attrs, "get", ""), y(e);
    if (
      // css module (injected by vue-loader)
      (I = d.__cssModules) && (I = I[l])
    )
      return I;
    if (i !== On && Pn(i, l))
      return f[l] = 4, i[l];
    if (
      // global properties
      q = h.config.globalProperties, Pn(q, l)
    )
      return q[l];
  },
  set({ _: e }, l, i) {
    const { data: a, setupState: s, ctx: o } = e;
    return bo(s, l) ? (s[l] = i, !0) : a !== On && Pn(a, l) ? (a[l] = i, !0) : Pn(e.props, l) || l[0] === "$" && l.slice(1) in e ? !1 : (o[l] = i, !0);
  },
  has({
    _: { data: e, setupState: l, accessCache: i, ctx: a, appContext: s, propsOptions: o, type: f }
  }, d) {
    let h, x;
    return !!(i[d] || e !== On && d[0] !== "$" && Pn(e, d) || bo(l, d) || (h = o[0]) && Pn(h, d) || Pn(a, d) || Pn(Kr, d) || Pn(s.config.globalProperties, d) || (x = f.__cssModules) && x[d]);
  },
  defineProperty(e, l, i) {
    return i.get != null ? e._.accessCache[l] = 0 : Pn(i, "value") && this.set(e, l, i.value, null), Reflect.defineProperty(e, l, i);
  }
}, my = /* @__PURE__ */ kn({}, am, {
  get(e, l) {
    if (l !== Symbol.unscopables)
      return am.get(e, l, e);
  },
  has(e, l) {
    return l[0] !== "_" && !Uv(l);
  }
});
function fy() {
  return null;
}
function dy() {
  return null;
}
function py(e) {
}
function hy(e) {
}
function gy() {
  return null;
}
function vy() {
}
function xy(e, l) {
  return null;
}
function yy() {
  return Lh().slots;
}
function Iy() {
  return Lh().attrs;
}
function Lh(e) {
  const l = Xn();
  return l.setupContext || (l.setupContext = Qh(l));
}
function ts(e) {
  return Xe(e) ? e.reduce(
    (l, i) => (l[i] = null, l),
    {}
  ) : e;
}
function Dh(e, l) {
  const i = ts(e);
  for (const a in l) {
    if (a.startsWith("__skip")) continue;
    let s = i[a];
    s ? Xe(s) || sn(s) ? s = i[a] = { type: s, default: l[a] } : s.default = l[a] : s === null && (s = i[a] = { default: l[a] }), s && l[`__skip_${a}`] && (s.skipFactory = !0);
  }
  return i;
}
function Ly(e, l) {
  return !e || !l ? e || l : Xe(e) && Xe(l) ? e.concat(l) : kn({}, ts(e), ts(l));
}
function Dy(e, l) {
  const i = {};
  for (const a in e)
    l.includes(a) || Object.defineProperty(i, a, {
      enumerable: !0,
      get: () => e[a]
    });
  return i;
}
function Oy(e) {
  const l = Xn();
  let i = e();
  return fm(), Um(i) && (i = i.catch((a) => {
    throw aa(l), a;
  })), [i, () => aa(l)];
}
let rm = !0;
function by(e) {
  const l = uf(e), i = e.proxy, a = e.ctx;
  rm = !1, l.beforeCreate && zf(l.beforeCreate, e, "bc");
  const {
    // state
    data: s,
    computed: o,
    methods: f,
    watch: d,
    provide: h,
    inject: x,
    // lifecycle
    created: y,
    beforeMount: I,
    mounted: q,
    beforeUpdate: R,
    updated: E,
    activated: M,
    deactivated: U,
    beforeDestroy: z,
    beforeUnmount: X,
    destroyed: B,
    unmounted: K,
    render: W,
    renderTracked: ae,
    renderTriggered: ne,
    errorCaptured: oe,
    serverPrefetch: k,
    // public API
    expose: me,
    inheritAttrs: be,
    // assets
    components: re,
    directives: ye,
    filters: xe
  } = l;
  if (x && wy(x, a, null), f)
    for (const ce in f) {
      const de = f[ce];
      sn(de) && (a[ce] = de.bind(i));
    }
  if (s) {
    const ce = s.call(i, i);
    _n(ce) && (e.data = Ga(ce));
  }
  if (rm = !0, o)
    for (const ce in o) {
      const de = o[ce], Le = sn(de) ? de.bind(i, i) : sn(de.get) ? de.get.bind(i, i) : bt, Ae = !sn(de) && sn(de.set) ? de.set.bind(i) : bt, We = _e({
        get: Le,
        set: Ae
      });
      Object.defineProperty(a, ce, {
        enumerable: !0,
        configurable: !0,
        get: () => We.value,
        set: (je) => We.value = je
      });
    }
  if (d)
    for (const ce in d)
      Oh(d[ce], a, i, ce);
  if (h) {
    const ce = sn(h) ? h.call(i) : h;
    Reflect.ownKeys(ce).forEach((de) => {
      Yc(de, ce[de]);
    });
  }
  y && zf(y, e, "c");
  function ge(ce, de) {
    Xe(de) ? de.forEach((Le) => ce(Le.bind(i))) : de && ce(de.bind(i));
  }
  if (ge(hh, I), ge(vl, q), ge(ef, R), ge(Wc, E), ge(fh, M), ge(dh, U), ge(yh, oe), ge(xh, ae), ge(vh, ne), ge(vs, X), ge(Dt, K), ge(gh, k), Xe(me))
    if (me.length) {
      const ce = e.exposed || (e.exposed = {});
      me.forEach((de) => {
        Object.defineProperty(ce, de, {
          get: () => i[de],
          set: (Le) => i[de] = Le,
          enumerable: !0
        });
      });
    } else e.exposed || (e.exposed = {});
  W && e.render === bt && (e.render = W), be != null && (e.inheritAttrs = be), re && (e.components = re), ye && (e.directives = ye), k && Qm(e);
}
function wy(e, l, i = bt) {
  Xe(e) && (e = sm(e));
  for (const a in e) {
    const s = e[a];
    let o;
    _n(s) ? "default" in s ? o = Fi(
      s.from || a,
      s.default,
      !0
    ) : o = Fi(s.from || a) : o = Fi(s), Vn(o) ? Object.defineProperty(l, a, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (f) => o.value = f
    }) : l[a] = o;
  }
}
function zf(e, l, i) {
  Ct(
    Xe(e) ? e.map((a) => a.bind(l.proxy)) : e.bind(l.proxy),
    l,
    i
  );
}
function Oh(e, l, i, a) {
  let s = a.includes(".") ? Bh(i, a) : () => i[a];
  if (Wn(e)) {
    const o = l[e];
    sn(o) && Cn(s, o);
  } else if (sn(e))
    Cn(s, e.bind(i));
  else if (_n(e))
    if (Xe(e))
      e.forEach((o) => Oh(o, l, i, a));
    else {
      const o = sn(e.handler) ? e.handler.bind(i) : l[e.handler];
      sn(o) && Cn(s, o, e);
    }
}
function uf(e) {
  const l = e.type, { mixins: i, extends: a } = l, {
    mixins: s,
    optionsCache: o,
    config: { optionMergeStrategies: f }
  } = e.appContext, d = o.get(l);
  let h;
  return d ? h = d : !s.length && !i && !a ? h = l : (h = {}, s.length && s.forEach(
    (x) => gc(h, x, f, !0)
  ), gc(h, l, f)), _n(l) && o.set(l, h), h;
}
function gc(e, l, i, a = !1) {
  const { mixins: s, extends: o } = l;
  o && gc(e, o, i, !0), s && s.forEach(
    (f) => gc(e, f, i, !0)
  );
  for (const f in l)
    if (!(a && f === "expose")) {
      const d = Sy[f] || i && i[f];
      e[f] = d ? d(e[f], l[f]) : l[f];
    }
  return e;
}
const Sy = {
  data: jf,
  props: Hf,
  emits: Hf,
  // objects
  methods: Mr,
  computed: Mr,
  // lifecycle
  beforeCreate: kl,
  created: kl,
  beforeMount: kl,
  mounted: kl,
  beforeUpdate: kl,
  updated: kl,
  beforeDestroy: kl,
  beforeUnmount: kl,
  destroyed: kl,
  unmounted: kl,
  activated: kl,
  deactivated: kl,
  errorCaptured: kl,
  serverPrefetch: kl,
  // assets
  components: Mr,
  directives: Mr,
  // watch
  watch: Ty,
  // provide / inject
  provide: jf,
  inject: Cy
};
function jf(e, l) {
  return l ? e ? function() {
    return kn(
      sn(e) ? e.call(this, this) : e,
      sn(l) ? l.call(this, this) : l
    );
  } : l : e;
}
function Cy(e, l) {
  return Mr(sm(e), sm(l));
}
function sm(e) {
  if (Xe(e)) {
    const l = {};
    for (let i = 0; i < e.length; i++)
      l[e[i]] = e[i];
    return l;
  }
  return e;
}
function kl(e, l) {
  return e ? [...new Set([].concat(e, l))] : l;
}
function Mr(e, l) {
  return e ? kn(/* @__PURE__ */ Object.create(null), e, l) : l;
}
function Hf(e, l) {
  return e ? Xe(e) && Xe(l) ? [.../* @__PURE__ */ new Set([...e, ...l])] : kn(
    /* @__PURE__ */ Object.create(null),
    ts(e),
    ts(l ?? {})
  ) : l;
}
function Ty(e, l) {
  if (!e) return l;
  if (!l) return e;
  const i = kn(/* @__PURE__ */ Object.create(null), e);
  for (const a in l)
    i[a] = kl(e[a], l[a]);
  return i;
}
function bh() {
  return {
    app: null,
    config: {
      isNativeTag: Cp,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let Py = 0;
function qy(e, l) {
  return function(a, s = null) {
    sn(a) || (a = kn({}, a)), s != null && !_n(s) && (s = null);
    const o = bh(), f = /* @__PURE__ */ new WeakSet(), d = [];
    let h = !1;
    const x = o.app = {
      _uid: Py++,
      _component: a,
      _props: s,
      _container: null,
      _context: o,
      _instance: null,
      version: ng,
      get config() {
        return o.config;
      },
      set config(y) {
      },
      use(y, ...I) {
        return f.has(y) || (y && sn(y.install) ? (f.add(y), y.install(x, ...I)) : sn(y) && (f.add(y), y(x, ...I))), x;
      },
      mixin(y) {
        return o.mixins.includes(y) || o.mixins.push(y), x;
      },
      component(y, I) {
        return I ? (o.components[y] = I, x) : o.components[y];
      },
      directive(y, I) {
        return I ? (o.directives[y] = I, x) : o.directives[y];
      },
      mount(y, I, q) {
        if (!h) {
          const R = x._ceVNode || ze(a, s);
          return R.appContext = o, q === !0 ? q = "svg" : q === !1 && (q = void 0), I && l ? l(R, y) : e(R, y, q), h = !0, x._container = y, y.__vue_app__ = x, Ls(R.component);
        }
      },
      onUnmount(y) {
        d.push(y);
      },
      unmount() {
        h && (Ct(
          d,
          x._instance,
          16
        ), e(null, x._container), delete x._container.__vue_app__);
      },
      provide(y, I) {
        return o.provides[y] = I, x;
      },
      runWithContext(y) {
        const I = ta;
        ta = x;
        try {
          return y();
        } finally {
          ta = I;
        }
      }
    };
    return x;
  };
}
let ta = null;
function Yc(e, l) {
  if (Rl) {
    let i = Rl.provides;
    const a = Rl.parent && Rl.parent.provides;
    a === i && (i = Rl.provides = Object.create(a)), i[e] = l;
  }
}
function Fi(e, l, i = !1) {
  const a = Xn();
  if (a || ta) {
    let s = ta ? ta._context.provides : a ? a.parent == null || a.ce ? a.vnode.appContext && a.vnode.appContext.provides : a.parent.provides : void 0;
    if (s && e in s)
      return s[e];
    if (arguments.length > 1)
      return i && sn(l) ? l.call(a && a.proxy) : l;
  }
}
function Xc() {
  return !!(Xn() || ta);
}
const wh = {}, Sh = () => Object.create(wh), Ch = (e) => Object.getPrototypeOf(e) === wh;
function Ry(e, l, i, a = !1) {
  const s = {}, o = Sh();
  e.propsDefaults = /* @__PURE__ */ Object.create(null), Th(e, l, s, o);
  for (const f in e.propsOptions[0])
    f in s || (s[f] = void 0);
  i ? e.props = a ? s : $p(s) : e.type.props ? e.props = s : e.props = o, e.attrs = o;
}
function Ay(e, l, i, a) {
  const {
    props: s,
    attrs: o,
    vnode: { patchFlag: f }
  } = e, d = Ln(s), [h] = e.propsOptions;
  let x = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (a || f > 0) && !(f & 16)
  ) {
    if (f & 8) {
      const y = e.vnode.dynamicProps;
      for (let I = 0; I < y.length; I++) {
        let q = y[I];
        if (Qc(e.emitsOptions, q))
          continue;
        const R = l[q];
        if (h)
          if (Pn(o, q))
            R !== o[q] && (o[q] = R, x = !0);
          else {
            const E = gl(q);
            s[E] = cm(
              h,
              d,
              E,
              R,
              e,
              !1
            );
          }
        else
          R !== o[q] && (o[q] = R, x = !0);
      }
    }
  } else {
    Th(e, l, s, o) && (x = !0);
    let y;
    for (const I in d)
      (!l || // for camelCase
      !Pn(l, I) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((y = ht(I)) === I || !Pn(l, y))) && (h ? i && // for camelCase
      (i[I] !== void 0 || // for kebab-case
      i[y] !== void 0) && (s[I] = cm(
        h,
        d,
        I,
        void 0,
        e,
        !0
      )) : delete s[I]);
    if (o !== d)
      for (const I in o)
        (!l || !Pn(l, I)) && (delete o[I], x = !0);
  }
  x && Ai(e.attrs, "set", "");
}
function Th(e, l, i, a) {
  const [s, o] = e.propsOptions;
  let f = !1, d;
  if (l)
    for (let h in l) {
      if (Pa(h))
        continue;
      const x = l[h];
      let y;
      s && Pn(s, y = gl(h)) ? !o || !o.includes(y) ? i[y] = x : (d || (d = {}))[y] = x : Qc(e.emitsOptions, h) || (!(h in a) || x !== a[h]) && (a[h] = x, f = !0);
    }
  if (o) {
    const h = Ln(i), x = d || On;
    for (let y = 0; y < o.length; y++) {
      const I = o[y];
      i[I] = cm(
        s,
        h,
        I,
        x[I],
        e,
        !Pn(x, I)
      );
    }
  }
  return f;
}
function cm(e, l, i, a, s, o) {
  const f = e[i];
  if (f != null) {
    const d = Pn(f, "default");
    if (d && a === void 0) {
      const h = f.default;
      if (f.type !== Function && !f.skipFactory && sn(h)) {
        const { propsDefaults: x } = s;
        if (i in x)
          a = x[i];
        else {
          const y = aa(s);
          a = x[i] = h.call(
            null,
            l
          ), y();
        }
      } else
        a = h;
      s.ce && s.ce._setProp(i, a);
    }
    f[
      0
      /* shouldCast */
    ] && (o && !d ? a = !1 : f[
      1
      /* shouldCastTrue */
    ] && (a === "" || a === ht(i)) && (a = !0));
  }
  return a;
}
const Ey = /* @__PURE__ */ new WeakMap();
function Ph(e, l, i = !1) {
  const a = i ? Ey : l.propsCache, s = a.get(e);
  if (s)
    return s;
  const o = e.props, f = {}, d = [];
  let h = !1;
  if (!sn(e)) {
    const y = (I) => {
      h = !0;
      const [q, R] = Ph(I, l, !0);
      kn(f, q), R && d.push(...R);
    };
    !i && l.mixins.length && l.mixins.forEach(y), e.extends && y(e.extends), e.mixins && e.mixins.forEach(y);
  }
  if (!o && !h)
    return _n(e) && a.set(e, Ca), Ca;
  if (Xe(o))
    for (let y = 0; y < o.length; y++) {
      const I = gl(o[y]);
      $f(I) && (f[I] = On);
    }
  else if (o)
    for (const y in o) {
      const I = gl(y);
      if ($f(I)) {
        const q = o[y], R = f[I] = Xe(q) || sn(q) ? { type: q } : kn({}, q), E = R.type;
        let M = !1, U = !0;
        if (Xe(E))
          for (let z = 0; z < E.length; ++z) {
            const X = E[z], B = sn(X) && X.name;
            if (B === "Boolean") {
              M = !0;
              break;
            } else B === "String" && (U = !1);
          }
        else
          M = sn(E) && E.name === "Boolean";
        R[
          0
          /* shouldCast */
        ] = M, R[
          1
          /* shouldCastTrue */
        ] = U, (M || Pn(R, "default")) && d.push(I);
      }
    }
  const x = [f, d];
  return _n(e) && a.set(e, x), x;
}
function $f(e) {
  return e[0] !== "$" && !Pa(e);
}
const af = (e) => e === "_" || e === "_ctx" || e === "$stable", rf = (e) => Xe(e) ? e.map(pt) : [pt(e)], _y = (e, l, i) => {
  if (l._n)
    return l;
  const a = ln((...s) => rf(l(...s)), i);
  return a._c = !1, a;
}, qh = (e, l, i) => {
  const a = e._ctx;
  for (const s in e) {
    if (af(s)) continue;
    const o = e[s];
    if (sn(o))
      l[s] = _y(s, o, a);
    else if (o != null) {
      const f = rf(o);
      l[s] = () => f;
    }
  }
}, Rh = (e, l) => {
  const i = rf(l);
  e.slots.default = () => i;
}, Ah = (e, l, i) => {
  for (const a in l)
    (i || !af(a)) && (e[a] = l[a]);
}, Ny = (e, l, i) => {
  const a = e.slots = Sh();
  if (e.vnode.shapeFlag & 32) {
    const s = l._;
    s ? (Ah(a, l, i), i && Pp(a, "_", s, !0)) : qh(l, a);
  } else l && Rh(e, l);
}, Fy = (e, l, i) => {
  const { vnode: a, slots: s } = e;
  let o = !0, f = On;
  if (a.shapeFlag & 32) {
    const d = l._;
    d ? i && d === 1 ? o = !1 : Ah(s, l, i) : (o = !l.$stable, qh(l, s)), f = l;
  } else l && (Rh(e, l), f = { default: 1 });
  if (o)
    for (const d in s)
      !af(d) && f[d] == null && delete s[d];
}, hl = Gh;
function Eh(e) {
  return Nh(e);
}
function _h(e) {
  return Nh(e, jx);
}
function Nh(e, l) {
  const i = Mc();
  i.__VUE__ = !0;
  const {
    insert: a,
    remove: s,
    patchProp: o,
    createElement: f,
    createText: d,
    createComment: h,
    setText: x,
    setElementText: y,
    parentNode: I,
    nextSibling: q,
    setScopeId: R = bt,
    insertStaticContent: E
  } = e, M = (j, ie, fe, Ce = null, Ie = null, we = null, Ne = void 0, Ee = null, Oe = !!ie.dynamicChildren) => {
    if (j === ie)
      return;
    j && !ri(j, ie) && (Ce = V(j), je(j, Ie, we, !0), j = null), ie.patchFlag === -2 && (Oe = !1, ie.dynamicChildren = null);
    const { type: Pe, ref: Ke, shapeFlag: ke } = ie;
    switch (Pe) {
      case Zu:
        U(j, ie, fe, Ce);
        break;
      case ul:
        z(j, ie, fe, Ce);
        break;
      case ia:
        j == null && X(ie, fe, Ce, Ne);
        break;
      case Mn:
        re(
          j,
          ie,
          fe,
          Ce,
          Ie,
          we,
          Ne,
          Ee,
          Oe
        );
        break;
      default:
        ke & 1 ? W(
          j,
          ie,
          fe,
          Ce,
          Ie,
          we,
          Ne,
          Ee,
          Oe
        ) : ke & 6 ? ye(
          j,
          ie,
          fe,
          Ce,
          Ie,
          we,
          Ne,
          Ee,
          Oe
        ) : (ke & 64 || ke & 128) && Pe.process(
          j,
          ie,
          fe,
          Ce,
          Ie,
          we,
          Ne,
          Ee,
          Oe,
          ue
        );
    }
    Ke != null && Ie ? Ea(Ke, j && j.ref, we, ie || j, !ie) : Ke == null && j && j.ref != null && Ea(j.ref, null, we, j, !0);
  }, U = (j, ie, fe, Ce) => {
    if (j == null)
      a(
        ie.el = d(ie.children),
        fe,
        Ce
      );
    else {
      const Ie = ie.el = j.el;
      ie.children !== j.children && x(Ie, ie.children);
    }
  }, z = (j, ie, fe, Ce) => {
    j == null ? a(
      ie.el = h(ie.children || ""),
      fe,
      Ce
    ) : ie.el = j.el;
  }, X = (j, ie, fe, Ce) => {
    [j.el, j.anchor] = E(
      j.children,
      ie,
      fe,
      Ce,
      j.el,
      j.anchor
    );
  }, B = ({ el: j, anchor: ie }, fe, Ce) => {
    let Ie;
    for (; j && j !== ie; )
      Ie = q(j), a(j, fe, Ce), j = Ie;
    a(ie, fe, Ce);
  }, K = ({ el: j, anchor: ie }) => {
    let fe;
    for (; j && j !== ie; )
      fe = q(j), s(j), j = fe;
    s(ie);
  }, W = (j, ie, fe, Ce, Ie, we, Ne, Ee, Oe) => {
    ie.type === "svg" ? Ne = "svg" : ie.type === "math" && (Ne = "mathml"), j == null ? ae(
      ie,
      fe,
      Ce,
      Ie,
      we,
      Ne,
      Ee,
      Oe
    ) : k(
      j,
      ie,
      Ie,
      we,
      Ne,
      Ee,
      Oe
    );
  }, ae = (j, ie, fe, Ce, Ie, we, Ne, Ee) => {
    let Oe, Pe;
    const { props: Ke, shapeFlag: ke, transition: Ze, dirs: Ue } = j;
    if (Oe = j.el = f(
      j.type,
      we,
      Ke && Ke.is,
      Ke
    ), ke & 8 ? y(Oe, j.children) : ke & 16 && oe(
      j.children,
      Oe,
      null,
      Ce,
      Ie,
      wo(j, we),
      Ne,
      Ee
    ), Ue && Li(j, null, Ce, "created"), ne(Oe, j, j.scopeId, Ne, Ce), Ke) {
      for (const yn in Ke)
        yn !== "value" && !Pa(yn) && o(Oe, yn, null, Ke[yn], we, Ce);
      "value" in Ke && o(Oe, "value", null, Ke.value, we), (Pe = Ke.onVnodeBeforeMount) && dt(Pe, Ce, j);
    }
    Ue && Li(j, null, Ce, "beforeMount");
    const Je = Fh(Ie, Ze);
    Je && Ze.beforeEnter(Oe), a(Oe, ie, fe), ((Pe = Ke && Ke.onVnodeMounted) || Je || Ue) && hl(() => {
      Pe && dt(Pe, Ce, j), Je && Ze.enter(Oe), Ue && Li(j, null, Ce, "mounted");
    }, Ie);
  }, ne = (j, ie, fe, Ce, Ie) => {
    if (fe && R(j, fe), Ce)
      for (let we = 0; we < Ce.length; we++)
        R(j, Ce[we]);
    if (Ie) {
      let we = Ie.subTree;
      if (ie === we || xc(we.type) && (we.ssContent === ie || we.ssFallback === ie)) {
        const Ne = Ie.vnode;
        ne(
          j,
          Ne,
          Ne.scopeId,
          Ne.slotScopeIds,
          Ie.parent
        );
      }
    }
  }, oe = (j, ie, fe, Ce, Ie, we, Ne, Ee, Oe = 0) => {
    for (let Pe = Oe; Pe < j.length; Pe++) {
      const Ke = j[Pe] = Ee ? Mu(j[Pe]) : pt(j[Pe]);
      M(
        null,
        Ke,
        ie,
        fe,
        Ce,
        Ie,
        we,
        Ne,
        Ee
      );
    }
  }, k = (j, ie, fe, Ce, Ie, we, Ne) => {
    const Ee = ie.el = j.el;
    let { patchFlag: Oe, dynamicChildren: Pe, dirs: Ke } = ie;
    Oe |= j.patchFlag & 16;
    const ke = j.props || On, Ze = ie.props || On;
    let Ue;
    if (fe && Wu(fe, !1), (Ue = Ze.onVnodeBeforeUpdate) && dt(Ue, fe, ie, j), Ke && Li(ie, j, fe, "beforeUpdate"), fe && Wu(fe, !0), (ke.innerHTML && Ze.innerHTML == null || ke.textContent && Ze.textContent == null) && y(Ee, ""), Pe ? me(
      j.dynamicChildren,
      Pe,
      Ee,
      fe,
      Ce,
      wo(ie, Ie),
      we
    ) : Ne || de(
      j,
      ie,
      Ee,
      null,
      fe,
      Ce,
      wo(ie, Ie),
      we,
      !1
    ), Oe > 0) {
      if (Oe & 16)
        be(Ee, ke, Ze, fe, Ie);
      else if (Oe & 2 && ke.class !== Ze.class && o(Ee, "class", null, Ze.class, Ie), Oe & 4 && o(Ee, "style", ke.style, Ze.style, Ie), Oe & 8) {
        const Je = ie.dynamicProps;
        for (let yn = 0; yn < Je.length; yn++) {
          const on = Je[yn], Bn = ke[on], Tn = Ze[on];
          (Tn !== Bn || on === "value") && o(Ee, on, Bn, Tn, Ie, fe);
        }
      }
      Oe & 1 && j.children !== ie.children && y(Ee, ie.children);
    } else !Ne && Pe == null && be(Ee, ke, Ze, fe, Ie);
    ((Ue = Ze.onVnodeUpdated) || Ke) && hl(() => {
      Ue && dt(Ue, fe, ie, j), Ke && Li(ie, j, fe, "updated");
    }, Ce);
  }, me = (j, ie, fe, Ce, Ie, we, Ne) => {
    for (let Ee = 0; Ee < ie.length; Ee++) {
      const Oe = j[Ee], Pe = ie[Ee], Ke = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        Oe.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (Oe.type === Mn || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !ri(Oe, Pe) || // - In the case of a component, it could contain anything.
        Oe.shapeFlag & 198) ? I(Oe.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fe
        )
      );
      M(
        Oe,
        Pe,
        Ke,
        null,
        Ce,
        Ie,
        we,
        Ne,
        !0
      );
    }
  }, be = (j, ie, fe, Ce, Ie) => {
    if (ie !== fe) {
      if (ie !== On)
        for (const we in ie)
          !Pa(we) && !(we in fe) && o(
            j,
            we,
            ie[we],
            null,
            Ie,
            Ce
          );
      for (const we in fe) {
        if (Pa(we)) continue;
        const Ne = fe[we], Ee = ie[we];
        Ne !== Ee && we !== "value" && o(j, we, Ee, Ne, Ie, Ce);
      }
      "value" in fe && o(j, "value", ie.value, fe.value, Ie);
    }
  }, re = (j, ie, fe, Ce, Ie, we, Ne, Ee, Oe) => {
    const Pe = ie.el = j ? j.el : d(""), Ke = ie.anchor = j ? j.anchor : d("");
    let { patchFlag: ke, dynamicChildren: Ze, slotScopeIds: Ue } = ie;
    Ue && (Ee = Ee ? Ee.concat(Ue) : Ue), j == null ? (a(Pe, fe, Ce), a(Ke, fe, Ce), oe(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      ie.children || [],
      fe,
      Ke,
      Ie,
      we,
      Ne,
      Ee,
      Oe
    )) : ke > 0 && ke & 64 && Ze && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    j.dynamicChildren ? (me(
      j.dynamicChildren,
      Ze,
      fe,
      Ie,
      we,
      Ne,
      Ee
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (ie.key != null || Ie && ie === Ie.subTree) && sf(
      j,
      ie,
      !0
      /* shallow */
    )) : de(
      j,
      ie,
      fe,
      Ke,
      Ie,
      we,
      Ne,
      Ee,
      Oe
    );
  }, ye = (j, ie, fe, Ce, Ie, we, Ne, Ee, Oe) => {
    ie.slotScopeIds = Ee, j == null ? ie.shapeFlag & 512 ? Ie.ctx.activate(
      ie,
      fe,
      Ce,
      Ne,
      Oe
    ) : xe(
      ie,
      fe,
      Ce,
      Ie,
      we,
      Ne,
      Oe
    ) : Se(j, ie, Oe);
  }, xe = (j, ie, fe, Ce, Ie, we, Ne) => {
    const Ee = j.component = $h(
      j,
      Ce,
      Ie
    );
    if (gs(j) && (Ee.ctx.renderer = ue), Yh(Ee, !1, Ne), Ee.asyncDep) {
      if (Ie && Ie.registerDep(Ee, ge, Ne), !j.el) {
        const Oe = Ee.subTree = ze(ul);
        z(null, Oe, ie, fe), j.placeholder = Oe.el;
      }
    } else
      ge(
        Ee,
        j,
        ie,
        fe,
        Ie,
        we,
        Ne
      );
  }, Se = (j, ie, fe) => {
    const Ce = ie.component = j.component;
    if (zy(j, ie, fe))
      if (Ce.asyncDep && !Ce.asyncResolved) {
        ce(Ce, ie, fe);
        return;
      } else
        Ce.next = ie, Ce.update();
    else
      ie.el = j.el, Ce.vnode = ie;
  }, ge = (j, ie, fe, Ce, Ie, we, Ne) => {
    const Ee = () => {
      if (j.isMounted) {
        let { next: ke, bu: Ze, u: Ue, parent: Je, vnode: yn } = j;
        {
          const Nn = Mh(j);
          if (Nn) {
            ke && (ke.el = yn.el, ce(j, ke, Ne)), Nn.asyncDep.then(() => {
              j.isUnmounted || Ee();
            });
            return;
          }
        }
        let on = ke, Bn;
        Wu(j, !1), ke ? (ke.el = yn.el, ce(j, ke, Ne)) : ke = yn, Ze && Ra(Ze), (Bn = ke.props && ke.props.onVnodeBeforeUpdate) && dt(Bn, Je, ke, yn), Wu(j, !0);
        const Tn = nc(j), Dn = j.subTree;
        j.subTree = Tn, M(
          Dn,
          Tn,
          // parent may have changed if it's in a teleport
          I(Dn.el),
          // anchor may have changed if it's in a fragment
          V(Dn),
          j,
          Ie,
          we
        ), ke.el = Tn.el, on === null && Jc(j, Tn.el), Ue && hl(Ue, Ie), (Bn = ke.props && ke.props.onVnodeUpdated) && hl(
          () => dt(Bn, Je, ke, yn),
          Ie
        );
      } else {
        let ke;
        const { el: Ze, props: Ue } = ie, { bm: Je, m: yn, parent: on, root: Bn, type: Tn } = j, Dn = Bu(ie);
        if (Wu(j, !1), Je && Ra(Je), !Dn && (ke = Ue && Ue.onVnodeBeforeMount) && dt(ke, on, ie), Wu(j, !0), Ze && De) {
          const Nn = () => {
            j.subTree = nc(j), De(
              Ze,
              j.subTree,
              j,
              Ie,
              null
            );
          };
          Dn && Tn.__asyncHydrate ? Tn.__asyncHydrate(
            Ze,
            j,
            Nn
          ) : Nn();
        } else {
          Bn.ce && // @ts-expect-error _def is private
          Bn.ce._def.shadowRoot !== !1 && Bn.ce._injectChildStyle(Tn);
          const Nn = j.subTree = nc(j);
          M(
            null,
            Nn,
            fe,
            Ce,
            j,
            Ie,
            we
          ), ie.el = Nn.el;
        }
        if (yn && hl(yn, Ie), !Dn && (ke = Ue && Ue.onVnodeMounted)) {
          const Nn = ie;
          hl(
            () => dt(ke, on, Nn),
            Ie
          );
        }
        (ie.shapeFlag & 256 || on && Bu(on.vnode) && on.vnode.shapeFlag & 256) && j.a && hl(j.a, Ie), j.isMounted = !0, ie = fe = Ce = null;
      }
    };
    j.scope.on();
    const Oe = j.effect = new Xr(Ee);
    j.scope.off();
    const Pe = j.update = Oe.run.bind(Oe), Ke = j.job = Oe.runIfDirty.bind(Oe);
    Ke.i = j, Ke.id = j.uid, Oe.scheduler = () => Wm(Ke), Wu(j, !0), Pe();
  }, ce = (j, ie, fe) => {
    ie.component = j;
    const Ce = j.vnode.props;
    j.vnode = ie, j.next = null, Ay(j, ie.props, Ce, fe), Fy(j, ie.children, fe), ki(), Ff(j), Vi();
  }, de = (j, ie, fe, Ce, Ie, we, Ne, Ee, Oe = !1) => {
    const Pe = j && j.children, Ke = j ? j.shapeFlag : 0, ke = ie.children, { patchFlag: Ze, shapeFlag: Ue } = ie;
    if (Ze > 0) {
      if (Ze & 128) {
        Ae(
          Pe,
          ke,
          fe,
          Ce,
          Ie,
          we,
          Ne,
          Ee,
          Oe
        );
        return;
      } else if (Ze & 256) {
        Le(
          Pe,
          ke,
          fe,
          Ce,
          Ie,
          we,
          Ne,
          Ee,
          Oe
        );
        return;
      }
    }
    Ue & 8 ? (Ke & 16 && tn(Pe, Ie, we), ke !== Pe && y(fe, ke)) : Ke & 16 ? Ue & 16 ? Ae(
      Pe,
      ke,
      fe,
      Ce,
      Ie,
      we,
      Ne,
      Ee,
      Oe
    ) : tn(Pe, Ie, we, !0) : (Ke & 8 && y(fe, ""), Ue & 16 && oe(
      ke,
      fe,
      Ce,
      Ie,
      we,
      Ne,
      Ee,
      Oe
    ));
  }, Le = (j, ie, fe, Ce, Ie, we, Ne, Ee, Oe) => {
    j = j || Ca, ie = ie || Ca;
    const Pe = j.length, Ke = ie.length, ke = Math.min(Pe, Ke);
    let Ze;
    for (Ze = 0; Ze < ke; Ze++) {
      const Ue = ie[Ze] = Oe ? Mu(ie[Ze]) : pt(ie[Ze]);
      M(
        j[Ze],
        Ue,
        fe,
        null,
        Ie,
        we,
        Ne,
        Ee,
        Oe
      );
    }
    Pe > Ke ? tn(
      j,
      Ie,
      we,
      !0,
      !1,
      ke
    ) : oe(
      ie,
      fe,
      Ce,
      Ie,
      we,
      Ne,
      Ee,
      Oe,
      ke
    );
  }, Ae = (j, ie, fe, Ce, Ie, we, Ne, Ee, Oe) => {
    let Pe = 0;
    const Ke = ie.length;
    let ke = j.length - 1, Ze = Ke - 1;
    for (; Pe <= ke && Pe <= Ze; ) {
      const Ue = j[Pe], Je = ie[Pe] = Oe ? Mu(ie[Pe]) : pt(ie[Pe]);
      if (ri(Ue, Je))
        M(
          Ue,
          Je,
          fe,
          null,
          Ie,
          we,
          Ne,
          Ee,
          Oe
        );
      else
        break;
      Pe++;
    }
    for (; Pe <= ke && Pe <= Ze; ) {
      const Ue = j[ke], Je = ie[Ze] = Oe ? Mu(ie[Ze]) : pt(ie[Ze]);
      if (ri(Ue, Je))
        M(
          Ue,
          Je,
          fe,
          null,
          Ie,
          we,
          Ne,
          Ee,
          Oe
        );
      else
        break;
      ke--, Ze--;
    }
    if (Pe > ke) {
      if (Pe <= Ze) {
        const Ue = Ze + 1, Je = Ue < Ke ? ie[Ue].el : Ce;
        for (; Pe <= Ze; )
          M(
            null,
            ie[Pe] = Oe ? Mu(ie[Pe]) : pt(ie[Pe]),
            fe,
            Je,
            Ie,
            we,
            Ne,
            Ee,
            Oe
          ), Pe++;
      }
    } else if (Pe > Ze)
      for (; Pe <= ke; )
        je(j[Pe], Ie, we, !0), Pe++;
    else {
      const Ue = Pe, Je = Pe, yn = /* @__PURE__ */ new Map();
      for (Pe = Je; Pe <= Ze; Pe++) {
        const se = ie[Pe] = Oe ? Mu(ie[Pe]) : pt(ie[Pe]);
        se.key != null && yn.set(se.key, Pe);
      }
      let on, Bn = 0;
      const Tn = Ze - Je + 1;
      let Dn = !1, Nn = 0;
      const yl = new Array(Tn);
      for (Pe = 0; Pe < Tn; Pe++) yl[Pe] = 0;
      for (Pe = Ue; Pe <= ke; Pe++) {
        const se = j[Pe];
        if (Bn >= Tn) {
          je(se, Ie, we, !0);
          continue;
        }
        let Fn;
        if (se.key != null)
          Fn = yn.get(se.key);
        else
          for (on = Je; on <= Ze; on++)
            if (yl[on - Je] === 0 && ri(se, ie[on])) {
              Fn = on;
              break;
            }
        Fn === void 0 ? je(se, Ie, we, !0) : (yl[Fn - Je] = Pe + 1, Fn >= Nn ? Nn = Fn : Dn = !0, M(
          se,
          ie[Fn],
          fe,
          null,
          Ie,
          we,
          Ne,
          Ee,
          Oe
        ), Bn++);
      }
      const Rn = Dn ? My(yl) : Ca;
      for (on = Rn.length - 1, Pe = Tn - 1; Pe >= 0; Pe--) {
        const se = Je + Pe, Fn = ie[se], Zn = ie[se + 1], Il = se + 1 < Ke ? (
          // #13559, fallback to el placeholder for unresolved async component
          Zn.el || Zn.placeholder
        ) : Ce;
        yl[Pe] === 0 ? M(
          null,
          Fn,
          fe,
          Il,
          Ie,
          we,
          Ne,
          Ee,
          Oe
        ) : Dn && (on < 0 || Pe !== Rn[on] ? We(Fn, fe, Il, 2) : on--);
      }
    }
  }, We = (j, ie, fe, Ce, Ie = null) => {
    const { el: we, type: Ne, transition: Ee, children: Oe, shapeFlag: Pe } = j;
    if (Pe & 6) {
      We(j.component.subTree, ie, fe, Ce);
      return;
    }
    if (Pe & 128) {
      j.suspense.move(ie, fe, Ce);
      return;
    }
    if (Pe & 64) {
      Ne.move(j, ie, fe, ue);
      return;
    }
    if (Ne === Mn) {
      a(we, ie, fe);
      for (let ke = 0; ke < Oe.length; ke++)
        We(Oe[ke], ie, fe, Ce);
      a(j.anchor, ie, fe);
      return;
    }
    if (Ne === ia) {
      B(j, ie, fe);
      return;
    }
    if (Ce !== 2 && Pe & 1 && Ee)
      if (Ce === 0)
        Ee.beforeEnter(we), a(we, ie, fe), hl(() => Ee.enter(we), Ie);
      else {
        const { leave: ke, delayLeave: Ze, afterLeave: Ue } = Ee, Je = () => {
          j.ctx.isUnmounted ? s(we) : a(we, ie, fe);
        }, yn = () => {
          we._isLeaving && we[qi](
            !0
            /* cancelled */
          ), ke(we, () => {
            Je(), Ue && Ue();
          });
        };
        Ze ? Ze(we, Je, yn) : yn();
      }
    else
      a(we, ie, fe);
  }, je = (j, ie, fe, Ce = !1, Ie = !1) => {
    const {
      type: we,
      props: Ne,
      ref: Ee,
      children: Oe,
      dynamicChildren: Pe,
      shapeFlag: Ke,
      patchFlag: ke,
      dirs: Ze,
      cacheIndex: Ue
    } = j;
    if (ke === -2 && (Ie = !1), Ee != null && (ki(), Ea(Ee, null, fe, j, !0), Vi()), Ue != null && (ie.renderCache[Ue] = void 0), Ke & 256) {
      ie.ctx.deactivate(j);
      return;
    }
    const Je = Ke & 1 && Ze, yn = !Bu(j);
    let on;
    if (yn && (on = Ne && Ne.onVnodeBeforeUnmount) && dt(on, ie, j), Ke & 6)
      gn(j.component, fe, Ce);
    else {
      if (Ke & 128) {
        j.suspense.unmount(fe, Ce);
        return;
      }
      Je && Li(j, null, ie, "beforeUnmount"), Ke & 64 ? j.type.remove(
        j,
        ie,
        fe,
        ue,
        Ce
      ) : Pe && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !Pe.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (we !== Mn || ke > 0 && ke & 64) ? tn(
        Pe,
        ie,
        fe,
        !1,
        !0
      ) : (we === Mn && ke & 384 || !Ie && Ke & 16) && tn(Oe, ie, fe), Ce && cn(j);
    }
    (yn && (on = Ne && Ne.onVnodeUnmounted) || Je) && hl(() => {
      on && dt(on, ie, j), Je && Li(j, null, ie, "unmounted");
    }, fe);
  }, cn = (j) => {
    const { type: ie, el: fe, anchor: Ce, transition: Ie } = j;
    if (ie === Mn) {
      bn(fe, Ce);
      return;
    }
    if (ie === ia) {
      K(j);
      return;
    }
    const we = () => {
      s(fe), Ie && !Ie.persisted && Ie.afterLeave && Ie.afterLeave();
    };
    if (j.shapeFlag & 1 && Ie && !Ie.persisted) {
      const { leave: Ne, delayLeave: Ee } = Ie, Oe = () => Ne(fe, we);
      Ee ? Ee(j.el, we, Oe) : Oe();
    } else
      we();
  }, bn = (j, ie) => {
    let fe;
    for (; j !== ie; )
      fe = q(j), s(j), j = fe;
    s(ie);
  }, gn = (j, ie, fe) => {
    const { bum: Ce, scope: Ie, job: we, subTree: Ne, um: Ee, m: Oe, a: Pe } = j;
    vc(Oe), vc(Pe), Ce && Ra(Ce), Ie.stop(), we && (we.flags |= 8, je(Ne, j, ie, fe)), Ee && hl(Ee, ie), hl(() => {
      j.isUnmounted = !0;
    }, ie);
  }, tn = (j, ie, fe, Ce = !1, Ie = !1, we = 0) => {
    for (let Ne = we; Ne < j.length; Ne++)
      je(j[Ne], ie, fe, Ce, Ie);
  }, V = (j) => {
    if (j.shapeFlag & 6)
      return V(j.component.subTree);
    if (j.shapeFlag & 128)
      return j.suspense.next();
    const ie = q(j.anchor || j.el), fe = ie && ie[th];
    return fe ? q(fe) : ie;
  };
  let _ = !1;
  const Z = (j, ie, fe) => {
    j == null ? ie._vnode && je(ie._vnode, null, null, !0) : M(
      ie._vnode || null,
      j,
      ie,
      null,
      null,
      null,
      fe
    ), ie._vnode = j, _ || (_ = !0, Ff(), pc(), _ = !1);
  }, ue = {
    p: M,
    um: je,
    m: We,
    r: cn,
    mt: xe,
    mc: oe,
    pc: de,
    pbc: me,
    n: V,
    o: e
  };
  let Qe, De;
  return l && ([Qe, De] = l(
    ue
  )), {
    render: Z,
    hydrate: Qe,
    createApp: qy(Z, Qe)
  };
}
function wo({ type: e, props: l }, i) {
  return i === "svg" && e === "foreignObject" || i === "mathml" && e === "annotation-xml" && l && l.encoding && l.encoding.includes("html") ? void 0 : i;
}
function Wu({ effect: e, job: l }, i) {
  i ? (e.flags |= 32, l.flags |= 4) : (e.flags &= -33, l.flags &= -5);
}
function Fh(e, l) {
  return (!e || e && !e.pendingBranch) && l && !l.persisted;
}
function sf(e, l, i = !1) {
  const a = e.children, s = l.children;
  if (Xe(a) && Xe(s))
    for (let o = 0; o < a.length; o++) {
      const f = a[o];
      let d = s[o];
      d.shapeFlag & 1 && !d.dynamicChildren && ((d.patchFlag <= 0 || d.patchFlag === 32) && (d = s[o] = Mu(s[o]), d.el = f.el), !i && d.patchFlag !== -2 && sf(f, d)), d.type === Zu && // avoid cached text nodes retaining detached dom nodes
      d.patchFlag !== -1 && (d.el = f.el), d.type === ul && !d.el && (d.el = f.el);
    }
}
function My(e) {
  const l = e.slice(), i = [0];
  let a, s, o, f, d;
  const h = e.length;
  for (a = 0; a < h; a++) {
    const x = e[a];
    if (x !== 0) {
      if (s = i[i.length - 1], e[s] < x) {
        l[a] = s, i.push(a);
        continue;
      }
      for (o = 0, f = i.length - 1; o < f; )
        d = o + f >> 1, e[i[d]] < x ? o = d + 1 : f = d;
      x < e[i[o]] && (o > 0 && (l[a] = i[o - 1]), i[o] = a);
    }
  }
  for (o = i.length, f = i[o - 1]; o-- > 0; )
    i[o] = f, f = l[f];
  return i;
}
function Mh(e) {
  const l = e.subTree.component;
  if (l)
    return l.asyncDep && !l.asyncResolved ? l : Mh(l);
}
function vc(e) {
  if (e)
    for (let l = 0; l < e.length; l++)
      e[l].flags |= 8;
}
const kh = Symbol.for("v-scx"), Vh = () => Fi(kh);
function Ml(e, l) {
  return Is(e, null, l);
}
function cf(e, l) {
  return Is(
    e,
    null,
    { flush: "post" }
  );
}
function of(e, l) {
  return Is(
    e,
    null,
    { flush: "sync" }
  );
}
function Cn(e, l, i) {
  return Is(e, l, i);
}
function Is(e, l, i = On) {
  const { immediate: a, deep: s, flush: o, once: f } = i, d = kn({}, i), h = l && a || !l && o !== "post";
  let x;
  if (Ma) {
    if (o === "sync") {
      const R = Vh();
      x = R.__watcherHandles || (R.__watcherHandles = []);
    } else if (!h) {
      const R = () => {
      };
      return R.stop = bt, R.resume = bt, R.pause = bt, R;
    }
  }
  const y = Rl;
  d.call = (R, E, M) => Ct(R, y, E, M);
  let I = !1;
  o === "post" ? d.scheduler = (R) => {
    hl(R, y && y.suspense);
  } : o !== "sync" && (I = !0, d.scheduler = (R, E) => {
    E ? R() : Wm(R);
  }), d.augmentJob = (R) => {
    l && (R.flags |= 4), I && (R.flags |= 2, y && (R.id = y.uid, R.i = y));
  };
  const q = Px(e, l, d);
  return Ma && (x ? x.push(q) : h && q()), q;
}
function ky(e, l, i) {
  const a = this.proxy, s = Wn(e) ? e.includes(".") ? Bh(a, e) : () => a[e] : e.bind(a, a);
  let o;
  sn(l) ? o = l : (o = l.handler, i = l);
  const f = aa(this), d = Is(s, o.bind(a), i);
  return f(), d;
}
function Bh(e, l) {
  const i = l.split(".");
  return () => {
    let a = e;
    for (let s = 0; s < i.length && a; s++)
      a = a[i[s]];
    return a;
  };
}
function Vy(e, l, i = On) {
  const a = Xn(), s = gl(l), o = ht(l), f = Zh(e, s), d = ja((h, x) => {
    let y, I = On, q;
    return of(() => {
      const R = e[s];
      Vl(y, R) && (y = R, x());
    }), {
      get() {
        return h(), i.get ? i.get(y) : y;
      },
      set(R) {
        const E = i.set ? i.set(R) : R;
        if (!Vl(E, y) && !(I !== On && Vl(R, I)))
          return;
        const M = a.vnode.props;
        M && // check if parent has passed v-model
        (l in M || s in M || o in M) && (`onUpdate:${l}` in M || `onUpdate:${s}` in M || `onUpdate:${o}` in M) || (y = R, x()), a.emit(`update:${l}`, E), Vl(R, E) && Vl(R, I) && !Vl(E, q) && x(), I = R, q = E;
      }
    };
  });
  return d[Symbol.iterator] = () => {
    let h = 0;
    return {
      next() {
        return h < 2 ? { value: h++ ? f || On : d, done: !1 } : { done: !0 };
      }
    };
  }, d;
}
const Zh = (e, l) => l === "modelValue" || l === "model-value" ? e.modelModifiers : e[`${l}Modifiers`] || e[`${gl(l)}Modifiers`] || e[`${ht(l)}Modifiers`];
function By(e, l, ...i) {
  if (e.isUnmounted) return;
  const a = e.vnode.props || On;
  let s = i;
  const o = l.startsWith("update:"), f = o && Zh(a, l.slice(7));
  f && (f.trim && (s = i.map((y) => Wn(y) ? y.trim() : y)), f.number && (s = i.map(sc)));
  let d, h = a[d = qa(l)] || // also try camelCase event handler (#2249)
  a[d = qa(gl(l))];
  !h && o && (h = a[d = qa(ht(l))]), h && Ct(
    h,
    e,
    6,
    s
  );
  const x = a[d + "Once"];
  if (x) {
    if (!e.emitted)
      e.emitted = {};
    else if (e.emitted[d])
      return;
    e.emitted[d] = !0, Ct(
      x,
      e,
      6,
      s
    );
  }
}
const Zy = /* @__PURE__ */ new WeakMap();
function Uh(e, l, i = !1) {
  const a = i ? Zy : l.emitsCache, s = a.get(e);
  if (s !== void 0)
    return s;
  const o = e.emits;
  let f = {}, d = !1;
  if (!sn(e)) {
    const h = (x) => {
      const y = Uh(x, l, !0);
      y && (d = !0, kn(f, y));
    };
    !i && l.mixins.length && l.mixins.forEach(h), e.extends && h(e.extends), e.mixins && e.mixins.forEach(h);
  }
  return !o && !d ? (_n(e) && a.set(e, null), null) : (Xe(o) ? o.forEach((h) => f[h] = null) : kn(f, o), _n(e) && a.set(e, f), f);
}
function Qc(e, l) {
  return !e || !ds(l) ? !1 : (l = l.slice(2).replace(/Once$/, ""), Pn(e, l[0].toLowerCase() + l.slice(1)) || Pn(e, ht(l)) || Pn(e, l));
}
function nc(e) {
  const {
    type: l,
    vnode: i,
    proxy: a,
    withProxy: s,
    propsOptions: [o],
    slots: f,
    attrs: d,
    emit: h,
    render: x,
    renderCache: y,
    props: I,
    data: q,
    setupState: R,
    ctx: E,
    inheritAttrs: M
  } = e, U = ls(e);
  let z, X;
  try {
    if (i.shapeFlag & 4) {
      const K = s || a, W = K;
      z = pt(
        x.call(
          W,
          K,
          y,
          I,
          R,
          q,
          E
        )
      ), X = d;
    } else {
      const K = l;
      z = pt(
        K.length > 1 ? K(
          I,
          { attrs: d, slots: f, emit: h }
        ) : K(
          I,
          null
        )
      ), X = l.props ? d : Ky(d);
    }
  } catch (K) {
    Gr.length = 0, oa(K, e, 1), z = ze(ul);
  }
  let B = z;
  if (X && M !== !1) {
    const K = Object.keys(X), { shapeFlag: W } = B;
    K.length && W & 7 && (o && K.some(Bm) && (X = Gy(
      X,
      o
    )), B = di(B, X, !1, !0));
  }
  return i.dirs && (B = di(B, null, !1, !0), B.dirs = B.dirs ? B.dirs.concat(i.dirs) : i.dirs), i.transition && Ui(B, i.transition), z = B, ls(U), z;
}
function Uy(e, l = !0) {
  let i;
  for (let a = 0; a < e.length; a++) {
    const s = e[a];
    if (Ki(s)) {
      if (s.type !== ul || s.children === "v-if") {
        if (i)
          return;
        i = s;
      }
    } else
      return;
  }
  return i;
}
const Ky = (e) => {
  let l;
  for (const i in e)
    (i === "class" || i === "style" || ds(i)) && ((l || (l = {}))[i] = e[i]);
  return l;
}, Gy = (e, l) => {
  const i = {};
  for (const a in e)
    (!Bm(a) || !(a.slice(9) in l)) && (i[a] = e[a]);
  return i;
};
function zy(e, l, i) {
  const { props: a, children: s, component: o } = e, { props: f, children: d, patchFlag: h } = l, x = o.emitsOptions;
  if (l.dirs || l.transition)
    return !0;
  if (i && h >= 0) {
    if (h & 1024)
      return !0;
    if (h & 16)
      return a ? Wf(a, f, x) : !!f;
    if (h & 8) {
      const y = l.dynamicProps;
      for (let I = 0; I < y.length; I++) {
        const q = y[I];
        if (f[q] !== a[q] && !Qc(x, q))
          return !0;
      }
    }
  } else
    return (s || d) && (!d || !d.$stable) ? !0 : a === f ? !1 : a ? f ? Wf(a, f, x) : !0 : !!f;
  return !1;
}
function Wf(e, l, i) {
  const a = Object.keys(l);
  if (a.length !== Object.keys(e).length)
    return !0;
  for (let s = 0; s < a.length; s++) {
    const o = a[s];
    if (l[o] !== e[o] && !Qc(i, o))
      return !0;
  }
  return !1;
}
function Jc({ vnode: e, parent: l }, i) {
  for (; l; ) {
    const a = l.subTree;
    if (a.suspense && a.suspense.activeBranch === e && (a.el = e.el), a === e)
      (e = l.vnode).el = i, l = l.parent;
    else
      break;
  }
}
const xc = (e) => e.__isSuspense;
let om = 0;
const jy = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: !0,
  process(e, l, i, a, s, o, f, d, h, x) {
    if (e == null)
      $y(
        l,
        i,
        a,
        s,
        o,
        f,
        d,
        h,
        x
      );
    else {
      if (o && o.deps > 0 && !e.suspense.isInFallback) {
        l.suspense = e.suspense, l.suspense.vnode = l, l.el = e.el;
        return;
      }
      Wy(
        e,
        l,
        i,
        a,
        s,
        f,
        d,
        h,
        x
      );
    }
  },
  hydrate: Yy,
  normalize: Xy
}, Hy = jy;
function is(e, l) {
  const i = e.props && e.props[l];
  sn(i) && i();
}
function $y(e, l, i, a, s, o, f, d, h) {
  const {
    p: x,
    o: { createElement: y }
  } = h, I = y("div"), q = e.suspense = Kh(
    e,
    s,
    a,
    l,
    I,
    i,
    o,
    f,
    d,
    h
  );
  x(
    null,
    q.pendingBranch = e.ssContent,
    I,
    null,
    a,
    q,
    o,
    f
  ), q.deps > 0 ? (is(e, "onPending"), is(e, "onFallback"), x(
    null,
    e.ssFallback,
    l,
    i,
    a,
    null,
    // fallback tree will not have suspense context
    o,
    f
  ), _a(q, e.ssFallback)) : q.resolve(!1, !0);
}
function Wy(e, l, i, a, s, o, f, d, { p: h, um: x, o: { createElement: y } }) {
  const I = l.suspense = e.suspense;
  I.vnode = l, l.el = e.el;
  const q = l.ssContent, R = l.ssFallback, { activeBranch: E, pendingBranch: M, isInFallback: U, isHydrating: z } = I;
  if (M)
    I.pendingBranch = q, ri(M, q) ? (h(
      M,
      q,
      I.hiddenContainer,
      null,
      s,
      I,
      o,
      f,
      d
    ), I.deps <= 0 ? I.resolve() : U && (z || (h(
      E,
      R,
      i,
      a,
      s,
      null,
      // fallback tree will not have suspense context
      o,
      f,
      d
    ), _a(I, R)))) : (I.pendingId = om++, z ? (I.isHydrating = !1, I.activeBranch = M) : x(M, s, I), I.deps = 0, I.effects.length = 0, I.hiddenContainer = y("div"), U ? (h(
      null,
      q,
      I.hiddenContainer,
      null,
      s,
      I,
      o,
      f,
      d
    ), I.deps <= 0 ? I.resolve() : (h(
      E,
      R,
      i,
      a,
      s,
      null,
      // fallback tree will not have suspense context
      o,
      f,
      d
    ), _a(I, R))) : E && ri(E, q) ? (h(
      E,
      q,
      i,
      a,
      s,
      I,
      o,
      f,
      d
    ), I.resolve(!0)) : (h(
      null,
      q,
      I.hiddenContainer,
      null,
      s,
      I,
      o,
      f,
      d
    ), I.deps <= 0 && I.resolve()));
  else if (E && ri(E, q))
    h(
      E,
      q,
      i,
      a,
      s,
      I,
      o,
      f,
      d
    ), _a(I, q);
  else if (is(l, "onPending"), I.pendingBranch = q, q.shapeFlag & 512 ? I.pendingId = q.component.suspenseId : I.pendingId = om++, h(
    null,
    q,
    I.hiddenContainer,
    null,
    s,
    I,
    o,
    f,
    d
  ), I.deps <= 0)
    I.resolve();
  else {
    const { timeout: X, pendingId: B } = I;
    X > 0 ? setTimeout(() => {
      I.pendingId === B && I.fallback(R);
    }, X) : X === 0 && I.fallback(R);
  }
}
function Kh(e, l, i, a, s, o, f, d, h, x, y = !1) {
  const {
    p: I,
    m: q,
    um: R,
    n: E,
    o: { parentNode: M, remove: U }
  } = x;
  let z;
  const X = Qy(e);
  X && l && l.pendingBranch && (z = l.pendingId, l.deps++);
  const B = e.props ? cc(e.props.timeout) : void 0, K = o, W = {
    vnode: e,
    parent: l,
    parentComponent: i,
    namespace: f,
    container: a,
    hiddenContainer: s,
    deps: 0,
    pendingId: om++,
    timeout: typeof B == "number" ? B : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !y,
    isHydrating: y,
    isUnmounted: !1,
    effects: [],
    resolve(ae = !1, ne = !1) {
      const {
        vnode: oe,
        activeBranch: k,
        pendingBranch: me,
        pendingId: be,
        effects: re,
        parentComponent: ye,
        container: xe
      } = W;
      let Se = !1;
      W.isHydrating ? W.isHydrating = !1 : ae || (Se = k && me.transition && me.transition.mode === "out-in", Se && (k.transition.afterLeave = () => {
        be === W.pendingId && (q(
          me,
          xe,
          o === K ? E(k) : o,
          0
        ), es(re));
      }), k && (M(k.el) === xe && (o = E(k)), R(k, ye, W, !0)), Se || q(me, xe, o, 0)), _a(W, me), W.pendingBranch = null, W.isInFallback = !1;
      let ge = W.parent, ce = !1;
      for (; ge; ) {
        if (ge.pendingBranch) {
          ge.effects.push(...re), ce = !0;
          break;
        }
        ge = ge.parent;
      }
      !ce && !Se && es(re), W.effects = [], X && l && l.pendingBranch && z === l.pendingId && (l.deps--, l.deps === 0 && !ne && l.resolve()), is(oe, "onResolve");
    },
    fallback(ae) {
      if (!W.pendingBranch)
        return;
      const { vnode: ne, activeBranch: oe, parentComponent: k, container: me, namespace: be } = W;
      is(ne, "onFallback");
      const re = E(oe), ye = () => {
        W.isInFallback && (I(
          null,
          ae,
          me,
          re,
          k,
          null,
          // fallback tree will not have suspense context
          be,
          d,
          h
        ), _a(W, ae));
      }, xe = ae.transition && ae.transition.mode === "out-in";
      xe && (oe.transition.afterLeave = ye), W.isInFallback = !0, R(
        oe,
        k,
        null,
        // no suspense so unmount hooks fire now
        !0
        // shouldRemove
      ), xe || ye();
    },
    move(ae, ne, oe) {
      W.activeBranch && q(W.activeBranch, ae, ne, oe), W.container = ae;
    },
    next() {
      return W.activeBranch && E(W.activeBranch);
    },
    registerDep(ae, ne, oe) {
      const k = !!W.pendingBranch;
      k && W.deps++;
      const me = ae.vnode.el;
      ae.asyncDep.catch((be) => {
        oa(be, ae, 0);
      }).then((be) => {
        if (ae.isUnmounted || W.isUnmounted || W.pendingId !== ae.suspenseId)
          return;
        ae.asyncResolved = !0;
        const { vnode: re } = ae;
        dm(ae, be, !1), me && (re.el = me);
        const ye = !me && ae.subTree.el;
        ne(
          ae,
          re,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          M(me || ae.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          me ? null : E(ae.subTree),
          W,
          f,
          oe
        ), ye && U(ye), Jc(ae, re.el), k && --W.deps === 0 && W.resolve();
      });
    },
    unmount(ae, ne) {
      W.isUnmounted = !0, W.activeBranch && R(
        W.activeBranch,
        i,
        ae,
        ne
      ), W.pendingBranch && R(
        W.pendingBranch,
        i,
        ae,
        ne
      );
    }
  };
  return W;
}
function Yy(e, l, i, a, s, o, f, d, h) {
  const x = l.suspense = Kh(
    l,
    a,
    i,
    e.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    s,
    o,
    f,
    d,
    !0
  ), y = h(
    e,
    x.pendingBranch = l.ssContent,
    i,
    x,
    o,
    f
  );
  return x.deps === 0 && x.resolve(!1, !0), y;
}
function Xy(e) {
  const { shapeFlag: l, children: i } = e, a = l & 32;
  e.ssContent = Yf(
    a ? i.default : i
  ), e.ssFallback = a ? Yf(i.fallback) : ze(ul);
}
function Yf(e) {
  let l;
  if (sn(e)) {
    const i = ua && e._c;
    i && (e._d = !1, Ye()), e = e(), i && (e._d = !0, l = Nl, zh());
  }
  return Xe(e) && (e = Uy(e)), e = pt(e), l && !e.dynamicChildren && (e.dynamicChildren = l.filter((i) => i !== e)), e;
}
function Gh(e, l) {
  l && l.pendingBranch ? Xe(e) ? l.effects.push(...e) : l.effects.push(e) : es(e);
}
function _a(e, l) {
  e.activeBranch = l;
  const { vnode: i, parentComponent: a } = e;
  let s = l.el;
  for (; !s && l.component; )
    l = l.component.subTree, s = l.el;
  i.el = s, a && a.subTree === i && (a.vnode.el = s, Jc(a, s));
}
function Qy(e) {
  const l = e.props && e.props.suspensible;
  return l != null && l !== !1;
}
const Mn = Symbol.for("v-fgt"), Zu = Symbol.for("v-txt"), ul = Symbol.for("v-cmt"), ia = Symbol.for("v-stc"), Gr = [];
let Nl = null;
function Ye(e = !1) {
  Gr.push(Nl = e ? null : []);
}
function zh() {
  Gr.pop(), Nl = Gr[Gr.length - 1] || null;
}
let ua = 1;
function us(e, l = !1) {
  ua += e, e < 0 && Nl && l && (Nl.hasOnce = !0);
}
function jh(e) {
  return e.dynamicChildren = ua > 0 ? Nl || Ca : null, zh(), ua > 0 && Nl && Nl.push(e), e;
}
function Yn(e, l, i, a, s, o) {
  return jh(
    fn(
      e,
      l,
      i,
      a,
      s,
      o,
      !0
    )
  );
}
function xn(e, l, i, a, s) {
  return jh(
    ze(
      e,
      l,
      i,
      a,
      s,
      !0
    )
  );
}
function Ki(e) {
  return e ? e.__v_isVNode === !0 : !1;
}
function ri(e, l) {
  return e.type === l.type && e.key === l.key;
}
function Jy(e) {
}
const Hh = ({ key: e }) => e ?? null, lc = ({
  ref: e,
  ref_key: l,
  ref_for: i
}) => (typeof e == "number" && (e = "" + e), e != null ? Wn(e) || Vn(e) || sn(e) ? { i: Al, r: e, k: l, f: !!i } : e : null);
function fn(e, l = null, i = null, a = 0, s = null, o = e === Mn ? 0 : 1, f = !1, d = !1) {
  const h = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: l,
    key: l && Hh(l),
    ref: l && lc(l),
    scopeId: jc,
    slotScopeIds: null,
    children: i,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: a,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: Al
  };
  return d ? (ff(h, i), o & 128 && e.normalize(h)) : i && (h.shapeFlag |= Wn(i) ? 8 : 16), ua > 0 && // avoid a block node from tracking itself
  !f && // has current parent block
  Nl && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (h.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  h.patchFlag !== 32 && Nl.push(h), h;
}
const ze = eI;
function eI(e, l = null, i = null, a = 0, s = null, o = !1) {
  if ((!e || e === Ih) && (e = ul), Ki(e)) {
    const d = di(
      e,
      l,
      !0
      /* mergeRef: true */
    );
    return i && ff(d, i), ua > 0 && !o && Nl && (d.shapeFlag & 6 ? Nl[Nl.indexOf(e)] = d : Nl.push(d)), d.patchFlag = -2, d;
  }
  if (sI(e) && (e = e.__vccOpts), l) {
    l = mf(l);
    let { class: d, style: h } = l;
    d && !Wn(d) && (l.class = Bl(d)), _n(h) && (zc(h) && !Xe(h) && (h = kn({}, h)), l.style = Hi(h));
  }
  const f = Wn(e) ? 1 : xc(e) ? 128 : ih(e) ? 64 : _n(e) ? 4 : sn(e) ? 2 : 0;
  return fn(
    e,
    l,
    i,
    a,
    s,
    f,
    o,
    !0
  );
}
function mf(e) {
  return e ? zc(e) || Ch(e) ? kn({}, e) : e : null;
}
function di(e, l, i = !1, a = !1) {
  const { props: s, ref: o, patchFlag: f, children: d, transition: h } = e, x = l ? pl(s || {}, l) : s, y = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: x,
    key: x && Hh(x),
    ref: l && l.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      i && o ? Xe(o) ? o.concat(lc(l)) : [o, lc(l)] : lc(l)
    ) : o,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: d,
    target: e.target,
    targetStart: e.targetStart,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: l && e.type !== Mn ? f === -1 ? 16 : f | 16 : f,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: h,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && di(e.ssContent),
    ssFallback: e.ssFallback && di(e.ssFallback),
    placeholder: e.placeholder,
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
  return h && a && Ui(
    y,
    h.clone(y)
  ), y;
}
function Gi(e = " ", l = 0) {
  return ze(Zu, null, e, l);
}
function nI(e, l) {
  const i = ze(ia, null, e);
  return i.staticCount = l, i;
}
function pi(e = "", l = !1) {
  return l ? (Ye(), xn(ul, null, e)) : ze(ul, null, e);
}
function pt(e) {
  return e == null || typeof e == "boolean" ? ze(ul) : Xe(e) ? ze(
    Mn,
    null,
    // #3666, avoid reference pollution when reusing vnode
    e.slice()
  ) : Ki(e) ? Mu(e) : ze(Zu, null, String(e));
}
function Mu(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : di(e);
}
function ff(e, l) {
  let i = 0;
  const { shapeFlag: a } = e;
  if (l == null)
    l = null;
  else if (Xe(l))
    i = 16;
  else if (typeof l == "object")
    if (a & 65) {
      const s = l.default;
      s && (s._c && (s._d = !1), ff(e, s()), s._c && (s._d = !0));
      return;
    } else {
      i = 32;
      const s = l._;
      !s && !Ch(l) ? l._ctx = Al : s === 3 && Al && (Al.slots._ === 1 ? l._ = 1 : (l._ = 2, e.patchFlag |= 1024));
    }
  else sn(l) ? (l = { default: l, _ctx: Al }, i = 32) : (l = String(l), a & 64 ? (i = 16, l = [Gi(l)]) : i = 8);
  e.children = l, e.shapeFlag |= i;
}
function pl(...e) {
  const l = {};
  for (let i = 0; i < e.length; i++) {
    const a = e[i];
    for (const s in a)
      if (s === "class")
        l.class !== a.class && (l.class = Bl([l.class, a.class]));
      else if (s === "style")
        l.style = Hi([l.style, a.style]);
      else if (ds(s)) {
        const o = l[s], f = a[s];
        f && o !== f && !(Xe(o) && o.includes(f)) && (l[s] = o ? [].concat(o, f) : f);
      } else s !== "" && (l[s] = a[s]);
  }
  return l;
}
function dt(e, l, i, a = null) {
  Ct(e, l, 7, [
    i,
    a
  ]);
}
const lI = bh();
let tI = 0;
function $h(e, l, i) {
  const a = e.type, s = (l ? l.appContext : e.appContext) || lI, o = {
    uid: tI++,
    vnode: e,
    type: a,
    parent: l,
    appContext: s,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Gm(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: l ? l.provides : Object.create(s.provides),
    ids: l ? l.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Ph(a, s),
    emitsOptions: Uh(a, s),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: On,
    // inheritAttrs
    inheritAttrs: a.inheritAttrs,
    // state
    ctx: On,
    data: On,
    props: On,
    attrs: On,
    slots: On,
    refs: On,
    setupState: On,
    setupContext: null,
    // suspense related
    suspense: i,
    suspenseId: i ? i.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return o.ctx = { _: o }, o.root = l ? l.root : o, o.emit = By.bind(null, o), e.ce && e.ce(o), o;
}
let Rl = null;
const Xn = () => Rl || Al;
let yc, mm;
{
  const e = Mc(), l = (i, a) => {
    let s;
    return (s = e[i]) || (s = e[i] = []), s.push(a), (o) => {
      s.length > 1 ? s.forEach((f) => f(o)) : s[0](o);
    };
  };
  yc = l(
    "__VUE_INSTANCE_SETTERS__",
    (i) => Rl = i
  ), mm = l(
    "__VUE_SSR_SETTERS__",
    (i) => Ma = i
  );
}
const aa = (e) => {
  const l = Rl;
  return yc(e), e.scope.on(), () => {
    e.scope.off(), yc(l);
  };
}, fm = () => {
  Rl && Rl.scope.off(), yc(null);
};
function Wh(e) {
  return e.vnode.shapeFlag & 4;
}
let Ma = !1;
function Yh(e, l = !1, i = !1) {
  l && mm(l);
  const { props: a, children: s } = e.vnode, o = Wh(e);
  Ry(e, a, o, l), Ny(e, s, i || l);
  const f = o ? iI(e, l) : void 0;
  return l && mm(!1), f;
}
function iI(e, l) {
  const i = e.type;
  e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = new Proxy(e.ctx, am);
  const { setup: a } = i;
  if (a) {
    ki();
    const s = e.setupContext = a.length > 1 ? Qh(e) : null, o = aa(e), f = Ha(
      a,
      e,
      0,
      [
        e.props,
        s
      ]
    ), d = Um(f);
    if (Vi(), o(), (d || e.sp) && !Bu(e) && Qm(e), d) {
      if (f.then(fm, fm), l)
        return f.then((h) => {
          dm(e, h, l);
        }).catch((h) => {
          oa(h, e, 0);
        });
      e.asyncDep = f;
    } else
      dm(e, f, l);
  } else
    Xh(e, l);
}
function dm(e, l, i) {
  sn(l) ? e.type.__ssrInlineRender ? e.ssrRender = l : e.render = l : _n(l) && (e.setupState = $m(l)), Xh(e, i);
}
let Ic, pm;
function uI(e) {
  Ic = e, pm = (l) => {
    l.render._rc && (l.withProxy = new Proxy(l.ctx, my));
  };
}
const aI = () => !Ic;
function Xh(e, l, i) {
  const a = e.type;
  if (!e.render) {
    if (!l && Ic && !a.render) {
      const s = a.template || uf(e).template;
      if (s) {
        const { isCustomElement: o, compilerOptions: f } = e.appContext.config, { delimiters: d, compilerOptions: h } = a, x = kn(
          kn(
            {
              isCustomElement: o,
              delimiters: d
            },
            f
          ),
          h
        );
        a.render = Ic(s, x);
      }
    }
    e.render = a.render || bt, pm && pm(e);
  }
  {
    const s = aa(e);
    ki();
    try {
      by(e);
    } finally {
      Vi(), s();
    }
  }
}
const rI = {
  get(e, l) {
    return _l(e, "get", ""), e[l];
  }
};
function Qh(e) {
  const l = (i) => {
    e.exposed = i || {};
  };
  return {
    attrs: new Proxy(e.attrs, rI),
    slots: e.slots,
    emit: e.emit,
    expose: l
  };
}
function Ls(e) {
  return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy($m(za(e.exposed)), {
    get(l, i) {
      if (i in l)
        return l[i];
      if (i in Kr)
        return Kr[i](e);
    },
    has(l, i) {
      return i in l || i in Kr;
    }
  })) : e.proxy;
}
function hm(e, l = !0) {
  return sn(e) ? e.displayName || e.name : e.name || l && e.__name;
}
function sI(e) {
  return sn(e) && "__vccOpts" in e;
}
const _e = (e, l) => wx(e, l, Ma);
function gt(e, l, i) {
  try {
    us(-1);
    const a = arguments.length;
    return a === 2 ? _n(l) && !Xe(l) ? Ki(l) ? ze(e, null, [l]) : ze(e, l) : ze(e, null, l) : (a > 3 ? i = Array.prototype.slice.call(arguments, 2) : a === 3 && Ki(i) && (i = [i]), ze(e, l, i));
  } finally {
    us(1);
  }
}
function cI() {
}
function Jh(e, l, i, a) {
  const s = i[a];
  if (s && eg(s, e))
    return s;
  const o = l();
  return o.memo = e.slice(), o.cacheIndex = a, i[a] = o;
}
function eg(e, l) {
  const i = e.memo;
  if (i.length != l.length)
    return !1;
  for (let a = 0; a < i.length; a++)
    if (Vl(i[a], l[a]))
      return !1;
  return ua > 0 && Nl && Nl.push(e), !0;
}
const ng = "3.5.22", oI = bt, mI = _x, fI = Oa, dI = lh, pI = {
  createComponentInstance: $h,
  setupComponent: Yh,
  renderComponentRoot: nc,
  setCurrentRenderingInstance: ls,
  isVNode: Ki,
  normalizeVNode: pt,
  getComponentPublicInstance: Ls,
  ensureValidVNode: tf,
  pushWarningContext: qx,
  popWarningContext: Rx
}, hI = pI, gI = null, vI = null, xI = null;
let gm;
const Xf = typeof window < "u" && window.trustedTypes;
if (Xf)
  try {
    gm = /* @__PURE__ */ Xf.createPolicy("vue", {
      createHTML: (e) => e
    });
  } catch {
  }
const lg = gm ? (e) => gm.createHTML(e) : (e) => e, yI = "http://www.w3.org/2000/svg", II = "http://www.w3.org/1998/Math/MathML", Pi = typeof document < "u" ? document : null, Qf = Pi && /* @__PURE__ */ Pi.createElement("template"), LI = {
  insert: (e, l, i) => {
    l.insertBefore(e, i || null);
  },
  remove: (e) => {
    const l = e.parentNode;
    l && l.removeChild(e);
  },
  createElement: (e, l, i, a) => {
    const s = l === "svg" ? Pi.createElementNS(yI, e) : l === "mathml" ? Pi.createElementNS(II, e) : i ? Pi.createElement(e, { is: i }) : Pi.createElement(e);
    return e === "select" && a && a.multiple != null && s.setAttribute("multiple", a.multiple), s;
  },
  createText: (e) => Pi.createTextNode(e),
  createComment: (e) => Pi.createComment(e),
  setText: (e, l) => {
    e.nodeValue = l;
  },
  setElementText: (e, l) => {
    e.textContent = l;
  },
  parentNode: (e) => e.parentNode,
  nextSibling: (e) => e.nextSibling,
  querySelector: (e) => Pi.querySelector(e),
  setScopeId(e, l) {
    e.setAttribute(l, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(e, l, i, a, s, o) {
    const f = i ? i.previousSibling : l.lastChild;
    if (s && (s === o || s.nextSibling))
      for (; l.insertBefore(s.cloneNode(!0), i), !(s === o || !(s = s.nextSibling)); )
        ;
    else {
      Qf.innerHTML = lg(
        a === "svg" ? `<svg>${e}</svg>` : a === "mathml" ? `<math>${e}</math>` : e
      );
      const d = Qf.content;
      if (a === "svg" || a === "mathml") {
        const h = d.firstChild;
        for (; h.firstChild; )
          d.appendChild(h.firstChild);
        d.removeChild(h);
      }
      l.insertBefore(d, i);
    }
    return [
      // first
      f ? f.nextSibling : l.firstChild,
      // last
      i ? i.previousSibling : l.lastChild
    ];
  }
}, Tu = "transition", br = "animation", ka = Symbol("_vtc"), tg = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, ig = /* @__PURE__ */ kn(
  {},
  Xm,
  tg
), DI = (e) => (e.displayName = "Transition", e.props = ig, e), ug = /* @__PURE__ */ DI(
  (e, { slots: l }) => gt(ch, ag(e), l)
), Yu = (e, l = []) => {
  Xe(e) ? e.forEach((i) => i(...l)) : e && e(...l);
}, Jf = (e) => e ? Xe(e) ? e.some((l) => l.length > 1) : e.length > 1 : !1;
function ag(e) {
  const l = {};
  for (const re in e)
    re in tg || (l[re] = e[re]);
  if (e.css === !1)
    return l;
  const {
    name: i = "v",
    type: a,
    duration: s,
    enterFromClass: o = `${i}-enter-from`,
    enterActiveClass: f = `${i}-enter-active`,
    enterToClass: d = `${i}-enter-to`,
    appearFromClass: h = o,
    appearActiveClass: x = f,
    appearToClass: y = d,
    leaveFromClass: I = `${i}-leave-from`,
    leaveActiveClass: q = `${i}-leave-active`,
    leaveToClass: R = `${i}-leave-to`
  } = e, E = OI(s), M = E && E[0], U = E && E[1], {
    onBeforeEnter: z,
    onEnter: X,
    onEnterCancelled: B,
    onLeave: K,
    onLeaveCancelled: W,
    onBeforeAppear: ae = z,
    onAppear: ne = X,
    onAppearCancelled: oe = B
  } = l, k = (re, ye, xe, Se) => {
    re._enterCancelled = Se, Au(re, ye ? y : d), Au(re, ye ? x : f), xe && xe();
  }, me = (re, ye) => {
    re._isLeaving = !1, Au(re, I), Au(re, R), Au(re, q), ye && ye();
  }, be = (re) => (ye, xe) => {
    const Se = re ? ne : X, ge = () => k(ye, re, xe);
    Yu(Se, [ye, ge]), ed(() => {
      Au(ye, re ? h : o), yi(ye, re ? y : d), Jf(Se) || nd(ye, a, M, ge);
    });
  };
  return kn(l, {
    onBeforeEnter(re) {
      Yu(z, [re]), yi(re, o), yi(re, f);
    },
    onBeforeAppear(re) {
      Yu(ae, [re]), yi(re, h), yi(re, x);
    },
    onEnter: be(!1),
    onAppear: be(!0),
    onLeave(re, ye) {
      re._isLeaving = !0;
      const xe = () => me(re, ye);
      yi(re, I), re._enterCancelled ? (yi(re, q), vm(re)) : (vm(re), yi(re, q)), ed(() => {
        re._isLeaving && (Au(re, I), yi(re, R), Jf(K) || nd(re, a, U, xe));
      }), Yu(K, [re, xe]);
    },
    onEnterCancelled(re) {
      k(re, !1, void 0, !0), Yu(B, [re]);
    },
    onAppearCancelled(re) {
      k(re, !0, void 0, !0), Yu(oe, [re]);
    },
    onLeaveCancelled(re) {
      me(re), Yu(W, [re]);
    }
  });
}
function OI(e) {
  if (e == null)
    return null;
  if (_n(e))
    return [So(e.enter), So(e.leave)];
  {
    const l = So(e);
    return [l, l];
  }
}
function So(e) {
  return cc(e);
}
function yi(e, l) {
  l.split(/\s+/).forEach((i) => i && e.classList.add(i)), (e[ka] || (e[ka] = /* @__PURE__ */ new Set())).add(l);
}
function Au(e, l) {
  l.split(/\s+/).forEach((a) => a && e.classList.remove(a));
  const i = e[ka];
  i && (i.delete(l), i.size || (e[ka] = void 0));
}
function ed(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e);
  });
}
let bI = 0;
function nd(e, l, i, a) {
  const s = e._endId = ++bI, o = () => {
    s === e._endId && a();
  };
  if (i != null)
    return setTimeout(o, i);
  const { type: f, timeout: d, propCount: h } = rg(e, l);
  if (!f)
    return a();
  const x = f + "end";
  let y = 0;
  const I = () => {
    e.removeEventListener(x, q), o();
  }, q = (R) => {
    R.target === e && ++y >= h && I();
  };
  setTimeout(() => {
    y < h && I();
  }, d + 1), e.addEventListener(x, q);
}
function rg(e, l) {
  const i = window.getComputedStyle(e), a = (E) => (i[E] || "").split(", "), s = a(`${Tu}Delay`), o = a(`${Tu}Duration`), f = ld(s, o), d = a(`${br}Delay`), h = a(`${br}Duration`), x = ld(d, h);
  let y = null, I = 0, q = 0;
  l === Tu ? f > 0 && (y = Tu, I = f, q = o.length) : l === br ? x > 0 && (y = br, I = x, q = h.length) : (I = Math.max(f, x), y = I > 0 ? f > x ? Tu : br : null, q = y ? y === Tu ? o.length : h.length : 0);
  const R = y === Tu && /\b(?:transform|all)(?:,|$)/.test(
    a(`${Tu}Property`).toString()
  );
  return {
    type: y,
    timeout: I,
    propCount: q,
    hasTransform: R
  };
}
function ld(e, l) {
  for (; e.length < l.length; )
    e = e.concat(e);
  return Math.max(...l.map((i, a) => td(i) + td(e[a])));
}
function td(e) {
  return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3;
}
function vm(e) {
  return (e ? e.ownerDocument : document).body.offsetHeight;
}
function wI(e, l, i) {
  const a = e[ka];
  a && (l = (l ? [l, ...a] : [...a]).join(" ")), l == null ? e.removeAttribute("class") : i ? e.setAttribute("class", l) : e.className = l;
}
const Lc = Symbol("_vod"), sg = Symbol("_vsh"), cg = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(e, { value: l }, { transition: i }) {
    e[Lc] = e.style.display === "none" ? "" : e.style.display, i && l ? i.beforeEnter(e) : wr(e, l);
  },
  mounted(e, { value: l }, { transition: i }) {
    i && l && i.enter(e);
  },
  updated(e, { value: l, oldValue: i }, { transition: a }) {
    !l != !i && (a ? l ? (a.beforeEnter(e), wr(e, !0), a.enter(e)) : a.leave(e, () => {
      wr(e, !1);
    }) : wr(e, l));
  },
  beforeUnmount(e, { value: l }) {
    wr(e, l);
  }
};
function wr(e, l) {
  e.style.display = l ? e[Lc] : "none", e[sg] = !l;
}
function SI() {
  cg.getSSRProps = ({ value: e }) => {
    if (!e)
      return { style: { display: "none" } };
  };
}
const og = Symbol("");
function CI(e) {
  const l = Xn();
  if (!l)
    return;
  const i = l.ut = (s = e(l.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${l.uid}"]`)
    ).forEach((o) => Dc(o, s));
  }, a = () => {
    const s = e(l.proxy);
    l.ce ? Dc(l.ce, s) : xm(l.subTree, s), i(s);
  };
  ef(() => {
    es(a);
  }), vl(() => {
    Cn(a, bt, { flush: "post" });
    const s = new MutationObserver(a);
    s.observe(l.subTree.el.parentNode, { childList: !0 }), Dt(() => s.disconnect());
  });
}
function xm(e, l) {
  if (e.shapeFlag & 128) {
    const i = e.suspense;
    e = i.activeBranch, i.pendingBranch && !i.isHydrating && i.effects.push(() => {
      xm(i.activeBranch, l);
    });
  }
  for (; e.component; )
    e = e.component.subTree;
  if (e.shapeFlag & 1 && e.el)
    Dc(e.el, l);
  else if (e.type === Mn)
    e.children.forEach((i) => xm(i, l));
  else if (e.type === ia) {
    let { el: i, anchor: a } = e;
    for (; i && (Dc(i, l), i !== a); )
      i = i.nextSibling;
  }
}
function Dc(e, l) {
  if (e.nodeType === 1) {
    const i = e.style;
    let a = "";
    for (const s in l) {
      const o = Yv(l[s]);
      i.setProperty(`--${s}`, o), a += `--${s}: ${o};`;
    }
    i[og] = a;
  }
}
const TI = /(?:^|;)\s*display\s*:/;
function PI(e, l, i) {
  const a = e.style, s = Wn(i);
  let o = !1;
  if (i && !s) {
    if (l)
      if (Wn(l))
        for (const f of l.split(";")) {
          const d = f.slice(0, f.indexOf(":")).trim();
          i[d] == null && tc(a, d, "");
        }
      else
        for (const f in l)
          i[f] == null && tc(a, f, "");
    for (const f in i)
      f === "display" && (o = !0), tc(a, f, i[f]);
  } else if (s) {
    if (l !== i) {
      const f = a[og];
      f && (i += ";" + f), a.cssText = i, o = TI.test(i);
    }
  } else l && e.removeAttribute("style");
  Lc in e && (e[Lc] = o ? a.display : "", e[sg] && (a.display = "none"));
}
const id = /\s*!important$/;
function tc(e, l, i) {
  if (Xe(i))
    i.forEach((a) => tc(e, l, a));
  else if (i == null && (i = ""), l.startsWith("--"))
    e.setProperty(l, i);
  else {
    const a = qI(e, l);
    id.test(i) ? e.setProperty(
      ht(a),
      i.replace(id, ""),
      "important"
    ) : e[a] = i;
  }
}
const ud = ["Webkit", "Moz", "ms"], Co = {};
function qI(e, l) {
  const i = Co[l];
  if (i)
    return i;
  let a = gl(l);
  if (a !== "filter" && a in e)
    return Co[l] = a;
  a = ps(a);
  for (let s = 0; s < ud.length; s++) {
    const o = ud[s] + a;
    if (o in e)
      return Co[l] = o;
  }
  return l;
}
const ad = "http://www.w3.org/1999/xlink";
function rd(e, l, i, a, s, o = $v(l)) {
  a && l.startsWith("xlink:") ? i == null ? e.removeAttributeNS(ad, l.slice(6, l.length)) : e.setAttributeNS(ad, l, i) : i == null || o && !qp(i) ? e.removeAttribute(l) : e.setAttribute(
    l,
    o ? "" : fi(i) ? String(i) : i
  );
}
function sd(e, l, i, a, s) {
  if (l === "innerHTML" || l === "textContent") {
    i != null && (e[l] = l === "innerHTML" ? lg(i) : i);
    return;
  }
  const o = e.tagName;
  if (l === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const d = o === "OPTION" ? e.getAttribute("value") || "" : e.value, h = i == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      e.type === "checkbox" ? "on" : ""
    ) : String(i);
    (d !== h || !("_value" in e)) && (e.value = h), i == null && e.removeAttribute(l), e._value = i;
    return;
  }
  let f = !1;
  if (i === "" || i == null) {
    const d = typeof e[l];
    d === "boolean" ? i = qp(i) : i == null && d === "string" ? (i = "", f = !0) : d === "number" && (i = 0, f = !0);
  }
  try {
    e[l] = i;
  } catch {
  }
  f && e.removeAttribute(s || l);
}
function _i(e, l, i, a) {
  e.addEventListener(l, i, a);
}
function RI(e, l, i, a) {
  e.removeEventListener(l, i, a);
}
const cd = Symbol("_vei");
function AI(e, l, i, a, s = null) {
  const o = e[cd] || (e[cd] = {}), f = o[l];
  if (a && f)
    f.value = a;
  else {
    const [d, h] = EI(l);
    if (a) {
      const x = o[l] = FI(
        a,
        s
      );
      _i(e, d, x, h);
    } else f && (RI(e, d, f, h), o[l] = void 0);
  }
}
const od = /(?:Once|Passive|Capture)$/;
function EI(e) {
  let l;
  if (od.test(e)) {
    l = {};
    let a;
    for (; a = e.match(od); )
      e = e.slice(0, e.length - a[0].length), l[a[0].toLowerCase()] = !0;
  }
  return [e[2] === ":" ? e.slice(3) : ht(e.slice(2)), l];
}
let To = 0;
const _I = /* @__PURE__ */ Promise.resolve(), NI = () => To || (_I.then(() => To = 0), To = Date.now());
function FI(e, l) {
  const i = (a) => {
    if (!a._vts)
      a._vts = Date.now();
    else if (a._vts <= i.attached)
      return;
    Ct(
      MI(a, i.value),
      l,
      5,
      [a]
    );
  };
  return i.value = e, i.attached = NI(), i;
}
function MI(e, l) {
  if (Xe(l)) {
    const i = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      i.call(e), e._stopped = !0;
    }, l.map(
      (a) => (s) => !s._stopped && a && a(s)
    );
  } else
    return l;
}
const md = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // lowercase letter
e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, kI = (e, l, i, a, s, o) => {
  const f = s === "svg";
  l === "class" ? wI(e, a, f) : l === "style" ? PI(e, i, a) : ds(l) ? Bm(l) || AI(e, l, i, a, o) : (l[0] === "." ? (l = l.slice(1), !0) : l[0] === "^" ? (l = l.slice(1), !1) : VI(e, l, a, f)) ? (sd(e, l, a), !e.tagName.includes("-") && (l === "value" || l === "checked" || l === "selected") && rd(e, l, a, f, o, l !== "value")) : /* #11081 force set props for possible async custom element */ e._isVueCE && (/[A-Z]/.test(l) || !Wn(a)) ? sd(e, gl(l), a, o, l) : (l === "true-value" ? e._trueValue = a : l === "false-value" && (e._falseValue = a), rd(e, l, a, f));
};
function VI(e, l, i, a) {
  if (a)
    return !!(l === "innerHTML" || l === "textContent" || l in e && md(l) && sn(i));
  if (l === "spellcheck" || l === "draggable" || l === "translate" || l === "autocorrect" || l === "form" || l === "list" && e.tagName === "INPUT" || l === "type" && e.tagName === "TEXTAREA")
    return !1;
  if (l === "width" || l === "height") {
    const s = e.tagName;
    if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE")
      return !1;
  }
  return md(l) && Wn(i) ? !1 : l in e;
}
const fd = {};
// @__NO_SIDE_EFFECTS__
function mg(e, l, i) {
  let a = /* @__PURE__ */ dn(e, l);
  Nc(a) && (a = kn({}, a, l));
  class s extends eo {
    constructor(f) {
      super(a, f, i);
    }
  }
  return s.def = a, s;
}
const BI = /* @__NO_SIDE_EFFECTS__ */ (e, l) => /* @__PURE__ */ mg(e, l, Og), ZI = typeof HTMLElement < "u" ? HTMLElement : class {
};
class eo extends ZI {
  constructor(l, i = {}, a = wc) {
    super(), this._def = l, this._props = i, this._createApp = a, this._isVueCE = !0, this._instance = null, this._app = null, this._nonce = this._def.nonce, this._connected = !1, this._resolved = !1, this._numberProps = null, this._styleChildren = /* @__PURE__ */ new WeakSet(), this._ob = null, this.shadowRoot && a !== wc ? this._root = this.shadowRoot : l.shadowRoot !== !1 ? (this.attachShadow(
      kn({}, l.shadowRootOptions, {
        mode: "open"
      })
    ), this._root = this.shadowRoot) : this._root = this;
  }
  connectedCallback() {
    if (!this.isConnected) return;
    !this.shadowRoot && !this._resolved && this._parseSlots(), this._connected = !0;
    let l = this;
    for (; l = l && (l.parentNode || l.host); )
      if (l instanceof eo) {
        this._parent = l;
        break;
      }
    this._instance || (this._resolved ? this._mount(this._def) : l && l._pendingResolve ? this._pendingResolve = l._pendingResolve.then(() => {
      this._pendingResolve = void 0, this._resolveDef();
    }) : this._resolveDef());
  }
  _setParent(l = this._parent) {
    l && (this._instance.parent = l._instance, this._inheritParentContext(l));
  }
  _inheritParentContext(l = this._parent) {
    l && this._app && Object.setPrototypeOf(
      this._app._context.provides,
      l._instance.provides
    );
  }
  disconnectedCallback() {
    this._connected = !1, il(() => {
      this._connected || (this._ob && (this._ob.disconnect(), this._ob = null), this._app && this._app.unmount(), this._instance && (this._instance.ce = void 0), this._app = this._instance = null, this._teleportTargets && (this._teleportTargets.clear(), this._teleportTargets = void 0));
    });
  }
  _processMutations(l) {
    for (const i of l)
      this._setAttr(i.attributeName);
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    if (this._pendingResolve)
      return;
    for (let a = 0; a < this.attributes.length; a++)
      this._setAttr(this.attributes[a].name);
    this._ob = new MutationObserver(this._processMutations.bind(this)), this._ob.observe(this, { attributes: !0 });
    const l = (a, s = !1) => {
      this._resolved = !0, this._pendingResolve = void 0;
      const { props: o, styles: f } = a;
      let d;
      if (o && !Xe(o))
        for (const h in o) {
          const x = o[h];
          (x === Number || x && x.type === Number) && (h in this._props && (this._props[h] = cc(this._props[h])), (d || (d = /* @__PURE__ */ Object.create(null)))[gl(h)] = !0);
        }
      this._numberProps = d, this._resolveProps(a), this.shadowRoot && this._applyStyles(f), this._mount(a);
    }, i = this._def.__asyncLoader;
    i ? this._pendingResolve = i().then((a) => {
      a.configureApp = this._def.configureApp, l(this._def = a, !0);
    }) : l(this._def);
  }
  _mount(l) {
    this._app = this._createApp(l), this._inheritParentContext(), l.configureApp && l.configureApp(this._app), this._app._ceVNode = this._createVNode(), this._app.mount(this._root);
    const i = this._instance && this._instance.exposed;
    if (i)
      for (const a in i)
        Pn(this, a) || Object.defineProperty(this, a, {
          // unwrap ref to be consistent with public instance behavior
          get: () => te(i[a])
        });
  }
  _resolveProps(l) {
    const { props: i } = l, a = Xe(i) ? i : Object.keys(i || {});
    for (const s of Object.keys(this))
      s[0] !== "_" && a.includes(s) && this._setProp(s, this[s]);
    for (const s of a.map(gl))
      Object.defineProperty(this, s, {
        get() {
          return this._getProp(s);
        },
        set(o) {
          this._setProp(s, o, !0, !0);
        }
      });
  }
  _setAttr(l) {
    if (l.startsWith("data-v-")) return;
    const i = this.hasAttribute(l);
    let a = i ? this.getAttribute(l) : fd;
    const s = gl(l);
    i && this._numberProps && this._numberProps[s] && (a = cc(a)), this._setProp(s, a, !1, !0);
  }
  /**
   * @internal
   */
  _getProp(l) {
    return this._props[l];
  }
  /**
   * @internal
   */
  _setProp(l, i, a = !0, s = !1) {
    if (i !== this._props[l] && (i === fd ? delete this._props[l] : (this._props[l] = i, l === "key" && this._app && (this._app._ceVNode.key = i)), s && this._instance && this._update(), a)) {
      const o = this._ob;
      o && (this._processMutations(o.takeRecords()), o.disconnect()), i === !0 ? this.setAttribute(ht(l), "") : typeof i == "string" || typeof i == "number" ? this.setAttribute(ht(l), i + "") : i || this.removeAttribute(ht(l)), o && o.observe(this, { attributes: !0 });
    }
  }
  _update() {
    const l = this._createVNode();
    this._app && (l.appContext = this._app._context), Dg(l, this._root);
  }
  _createVNode() {
    const l = {};
    this.shadowRoot || (l.onVnodeMounted = l.onVnodeUpdated = this._renderSlots.bind(this));
    const i = ze(this._def, kn(l, this._props));
    return this._instance || (i.ce = (a) => {
      this._instance = a, a.ce = this, a.isCE = !0;
      const s = (o, f) => {
        this.dispatchEvent(
          new CustomEvent(
            o,
            Nc(f[0]) ? kn({ detail: f }, f[0]) : { detail: f }
          )
        );
      };
      a.emit = (o, ...f) => {
        s(o, f), ht(o) !== o && s(ht(o), f);
      }, this._setParent();
    }), i;
  }
  _applyStyles(l, i) {
    if (!l) return;
    if (i) {
      if (i === this._def || this._styleChildren.has(i))
        return;
      this._styleChildren.add(i);
    }
    const a = this._nonce;
    for (let s = l.length - 1; s >= 0; s--) {
      const o = document.createElement("style");
      a && o.setAttribute("nonce", a), o.textContent = l[s], this.shadowRoot.prepend(o);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _parseSlots() {
    const l = this._slots = {};
    let i;
    for (; i = this.firstChild; ) {
      const a = i.nodeType === 1 && i.getAttribute("slot") || "default";
      (l[a] || (l[a] = [])).push(i), this.removeChild(i);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _renderSlots() {
    const l = this._getSlots(), i = this._instance.type.__scopeId;
    for (let a = 0; a < l.length; a++) {
      const s = l[a], o = s.getAttribute("name") || "default", f = this._slots[o], d = s.parentNode;
      if (f)
        for (const h of f) {
          if (i && h.nodeType === 1) {
            const x = i + "-s", y = document.createTreeWalker(h, 1);
            h.setAttribute(x, "");
            let I;
            for (; I = y.nextNode(); )
              I.setAttribute(x, "");
          }
          d.insertBefore(h, s);
        }
      else
        for (; s.firstChild; ) d.insertBefore(s.firstChild, s);
      d.removeChild(s);
    }
  }
  /**
   * @internal
   */
  _getSlots() {
    const l = [this];
    return this._teleportTargets && l.push(...this._teleportTargets), l.reduce((i, a) => (i.push(...Array.from(a.querySelectorAll("slot"))), i), []);
  }
  /**
   * @internal
   */
  _injectChildStyle(l) {
    this._applyStyles(l.styles, l);
  }
  /**
   * @internal
   */
  _removeChildStyle(l) {
  }
}
function fg(e) {
  const l = Xn(), i = l && l.ce;
  return i || null;
}
function UI() {
  const e = fg();
  return e && e.shadowRoot;
}
function KI(e = "$style") {
  {
    const l = Xn();
    if (!l)
      return On;
    const i = l.type.__cssModules;
    if (!i)
      return On;
    const a = i[e];
    return a || On;
  }
}
const dg = /* @__PURE__ */ new WeakMap(), pg = /* @__PURE__ */ new WeakMap(), Oc = Symbol("_moveCb"), dd = Symbol("_enterCb"), GI = (e) => (delete e.props.mode, e), zI = /* @__PURE__ */ GI({
  name: "TransitionGroup",
  props: /* @__PURE__ */ kn({}, ig, {
    tag: String,
    moveClass: String
  }),
  setup(e, { slots: l }) {
    const i = Xn(), a = Ym();
    let s, o;
    return Wc(() => {
      if (!s.length)
        return;
      const f = e.moveClass || `${e.name || "v"}-move`;
      if (!YI(
        s[0].el,
        i.vnode.el,
        f
      )) {
        s = [];
        return;
      }
      s.forEach(HI), s.forEach($I);
      const d = s.filter(WI);
      vm(i.vnode.el), d.forEach((h) => {
        const x = h.el, y = x.style;
        yi(x, f), y.transform = y.webkitTransform = y.transitionDuration = "";
        const I = x[Oc] = (q) => {
          q && q.target !== x || (!q || q.propertyName.endsWith("transform")) && (x.removeEventListener("transitionend", I), x[Oc] = null, Au(x, f));
        };
        x.addEventListener("transitionend", I);
      }), s = [];
    }), () => {
      const f = Ln(e), d = ag(f);
      let h = f.tag || Mn;
      if (s = [], o)
        for (let x = 0; x < o.length; x++) {
          const y = o[x];
          y.el && y.el instanceof Element && (s.push(y), Ui(
            y,
            Fa(
              y,
              d,
              a,
              i
            )
          ), dg.set(
            y,
            y.el.getBoundingClientRect()
          ));
        }
      o = l.default ? Hc(l.default()) : [];
      for (let x = 0; x < o.length; x++) {
        const y = o[x];
        y.key != null && Ui(
          y,
          Fa(y, d, a, i)
        );
      }
      return ze(h, null, o);
    };
  }
}), jI = zI;
function HI(e) {
  const l = e.el;
  l[Oc] && l[Oc](), l[dd] && l[dd]();
}
function $I(e) {
  pg.set(e, e.el.getBoundingClientRect());
}
function WI(e) {
  const l = dg.get(e), i = pg.get(e), a = l.left - i.left, s = l.top - i.top;
  if (a || s) {
    const o = e.el.style;
    return o.transform = o.webkitTransform = `translate(${a}px,${s}px)`, o.transitionDuration = "0s", e;
  }
}
function YI(e, l, i) {
  const a = e.cloneNode(), s = e[ka];
  s && s.forEach((d) => {
    d.split(/\s+/).forEach((h) => h && a.classList.remove(h));
  }), i.split(/\s+/).forEach((d) => d && a.classList.add(d)), a.style.display = "none";
  const o = l.nodeType === 1 ? l : l.parentNode;
  o.appendChild(a);
  const { hasTransform: f } = rg(a);
  return o.removeChild(a), f;
}
const Ku = (e) => {
  const l = e.props["onUpdate:modelValue"] || !1;
  return Xe(l) ? (i) => Ra(l, i) : l;
};
function XI(e) {
  e.target.composing = !0;
}
function pd(e) {
  const l = e.target;
  l.composing && (l.composing = !1, l.dispatchEvent(new Event("input")));
}
const wt = Symbol("_assign"), bc = {
  created(e, { modifiers: { lazy: l, trim: i, number: a } }, s) {
    e[wt] = Ku(s);
    const o = a || s.props && s.props.type === "number";
    _i(e, l ? "change" : "input", (f) => {
      if (f.target.composing) return;
      let d = e.value;
      i && (d = d.trim()), o && (d = sc(d)), e[wt](d);
    }), i && _i(e, "change", () => {
      e.value = e.value.trim();
    }), l || (_i(e, "compositionstart", XI), _i(e, "compositionend", pd), _i(e, "change", pd));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(e, { value: l }) {
    e.value = l ?? "";
  },
  beforeUpdate(e, { value: l, oldValue: i, modifiers: { lazy: a, trim: s, number: o } }, f) {
    if (e[wt] = Ku(f), e.composing) return;
    const d = (o || e.type === "number") && !/^0\d/.test(e.value) ? sc(e.value) : e.value, h = l ?? "";
    d !== h && (document.activeElement === e && e.type !== "range" && (a && l === i || s && e.value.trim() === h) || (e.value = h));
  }
}, df = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(e, l, i) {
    e[wt] = Ku(i), _i(e, "change", () => {
      const a = e._modelValue, s = Va(e), o = e.checked, f = e[wt];
      if (Xe(a)) {
        const d = Vc(a, s), h = d !== -1;
        if (o && !h)
          f(a.concat(s));
        else if (!o && h) {
          const x = [...a];
          x.splice(d, 1), f(x);
        }
      } else if (sa(a)) {
        const d = new Set(a);
        o ? d.add(s) : d.delete(s), f(d);
      } else
        f(gg(e, o));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: hd,
  beforeUpdate(e, l, i) {
    e[wt] = Ku(i), hd(e, l, i);
  }
};
function hd(e, { value: l, oldValue: i }, a) {
  e._modelValue = l;
  let s;
  if (Xe(l))
    s = Vc(l, a.props.value) > -1;
  else if (sa(l))
    s = l.has(a.props.value);
  else {
    if (l === i) return;
    s = Uu(l, gg(e, !0));
  }
  e.checked !== s && (e.checked = s);
}
const pf = {
  created(e, { value: l }, i) {
    e.checked = Uu(l, i.props.value), e[wt] = Ku(i), _i(e, "change", () => {
      e[wt](Va(e));
    });
  },
  beforeUpdate(e, { value: l, oldValue: i }, a) {
    e[wt] = Ku(a), l !== i && (e.checked = Uu(l, a.props.value));
  }
}, hg = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(e, { value: l, modifiers: { number: i } }, a) {
    const s = sa(l);
    _i(e, "change", () => {
      const o = Array.prototype.filter.call(e.options, (f) => f.selected).map(
        (f) => i ? sc(Va(f)) : Va(f)
      );
      e[wt](
        e.multiple ? s ? new Set(o) : o : o[0]
      ), e._assigning = !0, il(() => {
        e._assigning = !1;
      });
    }), e[wt] = Ku(a);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(e, { value: l }) {
    gd(e, l);
  },
  beforeUpdate(e, l, i) {
    e[wt] = Ku(i);
  },
  updated(e, { value: l }) {
    e._assigning || gd(e, l);
  }
};
function gd(e, l) {
  const i = e.multiple, a = Xe(l);
  if (!(i && !a && !sa(l))) {
    for (let s = 0, o = e.options.length; s < o; s++) {
      const f = e.options[s], d = Va(f);
      if (i)
        if (a) {
          const h = typeof d;
          h === "string" || h === "number" ? f.selected = l.some((x) => String(x) === String(d)) : f.selected = Vc(l, d) > -1;
        } else
          f.selected = l.has(d);
      else if (Uu(Va(f), l)) {
        e.selectedIndex !== s && (e.selectedIndex = s);
        return;
      }
    }
    !i && e.selectedIndex !== -1 && (e.selectedIndex = -1);
  }
}
function Va(e) {
  return "_value" in e ? e._value : e.value;
}
function gg(e, l) {
  const i = l ? "_trueValue" : "_falseValue";
  return i in e ? e[i] : l;
}
const vg = {
  created(e, l, i) {
    Vs(e, l, i, null, "created");
  },
  mounted(e, l, i) {
    Vs(e, l, i, null, "mounted");
  },
  beforeUpdate(e, l, i, a) {
    Vs(e, l, i, a, "beforeUpdate");
  },
  updated(e, l, i, a) {
    Vs(e, l, i, a, "updated");
  }
};
function xg(e, l) {
  switch (e) {
    case "SELECT":
      return hg;
    case "TEXTAREA":
      return bc;
    default:
      switch (l) {
        case "checkbox":
          return df;
        case "radio":
          return pf;
        default:
          return bc;
      }
  }
}
function Vs(e, l, i, a, s) {
  const f = xg(
    e.tagName,
    i.props && i.props.type
  )[s];
  f && f(e, l, i, a);
}
function QI() {
  bc.getSSRProps = ({ value: e }) => ({ value: e }), pf.getSSRProps = ({ value: e }, l) => {
    if (l.props && Uu(l.props.value, e))
      return { checked: !0 };
  }, df.getSSRProps = ({ value: e }, l) => {
    if (Xe(e)) {
      if (l.props && Vc(e, l.props.value) > -1)
        return { checked: !0 };
    } else if (sa(e)) {
      if (l.props && e.has(l.props.value))
        return { checked: !0 };
    } else if (e)
      return { checked: !0 };
  }, vg.getSSRProps = (e, l) => {
    if (typeof l.type != "string")
      return;
    const i = xg(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      l.type.toUpperCase(),
      l.props && l.props.type
    );
    if (i.getSSRProps)
      return i.getSSRProps(e, l);
  };
}
const JI = ["ctrl", "shift", "alt", "meta"], eL = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, l) => JI.some((i) => e[`${i}Key`] && !l.includes(i))
}, si = (e, l) => {
  const i = e._withMods || (e._withMods = {}), a = l.join(".");
  return i[a] || (i[a] = (s, ...o) => {
    for (let f = 0; f < l.length; f++) {
      const d = eL[l[f]];
      if (d && d(s, l)) return;
    }
    return e(s, ...o);
  });
}, nL = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, mi = (e, l) => {
  const i = e._withKeys || (e._withKeys = {}), a = l.join(".");
  return i[a] || (i[a] = (s) => {
    if (!("key" in s))
      return;
    const o = ht(s.key);
    if (l.some(
      (f) => f === o || nL[f] === o
    ))
      return e(s);
  });
}, yg = /* @__PURE__ */ kn({ patchProp: kI }, LI);
let zr, vd = !1;
function Ig() {
  return zr || (zr = Eh(yg));
}
function Lg() {
  return zr = vd ? zr : _h(yg), vd = !0, zr;
}
const Dg = (...e) => {
  Ig().render(...e);
}, lL = (...e) => {
  Lg().hydrate(...e);
}, wc = (...e) => {
  const l = Ig().createApp(...e), { mount: i } = l;
  return l.mount = (a) => {
    const s = wg(a);
    if (!s) return;
    const o = l._component;
    !sn(o) && !o.render && !o.template && (o.template = s.innerHTML), s.nodeType === 1 && (s.textContent = "");
    const f = i(s, !1, bg(s));
    return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), f;
  }, l;
}, Og = (...e) => {
  const l = Lg().createApp(...e), { mount: i } = l;
  return l.mount = (a) => {
    const s = wg(a);
    if (s)
      return i(s, !0, bg(s));
  }, l;
};
function bg(e) {
  if (e instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement)
    return "mathml";
}
function wg(e) {
  return Wn(e) ? document.querySelector(e) : e;
}
let xd = !1;
const tL = () => {
  xd || (xd = !0, QI(), SI());
};
const iL = () => {
}, uL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition: ch,
  BaseTransitionPropsValidators: Xm,
  Comment: ul,
  DeprecationTypes: xI,
  EffectScope: Gm,
  ErrorCodes: Ex,
  ErrorTypeStrings: mI,
  Fragment: Mn,
  KeepAlive: iy,
  ReactiveEffect: Xr,
  Static: ia,
  Suspense: Hy,
  Teleport: Ux,
  Text: Zu,
  TrackOpTypes: Sx,
  Transition: ug,
  TransitionGroup: jI,
  TriggerOpTypes: Cx,
  VueElement: eo,
  assertNumber: Ax,
  callWithAsyncErrorHandling: Ct,
  callWithErrorHandling: Ha,
  camelize: gl,
  capitalize: ps,
  cloneVNode: di,
  compatUtils: vI,
  compile: iL,
  computed: _e,
  createApp: wc,
  createBlock: xn,
  createCommentVNode: pi,
  createElementBlock: Yn,
  createElementVNode: fn,
  createHydrationRenderer: _h,
  createPropsRestProxy: Dy,
  createRenderer: Eh,
  createSSRApp: Og,
  createSlots: cy,
  createStaticVNode: nI,
  createTextVNode: Gi,
  createVNode: ze,
  customRef: ja,
  defineAsyncComponent: ly,
  defineComponent: dn,
  defineCustomElement: mg,
  defineEmits: dy,
  defineExpose: py,
  defineModel: vy,
  defineOptions: hy,
  defineProps: fy,
  defineSSRCustomElement: BI,
  defineSlots: gy,
  devtools: fI,
  effect: Qv,
  effectScope: Bc,
  getCurrentInstance: Xn,
  getCurrentScope: $i,
  getCurrentWatcher: Tx,
  getTransitionRawChildren: Hc,
  guardReactiveProps: mf,
  h: gt,
  handleError: oa,
  hasInjectionContext: Xc,
  hydrate: lL,
  hydrateOnIdle: Yx,
  hydrateOnInteraction: ey,
  hydrateOnMediaQuery: Jx,
  hydrateOnVisible: Qx,
  initCustomFormatter: cI,
  initDirectivesForSSR: tL,
  inject: Fi,
  isMemoSame: eg,
  isProxy: zc,
  isReactive: oi,
  isReadonly: Zi,
  isRef: Vn,
  isRuntimeOnly: aI,
  isShallow: yt,
  isVNode: Ki,
  markRaw: za,
  mergeDefaults: Dh,
  mergeModels: Ly,
  mergeProps: pl,
  nextTick: il,
  normalizeClass: Bl,
  normalizeProps: kc,
  normalizeStyle: Hi,
  onActivated: fh,
  onBeforeMount: hh,
  onBeforeUnmount: vs,
  onBeforeUpdate: ef,
  onDeactivated: dh,
  onErrorCaptured: yh,
  onMounted: vl,
  onRenderTracked: xh,
  onRenderTriggered: vh,
  onScopeDispose: ca,
  onServerPrefetch: gh,
  onUnmounted: Dt,
  onUpdated: Wc,
  onWatcherCleanup: Xp,
  openBlock: Ye,
  popScopeId: kx,
  provide: Yc,
  proxyRefs: $m,
  pushScopeId: Mx,
  queuePostFlushCb: es,
  reactive: Ga,
  readonly: Bi,
  ref: Fe,
  registerRuntimeCompiler: uI,
  render: Dg,
  renderList: ys,
  renderSlot: qn,
  resolveComponent: ry,
  resolveDirective: sy,
  resolveDynamicComponent: xs,
  resolveFilter: gI,
  resolveTransitionHooks: Fa,
  setBlockTracking: us,
  setDevtoolsHook: dI,
  setTransitionHooks: Ui,
  shallowReactive: $p,
  shallowReadonly: _u,
  shallowRef: Fl,
  ssrContextKey: kh,
  ssrUtils: hI,
  stop: Jv,
  toDisplayString: Ul,
  toHandlerKey: qa,
  toHandlers: oy,
  toRaw: Ln,
  toRef: hs,
  toRefs: St,
  toValue: hn,
  transformVNodeArgs: Jy,
  triggerRef: yx,
  unref: te,
  useAttrs: Iy,
  useCssModule: KI,
  useCssVars: CI,
  useHost: fg,
  useId: mh,
  useModel: Vy,
  useSSRContext: Vh,
  useShadowRoot: UI,
  useSlots: yy,
  useTemplateRef: Jm,
  useTransitionState: Ym,
  vModelCheckbox: df,
  vModelDynamic: vg,
  vModelRadio: pf,
  vModelSelect: hg,
  vModelText: bc,
  vShow: cg,
  version: ng,
  warn: oI,
  watch: Cn,
  watchEffect: Ml,
  watchPostEffect: cf,
  watchSyncEffect: of,
  withAsyncContext: Oy,
  withCtx: ln,
  withDefaults: xy,
  withDirectives: Bx,
  withKeys: mi,
  withMemo: Jh,
  withModifiers: si,
  withScopeId: Vx
}, Symbol.toStringTag, { value: "Module" }));
let Sg;
const no = (e) => Sg = e, Cg = (
  /* istanbul ignore next */
  Symbol()
);
function ym(e) {
  return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function";
}
var jr;
(function(e) {
  e.direct = "direct", e.patchObject = "patch object", e.patchFunction = "patch function";
})(jr || (jr = {}));
function aL() {
  const e = Bc(!0), l = e.run(() => Fe({}));
  let i = [], a = [];
  const s = za({
    install(o) {
      no(s), s._a = o, o.provide(Cg, s), o.config.globalProperties.$pinia = s, a.forEach((f) => i.push(f)), a = [];
    },
    use(o) {
      return this._a ? i.push(o) : a.push(o), this;
    },
    _p: i,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: e,
    _s: /* @__PURE__ */ new Map(),
    state: l
  });
  return s;
}
const Tg = () => {
};
function yd(e, l, i, a = Tg) {
  e.add(l);
  const s = () => {
    e.delete(l) && a();
  };
  return !i && $i() && ca(s), s;
}
function xa(e, ...l) {
  e.forEach((i) => {
    i(...l);
  });
}
const rL = (e) => e(), Id = Symbol(), Po = Symbol();
function Im(e, l) {
  e instanceof Map && l instanceof Map ? l.forEach((i, a) => e.set(a, i)) : e instanceof Set && l instanceof Set && l.forEach(e.add, e);
  for (const i in l) {
    if (!l.hasOwnProperty(i))
      continue;
    const a = l[i], s = e[i];
    ym(s) && ym(a) && e.hasOwnProperty(i) && !Vn(a) && !oi(a) ? e[i] = Im(s, a) : e[i] = a;
  }
  return e;
}
const sL = (
  /* istanbul ignore next */
  Symbol()
);
function cL(e) {
  return !ym(e) || !Object.prototype.hasOwnProperty.call(e, sL);
}
const { assign: Eu } = Object;
function oL(e) {
  return !!(Vn(e) && e.effect);
}
function mL(e, l, i, a) {
  const { state: s, actions: o, getters: f } = l, d = i.state.value[e];
  let h;
  function x() {
    d || (i.state.value[e] = s ? s() : {});
    const y = St(i.state.value[e]);
    return Eu(y, o, Object.keys(f || {}).reduce((I, q) => (I[q] = za(_e(() => {
      no(i);
      const R = i._s.get(e);
      return f[q].call(R, R);
    })), I), {}));
  }
  return h = Pg(e, x, l, i, a, !0), h;
}
function Pg(e, l, i = {}, a, s, o) {
  let f;
  const d = Eu({ actions: {} }, i), h = { deep: !0 };
  let x, y, I = /* @__PURE__ */ new Set(), q = /* @__PURE__ */ new Set(), R;
  const E = a.state.value[e];
  !o && !E && (a.state.value[e] = {}), Fe({});
  let M;
  function U(oe) {
    let k;
    x = y = !1, typeof oe == "function" ? (oe(a.state.value[e]), k = {
      type: jr.patchFunction,
      storeId: e,
      events: R
    }) : (Im(a.state.value[e], oe), k = {
      type: jr.patchObject,
      payload: oe,
      storeId: e,
      events: R
    });
    const me = M = Symbol();
    il().then(() => {
      M === me && (x = !0);
    }), y = !0, xa(I, k, a.state.value[e]);
  }
  const z = o ? function() {
    const { state: k } = i, me = k ? k() : {};
    this.$patch((be) => {
      Eu(be, me);
    });
  } : (
    /* istanbul ignore next */
    Tg
  );
  function X() {
    f.stop(), I.clear(), q.clear(), a._s.delete(e);
  }
  const B = (oe, k = "") => {
    if (Id in oe)
      return oe[Po] = k, oe;
    const me = function() {
      no(a);
      const be = Array.from(arguments), re = /* @__PURE__ */ new Set(), ye = /* @__PURE__ */ new Set();
      function xe(ce) {
        re.add(ce);
      }
      function Se(ce) {
        ye.add(ce);
      }
      xa(q, {
        args: be,
        name: me[Po],
        store: W,
        after: xe,
        onError: Se
      });
      let ge;
      try {
        ge = oe.apply(this && this.$id === e ? this : W, be);
      } catch (ce) {
        throw xa(ye, ce), ce;
      }
      return ge instanceof Promise ? ge.then((ce) => (xa(re, ce), ce)).catch((ce) => (xa(ye, ce), Promise.reject(ce))) : (xa(re, ge), ge);
    };
    return me[Id] = !0, me[Po] = k, me;
  }, K = {
    _p: a,
    // _s: scope,
    $id: e,
    $onAction: yd.bind(null, q),
    $patch: U,
    $reset: z,
    $subscribe(oe, k = {}) {
      const me = yd(I, oe, k.detached, () => be()), be = f.run(() => Cn(() => a.state.value[e], (re) => {
        (k.flush === "sync" ? y : x) && oe({
          storeId: e,
          type: jr.direct,
          events: R
        }, re);
      }, Eu({}, h, k)));
      return me;
    },
    $dispose: X
  }, W = Ga(K);
  a._s.set(e, W);
  const ne = (a._a && a._a.runWithContext || rL)(() => a._e.run(() => (f = Bc()).run(() => l({ action: B }))));
  for (const oe in ne) {
    const k = ne[oe];
    if (Vn(k) && !oL(k) || oi(k))
      o || (E && cL(k) && (Vn(k) ? k.value = E[oe] : Im(k, E[oe])), a.state.value[e][oe] = k);
    else if (typeof k == "function") {
      const me = B(k, oe);
      ne[oe] = me, d.actions[oe] = k;
    }
  }
  return Eu(W, ne), Eu(Ln(W), ne), Object.defineProperty(W, "$state", {
    get: () => a.state.value[e],
    set: (oe) => {
      U((k) => {
        Eu(k, oe);
      });
    }
  }), a._p.forEach((oe) => {
    Eu(W, f.run(() => oe({
      store: W,
      app: a._a,
      pinia: a,
      options: d
    })));
  }), E && o && i.hydrate && i.hydrate(W.$state, E), x = !0, y = !0, W;
}
// @__NO_SIDE_EFFECTS__
function lo(e, l, i) {
  let a;
  const s = typeof l == "function";
  a = s ? i : l;
  function o(f, d) {
    const h = Xc();
    return f = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    f || (h ? Fi(Cg, null) : null), f && no(f), f = Sg, f._s.has(e) || (s ? Pg(e, l, a, f) : mL(e, a, f)), f._s.get(e);
  }
  return o.$id = e, o;
}
function Lt(e) {
  const l = Ln(e), i = {};
  for (const a in l) {
    const s = l[a];
    s.effect ? i[a] = // ...
    _e({
      get: () => e[a],
      set(o) {
        e[a] = o;
      }
    }) : (Vn(s) || oi(s)) && (i[a] = // ---
    hs(e, a));
  }
  return i;
}
var fL = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function dL(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Lm = { exports: {} }, pL = Lm.exports, Ld;
function hL() {
  return Ld || (Ld = 1, function(e, l) {
    (function(i, a) {
      e.exports = a();
    })(pL, function() {
      var i = function(n, t) {
        return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(u, r) {
          u.__proto__ = r;
        } || function(u, r) {
          for (var c in r) Object.prototype.hasOwnProperty.call(r, c) && (u[c] = r[c]);
        })(n, t);
      }, a = function() {
        return (a = Object.assign || function(n) {
          for (var t, u = 1, r = arguments.length; u < r; u++) for (var c in t = arguments[u]) Object.prototype.hasOwnProperty.call(t, c) && (n[c] = t[c]);
          return n;
        }).apply(this, arguments);
      };
      function s(n, t, u) {
        for (var r, c = 0, m = t.length; c < m; c++) !r && c in t || ((r = r || Array.prototype.slice.call(t, 0, c))[c] = t[c]);
        return n.concat(r || Array.prototype.slice.call(t));
      }
      var o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : fL, f = Object.keys, d = Array.isArray;
      function h(n, t) {
        return typeof t != "object" || f(t).forEach(function(u) {
          n[u] = t[u];
        }), n;
      }
      typeof Promise > "u" || o.Promise || (o.Promise = Promise);
      var x = Object.getPrototypeOf, y = {}.hasOwnProperty;
      function I(n, t) {
        return y.call(n, t);
      }
      function q(n, t) {
        typeof t == "function" && (t = t(x(n))), (typeof Reflect > "u" ? f : Reflect.ownKeys)(t).forEach(function(u) {
          E(n, u, t[u]);
        });
      }
      var R = Object.defineProperty;
      function E(n, t, u, r) {
        R(n, t, h(u && I(u, "get") && typeof u.get == "function" ? { get: u.get, set: u.set, configurable: !0 } : { value: u, configurable: !0, writable: !0 }, r));
      }
      function M(n) {
        return { from: function(t) {
          return n.prototype = Object.create(t.prototype), E(n.prototype, "constructor", n), { extend: q.bind(null, n.prototype) };
        } };
      }
      var U = Object.getOwnPropertyDescriptor, z = [].slice;
      function X(n, t, u) {
        return z.call(n, t, u);
      }
      function B(n, t) {
        return t(n);
      }
      function K(n) {
        if (!n) throw new Error("Assertion Failed");
      }
      function W(n) {
        o.setImmediate ? setImmediate(n) : setTimeout(n, 0);
      }
      function ae(n, t) {
        if (typeof t == "string" && I(n, t)) return n[t];
        if (!t) return n;
        if (typeof t != "string") {
          for (var u = [], r = 0, c = t.length; r < c; ++r) {
            var m = ae(n, t[r]);
            u.push(m);
          }
          return u;
        }
        var p = t.indexOf(".");
        if (p !== -1) {
          var g = n[t.substr(0, p)];
          return g == null ? void 0 : ae(g, t.substr(p + 1));
        }
      }
      function ne(n, t, u) {
        if (n && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(n))) if (typeof t != "string" && "length" in t) {
          K(typeof u != "string" && "length" in u);
          for (var r = 0, c = t.length; r < c; ++r) ne(n, t[r], u[r]);
        } else {
          var m, p, g = t.indexOf(".");
          g !== -1 ? (m = t.substr(0, g), (p = t.substr(g + 1)) === "" ? u === void 0 ? d(n) && !isNaN(parseInt(m)) ? n.splice(m, 1) : delete n[m] : n[m] = u : ne(g = !(g = n[m]) || !I(n, m) ? n[m] = {} : g, p, u)) : u === void 0 ? d(n) && !isNaN(parseInt(t)) ? n.splice(t, 1) : delete n[t] : n[t] = u;
        }
      }
      function oe(n) {
        var t, u = {};
        for (t in n) I(n, t) && (u[t] = n[t]);
        return u;
      }
      var k = [].concat;
      function me(n) {
        return k.apply([], n);
      }
      var Ue = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(me([8, 16, 32, 64].map(function(n) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + n + "Array";
        });
      }))).filter(function(n) {
        return o[n];
      }), be = new Set(Ue.map(function(n) {
        return o[n];
      })), re = null;
      function ye(n) {
        return re = /* @__PURE__ */ new WeakMap(), n = function t(u) {
          if (!u || typeof u != "object") return u;
          var r = re.get(u);
          if (r) return r;
          if (d(u)) {
            r = [], re.set(u, r);
            for (var c = 0, m = u.length; c < m; ++c) r.push(t(u[c]));
          } else if (be.has(u.constructor)) r = u;
          else {
            var p, g = x(u);
            for (p in r = g === Object.prototype ? {} : Object.create(g), re.set(u, r), u) I(u, p) && (r[p] = t(u[p]));
          }
          return r;
        }(n), re = null, n;
      }
      var xe = {}.toString;
      function Se(n) {
        return xe.call(n).slice(8, -1);
      }
      var ge = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", ce = typeof ge == "symbol" ? function(n) {
        var t;
        return n != null && (t = n[ge]) && t.apply(n);
      } : function() {
        return null;
      };
      function de(n, t) {
        return t = n.indexOf(t), 0 <= t && n.splice(t, 1), 0 <= t;
      }
      var Le = {};
      function Ae(n) {
        var t, u, r, c;
        if (arguments.length === 1) {
          if (d(n)) return n.slice();
          if (this === Le && typeof n == "string") return [n];
          if (c = ce(n)) {
            for (u = []; !(r = c.next()).done; ) u.push(r.value);
            return u;
          }
          if (n == null) return [n];
          if (typeof (t = n.length) != "number") return [n];
          for (u = new Array(t); t--; ) u[t] = n[t];
          return u;
        }
        for (t = arguments.length, u = new Array(t); t--; ) u[t] = arguments[t];
        return u;
      }
      var We = typeof Symbol < "u" ? function(n) {
        return n[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ze = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], In = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ze), je = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function cn(n, t) {
        this.name = n, this.message = t;
      }
      function bn(n, t) {
        return n + ". Errors: " + Object.keys(t).map(function(u) {
          return t[u].toString();
        }).filter(function(u, r, c) {
          return c.indexOf(u) === r;
        }).join(`
`);
      }
      function gn(n, t, u, r) {
        this.failures = t, this.failedKeys = r, this.successCount = u, this.message = bn(n, t);
      }
      function tn(n, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(u) {
          return t[u];
        }), this.failuresByPos = t, this.message = bn(n, this.failures);
      }
      M(cn).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), M(gn).from(cn), M(tn).from(cn);
      var V = In.reduce(function(n, t) {
        return n[t] = t + "Error", n;
      }, {}), _ = cn, Z = In.reduce(function(n, t) {
        var u = t + "Error";
        function r(c, m) {
          this.name = u, c ? typeof c == "string" ? (this.message = "".concat(c).concat(m ? `
 ` + m : ""), this.inner = m || null) : typeof c == "object" && (this.message = "".concat(c.name, " ").concat(c.message), this.inner = c) : (this.message = je[t] || u, this.inner = null);
        }
        return M(r).from(_), n[t] = r, n;
      }, {});
      Z.Syntax = SyntaxError, Z.Type = TypeError, Z.Range = RangeError;
      var ue = Ze.reduce(function(n, t) {
        return n[t + "Error"] = Z[t], n;
      }, {}), Qe = In.reduce(function(n, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (n[t + "Error"] = Z[t]), n;
      }, {});
      function De() {
      }
      function j(n) {
        return n;
      }
      function ie(n, t) {
        return n == null || n === j ? t : function(u) {
          return t(n(u));
        };
      }
      function fe(n, t) {
        return function() {
          n.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function Ce(n, t) {
        return n === De ? t : function() {
          var u = n.apply(this, arguments);
          u !== void 0 && (arguments[0] = u);
          var r = this.onsuccess, c = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var m = t.apply(this, arguments);
          return r && (this.onsuccess = this.onsuccess ? fe(r, this.onsuccess) : r), c && (this.onerror = this.onerror ? fe(c, this.onerror) : c), m !== void 0 ? m : u;
        };
      }
      function Ie(n, t) {
        return n === De ? t : function() {
          n.apply(this, arguments);
          var u = this.onsuccess, r = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), u && (this.onsuccess = this.onsuccess ? fe(u, this.onsuccess) : u), r && (this.onerror = this.onerror ? fe(r, this.onerror) : r);
        };
      }
      function we(n, t) {
        return n === De ? t : function(u) {
          var r = n.apply(this, arguments);
          h(u, r);
          var c = this.onsuccess, m = this.onerror;
          return this.onsuccess = null, this.onerror = null, u = t.apply(this, arguments), c && (this.onsuccess = this.onsuccess ? fe(c, this.onsuccess) : c), m && (this.onerror = this.onerror ? fe(m, this.onerror) : m), r === void 0 ? u === void 0 ? void 0 : u : h(r, u);
        };
      }
      function Ne(n, t) {
        return n === De ? t : function() {
          return t.apply(this, arguments) !== !1 && n.apply(this, arguments);
        };
      }
      function Ee(n, t) {
        return n === De ? t : function() {
          var u = n.apply(this, arguments);
          if (u && typeof u.then == "function") {
            for (var r = this, c = arguments.length, m = new Array(c); c--; ) m[c] = arguments[c];
            return u.then(function() {
              return t.apply(r, m);
            });
          }
          return t.apply(this, arguments);
        };
      }
      Qe.ModifyError = gn, Qe.DexieError = cn, Qe.BulkError = tn;
      var Oe = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function Pe(n) {
        Oe = n;
      }
      var Ke = {}, ke = 100, Ue = typeof Promise > "u" ? [] : function() {
        var n = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [n, x(n), n];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, x(t), n];
      }(), Ze = Ue[0], In = Ue[1], Ue = Ue[2], In = In && In.then, Je = Ze && Ze.constructor, yn = !!Ue, on = function(n, t) {
        Fn.push([n, t]), Tn && (queueMicrotask(Ja), Tn = !1);
      }, Bn = !0, Tn = !0, Dn = [], Nn = [], yl = j, Rn = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: De, pgp: !1, env: {}, finalize: De }, se = Rn, Fn = [], Zn = 0, Il = [];
      function ee(n) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = se;
        if (typeof n != "function") {
          if (n !== Ke) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && qt(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function u(r, c) {
          try {
            c(function(m) {
              if (r._state === null) {
                if (m === r) throw new TypeError("A promise cannot be resolved with itself.");
                var p = r._lib && rl();
                m && typeof m.then == "function" ? u(r, function(g, L) {
                  m instanceof ee ? m._then(g, L) : m.then(g, L);
                }) : (r._state = !0, r._value = m, Xi(r)), p && sl();
              }
            }, qt.bind(null, r));
          } catch (m) {
            qt(r, m);
          }
        }(this, n);
      }
      var Pt = { get: function() {
        var n = se, t = Hl;
        function u(r, c) {
          var m = this, p = !n.global && (n !== se || t !== Hl), g = p && !Kn(), L = new ee(function(O, w) {
            Rt(m, new Yi(Ji(r, n, p, g), Ji(c, n, p, g), O, w, n));
          });
          return this._consoleTask && (L._consoleTask = this._consoleTask), L;
        }
        return u.prototype = Ke, u;
      }, set: function(n) {
        E(this, "then", n && n.prototype === Ke ? Pt : { get: function() {
          return n;
        }, set: Pt.set });
      } };
      function Yi(n, t, u, r, c) {
        this.onFulfilled = typeof n == "function" ? n : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = u, this.reject = r, this.psd = c;
      }
      function qt(n, t) {
        var u, r;
        Nn.push(t), n._state === null && (u = n._lib && rl(), t = yl(t), n._state = !1, n._value = t, r = n, Dn.some(function(c) {
          return c._value === r._value;
        }) || Dn.push(r), Xi(n), u && sl());
      }
      function Xi(n) {
        var t = n._listeners;
        n._listeners = [];
        for (var u = 0, r = t.length; u < r; ++u) Rt(n, t[u]);
        var c = n._PSD;
        --c.ref || c.finalize(), Zn === 0 && (++Zn, on(function() {
          --Zn == 0 && At();
        }, []));
      }
      function Rt(n, t) {
        if (n._state !== null) {
          var u = n._state ? t.onFulfilled : t.onRejected;
          if (u === null) return (n._state ? t.resolve : t.reject)(n._value);
          ++t.psd.ref, ++Zn, on(Qa, [u, n, t]);
        } else n._listeners.push(t);
      }
      function Qa(n, t, u) {
        try {
          var r, c = t._value;
          !t._state && Nn.length && (Nn = []), r = Oe && t._consoleTask ? t._consoleTask.run(function() {
            return n(c);
          }) : n(c), t._state || Nn.indexOf(c) !== -1 || function(m) {
            for (var p = Dn.length; p; ) if (Dn[--p]._value === m._value) return Dn.splice(p, 1);
          }(t), u.resolve(r);
        } catch (m) {
          u.reject(m);
        } finally {
          --Zn == 0 && At(), --u.psd.ref || u.psd.finalize();
        }
      }
      function Ja() {
        Qn(Rn, function() {
          rl() && sl();
        });
      }
      function rl() {
        var n = Bn;
        return Tn = Bn = !1, n;
      }
      function sl() {
        var n, t, u;
        do
          for (; 0 < Fn.length; ) for (n = Fn, Fn = [], u = n.length, t = 0; t < u; ++t) {
            var r = n[t];
            r[0].apply(null, r[1]);
          }
        while (0 < Fn.length);
        Tn = Bn = !0;
      }
      function At() {
        var n = Dn;
        Dn = [], n.forEach(function(r) {
          r._PSD.onunhandled.call(null, r._value, r);
        });
        for (var t = Il.slice(0), u = t.length; u; ) t[--u]();
      }
      function Gl(n) {
        return new ee(Ke, !1, n);
      }
      function Be(n, t) {
        var u = se;
        return function() {
          var r = rl(), c = se;
          try {
            return Gn(u, !0), n.apply(this, arguments);
          } catch (m) {
            t && t(m);
          } finally {
            Gn(c, !1), r && sl();
          }
        };
      }
      q(ee.prototype, { then: Pt, _then: function(n, t) {
        Rt(this, new Yi(null, null, n, t, se));
      }, catch: function(n) {
        if (arguments.length === 1) return this.then(null, n);
        var t = n, u = arguments[1];
        return typeof t == "function" ? this.then(null, function(r) {
          return (r instanceof t ? u : Gl)(r);
        }) : this.then(null, function(r) {
          return (r && r.name === t ? u : Gl)(r);
        });
      }, finally: function(n) {
        return this.then(function(t) {
          return ee.resolve(n()).then(function() {
            return t;
          });
        }, function(t) {
          return ee.resolve(n()).then(function() {
            return Gl(t);
          });
        });
      }, timeout: function(n, t) {
        var u = this;
        return n < 1 / 0 ? new ee(function(r, c) {
          var m = setTimeout(function() {
            return c(new Z.Timeout(t));
          }, n);
          u.then(r, c).finally(clearTimeout.bind(null, m));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && E(ee.prototype, Symbol.toStringTag, "Dexie.Promise"), Rn.env = Qi(), q(ee, { all: function() {
        var n = Ae.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.length === 0 && t([]);
          var r = n.length;
          n.forEach(function(c, m) {
            return ee.resolve(c).then(function(p) {
              n[m] = p, --r || t(n);
            }, u);
          });
        });
      }, resolve: function(n) {
        return n instanceof ee ? n : n && typeof n.then == "function" ? new ee(function(t, u) {
          n.then(t, u);
        }) : new ee(Ke, !0, n);
      }, reject: Gl, race: function() {
        var n = Ae.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.map(function(r) {
            return ee.resolve(r).then(t, u);
          });
        });
      }, PSD: { get: function() {
        return se;
      }, set: function(n) {
        return se = n;
      } }, totalEchoes: { get: function() {
        return Hl;
      } }, newPSD: Un, usePSD: Qn, scheduler: { get: function() {
        return on;
      }, set: function(n) {
        on = n;
      } }, rejectionMapper: { get: function() {
        return yl;
      }, set: function(n) {
        yl = n;
      } }, follow: function(n, t) {
        return new ee(function(u, r) {
          return Un(function(c, m) {
            var p = se;
            p.unhandleds = [], p.onunhandled = m, p.finalize = fe(function() {
              var g, L = this;
              g = function() {
                L.unhandleds.length === 0 ? c() : m(L.unhandleds[0]);
              }, Il.push(function O() {
                g(), Il.splice(Il.indexOf(O), 1);
              }), ++Zn, on(function() {
                --Zn == 0 && At();
              }, []);
            }, p.finalize), n();
          }, t, u, r);
        });
      } }), Je && (Je.allSettled && E(ee, "allSettled", function() {
        var n = Ae.apply(null, arguments).map($l);
        return new ee(function(t) {
          n.length === 0 && t([]);
          var u = n.length, r = new Array(u);
          n.forEach(function(c, m) {
            return ee.resolve(c).then(function(p) {
              return r[m] = { status: "fulfilled", value: p };
            }, function(p) {
              return r[m] = { status: "rejected", reason: p };
            }).then(function() {
              return --u || t(r);
            });
          });
        });
      }), Je.any && typeof AggregateError < "u" && E(ee, "any", function() {
        var n = Ae.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.length === 0 && u(new AggregateError([]));
          var r = n.length, c = new Array(r);
          n.forEach(function(m, p) {
            return ee.resolve(m).then(function(g) {
              return t(g);
            }, function(g) {
              c[p] = g, --r || u(new AggregateError(c));
            });
          });
        });
      }), Je.withResolvers && (ee.withResolvers = Je.withResolvers));
      var en = { awaits: 0, echoes: 0, id: 0 }, er = 0, zl = [], jl = 0, Hl = 0, nr = 0;
      function Un(n, t, u, r) {
        var c = se, m = Object.create(c);
        return m.parent = c, m.ref = 0, m.global = !1, m.id = ++nr, Rn.env, m.env = yn ? { Promise: ee, PromiseProp: { value: ee, configurable: !0, writable: !0 }, all: ee.all, race: ee.race, allSettled: ee.allSettled, any: ee.any, resolve: ee.resolve, reject: ee.reject } : {}, t && h(m, t), ++c.ref, m.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, r = Qn(m, n, u, r), m.ref === 0 && m.finalize(), r;
      }
      function cl() {
        return en.id || (en.id = ++er), ++en.awaits, en.echoes += ke, en.id;
      }
      function Kn() {
        return !!en.awaits && (--en.awaits == 0 && (en.id = 0), en.echoes = en.awaits * ke, !0);
      }
      function $l(n) {
        return en.echoes && n && n.constructor === Je ? (cl(), n.then(function(t) {
          return Kn(), t;
        }, function(t) {
          return Kn(), He(t);
        })) : n;
      }
      function lr() {
        var n = zl[zl.length - 1];
        zl.pop(), Gn(n, !1);
      }
      function Gn(n, t) {
        var u, r = se;
        (t ? !en.echoes || jl++ && n === se : !jl || --jl && n === se) || queueMicrotask(t ? (function(c) {
          ++Hl, en.echoes && --en.echoes != 0 || (en.echoes = en.awaits = en.id = 0), zl.push(se), Gn(c, !0);
        }).bind(null, n) : lr), n !== se && (se = n, r === Rn && (Rn.env = Qi()), yn && (u = Rn.env.Promise, t = n.env, (r.global || n.global) && (Object.defineProperty(o, "Promise", t.PromiseProp), u.all = t.all, u.race = t.race, u.resolve = t.resolve, u.reject = t.reject, t.allSettled && (u.allSettled = t.allSettled), t.any && (u.any = t.any))));
      }
      function Qi() {
        var n = o.Promise;
        return yn ? { Promise: n, PromiseProp: Object.getOwnPropertyDescriptor(o, "Promise"), all: n.all, race: n.race, allSettled: n.allSettled, any: n.any, resolve: n.resolve, reject: n.reject } : {};
      }
      function Qn(n, t, u, r, c) {
        var m = se;
        try {
          return Gn(n, !0), t(u, r, c);
        } finally {
          Gn(m, !1);
        }
      }
      function Ji(n, t, u, r) {
        return typeof n != "function" ? n : function() {
          var c = se;
          u && cl(), Gn(t, !0);
          try {
            return n.apply(this, arguments);
          } finally {
            Gn(c, !1), r && queueMicrotask(Kn);
          }
        };
      }
      function Et(n) {
        Promise === Je && en.echoes === 0 ? jl === 0 ? n() : enqueueNativeMicroTask(n) : setTimeout(n, 0);
      }
      ("" + In).indexOf("[native code]") === -1 && (cl = Kn = De);
      var He = ee.reject, Jn = "", An = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", eu = "String expected.", ol = [], Wl = "__dbnames", _t = "readonly", Nt = "readwrite";
      function el(n, t) {
        return n ? t ? function() {
          return n.apply(this, arguments) && t.apply(this, arguments);
        } : n : t;
      }
      var nu = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Yl(n) {
        return typeof n != "string" || /\./.test(n) ? function(t) {
          return t;
        } : function(t) {
          return t[n] === void 0 && n in t && delete (t = ye(t))[n], t;
        };
      }
      function lu() {
        throw Z.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Te(n, t) {
        try {
          var u = tu(n), r = tu(t);
          if (u !== r) return u === "Array" ? 1 : r === "Array" ? -1 : u === "binary" ? 1 : r === "binary" ? -1 : u === "string" ? 1 : r === "string" ? -1 : u === "Date" ? 1 : r !== "Date" ? NaN : -1;
          switch (u) {
            case "number":
            case "Date":
            case "string":
              return t < n ? 1 : n < t ? -1 : 0;
            case "binary":
              return function(c, m) {
                for (var p = c.length, g = m.length, L = p < g ? p : g, O = 0; O < L; ++O) if (c[O] !== m[O]) return c[O] < m[O] ? -1 : 1;
                return p === g ? 0 : p < g ? -1 : 1;
              }(iu(n), iu(t));
            case "Array":
              return function(c, m) {
                for (var p = c.length, g = m.length, L = p < g ? p : g, O = 0; O < L; ++O) {
                  var w = Te(c[O], m[O]);
                  if (w !== 0) return w;
                }
                return p === g ? 0 : p < g ? -1 : 1;
              }(n, t);
          }
        } catch {
        }
        return NaN;
      }
      function tu(n) {
        var t = typeof n;
        return t != "object" ? t : ArrayBuffer.isView(n) ? "binary" : (n = Se(n), n === "ArrayBuffer" ? "binary" : n);
      }
      function iu(n) {
        return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n);
      }
      function Xl(n, t, u) {
        var r = n.schema.yProps;
        return r ? (t && 0 < u.numFailures && (t = t.filter(function(c, m) {
          return !u.failures[m];
        })), Promise.all(r.map(function(c) {
          return c = c.updatesTable, t ? n.db.table(c).where("k").anyOf(t).delete() : n.db.table(c).clear();
        })).then(function() {
          return u;
        })) : u;
      }
      var uu = (Ve.prototype._trans = function(n, t, u) {
        var r = this._tx || se.trans, c = this.name, m = Oe && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(n === "readonly" ? "read" : "write", " ").concat(this.name));
        function p(O, w, v) {
          if (!v.schema[c]) throw new Z.NotFound("Table " + c + " not part of transaction");
          return t(v.idbtrans, v);
        }
        var g = rl();
        try {
          var L = r && r.db._novip === this.db._novip ? r === se.trans ? r._promise(n, p, u) : Un(function() {
            return r._promise(n, p, u);
          }, { trans: r, transless: se.transless || se }) : function O(w, v, T, D) {
            if (w.idbdb && (w._state.openComplete || se.letThrough || w._vip)) {
              var b = w._createTransaction(v, T, w._dbSchema);
              try {
                b.create(), w._state.PR1398_maxLoop = 3;
              } catch (C) {
                return C.name === V.InvalidState && w.isOpen() && 0 < --w._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), w.close({ disableAutoOpen: !1 }), w.open().then(function() {
                  return O(w, v, T, D);
                })) : He(C);
              }
              return b._promise(v, function(C, S) {
                return Un(function() {
                  return se.trans = b, D(C, S, b);
                });
              }).then(function(C) {
                if (v === "readwrite") try {
                  b.idbtrans.commit();
                } catch {
                }
                return v === "readonly" ? C : b._completion.then(function() {
                  return C;
                });
              });
            }
            if (w._state.openComplete) return He(new Z.DatabaseClosed(w._state.dbOpenError));
            if (!w._state.isBeingOpened) {
              if (!w._state.autoOpen) return He(new Z.DatabaseClosed());
              w.open().catch(De);
            }
            return w._state.dbReadyPromise.then(function() {
              return O(w, v, T, D);
            });
          }(this.db, n, [this.name], p);
          return m && (L._consoleTask = m, L = L.catch(function(O) {
            return console.trace(O), He(O);
          })), L;
        } finally {
          g && sl();
        }
      }, Ve.prototype.get = function(n, t) {
        var u = this;
        return n && n.constructor === Object ? this.where(n).first(t) : n == null ? He(new Z.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(r) {
          return u.core.get({ trans: r, key: n }).then(function(c) {
            return u.hook.reading.fire(c);
          });
        }).then(t);
      }, Ve.prototype.where = function(n) {
        if (typeof n == "string") return new this.db.WhereClause(this, n);
        if (d(n)) return new this.db.WhereClause(this, "[".concat(n.join("+"), "]"));
        var t = f(n);
        if (t.length === 1) return this.where(t[0]).equals(n[t[0]]);
        var u = this.schema.indexes.concat(this.schema.primKey).filter(function(g) {
          if (g.compound && t.every(function(O) {
            return 0 <= g.keyPath.indexOf(O);
          })) {
            for (var L = 0; L < t.length; ++L) if (t.indexOf(g.keyPath[L]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(g, L) {
          return g.keyPath.length - L.keyPath.length;
        })[0];
        if (u && this.db._maxKey !== Jn) {
          var m = u.keyPath.slice(0, t.length);
          return this.where(m).equals(m.map(function(L) {
            return n[L];
          }));
        }
        !u && Oe && console.warn("The query ".concat(JSON.stringify(n), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var r = this.schema.idxByName;
        function c(g, L) {
          return Te(g, L) === 0;
        }
        var p = t.reduce(function(v, L) {
          var O = v[0], w = v[1], v = r[L], T = n[L];
          return [O || v, O || !v ? el(w, v && v.multi ? function(D) {
            return D = ae(D, L), d(D) && D.some(function(b) {
              return c(T, b);
            });
          } : function(D) {
            return c(T, ae(D, L));
          }) : w];
        }, [null, null]), m = p[0], p = p[1];
        return m ? this.where(m.name).equals(n[m.keyPath]).filter(p) : u ? this.filter(p) : this.where(t).equals("");
      }, Ve.prototype.filter = function(n) {
        return this.toCollection().and(n);
      }, Ve.prototype.count = function(n) {
        return this.toCollection().count(n);
      }, Ve.prototype.offset = function(n) {
        return this.toCollection().offset(n);
      }, Ve.prototype.limit = function(n) {
        return this.toCollection().limit(n);
      }, Ve.prototype.each = function(n) {
        return this.toCollection().each(n);
      }, Ve.prototype.toArray = function(n) {
        return this.toCollection().toArray(n);
      }, Ve.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ve.prototype.orderBy = function(n) {
        return new this.db.Collection(new this.db.WhereClause(this, d(n) ? "[".concat(n.join("+"), "]") : n));
      }, Ve.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ve.prototype.mapToClass = function(n) {
        var t, u = this.db, r = this.name;
        function c() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = n).prototype instanceof lu && (function(L, O) {
          if (typeof O != "function" && O !== null) throw new TypeError("Class extends value " + String(O) + " is not a constructor or null");
          function w() {
            this.constructor = L;
          }
          i(L, O), L.prototype = O === null ? Object.create(O) : (w.prototype = O.prototype, new w());
        }(c, t = n), Object.defineProperty(c.prototype, "db", { get: function() {
          return u;
        }, enumerable: !1, configurable: !0 }), c.prototype.table = function() {
          return r;
        }, n = c);
        for (var m = /* @__PURE__ */ new Set(), p = n.prototype; p; p = x(p)) Object.getOwnPropertyNames(p).forEach(function(L) {
          return m.add(L);
        });
        function g(L) {
          if (!L) return L;
          var O, w = Object.create(n.prototype);
          for (O in L) if (!m.has(O)) try {
            w[O] = L[O];
          } catch {
          }
          return w;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = g, this.hook("reading", g), n;
      }, Ve.prototype.defineClass = function() {
        return this.mapToClass(function(n) {
          h(this, n);
        });
      }, Ve.prototype.add = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, m = r.keyPath, p = n;
        return m && c && (p = Yl(m)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "add", keys: t != null ? [t] : null, values: [p] });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (m) try {
            ne(n, m, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.update = function(n, t) {
        return typeof n != "object" || d(n) ? this.where(":id").equals(n).modify(t) : (n = ae(n, this.schema.primKey.keyPath), n === void 0 ? He(new Z.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(n).modify(t));
      }, Ve.prototype.put = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, m = r.keyPath, p = n;
        return m && c && (p = Yl(m)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "put", values: [p], keys: t != null ? [t] : null });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (m) try {
            ne(n, m, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.delete = function(n) {
        var t = this;
        return this._trans("readwrite", function(u) {
          return t.core.mutate({ trans: u, type: "delete", keys: [n] }).then(function(r) {
            return Xl(t, [n], r);
          }).then(function(r) {
            return r.numFailures ? ee.reject(r.failures[0]) : void 0;
          });
        });
      }, Ve.prototype.clear = function() {
        var n = this;
        return this._trans("readwrite", function(t) {
          return n.core.mutate({ trans: t, type: "deleteRange", range: nu }).then(function(u) {
            return Xl(n, null, u);
          });
        }).then(function(t) {
          return t.numFailures ? ee.reject(t.failures[0]) : void 0;
        });
      }, Ve.prototype.bulkGet = function(n) {
        var t = this;
        return this._trans("readonly", function(u) {
          return t.core.getMany({ keys: n, trans: u }).then(function(r) {
            return r.map(function(c) {
              return t.hook.reading.fire(c);
            });
          });
        });
      }, Ve.prototype.bulkAdd = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, m = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new Z.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new Z.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Yl(O)) : n;
          return r.core.mutate({ trans: p, type: "add", keys: c, values: O, wantResults: m }).then(function(b) {
            var v = b.numFailures, T = b.results, D = b.lastResult, b = b.failures;
            if (v === 0) return m ? T : D;
            throw new tn("".concat(r.name, ".bulkAdd(): ").concat(v, " of ").concat(L, " operations failed"), b);
          });
        });
      }, Ve.prototype.bulkPut = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, m = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new Z.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new Z.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Yl(O)) : n;
          return r.core.mutate({ trans: p, type: "put", keys: c, values: O, wantResults: m }).then(function(b) {
            var v = b.numFailures, T = b.results, D = b.lastResult, b = b.failures;
            if (v === 0) return m ? T : D;
            throw new tn("".concat(r.name, ".bulkPut(): ").concat(v, " of ").concat(L, " operations failed"), b);
          });
        });
      }, Ve.prototype.bulkUpdate = function(n) {
        var t = this, u = this.core, r = n.map(function(p) {
          return p.key;
        }), c = n.map(function(p) {
          return p.changes;
        }), m = [];
        return this._trans("readwrite", function(p) {
          return u.getMany({ trans: p, keys: r, cache: "clone" }).then(function(g) {
            var L = [], O = [];
            n.forEach(function(v, T) {
              var D = v.key, b = v.changes, C = g[T];
              if (C) {
                for (var S = 0, P = Object.keys(b); S < P.length; S++) {
                  var A = P[S], N = b[A];
                  if (A === t.schema.primKey.keyPath) {
                    if (Te(N, D) !== 0) throw new Z.Constraint("Cannot update primary key in bulkUpdate()");
                  } else ne(C, A, N);
                }
                m.push(T), L.push(D), O.push(C);
              }
            });
            var w = L.length;
            return u.mutate({ trans: p, type: "put", keys: L, values: O, updates: { keys: r, changeSpecs: c } }).then(function(v) {
              var T = v.numFailures, D = v.failures;
              if (T === 0) return w;
              for (var b = 0, C = Object.keys(D); b < C.length; b++) {
                var S, P = C[b], A = m[Number(P)];
                A != null && (S = D[P], delete D[P], D[A] = S);
              }
              throw new tn("".concat(t.name, ".bulkUpdate(): ").concat(T, " of ").concat(w, " operations failed"), D);
            });
          });
        });
      }, Ve.prototype.bulkDelete = function(n) {
        var t = this, u = n.length;
        return this._trans("readwrite", function(r) {
          return t.core.mutate({ trans: r, type: "delete", keys: n }).then(function(c) {
            return Xl(t, n, c);
          });
        }).then(function(p) {
          var c = p.numFailures, m = p.lastResult, p = p.failures;
          if (c === 0) return m;
          throw new tn("".concat(t.name, ".bulkDelete(): ").concat(c, " of ").concat(u, " operations failed"), p);
        });
      }, Ve);
      function Ve() {
      }
      function Ll(n) {
        function t(p, g) {
          if (g) {
            for (var L = arguments.length, O = new Array(L - 1); --L; ) O[L - 1] = arguments[L];
            return u[p].subscribe.apply(null, O), n;
          }
          if (typeof p == "string") return u[p];
        }
        var u = {};
        t.addEventType = m;
        for (var r = 1, c = arguments.length; r < c; ++r) m(arguments[r]);
        return t;
        function m(p, g, L) {
          if (typeof p != "object") {
            var O;
            g = g || Ne;
            var w = { subscribers: [], fire: L = L || De, subscribe: function(v) {
              w.subscribers.indexOf(v) === -1 && (w.subscribers.push(v), w.fire = g(w.fire, v));
            }, unsubscribe: function(v) {
              w.subscribers = w.subscribers.filter(function(T) {
                return T !== v;
              }), w.fire = w.subscribers.reduce(g, L);
            } };
            return u[p] = t[p] = w;
          }
          f(O = p).forEach(function(v) {
            var T = O[v];
            if (d(T)) m(v, O[v][0], O[v][1]);
            else {
              if (T !== "asap") throw new Z.InvalidArgument("Invalid event config");
              var D = m(v, j, function() {
                for (var b = arguments.length, C = new Array(b); b--; ) C[b] = arguments[b];
                D.subscribers.forEach(function(S) {
                  W(function() {
                    S.apply(null, C);
                  });
                });
              });
            }
          });
        }
      }
      function Dl(n, t) {
        return M(t).from({ prototype: n }), t;
      }
      function ml(n, t) {
        return !(n.filter || n.algorithm || n.or) && (t ? n.justLimit : !n.replayFilter);
      }
      function Ft(n, t) {
        n.filter = el(n.filter, t);
      }
      function Mt(n, t, u) {
        var r = n.replayFilter;
        n.replayFilter = r ? function() {
          return el(r(), t());
        } : t, n.justLimit = u && !r;
      }
      function Ql(n, t) {
        if (n.isPrimKey) return t.primaryKey;
        var u = t.getIndexByKeyPath(n.index);
        if (!u) throw new Z.Schema("KeyPath " + n.index + " on object store " + t.name + " is not indexed");
        return u;
      }
      function au(n, t, u) {
        var r = Ql(n, t.schema);
        return t.openCursor({ trans: u, values: !n.keysOnly, reverse: n.dir === "prev", unique: !!n.unique, query: { index: r, range: n.range } });
      }
      function Jl(n, t, u, r) {
        var c = n.replayFilter ? el(n.filter, n.replayFilter()) : n.filter;
        if (n.or) {
          var m = {}, p = function(g, L, O) {
            var w, v;
            c && !c(L, O, function(T) {
              return L.stop(T);
            }, function(T) {
              return L.fail(T);
            }) || ((v = "" + (w = L.primaryKey)) == "[object ArrayBuffer]" && (v = "" + new Uint8Array(w)), I(m, v) || (m[v] = !0, t(g, L, O)));
          };
          return Promise.all([n.or._iterate(p, u), ru(au(n, r, u), n.algorithm, p, !n.keysOnly && n.valueMapper)]);
        }
        return ru(au(n, r, u), el(n.algorithm, c), t, !n.keysOnly && n.valueMapper);
      }
      function ru(n, t, u, r) {
        var c = Be(r ? function(m, p, g) {
          return u(r(m), p, g);
        } : u);
        return n.then(function(m) {
          if (m) return m.start(function() {
            var p = function() {
              return m.continue();
            };
            t && !t(m, function(g) {
              return p = g;
            }, function(g) {
              m.stop(g), p = De;
            }, function(g) {
              m.fail(g), p = De;
            }) || c(m.value, m, function(g) {
              return p = g;
            }), p();
          });
        });
      }
      var Ol = (su.prototype.execute = function(n) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var u = t.add;
          if (d(u)) return s(s([], d(n) ? n : [], !0), u).sort();
          if (typeof u == "number") return (Number(n) || 0) + u;
          if (typeof u == "bigint") try {
            return BigInt(n) + u;
          } catch {
            return BigInt(0) + u;
          }
          throw new TypeError("Invalid term ".concat(u));
        }
        if (t.remove !== void 0) {
          var r = t.remove;
          if (d(r)) return d(n) ? n.filter(function(c) {
            return !r.includes(c);
          }).sort() : [];
          if (typeof r == "number") return Number(n) - r;
          if (typeof r == "bigint") try {
            return BigInt(n) - r;
          } catch {
            return BigInt(0) - r;
          }
          throw new TypeError("Invalid subtrahend ".concat(r));
        }
        return u = (u = t.replacePrefix) === null || u === void 0 ? void 0 : u[0], u && typeof n == "string" && n.startsWith(u) ? t.replacePrefix[1] + n.substring(u.length) : n;
      }, su);
      function su(n) {
        this["@@propmod"] = n;
      }
      var tr = (Re.prototype._read = function(n, t) {
        var u = this._ctx;
        return u.error ? u.table._trans(null, He.bind(null, u.error)) : u.table._trans("readonly", n).then(t);
      }, Re.prototype._write = function(n) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, He.bind(null, t.error)) : t.table._trans("readwrite", n, "locked");
      }, Re.prototype._addAlgorithm = function(n) {
        var t = this._ctx;
        t.algorithm = el(t.algorithm, n);
      }, Re.prototype._iterate = function(n, t) {
        return Jl(this._ctx, n, t, this._ctx.table.core);
      }, Re.prototype.clone = function(n) {
        var t = Object.create(this.constructor.prototype), u = Object.create(this._ctx);
        return n && h(u, n), t._ctx = u, t;
      }, Re.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Re.prototype.each = function(n) {
        var t = this._ctx;
        return this._read(function(u) {
          return Jl(t, n, u, t.table.core);
        });
      }, Re.prototype.count = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx, c = r.table.core;
          if (ml(r, !0)) return c.count({ trans: u, query: { index: Ql(r, c.schema), range: r.range } }).then(function(p) {
            return Math.min(p, r.limit);
          });
          var m = 0;
          return Jl(r, function() {
            return ++m, !1;
          }, u, c).then(function() {
            return m;
          });
        }).then(n);
      }, Re.prototype.sortBy = function(n, t) {
        var u = n.split(".").reverse(), r = u[0], c = u.length - 1;
        function m(L, O) {
          return O ? m(L[u[O]], O - 1) : L[r];
        }
        var p = this._ctx.dir === "next" ? 1 : -1;
        function g(L, O) {
          return Te(m(L, c), m(O, c)) * p;
        }
        return this.toArray(function(L) {
          return L.sort(g);
        }).then(t);
      }, Re.prototype.toArray = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx;
          if (r.dir === "next" && ml(r, !0) && 0 < r.limit) {
            var c = r.valueMapper, m = Ql(r, r.table.core.schema);
            return r.table.core.query({ trans: u, limit: r.limit, values: !0, query: { index: m, range: r.range } }).then(function(g) {
              return g = g.result, c ? g.map(c) : g;
            });
          }
          var p = [];
          return Jl(r, function(g) {
            return p.push(g);
          }, u, r.table.core).then(function() {
            return p;
          });
        }, n);
      }, Re.prototype.offset = function(n) {
        var t = this._ctx;
        return n <= 0 || (t.offset += n, ml(t) ? Mt(t, function() {
          var u = n;
          return function(r, c) {
            return u === 0 || (u === 1 ? --u : c(function() {
              r.advance(u), u = 0;
            }), !1);
          };
        }) : Mt(t, function() {
          var u = n;
          return function() {
            return --u < 0;
          };
        })), this;
      }, Re.prototype.limit = function(n) {
        return this._ctx.limit = Math.min(this._ctx.limit, n), Mt(this._ctx, function() {
          var t = n;
          return function(u, r, c) {
            return --t <= 0 && r(c), 0 <= t;
          };
        }, !0), this;
      }, Re.prototype.until = function(n, t) {
        return Ft(this._ctx, function(u, r, c) {
          return !n(u.value) || (r(c), t);
        }), this;
      }, Re.prototype.first = function(n) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(n);
      }, Re.prototype.last = function(n) {
        return this.reverse().first(n);
      }, Re.prototype.filter = function(n) {
        var t;
        return Ft(this._ctx, function(u) {
          return n(u.value);
        }), (t = this._ctx).isMatch = el(t.isMatch, n), this;
      }, Re.prototype.and = function(n) {
        return this.filter(n);
      }, Re.prototype.or = function(n) {
        return new this.db.WhereClause(this._ctx.table, n, this);
      }, Re.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Re.prototype.desc = function() {
        return this.reverse();
      }, Re.prototype.eachKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.key, r);
        });
      }, Re.prototype.eachUniqueKey = function(n) {
        return this._ctx.unique = "unique", this.eachKey(n);
      }, Re.prototype.eachPrimaryKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.primaryKey, r);
        });
      }, Re.prototype.keys = function(n) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.key);
        }).then(function() {
          return u;
        }).then(n);
      }, Re.prototype.primaryKeys = function(n) {
        var t = this._ctx;
        if (t.dir === "next" && ml(t, !0) && 0 < t.limit) return this._read(function(r) {
          var c = Ql(t, t.table.core.schema);
          return t.table.core.query({ trans: r, values: !1, limit: t.limit, query: { index: c, range: t.range } });
        }).then(function(r) {
          return r.result;
        }).then(n);
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.primaryKey);
        }).then(function() {
          return u;
        }).then(n);
      }, Re.prototype.uniqueKeys = function(n) {
        return this._ctx.unique = "unique", this.keys(n);
      }, Re.prototype.firstKey = function(n) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(n);
      }, Re.prototype.lastKey = function(n) {
        return this.reverse().firstKey(n);
      }, Re.prototype.distinct = function() {
        var n = this._ctx, n = n.index && n.table.schema.idxByName[n.index];
        if (!n || !n.multi) return this;
        var t = {};
        return Ft(this._ctx, function(c) {
          var r = c.primaryKey.toString(), c = I(t, r);
          return t[r] = !0, !c;
        }), this;
      }, Re.prototype.modify = function(n) {
        var t = this, u = this._ctx;
        return this._write(function(r) {
          var c, m, p;
          p = typeof n == "function" ? n : (c = f(n), m = c.length, function(P) {
            for (var A = !1, N = 0; N < m; ++N) {
              var F = c[N], G = n[F], Y = ae(P, F);
              G instanceof Ol ? (ne(P, F, G.execute(Y)), A = !0) : Y !== G && (ne(P, F, G), A = !0);
            }
            return A;
          });
          var g = u.table.core, v = g.schema.primaryKey, L = v.outbound, O = v.extractKey, w = 200, v = t.db._options.modifyChunkSize;
          v && (w = typeof v == "object" ? v[g.name] || v["*"] || 200 : v);
          function T(P, F) {
            var N = F.failures, F = F.numFailures;
            b += P - F;
            for (var G = 0, Y = f(N); G < Y.length; G++) {
              var H = Y[G];
              D.push(N[H]);
            }
          }
          var D = [], b = 0, C = [], S = n === cu;
          return t.clone().primaryKeys().then(function(P) {
            function A(F) {
              var G = Math.min(w, P.length - F), Y = P.slice(F, F + G);
              return (S ? Promise.resolve([]) : g.getMany({ trans: r, keys: Y, cache: "immutable" })).then(function(H) {
                var $ = [], J = [], Q = L ? [] : null, le = S ? Y : [];
                if (!S) for (var ve = 0; ve < G; ++ve) {
                  var qe = H[ve], he = { value: ye(qe), primKey: P[F + ve] };
                  p.call(he, he.value, he) !== !1 && (he.value == null ? le.push(P[F + ve]) : L || Te(O(qe), O(he.value)) === 0 ? (J.push(he.value), L && Q.push(P[F + ve])) : (le.push(P[F + ve]), $.push(he.value)));
                }
                return Promise.resolve(0 < $.length && g.mutate({ trans: r, type: "add", values: $ }).then(function(Ge) {
                  for (var pe in Ge.failures) le.splice(parseInt(pe), 1);
                  T($.length, Ge);
                })).then(function() {
                  return (0 < J.length || N && typeof n == "object") && g.mutate({ trans: r, type: "put", keys: Q, values: J, criteria: N, changeSpec: typeof n != "function" && n, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return T(J.length, Ge);
                  });
                }).then(function() {
                  return (0 < le.length || N && S) && g.mutate({ trans: r, type: "delete", keys: le, criteria: N, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return Xl(u.table, le, Ge);
                  }).then(function(Ge) {
                    return T(le.length, Ge);
                  });
                }).then(function() {
                  return P.length > F + G && A(F + w);
                });
              });
            }
            var N = ml(u) && u.limit === 1 / 0 && (typeof n != "function" || S) && { index: u.index, range: u.range };
            return A(0).then(function() {
              if (0 < D.length) throw new gn("Error modifying one or more objects", D, b, C);
              return P.length;
            });
          });
        });
      }, Re.prototype.delete = function() {
        var n = this._ctx, t = n.range;
        return !ml(n) || n.table.schema.yProps || !n.isPrimKey && t.type !== 3 ? this.modify(cu) : this._write(function(u) {
          var r = n.table.core.schema.primaryKey, c = t;
          return n.table.core.count({ trans: u, query: { index: r, range: c } }).then(function(m) {
            return n.table.core.mutate({ trans: u, type: "deleteRange", range: c }).then(function(L) {
              var g = L.failures, L = L.numFailures;
              if (L) throw new gn("Could not delete some values", Object.keys(g).map(function(O) {
                return g[O];
              }), m - L);
              return m - L;
            });
          });
        });
      }, Re);
      function Re() {
      }
      var cu = function(n, t) {
        return t.value = null;
      };
      function ir(n, t) {
        return n < t ? -1 : n === t ? 0 : 1;
      }
      function ur(n, t) {
        return t < n ? -1 : n === t ? 0 : 1;
      }
      function pn(n, t, u) {
        return n = n instanceof mu ? new n.Collection(n) : n, n._ctx.error = new (u || TypeError)(t), n;
      }
      function fl(n) {
        return new n.Collection(n, function() {
          return ou("");
        }).limit(0);
      }
      function et(n, t, u, r) {
        var c, m, p, g, L, O, w, v = u.length;
        if (!u.every(function(b) {
          return typeof b == "string";
        })) return pn(n, eu);
        function T(b) {
          c = b === "next" ? function(S) {
            return S.toUpperCase();
          } : function(S) {
            return S.toLowerCase();
          }, m = b === "next" ? function(S) {
            return S.toLowerCase();
          } : function(S) {
            return S.toUpperCase();
          }, p = b === "next" ? ir : ur;
          var C = u.map(function(S) {
            return { lower: m(S), upper: c(S) };
          }).sort(function(S, P) {
            return p(S.lower, P.lower);
          });
          g = C.map(function(S) {
            return S.upper;
          }), L = C.map(function(S) {
            return S.lower;
          }), w = (O = b) === "next" ? "" : r;
        }
        T("next"), n = new n.Collection(n, function() {
          return zn(g[0], L[v - 1] + r);
        }), n._ondirectionchange = function(b) {
          T(b);
        };
        var D = 0;
        return n._addAlgorithm(function(b, C, S) {
          var P = b.key;
          if (typeof P != "string") return !1;
          var A = m(P);
          if (t(A, L, D)) return !0;
          for (var N = null, F = D; F < v; ++F) {
            var G = function(Y, H, $, J, Q, le) {
              for (var ve = Math.min(Y.length, J.length), qe = -1, he = 0; he < ve; ++he) {
                var Ge = H[he];
                if (Ge !== J[he]) return Q(Y[he], $[he]) < 0 ? Y.substr(0, he) + $[he] + $.substr(he + 1) : Q(Y[he], J[he]) < 0 ? Y.substr(0, he) + J[he] + $.substr(he + 1) : 0 <= qe ? Y.substr(0, qe) + H[qe] + $.substr(qe + 1) : null;
                Q(Y[he], Ge) < 0 && (qe = he);
              }
              return ve < J.length && le === "next" ? Y + $.substr(Y.length) : ve < Y.length && le === "prev" ? Y.substr(0, $.length) : qe < 0 ? null : Y.substr(0, qe) + J[qe] + $.substr(qe + 1);
            }(P, A, g[F], L[F], p, O);
            G === null && N === null ? D = F + 1 : (N === null || 0 < p(N, G)) && (N = G);
          }
          return C(N !== null ? function() {
            b.continue(N + w);
          } : S), !1;
        }), n;
      }
      function zn(n, t, u, r) {
        return { type: 2, lower: n, upper: t, lowerOpen: u, upperOpen: r };
      }
      function ou(n) {
        return { type: 1, lower: n, upper: n };
      }
      var mu = (Object.defineProperty(nn.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), nn.prototype.between = function(n, t, u, r) {
        u = u !== !1, r = r === !0;
        try {
          return 0 < this._cmp(n, t) || this._cmp(n, t) === 0 && (u || r) && (!u || !r) ? fl(this) : new this.Collection(this, function() {
            return zn(n, t, !u, !r);
          });
        } catch {
          return pn(this, An);
        }
      }, nn.prototype.equals = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return ou(n);
        });
      }, nn.prototype.above = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return zn(n, void 0, !0);
        });
      }, nn.prototype.aboveOrEqual = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return zn(n, void 0, !1);
        });
      }, nn.prototype.below = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return zn(void 0, n, !1, !0);
        });
      }, nn.prototype.belowOrEqual = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return zn(void 0, n);
        });
      }, nn.prototype.startsWith = function(n) {
        return typeof n != "string" ? pn(this, eu) : this.between(n, n + Jn, !0, !0);
      }, nn.prototype.startsWithIgnoreCase = function(n) {
        return n === "" ? this.startsWith(n) : et(this, function(t, u) {
          return t.indexOf(u[0]) === 0;
        }, [n], Jn);
      }, nn.prototype.equalsIgnoreCase = function(n) {
        return et(this, function(t, u) {
          return t === u[0];
        }, [n], "");
      }, nn.prototype.anyOfIgnoreCase = function() {
        var n = Ae.apply(Le, arguments);
        return n.length === 0 ? fl(this) : et(this, function(t, u) {
          return u.indexOf(t) !== -1;
        }, n, "");
      }, nn.prototype.startsWithAnyOfIgnoreCase = function() {
        var n = Ae.apply(Le, arguments);
        return n.length === 0 ? fl(this) : et(this, function(t, u) {
          return u.some(function(r) {
            return t.indexOf(r) === 0;
          });
        }, n, Jn);
      }, nn.prototype.anyOf = function() {
        var n = this, t = Ae.apply(Le, arguments), u = this._cmp;
        try {
          t.sort(u);
        } catch {
          return pn(this, An);
        }
        if (t.length === 0) return fl(this);
        var r = new this.Collection(this, function() {
          return zn(t[0], t[t.length - 1]);
        });
        r._ondirectionchange = function(m) {
          u = m === "next" ? n._ascending : n._descending, t.sort(u);
        };
        var c = 0;
        return r._addAlgorithm(function(m, p, g) {
          for (var L = m.key; 0 < u(L, t[c]); ) if (++c === t.length) return p(g), !1;
          return u(L, t[c]) === 0 || (p(function() {
            m.continue(t[c]);
          }), !1);
        }), r;
      }, nn.prototype.notEqual = function(n) {
        return this.inAnyRange([[-1 / 0, n], [n, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, nn.prototype.noneOf = function() {
        var n = Ae.apply(Le, arguments);
        if (n.length === 0) return new this.Collection(this);
        try {
          n.sort(this._ascending);
        } catch {
          return pn(this, An);
        }
        var t = n.reduce(function(u, r) {
          return u ? u.concat([[u[u.length - 1][1], r]]) : [[-1 / 0, r]];
        }, null);
        return t.push([n[n.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, nn.prototype.inAnyRange = function(P, t) {
        var u = this, r = this._cmp, c = this._ascending, m = this._descending, p = this._min, g = this._max;
        if (P.length === 0) return fl(this);
        if (!P.every(function(A) {
          return A[0] !== void 0 && A[1] !== void 0 && c(A[0], A[1]) <= 0;
        })) return pn(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Z.InvalidArgument);
        var L = !t || t.includeLowers !== !1, O = t && t.includeUppers === !0, w, v = c;
        function T(A, N) {
          return v(A[0], N[0]);
        }
        try {
          (w = P.reduce(function(A, N) {
            for (var F = 0, G = A.length; F < G; ++F) {
              var Y = A[F];
              if (r(N[0], Y[1]) < 0 && 0 < r(N[1], Y[0])) {
                Y[0] = p(Y[0], N[0]), Y[1] = g(Y[1], N[1]);
                break;
              }
            }
            return F === G && A.push(N), A;
          }, [])).sort(T);
        } catch {
          return pn(this, An);
        }
        var D = 0, b = O ? function(A) {
          return 0 < c(A, w[D][1]);
        } : function(A) {
          return 0 <= c(A, w[D][1]);
        }, C = L ? function(A) {
          return 0 < m(A, w[D][0]);
        } : function(A) {
          return 0 <= m(A, w[D][0]);
        }, S = b, P = new this.Collection(this, function() {
          return zn(w[0][0], w[w.length - 1][1], !L, !O);
        });
        return P._ondirectionchange = function(A) {
          v = A === "next" ? (S = b, c) : (S = C, m), w.sort(T);
        }, P._addAlgorithm(function(A, N, F) {
          for (var G, Y = A.key; S(Y); ) if (++D === w.length) return N(F), !1;
          return !b(G = Y) && !C(G) || (u._cmp(Y, w[D][1]) === 0 || u._cmp(Y, w[D][0]) === 0 || N(function() {
            v === c ? A.continue(w[D][0]) : A.continue(w[D][1]);
          }), !1);
        }), P;
      }, nn.prototype.startsWithAnyOf = function() {
        var n = Ae.apply(Le, arguments);
        return n.every(function(t) {
          return typeof t == "string";
        }) ? n.length === 0 ? fl(this) : this.inAnyRange(n.map(function(t) {
          return [t, t + Jn];
        })) : pn(this, "startsWithAnyOf() only works with strings");
      }, nn);
      function nn() {
      }
      function wn(n) {
        return Be(function(t) {
          return bl(t), n(t.target.error), !1;
        });
      }
      function bl(n) {
        n.stopPropagation && n.stopPropagation(), n.preventDefault && n.preventDefault();
      }
      var wl = "storagemutated", kt = "x-storagemutated-1", jn = Ll(null, wl), ar = (Sn.prototype._lock = function() {
        return K(!se.global), ++this._reculock, this._reculock !== 1 || se.global || (se.lockOwnerFor = this), this;
      }, Sn.prototype._unlock = function() {
        if (K(!se.global), --this._reculock == 0) for (se.global || (se.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var n = this._blockedFuncs.shift();
          try {
            Qn(n[1], n[0]);
          } catch {
          }
        }
        return this;
      }, Sn.prototype._locked = function() {
        return this._reculock && se.lockOwnerFor !== this;
      }, Sn.prototype.create = function(n) {
        var t = this;
        if (!this.mode) return this;
        var u = this.db.idbdb, r = this.db._state.dbOpenError;
        if (K(!this.idbtrans), !n && !u) switch (r && r.name) {
          case "DatabaseClosedError":
            throw new Z.DatabaseClosed(r);
          case "MissingAPIError":
            throw new Z.MissingAPI(r.message, r);
          default:
            throw new Z.OpenFailed(r);
        }
        if (!this.active) throw new Z.TransactionInactive();
        return K(this._completion._state === null), (n = this.idbtrans = n || (this.db.core || u).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Be(function(c) {
          bl(c), t._reject(n.error);
        }), n.onabort = Be(function(c) {
          bl(c), t.active && t._reject(new Z.Abort(n.error)), t.active = !1, t.on("abort").fire(c);
        }), n.oncomplete = Be(function() {
          t.active = !1, t._resolve(), "mutatedParts" in n && jn.storagemutated.fire(n.mutatedParts);
        }), this;
      }, Sn.prototype._promise = function(n, t, u) {
        var r = this;
        if (n === "readwrite" && this.mode !== "readwrite") return He(new Z.ReadOnly("Transaction is readonly"));
        if (!this.active) return He(new Z.TransactionInactive());
        if (this._locked()) return new ee(function(m, p) {
          r._blockedFuncs.push([function() {
            r._promise(n, t, u).then(m, p);
          }, se]);
        });
        if (u) return Un(function() {
          var m = new ee(function(p, g) {
            r._lock();
            var L = t(p, g, r);
            L && L.then && L.then(p, g);
          });
          return m.finally(function() {
            return r._unlock();
          }), m._lib = !0, m;
        });
        var c = new ee(function(m, p) {
          var g = t(m, p, r);
          g && g.then && g.then(m, p);
        });
        return c._lib = !0, c;
      }, Sn.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Sn.prototype.waitFor = function(n) {
        var t, u = this._root(), r = ee.resolve(n);
        u._waitingFor ? u._waitingFor = u._waitingFor.then(function() {
          return r;
        }) : (u._waitingFor = r, u._waitingQueue = [], t = u.idbtrans.objectStore(u.storeNames[0]), function m() {
          for (++u._spinCount; u._waitingQueue.length; ) u._waitingQueue.shift()();
          u._waitingFor && (t.get(-1 / 0).onsuccess = m);
        }());
        var c = u._waitingFor;
        return new ee(function(m, p) {
          r.then(function(g) {
            return u._waitingQueue.push(Be(m.bind(null, g)));
          }, function(g) {
            return u._waitingQueue.push(Be(p.bind(null, g)));
          }).finally(function() {
            u._waitingFor === c && (u._waitingFor = null);
          });
        });
      }, Sn.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new Z.Abort()));
      }, Sn.prototype.table = function(n) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (I(t, n)) return t[n];
        var u = this.schema[n];
        if (!u) throw new Z.NotFound("Table " + n + " not part of transaction");
        return u = new this.db.Table(n, u, this), u.core = this.db.core.table(n), t[n] = u;
      }, Sn);
      function Sn() {
      }
      function Vt(n, t, u, r, c, m, p, g) {
        return { name: n, keyPath: t, unique: u, multi: r, auto: c, compound: m, src: (u && !p ? "&" : "") + (r ? "*" : "") + (c ? "++" : "") + fu(t), type: g };
      }
      function fu(n) {
        return typeof n == "string" ? n : n ? "[" + [].join.call(n, "+") + "]" : "";
      }
      function Bt(n, t, u) {
        return { name: n, primKey: t, indexes: u, mappedClass: null, idxByName: (r = function(c) {
          return [c.name, c];
        }, u.reduce(function(c, m, p) {
          return p = r(m, p), p && (c[p[0]] = p[1]), c;
        }, {})) };
        var r;
      }
      var Sl = function(n) {
        try {
          return n.only([[]]), Sl = function() {
            return [[]];
          }, [[]];
        } catch {
          return Sl = function() {
            return Jn;
          }, Jn;
        }
      };
      function Zt(n) {
        return n == null ? function() {
        } : typeof n == "string" ? (t = n).split(".").length === 1 ? function(u) {
          return u[t];
        } : function(u) {
          return ae(u, t);
        } : function(u) {
          return ae(u, n);
        };
        var t;
      }
      function du(n) {
        return [].slice.call(n);
      }
      var rr = 0;
      function Cl(n) {
        return n == null ? ":id" : typeof n == "string" ? n : "[".concat(n.join("+"), "]");
      }
      function sr(n, t, L) {
        function r(S) {
          if (S.type === 3) return null;
          if (S.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var D = S.lower, b = S.upper, C = S.lowerOpen, S = S.upperOpen;
          return D === void 0 ? b === void 0 ? null : t.upperBound(b, !!S) : b === void 0 ? t.lowerBound(D, !!C) : t.bound(D, b, !!C, !!S);
        }
        function c(T) {
          var D, b = T.name;
          return { name: b, schema: T, mutate: function(C) {
            var S = C.trans, P = C.type, A = C.keys, N = C.values, F = C.range;
            return new Promise(function(G, Y) {
              G = Be(G);
              var H = S.objectStore(b), $ = H.keyPath == null, J = P === "put" || P === "add";
              if (!J && P !== "delete" && P !== "deleteRange") throw new Error("Invalid operation type: " + P);
              var Q, le = (A || N || { length: 1 }).length;
              if (A && N && A.length !== N.length) throw new Error("Given keys array must have same length as given values array.");
              if (le === 0) return G({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ve(mn) {
                ++Ge, bl(mn);
              }
              var qe = [], he = [], Ge = 0;
              if (P === "deleteRange") {
                if (F.type === 4) return G({ numFailures: Ge, failures: he, results: [], lastResult: void 0 });
                F.type === 3 ? qe.push(Q = H.clear()) : qe.push(Q = H.delete(r(F)));
              } else {
                var $ = J ? $ ? [N, A] : [N, null] : [A, null], pe = $[0], an = $[1];
                if (J) for (var rn = 0; rn < le; ++rn) qe.push(Q = an && an[rn] !== void 0 ? H[P](pe[rn], an[rn]) : H[P](pe[rn])), Q.onerror = ve;
                else for (rn = 0; rn < le; ++rn) qe.push(Q = H[P](pe[rn])), Q.onerror = ve;
              }
              function ft(mn) {
                mn = mn.target.result, qe.forEach(function(tl, ui) {
                  return tl.error != null && (he[ui] = tl.error);
                }), G({ numFailures: Ge, failures: he, results: P === "delete" ? A : qe.map(function(tl) {
                  return tl.result;
                }), lastResult: mn });
              }
              Q.onerror = function(mn) {
                ve(mn), ft(mn);
              }, Q.onsuccess = ft;
            });
          }, getMany: function(C) {
            var S = C.trans, P = C.keys;
            return new Promise(function(A, N) {
              A = Be(A);
              for (var F, G = S.objectStore(b), Y = P.length, H = new Array(Y), $ = 0, J = 0, Q = function(qe) {
                qe = qe.target, H[qe._pos] = qe.result, ++J === $ && A(H);
              }, le = wn(N), ve = 0; ve < Y; ++ve) P[ve] != null && ((F = G.get(P[ve]))._pos = ve, F.onsuccess = Q, F.onerror = le, ++$);
              $ === 0 && A(H);
            });
          }, get: function(C) {
            var S = C.trans, P = C.key;
            return new Promise(function(A, N) {
              A = Be(A);
              var F = S.objectStore(b).get(P);
              F.onsuccess = function(G) {
                return A(G.target.result);
              }, F.onerror = wn(N);
            });
          }, query: (D = O, function(C) {
            return new Promise(function(S, P) {
              S = Be(S);
              var A, N, F, $ = C.trans, G = C.values, Y = C.limit, Q = C.query, H = Y === 1 / 0 ? void 0 : Y, J = Q.index, Q = Q.range, $ = $.objectStore(b), J = J.isPrimaryKey ? $ : $.index(J.name), Q = r(Q);
              if (Y === 0) return S({ result: [] });
              D ? ((H = G ? J.getAll(Q, H) : J.getAllKeys(Q, H)).onsuccess = function(le) {
                return S({ result: le.target.result });
              }, H.onerror = wn(P)) : (A = 0, N = !G && "openKeyCursor" in J ? J.openKeyCursor(Q) : J.openCursor(Q), F = [], N.onsuccess = function(le) {
                var ve = N.result;
                return ve ? (F.push(G ? ve.value : ve.primaryKey), ++A === Y ? S({ result: F }) : void ve.continue()) : S({ result: F });
              }, N.onerror = wn(P));
            });
          }), openCursor: function(C) {
            var S = C.trans, P = C.values, A = C.query, N = C.reverse, F = C.unique;
            return new Promise(function(G, Y) {
              G = Be(G);
              var J = A.index, H = A.range, $ = S.objectStore(b), $ = J.isPrimaryKey ? $ : $.index(J.name), J = N ? F ? "prevunique" : "prev" : F ? "nextunique" : "next", Q = !P && "openKeyCursor" in $ ? $.openKeyCursor(r(H), J) : $.openCursor(r(H), J);
              Q.onerror = wn(Y), Q.onsuccess = Be(function(le) {
                var ve, qe, he, Ge, pe = Q.result;
                pe ? (pe.___id = ++rr, pe.done = !1, ve = pe.continue.bind(pe), qe = (qe = pe.continuePrimaryKey) && qe.bind(pe), he = pe.advance.bind(pe), Ge = function() {
                  throw new Error("Cursor not stopped");
                }, pe.trans = S, pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = function() {
                  throw new Error("Cursor not started");
                }, pe.fail = Be(Y), pe.next = function() {
                  var an = this, rn = 1;
                  return this.start(function() {
                    return rn-- ? an.continue() : an.stop();
                  }).then(function() {
                    return an;
                  });
                }, pe.start = function(an) {
                  function rn() {
                    if (Q.result) try {
                      an();
                    } catch (mn) {
                      pe.fail(mn);
                    }
                    else pe.done = !0, pe.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, pe.stop();
                  }
                  var ft = new Promise(function(mn, tl) {
                    mn = Be(mn), Q.onerror = wn(tl), pe.fail = tl, pe.stop = function(ui) {
                      pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = Ge, mn(ui);
                    };
                  });
                  return Q.onsuccess = Be(function(mn) {
                    Q.onsuccess = rn, rn();
                  }), pe.continue = ve, pe.continuePrimaryKey = qe, pe.advance = he, rn(), ft;
                }, G(pe)) : G(null);
              }, Y);
            });
          }, count: function(C) {
            var S = C.query, P = C.trans, A = S.index, N = S.range;
            return new Promise(function(F, G) {
              var Y = P.objectStore(b), H = A.isPrimaryKey ? Y : Y.index(A.name), Y = r(N), H = Y ? H.count(Y) : H.count();
              H.onsuccess = Be(function($) {
                return F($.target.result);
              }), H.onerror = wn(G);
            });
          } };
        }
        var m, p, g, w = (p = L, g = du((m = n).objectStoreNames), { schema: { name: m.name, tables: g.map(function(T) {
          return p.objectStore(T);
        }).map(function(T) {
          var D = T.keyPath, S = T.autoIncrement, b = d(D), C = {}, S = { name: T.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: D == null, compound: b, keyPath: D, autoIncrement: S, unique: !0, extractKey: Zt(D) }, indexes: du(T.indexNames).map(function(P) {
            return T.index(P);
          }).map(function(F) {
            var A = F.name, N = F.unique, G = F.multiEntry, F = F.keyPath, G = { name: A, compound: d(F), keyPath: F, unique: N, multiEntry: G, extractKey: Zt(F) };
            return C[Cl(F)] = G;
          }), getIndexByKeyPath: function(P) {
            return C[Cl(P)];
          } };
          return C[":id"] = S.primaryKey, D != null && (C[Cl(D)] = S.primaryKey), S;
        }) }, hasGetAll: 0 < g.length && "getAll" in p.objectStore(g[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), L = w.schema, O = w.hasGetAll, w = L.tables.map(c), v = {};
        return w.forEach(function(T) {
          return v[T.name] = T;
        }), { stack: "dbcore", transaction: n.transaction.bind(n), table: function(T) {
          if (!v[T]) throw new Error("Table '".concat(T, "' not found"));
          return v[T];
        }, MIN_KEY: -1 / 0, MAX_KEY: Sl(t), schema: L };
      }
      function cr(n, t, u, r) {
        var c = u.IDBKeyRange;
        return u.indexedDB, { dbcore: (r = sr(t, c, r), n.dbcore.reduce(function(m, p) {
          return p = p.create, a(a({}, m), p(m));
        }, r)) };
      }
      function nt(n, r) {
        var u = r.db, r = cr(n._middlewares, u, n._deps, r);
        n.core = r.dbcore, n.tables.forEach(function(c) {
          var m = c.name;
          n.core.schema.tables.some(function(p) {
            return p.name === m;
          }) && (c.core = n.core.table(m), n[m] instanceof n.Table && (n[m].core = c.core));
        });
      }
      function lt(n, t, u, r) {
        u.forEach(function(c) {
          var m = r[c];
          t.forEach(function(p) {
            var g = function L(O, w) {
              return U(O, w) || (O = x(O)) && L(O, w);
            }(p, c);
            (!g || "value" in g && g.value === void 0) && (p === n.Transaction.prototype || p instanceof n.Transaction ? E(p, c, { get: function() {
              return this.table(c);
            }, set: function(L) {
              R(this, c, { value: L, writable: !0, configurable: !0, enumerable: !0 });
            } }) : p[c] = new n.Table(c, m));
          });
        });
      }
      function Ut(n, t) {
        t.forEach(function(u) {
          for (var r in u) u[r] instanceof n.Table && delete u[r];
        });
      }
      function or(n, t) {
        return n._cfg.version - t._cfg.version;
      }
      function mr(n, t, u, r) {
        var c = n._dbSchema;
        u.objectStoreNames.contains("$meta") && !c.$meta && (c.$meta = Bt("$meta", hu("")[0], []), n._storeNames.push("$meta"));
        var m = n._createTransaction("readwrite", n._storeNames, c);
        m.create(u), m._completion.catch(r);
        var p = m._reject.bind(m), g = se.transless || se;
        Un(function() {
          return se.trans = m, se.transless = g, t !== 0 ? (nt(n, u), O = t, ((L = m).storeNames.includes("$meta") ? L.table("$meta").get("version").then(function(w) {
            return w ?? O;
          }) : ee.resolve(O)).then(function(w) {
            return T = w, D = m, b = u, C = [], w = (v = n)._versions, S = v._dbSchema = it(0, v.idbdb, b), (w = w.filter(function(P) {
              return P._cfg.version >= T;
            })).length !== 0 ? (w.forEach(function(P) {
              C.push(function() {
                var A = S, N = P._cfg.dbschema;
                ut(v, A, b), ut(v, N, b), S = v._dbSchema = N;
                var F = Kt(A, N);
                F.add.forEach(function(J) {
                  Gt(b, J[0], J[1].primKey, J[1].indexes);
                }), F.change.forEach(function(J) {
                  if (J.recreate) throw new Z.Upgrade("Not yet support for changing primary key");
                  var Q = b.objectStore(J.name);
                  J.add.forEach(function(le) {
                    return tt(Q, le);
                  }), J.change.forEach(function(le) {
                    Q.deleteIndex(le.name), tt(Q, le);
                  }), J.del.forEach(function(le) {
                    return Q.deleteIndex(le);
                  });
                });
                var G = P._cfg.contentUpgrade;
                if (G && P._cfg.version > T) {
                  nt(v, b), D._memoizedTables = {};
                  var Y = oe(N);
                  F.del.forEach(function(J) {
                    Y[J] = A[J];
                  }), Ut(v, [v.Transaction.prototype]), lt(v, [v.Transaction.prototype], f(Y), Y), D.schema = Y;
                  var H, $ = We(G);
                  return $ && cl(), F = ee.follow(function() {
                    var J;
                    (H = G(D)) && $ && (J = Kn.bind(null, null), H.then(J, J));
                  }), H && typeof H.then == "function" ? ee.resolve(H) : F.then(function() {
                    return H;
                  });
                }
              }), C.push(function(A) {
                var N, F, G = P._cfg.dbschema;
                N = G, F = A, [].slice.call(F.db.objectStoreNames).forEach(function(Y) {
                  return N[Y] == null && F.db.deleteObjectStore(Y);
                }), Ut(v, [v.Transaction.prototype]), lt(v, [v.Transaction.prototype], v._storeNames, v._dbSchema), D.schema = v._dbSchema;
              }), C.push(function(A) {
                v.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(v.idbdb.version / 10) === P._cfg.version ? (v.idbdb.deleteObjectStore("$meta"), delete v._dbSchema.$meta, v._storeNames = v._storeNames.filter(function(N) {
                  return N !== "$meta";
                })) : A.objectStore("$meta").put(P._cfg.version, "version"));
              });
            }), function P() {
              return C.length ? ee.resolve(C.shift()(D.idbtrans)).then(P) : ee.resolve();
            }().then(function() {
              pu(S, b);
            })) : ee.resolve();
            var v, T, D, b, C, S;
          }).catch(p)) : (f(c).forEach(function(w) {
            Gt(u, w, c[w].primKey, c[w].indexes);
          }), nt(n, u), void ee.follow(function() {
            return n.on.populate.fire(m);
          }).catch(p));
          var L, O;
        });
      }
      function fr(n, t) {
        pu(n._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var u = it(0, n.idbdb, t);
        ut(n, n._dbSchema, t);
        for (var r = 0, c = Kt(u, n._dbSchema).change; r < c.length; r++) {
          var m = function(p) {
            if (p.change.length || p.recreate) return console.warn("Unable to patch indexes of table ".concat(p.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var g = t.objectStore(p.name);
            p.add.forEach(function(L) {
              Oe && console.debug("Dexie upgrade patch: Creating missing index ".concat(p.name, ".").concat(L.src)), tt(g, L);
            });
          }(c[r]);
          if (typeof m == "object") return m.value;
        }
      }
      function Kt(n, t) {
        var u, r = { del: [], add: [], change: [] };
        for (u in n) t[u] || r.del.push(u);
        for (u in t) {
          var c = n[u], m = t[u];
          if (c) {
            var p = { name: u, def: m, recreate: !1, del: [], add: [], change: [] };
            if ("" + (c.primKey.keyPath || "") != "" + (m.primKey.keyPath || "") || c.primKey.auto !== m.primKey.auto) p.recreate = !0, r.change.push(p);
            else {
              var g = c.idxByName, L = m.idxByName, O = void 0;
              for (O in g) L[O] || p.del.push(O);
              for (O in L) {
                var w = g[O], v = L[O];
                w ? w.src !== v.src && p.change.push(v) : p.add.push(v);
              }
              (0 < p.del.length || 0 < p.add.length || 0 < p.change.length) && r.change.push(p);
            }
          } else r.add.push([u, m]);
        }
        return r;
      }
      function Gt(n, t, u, r) {
        var c = n.db.createObjectStore(t, u.keyPath ? { keyPath: u.keyPath, autoIncrement: u.auto } : { autoIncrement: u.auto });
        return r.forEach(function(m) {
          return tt(c, m);
        }), c;
      }
      function pu(n, t) {
        f(n).forEach(function(u) {
          t.db.objectStoreNames.contains(u) || (Oe && console.debug("Dexie: Creating missing table", u), Gt(t, u, n[u].primKey, n[u].indexes));
        });
      }
      function tt(n, t) {
        n.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function it(n, t, u) {
        var r = {};
        return X(t.objectStoreNames, 0).forEach(function(c) {
          for (var m = u.objectStore(c), p = Vt(fu(O = m.keyPath), O || "", !0, !1, !!m.autoIncrement, O && typeof O != "string", !0), g = [], L = 0; L < m.indexNames.length; ++L) {
            var w = m.index(m.indexNames[L]), O = w.keyPath, w = Vt(w.name, O, !!w.unique, !!w.multiEntry, !1, O && typeof O != "string", !1);
            g.push(w);
          }
          r[c] = Bt(c, p, g);
        }), r;
      }
      function ut(n, t, u) {
        for (var r = u.db.objectStoreNames, c = 0; c < r.length; ++c) {
          var m = r[c], p = u.objectStore(m);
          n._hasGetAll = "getAll" in p;
          for (var g = 0; g < p.indexNames.length; ++g) {
            var L = p.indexNames[g], O = p.index(L).keyPath, w = typeof O == "string" ? O : "[" + X(O).join("+") + "]";
            !t[m] || (O = t[m].idxByName[w]) && (O.name = L, delete t[m].idxByName[w], t[m].idxByName[L] = O);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && o.WorkerGlobalScope && o instanceof o.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1);
      }
      function hu(n) {
        return n.split(",").map(function(t, u) {
          var m = t.split(":"), r = (c = m[1]) === null || c === void 0 ? void 0 : c.trim(), c = (t = m[0].trim()).replace(/([&*]|\+\+)/g, ""), m = /^\[/.test(c) ? c.match(/^\[(.*)\]$/)[1].split("+") : c;
          return Vt(c, m || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), d(m), u === 0, r);
        });
      }
      var dr = (dl.prototype._createTableSchema = Bt, dl.prototype._parseIndexSyntax = hu, dl.prototype._parseStoresSpec = function(n, t) {
        var u = this;
        f(n).forEach(function(r) {
          if (n[r] !== null) {
            var c = u._parseIndexSyntax(n[r]), m = c.shift();
            if (!m) throw new Z.Schema("Invalid schema for table " + r + ": " + n[r]);
            if (m.unique = !0, m.multi) throw new Z.Schema("Primary key cannot be multiEntry*");
            c.forEach(function(p) {
              if (p.auto) throw new Z.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!p.keyPath) throw new Z.Schema("Index must have a name and cannot be an empty string");
            }), c = u._createTableSchema(r, m, c), t[r] = c;
          }
        });
      }, dl.prototype.stores = function(u) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? h(this._cfg.storesSource, u) : u;
        var u = t._versions, r = {}, c = {};
        return u.forEach(function(m) {
          h(r, m._cfg.storesSource), c = m._cfg.dbschema = {}, m._parseStoresSpec(r, c);
        }), t._dbSchema = c, Ut(t, [t._allTables, t, t.Transaction.prototype]), lt(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], f(c), c), t._storeNames = f(c), this;
      }, dl.prototype.upgrade = function(n) {
        return this._cfg.contentUpgrade = Ee(this._cfg.contentUpgrade || De, n), this;
      }, dl);
      function dl() {
      }
      function zt(n, t) {
        var u = n._dbNamesDB;
        return u || (u = n._dbNamesDB = new En(Wl, { addons: [], indexedDB: n, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), u.table("dbnames");
      }
      function jt(n) {
        return n && typeof n.databases == "function";
      }
      function Ht(n) {
        return Un(function() {
          return se.letThrough = !0, n();
        });
      }
      function $t(n) {
        return !("from" in n);
      }
      var un = function(n, t) {
        if (!this) {
          var u = new un();
          return n && "d" in n && h(u, n), u;
        }
        h(this, arguments.length ? { d: 1, from: n, to: 1 < arguments.length ? t : n } : { d: 0 });
      };
      function Tl(n, t, u) {
        var r = Te(t, u);
        if (!isNaN(r)) {
          if (0 < r) throw RangeError();
          if ($t(n)) return h(n, { from: t, to: u, d: 1 });
          var c = n.l, r = n.r;
          if (Te(u, n.from) < 0) return c ? Tl(c, t, u) : n.l = { from: t, to: u, d: 1, l: null, r: null }, vu(n);
          if (0 < Te(t, n.to)) return r ? Tl(r, t, u) : n.r = { from: t, to: u, d: 1, l: null, r: null }, vu(n);
          Te(t, n.from) < 0 && (n.from = t, n.l = null, n.d = r ? r.d + 1 : 1), 0 < Te(u, n.to) && (n.to = u, n.r = null, n.d = n.l ? n.l.d + 1 : 1), u = !n.r, c && !n.l && Pl(n, c), r && u && Pl(n, r);
        }
      }
      function Pl(n, t) {
        $t(t) || function u(r, L) {
          var m = L.from, p = L.to, g = L.l, L = L.r;
          Tl(r, m, p), g && u(r, g), L && u(r, L);
        }(n, t);
      }
      function gu(n, t) {
        var u = at(t), r = u.next();
        if (r.done) return !1;
        for (var c = r.value, m = at(n), p = m.next(c.from), g = p.value; !r.done && !p.done; ) {
          if (Te(g.from, c.to) <= 0 && 0 <= Te(g.to, c.from)) return !0;
          Te(c.from, g.from) < 0 ? c = (r = u.next(g.from)).value : g = (p = m.next(c.from)).value;
        }
        return !1;
      }
      function at(n) {
        var t = $t(n) ? null : { s: 0, n };
        return { next: function(u) {
          for (var r = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, r) for (; t.n.l && Te(u, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !r || Te(u, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function vu(n) {
        var t, u, r = (((t = n.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((u = n.l) === null || u === void 0 ? void 0 : u.d) || 0), c = 1 < r ? "r" : r < -1 ? "l" : "";
        c && (t = c == "r" ? "l" : "r", u = a({}, n), r = n[c], n.from = r.from, n.to = r.to, n[c] = r[c], u[c] = r[t], (n[t] = u).d = xu(u)), n.d = xu(n);
      }
      function xu(u) {
        var t = u.r, u = u.l;
        return (t ? u ? Math.max(t.d, u.d) : t.d : u ? u.d : 0) + 1;
      }
      function rt(n, t) {
        return f(t).forEach(function(u) {
          n[u] ? Pl(n[u], t[u]) : n[u] = function r(c) {
            var m, p, g = {};
            for (m in c) I(c, m) && (p = c[m], g[m] = !p || typeof p != "object" || be.has(p.constructor) ? p : r(p));
            return g;
          }(t[u]);
        }), n;
      }
      function Wt(n, t) {
        return n.all || t.all || Object.keys(n).some(function(u) {
          return t[u] && gu(t[u], n[u]);
        });
      }
      q(un.prototype, ((In = { add: function(n) {
        return Pl(this, n), this;
      }, addKey: function(n) {
        return Tl(this, n, n), this;
      }, addKeys: function(n) {
        var t = this;
        return n.forEach(function(u) {
          return Tl(t, u, u);
        }), this;
      }, hasKey: function(n) {
        var t = at(this).next(n).value;
        return t && Te(t.from, n) <= 0 && 0 <= Te(t.to, n);
      } })[ge] = function() {
        return at(this);
      }, In));
      var nl = {}, Yt = {}, Xt = !1;
      function st(n) {
        rt(Yt, n), Xt || (Xt = !0, setTimeout(function() {
          Xt = !1, Qt(Yt, !(Yt = {}));
        }, 0));
      }
      function Qt(n, t) {
        t === void 0 && (t = !1);
        var u = /* @__PURE__ */ new Set();
        if (n.all) for (var r = 0, c = Object.values(nl); r < c.length; r++) yu(p = c[r], n, u, t);
        else for (var m in n) {
          var p, g = /^idb\:\/\/(.*)\/(.*)\//.exec(m);
          g && (m = g[1], g = g[2], (p = nl["idb://".concat(m, "/").concat(g)]) && yu(p, n, u, t));
        }
        u.forEach(function(L) {
          return L();
        });
      }
      function yu(n, t, u, r) {
        for (var c = [], m = 0, p = Object.entries(n.queries.query); m < p.length; m++) {
          for (var g = p[m], L = g[0], O = [], w = 0, v = g[1]; w < v.length; w++) {
            var T = v[w];
            Wt(t, T.obsSet) ? T.subscribers.forEach(function(S) {
              return u.add(S);
            }) : r && O.push(T);
          }
          r && c.push([L, O]);
        }
        if (r) for (var D = 0, b = c; D < b.length; D++) {
          var C = b[D], L = C[0], O = C[1];
          n.queries.query[L] = O;
        }
      }
      function pr(n) {
        var t = n._state, u = n._deps.indexedDB;
        if (t.isBeingOpened || n.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? He(t.dbOpenError) : n;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var r = t.openCanceller, c = Math.round(10 * n.verno), m = !1;
        function p() {
          if (t.openCanceller !== r) throw new Z.DatabaseClosed("db.open() was cancelled");
        }
        function g() {
          return new ee(function(T, D) {
            if (p(), !u) throw new Z.MissingAPI();
            var b = n.name, C = t.autoSchema || !c ? u.open(b) : u.open(b, c);
            if (!C) throw new Z.MissingAPI();
            C.onerror = wn(D), C.onblocked = Be(n._fireOnBlocked), C.onupgradeneeded = Be(function(S) {
              var P;
              w = C.transaction, t.autoSchema && !n._options.allowEmptyDB ? (C.onerror = bl, w.abort(), C.result.close(), (P = u.deleteDatabase(b)).onsuccess = P.onerror = Be(function() {
                D(new Z.NoSuchDatabase("Database ".concat(b, " doesnt exist")));
              })) : (w.onerror = wn(D), S = S.oldVersion > Math.pow(2, 62) ? 0 : S.oldVersion, v = S < 1, n.idbdb = C.result, m && fr(n, w), mr(n, S / 10, w, D));
            }, D), C.onsuccess = Be(function() {
              w = null;
              var S, P, A, N, F, G = n.idbdb = C.result, Y = X(G.objectStoreNames);
              if (0 < Y.length) try {
                var H = G.transaction((N = Y).length === 1 ? N[0] : N, "readonly");
                if (t.autoSchema) P = G, A = H, (S = n).verno = P.version / 10, A = S._dbSchema = it(0, P, A), S._storeNames = X(P.objectStoreNames, 0), lt(S, [S._allTables], f(A), A);
                else if (ut(n, n._dbSchema, H), ((F = Kt(it(0, (F = n).idbdb, H), F._dbSchema)).add.length || F.change.some(function($) {
                  return $.add.length || $.change.length;
                })) && !m) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), G.close(), c = G.version + 1, m = !0, T(g());
                nt(n, H);
              } catch {
              }
              ol.push(n), G.onversionchange = Be(function($) {
                t.vcFired = !0, n.on("versionchange").fire($);
              }), G.onclose = Be(function($) {
                n.on("close").fire($);
              }), v && (F = n._deps, H = b, G = F.indexedDB, F = F.IDBKeyRange, jt(G) || H === Wl || zt(G, F).put({ name: H }).catch(De)), T();
            }, D);
          }).catch(function(T) {
            switch (T?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), g();
                break;
              case "VersionError":
                if (0 < c) return c = 0, g();
            }
            return ee.reject(T);
          });
        }
        var L, O = t.dbReadyResolve, w = null, v = !1;
        return ee.race([r, (typeof navigator > "u" ? ee.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(T) {
          function D() {
            return indexedDB.databases().finally(T);
          }
          L = setInterval(D, 100), D();
        }).finally(function() {
          return clearInterval(L);
        }) : Promise.resolve()).then(g)]).then(function() {
          return p(), t.onReadyBeingFired = [], ee.resolve(Ht(function() {
            return n.on.ready.fire(n.vip);
          })).then(function T() {
            if (0 < t.onReadyBeingFired.length) {
              var D = t.onReadyBeingFired.reduce(Ee, De);
              return t.onReadyBeingFired = [], ee.resolve(Ht(function() {
                return D(n.vip);
              })).then(T);
            }
          });
        }).finally(function() {
          t.openCanceller === r && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(T) {
          t.dbOpenError = T;
          try {
            w && w.abort();
          } catch {
          }
          return r === t.openCanceller && n._close(), He(T);
        }).finally(function() {
          t.openComplete = !0, O();
        }).then(function() {
          var T;
          return v && (T = {}, n.tables.forEach(function(D) {
            D.schema.indexes.forEach(function(b) {
              b.name && (T["idb://".concat(n.name, "/").concat(D.name, "/").concat(b.name)] = new un(-1 / 0, [[[]]]));
            }), T["idb://".concat(n.name, "/").concat(D.name, "/")] = T["idb://".concat(n.name, "/").concat(D.name, "/:dels")] = new un(-1 / 0, [[[]]]);
          }), jn(wl).fire(T), Qt(T, !0)), n;
        });
      }
      function Jt(n) {
        function t(m) {
          return n.next(m);
        }
        var u = c(t), r = c(function(m) {
          return n.throw(m);
        });
        function c(m) {
          return function(L) {
            var g = m(L), L = g.value;
            return g.done ? L : L && typeof L.then == "function" ? L.then(u, r) : d(L) ? Promise.all(L).then(u, r) : u(L);
          };
        }
        return c(t)();
      }
      function ct(n, t, u) {
        for (var r = d(n) ? n.slice() : [n], c = 0; c < u; ++c) r.push(t);
        return r;
      }
      var hr = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema, c = {}, m = [];
          function p(v, T, D) {
            var b = Cl(v), C = c[b] = c[b] || [], S = v == null ? 0 : typeof v == "string" ? 1 : v.length, P = 0 < T, P = a(a({}, D), { name: P ? "".concat(b, "(virtual-from:").concat(D.name, ")") : D.name, lowLevelIndex: D, isVirtual: P, keyTail: T, keyLength: S, extractKey: Zt(v), unique: !P && D.unique });
            return C.push(P), P.isPrimaryKey || m.push(P), 1 < S && p(S === 2 ? v[0] : v.slice(0, S - 1), T + 1, D), C.sort(function(A, N) {
              return A.keyTail - N.keyTail;
            }), P;
          }
          t = p(r.primaryKey.keyPath, 0, r.primaryKey), c[":id"] = [t];
          for (var g = 0, L = r.indexes; g < L.length; g++) {
            var O = L[g];
            p(O.keyPath, 0, O);
          }
          function w(v) {
            var T, D = v.query.index;
            return D.isVirtual ? a(a({}, v), { query: { index: D.lowLevelIndex, range: (T = v.query.range, D = D.keyTail, { type: T.type === 1 ? 2 : T.type, lower: ct(T.lower, T.lowerOpen ? n.MAX_KEY : n.MIN_KEY, D), lowerOpen: !0, upper: ct(T.upper, T.upperOpen ? n.MIN_KEY : n.MAX_KEY, D), upperOpen: !0 }) } }) : v;
          }
          return a(a({}, u), { schema: a(a({}, r), { primaryKey: t, indexes: m, getIndexByKeyPath: function(v) {
            return (v = c[Cl(v)]) && v[0];
          } }), count: function(v) {
            return u.count(w(v));
          }, query: function(v) {
            return u.query(w(v));
          }, openCursor: function(v) {
            var T = v.query.index, D = T.keyTail, b = T.isVirtual, C = T.keyLength;
            return b ? u.openCursor(w(v)).then(function(P) {
              return P && S(P);
            }) : u.openCursor(v);
            function S(P) {
              return Object.create(P, { continue: { value: function(A) {
                A != null ? P.continue(ct(A, v.reverse ? n.MAX_KEY : n.MIN_KEY, D)) : v.unique ? P.continue(P.key.slice(0, C).concat(v.reverse ? n.MIN_KEY : n.MAX_KEY, D)) : P.continue();
              } }, continuePrimaryKey: { value: function(A, N) {
                P.continuePrimaryKey(ct(A, n.MAX_KEY, D), N);
              } }, primaryKey: { get: function() {
                return P.primaryKey;
              } }, key: { get: function() {
                var A = P.key;
                return C === 1 ? A[0] : A.slice(0, C);
              } }, value: { get: function() {
                return P.value;
              } } });
            }
          } });
        } });
      } };
      function ei(n, t, u, r) {
        return u = u || {}, r = r || "", f(n).forEach(function(c) {
          var m, p, g;
          I(t, c) ? (m = n[c], p = t[c], typeof m == "object" && typeof p == "object" && m && p ? (g = Se(m)) !== Se(p) ? u[r + c] = t[c] : g === "Object" ? ei(m, p, u, r + c + ".") : m !== p && (u[r + c] = t[c]) : m !== p && (u[r + c] = t[c])) : u[r + c] = void 0;
        }), f(t).forEach(function(c) {
          I(n, c) || (u[r + c] = t[c]);
        }), u;
      }
      function ni(n, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(n.extractKey);
      }
      var gr = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema.primaryKey;
          return a(a({}, u), { mutate: function(c) {
            var m = se.trans, p = m.table(t).hook, g = p.deleting, L = p.creating, O = p.updating;
            switch (c.type) {
              case "add":
                if (L.fire === De) break;
                return m._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "put":
                if (L.fire === De && O.fire === De) break;
                return m._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "delete":
                if (g.fire === De) break;
                return m._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "deleteRange":
                if (g.fire === De) break;
                return m._promise("readwrite", function() {
                  return function v(T, D, b) {
                    return u.query({ trans: T, values: !1, query: { index: r, range: D }, limit: b }).then(function(C) {
                      var S = C.result;
                      return w({ type: "delete", keys: S, trans: T }).then(function(P) {
                        return 0 < P.numFailures ? Promise.reject(P.failures[0]) : S.length < b ? { failures: [], numFailures: 0, lastResult: void 0 } : v(T, a(a({}, D), { lower: S[S.length - 1], lowerOpen: !0 }), b);
                      });
                    });
                  }(c.trans, c.range, 1e4);
                }, !0);
            }
            return u.mutate(c);
            function w(v) {
              var T, D, b, C = se.trans, S = v.keys || ni(r, v);
              if (!S) throw new Error("Keys missing");
              return (v = v.type === "add" || v.type === "put" ? a(a({}, v), { keys: S }) : a({}, v)).type !== "delete" && (v.values = s([], v.values)), v.keys && (v.keys = s([], v.keys)), T = u, b = S, ((D = v).type === "add" ? Promise.resolve([]) : T.getMany({ trans: D.trans, keys: b, cache: "immutable" })).then(function(P) {
                var A = S.map(function(N, F) {
                  var G, Y, H, $ = P[F], J = { onerror: null, onsuccess: null };
                  return v.type === "delete" ? g.fire.call(J, N, $, C) : v.type === "add" || $ === void 0 ? (G = L.fire.call(J, N, v.values[F], C), N == null && G != null && (v.keys[F] = N = G, r.outbound || ne(v.values[F], r.keyPath, N))) : (G = ei($, v.values[F]), (Y = O.fire.call(J, G, N, $, C)) && (H = v.values[F], Object.keys(Y).forEach(function(Q) {
                    I(H, Q) ? H[Q] = Y[Q] : ne(H, Q, Y[Q]);
                  }))), J;
                });
                return u.mutate(v).then(function(N) {
                  for (var F = N.failures, G = N.results, Y = N.numFailures, N = N.lastResult, H = 0; H < S.length; ++H) {
                    var $ = (G || S)[H], J = A[H];
                    $ == null ? J.onerror && J.onerror(F[H]) : J.onsuccess && J.onsuccess(v.type === "put" && P[H] ? v.values[H] : $);
                  }
                  return { failures: F, results: G, numFailures: Y, lastResult: N };
                }).catch(function(N) {
                  return A.forEach(function(F) {
                    return F.onerror && F.onerror(N);
                  }), Promise.reject(N);
                });
              });
            }
          } });
        } });
      } };
      function Iu(n, t, u) {
        try {
          if (!t || t.keys.length < n.length) return null;
          for (var r = [], c = 0, m = 0; c < t.keys.length && m < n.length; ++c) Te(t.keys[c], n[m]) === 0 && (r.push(u ? ye(t.values[c]) : t.values[c]), ++m);
          return r.length === n.length ? r : null;
        } catch {
          return null;
        }
      }
      var vr = { stack: "dbcore", level: -1, create: function(n) {
        return { table: function(t) {
          var u = n.table(t);
          return a(a({}, u), { getMany: function(r) {
            if (!r.cache) return u.getMany(r);
            var c = Iu(r.keys, r.trans._cache, r.cache === "clone");
            return c ? ee.resolve(c) : u.getMany(r).then(function(m) {
              return r.trans._cache = { keys: r.keys, values: r.cache === "clone" ? ye(m) : m }, m;
            });
          }, mutate: function(r) {
            return r.type !== "add" && (r.trans._cache = null), u.mutate(r);
          } });
        } };
      } };
      function Lu(n, t) {
        return n.trans.mode === "readonly" && !!n.subscr && !n.trans.explicit && n.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function Du(n, t) {
        switch (n) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var xr = { stack: "dbcore", level: 0, name: "Observability", create: function(n) {
        var t = n.schema.name, u = new un(n.MIN_KEY, n.MAX_KEY);
        return a(a({}, n), { transaction: function(r, c, m) {
          if (se.subscr && c !== "readonly") throw new Z.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(se.querier));
          return n.transaction(r, c, m);
        }, table: function(r) {
          var c = n.table(r), m = c.schema, p = m.primaryKey, v = m.indexes, g = p.extractKey, L = p.outbound, O = p.autoIncrement && v.filter(function(D) {
            return D.compound && D.keyPath.includes(p.keyPath);
          }), w = a(a({}, c), { mutate: function(D) {
            function b(Q) {
              return Q = "idb://".concat(t, "/").concat(r, "/").concat(Q), N[Q] || (N[Q] = new un());
            }
            var C, S, P, A = D.trans, N = D.mutatedParts || (D.mutatedParts = {}), F = b(""), G = b(":dels"), Y = D.type, J = D.type === "deleteRange" ? [D.range] : D.type === "delete" ? [D.keys] : D.values.length < 50 ? [ni(p, D).filter(function(Q) {
              return Q;
            }), D.values] : [], H = J[0], $ = J[1], J = D.trans._cache;
            return d(H) ? (F.addKeys(H), (J = Y === "delete" || H.length === $.length ? Iu(H, J) : null) || G.addKeys(H), (J || $) && (C = b, S = J, P = $, m.indexes.forEach(function(Q) {
              var le = C(Q.name || "");
              function ve(he) {
                return he != null ? Q.extractKey(he) : null;
              }
              function qe(he) {
                return Q.multiEntry && d(he) ? he.forEach(function(Ge) {
                  return le.addKey(Ge);
                }) : le.addKey(he);
              }
              (S || P).forEach(function(he, an) {
                var pe = S && ve(S[an]), an = P && ve(P[an]);
                Te(pe, an) !== 0 && (pe != null && qe(pe), an != null && qe(an));
              });
            }))) : H ? ($ = { from: ($ = H.lower) !== null && $ !== void 0 ? $ : n.MIN_KEY, to: ($ = H.upper) !== null && $ !== void 0 ? $ : n.MAX_KEY }, G.add($), F.add($)) : (F.add(u), G.add(u), m.indexes.forEach(function(Q) {
              return b(Q.name).add(u);
            })), c.mutate(D).then(function(Q) {
              return !H || D.type !== "add" && D.type !== "put" || (F.addKeys(Q.results), O && O.forEach(function(le) {
                for (var ve = D.values.map(function(pe) {
                  return le.extractKey(pe);
                }), qe = le.keyPath.findIndex(function(pe) {
                  return pe === p.keyPath;
                }), he = 0, Ge = Q.results.length; he < Ge; ++he) ve[he][qe] = Q.results[he];
                b(le.name).addKeys(ve);
              })), A.mutatedParts = rt(A.mutatedParts || {}, N), Q;
            });
          } }), v = function(b) {
            var C = b.query, b = C.index, C = C.range;
            return [b, new un((b = C.lower) !== null && b !== void 0 ? b : n.MIN_KEY, (C = C.upper) !== null && C !== void 0 ? C : n.MAX_KEY)];
          }, T = { get: function(D) {
            return [p, new un(D.key)];
          }, getMany: function(D) {
            return [p, new un().addKeys(D.keys)];
          }, count: v, query: v, openCursor: v };
          return f(T).forEach(function(D) {
            w[D] = function(b) {
              var C = se.subscr, S = !!C, P = Lu(se, c) && Du(D, b) ? b.obsSet = {} : C;
              if (S) {
                var A = function($) {
                  return $ = "idb://".concat(t, "/").concat(r, "/").concat($), P[$] || (P[$] = new un());
                }, N = A(""), F = A(":dels"), C = T[D](b), S = C[0], C = C[1];
                if ((D === "query" && S.isPrimaryKey && !b.values ? F : A(S.name || "")).add(C), !S.isPrimaryKey) {
                  if (D !== "count") {
                    var G = D === "query" && L && b.values && c.query(a(a({}, b), { values: !1 }));
                    return c[D].apply(this, arguments).then(function($) {
                      if (D === "query") {
                        if (L && b.values) return G.then(function(ve) {
                          return ve = ve.result, N.addKeys(ve), $;
                        });
                        var J = b.values ? $.result.map(g) : $.result;
                        (b.values ? N : F).addKeys(J);
                      } else if (D === "openCursor") {
                        var Q = $, le = b.values;
                        return Q && Object.create(Q, { key: { get: function() {
                          return F.addKey(Q.primaryKey), Q.key;
                        } }, primaryKey: { get: function() {
                          var ve = Q.primaryKey;
                          return F.addKey(ve), ve;
                        } }, value: { get: function() {
                          return le && N.addKey(Q.primaryKey), Q.value;
                        } } });
                      }
                      return $;
                    });
                  }
                  F.add(u);
                }
              }
              return c[D].apply(this, arguments);
            };
          }), w;
        } });
      } };
      function Ou(n, t, u) {
        if (u.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var r = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return u.numFailures === r ? null : (t = a({}, t), d(t.keys) && (t.keys = t.keys.filter(function(c, m) {
          return !(m in u.failures);
        })), "values" in t && d(t.values) && (t.values = t.values.filter(function(c, m) {
          return !(m in u.failures);
        })), t);
      }
      function li(n, t) {
        return u = n, ((r = t).lower === void 0 || (r.lowerOpen ? 0 < Te(u, r.lower) : 0 <= Te(u, r.lower))) && (n = n, (t = t).upper === void 0 || (t.upperOpen ? Te(n, t.upper) < 0 : Te(n, t.upper) <= 0));
        var u, r;
      }
      function bu(n, t, T, r, c, m) {
        if (!T || T.length === 0) return n;
        var p = t.query.index, g = p.multiEntry, L = t.query.range, O = r.schema.primaryKey.extractKey, w = p.extractKey, v = (p.lowLevelIndex || p).extractKey, T = T.reduce(function(D, b) {
          var C = D, S = [];
          if (b.type === "add" || b.type === "put") for (var P = new un(), A = b.values.length - 1; 0 <= A; --A) {
            var N, F = b.values[A], G = O(F);
            P.hasKey(G) || (N = w(F), (g && d(N) ? N.some(function(Q) {
              return li(Q, L);
            }) : li(N, L)) && (P.addKey(G), S.push(F)));
          }
          switch (b.type) {
            case "add":
              var Y = new un().addKeys(t.values ? D.map(function(le) {
                return O(le);
              }) : D), C = D.concat(t.values ? S.filter(function(le) {
                return le = O(le), !Y.hasKey(le) && (Y.addKey(le), !0);
              }) : S.map(function(le) {
                return O(le);
              }).filter(function(le) {
                return !Y.hasKey(le) && (Y.addKey(le), !0);
              }));
              break;
            case "put":
              var H = new un().addKeys(b.values.map(function(le) {
                return O(le);
              }));
              C = D.filter(function(le) {
                return !H.hasKey(t.values ? O(le) : le);
              }).concat(t.values ? S : S.map(function(le) {
                return O(le);
              }));
              break;
            case "delete":
              var $ = new un().addKeys(b.keys);
              C = D.filter(function(le) {
                return !$.hasKey(t.values ? O(le) : le);
              });
              break;
            case "deleteRange":
              var J = b.range;
              C = D.filter(function(le) {
                return !li(O(le), J);
              });
          }
          return C;
        }, n);
        return T === n ? n : (T.sort(function(D, b) {
          return Te(v(D), v(b)) || Te(O(D), O(b));
        }), t.limit && t.limit < 1 / 0 && (T.length > t.limit ? T.length = t.limit : n.length === t.limit && T.length < t.limit && (c.dirty = !0)), m ? Object.freeze(T) : T);
      }
      function wu(n, t) {
        return Te(n.lower, t.lower) === 0 && Te(n.upper, t.upper) === 0 && !!n.lowerOpen == !!t.lowerOpen && !!n.upperOpen == !!t.upperOpen;
      }
      function yr(n, t) {
        return function(u, r, c, m) {
          if (u === void 0) return r !== void 0 ? -1 : 0;
          if (r === void 0) return 1;
          if ((r = Te(u, r)) === 0) {
            if (c && m) return 0;
            if (c) return 1;
            if (m) return -1;
          }
          return r;
        }(n.lower, t.lower, n.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(u, r, c, m) {
          if (u === void 0) return r !== void 0 ? 1 : 0;
          if (r === void 0) return -1;
          if ((r = Te(u, r)) === 0) {
            if (c && m) return 0;
            if (c) return -1;
            if (m) return 1;
          }
          return r;
        }(n.upper, t.upper, n.upperOpen, t.upperOpen);
      }
      function Ir(n, t, u, r) {
        n.subscribers.add(u), r.addEventListener("abort", function() {
          var c, m;
          n.subscribers.delete(u), n.subscribers.size === 0 && (c = n, m = t, setTimeout(function() {
            c.subscribers.size === 0 && de(m, c);
          }, 3e3));
        });
      }
      var Lr = { stack: "dbcore", level: 0, name: "Cache", create: function(n) {
        var t = n.schema.name;
        return a(a({}, n), { transaction: function(u, r, c) {
          var m, p, g = n.transaction(u, r, c);
          return r === "readwrite" && (p = (m = new AbortController()).signal, c = function(L) {
            return function() {
              if (m.abort(), r === "readwrite") {
                for (var O = /* @__PURE__ */ new Set(), w = 0, v = u; w < v.length; w++) {
                  var T = v[w], D = nl["idb://".concat(t, "/").concat(T)];
                  if (D) {
                    var b = n.table(T), C = D.optimisticOps.filter(function(le) {
                      return le.trans === g;
                    });
                    if (g._explicit && L && g.mutatedParts) for (var S = 0, P = Object.values(D.queries.query); S < P.length; S++) for (var A = 0, N = (Y = P[S]).slice(); A < N.length; A++) Wt((H = N[A]).obsSet, g.mutatedParts) && (de(Y, H), H.subscribers.forEach(function(le) {
                      return O.add(le);
                    }));
                    else if (0 < C.length) {
                      D.optimisticOps = D.optimisticOps.filter(function(le) {
                        return le.trans !== g;
                      });
                      for (var F = 0, G = Object.values(D.queries.query); F < G.length; F++) for (var Y, H, $, J = 0, Q = (Y = G[F]).slice(); J < Q.length; J++) (H = Q[J]).res != null && g.mutatedParts && (L && !H.dirty ? ($ = Object.isFrozen(H.res), $ = bu(H.res, H.req, C, b, H, $), H.dirty ? (de(Y, H), H.subscribers.forEach(function(le) {
                        return O.add(le);
                      })) : $ !== H.res && (H.res = $, H.promise = ee.resolve({ result: $ }))) : (H.dirty && de(Y, H), H.subscribers.forEach(function(le) {
                        return O.add(le);
                      })));
                    }
                  }
                }
                O.forEach(function(le) {
                  return le();
                });
              }
            };
          }, g.addEventListener("abort", c(!1), { signal: p }), g.addEventListener("error", c(!1), { signal: p }), g.addEventListener("complete", c(!0), { signal: p })), g;
        }, table: function(u) {
          var r = n.table(u), c = r.schema.primaryKey;
          return a(a({}, r), { mutate: function(m) {
            var p = se.trans;
            if (c.outbound || p.db._options.cache === "disabled" || p.explicit || p.idbtrans.mode !== "readwrite") return r.mutate(m);
            var g = nl["idb://".concat(t, "/").concat(u)];
            return g ? (p = r.mutate(m), m.type !== "add" && m.type !== "put" || !(50 <= m.values.length || ni(c, m).some(function(L) {
              return L == null;
            })) ? (g.optimisticOps.push(m), m.mutatedParts && st(m.mutatedParts), p.then(function(L) {
              0 < L.numFailures && (de(g.optimisticOps, m), (L = Ou(0, m, L)) && g.optimisticOps.push(L), m.mutatedParts && st(m.mutatedParts));
            }), p.catch(function() {
              de(g.optimisticOps, m), m.mutatedParts && st(m.mutatedParts);
            })) : p.then(function(L) {
              var O = Ou(0, a(a({}, m), { values: m.values.map(function(w, v) {
                var T;
                return L.failures[v] || (w = (T = c.keyPath) !== null && T !== void 0 && T.includes(".") ? ye(w) : a({}, w), ne(w, c.keyPath, L.results[v])), w;
              }) }), L);
              g.optimisticOps.push(O), queueMicrotask(function() {
                return m.mutatedParts && st(m.mutatedParts);
              });
            }), p) : r.mutate(m);
          }, query: function(m) {
            if (!Lu(se, r) || !Du("query", m)) return r.query(m);
            var p = ((O = se.trans) === null || O === void 0 ? void 0 : O.db._options.cache) === "immutable", v = se, g = v.requery, L = v.signal, O = function(b, C, S, P) {
              var A = nl["idb://".concat(b, "/").concat(C)];
              if (!A) return [];
              if (!(C = A.queries[S])) return [null, !1, A, null];
              var N = C[(P.query ? P.query.index.name : null) || ""];
              if (!N) return [null, !1, A, null];
              switch (S) {
                case "query":
                  var F = N.find(function(G) {
                    return G.req.limit === P.limit && G.req.values === P.values && wu(G.req.query.range, P.query.range);
                  });
                  return F ? [F, !0, A, N] : [N.find(function(G) {
                    return ("limit" in G.req ? G.req.limit : 1 / 0) >= P.limit && (!P.values || G.req.values) && yr(G.req.query.range, P.query.range);
                  }), !1, A, N];
                case "count":
                  return F = N.find(function(G) {
                    return wu(G.req.query.range, P.query.range);
                  }), [F, !!F, A, N];
              }
            }(t, u, "query", m), w = O[0], v = O[1], T = O[2], D = O[3];
            return w && v ? w.obsSet = m.obsSet : (v = r.query(m).then(function(b) {
              var C = b.result;
              if (w && (w.res = C), p) {
                for (var S = 0, P = C.length; S < P; ++S) Object.freeze(C[S]);
                Object.freeze(C);
              } else b.result = ye(C);
              return b;
            }).catch(function(b) {
              return D && w && de(D, w), Promise.reject(b);
            }), w = { obsSet: m.obsSet, promise: v, subscribers: /* @__PURE__ */ new Set(), type: "query", req: m, dirty: !1 }, D ? D.push(w) : (D = [w], (T = T || (nl["idb://".concat(t, "/").concat(u)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[m.query.index.name || ""] = D)), Ir(w, D, g, L), w.promise.then(function(b) {
              return { result: bu(b.result, m, T?.optimisticOps, r, w, p) };
            });
          } });
        } });
      } };
      function ot(n, t) {
        return new Proxy(n, { get: function(u, r, c) {
          return r === "db" ? t : Reflect.get(u, r, c);
        } });
      }
      var En = ($e.prototype.version = function(n) {
        if (isNaN(n) || n < 0.1) throw new Z.Type("Given version is not a positive number");
        if (n = Math.round(10 * n) / 10, this.idbdb || this._state.isBeingOpened) throw new Z.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, n);
        var t = this._versions, u = t.filter(function(r) {
          return r._cfg.version === n;
        })[0];
        return u || (u = new this.Version(n), t.push(u), t.sort(or), u.stores({}), this._state.autoSchema = !1, u);
      }, $e.prototype._whenReady = function(n) {
        var t = this;
        return this.idbdb && (this._state.openComplete || se.letThrough || this._vip) ? n() : new ee(function(u, r) {
          if (t._state.openComplete) return r(new Z.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void r(new Z.DatabaseClosed());
            t.open().catch(De);
          }
          t._state.dbReadyPromise.then(u, r);
        }).then(n);
      }, $e.prototype.use = function(n) {
        var t = n.stack, u = n.create, r = n.level, c = n.name;
        return c && this.unuse({ stack: t, name: c }), n = this._middlewares[t] || (this._middlewares[t] = []), n.push({ stack: t, create: u, level: r ?? 10, name: c }), n.sort(function(m, p) {
          return m.level - p.level;
        }), this;
      }, $e.prototype.unuse = function(n) {
        var t = n.stack, u = n.name, r = n.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(c) {
          return r ? c.create !== r : !!u && c.name !== u;
        })), this;
      }, $e.prototype.open = function() {
        var n = this;
        return Qn(Rn, function() {
          return pr(n);
        });
      }, $e.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var n = this._state, t = ol.indexOf(this);
        if (0 <= t && ol.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        n.isBeingOpened || (n.dbReadyPromise = new ee(function(u) {
          n.dbReadyResolve = u;
        }), n.openCanceller = new ee(function(u, r) {
          n.cancelOpen = r;
        }));
      }, $e.prototype.close = function(u) {
        var t = (u === void 0 ? { disableAutoOpen: !0 } : u).disableAutoOpen, u = this._state;
        t ? (u.isBeingOpened && u.cancelOpen(new Z.DatabaseClosed()), this._close(), u.autoOpen = !1, u.dbOpenError = new Z.DatabaseClosed()) : (this._close(), u.autoOpen = this._options.autoOpen || u.isBeingOpened, u.openComplete = !1, u.dbOpenError = null);
      }, $e.prototype.delete = function(n) {
        var t = this;
        n === void 0 && (n = { disableAutoOpen: !0 });
        var u = 0 < arguments.length && typeof arguments[0] != "object", r = this._state;
        return new ee(function(c, m) {
          function p() {
            t.close(n);
            var g = t._deps.indexedDB.deleteDatabase(t.name);
            g.onsuccess = Be(function() {
              var L, O, w;
              L = t._deps, O = t.name, w = L.indexedDB, L = L.IDBKeyRange, jt(w) || O === Wl || zt(w, L).delete(O).catch(De), c();
            }), g.onerror = wn(m), g.onblocked = t._fireOnBlocked;
          }
          if (u) throw new Z.InvalidArgument("Invalid closeOptions argument to db.delete()");
          r.isBeingOpened ? r.dbReadyPromise.then(p) : p();
        });
      }, $e.prototype.backendDB = function() {
        return this.idbdb;
      }, $e.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, $e.prototype.hasBeenClosed = function() {
        var n = this._state.dbOpenError;
        return n && n.name === "DatabaseClosed";
      }, $e.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, $e.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty($e.prototype, "tables", { get: function() {
        var n = this;
        return f(this._allTables).map(function(t) {
          return n._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), $e.prototype.transaction = function() {
        var n = (function(t, u, r) {
          var c = arguments.length;
          if (c < 2) throw new Z.InvalidArgument("Too few arguments");
          for (var m = new Array(c - 1); --c; ) m[c - 1] = arguments[c];
          return r = m.pop(), [t, me(m), r];
        }).apply(this, arguments);
        return this._transaction.apply(this, n);
      }, $e.prototype._transaction = function(n, t, u) {
        var r = this, c = se.trans;
        c && c.db === this && n.indexOf("!") === -1 || (c = null);
        var m, p, g = n.indexOf("?") !== -1;
        n = n.replace("!", "").replace("?", "");
        try {
          if (p = t.map(function(O) {
            if (O = O instanceof r.Table ? O.name : O, typeof O != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return O;
          }), n == "r" || n === _t) m = _t;
          else {
            if (n != "rw" && n != Nt) throw new Z.InvalidArgument("Invalid transaction mode: " + n);
            m = Nt;
          }
          if (c) {
            if (c.mode === _t && m === Nt) {
              if (!g) throw new Z.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              c = null;
            }
            c && p.forEach(function(O) {
              if (c && c.storeNames.indexOf(O) === -1) {
                if (!g) throw new Z.SubTransaction("Table " + O + " not included in parent transaction.");
                c = null;
              }
            }), g && c && !c.active && (c = null);
          }
        } catch (O) {
          return c ? c._promise(null, function(w, v) {
            v(O);
          }) : He(O);
        }
        var L = (function O(w, v, T, D, b) {
          return ee.resolve().then(function() {
            var C = se.transless || se, S = w._createTransaction(v, T, w._dbSchema, D);
            if (S.explicit = !0, C = { trans: S, transless: C }, D) S.idbtrans = D.idbtrans;
            else try {
              S.create(), S.idbtrans._explicit = !0, w._state.PR1398_maxLoop = 3;
            } catch (N) {
              return N.name === V.InvalidState && w.isOpen() && 0 < --w._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), w.close({ disableAutoOpen: !1 }), w.open().then(function() {
                return O(w, v, T, null, b);
              })) : He(N);
            }
            var P, A = We(b);
            return A && cl(), C = ee.follow(function() {
              var N;
              (P = b.call(S, S)) && (A ? (N = Kn.bind(null, null), P.then(N, N)) : typeof P.next == "function" && typeof P.throw == "function" && (P = Jt(P)));
            }, C), (P && typeof P.then == "function" ? ee.resolve(P).then(function(N) {
              return S.active ? N : He(new Z.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : C.then(function() {
              return P;
            })).then(function(N) {
              return D && S._resolve(), S._completion.then(function() {
                return N;
              });
            }).catch(function(N) {
              return S._reject(N), He(N);
            });
          });
        }).bind(null, this, m, p, c, u);
        return c ? c._promise(m, L, "lock") : se.trans ? Qn(se.transless, function() {
          return r._whenReady(L);
        }) : this._whenReady(L);
      }, $e.prototype.table = function(n) {
        if (!I(this._allTables, n)) throw new Z.InvalidTable("Table ".concat(n, " does not exist"));
        return this._allTables[n];
      }, $e);
      function $e(n, t) {
        var u = this;
        this._middlewares = {}, this.verno = 0;
        var r = $e.dependencies;
        this._options = t = a({ addons: $e.addons, autoOpen: !0, indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, r = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var c, m, p, g, L, O = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: De, dbReadyPromise: null, cancelOpen: De, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        O.dbReadyPromise = new ee(function(v) {
          O.dbReadyResolve = v;
        }), O.openCanceller = new ee(function(v, T) {
          O.cancelOpen = T;
        }), this._state = O, this.name = n, this.on = Ll(this, "populate", "blocked", "versionchange", "close", { ready: [Ee, De] }), this.once = function(v, T) {
          var D = function() {
            for (var b = [], C = 0; C < arguments.length; C++) b[C] = arguments[C];
            u.on(v).unsubscribe(D), T.apply(u, b);
          };
          return u.on(v, D);
        }, this.on.ready.subscribe = B(this.on.ready.subscribe, function(v) {
          return function(T, D) {
            $e.vip(function() {
              var b, C = u._state;
              C.openComplete ? (C.dbOpenError || ee.resolve().then(T), D && v(T)) : C.onReadyBeingFired ? (C.onReadyBeingFired.push(T), D && v(T)) : (v(T), b = u, D || v(function S() {
                b.on.ready.unsubscribe(T), b.on.ready.unsubscribe(S);
              }));
            });
          };
        }), this.Collection = (c = this, Dl(tr.prototype, function(P, S) {
          this.db = c;
          var D = nu, b = null;
          if (S) try {
            D = S();
          } catch (A) {
            b = A;
          }
          var C = P._ctx, S = C.table, P = S.hook.reading.fire;
          this._ctx = { table: S, index: C.index, isPrimKey: !C.index || S.schema.primKey.keyPath && C.index === S.schema.primKey.name, range: D, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: b, or: C.or, valueMapper: P !== j ? P : null };
        })), this.Table = (m = this, Dl(uu.prototype, function(v, T, D) {
          this.db = m, this._tx = D, this.name = v, this.schema = T, this.hook = m._allTables[v] ? m._allTables[v].hook : Ll(null, { creating: [Ce, De], reading: [ie, j], updating: [we, De], deleting: [Ie, De] });
        })), this.Transaction = (p = this, Dl(ar.prototype, function(v, T, D, b, C) {
          var S = this;
          v !== "readonly" && T.forEach(function(P) {
            P = (P = D[P]) === null || P === void 0 ? void 0 : P.yProps, P && (T = T.concat(P.map(function(A) {
              return A.updatesTable;
            })));
          }), this.db = p, this.mode = v, this.storeNames = T, this.schema = D, this.chromeTransactionDurability = b, this.idbtrans = null, this.on = Ll(this, "complete", "error", "abort"), this.parent = C || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ee(function(P, A) {
            S._resolve = P, S._reject = A;
          }), this._completion.then(function() {
            S.active = !1, S.on.complete.fire();
          }, function(P) {
            var A = S.active;
            return S.active = !1, S.on.error.fire(P), S.parent ? S.parent._reject(P) : A && S.idbtrans && S.idbtrans.abort(), He(P);
          });
        })), this.Version = (g = this, Dl(dr.prototype, function(v) {
          this.db = g, this._cfg = { version: v, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (L = this, Dl(mu.prototype, function(v, T, D) {
          if (this.db = L, this._ctx = { table: v, index: T === ":id" ? null : T, or: D }, this._cmp = this._ascending = Te, this._descending = function(b, C) {
            return Te(C, b);
          }, this._max = function(b, C) {
            return 0 < Te(b, C) ? b : C;
          }, this._min = function(b, C) {
            return Te(b, C) < 0 ? b : C;
          }, this._IDBKeyRange = L._deps.IDBKeyRange, !this._IDBKeyRange) throw new Z.MissingAPI();
        })), this.on("versionchange", function(v) {
          0 < v.newVersion ? console.warn("Another connection wants to upgrade database '".concat(u.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(u.name, "'. Closing db now to resume the delete request.")), u.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(v) {
          !v.newVersion || v.newVersion < v.oldVersion ? console.warn("Dexie.delete('".concat(u.name, "') was blocked")) : console.warn("Upgrade '".concat(u.name, "' blocked by other connection holding version ").concat(v.oldVersion / 10));
        }), this._maxKey = Sl(t.IDBKeyRange), this._createTransaction = function(v, T, D, b) {
          return new u.Transaction(v, T, D, u._options.chromeTransactionDurability, b);
        }, this._fireOnBlocked = function(v) {
          u.on("blocked").fire(v), ol.filter(function(T) {
            return T.name === u.name && T !== u && !T._state.vcFired;
          }).map(function(T) {
            return T.on("versionchange").fire(v);
          });
        }, this.use(vr), this.use(Lr), this.use(xr), this.use(hr), this.use(gr);
        var w = new Proxy(this, { get: function(v, T, D) {
          if (T === "_vip") return !0;
          if (T === "table") return function(C) {
            return ot(u.table(C), w);
          };
          var b = Reflect.get(v, T, D);
          return b instanceof uu ? ot(b, w) : T === "tables" ? b.map(function(C) {
            return ot(C, w);
          }) : T === "_createTransaction" ? function() {
            return ot(b.apply(this, arguments), w);
          } : b;
        } });
        this.vip = w, r.forEach(function(v) {
          return v(u);
        });
      }
      var mt, In = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Dr = (ti.prototype.subscribe = function(n, t, u) {
        return this._subscribe(n && typeof n != "function" ? n : { next: n, error: t, complete: u });
      }, ti.prototype[In] = function() {
        return this;
      }, ti);
      function ti(n) {
        this._subscribe = n;
      }
      try {
        mt = { indexedDB: o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB, IDBKeyRange: o.IDBKeyRange || o.webkitIDBKeyRange };
      } catch {
        mt = { indexedDB: null, IDBKeyRange: null };
      }
      function Su(n) {
        var t, u = !1, r = new Dr(function(c) {
          var m = We(n), p, g = !1, L = {}, O = {}, w = { get closed() {
            return g;
          }, unsubscribe: function() {
            g || (g = !0, p && p.abort(), v && jn.storagemutated.unsubscribe(D));
          } };
          c.start && c.start(w);
          var v = !1, T = function() {
            return Et(b);
          }, D = function(C) {
            rt(L, C), Wt(O, L) && T();
          }, b = function() {
            var C, S, P;
            !g && mt.indexedDB && (L = {}, C = {}, p && p.abort(), p = new AbortController(), P = function(A) {
              var N = rl();
              try {
                m && cl();
                var F = Un(n, A);
                return F = m ? F.finally(Kn) : F;
              } finally {
                N && sl();
              }
            }(S = { subscr: C, signal: p.signal, requery: T, querier: n, trans: null }), Promise.resolve(P).then(function(A) {
              u = !0, t = A, g || S.signal.aborted || (L = {}, function(N) {
                for (var F in N) if (I(N, F)) return;
                return 1;
              }(O = C) || v || (jn(wl, D), v = !0), Et(function() {
                return !g && c.next && c.next(A);
              }));
            }, function(A) {
              u = !1, ["DatabaseClosedError", "AbortError"].includes(A?.name) || g || Et(function() {
                g || c.error && c.error(A);
              });
            }));
          };
          return setTimeout(T, 0), w;
        });
        return r.hasValue = function() {
          return u;
        }, r.getValue = function() {
          return t;
        }, r;
      }
      var ll = En;
      function ii(n) {
        var t = Hn;
        try {
          Hn = !0, jn.storagemutated.fire(n), Qt(n, !0);
        } finally {
          Hn = t;
        }
      }
      q(ll, a(a({}, Qe), { delete: function(n) {
        return new ll(n, { addons: [] }).delete();
      }, exists: function(n) {
        return new ll(n, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(n) {
        try {
          return t = ll.dependencies, u = t.indexedDB, t = t.IDBKeyRange, (jt(u) ? Promise.resolve(u.databases()).then(function(r) {
            return r.map(function(c) {
              return c.name;
            }).filter(function(c) {
              return c !== Wl;
            });
          }) : zt(u, t).toCollection().primaryKeys()).then(n);
        } catch {
          return He(new Z.MissingAPI());
        }
        var t, u;
      }, defineClass: function() {
        return function(n) {
          h(this, n);
        };
      }, ignoreTransaction: function(n) {
        return se.trans ? Qn(se.transless, n) : n();
      }, vip: Ht, async: function(n) {
        return function() {
          try {
            var t = Jt(n.apply(this, arguments));
            return t && typeof t.then == "function" ? t : ee.resolve(t);
          } catch (u) {
            return He(u);
          }
        };
      }, spawn: function(n, t, u) {
        try {
          var r = Jt(n.apply(u, t || []));
          return r && typeof r.then == "function" ? r : ee.resolve(r);
        } catch (c) {
          return He(c);
        }
      }, currentTransaction: { get: function() {
        return se.trans || null;
      } }, waitFor: function(n, t) {
        return t = ee.resolve(typeof n == "function" ? ll.ignoreTransaction(n) : n).timeout(t || 6e4), se.trans ? se.trans.waitFor(t) : t;
      }, Promise: ee, debug: { get: function() {
        return Oe;
      }, set: function(n) {
        Pe(n);
      } }, derive: M, extend: h, props: q, override: B, Events: Ll, on: jn, liveQuery: Su, extendObservabilitySet: rt, getByKeyPath: ae, setByKeyPath: ne, delByKeyPath: function(n, t) {
        typeof t == "string" ? ne(n, t, void 0) : "length" in t && [].map.call(t, function(u) {
          ne(n, u, void 0);
        });
      }, shallowClone: oe, deepClone: ye, getObjectDiff: ei, cmp: Te, asap: W, minKey: -1 / 0, addons: [], connections: ol, errnames: V, dependencies: mt, cache: nl, semVer: "4.2.0", version: "4.2.0".split(".").map(function(n) {
        return parseInt(n);
      }).reduce(function(n, t, u) {
        return n + t / Math.pow(10, 2 * u);
      }) })), ll.maxKey = Sl(ll.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (jn(wl, function(n) {
        Hn || (n = new CustomEvent(kt, { detail: n }), Hn = !0, dispatchEvent(n), Hn = !1);
      }), addEventListener(kt, function(n) {
        n = n.detail, Hn || ii(n);
      }));
      var xl, Hn = !1, Cu = function() {
      };
      return typeof BroadcastChannel < "u" && ((Cu = function() {
        (xl = new BroadcastChannel(kt)).onmessage = function(n) {
          return n.data && ii(n.data);
        };
      })(), typeof xl.unref == "function" && xl.unref(), jn(wl, function(n) {
        Hn || xl.postMessage(n);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(n) {
        if (!En.disableBfCache && n.persisted) {
          Oe && console.debug("Dexie: handling persisted pagehide"), xl?.close();
          for (var t = 0, u = ol; t < u.length; t++) u[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(n) {
        !En.disableBfCache && n.persisted && (Oe && console.debug("Dexie: handling persisted pageshow"), Cu(), ii({ all: new un(-1 / 0, [[]]) }));
      })), ee.rejectionMapper = function(n, t) {
        return !n || n instanceof cn || n instanceof TypeError || n instanceof SyntaxError || !n.name || !ue[n.name] ? n : (t = new ue[n.name](t || n.message, n), "stack" in n && E(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, Pe(Oe), a(En, Object.freeze({ __proto__: null, Dexie: En, liveQuery: Su, Entity: lu, cmp: Te, PropModification: Ol, replacePrefix: function(n, t) {
        return new Ol({ replacePrefix: [n, t] });
      }, add: function(n) {
        return new Ol({ add: n });
      }, remove: function(n) {
        return new Ol({ remove: n });
      }, default: En, RangeSet: un, mergeRanges: Pl, rangesOverlap: gu }), { default: En }), En;
    });
  }(Lm)), Lm.exports;
}
var gL = hL();
const Dm = /* @__PURE__ */ dL(gL), Dd = Symbol.for("Dexie"), Sc = globalThis[Dd] || (globalThis[Dd] = Dm);
if (Dm.semVer !== Sc.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Dm.semVer} and ${Sc.semVer}`);
const {
  liveQuery: qg,
  mergeRanges: vC,
  rangesOverlap: xC,
  RangeSet: yC,
  cmp: IC,
  Entity: LC,
  PropModification: DC,
  replacePrefix: OC,
  add: bC,
  remove: wC,
  DexieYProvider: SC
} = Sc, Kl = "sclElements", vL = "id, tagName, [id+tagName], &attributes.uuid, &attributes.id, attributes.name, parent.id, parent.tagName, *children.id, *children.tagName";
function xL(e) {
  const { databaseName: l } = e, i = new Sc(l);
  return i.version(1).stores({
    [`${Kl}`]: vL
  }), i;
}
const yL = {
  FunctionCategory: {
    tag: "FunctionCategory",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Category of functions. To be added to Process, Line, Substation, VoltageLevel and Bay SCL elements

Category of functions. To be added to Process, Line, Substation, VoltageLevel and Bay SCL elements`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SubCategory", "FunctionCatRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubCategory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FunctionCatRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProcessResources: {
    tag: "ProcessResources",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `List of Process Resources related to a function. to be added to the SCL elements Function, SubFunction, EqFunction and EqSubFunction

List of Process Resources related to a function. to be added to the SCL elements Function, SubFunction, EqFunction and EqSubFunction`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "ProcessResource"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessResource: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueResource",
              kind: "unique",
              paths: [["Resource"]],
              deep: !1,
              attributes: ["resInst"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniquePR",
        kind: "unique",
        paths: [["ProcessResource"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PowerSystemRelations: {
    tag: "PowerSystemRelations",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Functional relation from a Function/SubFunction to another element of the process

Functional relation from a Function/SubFunction to another element of the process`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "PowerSystemRelation"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        PowerSystemRelation: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniquePSR",
        kind: "unique",
        paths: [["PowerSystemRelation"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeInputs: {
    tag: "LNodeInputs",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `List of specification inputs of the given LNode. To be added at LNode level

List of specification inputs of the given LNode. To be added at LNode level`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SourceRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SourceRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueSourceRef",
        kind: "unique",
        paths: [["SourceRef"]],
        deep: !1,
        attributes: ["input", "inputInst", "pDA"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeOutputs: {
    tag: "LNodeOutputs",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `List of specification outputs of the given LNode. To be added at LNode level

List of specification outputs of the given LNode. To be added at LNode level`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "ControlRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ControlRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueControlRef",
        kind: "unique",
        paths: [["ControlRef"]],
        deep: !1,
        attributes: ["output", "outputInst"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProcessEcho: {
    tag: "ProcessEcho",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Definition of an echo LNode, mirroring the DO of another LNode

Definition of an echo LNode, mirroring the DO of another LNode`,
    parents: ["DAS", "DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "source", "sourceDaName", "sourceDoName", "sourceLNodeUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceDaName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceLNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeSpecNaming: {
    tag: "LNodeSpecNaming",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `LNode user specification. To be added to LNode SCL element

LNode user specification. To be added to LNode SCL element`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["sIedName", "sLdInst", "sLnClass", "sLnInst", "sPrefix"],
      details: {
        sIedName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "None",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sLdInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sLnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sLnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sPrefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DOS: {
    tag: "DOS",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Data Object specification. To be added to LNode SCL element

Data Object specification. To be added to LNode SCL element`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "mappedDoName", "mappedLnUuid", "name"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedLnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 12,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "SDS",
        "DAS",
        "SubscriberLNode",
        "ControllingLNode",
        "ProcessEcho",
        "LogParametersRef",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SDS: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueSDS_DASinSDS",
              kind: "unique",
              paths: [["DAS|.", "SDS"]],
              deep: !1,
              attributes: ["name", "ix"],
              refer: null,
              text: !1
            }
          ]
        },
        DAS: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubscriberLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ControllingLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessEcho: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDOS",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "SDS",
            "DAS",
            "SubscriberLNode",
            "ControllingLNode",
            "ProcessEcho",
            "LogParametersRef"
          ]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueSDS_DASinDOS",
        kind: "unique",
        paths: [["DAS|.", "SDS"]],
        deep: !1,
        attributes: ["name", "ix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionSclRef: {
    tag: "FunctionSclRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to the FSD files used to create a Function. Could be added under Function/SubFunction/EqFunction/EqSubFunction

Reference to the FSD files used to create a Function. Could be added under Function/SubFunction/EqFunction/EqSubFunction`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SclFileReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SclFileReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  CheckoutID: {
    tag: "CheckoutID",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Element used by an IED to indicates that a file has been imported to give engineering rights on this IED. This is opening a transaction between both projects to lock it on first project until the checkout is given back from current project, which then lock the IED locally

Element used by an IED to indicates that a file has been imported to give engineering rights on this IED. This is opening a transaction between both projects to lock it on first project until the checkout is given back from current project, which then lock the IED locally`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "desc",
        "engRight",
        "fileName",
        "fileType",
        "fileUuid",
        "headerId",
        "revision",
        "version",
        "when"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        engRight: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["full", "fix", "dataflow"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["SED", "SCC", "ICD", "IID", "CID", "SSD", "SCD"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        headerId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["SubCheckoutID"],
      details: {
        SubCheckoutID: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tSclFileUUIDCheckoutRestriction",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Variable: {
    tag: "Variable",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `A Variable is a way to define a global variable which can be modified by a user and applied to a list of SCL attributes

A Variable is a way to define a global variable which can be modified by a user and applied to a list of SCL attributes`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid", "value"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "VariableApplyTo"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        VariableApplyTo: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  CommunicationServiceSpecifications: {
    tag: "CommunicationServiceSpecifications",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `The CommunicationServiceSpecifications is containing parameters used to create control blocks during implementation

The CommunicationServiceSpecifications is containing parameters used to create control blocks during implementation`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "GooseParameters", "SMVParameters", "ReportParameters"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GooseParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["GooseParameters", "SMVParameters", "ReportParameters"]
        }
      ]
    },
    constraints: [
      {
        name: "commServiceSpecKey",
        kind: "key",
        paths: [["*"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ServiceSpecifications: {
    tag: "ServiceSpecifications",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `The ServiceSpecification is containing parameters used to create control blocks or physical interface (LPDI/LPDO) during implementation

The ServiceSpecification is containing parameters used to create control blocks or physical interface (LPDI/LPDO) during implementation`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "GooseParameters",
        "SMVParameters",
        "ReportParameters",
        "BinaryWiringParameters",
        "AnalogueWiringParameters",
        "LogParameters"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GooseParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        AnalogueWiringParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "GooseParameters",
            "SMVParameters",
            "ReportParameters",
            "BinaryWiringParameters",
            "AnalogueWiringParameters",
            "LogParameters"
          ]
        }
      ]
    },
    constraints: [
      {
        name: "serviceSpecKey",
        kind: "key",
        paths: [["*"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BayType: {
    tag: "BayType",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Bay type element is keeping value of the type. It's a free string

Bay type element is keeping value of the type. It's a free string`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tBayType",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AllocationRole: {
    tag: "AllocationRole",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Definition of an allocation role allowing definition of possible allocation to devices type without using virtual IED

Definition of an allocation role allowing definition of possible allocation to devices type without using virtual IED`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Application: {
    tag: "Application",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Application definition to be added at Process, Substation, Voltage Level or Bay level

Application definition to be added at Process, Substation, Voltage Level or Bay level`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "FunctionRole",
        "FunctionalVariant",
        "FunctionalVariantGroup",
        "AllocationRoleRef",
        "ApplicationSclRef"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionRole: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueRoleContent",
              kind: "unique",
              paths: [["FunctionRoleContent"]],
              deep: !1,
              attributes: ["roleInst"],
              refer: null,
              text: !1
            }
          ]
        },
        FunctionalVariant: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FunctionalVariantGroup: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        AllocationRoleRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ApplicationSclRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BehaviorDescription: {
    tag: "BehaviorDescription",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Element allowing to describe the behavior its parent (Application, Bay, Function, LN...)

Element allowing to describe the behavior its parent (Application, Bay, Function, LN...)`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "desc",
        "fileReference",
        "format",
        "isSimulation",
        "isSpecification",
        "name",
        "originUuid",
        "templateUuid",
        "uuid"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileReference: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        format: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["IEC 61131", "Textual", "Graphic"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        isSimulation: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        isSpecification: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "InputVar", "OutputVar", "BehaviorReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        InputVar: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        OutputVar: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        BehaviorReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInBehaviorDescription",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["varName"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Project: {
    tag: "Project",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Element allowing to define a project, to identify the project and the process elements defined by this project

Element allowing to define a project, to identify the project and the process elements defined by this project`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "ProjectProcessReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProjectProcessReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionTemplate: {
    tag: "FunctionTemplate",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Base element for FSD format, will be used as a template element for Function/SubFunction or EqFunction/EqSubFunction

Base element for FSD format, will be used as a template element for Function/SubFunction or EqFunction/EqSubFunction`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "LNode", "SubFunctionTemplate", "GeneralEquipment", "ConductingEquipment"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SubFunctionTemplate: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInSubFuncTemplate",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGEFuncTemplate",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipmentOfFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInCondEqTemplate",
              kind: "unique",
              paths: [["SubEquipment|.", "EqFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "t6-100LNodeContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SCL: {
    tag: "SCL",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["release", "revision", "version"],
      details: {
        release: {
          required: !0,
          default: "5",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 255,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: "C",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z]", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: "2007",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["2[0-2][0-9]{2}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Header",
        "Substation",
        "Communication",
        "IED",
        "DataTypeTemplates",
        "Line",
        "Process"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Header: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueHitem",
              kind: "unique",
              paths: [["History", "Hitem"]],
              deep: !1,
              attributes: ["version", "revision"],
              refer: null,
              text: !1
            }
          ]
        },
        Substation: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Communication: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        IED: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DataTypeTemplates: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Line: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Process: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "SubstationKey",
        kind: "key",
        paths: [["Substation|.", "Process|.", "Line"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "IEDKey",
        kind: "key",
        paths: [["IED"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "LNodeTypeKey",
        kind: "key",
        paths: [["DataTypeTemplates", "LNodeType"]],
        deep: !1,
        attributes: ["id", "lnClass"],
        refer: null,
        text: !1
      },
      {
        name: "ConnectivityNodeKey",
        kind: "key",
        paths: [["ConnectivityNode"]],
        deep: !0,
        attributes: ["pathName"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueHitem",
        kind: "unique",
        paths: [["History", "Hitem"]],
        deep: !1,
        attributes: ["version", "revision"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueUUID",
        kind: "unique",
        paths: [["*"]],
        deep: !0,
        attributes: ["uuid"],
        refer: null,
        text: !1
      },
      {
        name: "ref2LNodeTypeDomain1",
        kind: "keyref",
        paths: [["IED", "AccessPoint", "LN"]],
        deep: !1,
        attributes: ["lnType", "lnClass"],
        refer: "LNodeTypeKey",
        text: !1
      },
      {
        name: "ref2LNodeTypeDomain2",
        kind: "keyref",
        paths: [["IED", "AccessPoint", "Server", "LDevice", "LN"]],
        deep: !1,
        attributes: ["lnType", "lnClass"],
        refer: "LNodeTypeKey",
        text: !1
      },
      {
        name: "ref2LNodeTypeLLN0",
        kind: "keyref",
        paths: [["IED", "AccessPoint", "Server", "LDevice", "LN0"]],
        deep: !1,
        attributes: ["lnType", "lnClass"],
        refer: "LNodeTypeKey",
        text: !1
      },
      {
        name: "refConnectedAP2IED",
        kind: "keyref",
        paths: [["Communication", "SubNetwork", "ConnectedAP"]],
        deep: !1,
        attributes: ["iedName"],
        refer: "IEDKey",
        text: !1
      },
      {
        name: "ref2SubstationFromTerminal",
        kind: "keyref",
        paths: [["Terminal"]],
        deep: !0,
        attributes: ["substationName"],
        refer: "scl:SubstationKey",
        text: !1
      }
    ],
    value: {
      type: "tBaseElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Substation: {
    tag: "Substation",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Process", "SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "PowerTransformer",
        "GeneralEquipment",
        "VoltageLevel",
        "Function"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        PowerTransformer: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInPowerTransformer",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTR",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        VoltageLevel: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueChildNameInVoltageLevel",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueLNodeInVoltageLevel",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunctionSS",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInSubstationFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInSubstation",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInSubstation",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Process: {
    tag: "Process",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Process", "SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "GeneralEquipment",
        "Function",
        "ConductingEquipment",
        "Substation",
        "Line",
        "Process"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment2",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE2",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFunction",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Substation: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueChildNameInProcessSubstation",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueLNodeInProcessSubstation",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Line: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Process: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueChildNameInSubProcess",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueLNodeInSubProcess",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInProcess",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInProcess",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tGeneralEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Line: {
    tag: "Line",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Process", "SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "nomFreq", "numPhases", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nomFreq: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: "0",
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        numPhases: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 255,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "GeneralEquipment",
        "Function",
        "Voltage",
        "ConductingEquipment",
        "ConnectivityNode"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment2",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE2",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFunction",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        Voltage: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConductingEquipment: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        },
        ConnectivityNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInLine",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInLine",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tGeneralEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LN0: {
    tag: "LN0",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LDevice"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "inst", "lnClass", "lnType", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inst: {
          required: !0,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: "LLN0",
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "DataSet",
        "ReportControl",
        "LogControl",
        "DOI",
        "Inputs",
        "Outputs",
        "Log",
        "Labels",
        "GSEControl",
        "SampledValueControl",
        "SettingControl"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DataSet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ReportControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LogControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DOI: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueSDI_DAIinDOI",
              kind: "unique",
              paths: [["DAI|.", "SDI"]],
              deep: !1,
              attributes: ["name", "ix"],
              refer: null,
              text: !1
            }
          ]
        },
        Inputs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Outputs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Log: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLN",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        GSEControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SampledValueControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SettingControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "DataSetKeyLN0",
        kind: "key",
        paths: [["DataSet"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueReportControlInLN0",
        kind: "unique",
        paths: [["ReportControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLogControlInLN0",
        kind: "unique",
        paths: [["LogControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueGSEControlInLN0",
        kind: "unique",
        paths: [["GSEControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueSampledValueControlInLN0",
        kind: "unique",
        paths: [["SampledValueControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueDOIinLN0",
        kind: "unique",
        paths: [["DOI"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLogInLN0",
        kind: "unique",
        paths: [["Log"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "ref2DataSetReportLN0",
        kind: "keyref",
        paths: [["ReportControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyLN0",
        text: !1
      },
      {
        name: "ref2DataSetLogLN0",
        kind: "keyref",
        paths: [["LogControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyLN0",
        text: !1
      },
      {
        name: "ref2DataSetGSELN0",
        kind: "keyref",
        paths: [["GSEControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyLN0",
        text: !1
      },
      {
        name: "ref2DataSetSVLN0",
        kind: "keyref",
        paths: [["SampledValueControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyLN0",
        text: !1
      }
    ],
    value: {
      type: "tLN0",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LN: {
    tag: "LN",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["AccessPoint", "LDevice"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "inst", "lnClass", "lnType", "prefix", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "DataSet",
        "ReportControl",
        "LogControl",
        "DOI",
        "Inputs",
        "Outputs",
        "Log",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DataSet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ReportControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LogControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DOI: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueSDI_DAIinDOI",
              kind: "unique",
              paths: [["DAI|.", "SDI"]],
              deep: !1,
              attributes: ["name", "ix"],
              refer: null,
              text: !1
            }
          ]
        },
        Inputs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Outputs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Log: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLN",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "DataSetKeyInLN",
        kind: "key",
        paths: [["DataSet"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueReportControlInLN",
        kind: "unique",
        paths: [["ReportControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLogControlInLN",
        kind: "unique",
        paths: [["LogControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueDOIinLN",
        kind: "unique",
        paths: [["DOI"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLogInLN",
        kind: "unique",
        paths: [["Log"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "ref2DataSetReport",
        kind: "keyref",
        paths: [["ReportControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyInLN",
        text: !1
      },
      {
        name: "ref2DataSetLog",
        kind: "keyref",
        paths: [["LogControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyInLN",
        text: !1
      }
    ],
    value: {
      type: "tAnyLN",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  IED: {
    tag: "IED",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "configVersion",
        "desc",
        "engRight",
        "manufacturer",
        "name",
        "originalSclRelease",
        "originalSclRevision",
        "originalSclVersion",
        "owner",
        "templateUuid",
        "type",
        "uuid"
      ],
      details: {
        configVersion: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        engRight: {
          required: !1,
          default: "full",
          namespace: null,
          validation: {
            enumeration: ["full", "fix", "dataflow"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        manufacturer: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originalSclRelease: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 255,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originalSclRevision: {
          required: !1,
          default: "A",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z]", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originalSclVersion: {
          required: !1,
          default: "2003",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["2[0-2][0-9]{2}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        owner: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Services",
        "AccessPoint",
        "KDC",
        "IEDSourceFiles",
        "MinRequestedSCDFiles",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Services: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        AccessPoint: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNInAccessPoint",
              kind: "unique",
              paths: [["LN"]],
              deep: !1,
              attributes: ["inst", "lnClass", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        KDC: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        IEDSourceFiles: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        MinRequestedSCDFiles: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueProjectInReqSCD",
              kind: "unique",
              paths: [["MinRequestedSCDFile"]],
              deep: !1,
              attributes: ["fileUuid"],
              refer: null,
              text: !1
            }
          ]
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInIED",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "LDeviceInIEDKey",
        kind: "key",
        paths: [["AccessPoint", "Server", "LDevice"]],
        deep: !1,
        attributes: ["inst"],
        refer: null,
        text: !1
      },
      {
        name: "AccessPointInIEDKey",
        kind: "key",
        paths: [["AccessPoint"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "ref2LDeviceInDataSetForFCDAinLN",
        kind: "keyref",
        paths: [["AccessPoint", "Server", "LDevice", "LN", "DataSet", "FCDA"]],
        deep: !1,
        attributes: ["ldInst"],
        refer: "LDeviceInIEDKey",
        text: !1
      },
      {
        name: "ref2LDeviceInDataSetForFCDAinLN0",
        kind: "keyref",
        paths: [["AccessPoint", "Server", "LDevice", "LN0", "DataSet", "FCDA"]],
        deep: !1,
        attributes: ["ldInst"],
        refer: "LDeviceInIEDKey",
        text: !1
      },
      {
        name: "ServerAtRef2AccessPoint",
        kind: "keyref",
        paths: [["AccessPoint", "ServerAt"]],
        deep: !1,
        attributes: ["apName"],
        refer: "AccessPointInIEDKey",
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Communication: {
    tag: "Communication",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SubNetwork"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SubNetwork: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueConnectedAP",
              kind: "unique",
              paths: [["ConnectedAP"]],
              deep: !1,
              attributes: ["iedName", "apName"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueSubNetwork",
        kind: "unique",
        paths: [["SubNetwork"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DataTypeTemplates: {
    tag: "DataTypeTemplates",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: ["LNodeType", "DOType", "DAType", "EnumType"],
      details: {
        LNodeType: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueDOInLNodeType",
              kind: "unique",
              paths: [["DO"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        DOType: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueDAorSDOInDOType",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        DAType: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueBDAInDAType",
              kind: "unique",
              paths: [["BDA"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueProtNs",
              kind: "unique",
              paths: [["ProtNs"]],
              deep: !1,
              attributes: ["type"],
              refer: null,
              text: !1
            }
          ]
        },
        EnumType: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueOrdInEnumType",
              kind: "unique",
              paths: [["EnumVal"]],
              deep: !1,
              attributes: ["ord"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueEnumValue",
              kind: "unique",
              paths: [["EnumVal"]],
              deep: !1,
              attributes: [],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "DOTypeKey",
        kind: "key",
        paths: [["DOType"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      },
      {
        name: "EnumTypeDATypeKey",
        kind: "key",
        paths: [["DAType | scl:EnumType"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueDTT_ID",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      },
      {
        name: "ref2DOType",
        kind: "keyref",
        paths: [["LNodeType", "DO"]],
        deep: !1,
        attributes: ["type"],
        refer: "DOTypeKey",
        text: !1
      },
      {
        name: "ref2DOTypeForSDO",
        kind: "keyref",
        paths: [["DOType", "SDO"]],
        deep: !1,
        attributes: ["type"],
        refer: "DOTypeKey",
        text: !1
      },
      {
        name: "ref2EnumTypeDAType",
        kind: "keyref",
        paths: [["DOType", "DA | scl:DAType", "BDA"]],
        deep: !1,
        attributes: ["type"],
        refer: "scl:EnumTypeDATypeKey",
        text: !1
      }
    ],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Text: {
    tag: "Text",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [
      "AccessPoint",
      "AllocationRole",
      "AllocationRoleRef",
      "AnalogueWiringParameters",
      "AnalogueWiringParametersRef",
      "Application",
      "ApplicationSclRef",
      "BDA",
      "Bay",
      "BehaviorDescription",
      "BehaviorDescriptionRef",
      "BehaviorReference",
      "BinaryWiringParameters",
      "BinaryWiringParametersRef",
      "Communication",
      "CommunicationServiceSpecifications",
      "ConductingEquipment",
      "ConnectedAP",
      "ConnectivityNode",
      "ControlRef",
      "ControllingLNode",
      "DA",
      "DAI",
      "DAS",
      "DAType",
      "DO",
      "DOI",
      "DOS",
      "DOType",
      "DataSet",
      "EnumType",
      "EqFunction",
      "EqSubFunction",
      "ExtCtrl",
      "ExtRef",
      "Function",
      "FunctionCatRef",
      "FunctionCategory",
      "FunctionCategoryRef",
      "FunctionRef",
      "FunctionRole",
      "FunctionRoleContent",
      "FunctionSclRef",
      "FunctionTemplate",
      "FunctionalSubVariant",
      "FunctionalVariant",
      "FunctionalVariantGroup",
      "FunctionalVariantRef",
      "GOOSESecurity",
      "GSE",
      "GSEControl",
      "GeneralEquipment",
      "GooseParameters",
      "GooseParametersRef",
      "Header",
      "IED",
      "IEDSourceFiles",
      "InputVar",
      "InputVarRef",
      "Inputs",
      "L2CommParameters",
      "L3IPv4CommParameters",
      "L3IPv6CommParameters",
      "LDevice",
      "LN",
      "LN0",
      "LNode",
      "LNodeDataRef",
      "LNodeInputRef",
      "LNodeInputs",
      "LNodeOutputRef",
      "LNodeOutputs",
      "LNodeSpecNaming",
      "LNodeType",
      "Labels",
      "Line",
      "Log",
      "LogControl",
      "LogParameters",
      "LogParametersRef",
      "MinRequestedSCDFiles",
      "NeutralPoint",
      "OutputVar",
      "OutputVarRef",
      "Outputs",
      "PhysConn",
      "PowerSystemRelation",
      "PowerSystemRelationRef",
      "PowerSystemRelations",
      "PowerTransformer",
      "Process",
      "ProcessEcho",
      "ProcessResource",
      "ProcessResourceRef",
      "ProcessResources",
      "Project",
      "ProjectProcessReference",
      "ReportControl",
      "ReportParameters",
      "ReportParametersRef",
      "RptEnabled",
      "SCL",
      "SDI",
      "SDO",
      "SDS",
      "SMV",
      "SMVParameters",
      "SMVParametersRef",
      "SMVSecurity",
      "SampledValueControl",
      "SclFileReference",
      "Server",
      "ServerAt",
      "ServiceSpecifications",
      "SettingControl",
      "SignalRole",
      "SourceFiles",
      "SourceRef",
      "SubCategory",
      "SubEquipment",
      "SubFunction",
      "SubFunctionTemplate",
      "SubNetwork",
      "SubscriberLNode",
      "Substation",
      "TapChanger",
      "Terminal",
      "TransformerWinding",
      "Variable",
      "VariableApplyTo",
      "VariableRef",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["source"],
      details: {
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tAnyContentFromOtherNamespace",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubCategory: {
    tag: "SubCategory",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Recursive definition of function category

Recursive definition of function category`,
    parents: ["FunctionCategory", "SubCategory"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SubCategory", "FunctionCatRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubCategory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FunctionCatRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionCatRef: {
    tag: "FunctionCatRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a function which is part of the current category

Reference to a function which is part of the current category`,
    parents: ["FunctionCategory", "SubCategory"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["function", "functionUuid"],
      details: {
        function: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProcessResource: {
    tag: "ProcessResource",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["ProcessResources"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cardinality",
        "desc",
        "max",
        "name",
        "originUuid",
        "selector",
        "templateUuid",
        "uuid"
      ],
      details: {
        cardinality: {
          required: !1,
          default: "1..1",
          namespace: null,
          validation: {
            enumeration: ["0..1", "1..1", "0..n", "1..n"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 2,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        selector: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Resource"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Resource: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueResource",
        kind: "unique",
        paths: [["Resource"]],
        deep: !1,
        attributes: ["resInst"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PowerSystemRelation: {
    tag: "PowerSystemRelation",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["PowerSystemRelations"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "desc",
        "name",
        "originUuid",
        "relation",
        "relationUuid",
        "selector",
        "templateUuid",
        "uuid"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        relation: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        relationUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        selector: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SourceRef: {
    tag: "SourceRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a data in the process

Reference to a data in the process`,
    parents: ["LNodeInputs"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "desc",
        "extRefAddr",
        "extRefUuid",
        "input",
        "inputInst",
        "originUuid",
        "pDA",
        "pDO",
        "pLN",
        "resourceName",
        "resourceUuid",
        "service",
        "source",
        "sourceDaName",
        "sourceDoName",
        "sourceLNodeUuid",
        "templateUuid",
        "uuid"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        extRefAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        extRefUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        input: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inputInst: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDA: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDO: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        service: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Poll", "Report", "GOOSE", "SMV", "Wired", "Internal"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceDaName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceLNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "GooseParametersRef",
        "SMVParametersRef",
        "ReportParametersRef",
        "BinaryWiringParametersRef",
        "AnalogueWiringParametersRef"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GooseParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        AnalogueWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: [
            "GooseParametersRef",
            "SMVParametersRef",
            "ReportParametersRef",
            "BinaryWiringParametersRef",
            "AnalogueWiringParametersRef"
          ]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tLinkFCDARef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ControlRef: {
    tag: "ControlRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a control data in the process

Reference to a control data in the process`,
    parents: ["LNodeOutputs"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "controlled",
        "controlledDoName",
        "controlledLNodeUuid",
        "desc",
        "extCtrlAddr",
        "extCtrlUuid",
        "originUuid",
        "output",
        "outputInst",
        "pDO",
        "pLN",
        "resourceName",
        "resourceUuid",
        "templateUuid",
        "uuid"
      ],
      details: {
        controlled: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        controlledDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        controlledLNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        extCtrlAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        extCtrlUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        output: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outputInst: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDO: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "BinaryWiringParametersRef", "AnalogueWiringParametersRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        AnalogueWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["BinaryWiringParametersRef", "AnalogueWiringParametersRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tLinkFCDRef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SDS: {
    tag: "SDS",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of a sub-Data Object

Specification of a sub-Data Object`,
    parents: ["DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "ix", "mappedDoName", "mappedLnUuid", "name"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedLnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "SDS",
        "DAS",
        "SubscriberLNode",
        "ControllingLNode",
        "ProcessEcho",
        "LogParametersRef",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SDS: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        DAS: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubscriberLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ControllingLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessEcho: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInSDS",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "SDS",
            "DAS",
            "SubscriberLNode",
            "ControllingLNode",
            "ProcessEcho",
            "LogParametersRef"
          ]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueSDS_DASinSDS",
        kind: "unique",
        paths: [["DAS|.", "SDS"]],
        deep: !1,
        attributes: ["name", "ix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DAS: {
    tag: "DAS",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of a Data attribute

Specification of a Data attribute`,
    parents: ["DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "ix", "mappedDaName", "mappedLnUuid", "name", "valImport", "valKind"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedDaName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)\\.([a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*)"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedLnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valImport: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valKind: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Spec", "Conf", "RO", "Set"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "SubscriberLNode",
        "ControllingLNode",
        "ProcessEcho",
        "LogParametersRef",
        "Val",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubscriberLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ControllingLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessEcho: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Val: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDAS",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "SubscriberLNode",
            "ControllingLNode",
            "ProcessEcho",
            "LogParametersRef",
            "Val",
            "Labels"
          ]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubscriberLNode: {
    tag: "SubscriberLNode",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["DAS", "DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "inputName", "pLN", "resourceName", "resourceUuid", "service"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inputName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        service: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Poll", "Report", "GOOSE", "SMV", "Wired", "Internal"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "GooseParametersRef",
        "SMVParametersRef",
        "ReportParametersRef",
        "BinaryWiringParametersRef"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GooseParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: [
            "GooseParametersRef",
            "SMVParametersRef",
            "ReportParametersRef",
            "BinaryWiringParametersRef"
          ]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ControllingLNode: {
    tag: "ControllingLNode",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["DAS", "DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "outputName", "pLN", "resourceName", "resourceUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outputName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "BinaryWiringParametersRef", "AnalogueWiringParametersRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        AnalogueWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["BinaryWiringParametersRef", "AnalogueWiringParametersRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LogParametersRef: {
    tag: "LogParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the Log parameters expected for the current DOS when Log capability is required

Specification of the Log parameters expected for the current DOS when Log capability is required`,
    parents: ["DAS", "DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Labels: {
    tag: "Labels",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [
      "AccessPoint",
      "BDA",
      "Bay",
      "ConductingEquipment",
      "ConnectivityNode",
      "DA",
      "DAI",
      "DAS",
      "DAType",
      "DO",
      "DOI",
      "DOS",
      "DOType",
      "EqFunction",
      "EqSubFunction",
      "Function",
      "GOOSESecurity",
      "GeneralEquipment",
      "IED",
      "LDevice",
      "LN",
      "LN0",
      "LNode",
      "LNodeType",
      "Line",
      "PowerTransformer",
      "Process",
      "SDI",
      "SDO",
      "SDS",
      "SMVSecurity",
      "SubEquipment",
      "SubFunction",
      "SubNetwork",
      "Substation",
      "TapChanger",
      "TransformerWinding",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Label"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Label: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLabel",
        kind: "unique",
        paths: [["Label"]],
        deep: !1,
        attributes: ["id", "lang"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SclFileReference: {
    tag: "SclFileReference",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ApplicationSclRef", "FunctionSclRef", "IEDSourceFiles", "SourceFiles"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "fileName", "fileType", "fileUuid", "revision", "version", "when"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["ICD", "IID", "CID", "SSD", "SCD", "SED"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubCheckoutID: {
    tag: "SubCheckoutID",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `When an IED is checkedout for a collaborative work by an SCC, it may be required to give right to a subpart of the collaborative project. So a CheckoutID may have an additional SubCheckoutID giving IED to nother project

When an IED is checkedout for a collaborative work by an SCC, it may be required to give right to a subpart of the collaborative project. So a CheckoutID may have an additional SubCheckoutID giving IED to nother project`,
    parents: ["CheckoutID", "SubCheckoutID"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "desc",
        "engRight",
        "fileName",
        "fileType",
        "fileUuid",
        "headerId",
        "revision",
        "version",
        "when"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        engRight: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["full", "fix", "dataflow"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["SED", "SCC", "ICD", "IID", "CID", "SSD", "SCD"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        headerId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["SubCheckoutID"],
      details: {
        SubCheckoutID: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tSclFileUUIDCheckoutRestriction",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  VariableApplyTo: {
    tag: "VariableApplyTo",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["Variable"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "attribute",
        "daName",
        "defaultValue",
        "desc",
        "doName",
        "element",
        "elementUuid",
        "format",
        "sGroup"
      ],
      details: {
        attribute: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        defaultValue: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        element: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        elementUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        format: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sGroup: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GooseParameters: {
    tag: "GooseParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["cbName", "desc", "dsName", "goId", "id", "maxTime", "minTime", "securityEnabled"],
      details: {
        cbName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        goId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxTime: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        minTime: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        securityEnabled: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "L2CommParameters", "L3IPv4CommParameters", "L3IPv6CommParameters"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        L2CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        L3IPv4CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        L3IPv6CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["L2CommParameters", "L3IPv4CommParameters", "L3IPv6CommParameters"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tControlBlockParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVParameters: {
    tag: "SMVParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cbName",
        "desc",
        "dsName",
        "id",
        "multicast",
        "nofASDU",
        "securityEnabled",
        "smpMod",
        "smpRate",
        "smvId"
      ],
      details: {
        cbName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        multicast: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nofASDU: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        securityEnabled: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpMod: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["SmpPerPeriod", "SmpPerSec", "SecPerSmp"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpRate: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smvId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "L2CommParameters", "L3IPv4CommParameters", "L3IPv6CommParameters"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        L2CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        L3IPv4CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        L3IPv6CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["L2CommParameters", "L3IPv4CommParameters", "L3IPv6CommParameters"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tControlBlockParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReportParameters: {
    tag: "ReportParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["bufTime", "buffered", "cbName", "desc", "dsName", "id", "intgPd"],
      details: {
        bufTime: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        buffered: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlBlockParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BinaryWiringParameters: {
    tag: "BinaryWiringParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "debTm",
        "desc",
        "fastOutput",
        "id",
        "inpNam",
        "inpRef",
        "outNam",
        "outOffDl",
        "outOnDl",
        "outRef",
        "outTyp",
        "vInOff",
        "vInOn"
      ],
      details: {
        debTm: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fastOutput: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inpNam: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inpRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outNam: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outOffDl: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outOnDl: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outTyp: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Normally open", "Normally closed", "Change over"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vInOff: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vInOn: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tWiringParameters",
      validation: {
        enumeration: ["Normally open", "Normally closed", "Change over"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AnalogueWiringParameters: {
    tag: "AnalogueWiringParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "dsgInp", "fctInp", "id", "inpNam", "inpRef"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsgInp: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fctInp: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inpNam: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inpRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tWiringParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LogParameters: {
    tag: "LogParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cbName",
        "desc",
        "dsName",
        "id",
        "intgPd",
        "logEna",
        "logLdInst",
        "logLnClass",
        "logLnInst",
        "logName",
        "logPrefix",
        "reasonCode"
      ],
      details: {
        cbName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logEna: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logLdInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logLnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logLnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logPrefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        reasonCode: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlBlockParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionRef: {
    tag: "FunctionRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a function definition attached to current allocation role

Reference to a function definition attached to current allocation role`,
    parents: ["AllocationRole", "FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "function", "functionUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        function: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef", "SignalRole"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SignalRole: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionRole: {
    tag: "FunctionRole",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Role attached to the application type

Role attached to the application type`,
    parents: ["Application"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cardinality",
        "desc",
        "max",
        "name",
        "originUuid",
        "selector",
        "templateUuid",
        "type",
        "uuid"
      ],
      details: {
        cardinality: {
          required: !1,
          default: "1..1",
          namespace: null,
          validation: {
            enumeration: ["0..1", "1..1", "0..n", "1..n"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 2,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        selector: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef", "FunctionRoleContent"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FunctionRoleContent: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        },
        {
          minOccurrence: 1,
          maxOccurrence: null,
          options: ["FunctionRoleContent"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueRoleContent",
        kind: "unique",
        paths: [["FunctionRoleContent"]],
        deep: !1,
        attributes: ["roleInst"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionalVariant: {
    tag: "FunctionalVariant",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Variant attached to the application type

Variant attached to the application type`,
    parents: ["Application", "FunctionalVariantGroup"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "isBaseline", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        isBaseline: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalSubVariant", "VariableRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalSubVariant: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        VariableRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalSubVariant", "VariableRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tAbstractFunctionalVariant",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionalVariantGroup: {
    tag: "FunctionalVariantGroup",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Group of variants attached to the application type

Group of variants attached to the application type`,
    parents: ["Application"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariant"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariant: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AllocationRoleRef: {
    tag: "AllocationRoleRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Allocation role attached to the application type

Allocation role attached to the application type`,
    parents: ["Application"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["allocationRole", "allocationRoleUuid", "desc"],
      details: {
        allocationRole: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        allocationRoleUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ApplicationSclRef: {
    tag: "ApplicationSclRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to the ASD files used to create an Application

Reference to the ASD files used to create an Application`,
    parents: ["Application"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SclFileReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SclFileReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  InputVar: {
    tag: "InputVar",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Input variable used in the behavior description

Input variable used in the behavior description`,
    parents: ["BehaviorDescription"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "daName",
        "dataName",
        "desc",
        "doName",
        "inputName",
        "inputUuid",
        "lnodeUuid",
        "value",
        "varName"
      ],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inputName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inputUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        varName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tLogicVarRef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  OutputVar: {
    tag: "OutputVar",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Output variable used in the behavior description

Output variable used in the behavior description`,
    parents: ["BehaviorDescription"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "daName",
        "dataName",
        "desc",
        "doName",
        "lnodeUuid",
        "outputName",
        "outputUuid",
        "value",
        "varName"
      ],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outputName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outputUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        varName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tLogicVarRef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BehaviorReference: {
    tag: "BehaviorReference",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a behavior description when for example a manufacturer wants to indicate its implementation of a user specification described by another behavior description

Reference to a behavior description when for example a manufacturer wants to indicate its implementation of a user specification described by another behavior description`,
    parents: ["BehaviorDescription"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["behaviorReference", "behaviorUuid", "desc"],
      details: {
        behaviorReference: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        behaviorUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProjectProcessReference: {
    tag: "ProjectProcessReference",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to the process elements belonging to the current project

Reference to the process elements belonging to the current project`,
    parents: ["Project"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "processReference", "processUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processReference: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNode: {
    tag: "LNode",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [
      "Bay",
      "ConductingEquipment",
      "ConnectivityNode",
      "EqFunction",
      "EqSubFunction",
      "Function",
      "FunctionTemplate",
      "GeneralEquipment",
      "Line",
      "PowerTransformer",
      "Process",
      "SubEquipment",
      "SubFunction",
      "SubFunctionTemplate",
      "Substation",
      "TapChanger",
      "TransformerWinding",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "desc",
        "iedName",
        "ldInst",
        "lnClass",
        "lnInst",
        "lnType",
        "lnUuid",
        "prefix",
        "templateUuid",
        "uuid"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !1,
          default: "None",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "None",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 0,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnType: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLNode",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubFunctionTemplate: {
    tag: "SubFunctionTemplate",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["FunctionTemplate", "SubFunctionTemplate"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "LNode", "GeneralEquipment", "ConductingEquipment", "SubFunctionTemplate"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfSubFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGESubFuncTemplate",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipmentOfSubFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubEquipmentSubFuncTemplate",
              kind: "unique",
              paths: [["SubEquipment"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        SubFunctionTemplate: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubSubFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubSubFuncTemplate",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInSubFunctionTemplate",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInSubFuncTemplate",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "t6-100LNodeContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GeneralEquipment: {
    tag: "GeneralEquipment",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [
      "Bay",
      "EqFunction",
      "EqSubFunction",
      "Function",
      "FunctionTemplate",
      "Line",
      "Process",
      "SubFunction",
      "SubFunctionTemplate",
      "Substation",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["AXN", "BAT", "MOT", "FAN", "FIL", "PMP", "TNK", "VLV"],
            pattern: ["\\i\\c*", "E[A-Z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 3,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "EqFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForGE",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForGE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInGeneralEquipment",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInGE",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipment",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConductingEquipment: {
    tag: "ConductingEquipment",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [
      "Bay",
      "Function",
      "FunctionTemplate",
      "Line",
      "Process",
      "SubFunction",
      "SubFunctionTemplate"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "CBR",
              "DIS",
              "VTR",
              "CTR",
              "GEN",
              "CAP",
              "REA",
              "CON",
              "MOT",
              "EFN",
              "PSH",
              "BAT",
              "BSH",
              "CAB",
              "GIL",
              "LIN",
              "RES",
              "RRC",
              "SAR",
              "TCF",
              "TCR",
              "IFL",
              "FAN",
              "SCR",
              "SMC",
              "PMP"
            ],
            pattern: ["\\i\\c*", "E[A-Z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 3,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "Terminal", "SubEquipment", "EqFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Terminal: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 2
          },
          constraints: null
        },
        SubEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInACESubEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForCE",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForCE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tAbstractConductingEquipment",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Private: {
    tag: "Private",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [
      "AccessPoint",
      "BDA",
      "Bay",
      "Communication",
      "ConductingEquipment",
      "ConnectedAP",
      "ConnectivityNode",
      "DA",
      "DAI",
      "DAType",
      "DO",
      "DOI",
      "DOType",
      "DataSet",
      "EnumType",
      "EqFunction",
      "EqSubFunction",
      "ExtCtrl",
      "ExtRef",
      "Function",
      "GOOSESecurity",
      "GSE",
      "GSEControl",
      "GeneralEquipment",
      "IED",
      "IEDSourceFiles",
      "Inputs",
      "LDevice",
      "LN",
      "LN0",
      "LNode",
      "LNodeType",
      "Labels",
      "Line",
      "Log",
      "LogControl",
      "MinRequestedSCDFiles",
      "NeutralPoint",
      "Outputs",
      "PhysConn",
      "PowerTransformer",
      "Process",
      "ReportControl",
      "RptEnabled",
      "SCL",
      "SDI",
      "SDO",
      "SMV",
      "SMVSecurity",
      "SampledValueControl",
      "SclFileReference",
      "Server",
      "ServerAt",
      "SettingControl",
      "SourceFiles",
      "SubEquipment",
      "SubFunction",
      "SubNetwork",
      "Substation",
      "TapChanger",
      "Terminal",
      "TransformerWinding",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["source", "type"],
      details: {
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tAnyContentFromOtherNamespace",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Header: {
    tag: "Header",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "baseUuid",
        "fileType",
        "id",
        "nameStructure",
        "revision",
        "toolID",
        "uuid",
        "version"
      ],
      details: {
        baseUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["ICD", "IID", "CID", "SSD", "SCD", "SED"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nameStructure: {
          required: !1,
          default: "IEDName",
          namespace: null,
          validation: {
            enumeration: ["IEDName"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        toolID: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: ["Text", "History", "SourceFiles"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        History: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SourceFiles: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueHitem",
        kind: "unique",
        paths: [["History", "Hitem"]],
        deep: !1,
        attributes: ["version", "revision"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: null,
      validation: {
        enumeration: ["IEDName"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PowerTransformer: {
    tag: "PowerTransformer",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Bay", "Substation", "VoltageLevel"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: "PTR",
          namespace: null,
          validation: {
            enumeration: ["PTR"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "TransformerWinding",
        "SubEquipment",
        "EqFunction"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        TransformerWinding: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInTransformerWinding",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTW",
              kind: "unique",
              paths: [["SubEquipment|.", "TapChanger|.", "EqFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        SubEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubEquipmentPTR",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTRSubEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForPTR",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForPTR",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInPowerTransformer",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInPTR",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipment",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  VoltageLevel: {
    tag: "VoltageLevel",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Substation"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "nomFreq", "numPhases", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nomFreq: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: "0",
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        numPhases: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 255,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "PowerTransformer",
        "GeneralEquipment",
        "Voltage",
        "Bay",
        "Function"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        PowerTransformer: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInPowerTransformer",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTR",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        Voltage: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Bay: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueChildNameInBay",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueLNodeInBay",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunctionVL",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInVoltageLevelFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInVoltageLevel",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInVoltageLevel",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Function: {
    tag: "Function",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Bay", "Line", "Process", "Substation", "VoltageLevel"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "SubFunction",
        "GeneralEquipment",
        "ConductingEquipment"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SubFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInSubFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGEFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipmentOfFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInCondEq",
              kind: "unique",
              paths: [["SubEquipment|.", "EqFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInFunctionSS",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInSubstationFunc",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tPowerSystemResource",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Voltage: {
    tag: "Voltage",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Line", "VoltageLevel"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["multiplier", "unit"],
      details: {
        multiplier: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: [
              "",
              "m",
              "k",
              "M",
              "mu",
              "y",
              "z",
              "a",
              "f",
              "p",
              "n",
              "c",
              "d",
              "da",
              "h",
              "G",
              "T",
              "P",
              "E",
              "Z",
              "Y"
            ],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unit: {
          required: !0,
          default: "V",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConnectivityNode: {
    tag: "ConnectivityNode",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Bay", "Line"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "pathName", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pathName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+/.+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tLNodeContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DataSet: {
    tag: "DataSet",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "FCDA"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FCDA: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 1,
          maxOccurrence: null,
          options: ["FCDA"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReportControl: {
    tag: "ReportControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bufTime",
        "buffered",
        "confRev",
        "datSet",
        "desc",
        "indexed",
        "intgPd",
        "name",
        "rptID",
        "templateUuid",
        "uuid"
      ],
      details: {
        bufTime: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        buffered: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        confRev: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        indexed: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rptID: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[ -~]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 129,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "TrgOps", "OptFields", "RptEnabled"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        TrgOps: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        OptFields: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        RptEnabled: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlWithTriggerOpt",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LogControl: {
    tag: "LogControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bufTime",
        "datSet",
        "desc",
        "intgPd",
        "ldInst",
        "lnClass",
        "lnInst",
        "logEna",
        "logName",
        "name",
        "prefix",
        "reasonCode",
        "templateUuid",
        "uuid"
      ],
      details: {
        bufTime: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: "LLN0",
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logEna: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        reasonCode: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "TrgOps"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        TrgOps: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlWithTriggerOpt",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DOI: {
    tag: "DOI",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["accessControl", "desc", "ix", "name"],
      details: {
        accessControl: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 12,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SDI", "DAI", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SDI: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueSDI_DAIinSDI",
              kind: "unique",
              paths: [["DAI|.", "SDI"]],
              deep: !1,
              attributes: ["name", "ix"],
              refer: null,
              text: !1
            }
          ]
        },
        DAI: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelinDOI",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["SDI", "DAI"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueSDI_DAIinDOI",
        kind: "unique",
        paths: [["DAI|.", "SDI"]],
        deep: !1,
        attributes: ["name", "ix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Inputs: {
    tag: "Inputs",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "ExtRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ExtRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Outputs: {
    tag: "Outputs",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "ExtCtrl"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ExtCtrl: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Log: {
    tag: "Log",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSEControl: {
    tag: "GSEControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "appID",
        "confRev",
        "datSet",
        "desc",
        "fixedOffs",
        "name",
        "securityEnable",
        "templateUuid",
        "type",
        "uuid"
      ],
      details: {
        appID: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[ -~]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 129,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        confRev: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fixedOffs: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        securityEnable: {
          required: !1,
          default: "None",
          namespace: null,
          validation: {
            enumeration: ["None", "Signature", "SignatureAndEncryption"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: "GOOSE",
          namespace: null,
          validation: {
            enumeration: ["GSSE", "GOOSE"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "IEDName", "Protocol"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        IEDName: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Protocol: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlWithIEDName",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SampledValueControl: {
    tag: "SampledValueControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "confRev",
        "datSet",
        "desc",
        "multicast",
        "name",
        "nofASDU",
        "securityEnable",
        "smpMod",
        "smpRate",
        "smvID",
        "templateUuid",
        "uuid"
      ],
      details: {
        confRev: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        multicast: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nofASDU: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        securityEnable: {
          required: !1,
          default: "None",
          namespace: null,
          validation: {
            enumeration: ["None", "Signature", "SignatureAndEncryption"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpMod: {
          required: !1,
          default: "SmpPerPeriod",
          namespace: null,
          validation: {
            enumeration: ["SmpPerPeriod", "SmpPerSec", "SecPerSmp"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpRate: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smvID: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[ -~]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 129,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "IEDName", "SmvOpts", "Protocol"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        IEDName: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SmvOpts: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Protocol: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlWithIEDName",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SettingControl: {
    tag: "SettingControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["actSG", "desc", "numOfSGs", "resvTms"],
      details: {
        actSG: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        numOfSGs: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resvTms: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 65535,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Services: {
    tag: "Services",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["AccessPoint", "IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["nameLength"],
      details: {
        nameLength: {
          required: !1,
          default: "32",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["32", "64", "6[5-9]", "[7-9]\\d", "[1-9]\\d\\d+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [
        "DynAssociation",
        "SettingGroups",
        "GetDirectory",
        "GetDataObjectDefinition",
        "DataObjectDirectory",
        "GetDataSetValue",
        "SetDataSetValue",
        "DataSetDirectory",
        "ConfDataSet",
        "DynDataSet",
        "ReadWrite",
        "TimerActivatedControl",
        "ConfReportControl",
        "GetCBValues",
        "ConfLogControl",
        "ReportSettings",
        "LogSettings",
        "GSESettings",
        "SMVSettings",
        "GSEDir",
        "GOOSE",
        "GSSE",
        "SMVsc",
        "FileHandling",
        "ConfLNs",
        "ClientServices",
        "ConfLdName",
        "SupSubscription",
        "ConfSigRef",
        "ValueHandling",
        "RedProt",
        "TimeSyncProt",
        "CommProt",
        "SCSM",
        "Security",
        "MultiAPPerSubNet"
      ],
      details: {
        DynAssociation: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SettingGroups: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GetDirectory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GetDataObjectDefinition: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        DataObjectDirectory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GetDataSetValue: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SetDataSetValue: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        DataSetDirectory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfDataSet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        DynDataSet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReadWrite: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        TimerActivatedControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfReportControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GetCBValues: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfLogControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportSettings: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogSettings: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GSESettings: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVSettings: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GSEDir: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GOOSE: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GSSE: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVsc: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FileHandling: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfLNs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ClientServices: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfLdName: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SupSubscription: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfSigRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ValueHandling: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        RedProt: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        TimeSyncProt: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        CommProt: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SCSM: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Security: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        MultiAPPerSubNet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AccessPoint: {
    tag: "AccessPoint",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["clock", "desc", "kdc", "name", "router", "templateUuid", "uuid"],
      details: {
        clock: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        kdc: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        router: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Server",
        "LN",
        "ServerAt",
        "Services",
        "GOOSESecurity",
        "SMVSecurity",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Server: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueAssociationInServer",
              kind: "unique",
              paths: [["Association"]],
              deep: !1,
              attributes: ["associationID"],
              refer: null,
              text: !1
            }
          ]
        },
        LN: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        },
        ServerAt: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Services: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GOOSESecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 7
          },
          constraints: null
        },
        SMVSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 7
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInAP",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["Server", "LN", "ServerAt"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueLNInAccessPoint",
        kind: "unique",
        paths: [["LN"]],
        deep: !1,
        attributes: ["inst", "lnClass", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  KDC: {
    tag: "KDC",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["apName", "apUuid", "iedName"],
      details: {
        apName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        apUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  IEDSourceFiles: {
    tag: "IEDSourceFiles",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SclFileReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SclFileReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MinRequestedSCDFiles: {
    tag: "MinRequestedSCDFiles",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "MinRequestedSCDFile"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        MinRequestedSCDFile: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueProjectInReqSCD",
        kind: "unique",
        paths: [["MinRequestedSCDFile"]],
        deep: !1,
        attributes: ["fileUuid"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubNetwork: {
    tag: "SubNetwork",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Communication"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["8-MMS", "8-XMPP"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "BitRate", "ConnectedAP"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        BitRate: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConnectedAP: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueGSEinConnectedAP",
              kind: "unique",
              paths: [["GSE"]],
              deep: !1,
              attributes: ["cbName", "ldInst"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSMVinConnectedAP",
              kind: "unique",
              paths: [["SMV"]],
              deep: !1,
              attributes: ["cbName", "ldInst"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueConnectedAP",
        kind: "unique",
        paths: [["ConnectedAP"]],
        deep: !1,
        attributes: ["iedName", "apName"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeType: {
    tag: "LNodeType",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DataTypeTemplates"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "id", "iedType", "lnClass"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedType: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "DO", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DO: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLNType",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueDOInLNodeType",
        kind: "unique",
        paths: [["DO"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tIDNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DOType: {
    tag: "DOType",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DataTypeTemplates"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["cdc", "desc", "id", "iedType"],
      details: {
        cdc: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "SPS",
              "DPS",
              "INS",
              "ENS",
              "ACT",
              "ACD",
              "SEC",
              "BCR",
              "HST",
              "VSS",
              "MV",
              "CMV",
              "SAV",
              "WYE",
              "DEL",
              "SEQ",
              "HMV",
              "HWYE",
              "HDEL",
              "SPC",
              "DPC",
              "INC",
              "ENC",
              "BSC",
              "ISC",
              "APC",
              "BAC",
              "SPG",
              "ING",
              "ENG",
              "ORG",
              "TSG",
              "CUG",
              "VSG",
              "ASG",
              "CURVE",
              "CSG",
              "DPL",
              "LPL",
              "CSD",
              "CST",
              "BTS",
              "UTS",
              "LTS",
              "GTS",
              "MTS",
              "NTS",
              "STS",
              "CTS",
              "OTS",
              "VSD",
              "ORS",
              "TCS"
            ],
            pattern: ["\\i\\c*", "[A-Za-z]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 5,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedType: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SDO", "DA", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SDO: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        DA: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueProtNsInDA",
              kind: "unique",
              paths: [["ProtNs"]],
              deep: !1,
              attributes: ["type"],
              refer: null,
              text: !1
            }
          ]
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDOType",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["SDO", "DA"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueDAorSDOInDOType",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tIDNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DAType: {
    tag: "DAType",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DataTypeTemplates"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "id", "iedType"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedType: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "BDA", "ProtNs", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        BDA: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        },
        ProtNs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDAType",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueBDAInDAType",
        kind: "unique",
        paths: [["BDA"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueProtNs",
        kind: "unique",
        paths: [["ProtNs"]],
        deep: !1,
        attributes: ["type"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tIDNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  EnumType: {
    tag: "EnumType",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DataTypeTemplates"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "EnumVal"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        EnumVal: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: ["[\\p{IsBasicLatin}\\p{IsLatin-1Supplement}]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 127,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueOrdInEnumType",
        kind: "unique",
        paths: [["EnumVal"]],
        deep: !1,
        attributes: ["ord"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueEnumValue",
        kind: "unique",
        paths: [["EnumVal"]],
        deep: !1,
        attributes: [],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tIDNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Resource: {
    tag: "Resource",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `resource bound to this element could be multi

resource bound to this element could be multi`,
    parents: ["ProcessResource"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["resInst", "source", "sourceUuid"],
      details: {
        resInst: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "normalizedString",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GooseParametersRef: {
    tag: "GooseParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the communication parameters expected for the current SourceRef when ServiceType is GOOSE

Specification of the communication parameters expected for the current SourceRef when ServiceType is GOOSE`,
    parents: ["SourceRef", "SubscriberLNode"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVParametersRef: {
    tag: "SMVParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the communication parameters expected for the current SourceRef when ServiceType is SMV

Specification of the communication parameters expected for the current SourceRef when ServiceType is SMV`,
    parents: ["SourceRef", "SubscriberLNode"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReportParametersRef: {
    tag: "ReportParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the communication parameters expected for the current SourceRef when ServiceType is Report

Specification of the communication parameters expected for the current SourceRef when ServiceType is Report`,
    parents: ["SourceRef", "SubscriberLNode"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BinaryWiringParametersRef: {
    tag: "BinaryWiringParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the binary wiring parameters expected for the current SourceRef when ServiceType is Wired

Specification of the binary wiring parameters expected for the current SourceRef when ServiceType is Wired`,
    parents: ["ControlRef", "ControllingLNode", "SourceRef", "SubscriberLNode"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AnalogueWiringParametersRef: {
    tag: "AnalogueWiringParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the analogue wiring parameters expected for the current SourceRef when ServiceType is Wired

Specification of the analogue wiring parameters expected for the current SourceRef when ServiceType is Wired`,
    parents: ["ControlRef", "ControllingLNode", "SourceRef"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Val: {
    tag: "Val",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["BDA", "DA", "DAI", "DAS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["sGroup"],
      details: {
        sGroup: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "normalizedString",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Label: {
    tag: "Label",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Labels"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["id", "lang"],
      details: {
        id: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lang: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "normalizedString",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  L2CommParameters: {
    tag: "L2CommParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["GooseParameters", "SMVParameters"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["appId", "desc", "macAddr", "vlanId", "vlanPriority"],
      details: {
        appId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        macAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanPriority: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-7]"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tCommParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  L3IPv4CommParameters: {
    tag: "L3IPv4CommParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["GooseParameters", "SMVParameters"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["IPv4", "IPv4-IGMPv3Src", "appId", "desc", "vlanId", "vlanPriority"],
      details: {
        IPv4: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        "IPv4-IGMPv3Src": {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        appId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanPriority: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-7]"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tCommParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  L3IPv6CommParameters: {
    tag: "L3IPv6CommParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["GooseParameters", "SMVParameters"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["IPv6", "IPv6-IGMPv3Src", "appId", "desc", "vlanId", "vlanPriority"],
      details: {
        IPv6: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["([0-9a-f]{1,4}:){7}[0-9a-f]{1,4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        "IPv6-IGMPv3Src": {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["([0-9a-f]{1,4}:){7}[0-9a-f]{1,4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        appId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanPriority: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-7]"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tCommParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionalVariantRef: {
    tag: "FunctionalVariantRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Ref to a functional variant of the Application

Ref to a functional variant of the Application`,
    parents: [
      "AllocationRoleRef",
      "BehaviorDescriptionRef",
      "FunctionCategoryRef",
      "FunctionRef",
      "FunctionRole",
      "InputVarRef",
      "LNodeDataRef",
      "LNodeInputRef",
      "LNodeOutputRef",
      "OutputVarRef",
      "PowerSystemRelationRef",
      "ProcessResourceRef",
      "SignalRole",
      "VariableRef"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["functionalVariant", "functionalVariantUuid", "update"],
      details: {
        functionalVariant: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionalVariantUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        update: {
          required: !1,
          default: "add",
          namespace: null,
          validation: {
            enumeration: ["add", "remove"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: ["add", "remove"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SignalRole: {
    tag: "SignalRole",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Signal list attached to the referenced function in the context of the cureent Role definition

Signal list attached to the referenced function in the context of the cureent Role definition`,
    parents: ["FunctionRef"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef", "LNodeInputRef", "LNodeOutputRef", "LNodeDataRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LNodeInputRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LNodeOutputRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LNodeDataRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionRoleContent: {
    tag: "FunctionRoleContent",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `an instance of the current role. In case of application type definition, instance 1 is the default instance

an instance of the current role. In case of application type definition, instance 1 is the default instance`,
    parents: ["FunctionRole"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["roleInst"],
      details: {
        roleInst: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "FunctionRef",
        "BehaviorDescriptionRef",
        "ProcessResourceRef",
        "VariableRef",
        "FunctionCategoryRef",
        "PowerSystemRelationRef"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        BehaviorDescriptionRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessResourceRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        VariableRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionCategoryRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        PowerSystemRelationRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "FunctionRef",
            "BehaviorDescriptionRef",
            "ProcessResourceRef",
            "VariableRef",
            "FunctionCategoryRef",
            "PowerSystemRelationRef"
          ]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionalSubVariant: {
    tag: "FunctionalSubVariant",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Sub variant of the current variant

Sub variant of the current variant`,
    parents: ["FunctionalSubVariant", "FunctionalVariant"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "isBaseline", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        isBaseline: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalSubVariant", "VariableRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalSubVariant: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        VariableRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalSubVariant", "VariableRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tAbstractFunctionalVariant",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  VariableRef: {
    tag: "VariableRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a variable attached to current variant, to parameterize the instance with the value defined in the reference

Reference to a variable attached to current variant, to parameterize the instance with the value defined in the reference`,
    parents: ["FunctionRoleContent", "FunctionalSubVariant", "FunctionalVariant"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "value", "variable", "variableUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        variable: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        variableUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tVariableRef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  EqFunction: {
    tag: "EqFunction",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: [
      "ConductingEquipment",
      "GeneralEquipment",
      "PowerTransformer",
      "SubEquipment",
      "TapChanger",
      "TransformerWinding"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "GeneralEquipment", "EqSubFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfFuncForEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGEFuncForEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqSubFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubFuncForEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubFuncForEquipment",
              kind: "unique",
              paths: [["EqSubFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInFuncForGE",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInFuncForGE",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tAbstractEqFuncSubFunc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Terminal: {
    tag: "Terminal",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ConductingEquipment", "TransformerWinding"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bayName",
        "cNodeName",
        "cNodeUuid",
        "connectivityNode",
        "desc",
        "lineName",
        "name",
        "processName",
        "substationName",
        "voltageLevelName"
      ],
      details: {
        bayName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cNodeName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        connectivityNode: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+/.+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lineName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        substationName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        voltageLevelName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubEquipment: {
    tag: "SubEquipment",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ConductingEquipment", "PowerTransformer", "TapChanger", "TransformerWinding"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "phase", "templateUuid", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        phase: {
          required: !1,
          default: "none",
          namespace: null,
          validation: {
            enumeration: ["A", "B", "C", "N", "all", "none", "AB", "BC", "CA"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "EqFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForSubEq",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForSubEq",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInSubEquipment",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInACESubEquipment",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tPowerSystemResource",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  History: {
    tag: "History",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Header"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: ["Hitem"],
      details: {
        Hitem: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SourceFiles: {
    tag: "SourceFiles",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Header", "Hitem"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SclFileReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SclFileReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TransformerWinding: {
    tag: "TransformerWinding",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["PowerTransformer"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: "PTW",
          namespace: null,
          validation: {
            enumeration: ["PTW"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "Terminal",
        "SubEquipment",
        "TapChanger",
        "NeutralPoint",
        "EqFunction"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Terminal: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 2
          },
          constraints: null
        },
        SubEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInACESubEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        TapChanger: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLNodeInTapChanger",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInLTC",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        NeutralPoint: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForPTW",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForPTW",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInTransformerWinding",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInPTW",
        kind: "unique",
        paths: [["SubEquipment|.", "TapChanger|.", "EqFunction"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tAbstractConductingEquipment",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Bay: {
    tag: "Bay",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["VoltageLevel"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "PowerTransformer",
        "GeneralEquipment",
        "ConductingEquipment",
        "ConnectivityNode",
        "Function"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        PowerTransformer: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInPowerTransformer",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTR",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInCE",
              kind: "unique",
              paths: [["SubEquipment|.", "EqFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConnectivityNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConnectivityNode",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunctionB",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInBayFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInBay",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInBay",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubFunction: {
    tag: "SubFunction",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Function", "SubFunction"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "GeneralEquipment",
        "ConductingEquipment",
        "SubFunction"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfSubFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGESubFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipmentOfSubFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubEquipmentSubFunc",
              kind: "unique",
              paths: [["SubEquipment"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        SubFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubSubFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubSubFunc",
              kind: "unique",
              paths: [["SubFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInSubFunction",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInSubFunc",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tPowerSystemResource",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FCDA: {
    tag: "FCDA",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DataSet"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["daName", "doName", "fc", "ix", "ldInst", "lnClass", "lnInst", "lnUuid", "prefix"],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fc: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "ST",
              "MX",
              "CO",
              "SP",
              "SG",
              "SE",
              "SV",
              "CF",
              "DC",
              "EX",
              "SR",
              "BL",
              "OR"
            ],
            pattern: ["\\i\\c*", "[A-Z]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 2,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TrgOps: {
    tag: "TrgOps",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LogControl", "ReportControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["dchg", "dupd", "gi", "period", "qchg"],
      details: {
        dchg: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dupd: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        gi: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        period: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        qchg: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  OptFields: {
    tag: "OptFields",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ReportControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "bufOvfl",
        "configRef",
        "dataRef",
        "dataSet",
        "entryID",
        "reasonCode",
        "seqNum",
        "timeStamp"
      ],
      details: {
        bufOvfl: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        configRef: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataRef: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataSet: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        entryID: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        reasonCode: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        seqNum: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        timeStamp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  RptEnabled: {
    tag: "RptEnabled",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ReportControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "max"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "ClientLN"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ClientLN: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SDI: {
    tag: "SDI",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DOI", "SDI"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "ix", "name", "sAddr"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SDI", "DAI", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SDI: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        DAI: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelinSDI",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["SDI", "DAI"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueSDI_DAIinSDI",
        kind: "unique",
        paths: [["DAI|.", "SDI"]],
        deep: !1,
        attributes: ["name", "ix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DAI: {
    tag: "DAI",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DOI", "SDI"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "ix", "name", "sAddr", "valImport", "valKind"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valImport: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valKind: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Spec", "Conf", "RO", "Set"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Val", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Val: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelinDAI",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ExtRef: {
    tag: "ExtRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Inputs"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "daName",
        "desc",
        "doName",
        "iedName",
        "intAddr",
        "ldInst",
        "lnClass",
        "lnInst",
        "lnUuid",
        "pDA",
        "pDO",
        "pLN",
        "pServT",
        "prefix",
        "serviceType",
        "srcCBName",
        "srcCBUuid",
        "srcLDInst",
        "srcLNClass",
        "srcLNInst",
        "srcPrefix",
        "templateUuid",
        "uuid"
      ],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "@",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDA: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDO: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pServT: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Poll", "Report", "GOOSE", "SMV"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        serviceType: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Poll", "Report", "GOOSE", "SMV"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcCBName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcCBUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcLDInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcLNClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcLNInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcPrefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tDORef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ExtCtrl: {
    tag: "ExtCtrl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Outputs"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "apRef",
        "checkInterlock",
        "checkSynchrocheck",
        "desc",
        "doName",
        "iedName",
        "intAddr",
        "ldInst",
        "lnClass",
        "lnInst",
        "lnUuid",
        "pDO",
        "pLN",
        "prefix",
        "templateUuid",
        "uuid"
      ],
      details: {
        apRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        checkInterlock: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: ["true", "false", "conserve"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        checkSynchrocheck: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: ["true", "false", "conserve"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "@",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDO: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tDORef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  IEDName: {
    tag: "IEDName",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["GSEControl", "SampledValueControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["apRef", "apUuid", "ldInst", "ldUuid", "lnClass", "lnInst", "lnUuid", "prefix"],
      details: {
        apRef: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        apUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tIEDName",
      validation: {
        enumeration: null,
        pattern: [
          "[A-Za-z][0-9A-Za-z_]{0,2}",
          "[A-Za-z][0-9A-Za-z_]{4,63}",
          "[A-MO-Za-z][0-9A-Za-z_]{3}",
          "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
          "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
          "Non[0-9A-Za-df-z_]",
          "[A-Za-z][0-9A-Za-z_]*",
          "\\i\\c*"
        ],
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: 64,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Protocol: {
    tag: "Protocol",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["GSEControl", "SampledValueControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["mustUnderstand"],
      details: {
        mustUnderstand: {
          required: !0,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "normalizedString",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SmvOpts: {
    tag: "SmvOpts",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SampledValueControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "dataSet",
        "refreshTime",
        "sampleMode",
        "sampleRate",
        "sampleSynchronized",
        "security",
        "synchSourceId",
        "timestamp"
      ],
      details: {
        dataSet: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        refreshTime: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sampleMode: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sampleRate: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sampleSynchronized: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        security: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        synchSourceId: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        timestamp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DynAssociation: {
    tag: "DynAssociation",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max"],
      details: {
        max: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SettingGroups: {
    tag: "SettingGroups",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: ["SGEdit", "ConfSG"],
      details: {
        SGEdit: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfSG: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GetDirectory: {
    tag: "GetDirectory",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GetDataObjectDefinition: {
    tag: "GetDataObjectDefinition",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DataObjectDirectory: {
    tag: "DataObjectDirectory",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GetDataSetValue: {
    tag: "GetDataSetValue",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SetDataSetValue: {
    tag: "SetDataSetValue",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DataSetDirectory: {
    tag: "DataSetDirectory",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfDataSet: {
    tag: "ConfDataSet",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max", "maxAttributes", "modify"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxAttributes: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        modify: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMaxAndMaxAttributes",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DynDataSet: {
    tag: "DynDataSet",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max", "maxAttributes"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxAttributes: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMax",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReadWrite: {
    tag: "ReadWrite",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TimerActivatedControl: {
    tag: "TimerActivatedControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfReportControl: {
    tag: "ConfReportControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["bufConf", "bufMode", "max", "maxBuf"],
      details: {
        bufConf: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        bufMode: {
          required: !1,
          default: "both",
          namespace: null,
          validation: {
            enumeration: ["unbuffered", "buffered", "both"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxBuf: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMax",
      validation: {
        enumeration: ["unbuffered", "buffered", "both"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GetCBValues: {
    tag: "GetCBValues",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfLogControl: {
    tag: "ConfLogControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReportSettings: {
    tag: "ReportSettings",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "bufTime",
        "cbName",
        "datSet",
        "intgPd",
        "optFields",
        "owner",
        "resvTms",
        "rptID",
        "trgOps"
      ],
      details: {
        bufTime: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbName: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        optFields: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        owner: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resvTms: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rptID: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        trgOps: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceSettings",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LogSettings: {
    tag: "LogSettings",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["cbName", "datSet", "intgPd", "logEna", "trgOps"],
      details: {
        cbName: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logEna: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        trgOps: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceSettings",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSESettings: {
    tag: "GSESettings",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["appID", "cbName", "datSet", "dataLabel", "kdaParticipant"],
      details: {
        appID: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbName: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataLabel: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        kdaParticipant: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: ["McSecurity"],
      details: {
        McSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceSettings",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVSettings: {
    tag: "SMVSettings",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cbName",
        "datSet",
        "kdaParticipant",
        "nofASDU",
        "optFields",
        "pdcTimeStamp",
        "samplesPerSec",
        "smpRate",
        "svID",
        "synchSrcId"
      ],
      details: {
        cbName: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        kdaParticipant: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nofASDU: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        optFields: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pdcTimeStamp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        samplesPerSec: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpRate: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        svID: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        synchSrcId: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: ["SmpRate", "SamplesPerSec", "SecPerSamples", "McSecurity"],
      details: {
        SmpRate: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SamplesPerSec: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SecPerSamples: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        McSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 1,
          maxOccurrence: null,
          options: ["SmpRate", "SamplesPerSec", "SecPerSamples"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tServiceSettings",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSEDir: {
    tag: "GSEDir",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GOOSE: {
    tag: "GOOSE",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["fixedOffs", "goose", "max", "rGOOSE"],
      details: {
        fixedOffs: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        goose: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rGOOSE: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMax",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSSE: {
    tag: "GSSE",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVsc: {
    tag: "SMVsc",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["delivery", "deliveryConf", "max", "rSV", "sv"],
      details: {
        delivery: {
          required: !1,
          default: "multicast",
          namespace: null,
          validation: {
            enumeration: ["unicast", "multicast", "both"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        deliveryConf: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rSV: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sv: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMax",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FileHandling: {
    tag: "FileHandling",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["ftp", "ftps", "mms"],
      details: {
        ftp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ftps: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mms: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfLNs: {
    tag: "ConfLNs",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["fixLnInst", "fixPrefix"],
      details: {
        fixLnInst: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fixPrefix: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ClientServices: {
    tag: "ClientServices",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "acceptServerInitiatedAssociation",
        "bufReport",
        "goose",
        "gsse",
        "maxAttributes",
        "maxGOOSE",
        "maxReports",
        "maxSMV",
        "noIctBinding",
        "rGOOSE",
        "rSV",
        "readLog",
        "supportsLdName",
        "sv",
        "unbufReport"
      ],
      details: {
        acceptServerInitiatedAssociation: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        bufReport: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        goose: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        gsse: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxAttributes: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxGOOSE: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxReports: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxSMV: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        noIctBinding: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rGOOSE: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rSV: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        readLog: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        supportsLdName: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sv: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unbufReport: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: ["TimeSyncProt", "GOOSEMcSecurity", "SVMcSecurity", "Security"],
      details: {
        TimeSyncProt: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GOOSEMcSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SVMcSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Security: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfLdName: {
    tag: "ConfLdName",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SupSubscription: {
    tag: "SupSubscription",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["maxGo", "maxSv"],
      details: {
        maxGo: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxSv: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfSigRef: {
    tag: "ConfSigRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ValueHandling: {
    tag: "ValueHandling",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["setToRO"],
      details: {
        setToRO: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  RedProt: {
    tag: "RedProt",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["hsr", "prp", "rstp"],
      details: {
        hsr: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rstp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TimeSyncProt: {
    tag: "TimeSyncProt",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ClientServices", "Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["c37_238", "iec61850_9_3", "other", "sntp"],
      details: {
        c37_238: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iec61850_9_3: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        other: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sntp: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  CommProt: {
    tag: "CommProt",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["ipv6"],
      details: {
        ipv6: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SCSM: {
    tag: "SCSM",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["iec61850_8_1", "iec61850_8_2", "serverAssociationInitiation"],
      details: {
        iec61850_8_1: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iec61850_8_2: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        serverAssociationInitiation: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Security: {
    tag: "Security",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ClientServices", "Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["ACSEAuthentication", "E2ESecurity"],
      details: {
        ACSEAuthentication: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        E2ESecurity: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MultiAPPerSubNet: {
    tag: "MultiAPPerSubNet",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Server: {
    tag: "Server",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["AccessPoint"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "timeout"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        timeout: {
          required: !1,
          default: "30",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Authentication", "LDevice", "Association"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Authentication: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LDevice: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNInLDevice",
              kind: "unique",
              paths: [["LN"]],
              deep: !1,
              attributes: ["inst", "lnClass", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Association: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueAssociationInServer",
        kind: "unique",
        paths: [["Association"]],
        deep: !1,
        attributes: ["associationID"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ServerAt: {
    tag: "ServerAt",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["AccessPoint"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["apName", "apUuid", "desc"],
      details: {
        apName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        apUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GOOSESecurity: {
    tag: "GOOSESecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["AccessPoint"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "serialNumber", "templateUuid", "uuid", "xferNumber"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        serialNumber: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        xferNumber: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "Subject", "IssuerName"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        Subject: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        IssuerName: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVSecurity: {
    tag: "SMVSecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["AccessPoint"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "serialNumber", "templateUuid", "uuid", "xferNumber"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        serialNumber: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        xferNumber: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "Subject", "IssuerName"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        Subject: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        IssuerName: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MinRequestedSCDFile: {
    tag: "MinRequestedSCDFile",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["MinRequestedSCDFiles"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "fileName", "fileType", "fileUuid", "revision", "version", "when"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["SCD", "ICD", "IID", "CID", "SSD", "SED"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tSclFileUUIDReference",
      validation: {
        enumeration: ["SCD"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BitRate: {
    tag: "BitRate",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SubNetwork"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["multiplier", "unit"],
      details: {
        multiplier: {
          required: !1,
          default: "M",
          namespace: null,
          validation: {
            enumeration: [
              "",
              "m",
              "k",
              "M",
              "mu",
              "y",
              "z",
              "a",
              "f",
              "p",
              "n",
              "c",
              "d",
              "da",
              "h",
              "G",
              "T",
              "P",
              "E",
              "Z",
              "Y"
            ],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unit: {
          required: !1,
          default: "b/s",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "decimal",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConnectedAP: {
    tag: "ConnectedAP",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SubNetwork"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["apName", "apUuid", "desc", "iedName", "redProt"],
      details: {
        apName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        apUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        redProt: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["none", "hsr", "prp", "rstp"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Address", "GSE", "SMV", "PhysConn"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Address: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GSE: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SMV: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        PhysConn: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniquePTypeInPhysConn",
              kind: "unique",
              paths: [["P"]],
              deep: !1,
              attributes: ["type"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueGSEinConnectedAP",
        kind: "unique",
        paths: [["GSE"]],
        deep: !1,
        attributes: ["cbName", "ldInst"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueSMVinConnectedAP",
        kind: "unique",
        paths: [["SMV"]],
        deep: !1,
        attributes: ["cbName", "ldInst"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DO: {
    tag: "DO",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LNodeType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["accessControl", "desc", "name", "transient", "type"],
      details: {
        accessControl: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 12,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        transient: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDO",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SDO: {
    tag: "SDO",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DOType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["count", "desc", "name", "type"],
      details: {
        count: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[a-z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[a-z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInSDO",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DA: {
    tag: "DA",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DOType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bType",
        "count",
        "dchg",
        "desc",
        "dupd",
        "fc",
        "name",
        "qchg",
        "sAddr",
        "type",
        "valImport",
        "valKind"
      ],
      details: {
        bType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "BOOLEAN",
              "INT8",
              "INT16",
              "INT24",
              "INT32",
              "INT64",
              "INT128",
              "INT8U",
              "INT16U",
              "INT24U",
              "INT32U",
              "FLOAT32",
              "FLOAT64",
              "Enum",
              "Dbpos",
              "Tcmd",
              "Quality",
              "Timestamp",
              "VisString32",
              "VisString64",
              "VisString65",
              "VisString129",
              "VisString255",
              "Octet64",
              "Unicode255",
              "Struct",
              "EntryTime",
              "Check",
              "ObjRef",
              "Currency",
              "PhyComAddr",
              "TrgOps",
              "OptFlds",
              "SvOptFlds",
              "LogOptFlds",
              "EntryID",
              "Octet6",
              "Octet16"
            ],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        count: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dchg: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dupd: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fc: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "ST",
              "MX",
              "CO",
              "SP",
              "SG",
              "SE",
              "SV",
              "CF",
              "DC",
              "EX",
              "SR",
              "BL",
              "OR"
            ],
            pattern: ["\\i\\c*", "[A-Z]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 2,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        qchg: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valImport: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valKind: {
          required: !1,
          default: "Set",
          namespace: null,
          validation: {
            enumeration: ["Spec", "Conf", "RO", "Set"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Val", "Labels", "ProtNs"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Val: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDA",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        ProtNs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueProtNsInDA",
        kind: "unique",
        paths: [["ProtNs"]],
        deep: !1,
        attributes: ["type"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tAbstractDataAttribute",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BDA: {
    tag: "BDA",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DAType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["bType", "count", "desc", "name", "sAddr", "type", "valImport", "valKind"],
      details: {
        bType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "BOOLEAN",
              "INT8",
              "INT16",
              "INT24",
              "INT32",
              "INT64",
              "INT128",
              "INT8U",
              "INT16U",
              "INT24U",
              "INT32U",
              "FLOAT32",
              "FLOAT64",
              "Enum",
              "Dbpos",
              "Tcmd",
              "Quality",
              "Timestamp",
              "VisString32",
              "VisString64",
              "VisString65",
              "VisString129",
              "VisString255",
              "Octet64",
              "Unicode255",
              "Struct",
              "EntryTime",
              "Check",
              "ObjRef",
              "Currency",
              "PhyComAddr",
              "TrgOps",
              "OptFlds",
              "SvOptFlds",
              "LogOptFlds",
              "EntryID",
              "Octet6",
              "Octet16"
            ],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        count: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valImport: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valKind: {
          required: !1,
          default: "Set",
          namespace: null,
          validation: {
            enumeration: ["Spec", "Conf", "RO", "Set"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Val", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Val: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDA",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tAbstractDataAttribute",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProtNs: {
    tag: "ProtNs",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["DA", "DAType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["type"],
      details: {
        type: {
          required: !1,
          default: "8-MMS",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tNamespaceName",
      validation: {
        enumeration: null,
        pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  EnumVal: {
    tag: "EnumVal",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["EnumType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "ord"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ord: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: -2147483648,
            maxInclusive: 2147483647,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tEnumStringValue",
      validation: {
        enumeration: null,
        pattern: ["[\\p{IsBasicLatin}\\p{IsLatin-1Supplement}]*"],
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: 127,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeInputRef: {
    tag: "LNodeInputRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to SourceRefs belonging to current role

Reference to SourceRefs belonging to current role`,
    parents: ["SignalRole"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "sourceRef", "sourceRefUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceRefUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeOutputRef: {
    tag: "LNodeOutputRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to ControlRefs belonging to current role

Reference to ControlRefs belonging to current role`,
    parents: ["SignalRole"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["controlRef", "controlRefUuid", "desc"],
      details: {
        controlRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        controlRefUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeDataRef: {
    tag: "LNodeDataRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to Data belonging to current role

Reference to Data belonging to current role`,
    parents: ["SignalRole"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["daName", "data", "desc", "doName", "lnodeUuid"],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        data: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BehaviorDescriptionRef: {
    tag: "BehaviorDescriptionRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a behavior description attached to current role

Reference to a behavior description attached to current role`,
    parents: ["FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["behaviorDescription", "behaviorDescriptionUuid", "desc"],
      details: {
        behaviorDescription: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        behaviorDescriptionUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef", "InputVarRef", "OutputVarRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        InputVarRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        OutputVarRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        },
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["InputVarRef", "OutputVarRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProcessResourceRef: {
    tag: "ProcessResourceRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a process resource attached to current role

Reference to a process resource attached to current role`,
    parents: ["FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "processResource", "processResourceUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processResource: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processResourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionCategoryRef: {
    tag: "FunctionCategoryRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a function category attached to current role

Reference to a function category attached to current role`,
    parents: ["FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "functionCategory", "functionCategoryUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionCategory: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionCategoryUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PowerSystemRelationRef: {
    tag: "PowerSystemRelationRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a power system relation attached to current role

Reference to a power system relation attached to current role`,
    parents: ["FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "powerSystemRelation", "powerSystemRelationUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        powerSystemRelation: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        powerSystemRelationUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  EqSubFunction: {
    tag: "EqSubFunction",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["EqFunction", "EqSubFunction"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "GeneralEquipment", "EqSubFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfFuncForEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGEFuncForEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqSubFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubFuncForEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubFuncForEquipment",
              kind: "unique",
              paths: [["EqSubFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInSubFuncForEquipment",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueSubFuncForEquipment",
        kind: "unique",
        paths: [["EqSubFunction"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tAbstractEqFuncSubFunc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Hitem: {
    tag: "Hitem",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["History"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["revision", "version", "what", "when", "who", "why"],
      details: {
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        what: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        who: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        why: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["SourceFiles"],
      details: {
        SourceFiles: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tAnyContentFromOtherNamespace",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TapChanger: {
    tag: "TapChanger",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["TransformerWinding"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: "LTC",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "SubEquipment", "EqFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SubEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubEquipmentLTC",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInLTCSubEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForLTC",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForLTC",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInTapChanger",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInLTC",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tPowerSystemResource",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  NeutralPoint: {
    tag: "NeutralPoint",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["TransformerWinding"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bayName",
        "cNodeName",
        "cNodeUuid",
        "connectivityNode",
        "desc",
        "lineName",
        "name",
        "processName",
        "substationName",
        "voltageLevelName"
      ],
      details: {
        bayName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cNodeName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        connectivityNode: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+/.+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lineName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        substationName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        voltageLevelName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ClientLN: {
    tag: "ClientLN",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["RptEnabled"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["apRef", "desc", "iedName", "ldInst", "lnClass", "lnInst", "lnUuid", "prefix"],
      details: {
        apRef: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 0,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SGEdit: {
    tag: "SGEdit",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SettingGroups"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["resvTms"],
      details: {
        resvTms: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfSG: {
    tag: "ConfSG",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SettingGroups"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["resvTms"],
      details: {
        resvTms: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  McSecurity: {
    tag: "McSecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["GSESettings", "SMVSettings"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["encryption", "signature"],
      details: {
        encryption: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        signature: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SmpRate: {
    tag: "SmpRate",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SMVSettings"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: 0,
        maxInclusive: 4294967295,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SamplesPerSec: {
    tag: "SamplesPerSec",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SMVSettings"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: 0,
        maxInclusive: 4294967295,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SecPerSamples: {
    tag: "SecPerSamples",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["SMVSettings"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: 0,
        maxInclusive: 4294967295,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GOOSEMcSecurity: {
    tag: "GOOSEMcSecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ClientServices"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["encryption", "signature"],
      details: {
        encryption: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        signature: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SVMcSecurity: {
    tag: "SVMcSecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ClientServices"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["encryption", "signature"],
      details: {
        encryption: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        signature: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Authentication: {
    tag: "Authentication",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Server"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["certificate", "none", "password", "strong", "weak"],
      details: {
        certificate: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        none: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        password: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        strong: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        weak: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LDevice: {
    tag: "LDevice",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Server"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "inst", "ldName", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "LN0", "LN", "AccessControl", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LN0: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LN: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        AccessControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLD",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNInLDevice",
        kind: "unique",
        paths: [["LN"]],
        deep: !1,
        attributes: ["inst", "lnClass", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Association: {
    tag: "Association",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Server"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "apRef",
        "associationID",
        "desc",
        "iedName",
        "initiator",
        "kind",
        "ldInst",
        "lnClass",
        "lnInst",
        "lnUuid",
        "prefix"
      ],
      details: {
        apRef: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        associationID: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-Za-z]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        initiator: {
          required: !1,
          default: "client",
          namespace: null,
          validation: {
            enumeration: ["client", "server"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        kind: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["pre-established", "predefined"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 0,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Subject: {
    tag: "Subject",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["GOOSESecurity", "SMVSecurity"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["commonName", "idHierarchy"],
      details: {
        commonName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["none", "CN=.+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 4,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        idHierarchy: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  IssuerName: {
    tag: "IssuerName",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["GOOSESecurity", "SMVSecurity"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["commonName", "idHierarchy"],
      details: {
        commonName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["none", "CN=.+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 4,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        idHierarchy: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Address: {
    tag: "Address",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ConnectedAP", "GSE", "SMV"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: ["P"],
      details: {
        P: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSE: {
    tag: "GSE",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ConnectedAP"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["cbName", "cbUuid", "desc", "ldInst"],
      details: {
        cbName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Address", "MinTime", "MaxTime"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Address: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        MinTime: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        MaxTime: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlBlock",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMV: {
    tag: "SMV",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ConnectedAP"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["cbName", "cbUuid", "desc", "ldInst"],
      details: {
        cbName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Address"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Address: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlBlock",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PhysConn: {
    tag: "PhysConn",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["ConnectedAP"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "type"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Connection", "RedConn"],
            pattern: ["[A-Z][0-9A-Za-z\\-]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "P"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        P: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniquePTypeInPhysConn",
        kind: "unique",
        paths: [["P"]],
        deep: !1,
        attributes: ["type"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  InputVarRef: {
    tag: "InputVarRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to InputVar belonging to current behavior description

Reference to InputVar belonging to current behavior description`,
    parents: ["BehaviorDescriptionRef"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "value", "variable"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        variable: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  OutputVarRef: {
    tag: "OutputVarRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to OutputVar belonging to current behavior description

Reference to OutputVar belonging to current behavior description`,
    parents: ["BehaviorDescriptionRef"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "value", "variable"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        variable: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AccessControl: {
    tag: "AccessControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["LDevice"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tAnyContentFromOtherNamespace",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  P: {
    tag: "P",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["Address", "PhysConn"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["type"],
      details: {
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "IP",
              "IP-SUBNET",
              "IP-GATEWAY",
              "OSI-NSAP",
              "OSI-TSEL",
              "OSI-SSEL",
              "OSI-PSEL",
              "OSI-AP-Title",
              "OSI-AP-Invoke",
              "OSI-AE-Qualifier",
              "OSI-AE-Invoke",
              "MAC-Address",
              "APPID",
              "VLAN-PRIORITY",
              "VLAN-ID",
              "SNTP-Port",
              "MMS-Port",
              "DNSName",
              "IPv6FlowLabel",
              "IPv6ClassOfTraffic",
              "C37-118-IP-Port",
              "IP-UDP-PORT",
              "IP-TCP-PORT",
              "IPv6",
              "IPv6-SUBNET",
              "IPv6-GATEWAY",
              "IPv6-IGMPv3Src",
              "IP-IGMPv3Src",
              "IP-ClassOfTraffic"
            ],
            pattern: ["\\i\\c*", "[A-Z][0-9A-Za-z\\-]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tPAddr",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: 1,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MinTime: {
    tag: "MinTime",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["GSE"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["multiplier", "unit"],
      details: {
        multiplier: {
          required: !1,
          default: "m",
          namespace: null,
          validation: {
            enumeration: [
              "",
              "m",
              "k",
              "M",
              "mu",
              "y",
              "z",
              "a",
              "f",
              "p",
              "n",
              "c",
              "d",
              "da",
              "h",
              "G",
              "T",
              "P",
              "E",
              "Z",
              "Y"
            ],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unit: {
          required: !1,
          default: "s",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "decimal",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MaxTime: {
    tag: "MaxTime",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: ""
    },
    documentation: null,
    parents: ["GSE"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["multiplier", "unit"],
      details: {
        multiplier: {
          required: !1,
          default: "m",
          namespace: null,
          validation: {
            enumeration: [
              "",
              "m",
              "k",
              "M",
              "mu",
              "y",
              "z",
              "a",
              "f",
              "p",
              "n",
              "c",
              "d",
              "da",
              "h",
              "G",
              "T",
              "P",
              "E",
              "Z",
              "Y"
            ],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unit: {
          required: !1,
          default: "s",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "decimal",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  }
}, IL = [
  "AccessControl",
  "AccessPoint",
  "Address",
  "AllocationRole",
  "AllocationRoleRef",
  "AnalogueWiringParameters",
  "AnalogueWiringParametersRef",
  "Application",
  "ApplicationSclRef",
  "Association",
  "Authentication",
  "BDA",
  "Bay",
  "BayType",
  "BehaviorDescription",
  "BehaviorDescriptionRef",
  "BehaviorReference",
  "BinaryWiringParameters",
  "BinaryWiringParametersRef",
  "BitRate",
  "CheckoutID",
  "ClientLN",
  "ClientServices",
  "CommProt",
  "Communication",
  "CommunicationServiceSpecifications",
  "ConductingEquipment",
  "ConfDataSet",
  "ConfLNs",
  "ConfLdName",
  "ConfLogControl",
  "ConfReportControl",
  "ConfSG",
  "ConfSigRef",
  "ConnectedAP",
  "ConnectivityNode",
  "ControlRef",
  "ControllingLNode",
  "DA",
  "DAI",
  "DAS",
  "DAType",
  "DO",
  "DOI",
  "DOS",
  "DOType",
  "DataObjectDirectory",
  "DataSet",
  "DataSetDirectory",
  "DataTypeTemplates",
  "DynAssociation",
  "DynDataSet",
  "EnumType",
  "EnumVal",
  "EqFunction",
  "EqSubFunction",
  "ExtCtrl",
  "ExtRef",
  "FCDA",
  "FileHandling",
  "Function",
  "FunctionCatRef",
  "FunctionCategory",
  "FunctionCategoryRef",
  "FunctionRef",
  "FunctionRole",
  "FunctionRoleContent",
  "FunctionSclRef",
  "FunctionTemplate",
  "FunctionalSubVariant",
  "FunctionalVariant",
  "FunctionalVariantGroup",
  "FunctionalVariantRef",
  "GOOSE",
  "GOOSEMcSecurity",
  "GOOSESecurity",
  "GSE",
  "GSEControl",
  "GSEDir",
  "GSESettings",
  "GSSE",
  "GeneralEquipment",
  "GetCBValues",
  "GetDataObjectDefinition",
  "GetDataSetValue",
  "GetDirectory",
  "GooseParameters",
  "GooseParametersRef",
  "Header",
  "History",
  "Hitem",
  "IED",
  "IEDName",
  "IEDSourceFiles",
  "InputVar",
  "InputVarRef",
  "Inputs",
  "IssuerName",
  "KDC",
  "L2CommParameters",
  "L3IPv4CommParameters",
  "L3IPv6CommParameters",
  "LDevice",
  "LN",
  "LN0",
  "LNode",
  "LNodeDataRef",
  "LNodeInputRef",
  "LNodeInputs",
  "LNodeOutputRef",
  "LNodeOutputs",
  "LNodeSpecNaming",
  "LNodeType",
  "Label",
  "Labels",
  "Line",
  "Log",
  "LogControl",
  "LogParameters",
  "LogParametersRef",
  "LogSettings",
  "MaxTime",
  "McSecurity",
  "MinRequestedSCDFile",
  "MinRequestedSCDFiles",
  "MinTime",
  "MultiAPPerSubNet",
  "NeutralPoint",
  "OptFields",
  "OutputVar",
  "OutputVarRef",
  "Outputs",
  "P",
  "PhysConn",
  "PowerSystemRelation",
  "PowerSystemRelationRef",
  "PowerSystemRelations",
  "PowerTransformer",
  "Private",
  "Process",
  "ProcessEcho",
  "ProcessResource",
  "ProcessResourceRef",
  "ProcessResources",
  "Project",
  "ProjectProcessReference",
  "ProtNs",
  "Protocol",
  "ReadWrite",
  "RedProt",
  "ReportControl",
  "ReportParameters",
  "ReportParametersRef",
  "ReportSettings",
  "Resource",
  "RptEnabled",
  "SCL",
  "SCSM",
  "SDI",
  "SDO",
  "SDS",
  "SGEdit",
  "SMV",
  "SMVParameters",
  "SMVParametersRef",
  "SMVSecurity",
  "SMVSettings",
  "SMVsc",
  "SVMcSecurity",
  "SampledValueControl",
  "SamplesPerSec",
  "SclFileReference",
  "SecPerSamples",
  "Security",
  "Server",
  "ServerAt",
  "ServiceSpecifications",
  "Services",
  "SetDataSetValue",
  "SettingControl",
  "SettingGroups",
  "SignalRole",
  "SmpRate",
  "SmvOpts",
  "SourceFiles",
  "SourceRef",
  "SubCategory",
  "SubCheckoutID",
  "SubEquipment",
  "SubFunction",
  "SubFunctionTemplate",
  "SubNetwork",
  "Subject",
  "SubscriberLNode",
  "Substation",
  "SupSubscription",
  "TapChanger",
  "Terminal",
  "Text",
  "TimeSyncProt",
  "TimerActivatedControl",
  "TransformerWinding",
  "TrgOps",
  "Val",
  "ValueHandling",
  "Variable",
  "VariableApplyTo",
  "VariableRef",
  "Voltage",
  "VoltageLevel"
], LL = {
  AccessControl: [],
  AccessPoint: ["name"],
  Address: [],
  AllocationRole: ["name"],
  AllocationRoleRef: [],
  AnalogueWiringParameters: ["id"],
  AnalogueWiringParametersRef: ["id"],
  Application: ["name"],
  ApplicationSclRef: [],
  Association: ["apRef", "iedName", "kind", "ldInst", "lnClass", "lnInst"],
  Authentication: [],
  BDA: ["bType", "name"],
  Bay: ["name"],
  BayType: [],
  BehaviorDescription: ["name"],
  BehaviorDescriptionRef: [],
  BehaviorReference: [],
  BinaryWiringParameters: ["id"],
  BinaryWiringParametersRef: ["id"],
  BitRate: [],
  CheckoutID: ["fileType", "revision", "version"],
  ClientLN: ["apRef", "iedName", "ldInst", "lnClass", "lnInst"],
  ClientServices: [],
  CommProt: [],
  Communication: [],
  CommunicationServiceSpecifications: [],
  ConductingEquipment: ["name", "type"],
  ConfDataSet: ["max"],
  ConfLNs: [],
  ConfLdName: [],
  ConfLogControl: ["max"],
  ConfReportControl: ["max"],
  ConfSG: [],
  ConfSigRef: ["max"],
  ConnectedAP: ["apName", "iedName"],
  ConnectivityNode: ["name", "pathName"],
  ControlRef: ["output"],
  ControllingLNode: ["outputName"],
  DA: ["bType", "fc", "name"],
  DAI: ["name"],
  DAS: ["name"],
  DAType: ["id"],
  DO: ["name", "type"],
  DOI: ["name"],
  DOS: ["name"],
  DOType: ["cdc", "id"],
  DataObjectDirectory: [],
  DataSet: ["name"],
  DataSetDirectory: [],
  DataTypeTemplates: [],
  DynAssociation: [],
  DynDataSet: ["max"],
  EnumType: ["id"],
  EnumVal: ["ord"],
  EqFunction: ["name"],
  EqSubFunction: ["name"],
  ExtCtrl: [],
  ExtRef: [],
  FCDA: ["fc"],
  FileHandling: [],
  Function: ["name"],
  FunctionCatRef: [],
  FunctionCategory: ["name"],
  FunctionCategoryRef: [],
  FunctionRef: [],
  FunctionRole: ["name"],
  FunctionRoleContent: [],
  FunctionSclRef: [],
  FunctionTemplate: ["name"],
  FunctionalSubVariant: ["name"],
  FunctionalVariant: ["name"],
  FunctionalVariantGroup: ["name"],
  FunctionalVariantRef: [],
  GOOSE: ["max"],
  GOOSEMcSecurity: [],
  GOOSESecurity: ["name", "serialNumber"],
  GSE: ["cbName", "ldInst"],
  GSEControl: ["appID", "name"],
  GSEDir: [],
  GSESettings: [],
  GSSE: ["max"],
  GeneralEquipment: ["name", "type"],
  GetCBValues: [],
  GetDataObjectDefinition: [],
  GetDataSetValue: [],
  GetDirectory: [],
  GooseParameters: ["id"],
  GooseParametersRef: ["id"],
  Header: ["id", "uuid"],
  History: [],
  Hitem: ["revision", "version", "when"],
  IED: ["name"],
  IEDName: ["apRef"],
  IEDSourceFiles: [],
  InputVar: ["varName"],
  InputVarRef: [],
  Inputs: [],
  IssuerName: ["commonName", "idHierarchy"],
  KDC: ["apName", "iedName"],
  L2CommParameters: [],
  L3IPv4CommParameters: [],
  L3IPv6CommParameters: [],
  LDevice: ["inst"],
  LN: ["inst", "lnClass", "lnType"],
  LN0: ["inst", "lnClass", "lnType"],
  LNode: ["lnClass"],
  LNodeDataRef: [],
  LNodeInputRef: [],
  LNodeInputs: [],
  LNodeOutputRef: [],
  LNodeOutputs: [],
  LNodeSpecNaming: [],
  LNodeType: ["id", "lnClass"],
  Label: ["lang"],
  Labels: [],
  Line: ["name"],
  Log: [],
  LogControl: ["logName", "name"],
  LogParameters: ["id"],
  LogParametersRef: ["id"],
  LogSettings: [],
  MaxTime: [],
  McSecurity: [],
  MinRequestedSCDFile: ["fileType", "revision", "version"],
  MinRequestedSCDFiles: [],
  MinTime: [],
  MultiAPPerSubNet: [],
  NeutralPoint: ["cNodeName", "connectivityNode"],
  OptFields: [],
  OutputVar: ["varName"],
  OutputVarRef: [],
  Outputs: [],
  P: ["type"],
  PhysConn: ["type"],
  PowerSystemRelation: ["name"],
  PowerSystemRelationRef: [],
  PowerSystemRelations: [],
  PowerTransformer: ["name", "type"],
  Private: ["type"],
  Process: ["name"],
  ProcessEcho: [],
  ProcessResource: ["name"],
  ProcessResourceRef: [],
  ProcessResources: [],
  Project: ["name"],
  ProjectProcessReference: [],
  ProtNs: [],
  Protocol: ["mustUnderstand"],
  ReadWrite: [],
  RedProt: [],
  ReportControl: ["confRev", "name"],
  ReportParameters: ["id"],
  ReportParametersRef: ["id"],
  ReportSettings: [],
  Resource: [],
  RptEnabled: [],
  SCL: ["release", "revision", "version"],
  SCSM: [],
  SDI: ["name"],
  SDO: ["name", "type"],
  SDS: ["name"],
  SGEdit: [],
  SMV: ["cbName", "ldInst"],
  SMVParameters: ["id"],
  SMVParametersRef: ["id"],
  SMVSecurity: ["name", "serialNumber"],
  SMVSettings: [],
  SMVsc: ["max"],
  SVMcSecurity: [],
  SampledValueControl: ["name", "nofASDU", "smpRate", "smvID"],
  SamplesPerSec: [],
  SclFileReference: ["fileType", "revision", "version"],
  SecPerSamples: [],
  Security: [],
  Server: [],
  ServerAt: ["apName"],
  ServiceSpecifications: [],
  Services: [],
  SetDataSetValue: [],
  SettingControl: ["numOfSGs"],
  SettingGroups: [],
  SignalRole: ["name"],
  SmpRate: [],
  SmvOpts: [],
  SourceFiles: [],
  SourceRef: ["input"],
  SubCategory: ["name"],
  SubCheckoutID: ["fileType", "revision", "version"],
  SubEquipment: ["name"],
  SubFunction: ["name"],
  SubFunctionTemplate: ["name"],
  SubNetwork: ["name"],
  Subject: ["commonName", "idHierarchy"],
  SubscriberLNode: ["inputName"],
  Substation: ["name"],
  SupSubscription: ["maxGo", "maxSv"],
  TapChanger: ["name", "type"],
  Terminal: ["cNodeName", "connectivityNode"],
  Text: [],
  TimeSyncProt: [],
  TimerActivatedControl: [],
  TransformerWinding: ["name", "type"],
  TrgOps: [],
  Val: [],
  ValueHandling: [],
  Variable: ["name"],
  VariableApplyTo: [],
  VariableRef: [],
  Voltage: ["unit"],
  VoltageLevel: ["name"]
}, DL = {
  AccessControl: {},
  AccessPoint: {
    clock: "",
    desc: "",
    kdc: "",
    name: "",
    router: "",
    templateUuid: "",
    uuid: ""
  },
  Address: {},
  AllocationRole: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  AllocationRoleRef: {
    allocationRole: "",
    allocationRoleUuid: "",
    desc: ""
  },
  AnalogueWiringParameters: {
    desc: "",
    dsgInp: "",
    fctInp: "",
    id: "",
    inpNam: "",
    inpRef: ""
  },
  AnalogueWiringParametersRef: {
    desc: "",
    id: ""
  },
  Application: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  ApplicationSclRef: {},
  Association: {
    apRef: "",
    associationID: "",
    desc: "",
    iedName: "",
    initiator: "",
    kind: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    prefix: ""
  },
  Authentication: {
    certificate: "",
    none: "",
    password: "",
    strong: "",
    weak: ""
  },
  BDA: {
    bType: "",
    count: "",
    desc: "",
    name: "",
    sAddr: "",
    type: "",
    valImport: "",
    valKind: ""
  },
  Bay: {
    desc: "",
    name: "",
    templateUuid: "",
    uuid: ""
  },
  BayType: {},
  BehaviorDescription: {
    desc: "",
    fileReference: "",
    format: "",
    isSimulation: "",
    isSpecification: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  BehaviorDescriptionRef: {
    behaviorDescription: "",
    behaviorDescriptionUuid: "",
    desc: ""
  },
  BehaviorReference: {
    behaviorReference: "",
    behaviorUuid: "",
    desc: ""
  },
  BinaryWiringParameters: {
    debTm: "",
    desc: "",
    fastOutput: "",
    id: "",
    inpNam: "",
    inpRef: "",
    outNam: "",
    outOffDl: "",
    outOnDl: "",
    outRef: "",
    outTyp: "",
    vInOff: "",
    vInOn: ""
  },
  BinaryWiringParametersRef: {
    desc: "",
    id: ""
  },
  BitRate: { multiplier: "", unit: "" },
  CheckoutID: {
    desc: "",
    engRight: "",
    fileName: "",
    fileType: "",
    fileUuid: "",
    headerId: "",
    revision: "",
    version: "",
    when: ""
  },
  ClientLN: {
    apRef: "",
    desc: "",
    iedName: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    prefix: ""
  },
  ClientServices: {
    acceptServerInitiatedAssociation: "",
    bufReport: "",
    goose: "",
    gsse: "",
    maxAttributes: "",
    maxGOOSE: "",
    maxReports: "",
    maxSMV: "",
    noIctBinding: "",
    rGOOSE: "",
    rSV: "",
    readLog: "",
    supportsLdName: "",
    sv: "",
    unbufReport: ""
  },
  CommProt: { ipv6: "" },
  Communication: { desc: "" },
  CommunicationServiceSpecifications: {
    desc: ""
  },
  ConductingEquipment: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  ConfDataSet: {
    max: "",
    maxAttributes: "",
    modify: ""
  },
  ConfLNs: { fixLnInst: "", fixPrefix: "" },
  ConfLdName: {},
  ConfLogControl: { max: "" },
  ConfReportControl: {
    bufConf: "",
    bufMode: "",
    max: "",
    maxBuf: ""
  },
  ConfSG: { resvTms: "" },
  ConfSigRef: { max: "" },
  ConnectedAP: {
    apName: "",
    apUuid: "",
    desc: "",
    iedName: "",
    redProt: ""
  },
  ConnectivityNode: {
    desc: "",
    name: "",
    pathName: "",
    templateUuid: "",
    uuid: ""
  },
  ControlRef: {
    controlled: "",
    controlledDoName: "",
    controlledLNodeUuid: "",
    desc: "",
    extCtrlAddr: "",
    extCtrlUuid: "",
    originUuid: "",
    output: "",
    outputInst: "",
    pDO: "",
    pLN: "",
    resourceName: "",
    resourceUuid: "",
    templateUuid: "",
    uuid: ""
  },
  ControllingLNode: {
    desc: "",
    outputName: "",
    pLN: "",
    resourceName: "",
    resourceUuid: ""
  },
  DA: {
    bType: "",
    count: "",
    dchg: "",
    desc: "",
    dupd: "",
    fc: "",
    name: "",
    qchg: "",
    sAddr: "",
    type: "",
    valImport: "",
    valKind: ""
  },
  DAI: {
    desc: "",
    ix: "",
    name: "",
    sAddr: "",
    valImport: "",
    valKind: ""
  },
  DAS: {
    desc: "",
    ix: "",
    mappedDaName: "",
    mappedLnUuid: "",
    name: "",
    valImport: "",
    valKind: ""
  },
  DAType: { desc: "", id: "", iedType: "" },
  DO: {
    accessControl: "",
    desc: "",
    name: "",
    transient: "",
    type: ""
  },
  DOI: {
    accessControl: "",
    desc: "",
    ix: "",
    name: ""
  },
  DOS: {
    desc: "",
    mappedDoName: "",
    mappedLnUuid: "",
    name: ""
  },
  DOType: {
    cdc: "",
    desc: "",
    id: "",
    iedType: ""
  },
  DataObjectDirectory: {},
  DataSet: {
    desc: "",
    name: "",
    templateUuid: "",
    uuid: ""
  },
  DataSetDirectory: {},
  DataTypeTemplates: {},
  DynAssociation: { max: "" },
  DynDataSet: { max: "", maxAttributes: "" },
  EnumType: { desc: "", id: "" },
  EnumVal: { desc: "", ord: "" },
  EqFunction: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  EqSubFunction: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  ExtCtrl: {
    apRef: "",
    checkInterlock: "",
    checkSynchrocheck: "",
    desc: "",
    doName: "",
    iedName: "",
    intAddr: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    pDO: "",
    pLN: "",
    prefix: "",
    templateUuid: "",
    uuid: ""
  },
  ExtRef: {
    daName: "",
    desc: "",
    doName: "",
    iedName: "",
    intAddr: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    pDA: "",
    pDO: "",
    pLN: "",
    pServT: "",
    prefix: "",
    serviceType: "",
    srcCBName: "",
    srcCBUuid: "",
    srcLDInst: "",
    srcLNClass: "",
    srcLNInst: "",
    srcPrefix: "",
    templateUuid: "",
    uuid: ""
  },
  FCDA: {
    daName: "",
    doName: "",
    fc: "",
    ix: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    prefix: ""
  },
  FileHandling: {
    ftp: "",
    ftps: "",
    mms: ""
  },
  Function: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  FunctionCatRef: {
    function: "",
    functionUuid: ""
  },
  FunctionCategory: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  FunctionCategoryRef: {
    desc: "",
    functionCategory: "",
    functionCategoryUuid: ""
  },
  FunctionRef: {
    desc: "",
    function: "",
    functionUuid: ""
  },
  FunctionRole: {
    cardinality: "",
    desc: "",
    max: "",
    name: "",
    originUuid: "",
    selector: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  FunctionRoleContent: { roleInst: "" },
  FunctionSclRef: {},
  FunctionTemplate: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  FunctionalSubVariant: {
    desc: "",
    isBaseline: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  FunctionalVariant: {
    desc: "",
    isBaseline: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  FunctionalVariantGroup: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  FunctionalVariantRef: {
    functionalVariant: "",
    functionalVariantUuid: "",
    update: ""
  },
  GOOSE: {
    fixedOffs: "",
    goose: "",
    max: "",
    rGOOSE: ""
  },
  GOOSEMcSecurity: {
    encryption: "",
    signature: ""
  },
  GOOSESecurity: {
    desc: "",
    name: "",
    serialNumber: "",
    templateUuid: "",
    uuid: "",
    xferNumber: ""
  },
  GSE: {
    cbName: "",
    cbUuid: "",
    desc: "",
    ldInst: ""
  },
  GSEControl: {
    appID: "",
    confRev: "",
    datSet: "",
    desc: "",
    fixedOffs: "",
    name: "",
    securityEnable: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  GSEDir: {},
  GSESettings: {
    appID: "",
    cbName: "",
    datSet: "",
    dataLabel: "",
    kdaParticipant: ""
  },
  GSSE: { max: "" },
  GeneralEquipment: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  GetCBValues: {},
  GetDataObjectDefinition: {},
  GetDataSetValue: {},
  GetDirectory: {},
  GooseParameters: {
    cbName: "",
    desc: "",
    dsName: "",
    goId: "",
    id: "",
    maxTime: "",
    minTime: "",
    securityEnabled: ""
  },
  GooseParametersRef: {
    desc: "",
    id: ""
  },
  Header: {
    baseUuid: "",
    fileType: "",
    id: "",
    nameStructure: "",
    revision: "",
    toolID: "",
    uuid: "",
    version: ""
  },
  History: {},
  Hitem: {
    revision: "",
    version: "",
    what: "",
    when: "",
    who: "",
    why: ""
  },
  IED: {
    configVersion: "",
    desc: "",
    engRight: "",
    manufacturer: "",
    name: "",
    originalSclRelease: "",
    originalSclRevision: "",
    originalSclVersion: "",
    owner: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  IEDName: {
    apRef: "",
    apUuid: "",
    ldInst: "",
    ldUuid: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    prefix: ""
  },
  IEDSourceFiles: {},
  InputVar: {
    daName: "",
    dataName: "",
    desc: "",
    doName: "",
    inputName: "",
    inputUuid: "",
    lnodeUuid: "",
    value: "",
    varName: ""
  },
  InputVarRef: {
    desc: "",
    value: "",
    variable: ""
  },
  Inputs: { desc: "" },
  IssuerName: { commonName: "", idHierarchy: "" },
  KDC: { apName: "", apUuid: "", iedName: "" },
  L2CommParameters: {
    appId: "",
    desc: "",
    macAddr: "",
    vlanId: "",
    vlanPriority: ""
  },
  L3IPv4CommParameters: {
    IPv4: "",
    "IPv4-IGMPv3Src": "",
    appId: "",
    desc: "",
    vlanId: "",
    vlanPriority: ""
  },
  L3IPv6CommParameters: {
    IPv6: "",
    "IPv6-IGMPv3Src": "",
    appId: "",
    desc: "",
    vlanId: "",
    vlanPriority: ""
  },
  LDevice: {
    desc: "",
    inst: "",
    ldName: "",
    templateUuid: "",
    uuid: ""
  },
  LN: {
    desc: "",
    inst: "",
    lnClass: "",
    lnType: "",
    prefix: "",
    templateUuid: "",
    uuid: ""
  },
  LN0: {
    desc: "",
    inst: "",
    lnClass: "",
    lnType: "",
    templateUuid: "",
    uuid: ""
  },
  LNode: {
    desc: "",
    iedName: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnType: "",
    lnUuid: "",
    prefix: "",
    templateUuid: "",
    uuid: ""
  },
  LNodeDataRef: {
    daName: "",
    data: "",
    desc: "",
    doName: "",
    lnodeUuid: ""
  },
  LNodeInputRef: {
    desc: "",
    sourceRef: "",
    sourceRefUuid: ""
  },
  LNodeInputs: { desc: "" },
  LNodeOutputRef: {
    controlRef: "",
    controlRefUuid: "",
    desc: ""
  },
  LNodeOutputs: { desc: "" },
  LNodeSpecNaming: {
    sIedName: "",
    sLdInst: "",
    sLnClass: "",
    sLnInst: "",
    sPrefix: ""
  },
  LNodeType: {
    desc: "",
    id: "",
    iedType: "",
    lnClass: ""
  },
  Label: { id: "", lang: "" },
  Labels: { desc: "" },
  Line: {
    desc: "",
    name: "",
    nomFreq: "",
    numPhases: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  Log: { desc: "", name: "" },
  LogControl: {
    bufTime: "",
    datSet: "",
    desc: "",
    intgPd: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    logEna: "",
    logName: "",
    name: "",
    prefix: "",
    reasonCode: "",
    templateUuid: "",
    uuid: ""
  },
  LogParameters: {
    cbName: "",
    desc: "",
    dsName: "",
    id: "",
    intgPd: "",
    logEna: "",
    logLdInst: "",
    logLnClass: "",
    logLnInst: "",
    logName: "",
    logPrefix: "",
    reasonCode: ""
  },
  LogParametersRef: { desc: "", id: "" },
  LogSettings: {
    cbName: "",
    datSet: "",
    intgPd: "",
    logEna: "",
    trgOps: ""
  },
  MaxTime: { multiplier: "", unit: "" },
  McSecurity: { encryption: "", signature: "" },
  MinRequestedSCDFile: {
    desc: "",
    fileName: "",
    fileType: "",
    fileUuid: "",
    revision: "",
    version: "",
    when: ""
  },
  MinRequestedSCDFiles: {},
  MinTime: { multiplier: "", unit: "" },
  MultiAPPerSubNet: {},
  NeutralPoint: {
    bayName: "",
    cNodeName: "",
    cNodeUuid: "",
    connectivityNode: "",
    desc: "",
    lineName: "",
    name: "",
    processName: "",
    substationName: "",
    voltageLevelName: ""
  },
  OptFields: {
    bufOvfl: "",
    configRef: "",
    dataRef: "",
    dataSet: "",
    entryID: "",
    reasonCode: "",
    seqNum: "",
    timeStamp: ""
  },
  OutputVar: {
    daName: "",
    dataName: "",
    desc: "",
    doName: "",
    lnodeUuid: "",
    outputName: "",
    outputUuid: "",
    value: "",
    varName: ""
  },
  OutputVarRef: {
    desc: "",
    value: "",
    variable: ""
  },
  Outputs: { desc: "" },
  P: { type: "" },
  PhysConn: { desc: "", type: "" },
  PowerSystemRelation: {
    desc: "",
    name: "",
    originUuid: "",
    relation: "",
    relationUuid: "",
    selector: "",
    templateUuid: "",
    uuid: ""
  },
  PowerSystemRelationRef: {
    desc: "",
    powerSystemRelation: "",
    powerSystemRelationUuid: ""
  },
  PowerSystemRelations: { desc: "" },
  PowerTransformer: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  Private: { source: "", type: "" },
  Process: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  ProcessEcho: {
    desc: "",
    source: "",
    sourceDaName: "",
    sourceDoName: "",
    sourceLNodeUuid: ""
  },
  ProcessResource: {
    cardinality: "",
    desc: "",
    max: "",
    name: "",
    originUuid: "",
    selector: "",
    templateUuid: "",
    uuid: ""
  },
  ProcessResourceRef: {
    desc: "",
    processResource: "",
    processResourceUuid: ""
  },
  ProcessResources: { desc: "" },
  Project: {
    desc: "",
    name: "",
    uuid: ""
  },
  ProjectProcessReference: {
    desc: "",
    processReference: "",
    processUuid: ""
  },
  ProtNs: { type: "" },
  Protocol: { mustUnderstand: "" },
  ReadWrite: {},
  RedProt: { hsr: "", prp: "", rstp: "" },
  ReportControl: {
    bufTime: "",
    buffered: "",
    confRev: "",
    datSet: "",
    desc: "",
    indexed: "",
    intgPd: "",
    name: "",
    rptID: "",
    templateUuid: "",
    uuid: ""
  },
  ReportParameters: {
    bufTime: "",
    buffered: "",
    cbName: "",
    desc: "",
    dsName: "",
    id: "",
    intgPd: ""
  },
  ReportParametersRef: {
    desc: "",
    id: ""
  },
  ReportSettings: {
    bufTime: "",
    cbName: "",
    datSet: "",
    intgPd: "",
    optFields: "",
    owner: "",
    resvTms: "",
    rptID: "",
    trgOps: ""
  },
  Resource: {
    resInst: "",
    source: "",
    sourceUuid: ""
  },
  RptEnabled: { desc: "", max: "" },
  SCL: {
    release: "",
    revision: "",
    version: ""
  },
  SCSM: {
    iec61850_8_1: "",
    iec61850_8_2: "",
    serverAssociationInitiation: ""
  },
  SDI: {
    desc: "",
    ix: "",
    name: "",
    sAddr: ""
  },
  SDO: {
    count: "",
    desc: "",
    name: "",
    type: ""
  },
  SDS: {
    desc: "",
    ix: "",
    mappedDoName: "",
    mappedLnUuid: "",
    name: ""
  },
  SGEdit: { resvTms: "" },
  SMV: {
    cbName: "",
    cbUuid: "",
    desc: "",
    ldInst: ""
  },
  SMVParameters: {
    cbName: "",
    desc: "",
    dsName: "",
    id: "",
    multicast: "",
    nofASDU: "",
    securityEnabled: "",
    smpMod: "",
    smpRate: "",
    smvId: ""
  },
  SMVParametersRef: { desc: "", id: "" },
  SMVSecurity: {
    desc: "",
    name: "",
    serialNumber: "",
    templateUuid: "",
    uuid: "",
    xferNumber: ""
  },
  SMVSettings: {
    cbName: "",
    datSet: "",
    kdaParticipant: "",
    nofASDU: "",
    optFields: "",
    pdcTimeStamp: "",
    samplesPerSec: "",
    smpRate: "",
    svID: "",
    synchSrcId: ""
  },
  SMVsc: {
    delivery: "",
    deliveryConf: "",
    max: "",
    rSV: "",
    sv: ""
  },
  SVMcSecurity: {
    encryption: "",
    signature: ""
  },
  SampledValueControl: {
    confRev: "",
    datSet: "",
    desc: "",
    multicast: "",
    name: "",
    nofASDU: "",
    securityEnable: "",
    smpMod: "",
    smpRate: "",
    smvID: "",
    templateUuid: "",
    uuid: ""
  },
  SamplesPerSec: {},
  SclFileReference: {
    desc: "",
    fileName: "",
    fileType: "",
    fileUuid: "",
    revision: "",
    version: "",
    when: ""
  },
  SecPerSamples: {},
  Security: {
    ACSEAuthentication: "",
    E2ESecurity: ""
  },
  Server: { desc: "", timeout: "" },
  ServerAt: {
    apName: "",
    apUuid: "",
    desc: ""
  },
  ServiceSpecifications: { desc: "" },
  Services: { nameLength: "" },
  SetDataSetValue: {},
  SettingControl: {
    actSG: "",
    desc: "",
    numOfSGs: "",
    resvTms: ""
  },
  SettingGroups: {},
  SignalRole: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  SmpRate: {},
  SmvOpts: {
    dataSet: "",
    refreshTime: "",
    sampleMode: "",
    sampleRate: "",
    sampleSynchronized: "",
    security: "",
    synchSourceId: "",
    timestamp: ""
  },
  SourceFiles: {},
  SourceRef: {
    desc: "",
    extRefAddr: "",
    extRefUuid: "",
    input: "",
    inputInst: "",
    originUuid: "",
    pDA: "",
    pDO: "",
    pLN: "",
    resourceName: "",
    resourceUuid: "",
    service: "",
    source: "",
    sourceDaName: "",
    sourceDoName: "",
    sourceLNodeUuid: "",
    templateUuid: "",
    uuid: ""
  },
  SubCategory: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  SubCheckoutID: {
    desc: "",
    engRight: "",
    fileName: "",
    fileType: "",
    fileUuid: "",
    headerId: "",
    revision: "",
    version: "",
    when: ""
  },
  SubEquipment: {
    desc: "",
    name: "",
    phase: "",
    templateUuid: "",
    uuid: "",
    virtual: ""
  },
  SubFunction: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  SubFunctionTemplate: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  SubNetwork: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  Subject: { commonName: "", idHierarchy: "" },
  SubscriberLNode: {
    desc: "",
    inputName: "",
    pLN: "",
    resourceName: "",
    resourceUuid: "",
    service: ""
  },
  Substation: {
    desc: "",
    name: "",
    templateUuid: "",
    uuid: ""
  },
  SupSubscription: { maxGo: "", maxSv: "" },
  TapChanger: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  Terminal: {
    bayName: "",
    cNodeName: "",
    cNodeUuid: "",
    connectivityNode: "",
    desc: "",
    lineName: "",
    name: "",
    processName: "",
    substationName: "",
    voltageLevelName: ""
  },
  Text: { source: "" },
  TimeSyncProt: {
    c37_238: "",
    iec61850_9_3: "",
    other: "",
    sntp: ""
  },
  TimerActivatedControl: {},
  TransformerWinding: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  TrgOps: {
    dchg: "",
    dupd: "",
    gi: "",
    period: "",
    qchg: ""
  },
  Val: { sGroup: "" },
  ValueHandling: { setToRO: "" },
  Variable: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: "",
    value: ""
  },
  VariableApplyTo: {
    attribute: "",
    daName: "",
    defaultValue: "",
    desc: "",
    doName: "",
    element: "",
    elementUuid: "",
    format: "",
    sGroup: ""
  },
  VariableRef: {
    desc: "",
    value: "",
    variable: "",
    variableUuid: ""
  },
  Voltage: { multiplier: "", unit: "" },
  VoltageLevel: {
    desc: "",
    name: "",
    nomFreq: "",
    numPhases: "",
    templateUuid: "",
    uuid: ""
  }
}, OL = {
  AccessControl: [],
  AccessPoint: [
    "Text",
    "Private",
    "Server",
    "LN",
    "ServerAt",
    "Services",
    "GOOSESecurity",
    "SMVSecurity",
    "Labels"
  ],
  Address: ["P"],
  AllocationRole: ["Text", "FunctionRef"],
  AllocationRoleRef: ["Text", "FunctionalVariantRef"],
  AnalogueWiringParameters: ["Text"],
  AnalogueWiringParametersRef: ["Text"],
  Application: [
    "Text",
    "FunctionRole",
    "FunctionalVariant",
    "FunctionalVariantGroup",
    "AllocationRoleRef",
    "ApplicationSclRef"
  ],
  ApplicationSclRef: ["Text", "SclFileReference"],
  Association: [],
  Authentication: [],
  BDA: ["Text", "Private", "Val", "Labels"],
  Bay: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "PowerTransformer",
    "GeneralEquipment",
    "ConductingEquipment",
    "ConnectivityNode",
    "Function"
  ],
  BayType: [],
  BehaviorDescription: ["Text", "InputVar", "OutputVar", "BehaviorReference"],
  BehaviorDescriptionRef: ["Text", "FunctionalVariantRef", "InputVarRef", "OutputVarRef"],
  BehaviorReference: ["Text"],
  BinaryWiringParameters: ["Text"],
  BinaryWiringParametersRef: ["Text"],
  BitRate: [],
  CheckoutID: ["SubCheckoutID"],
  ClientLN: [],
  ClientServices: ["TimeSyncProt", "GOOSEMcSecurity", "SVMcSecurity", "Security"],
  CommProt: [],
  Communication: ["Text", "Private", "SubNetwork"],
  CommunicationServiceSpecifications: [
    "Text",
    "GooseParameters",
    "SMVParameters",
    "ReportParameters"
  ],
  ConductingEquipment: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "Terminal",
    "SubEquipment",
    "EqFunction"
  ],
  ConfDataSet: [],
  ConfLNs: [],
  ConfLdName: [],
  ConfLogControl: [],
  ConfReportControl: [],
  ConfSG: [],
  ConfSigRef: [],
  ConnectedAP: ["Text", "Private", "Address", "GSE", "SMV", "PhysConn"],
  ConnectivityNode: ["Text", "Private", "Labels", "LNode"],
  ControlRef: ["Text", "BinaryWiringParametersRef", "AnalogueWiringParametersRef"],
  ControllingLNode: ["Text", "BinaryWiringParametersRef", "AnalogueWiringParametersRef"],
  DA: ["Text", "Private", "Val", "Labels", "ProtNs"],
  DAI: ["Text", "Private", "Val", "Labels"],
  DAS: [
    "Text",
    "SubscriberLNode",
    "ControllingLNode",
    "ProcessEcho",
    "LogParametersRef",
    "Val",
    "Labels"
  ],
  DAType: ["Text", "Private", "BDA", "ProtNs", "Labels"],
  DO: ["Text", "Private", "Labels"],
  DOI: ["Text", "Private", "SDI", "DAI", "Labels"],
  DOS: [
    "Text",
    "SDS",
    "DAS",
    "SubscriberLNode",
    "ControllingLNode",
    "ProcessEcho",
    "LogParametersRef",
    "Labels"
  ],
  DOType: ["Text", "Private", "SDO", "DA", "Labels"],
  DataObjectDirectory: [],
  DataSet: ["Text", "Private", "FCDA"],
  DataSetDirectory: [],
  DataTypeTemplates: ["LNodeType", "DOType", "DAType", "EnumType"],
  DynAssociation: [],
  DynDataSet: [],
  EnumType: ["Text", "Private", "EnumVal"],
  EnumVal: [],
  EqFunction: ["Text", "Private", "Labels", "LNode", "GeneralEquipment", "EqSubFunction"],
  EqSubFunction: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "GeneralEquipment",
    "EqSubFunction"
  ],
  ExtCtrl: ["Text", "Private"],
  ExtRef: ["Text", "Private"],
  FCDA: [],
  FileHandling: [],
  Function: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "SubFunction",
    "GeneralEquipment",
    "ConductingEquipment"
  ],
  FunctionCatRef: ["Text"],
  FunctionCategory: ["Text", "SubCategory", "FunctionCatRef"],
  FunctionCategoryRef: ["Text", "FunctionalVariantRef"],
  FunctionRef: ["Text", "FunctionalVariantRef", "SignalRole"],
  FunctionRole: ["Text", "FunctionalVariantRef", "FunctionRoleContent"],
  FunctionRoleContent: [
    "Text",
    "FunctionRef",
    "BehaviorDescriptionRef",
    "ProcessResourceRef",
    "VariableRef",
    "FunctionCategoryRef",
    "PowerSystemRelationRef"
  ],
  FunctionSclRef: ["Text", "SclFileReference"],
  FunctionTemplate: [
    "Text",
    "LNode",
    "SubFunctionTemplate",
    "GeneralEquipment",
    "ConductingEquipment"
  ],
  FunctionalSubVariant: ["Text", "FunctionalSubVariant", "VariableRef"],
  FunctionalVariant: ["Text", "FunctionalSubVariant", "VariableRef"],
  FunctionalVariantGroup: ["Text", "FunctionalVariant"],
  FunctionalVariantRef: ["Text"],
  GOOSE: [],
  GOOSEMcSecurity: [],
  GOOSESecurity: ["Text", "Private", "Labels", "Subject", "IssuerName"],
  GSE: ["Text", "Private", "Address", "MinTime", "MaxTime"],
  GSEControl: ["Text", "Private", "IEDName", "Protocol"],
  GSEDir: [],
  GSESettings: ["McSecurity"],
  GSSE: [],
  GeneralEquipment: ["Text", "Private", "Labels", "LNode", "EqFunction"],
  GetCBValues: [],
  GetDataObjectDefinition: [],
  GetDataSetValue: [],
  GetDirectory: [],
  GooseParameters: [
    "Text",
    "L2CommParameters",
    "L3IPv4CommParameters",
    "L3IPv6CommParameters"
  ],
  GooseParametersRef: ["Text"],
  Header: ["Text", "History", "SourceFiles"],
  History: ["Hitem"],
  Hitem: ["SourceFiles"],
  IED: [
    "Text",
    "Private",
    "Services",
    "AccessPoint",
    "KDC",
    "IEDSourceFiles",
    "MinRequestedSCDFiles",
    "Labels"
  ],
  IEDName: [],
  IEDSourceFiles: ["Text", "Private", "SclFileReference"],
  InputVar: ["Text"],
  InputVarRef: ["Text", "FunctionalVariantRef"],
  Inputs: ["Text", "Private", "ExtRef"],
  IssuerName: [],
  KDC: [],
  L2CommParameters: ["Text"],
  L3IPv4CommParameters: ["Text"],
  L3IPv6CommParameters: ["Text"],
  LDevice: ["Text", "Private", "LN0", "LN", "AccessControl", "Labels"],
  LN: [
    "Text",
    "Private",
    "DataSet",
    "ReportControl",
    "LogControl",
    "DOI",
    "Inputs",
    "Outputs",
    "Log",
    "Labels"
  ],
  LN0: [
    "Text",
    "Private",
    "DataSet",
    "ReportControl",
    "LogControl",
    "DOI",
    "Inputs",
    "Outputs",
    "Log",
    "Labels",
    "GSEControl",
    "SampledValueControl",
    "SettingControl"
  ],
  LNode: ["Text", "Private", "Labels"],
  LNodeDataRef: ["Text", "FunctionalVariantRef"],
  LNodeInputRef: ["Text", "FunctionalVariantRef"],
  LNodeInputs: ["Text", "SourceRef"],
  LNodeOutputRef: ["Text", "FunctionalVariantRef"],
  LNodeOutputs: ["Text", "ControlRef"],
  LNodeSpecNaming: ["Text"],
  LNodeType: ["Text", "Private", "DO", "Labels"],
  Label: [],
  Labels: ["Text", "Private", "Label"],
  Line: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "GeneralEquipment",
    "Function",
    "Voltage",
    "ConductingEquipment",
    "ConnectivityNode"
  ],
  Log: ["Text", "Private"],
  LogControl: ["Text", "Private", "TrgOps"],
  LogParameters: ["Text"],
  LogParametersRef: ["Text"],
  LogSettings: [],
  MaxTime: [],
  McSecurity: [],
  MinRequestedSCDFile: [],
  MinRequestedSCDFiles: ["Text", "Private", "MinRequestedSCDFile"],
  MinTime: [],
  MultiAPPerSubNet: [],
  NeutralPoint: ["Text", "Private"],
  OptFields: [],
  OutputVar: ["Text"],
  OutputVarRef: ["Text", "FunctionalVariantRef"],
  Outputs: ["Text", "Private", "ExtCtrl"],
  P: [],
  PhysConn: ["Text", "Private", "P"],
  PowerSystemRelation: ["Text"],
  PowerSystemRelationRef: ["Text", "FunctionalVariantRef"],
  PowerSystemRelations: ["Text", "PowerSystemRelation"],
  PowerTransformer: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "TransformerWinding",
    "SubEquipment",
    "EqFunction"
  ],
  Private: [],
  Process: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "GeneralEquipment",
    "Function",
    "ConductingEquipment",
    "Substation",
    "Line",
    "Process"
  ],
  ProcessEcho: ["Text"],
  ProcessResource: ["Text", "Resource"],
  ProcessResourceRef: ["Text", "FunctionalVariantRef"],
  ProcessResources: ["Text", "ProcessResource"],
  Project: ["Text", "ProjectProcessReference"],
  ProjectProcessReference: ["Text"],
  ProtNs: [],
  Protocol: [],
  ReadWrite: [],
  RedProt: [],
  ReportControl: ["Text", "Private", "TrgOps", "OptFields", "RptEnabled"],
  ReportParameters: ["Text"],
  ReportParametersRef: ["Text"],
  ReportSettings: [],
  Resource: [],
  RptEnabled: ["Text", "Private", "ClientLN"],
  SCL: [
    "Text",
    "Private",
    "Header",
    "Substation",
    "Communication",
    "IED",
    "DataTypeTemplates",
    "Line",
    "Process"
  ],
  SCSM: [],
  SDI: ["Text", "Private", "SDI", "DAI", "Labels"],
  SDO: ["Text", "Private", "Labels"],
  SDS: [
    "Text",
    "SDS",
    "DAS",
    "SubscriberLNode",
    "ControllingLNode",
    "ProcessEcho",
    "LogParametersRef",
    "Labels"
  ],
  SGEdit: [],
  SMV: ["Text", "Private", "Address"],
  SMVParameters: [
    "Text",
    "L2CommParameters",
    "L3IPv4CommParameters",
    "L3IPv6CommParameters"
  ],
  SMVParametersRef: ["Text"],
  SMVSecurity: ["Text", "Private", "Labels", "Subject", "IssuerName"],
  SMVSettings: ["SmpRate", "SamplesPerSec", "SecPerSamples", "McSecurity"],
  SMVsc: [],
  SVMcSecurity: [],
  SampledValueControl: ["Text", "Private", "IEDName", "SmvOpts", "Protocol"],
  SamplesPerSec: [],
  SclFileReference: ["Text", "Private"],
  SecPerSamples: [],
  Security: [],
  Server: ["Text", "Private", "Authentication", "LDevice", "Association"],
  ServerAt: ["Text", "Private"],
  ServiceSpecifications: [
    "Text",
    "GooseParameters",
    "SMVParameters",
    "ReportParameters",
    "BinaryWiringParameters",
    "AnalogueWiringParameters",
    "LogParameters"
  ],
  Services: [
    "DynAssociation",
    "SettingGroups",
    "GetDirectory",
    "GetDataObjectDefinition",
    "DataObjectDirectory",
    "GetDataSetValue",
    "SetDataSetValue",
    "DataSetDirectory",
    "ConfDataSet",
    "DynDataSet",
    "ReadWrite",
    "TimerActivatedControl",
    "ConfReportControl",
    "GetCBValues",
    "ConfLogControl",
    "ReportSettings",
    "LogSettings",
    "GSESettings",
    "SMVSettings",
    "GSEDir",
    "GOOSE",
    "GSSE",
    "SMVsc",
    "FileHandling",
    "ConfLNs",
    "ClientServices",
    "ConfLdName",
    "SupSubscription",
    "ConfSigRef",
    "ValueHandling",
    "RedProt",
    "TimeSyncProt",
    "CommProt",
    "SCSM",
    "Security",
    "MultiAPPerSubNet"
  ],
  SetDataSetValue: [],
  SettingControl: ["Text", "Private"],
  SettingGroups: ["SGEdit", "ConfSG"],
  SignalRole: [
    "Text",
    "FunctionalVariantRef",
    "LNodeInputRef",
    "LNodeOutputRef",
    "LNodeDataRef"
  ],
  SmpRate: [],
  SmvOpts: [],
  SourceFiles: ["Text", "Private", "SclFileReference"],
  SourceRef: [
    "Text",
    "GooseParametersRef",
    "SMVParametersRef",
    "ReportParametersRef",
    "BinaryWiringParametersRef",
    "AnalogueWiringParametersRef"
  ],
  SubCategory: ["Text", "SubCategory", "FunctionCatRef"],
  SubCheckoutID: ["SubCheckoutID"],
  SubEquipment: ["Text", "Private", "Labels", "LNode", "EqFunction"],
  SubFunction: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "GeneralEquipment",
    "ConductingEquipment",
    "SubFunction"
  ],
  SubFunctionTemplate: [
    "Text",
    "LNode",
    "GeneralEquipment",
    "ConductingEquipment",
    "SubFunctionTemplate"
  ],
  SubNetwork: ["Text", "Private", "Labels", "BitRate", "ConnectedAP"],
  Subject: [],
  SubscriberLNode: [
    "Text",
    "GooseParametersRef",
    "SMVParametersRef",
    "ReportParametersRef",
    "BinaryWiringParametersRef"
  ],
  Substation: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "PowerTransformer",
    "GeneralEquipment",
    "VoltageLevel",
    "Function"
  ],
  SupSubscription: [],
  TapChanger: ["Text", "Private", "Labels", "LNode", "SubEquipment", "EqFunction"],
  Terminal: ["Text", "Private"],
  Text: [],
  TimeSyncProt: [],
  TimerActivatedControl: [],
  TransformerWinding: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "Terminal",
    "SubEquipment",
    "TapChanger",
    "NeutralPoint",
    "EqFunction"
  ],
  TrgOps: [],
  Val: [],
  ValueHandling: [],
  Variable: ["Text", "VariableApplyTo"],
  VariableApplyTo: ["Text"],
  VariableRef: ["Text", "FunctionalVariantRef"],
  Voltage: [],
  VoltageLevel: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "PowerTransformer",
    "GeneralEquipment",
    "Voltage",
    "Bay",
    "Function"
  ]
}, bL = {
  AccessControl: ["LDevice"],
  AccessPoint: ["IED"],
  Address: ["ConnectedAP", "GSE", "SMV"],
  AllocationRole: [],
  AllocationRoleRef: ["Application"],
  AnalogueWiringParameters: ["ServiceSpecifications"],
  AnalogueWiringParametersRef: ["ControlRef", "ControllingLNode", "SourceRef"],
  Application: [],
  ApplicationSclRef: ["Application"],
  Association: ["Server"],
  Authentication: ["Server"],
  BDA: ["DAType"],
  Bay: ["VoltageLevel"],
  BayType: [],
  BehaviorDescription: [],
  BehaviorDescriptionRef: ["FunctionRoleContent"],
  BehaviorReference: ["BehaviorDescription"],
  BinaryWiringParameters: ["ServiceSpecifications"],
  BinaryWiringParametersRef: [
    "ControlRef",
    "ControllingLNode",
    "SourceRef",
    "SubscriberLNode"
  ],
  BitRate: ["SubNetwork"],
  CheckoutID: [],
  ClientLN: ["RptEnabled"],
  ClientServices: ["Services"],
  CommProt: ["Services"],
  Communication: ["SCL"],
  CommunicationServiceSpecifications: [],
  ConductingEquipment: [
    "Bay",
    "Function",
    "FunctionTemplate",
    "Line",
    "Process",
    "SubFunction",
    "SubFunctionTemplate"
  ],
  ConfDataSet: ["Services"],
  ConfLNs: ["Services"],
  ConfLdName: ["Services"],
  ConfLogControl: ["Services"],
  ConfReportControl: ["Services"],
  ConfSG: ["SettingGroups"],
  ConfSigRef: ["Services"],
  ConnectedAP: ["SubNetwork"],
  ConnectivityNode: ["Bay", "Line"],
  ControlRef: ["LNodeOutputs"],
  ControllingLNode: ["DAS", "DOS", "SDS"],
  DA: ["DOType"],
  DAI: ["DOI", "SDI"],
  DAS: ["DOS", "SDS"],
  DAType: ["DataTypeTemplates"],
  DO: ["LNodeType"],
  DOI: ["LN", "LN0"],
  DOS: [],
  DOType: ["DataTypeTemplates"],
  DataObjectDirectory: ["Services"],
  DataSet: ["LN", "LN0"],
  DataSetDirectory: ["Services"],
  DataTypeTemplates: ["SCL"],
  DynAssociation: ["Services"],
  DynDataSet: ["Services"],
  EnumType: ["DataTypeTemplates"],
  EnumVal: ["EnumType"],
  EqFunction: [
    "ConductingEquipment",
    "GeneralEquipment",
    "PowerTransformer",
    "SubEquipment",
    "TapChanger",
    "TransformerWinding"
  ],
  EqSubFunction: ["EqFunction", "EqSubFunction"],
  ExtCtrl: ["Outputs"],
  ExtRef: ["Inputs"],
  FCDA: ["DataSet"],
  FileHandling: ["Services"],
  Function: ["Bay", "Line", "Process", "Substation", "VoltageLevel"],
  FunctionCatRef: ["FunctionCategory", "SubCategory"],
  FunctionCategory: [],
  FunctionCategoryRef: ["FunctionRoleContent"],
  FunctionRef: ["AllocationRole", "FunctionRoleContent"],
  FunctionRole: ["Application"],
  FunctionRoleContent: ["FunctionRole"],
  FunctionSclRef: [],
  FunctionTemplate: [],
  FunctionalSubVariant: ["FunctionalSubVariant", "FunctionalVariant"],
  FunctionalVariant: ["Application", "FunctionalVariantGroup"],
  FunctionalVariantGroup: ["Application"],
  FunctionalVariantRef: [
    "AllocationRoleRef",
    "BehaviorDescriptionRef",
    "FunctionCategoryRef",
    "FunctionRef",
    "FunctionRole",
    "InputVarRef",
    "LNodeDataRef",
    "LNodeInputRef",
    "LNodeOutputRef",
    "OutputVarRef",
    "PowerSystemRelationRef",
    "ProcessResourceRef",
    "SignalRole",
    "VariableRef"
  ],
  GOOSE: ["Services"],
  GOOSEMcSecurity: ["ClientServices"],
  GOOSESecurity: ["AccessPoint"],
  GSE: ["ConnectedAP"],
  GSEControl: ["LN0"],
  GSEDir: ["Services"],
  GSESettings: ["Services"],
  GSSE: ["Services"],
  GeneralEquipment: [
    "Bay",
    "EqFunction",
    "EqSubFunction",
    "Function",
    "FunctionTemplate",
    "Line",
    "Process",
    "SubFunction",
    "SubFunctionTemplate",
    "Substation",
    "VoltageLevel"
  ],
  GetCBValues: ["Services"],
  GetDataObjectDefinition: ["Services"],
  GetDataSetValue: ["Services"],
  GetDirectory: ["Services"],
  GooseParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
  GooseParametersRef: ["SourceRef", "SubscriberLNode"],
  Header: ["SCL"],
  History: ["Header"],
  Hitem: ["History"],
  IED: ["SCL"],
  IEDName: ["GSEControl", "SampledValueControl"],
  IEDSourceFiles: ["IED"],
  InputVar: ["BehaviorDescription"],
  InputVarRef: ["BehaviorDescriptionRef"],
  Inputs: ["LN", "LN0"],
  IssuerName: ["GOOSESecurity", "SMVSecurity"],
  KDC: ["IED"],
  L2CommParameters: ["GooseParameters", "SMVParameters"],
  L3IPv4CommParameters: ["GooseParameters", "SMVParameters"],
  L3IPv6CommParameters: ["GooseParameters", "SMVParameters"],
  LDevice: ["Server"],
  LN: ["AccessPoint", "LDevice"],
  LN0: ["LDevice"],
  LNode: [
    "Bay",
    "ConductingEquipment",
    "ConnectivityNode",
    "EqFunction",
    "EqSubFunction",
    "Function",
    "FunctionTemplate",
    "GeneralEquipment",
    "Line",
    "PowerTransformer",
    "Process",
    "SubEquipment",
    "SubFunction",
    "SubFunctionTemplate",
    "Substation",
    "TapChanger",
    "TransformerWinding",
    "VoltageLevel"
  ],
  LNodeDataRef: ["SignalRole"],
  LNodeInputRef: ["SignalRole"],
  LNodeInputs: [],
  LNodeOutputRef: ["SignalRole"],
  LNodeOutputs: [],
  LNodeSpecNaming: [],
  LNodeType: ["DataTypeTemplates"],
  Label: ["Labels"],
  Labels: [
    "AccessPoint",
    "BDA",
    "Bay",
    "ConductingEquipment",
    "ConnectivityNode",
    "DA",
    "DAI",
    "DAS",
    "DAType",
    "DO",
    "DOI",
    "DOS",
    "DOType",
    "EqFunction",
    "EqSubFunction",
    "Function",
    "GOOSESecurity",
    "GeneralEquipment",
    "IED",
    "LDevice",
    "LN",
    "LN0",
    "LNode",
    "LNodeType",
    "Line",
    "PowerTransformer",
    "Process",
    "SDI",
    "SDO",
    "SDS",
    "SMVSecurity",
    "SubEquipment",
    "SubFunction",
    "SubNetwork",
    "Substation",
    "TapChanger",
    "TransformerWinding",
    "VoltageLevel"
  ],
  Line: ["Process", "SCL"],
  Log: ["LN", "LN0"],
  LogControl: ["LN", "LN0"],
  LogParameters: ["ServiceSpecifications"],
  LogParametersRef: ["DAS", "DOS", "SDS"],
  LogSettings: ["Services"],
  MaxTime: ["GSE"],
  McSecurity: ["GSESettings", "SMVSettings"],
  MinRequestedSCDFile: ["MinRequestedSCDFiles"],
  MinRequestedSCDFiles: ["IED"],
  MinTime: ["GSE"],
  MultiAPPerSubNet: ["Services"],
  NeutralPoint: ["TransformerWinding"],
  OptFields: ["ReportControl"],
  OutputVar: ["BehaviorDescription"],
  OutputVarRef: ["BehaviorDescriptionRef"],
  Outputs: ["LN", "LN0"],
  P: ["Address", "PhysConn"],
  PhysConn: ["ConnectedAP"],
  PowerSystemRelation: ["PowerSystemRelations"],
  PowerSystemRelationRef: ["FunctionRoleContent"],
  PowerSystemRelations: [],
  PowerTransformer: ["Bay", "Substation", "VoltageLevel"],
  Private: [
    "AccessPoint",
    "BDA",
    "Bay",
    "Communication",
    "ConductingEquipment",
    "ConnectedAP",
    "ConnectivityNode",
    "DA",
    "DAI",
    "DAType",
    "DO",
    "DOI",
    "DOType",
    "DataSet",
    "EnumType",
    "EqFunction",
    "EqSubFunction",
    "ExtCtrl",
    "ExtRef",
    "Function",
    "GOOSESecurity",
    "GSE",
    "GSEControl",
    "GeneralEquipment",
    "IED",
    "IEDSourceFiles",
    "Inputs",
    "LDevice",
    "LN",
    "LN0",
    "LNode",
    "LNodeType",
    "Labels",
    "Line",
    "Log",
    "LogControl",
    "MinRequestedSCDFiles",
    "NeutralPoint",
    "Outputs",
    "PhysConn",
    "PowerTransformer",
    "Process",
    "ReportControl",
    "RptEnabled",
    "SCL",
    "SDI",
    "SDO",
    "SMV",
    "SMVSecurity",
    "SampledValueControl",
    "SclFileReference",
    "Server",
    "ServerAt",
    "SettingControl",
    "SourceFiles",
    "SubEquipment",
    "SubFunction",
    "SubNetwork",
    "Substation",
    "TapChanger",
    "Terminal",
    "TransformerWinding",
    "VoltageLevel"
  ],
  Process: ["Process", "SCL"],
  ProcessEcho: ["DAS", "DOS", "SDS"],
  ProcessResource: ["ProcessResources"],
  ProcessResourceRef: ["FunctionRoleContent"],
  ProcessResources: [],
  Project: [],
  ProjectProcessReference: ["Project"],
  ProtNs: ["DA", "DAType"],
  Protocol: ["GSEControl", "SampledValueControl"],
  ReadWrite: ["Services"],
  RedProt: ["Services"],
  ReportControl: ["LN", "LN0"],
  ReportParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
  ReportParametersRef: ["SourceRef", "SubscriberLNode"],
  ReportSettings: ["Services"],
  Resource: ["ProcessResource"],
  RptEnabled: ["ReportControl"],
  SCL: [],
  SCSM: ["Services"],
  SDI: ["DOI", "SDI"],
  SDO: ["DOType"],
  SDS: ["DOS", "SDS"],
  SGEdit: ["SettingGroups"],
  SMV: ["ConnectedAP"],
  SMVParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
  SMVParametersRef: ["SourceRef", "SubscriberLNode"],
  SMVSecurity: ["AccessPoint"],
  SMVSettings: ["Services"],
  SMVsc: ["Services"],
  SVMcSecurity: ["ClientServices"],
  SampledValueControl: ["LN0"],
  SamplesPerSec: ["SMVSettings"],
  SclFileReference: [
    "ApplicationSclRef",
    "FunctionSclRef",
    "IEDSourceFiles",
    "SourceFiles"
  ],
  SecPerSamples: ["SMVSettings"],
  Security: ["ClientServices", "Services"],
  Server: ["AccessPoint"],
  ServerAt: ["AccessPoint"],
  ServiceSpecifications: [],
  Services: ["AccessPoint", "IED"],
  SetDataSetValue: ["Services"],
  SettingControl: ["LN0"],
  SettingGroups: ["Services"],
  SignalRole: ["FunctionRef"],
  SmpRate: ["SMVSettings"],
  SmvOpts: ["SampledValueControl"],
  SourceFiles: ["Header", "Hitem"],
  SourceRef: ["LNodeInputs"],
  SubCategory: ["FunctionCategory", "SubCategory"],
  SubCheckoutID: ["CheckoutID", "SubCheckoutID"],
  SubEquipment: [
    "ConductingEquipment",
    "PowerTransformer",
    "TapChanger",
    "TransformerWinding"
  ],
  SubFunction: ["Function", "SubFunction"],
  SubFunctionTemplate: ["FunctionTemplate", "SubFunctionTemplate"],
  SubNetwork: ["Communication"],
  Subject: ["GOOSESecurity", "SMVSecurity"],
  SubscriberLNode: ["DAS", "DOS", "SDS"],
  Substation: ["Process", "SCL"],
  SupSubscription: ["Services"],
  TapChanger: ["TransformerWinding"],
  Terminal: ["ConductingEquipment", "TransformerWinding"],
  Text: [
    "AccessPoint",
    "AllocationRole",
    "AllocationRoleRef",
    "AnalogueWiringParameters",
    "AnalogueWiringParametersRef",
    "Application",
    "ApplicationSclRef",
    "BDA",
    "Bay",
    "BehaviorDescription",
    "BehaviorDescriptionRef",
    "BehaviorReference",
    "BinaryWiringParameters",
    "BinaryWiringParametersRef",
    "Communication",
    "CommunicationServiceSpecifications",
    "ConductingEquipment",
    "ConnectedAP",
    "ConnectivityNode",
    "ControlRef",
    "ControllingLNode",
    "DA",
    "DAI",
    "DAS",
    "DAType",
    "DO",
    "DOI",
    "DOS",
    "DOType",
    "DataSet",
    "EnumType",
    "EqFunction",
    "EqSubFunction",
    "ExtCtrl",
    "ExtRef",
    "Function",
    "FunctionCatRef",
    "FunctionCategory",
    "FunctionCategoryRef",
    "FunctionRef",
    "FunctionRole",
    "FunctionRoleContent",
    "FunctionSclRef",
    "FunctionTemplate",
    "FunctionalSubVariant",
    "FunctionalVariant",
    "FunctionalVariantGroup",
    "FunctionalVariantRef",
    "GOOSESecurity",
    "GSE",
    "GSEControl",
    "GeneralEquipment",
    "GooseParameters",
    "GooseParametersRef",
    "Header",
    "IED",
    "IEDSourceFiles",
    "InputVar",
    "InputVarRef",
    "Inputs",
    "L2CommParameters",
    "L3IPv4CommParameters",
    "L3IPv6CommParameters",
    "LDevice",
    "LN",
    "LN0",
    "LNode",
    "LNodeDataRef",
    "LNodeInputRef",
    "LNodeInputs",
    "LNodeOutputRef",
    "LNodeOutputs",
    "LNodeSpecNaming",
    "LNodeType",
    "Labels",
    "Line",
    "Log",
    "LogControl",
    "LogParameters",
    "LogParametersRef",
    "MinRequestedSCDFiles",
    "NeutralPoint",
    "OutputVar",
    "OutputVarRef",
    "Outputs",
    "PhysConn",
    "PowerSystemRelation",
    "PowerSystemRelationRef",
    "PowerSystemRelations",
    "PowerTransformer",
    "Process",
    "ProcessEcho",
    "ProcessResource",
    "ProcessResourceRef",
    "ProcessResources",
    "Project",
    "ProjectProcessReference",
    "ReportControl",
    "ReportParameters",
    "ReportParametersRef",
    "RptEnabled",
    "SCL",
    "SDI",
    "SDO",
    "SDS",
    "SMV",
    "SMVParameters",
    "SMVParametersRef",
    "SMVSecurity",
    "SampledValueControl",
    "SclFileReference",
    "Server",
    "ServerAt",
    "ServiceSpecifications",
    "SettingControl",
    "SignalRole",
    "SourceFiles",
    "SourceRef",
    "SubCategory",
    "SubEquipment",
    "SubFunction",
    "SubFunctionTemplate",
    "SubNetwork",
    "SubscriberLNode",
    "Substation",
    "TapChanger",
    "Terminal",
    "TransformerWinding",
    "Variable",
    "VariableApplyTo",
    "VariableRef",
    "VoltageLevel"
  ],
  TimeSyncProt: ["ClientServices", "Services"],
  TimerActivatedControl: ["Services"],
  TransformerWinding: ["PowerTransformer"],
  TrgOps: ["LogControl", "ReportControl"],
  Val: ["BDA", "DA", "DAI", "DAS"],
  ValueHandling: ["Services"],
  Variable: [],
  VariableApplyTo: ["Variable"],
  VariableRef: ["FunctionRoleContent", "FunctionalSubVariant", "FunctionalVariant"],
  Voltage: ["Line", "VoltageLevel"],
  VoltageLevel: ["Substation"]
}, wL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ATTRIBUTES: DL,
  CHILDREN: OL,
  DEFINITION: yL,
  ELEMENT_NAMES: IL,
  PARENTS: bL,
  REQUIRED: LL
}, Symbol.toStringTag, { value: "Module" })), Ni = {
  v2019C1: wL
}, Om = {
  default: {
    prefix: "",
    uri: "http://www.iec.ch/61850/2003/SCL"
  }
};
function Rg(e) {
  return e.reduce(
    (l, i) => {
      if (!i) return l;
      const a = i.tagName, s = l[a] ?? [];
      return s.push(i), l[a] = s, l;
    },
    {}
  );
}
function SL(e) {
  return typeof e == "object" && e !== null && "id" in e && "tagName" in e && "namespace" in e && "attributes" in e && "children" in e && !("treeChildren" in e) && !("status" in e);
}
function to(e) {
  return "treeChildren" in e && "status" in e;
}
function $a(e) {
  return to(e) ? e : {
    ...e,
    treeChildren: [],
    status: "unchanged"
  };
}
function Mi(e) {
  if (to(e)) {
    const { treeChildren: l, status: i, ...a } = e;
    return a;
  }
  return e;
}
function CL(e) {
  const { childRecord: l, parentRecord: i, stagedOperations: a } = e;
  function s(y) {
    const I = [...a].reverse().find((q) => q.type === "create" ? q.record.id === y && q.record.tagName === "Private" : q.type === "update" ? q.new.id === y && q.new.tagName === "Private" : !1);
    if (I?.type === "create")
      return I.record;
    if (I?.type === "update")
      return I.new;
  }
  function o(y) {
    const I = {
      ...l,
      parent: { id: y.id, tagName: "Private" }
    }, q = {
      ...y,
      children: [
        ...y.children,
        { id: l.id, tagName: l.tagName }
      ]
    };
    return { childRecord: I, privateRecord: q };
  }
  if (i.tagName === "Private") {
    const y = i, I = s(y.id) || y, { childRecord: q, privateRecord: R } = o(I);
    return {
      childRecord: q,
      privateRecord: R,
      oldPrivateRecord: I,
      updatedParentRecord: R,
      isNewPrivateElement: !1
    };
  }
  const f = i.children.find((y) => y.tagName === "Private");
  if (f) {
    const y = s(f.id);
    if (y && y.attributes.some(
      (I) => I.name === "type" && I.value === l.namespace.prefix
    )) {
      const { childRecord: I, privateRecord: q } = o(y);
      return {
        childRecord: I,
        privateRecord: q,
        oldPrivateRecord: y,
        updatedParentRecord: i,
        isNewPrivateElement: !1
      };
    }
  }
  const d = {
    id: crypto.randomUUID(),
    tagName: "Private",
    namespace: { prefix: Om.default.prefix, uri: Om.default.uri },
    attributes: [
      {
        name: "type",
        value: l.namespace.prefix
      }
    ],
    value: "",
    parent: { id: i.id, tagName: i.tagName },
    children: [
      { id: l.id, tagName: l.tagName }
    ],
    status: "create",
    treeChildren: []
  }, h = {
    ...l,
    parent: { id: d.id, tagName: "Private" }
  }, x = {
    ...i,
    children: [...i.children, { id: d.id, tagName: "Private" }]
  };
  return {
    childRecord: h,
    privateRecord: d,
    updatedParentRecord: x,
    isNewPrivateElement: !0
    // Private element is new, no update needed
  };
}
function as(e) {
  const { attributes: l, name: i } = e;
  return l.find((a) => a.name === i)?.value || "";
}
function Ag(e) {
  const { attributes: l } = e;
  return l.reduce(
    (i, a) => {
      const s = a.value || "";
      return i[a.name] = s, i;
    },
    {}
  );
}
const hf = ["DO", "SDO", "DA", "BDA", "EnumVal"], Eg = {
  LNodeType: "id",
  DOType: "id",
  DAType: "id",
  EnumType: "id",
  DO: "name",
  SDO: "name",
  DA: "name",
  BDA: "name",
  EnumVal: "ord"
};
function gf(e) {
  return Eg[e];
}
function vf(e) {
  const { source: l, targets: i } = e;
  let a;
  l.tagName === "LNode" || l.tagName === "LN" ? a = "lnType" : a = "type";
  const s = l.attributes, o = as({
    attributes: s,
    name: a
  });
  return i.find((f) => {
    const d = gf(f.tagName), h = f.attributes;
    return as({ attributes: h, name: d }) === o;
  });
}
function ic(e) {
  const { sources: l, targets: i } = e, a = [];
  for (const s of l) {
    const o = vf({
      source: s,
      targets: i
    });
    o && a.push(o);
  }
  return a;
}
function _g(e) {
  const { version: l, records: i } = e;
  return i.length === 0 ? !0 : i.every((a) => {
    if (!to(a) || !Ni[l].CHILDREN.DataTypeTemplates.includes(a.tagName)) return !1;
    const s = Ni[l].CHILDREN[a.tagName];
    return a.treeChildren.every((o) => !!(hf.includes(o.tagName) || s && s.includes(o.tagName)));
  });
}
function TL(e) {
  const { version: l, records: i } = e;
  if (!_g({ version: l, records: i }))
    throw new Error("Some records are not valid data model records.");
  return i;
}
function PL(e) {
  const { version: l, tagName: i, attributeName: a, value: s, elementId: o } = e, f = Ni[l].DEFINITION[i];
  if (!f || !f.attributes?.details) return;
  const d = f.attributes.details[a];
  if (!d?.validation?.enumeration) return;
  const h = d.validation.enumeration;
  if (!h.includes(s))
    throw new Error(
      `Invalid value '${s}' for attribute '${a}' on ${i}(element: ${o}). Expected one of: ${h.join(", ")}`
    );
}
const qL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DATA_MODEL_CHILDREN_TAG_NAMES: hf,
  DATA_MODEL_ROOT_ELEMENT_TO_ATTRIBUTE_KEY: Eg,
  areDataModelRecords: _g,
  filterDataModelRootElements: ic,
  getAttributeValueByName: as,
  getAttributesValuesByName: Ag,
  getDataModelRootElementKeyAttribute: gf,
  groupRecordsByTagName: Rg,
  isDatabaseRecord: SL,
  isTreeRecord: to,
  resolveDataModelRootElementReference: vf,
  toDataModelRecords: TL,
  toDatabaseRecord: Mi,
  toTreeRecord: $a,
  validateAttributeValue: PL
}, Symbol.toStringTag, { value: "Module" }));
function RL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function(s) {
    const { tagName: o, attributes: f, namespace: d, value: h, setFocus: x = !1 } = s, y = crypto.randomUUID(), I = i.then((q) => {
      let R, E;
      if (Ni[q.version].DEFINITION.hasOwnProperty(o)) {
        E = Ni[q.version].DEFINITION[o].namespace;
        const U = Ni[q.version].DEFINITION[o].attributes.details;
        R = Array.isArray(f) ? f : Object.entries(f).map(([B, K]) => {
          const W = B, ae = W === "uuid" ? crypto.randomUUID() : K;
          return {
            name: W,
            value: ae,
            namespace: U[W]?.namespace
          };
        });
        const z = Object.keys(
          Ni[q.version].ATTRIBUTES[o]
        ).includes("uuid"), X = R.some((B) => B.name === "uuid");
        if (z && !X) {
          const B = "uuid";
          R.push({
            name: B,
            value: crypto.randomUUID(),
            namespace: U[B]?.namespace
          });
        }
      } else
        E = d ?? { prefix: "", uri: "" }, R = Array.isArray(f) ? f : [];
      const M = {
        id: y,
        tagName: o,
        namespace: E,
        attributes: R,
        value: h ?? "",
        parent: { id: q.currentFocus.id, tagName: q.currentFocus.tagName },
        children: [],
        status: "created",
        treeChildren: []
      };
      if (M.namespace.prefix !== Om.default.prefix) {
        const {
          childRecord: U,
          privateRecord: z,
          oldPrivateRecord: X,
          updatedParentRecord: B,
          isNewPrivateElement: K
        } = CL({
          childRecord: M,
          parentRecord: q.currentFocus,
          stagedOperations: q.stagedOperations
        });
        if (K && Di({ context: q, type: "create", record: z }), Di({ context: q, type: "create", record: U }), !K && X && Di({
          context: q,
          type: "update",
          old: X,
          new: z
        }), Di({
          context: q,
          type: "update",
          old: Mi(q.currentFocus),
          new: B
        }), x)
          return {
            ...q,
            currentFocus: U
          };
        {
          const W = {
            ...q.currentFocus,
            ...B
          };
          return {
            ...q,
            currentFocus: W
          };
        }
      } else {
        Di({ context: q, type: "create", record: M });
        const U = {
          ...q.currentFocus,
          children: [
            ...q.currentFocus.children,
            {
              id: M.id,
              tagName: M.tagName
            }
          ]
        };
        return Di({
          context: q,
          type: "update",
          old: Mi(q.currentFocus),
          new: Mi(U)
        }), x ? {
          ...q,
          currentFocus: M
        } : {
          ...q,
          currentFocus: U
        };
      }
    });
    return l(x ? {
      contextPromise: I,
      extensions: a,
      tagName: o
    } : {
      contextPromise: I,
      extensions: a,
      tagName: o
    });
  };
}
function AL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function(s) {
    const { record: o, setFocus: f = !1 } = s, d = i.then(async (h) => {
      function x(E) {
        return 1 + E.treeChildren.reduce((M, U) => M + x(U), 0);
      }
      const y = x(o);
      let I = 0;
      function q(E, M) {
        const U = E.addChild({
          tagName: M.tagName,
          namespace: M.namespace,
          attributes: M.attributes,
          value: M.value,
          setFocus: !0
        });
        I++, h.onProgress && h.onProgress({
          current: I,
          total: y,
          message: `Cloning ${M.tagName}`,
          scope: "deepCloneChild"
        });
        let z = U;
        for (const X of M.treeChildren)
          z = q(z, X), z = z.goToParent();
        return z;
      }
      let R = l({
        contextPromise: Promise.resolve(h),
        extensions: a,
        tagName: h.currentFocus.tagName
      });
      return R = q(R, o), f || (R = R.goToParent()), await R.getContext();
    });
    return l(f ? {
      contextPromise: d,
      extensions: a,
      tagName: o.tagName
    } : {
      contextPromise: d,
      extensions: a,
      tagName: o.tagName
    });
  };
}
function EL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a, tagName: s } = e;
  return function(o) {
    const { attributes: f, value: d } = o, h = i.then(async (x) => {
      const y = [
        ...x.currentFocus.attributes
      ];
      if (f)
        for (const E of f) {
          const M = y.findIndex(
            (z) => z.name === E.name
          );
          if (E.value === "" || E.value === void 0 || E.value === null) {
            M >= 0 && y.splice(M, 1);
            continue;
          }
          const U = {
            name: E.name,
            value: String(E.value),
            ...E.namespace && { namespace: E.namespace }
          };
          M >= 0 ? y[M] = U : y.push(U);
        }
      const I = Ni[x.version].DEFINITION[x.currentFocus.tagName].namespace, q = x.currentFocus.namespace?.prefix === I.prefix, R = {
        ...x.currentFocus,
        namespace: I && !q ? I : x.currentFocus.namespace,
        attributes: f ? y : x.currentFocus.attributes,
        value: d ?? x.currentFocus.value
      };
      return Di({
        context: x,
        type: "update",
        old: Mi(x.currentFocus),
        new: Mi(R)
      }), {
        ...x,
        currentFocus: R
      };
    });
    return l({
      contextPromise: h,
      extensions: a,
      tagName: s
    });
  };
}
function _L(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function() {
    let s;
    const o = i.then(async (f) => {
      const d = f.currentFocus.id;
      Di({ context: f, type: "delete", record: Mi(f.currentFocus) });
      const h = f.currentFocus.parent;
      if (!h) throw new Error("Cannot delete element without a parent");
      s = h.tagName, await x(f.currentFocus.children);
      async function x(R) {
        for (const E of R) {
          const M = [...f.stagedOperations].reverse().find((z) => z.type === "create" ? z.record.id === E.id : z.type === "update" ? z.new.id === E.id : !1);
          let U;
          M ? M.type === "create" ? U = M.record : M.type === "update" && (U = M.new) : U = await f.databaseInstance.sclElements.get({
            id: E.id,
            tagName: E.tagName
          }), U && (U.children && U.children.length > 0 && await x(U.children), Di({
            context: f,
            type: "delete",
            record: U
          }));
        }
      }
      const y = [...f.stagedOperations].reverse().find((R) => R.type === "create" ? R.record.id === h.id : R.type === "update" ? R.new.id === h.id : !1);
      let I;
      if (y)
        if (y.type === "create")
          I = y.record;
        else if (y.type === "update")
          I = y.new;
        else
          throw new Error("Unexpected operation type");
      else {
        const R = await f.databaseInstance.sclElements.get({
          id: h.id,
          tagName: h.tagName
        });
        if (!R) throw new Error("Parent record not found in database");
        I = R;
      }
      const q = {
        ...$a(I),
        children: I.children.filter((R) => R.id !== d)
      };
      return Di({
        context: f,
        type: "update",
        old: Mi(I),
        new: Mi(q)
      }), {
        ...f,
        currentFocus: q
      };
    });
    return l({
      contextPromise: o,
      extensions: a,
      tagName: s
    });
  };
}
function Di(e) {
  const { context: l, type: i, record: a, old: s, new: o } = e;
  if (i === "create") {
    if (!a) throw new Error("record is required for create");
    l.stagedOperations.push({ type: i, record: a });
  } else if (i === "update") {
    if (!s || !o) throw new Error("old and new are required for update");
    l.stagedOperations.push({ type: i, old: s, new: o });
  } else if (i === "delete") {
    if (!a) throw new Error("record is required for delete");
    l.stagedOperations.push({ type: i, record: a });
  }
}
function NL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  function s(o) {
    const { tagName: f, id: d } = o, h = i.then(async (x) => {
      let y;
      if ((f === "SCL" || f === "Header" || f === "Communication" || f === "DataTypeTemplates") && !d)
        y = await x.databaseInstance[Kl].where("tagName").equals(f).first();
      else if (d)
        y = await x.databaseInstance[Kl].get({ id: d, tagName: f });
      else throw new Error(`Element ${f} requires an id parameter`);
      if (!y) {
        const q = d ? ` with id ${d}` : "";
        throw new Error(`No element ${f}${q} found in database`);
      }
      if (y.tagName !== f) throw new Error("Element tagName mismatch");
      const I = $a(y);
      return {
        ...x,
        entrypoint: I,
        currentFocus: I
      };
    });
    return l({
      contextPromise: h,
      extensions: a,
      tagName: f
    });
  }
  return s;
}
function FL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function() {
    let s;
    const o = i.then(async (f) => {
      const d = f.currentFocus.parent;
      if (!d) throw new Error("No parent found");
      s = d.tagName;
      const h = [...f.stagedOperations].reverse().find((y) => y.type === "create" ? y.record.id === d.id : y.type === "update" ? y.new.id === d.id : !1);
      let x;
      if (h && h.type !== "delete")
        x = h.type === "create" ? h.record : h.new;
      else {
        const y = await f.databaseInstance[Kl].get({
          id: d.id,
          tagName: d.tagName
        });
        if (!y) throw new Error("Parent record not found in database");
        x = y;
      }
      return {
        ...f,
        currentFocus: $a(x)
      };
    });
    return l({
      contextPromise: o,
      extensions: a,
      tagName: s
    });
  };
}
async function Ng(e) {
  const { context: l, options: i } = e, { depth: a, filter: s, withStagedOperations: o, withPrivate: f } = i || {};
  let d, h;
  o && (d = VL(l.stagedOperations), h = [...l.stagedOperations].reverse().find((q) => q.type === "create" ? q.record.id === l.currentFocus.id : q.type === "update" ? q.new.id === l.currentFocus.id : !1));
  let x = l.currentFocus;
  h?.type === "update" && (x = h.new), h?.type === "create" && (x = h.record);
  const y = ML(s?.pick), I = kL(s?.exclude);
  return await bm({
    context: l,
    record: x,
    currentDepth: 0,
    stagedOperationsPerRecordId: d,
    pickMap: y,
    excludeSet: I,
    isDeepBranch: !1,
    options: { depth: a, withStagedOperations: o, withPrivate: !!f }
  });
}
function ML(e) {
  const l = /* @__PURE__ */ new Map();
  if (!e) return l;
  for (const i of e)
    typeof i == "string" ? l.set(i, !1) : typeof i == "object" && "tagName" in i && l.set(i.tagName, !!i.deep);
  return l;
}
function kL(e) {
  return e ? new Set(e) : /* @__PURE__ */ new Set();
}
function VL(e) {
  const l = /* @__PURE__ */ new Map();
  for (const i of e)
    i.type === "delete" || i.type === "create" ? l.has(i.record.id) || l.set(i.record.id, i) : i.type === "update" && (l.has(i.new.id) || l.set(i.new.id, i));
  return l;
}
function BL(e, l) {
  return l.get(e)?.type || "unchanged";
}
function Fg(e) {
  const { tagName: l, pickMap: i, excludeSet: a, isDeepBranch: s, withPrivate: o } = e;
  return l === "Private" && !o ? { shouldInclude: !1, nextDeepBranch: !1 } : s ? { shouldInclude: !0, nextDeepBranch: !0 } : a.has(l) ? { shouldInclude: !1, nextDeepBranch: !1 } : i.size > 0 ? i.has(l) ? { shouldInclude: !0, nextDeepBranch: i.get(l) ?? !1 } : { shouldInclude: !1, nextDeepBranch: !1 } : { shouldInclude: !0, nextDeepBranch: !1 };
}
function Mg(e) {
  const { childTree: l, pickMap: i, excludeSet: a, withPrivate: s } = e;
  if (!l.treeChildren || l.treeChildren.length === 0) return [];
  const o = [];
  for (const f of l.treeChildren) {
    const { shouldInclude: d } = Fg({
      tagName: f.tagName,
      pickMap: i,
      excludeSet: a,
      isDeepBranch: !1,
      withPrivate: s
    });
    d ? o.push(f) : o.push(
      ...Mg({
        childTree: f,
        pickMap: i,
        excludeSet: a,
        withPrivate: s
      })
    );
  }
  return o;
}
function Od(e) {
  const { tree: l, recordId: i, stagedOperationsPerRecordId: a } = e;
  return {
    ...l,
    status: a ? BL(i, a) : "unchanged"
  };
}
async function bm(e) {
  const {
    context: l,
    record: i,
    currentDepth: a,
    stagedOperationsPerRecordId: s,
    pickMap: o,
    excludeSet: f,
    isDeepBranch: d,
    options: h
  } = e, { depth: x, withStagedOperations: y, withPrivate: I } = h, q = (await Promise.all(
    i.children.map(async (M) => {
      if (y) {
        const U = [...l.stagedOperations].reverse().find((z) => z.type === "create" ? z.record.id === M.id : z.type === "update" ? z.new.id === M.id : !1);
        if (U && U.type !== "delete")
          return U.type === "create" ? U.record : U.new;
      }
      return l.databaseInstance[Kl].get({
        id: M.id,
        tagName: M.tagName
      });
    })
  )).filter(
    (M) => !!M
  );
  if (x !== void 0 && a >= x && i.tagName !== "Private" && !I) {
    const M = {
      ...i,
      treeChildren: []
    };
    return Od({
      tree: M,
      recordId: i.id,
      stagedOperationsPerRecordId: s
    });
  }
  const R = [];
  for (const M of q) {
    const U = M.tagName, { shouldInclude: z, nextDeepBranch: X } = Fg({
      tagName: U,
      pickMap: o,
      excludeSet: f,
      isDeepBranch: d,
      withPrivate: I
    });
    if (z) {
      const B = await bm({
        context: l,
        record: M,
        currentDepth: a + 1,
        stagedOperationsPerRecordId: s,
        pickMap: o,
        excludeSet: f,
        isDeepBranch: X,
        options: e.options
      });
      R.push(
        B
      );
    } else if (U === "Private" || o.size > 0) {
      const B = await bm({
        context: l,
        record: M,
        currentDepth: a + 1,
        stagedOperationsPerRecordId: s,
        pickMap: o,
        excludeSet: f,
        isDeepBranch: X,
        options: e.options
      }), K = Mg({
        childTree: B,
        pickMap: o,
        excludeSet: f,
        withPrivate: I
      });
      R.push(...K);
    }
  }
  const E = {
    ...i,
    treeChildren: R
  };
  return Od({
    tree: E,
    recordId: i.id,
    stagedOperationsPerRecordId: s
  });
}
function ZL(e) {
  const { contextPromise: l } = e;
  return async function() {
    const i = await l;
    return qg(
      () => i.databaseInstance[Kl].get(i.currentFocus.id)
    );
  };
}
function UL(e) {
  const { contextPromise: l } = e;
  return async function() {
    const i = await l;
    return await Ng({
      context: i,
      options: {
        withStagedOperations: !0
      }
    });
  };
}
function KL(e) {
  const { contextPromise: l } = e;
  return async function() {
    return await l;
  };
}
function GL(e) {
  const { contextPromise: l } = e;
  return async function(i) {
    const { depth: a, filter: s, withStagedOperations: o, withPrivate: f } = i || {}, d = await l;
    return await Ng({
      context: d,
      options: { depth: a, filter: s, withStagedOperations: o, withPrivate: f }
    });
  };
}
function zL(e) {
  const { contextPromise: l } = e;
  return async function() {
    const i = await l, a = i.stagedOperations.length;
    try {
      await i.databaseInstance.transaction(
        "rw",
        i.databaseInstance.tables,
        async () => {
          const s = i.stagedOperations.filter((h) => h.type === "create"), o = i.stagedOperations.filter((h) => h.type === "update"), f = i.stagedOperations.filter((h) => h.type === "delete");
          let d = 0;
          s.length > 0 && (i.onProgress?.({
            current: d,
            total: a,
            message: `Creating ${s.length} records`,
            scope: "commit"
          }), await i.databaseInstance[Kl].bulkAdd(
            s.map((h) => h.record)
          ), d += s.length, i.onProgress?.({
            current: d,
            total: a,
            message: `Created ${s.length} records`,
            scope: "commit"
          })), o.length > 0 && (i.onProgress?.({
            current: d,
            total: a,
            message: `Updating ${o.length} records`,
            scope: "commit"
          }), await i.databaseInstance[Kl].bulkPut(
            o.map((h) => h.new)
          ), d += o.length, i.onProgress?.({
            current: d,
            total: a,
            message: `Updated ${o.length} records`,
            scope: "commit"
          })), f.length > 0 && (i.onProgress?.({
            current: d,
            total: a,
            message: `Deleting ${f.length} records`,
            scope: "commit"
          }), await i.databaseInstance[Kl].bulkDelete(
            f.map((h) => h.record.id)
          ), d += f.length, i.onProgress?.({
            current: d,
            total: a,
            message: `Deleted ${f.length} records`,
            scope: "commit"
          }));
        }
      );
    } catch (s) {
      throw new Error("Transaction failed", { cause: s });
    }
  };
}
function Ri(e) {
  const { contextPromise: l, extensions: i, tagName: a } = e, s = {
    //== Crud methods
    addChild: RL({
      genericApiBuilder: Ri,
      contextPromise: l,
      extensions: i
    }),
    deepCloneChild: AL({
      genericApiBuilder: Ri,
      contextPromise: l,
      extensions: i
    }),
    update: EL({
      genericApiBuilder: Ri,
      contextPromise: l,
      extensions: i,
      tagName: a
    }),
    delete: a === "SCL" ? void 0 : _L({
      genericApiBuilder: Ri,
      contextPromise: l,
      extensions: i
    }),
    //== Navigation methods
    goToElement: NL({
      genericApiBuilder: Ri,
      contextPromise: l,
      extensions: i
    }),
    goToParent: FL({
      genericApiBuilder: Ri,
      contextPromise: l,
      extensions: i
    }),
    //== Ending methods
    getObservable: ZL({
      contextPromise: l
    }),
    getChildren: GL({
      contextPromise: l
    }),
    getSnapshot: UL({
      contextPromise: l
    }),
    getContext: KL({
      contextPromise: l
    }),
    commit: zL({
      contextPromise: l
    })
  };
  return jL({
    genericBuilder: s,
    extensions: i,
    tagName: a,
    contextPromise: l
  });
}
function jL(e) {
  const { genericBuilder: l, extensions: i, tagName: a, contextPromise: s } = e, o = l, f = i[a] || {};
  for (const [d, h] of Object.entries(f))
    typeof h == "function" && (o[d] = h({
      genericApiBuilder: Ri,
      contextPromise: s,
      extensions: i
    }));
  return o;
}
function HL(e) {
  const { databaseInstance: l, tagName: i } = e;
  return qg(() => l[Kl].where({ tagName: i }).toArray());
}
function $L(e) {
  const { version: l, databaseInstance: i, extensions: a, tagName: s, id: o, onProgress: f } = e, d = Promise.resolve().then(async () => {
    const h = s === "SCL" || s === "Header" || s === "Communication" || s === "DataTypeTemplates";
    let x;
    if (h && !o)
      x = await i[Kl].where("tagName").equals(s).first();
    else if (o)
      x = await i[Kl].get({ id: o, tagName: s });
    else
      throw new Error(`Element ${s} requires an id parameter`);
    if (!x) {
      const I = o ? ` with id ${o}` : "";
      throw new Error(`No element ${s}${I} found in database`);
    }
    if (x.tagName !== s) throw new Error("Element tagName mismatch");
    const y = $a(x);
    return {
      version: l,
      databaseInstance: i,
      entrypoint: y,
      currentFocus: y,
      stagedOperations: [],
      onProgress: f
    };
  });
  return Ri({
    contextPromise: d,
    extensions: a,
    tagName: s
  });
}
function WL(e) {
  const { version: l, databaseInstance: i, extensions: a, onProgress: s } = e, o = Promise.resolve().then(async () => {
    const f = await i[Kl].where({
      tagName: "SCL"
    }).count();
    if (f === 0) throw new Error("No root SCL element found in database");
    if (f > 1)
      throw new Error("Multiple root SCL elements found in database, database is corrupted");
    const d = await i[Kl].get({ tagName: "SCL" });
    if (!d) throw new Error("No root SCL element found in database");
    const h = $a(d);
    return {
      version: l,
      databaseInstance: i,
      entrypoint: h,
      currentFocus: h,
      stagedOperations: [],
      onProgress: s
    };
  });
  return Ri({
    contextPromise: o,
    extensions: a,
    tagName: "SCL"
  });
}
async function kg(e) {
  const { record: l, dataTypeTemplates: i } = e, {
    LNodeType: a = [],
    DOType: s = [],
    DAType: o = [],
    EnumType: f = []
  } = Rg(i.treeChildren), d = vf({
    source: l,
    targets: a
  });
  if (!d)
    throw new Error(
      `LNodeType for ${l.tagName} ${l.attributes.find((I) => I.name === "lnType")?.value} not found`
    );
  const h = ic({
    sources: d.treeChildren.filter((I) => I.tagName === "DO"),
    targets: s
  }), x = ic({
    sources: h.flatMap(
      (I) => I.treeChildren.filter((q) => q.tagName === "DA")
    ),
    targets: o
  }), y = ic({
    sources: x.flatMap(
      (I) => I.treeChildren.filter((q) => q.tagName === "BDA")
    ),
    targets: f
  });
  return {
    ...l,
    treeChildren: [d, ...h, ...x, ...y],
    status: "unchanged"
  };
}
function YL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function() {
    const s = i.then(async (o) => {
      const f = o.currentFocus, d = await l({
        contextPromise: Promise.resolve(o),
        extensions: a,
        tagName: o.currentFocus.tagName
      }).goToElement({ tagName: "DataTypeTemplates" }).getChildren(), h = await kg({
        record: f,
        dataTypeTemplates: d
      });
      return {
        ...o,
        currentFocus: h
      };
    });
    return l({
      contextPromise: s,
      extensions: a,
      tagName: "LNode"
    });
  };
}
const XL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  resolveDataModel: YL
}, Symbol.toStringTag, { value: "Module" }));
function QL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function(s) {
    const { subnetworkId: o } = s, f = i.then(async (d) => {
      const h = l({
        contextPromise: Promise.resolve(d),
        extensions: a,
        tagName: "IED"
      }), x = as({
        attributes: d.currentFocus.attributes,
        name: "name"
      }), y = await h.getChildren({
        filter: { pick: ["AccessPoint"] },
        withStagedOperations: !0
      });
      let I = h.goToElement({
        tagName: "SubNetwork",
        id: o
      });
      for (const R of y.treeChildren) {
        const E = as({
          attributes: R.attributes,
          name: "name"
        });
        I = I.addChild({
          tagName: "ConnectedAP",
          attributes: {
            iedName: x,
            apName: E
          }
        });
      }
      const q = (await I.getContext()).stagedOperations;
      return {
        ...d,
        stagedOperations: q
      };
    });
    return l({
      contextPromise: f,
      extensions: a,
      tagName: "IED"
    });
  };
}
const JL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attachAllAccessPointToSubNetwork: QL
}, Symbol.toStringTag, { value: "Module" }));
function eD(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function() {
    const s = i.then(async (o) => {
      const f = o.currentFocus, d = await l({
        contextPromise: Promise.resolve(o),
        extensions: a,
        tagName: o.currentFocus.tagName
      }).goToElement({ tagName: "DataTypeTemplates" }).getChildren(), h = await kg({
        record: f,
        dataTypeTemplates: d
      });
      return {
        ...o,
        currentFocus: h
      };
    });
    return l({
      contextPromise: s,
      extensions: a,
      tagName: "LN"
    });
  };
}
const nD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  resolveDataModel: eD
}, Symbol.toStringTag, { value: "Module" }));
function lD(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function(s) {
    const { dataModel: o } = s, f = i.then(async (d) => {
      let h = l({
        contextPromise: Promise.resolve(d),
        extensions: a,
        tagName: "DataTypeTemplates"
      });
      for (const x of o) {
        if (await Bg(h, x)) continue;
        h = Vg(h, x);
        const y = x.treeChildren.filter(
          (I) => hf.includes(I.tagName)
        );
        for (const I of y)
          h = await tD(h, I);
        h = h.goToParent();
      }
      return await h.getContext();
    });
    return l({
      contextPromise: f,
      extensions: a,
      tagName: "DataTypeTemplates"
    });
  };
}
async function tD(e, l) {
  return await Bg(e, l) ? e : Vg(e, l).goToParent();
}
function Vg(e, l) {
  const i = Ag({
    attributes: l.attributes
  });
  return e.addChild({
    tagName: l.tagName,
    attributes: i,
    setFocus: !0
  });
}
async function Bg(e, l) {
  const i = gf(l.tagName), a = l.attributes.find((s) => s.name === i)?.value;
  if (!a)
    throw new Error(`Key attribute "${i}" is missing in element attributes.`);
  return (await e.getChildren({ depth: 1, withStagedOperations: !0 })).treeChildren.find(
    (s) => s.tagName === l.tagName && s.attributes.find((o) => o.name === i)?.value === a
  );
}
const iD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addToDataModel: lD
}, Symbol.toStringTag, { value: "Module" })), uD = {
  LNode: XL,
  IED: JL,
  LN: nD,
  DataTypeTemplates: iD
}, aD = {
  v2019C1: uD
};
function rD(e) {
  const { version: l, databaseInstance: i } = e, a = aD[l];
  return {
    // chainable methods
    fromRoot: (s) => WL({ version: l, databaseInstance: i, extensions: a, onProgress: s?.onProgress }),
    fromElement: (s) => $L({
      version: l,
      databaseInstance: i,
      extensions: a,
      tagName: s.tagName,
      id: s.id,
      onProgress: s?.onProgress
    }),
    // ending methods
    getObservable: (s) => HL({ databaseInstance: i, ...s }),
    getElement: async (s) => await i[Kl].get({
      tagName: s.tagName,
      id: s.id
    })
  };
}
function bd(e) {
  const { databaseName: l, version: i } = e, a = xL({
    databaseName: l
  });
  return {
    api: rD({ version: i, databaseInstance: a }),
    utils: qL,
    database: a,
    standard: Ni[i]
  };
}
const Cc = "v2019C1";
var sD = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function cD(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function oD(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var l = e.default;
  if (typeof l == "function") {
    var i = function a() {
      var s = !1;
      try {
        s = this instanceof a;
      } catch {
      }
      return s ? Reflect.construct(l, arguments, this.constructor) : l.apply(this, arguments);
    };
    i.prototype = l.prototype;
  } else i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(e).forEach(function(a) {
    var s = Object.getOwnPropertyDescriptor(e, a);
    Object.defineProperty(i, a, s.get ? s : {
      enumerable: !0,
      get: function() {
        return e[a];
      }
    });
  }), i;
}
var wd = {};
const mD = {}, fD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: mD
}, Symbol.toStringTag, { value: "Module" })), Sd = /* @__PURE__ */ oD(fD);
var Cd;
function dD() {
  return Cd || (Cd = 1, function(e) {
    (function(l) {
      l.parser = function(V, _) {
        return new a(V, _);
      }, l.SAXParser = a, l.SAXStream = y, l.createStream = x, l.MAX_BUFFER_LENGTH = 64 * 1024;
      var i = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      l.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function a(V, _) {
        if (!(this instanceof a))
          return new a(V, _);
        var Z = this;
        o(Z), Z.q = Z.c = "", Z.bufferCheckPosition = l.MAX_BUFFER_LENGTH, Z.opt = _ || {}, Z.opt.lowercase = Z.opt.lowercase || Z.opt.lowercasetags, Z.looseCase = Z.opt.lowercase ? "toLowerCase" : "toUpperCase", Z.tags = [], Z.closed = Z.closedRoot = Z.sawRoot = !1, Z.tag = Z.error = null, Z.strict = !!V, Z.noscript = !!(V || Z.opt.noscript), Z.state = k.BEGIN, Z.strictEntities = Z.opt.strictEntities, Z.ENTITIES = Z.strictEntities ? Object.create(l.XML_ENTITIES) : Object.create(l.ENTITIES), Z.attribList = [], Z.opt.xmlns && (Z.ns = Object.create(M)), Z.opt.unquotedAttributeValues === void 0 && (Z.opt.unquotedAttributeValues = !V), Z.trackPosition = Z.opt.position !== !1, Z.trackPosition && (Z.position = Z.line = Z.column = 0), be(Z, "onready");
      }
      Object.create || (Object.create = function(V) {
        function _() {
        }
        _.prototype = V;
        var Z = new _();
        return Z;
      }), Object.keys || (Object.keys = function(V) {
        var _ = [];
        for (var Z in V) V.hasOwnProperty(Z) && _.push(Z);
        return _;
      });
      function s(V) {
        for (var _ = Math.max(l.MAX_BUFFER_LENGTH, 10), Z = 0, ue = 0, Qe = i.length; ue < Qe; ue++) {
          var De = V[i[ue]].length;
          if (De > _)
            switch (i[ue]) {
              case "textNode":
                ye(V);
                break;
              case "cdata":
                re(V, "oncdata", V.cdata), V.cdata = "";
                break;
              case "script":
                re(V, "onscript", V.script), V.script = "";
                break;
              default:
                Se(V, "Max buffer length exceeded: " + i[ue]);
            }
          Z = Math.max(Z, De);
        }
        var j = l.MAX_BUFFER_LENGTH - Z;
        V.bufferCheckPosition = j + V.position;
      }
      function o(V) {
        for (var _ = 0, Z = i.length; _ < Z; _++)
          V[i[_]] = "";
      }
      function f(V) {
        ye(V), V.cdata !== "" && (re(V, "oncdata", V.cdata), V.cdata = ""), V.script !== "" && (re(V, "onscript", V.script), V.script = "");
      }
      a.prototype = {
        end: function() {
          ge(this);
        },
        write: tn,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          f(this);
        }
      };
      var d;
      try {
        d = Sd.Stream;
      } catch {
        d = function() {
        };
      }
      d || (d = function() {
      });
      var h = l.EVENTS.filter(function(V) {
        return V !== "error" && V !== "end";
      });
      function x(V, _) {
        return new y(V, _);
      }
      function y(V, _) {
        if (!(this instanceof y))
          return new y(V, _);
        d.apply(this), this._parser = new a(V, _), this.writable = !0, this.readable = !0;
        var Z = this;
        this._parser.onend = function() {
          Z.emit("end");
        }, this._parser.onerror = function(ue) {
          Z.emit("error", ue), Z._parser.error = null;
        }, this._decoder = null, h.forEach(function(ue) {
          Object.defineProperty(Z, "on" + ue, {
            get: function() {
              return Z._parser["on" + ue];
            },
            set: function(Qe) {
              if (!Qe)
                return Z.removeAllListeners(ue), Z._parser["on" + ue] = Qe, Qe;
              Z.on(ue, Qe);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      y.prototype = Object.create(d.prototype, {
        constructor: {
          value: y
        }
      }), y.prototype.write = function(V) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(V)) {
          if (!this._decoder) {
            var _ = Sd.StringDecoder;
            this._decoder = new _("utf8");
          }
          V = this._decoder.write(V);
        }
        return this._parser.write(V.toString()), this.emit("data", V), !0;
      }, y.prototype.end = function(V) {
        return V && V.length && this.write(V), this._parser.end(), !0;
      }, y.prototype.on = function(V, _) {
        var Z = this;
        return !Z._parser["on" + V] && h.indexOf(V) !== -1 && (Z._parser["on" + V] = function() {
          var ue = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          ue.splice(0, 0, V), Z.emit.apply(Z, ue);
        }), d.prototype.on.call(Z, V, _);
      };
      var I = "[CDATA[", q = "DOCTYPE", R = "http://www.w3.org/XML/1998/namespace", E = "http://www.w3.org/2000/xmlns/", M = { xml: R, xmlns: E }, U = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, z = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, X = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, B = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function K(V) {
        return V === " " || V === `
` || V === "\r" || V === "	";
      }
      function W(V) {
        return V === '"' || V === "'";
      }
      function ae(V) {
        return V === ">" || K(V);
      }
      function ne(V, _) {
        return V.test(_);
      }
      function oe(V, _) {
        return !ne(V, _);
      }
      var k = 0;
      l.STATE = {
        BEGIN: k++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: k++,
        // leading whitespace
        TEXT: k++,
        // general stuff
        TEXT_ENTITY: k++,
        // &amp and such.
        OPEN_WAKA: k++,
        // <
        SGML_DECL: k++,
        // <!BLARG
        SGML_DECL_QUOTED: k++,
        // <!BLARG foo "bar
        DOCTYPE: k++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: k++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: k++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: k++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: k++,
        // <!-
        COMMENT: k++,
        // <!--
        COMMENT_ENDING: k++,
        // <!-- blah -
        COMMENT_ENDED: k++,
        // <!-- blah --
        CDATA: k++,
        // <![CDATA[ something
        CDATA_ENDING: k++,
        // ]
        CDATA_ENDING_2: k++,
        // ]]
        PROC_INST: k++,
        // <?hi
        PROC_INST_BODY: k++,
        // <?hi there
        PROC_INST_ENDING: k++,
        // <?hi "there" ?
        OPEN_TAG: k++,
        // <strong
        OPEN_TAG_SLASH: k++,
        // <strong /
        ATTRIB: k++,
        // <a
        ATTRIB_NAME: k++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: k++,
        // <a foo _
        ATTRIB_VALUE: k++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: k++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: k++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: k++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: k++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: k++,
        // <foo bar=&quot
        CLOSE_TAG: k++,
        // </a
        CLOSE_TAG_SAW_WHITE: k++,
        // </a   >
        SCRIPT: k++,
        // <script> ...
        SCRIPT_ENDING: k++
        // <script> ... <
      }, l.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, l.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(l.ENTITIES).forEach(function(V) {
        var _ = l.ENTITIES[V], Z = typeof _ == "number" ? String.fromCharCode(_) : _;
        l.ENTITIES[V] = Z;
      });
      for (var me in l.STATE)
        l.STATE[l.STATE[me]] = me;
      k = l.STATE;
      function be(V, _, Z) {
        V[_] && V[_](Z);
      }
      function re(V, _, Z) {
        V.textNode && ye(V), be(V, _, Z);
      }
      function ye(V) {
        V.textNode = xe(V.opt, V.textNode), V.textNode && be(V, "ontext", V.textNode), V.textNode = "";
      }
      function xe(V, _) {
        return V.trim && (_ = _.trim()), V.normalize && (_ = _.replace(/\s+/g, " ")), _;
      }
      function Se(V, _) {
        return ye(V), V.trackPosition && (_ += `
Line: ` + V.line + `
Column: ` + V.column + `
Char: ` + V.c), _ = new Error(_), V.error = _, be(V, "onerror", _), V;
      }
      function ge(V) {
        return V.sawRoot && !V.closedRoot && ce(V, "Unclosed root tag"), V.state !== k.BEGIN && V.state !== k.BEGIN_WHITESPACE && V.state !== k.TEXT && Se(V, "Unexpected end"), ye(V), V.c = "", V.closed = !0, be(V, "onend"), a.call(V, V.strict, V.opt), V;
      }
      function ce(V, _) {
        if (typeof V != "object" || !(V instanceof a))
          throw new Error("bad call to strictFail");
        V.strict && Se(V, _);
      }
      function de(V) {
        V.strict || (V.tagName = V.tagName[V.looseCase]());
        var _ = V.tags[V.tags.length - 1] || V, Z = V.tag = { name: V.tagName, attributes: {} };
        V.opt.xmlns && (Z.ns = _.ns), V.attribList.length = 0, re(V, "onopentagstart", Z);
      }
      function Le(V, _) {
        var Z = V.indexOf(":"), ue = Z < 0 ? ["", V] : V.split(":"), Qe = ue[0], De = ue[1];
        return _ && V === "xmlns" && (Qe = "xmlns", De = ""), { prefix: Qe, local: De };
      }
      function Ae(V) {
        if (V.strict || (V.attribName = V.attribName[V.looseCase]()), V.attribList.indexOf(V.attribName) !== -1 || V.tag.attributes.hasOwnProperty(V.attribName)) {
          V.attribName = V.attribValue = "";
          return;
        }
        if (V.opt.xmlns) {
          var _ = Le(V.attribName, !0), Z = _.prefix, ue = _.local;
          if (Z === "xmlns")
            if (ue === "xml" && V.attribValue !== R)
              ce(
                V,
                "xml: prefix must be bound to " + R + `
Actual: ` + V.attribValue
              );
            else if (ue === "xmlns" && V.attribValue !== E)
              ce(
                V,
                "xmlns: prefix must be bound to " + E + `
Actual: ` + V.attribValue
              );
            else {
              var Qe = V.tag, De = V.tags[V.tags.length - 1] || V;
              Qe.ns === De.ns && (Qe.ns = Object.create(De.ns)), Qe.ns[ue] = V.attribValue;
            }
          V.attribList.push([V.attribName, V.attribValue]);
        } else
          V.tag.attributes[V.attribName] = V.attribValue, re(V, "onattribute", {
            name: V.attribName,
            value: V.attribValue
          });
        V.attribName = V.attribValue = "";
      }
      function We(V, _) {
        if (V.opt.xmlns) {
          var Z = V.tag, ue = Le(V.tagName);
          Z.prefix = ue.prefix, Z.local = ue.local, Z.uri = Z.ns[ue.prefix] || "", Z.prefix && !Z.uri && (ce(V, "Unbound namespace prefix: " + JSON.stringify(V.tagName)), Z.uri = ue.prefix);
          var Qe = V.tags[V.tags.length - 1] || V;
          Z.ns && Qe.ns !== Z.ns && Object.keys(Z.ns).forEach(function(Pe) {
            re(V, "onopennamespace", {
              prefix: Pe,
              uri: Z.ns[Pe]
            });
          });
          for (var De = 0, j = V.attribList.length; De < j; De++) {
            var ie = V.attribList[De], fe = ie[0], Ce = ie[1], Ie = Le(fe, !0), we = Ie.prefix, Ne = Ie.local, Ee = we === "" ? "" : Z.ns[we] || "", Oe = {
              name: fe,
              value: Ce,
              prefix: we,
              local: Ne,
              uri: Ee
            };
            we && we !== "xmlns" && !Ee && (ce(V, "Unbound namespace prefix: " + JSON.stringify(we)), Oe.uri = we), V.tag.attributes[fe] = Oe, re(V, "onattribute", Oe);
          }
          V.attribList.length = 0;
        }
        V.tag.isSelfClosing = !!_, V.sawRoot = !0, V.tags.push(V.tag), re(V, "onopentag", V.tag), _ || (!V.noscript && V.tagName.toLowerCase() === "script" ? V.state = k.SCRIPT : V.state = k.TEXT, V.tag = null, V.tagName = ""), V.attribName = V.attribValue = "", V.attribList.length = 0;
      }
      function je(V) {
        if (!V.tagName) {
          ce(V, "Weird empty close tag."), V.textNode += "</>", V.state = k.TEXT;
          return;
        }
        if (V.script) {
          if (V.tagName !== "script") {
            V.script += "</" + V.tagName + ">", V.tagName = "", V.state = k.SCRIPT;
            return;
          }
          re(V, "onscript", V.script), V.script = "";
        }
        var _ = V.tags.length, Z = V.tagName;
        V.strict || (Z = Z[V.looseCase]());
        for (var ue = Z; _--; ) {
          var Qe = V.tags[_];
          if (Qe.name !== ue)
            ce(V, "Unexpected close tag");
          else
            break;
        }
        if (_ < 0) {
          ce(V, "Unmatched closing tag: " + V.tagName), V.textNode += "</" + V.tagName + ">", V.state = k.TEXT;
          return;
        }
        V.tagName = Z;
        for (var De = V.tags.length; De-- > _; ) {
          var j = V.tag = V.tags.pop();
          V.tagName = V.tag.name, re(V, "onclosetag", V.tagName);
          var ie = {};
          for (var fe in j.ns)
            ie[fe] = j.ns[fe];
          var Ce = V.tags[V.tags.length - 1] || V;
          V.opt.xmlns && j.ns !== Ce.ns && Object.keys(j.ns).forEach(function(Ie) {
            var we = j.ns[Ie];
            re(V, "onclosenamespace", { prefix: Ie, uri: we });
          });
        }
        _ === 0 && (V.closedRoot = !0), V.tagName = V.attribValue = V.attribName = "", V.attribList.length = 0, V.state = k.TEXT;
      }
      function cn(V) {
        var _ = V.entity, Z = _.toLowerCase(), ue, Qe = "";
        return V.ENTITIES[_] ? V.ENTITIES[_] : V.ENTITIES[Z] ? V.ENTITIES[Z] : (_ = Z, _.charAt(0) === "#" && (_.charAt(1) === "x" ? (_ = _.slice(2), ue = parseInt(_, 16), Qe = ue.toString(16)) : (_ = _.slice(1), ue = parseInt(_, 10), Qe = ue.toString(10))), _ = _.replace(/^0+/, ""), isNaN(ue) || Qe.toLowerCase() !== _ ? (ce(V, "Invalid character entity"), "&" + V.entity + ";") : String.fromCodePoint(ue));
      }
      function bn(V, _) {
        _ === "<" ? (V.state = k.OPEN_WAKA, V.startTagPosition = V.position) : K(_) || (ce(V, "Non-whitespace before first tag."), V.textNode = _, V.state = k.TEXT);
      }
      function gn(V, _) {
        var Z = "";
        return _ < V.length && (Z = V.charAt(_)), Z;
      }
      function tn(V) {
        var _ = this;
        if (this.error)
          throw this.error;
        if (_.closed)
          return Se(
            _,
            "Cannot write after close. Assign an onready handler."
          );
        if (V === null)
          return ge(_);
        typeof V == "object" && (V = V.toString());
        for (var Z = 0, ue = ""; ue = gn(V, Z++), _.c = ue, !!ue; )
          switch (_.trackPosition && (_.position++, ue === `
` ? (_.line++, _.column = 0) : _.column++), _.state) {
            case k.BEGIN:
              if (_.state = k.BEGIN_WHITESPACE, ue === "\uFEFF")
                continue;
              bn(_, ue);
              continue;
            case k.BEGIN_WHITESPACE:
              bn(_, ue);
              continue;
            case k.TEXT:
              if (_.sawRoot && !_.closedRoot) {
                for (var Qe = Z - 1; ue && ue !== "<" && ue !== "&"; )
                  ue = gn(V, Z++), ue && _.trackPosition && (_.position++, ue === `
` ? (_.line++, _.column = 0) : _.column++);
                _.textNode += V.substring(Qe, Z - 1);
              }
              ue === "<" && !(_.sawRoot && _.closedRoot && !_.strict) ? (_.state = k.OPEN_WAKA, _.startTagPosition = _.position) : (!K(ue) && (!_.sawRoot || _.closedRoot) && ce(_, "Text data outside of root node."), ue === "&" ? _.state = k.TEXT_ENTITY : _.textNode += ue);
              continue;
            case k.SCRIPT:
              ue === "<" ? _.state = k.SCRIPT_ENDING : _.script += ue;
              continue;
            case k.SCRIPT_ENDING:
              ue === "/" ? _.state = k.CLOSE_TAG : (_.script += "<" + ue, _.state = k.SCRIPT);
              continue;
            case k.OPEN_WAKA:
              if (ue === "!")
                _.state = k.SGML_DECL, _.sgmlDecl = "";
              else if (!K(ue)) if (ne(U, ue))
                _.state = k.OPEN_TAG, _.tagName = ue;
              else if (ue === "/")
                _.state = k.CLOSE_TAG, _.tagName = "";
              else if (ue === "?")
                _.state = k.PROC_INST, _.procInstName = _.procInstBody = "";
              else {
                if (ce(_, "Unencoded <"), _.startTagPosition + 1 < _.position) {
                  var De = _.position - _.startTagPosition;
                  ue = new Array(De).join(" ") + ue;
                }
                _.textNode += "<" + ue, _.state = k.TEXT;
              }
              continue;
            case k.SGML_DECL:
              if (_.sgmlDecl + ue === "--") {
                _.state = k.COMMENT, _.comment = "", _.sgmlDecl = "";
                continue;
              }
              _.doctype && _.doctype !== !0 && _.sgmlDecl ? (_.state = k.DOCTYPE_DTD, _.doctype += "<!" + _.sgmlDecl + ue, _.sgmlDecl = "") : (_.sgmlDecl + ue).toUpperCase() === I ? (re(_, "onopencdata"), _.state = k.CDATA, _.sgmlDecl = "", _.cdata = "") : (_.sgmlDecl + ue).toUpperCase() === q ? (_.state = k.DOCTYPE, (_.doctype || _.sawRoot) && ce(
                _,
                "Inappropriately located doctype declaration"
              ), _.doctype = "", _.sgmlDecl = "") : ue === ">" ? (re(_, "onsgmldeclaration", _.sgmlDecl), _.sgmlDecl = "", _.state = k.TEXT) : (W(ue) && (_.state = k.SGML_DECL_QUOTED), _.sgmlDecl += ue);
              continue;
            case k.SGML_DECL_QUOTED:
              ue === _.q && (_.state = k.SGML_DECL, _.q = ""), _.sgmlDecl += ue;
              continue;
            case k.DOCTYPE:
              ue === ">" ? (_.state = k.TEXT, re(_, "ondoctype", _.doctype), _.doctype = !0) : (_.doctype += ue, ue === "[" ? _.state = k.DOCTYPE_DTD : W(ue) && (_.state = k.DOCTYPE_QUOTED, _.q = ue));
              continue;
            case k.DOCTYPE_QUOTED:
              _.doctype += ue, ue === _.q && (_.q = "", _.state = k.DOCTYPE);
              continue;
            case k.DOCTYPE_DTD:
              ue === "]" ? (_.doctype += ue, _.state = k.DOCTYPE) : ue === "<" ? (_.state = k.OPEN_WAKA, _.startTagPosition = _.position) : W(ue) ? (_.doctype += ue, _.state = k.DOCTYPE_DTD_QUOTED, _.q = ue) : _.doctype += ue;
              continue;
            case k.DOCTYPE_DTD_QUOTED:
              _.doctype += ue, ue === _.q && (_.state = k.DOCTYPE_DTD, _.q = "");
              continue;
            case k.COMMENT:
              ue === "-" ? _.state = k.COMMENT_ENDING : _.comment += ue;
              continue;
            case k.COMMENT_ENDING:
              ue === "-" ? (_.state = k.COMMENT_ENDED, _.comment = xe(_.opt, _.comment), _.comment && re(_, "oncomment", _.comment), _.comment = "") : (_.comment += "-" + ue, _.state = k.COMMENT);
              continue;
            case k.COMMENT_ENDED:
              ue !== ">" ? (ce(_, "Malformed comment"), _.comment += "--" + ue, _.state = k.COMMENT) : _.doctype && _.doctype !== !0 ? _.state = k.DOCTYPE_DTD : _.state = k.TEXT;
              continue;
            case k.CDATA:
              ue === "]" ? _.state = k.CDATA_ENDING : _.cdata += ue;
              continue;
            case k.CDATA_ENDING:
              ue === "]" ? _.state = k.CDATA_ENDING_2 : (_.cdata += "]" + ue, _.state = k.CDATA);
              continue;
            case k.CDATA_ENDING_2:
              ue === ">" ? (_.cdata && re(_, "oncdata", _.cdata), re(_, "onclosecdata"), _.cdata = "", _.state = k.TEXT) : ue === "]" ? _.cdata += "]" : (_.cdata += "]]" + ue, _.state = k.CDATA);
              continue;
            case k.PROC_INST:
              ue === "?" ? _.state = k.PROC_INST_ENDING : K(ue) ? _.state = k.PROC_INST_BODY : _.procInstName += ue;
              continue;
            case k.PROC_INST_BODY:
              if (!_.procInstBody && K(ue))
                continue;
              ue === "?" ? _.state = k.PROC_INST_ENDING : _.procInstBody += ue;
              continue;
            case k.PROC_INST_ENDING:
              ue === ">" ? (re(_, "onprocessinginstruction", {
                name: _.procInstName,
                body: _.procInstBody
              }), _.procInstName = _.procInstBody = "", _.state = k.TEXT) : (_.procInstBody += "?" + ue, _.state = k.PROC_INST_BODY);
              continue;
            case k.OPEN_TAG:
              ne(z, ue) ? _.tagName += ue : (de(_), ue === ">" ? We(_) : ue === "/" ? _.state = k.OPEN_TAG_SLASH : (K(ue) || ce(_, "Invalid character in tag name"), _.state = k.ATTRIB));
              continue;
            case k.OPEN_TAG_SLASH:
              ue === ">" ? (We(_, !0), je(_)) : (ce(_, "Forward-slash in opening tag not followed by >"), _.state = k.ATTRIB);
              continue;
            case k.ATTRIB:
              if (K(ue))
                continue;
              ue === ">" ? We(_) : ue === "/" ? _.state = k.OPEN_TAG_SLASH : ne(U, ue) ? (_.attribName = ue, _.attribValue = "", _.state = k.ATTRIB_NAME) : ce(_, "Invalid attribute name");
              continue;
            case k.ATTRIB_NAME:
              ue === "=" ? _.state = k.ATTRIB_VALUE : ue === ">" ? (ce(_, "Attribute without value"), _.attribValue = _.attribName, Ae(_), We(_)) : K(ue) ? _.state = k.ATTRIB_NAME_SAW_WHITE : ne(z, ue) ? _.attribName += ue : ce(_, "Invalid attribute name");
              continue;
            case k.ATTRIB_NAME_SAW_WHITE:
              if (ue === "=")
                _.state = k.ATTRIB_VALUE;
              else {
                if (K(ue))
                  continue;
                ce(_, "Attribute without value"), _.tag.attributes[_.attribName] = "", _.attribValue = "", re(_, "onattribute", {
                  name: _.attribName,
                  value: ""
                }), _.attribName = "", ue === ">" ? We(_) : ne(U, ue) ? (_.attribName = ue, _.state = k.ATTRIB_NAME) : (ce(_, "Invalid attribute name"), _.state = k.ATTRIB);
              }
              continue;
            case k.ATTRIB_VALUE:
              if (K(ue))
                continue;
              W(ue) ? (_.q = ue, _.state = k.ATTRIB_VALUE_QUOTED) : (_.opt.unquotedAttributeValues || Se(_, "Unquoted attribute value"), _.state = k.ATTRIB_VALUE_UNQUOTED, _.attribValue = ue);
              continue;
            case k.ATTRIB_VALUE_QUOTED:
              if (ue !== _.q) {
                ue === "&" ? _.state = k.ATTRIB_VALUE_ENTITY_Q : _.attribValue += ue;
                continue;
              }
              Ae(_), _.q = "", _.state = k.ATTRIB_VALUE_CLOSED;
              continue;
            case k.ATTRIB_VALUE_CLOSED:
              K(ue) ? _.state = k.ATTRIB : ue === ">" ? We(_) : ue === "/" ? _.state = k.OPEN_TAG_SLASH : ne(U, ue) ? (ce(_, "No whitespace between attributes"), _.attribName = ue, _.attribValue = "", _.state = k.ATTRIB_NAME) : ce(_, "Invalid attribute name");
              continue;
            case k.ATTRIB_VALUE_UNQUOTED:
              if (!ae(ue)) {
                ue === "&" ? _.state = k.ATTRIB_VALUE_ENTITY_U : _.attribValue += ue;
                continue;
              }
              Ae(_), ue === ">" ? We(_) : _.state = k.ATTRIB;
              continue;
            case k.CLOSE_TAG:
              if (_.tagName)
                ue === ">" ? je(_) : ne(z, ue) ? _.tagName += ue : _.script ? (_.script += "</" + _.tagName, _.tagName = "", _.state = k.SCRIPT) : (K(ue) || ce(_, "Invalid tagname in closing tag"), _.state = k.CLOSE_TAG_SAW_WHITE);
              else {
                if (K(ue))
                  continue;
                oe(U, ue) ? _.script ? (_.script += "</" + ue, _.state = k.SCRIPT) : ce(_, "Invalid tagname in closing tag.") : _.tagName = ue;
              }
              continue;
            case k.CLOSE_TAG_SAW_WHITE:
              if (K(ue))
                continue;
              ue === ">" ? je(_) : ce(_, "Invalid characters in closing tag");
              continue;
            case k.TEXT_ENTITY:
            case k.ATTRIB_VALUE_ENTITY_Q:
            case k.ATTRIB_VALUE_ENTITY_U:
              var j, ie;
              switch (_.state) {
                case k.TEXT_ENTITY:
                  j = k.TEXT, ie = "textNode";
                  break;
                case k.ATTRIB_VALUE_ENTITY_Q:
                  j = k.ATTRIB_VALUE_QUOTED, ie = "attribValue";
                  break;
                case k.ATTRIB_VALUE_ENTITY_U:
                  j = k.ATTRIB_VALUE_UNQUOTED, ie = "attribValue";
                  break;
              }
              if (ue === ";") {
                var fe = cn(_);
                _.opt.unparsedEntities && !Object.values(l.XML_ENTITIES).includes(fe) ? (_.entity = "", _.state = j, _.write(fe)) : (_[ie] += fe, _.entity = "", _.state = j);
              } else ne(_.entity.length ? B : X, ue) ? _.entity += ue : (ce(_, "Invalid character in entity name"), _[ie] += "&" + _.entity + ue, _.entity = "", _.state = j);
              continue;
            default:
              throw new Error(_, "Unknown state: " + _.state);
          }
        return _.position >= _.bufferCheckPosition && s(_), _;
      }
      String.fromCodePoint || function() {
        var V = String.fromCharCode, _ = Math.floor, Z = function() {
          var ue = 16384, Qe = [], De, j, ie = -1, fe = arguments.length;
          if (!fe)
            return "";
          for (var Ce = ""; ++ie < fe; ) {
            var Ie = Number(arguments[ie]);
            if (!isFinite(Ie) || // `NaN`, `+Infinity`, or `-Infinity`
            Ie < 0 || // not a valid Unicode code point
            Ie > 1114111 || // not a valid Unicode code point
            _(Ie) !== Ie)
              throw RangeError("Invalid code point: " + Ie);
            Ie <= 65535 ? Qe.push(Ie) : (Ie -= 65536, De = (Ie >> 10) + 55296, j = Ie % 1024 + 56320, Qe.push(De, j)), (ie + 1 === fe || Qe.length > ue) && (Ce += V.apply(null, Qe), Qe.length = 0);
          }
          return Ce;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: Z,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = Z;
      }();
    })(e);
  }(wd)), wd;
}
var pD = dD();
const Hr = {};
function hD(e) {
  const { parentId: l, child: i } = e;
  Hr[l] || (Hr[l] = []);
  const a = {
    id: i.id,
    tagName: i.tagName
  };
  Hr[l].push(a);
}
function gD(e) {
  const { currentBatch: l } = e, i = [...l];
  for (const [a, s] of i.entries()) {
    const o = Hr[s.id] || [];
    o.length > 0 && (i[a].children.push(...o), vD({
      parentId: s.id
    }));
  }
  return i;
}
function vD(e) {
  const { parentId: l } = e;
  delete Hr[l];
}
function xD(e) {
  return "prefix" in e && "uri" in e && !!e.prefix && !!e.uri;
}
const yD = [
  ".fsd",
  ".asd",
  ".ssd",
  ".scd",
  ".isd",
  ".icd",
  ".xml"
], uc = "sclElements", qo = "id, tagName, &attributes.uuid, &attributes.id, attributes.name, parent.id, parent.tagName, *children.id, *children.tagName", Ro = "attachedFiles", Td = "id, filename, file", ID = {
  default: {
    prefix: "",
    uri: "http://www.iec.ch/61850/2003/SCL"
  }
};
function LD() {
  let e = {
    defaultNamespace: null,
    stack: [],
    recordsBatch: []
  };
  const l = pD.parser(
    !0,
    // strict mode
    {
      lowercase: !1,
      // Preserve case
      trim: !0,
      // Trim text nodes
      normalize: !0,
      // Normalize whitespace
      position: !1,
      // Don't track position (performance boost)
      xmlns: !0
      // Enable namespace handling
    }
  );
  l.onopentag = (s) => e = DD({ node: s, state: e }), l.ontext = (s) => e = OD({ text: s, state: e }), l.onclosetag = () => ({ updatedState: e } = bD({
    state: e
  })), l.onerror = wD;
  function i() {
    const s = e.recordsBatch;
    return e.recordsBatch = [], s;
  }
  function a() {
    return e.recordsBatch.length;
  }
  return {
    parser: l,
    drainBatch: i,
    getSize: a
  };
}
function DD(e) {
  const { node: l, state: i } = e, a = { ...i }, s = SD(l);
  a.defaultNamespace || (a.defaultNamespace = CD(l));
  const o = TD(l, a.defaultNamespace), f = PD(l.attributes), d = qD(i.stack), h = {
    id: crypto.randomUUID(),
    tagName: s,
    namespace: o,
    attributes: f,
    value: "",
    parent: d,
    children: []
  };
  return a.stack.push(h), a;
}
function OD(e) {
  const { text: l, state: i } = e;
  return l && i.stack.length > 0 && (i.stack[i.stack.length - 1].value += l), i;
}
function bD(e) {
  const { state: l } = e, i = l.stack.at(-1);
  let a = l.stack.slice(0, -1);
  const s = [...l.recordsBatch];
  if (i) {
    if (a.length) {
      const o = a.length - 1;
      a = a.map(
        (f, d) => d === o ? {
          ...f,
          children: [
            ...f.children,
            { id: i.id, tagName: i.tagName }
          ]
        } : f
      );
    } else i.parent && hD({
      parentId: i.parent.id,
      child: { id: i.id, tagName: i.tagName }
    });
    s.push(i);
  }
  return {
    updatedState: {
      defaultNamespace: l.defaultNamespace,
      stack: a,
      recordsBatch: s
    }
  };
}
function wD(e) {
  return new Error(`XML parsing error: ${e}`);
}
function SD(e) {
  return e.local || null;
}
function CD(e) {
  if (e.name !== "SCL") throw new Error("Default namespace can only be set on SCL element");
  return e.attributes?.xmlns?.value ? {
    prefix: "",
    uri: e.attributes.xmlns.value
  } : ID.default;
}
function TD(e, l) {
  return xD(e) ? {
    prefix: e.prefix,
    uri: e.uri
  } : l;
}
function PD(e) {
  return Object.values(e).map((l) => {
    const i = l.prefix && l.uri ? {
      prefix: l.prefix,
      uri: l.uri
    } : void 0;
    return {
      name: i ? l.local : l.name,
      value: l.value,
      ...i && { namespace: i }
    };
  });
}
function qD(e) {
  if (e.length === 0) return null;
  const l = e[e.length - 1];
  return l ? { id: l.id, tagName: l.tagName } : null;
}
var wm = { exports: {} }, RD = wm.exports, Pd;
function AD() {
  return Pd || (Pd = 1, function(e, l) {
    (function(i, a) {
      e.exports = a();
    })(RD, function() {
      var i = function(n, t) {
        return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(u, r) {
          u.__proto__ = r;
        } || function(u, r) {
          for (var c in r) Object.prototype.hasOwnProperty.call(r, c) && (u[c] = r[c]);
        })(n, t);
      }, a = function() {
        return (a = Object.assign || function(n) {
          for (var t, u = 1, r = arguments.length; u < r; u++) for (var c in t = arguments[u]) Object.prototype.hasOwnProperty.call(t, c) && (n[c] = t[c]);
          return n;
        }).apply(this, arguments);
      };
      function s(n, t, u) {
        for (var r, c = 0, m = t.length; c < m; c++) !r && c in t || ((r = r || Array.prototype.slice.call(t, 0, c))[c] = t[c]);
        return n.concat(r || Array.prototype.slice.call(t));
      }
      var o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : sD, f = Object.keys, d = Array.isArray;
      function h(n, t) {
        return typeof t != "object" || f(t).forEach(function(u) {
          n[u] = t[u];
        }), n;
      }
      typeof Promise > "u" || o.Promise || (o.Promise = Promise);
      var x = Object.getPrototypeOf, y = {}.hasOwnProperty;
      function I(n, t) {
        return y.call(n, t);
      }
      function q(n, t) {
        typeof t == "function" && (t = t(x(n))), (typeof Reflect > "u" ? f : Reflect.ownKeys)(t).forEach(function(u) {
          E(n, u, t[u]);
        });
      }
      var R = Object.defineProperty;
      function E(n, t, u, r) {
        R(n, t, h(u && I(u, "get") && typeof u.get == "function" ? { get: u.get, set: u.set, configurable: !0 } : { value: u, configurable: !0, writable: !0 }, r));
      }
      function M(n) {
        return { from: function(t) {
          return n.prototype = Object.create(t.prototype), E(n.prototype, "constructor", n), { extend: q.bind(null, n.prototype) };
        } };
      }
      var U = Object.getOwnPropertyDescriptor, z = [].slice;
      function X(n, t, u) {
        return z.call(n, t, u);
      }
      function B(n, t) {
        return t(n);
      }
      function K(n) {
        if (!n) throw new Error("Assertion Failed");
      }
      function W(n) {
        o.setImmediate ? setImmediate(n) : setTimeout(n, 0);
      }
      function ae(n, t) {
        if (typeof t == "string" && I(n, t)) return n[t];
        if (!t) return n;
        if (typeof t != "string") {
          for (var u = [], r = 0, c = t.length; r < c; ++r) {
            var m = ae(n, t[r]);
            u.push(m);
          }
          return u;
        }
        var p = t.indexOf(".");
        if (p !== -1) {
          var g = n[t.substr(0, p)];
          return g == null ? void 0 : ae(g, t.substr(p + 1));
        }
      }
      function ne(n, t, u) {
        if (n && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(n))) if (typeof t != "string" && "length" in t) {
          K(typeof u != "string" && "length" in u);
          for (var r = 0, c = t.length; r < c; ++r) ne(n, t[r], u[r]);
        } else {
          var m, p, g = t.indexOf(".");
          g !== -1 ? (m = t.substr(0, g), (p = t.substr(g + 1)) === "" ? u === void 0 ? d(n) && !isNaN(parseInt(m)) ? n.splice(m, 1) : delete n[m] : n[m] = u : ne(g = !(g = n[m]) || !I(n, m) ? n[m] = {} : g, p, u)) : u === void 0 ? d(n) && !isNaN(parseInt(t)) ? n.splice(t, 1) : delete n[t] : n[t] = u;
        }
      }
      function oe(n) {
        var t, u = {};
        for (t in n) I(n, t) && (u[t] = n[t]);
        return u;
      }
      var k = [].concat;
      function me(n) {
        return k.apply([], n);
      }
      var Ue = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(me([8, 16, 32, 64].map(function(n) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + n + "Array";
        });
      }))).filter(function(n) {
        return o[n];
      }), be = new Set(Ue.map(function(n) {
        return o[n];
      })), re = null;
      function ye(n) {
        return re = /* @__PURE__ */ new WeakMap(), n = function t(u) {
          if (!u || typeof u != "object") return u;
          var r = re.get(u);
          if (r) return r;
          if (d(u)) {
            r = [], re.set(u, r);
            for (var c = 0, m = u.length; c < m; ++c) r.push(t(u[c]));
          } else if (be.has(u.constructor)) r = u;
          else {
            var p, g = x(u);
            for (p in r = g === Object.prototype ? {} : Object.create(g), re.set(u, r), u) I(u, p) && (r[p] = t(u[p]));
          }
          return r;
        }(n), re = null, n;
      }
      var xe = {}.toString;
      function Se(n) {
        return xe.call(n).slice(8, -1);
      }
      var ge = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", ce = typeof ge == "symbol" ? function(n) {
        var t;
        return n != null && (t = n[ge]) && t.apply(n);
      } : function() {
        return null;
      };
      function de(n, t) {
        return t = n.indexOf(t), 0 <= t && n.splice(t, 1), 0 <= t;
      }
      var Le = {};
      function Ae(n) {
        var t, u, r, c;
        if (arguments.length === 1) {
          if (d(n)) return n.slice();
          if (this === Le && typeof n == "string") return [n];
          if (c = ce(n)) {
            for (u = []; !(r = c.next()).done; ) u.push(r.value);
            return u;
          }
          if (n == null) return [n];
          if (typeof (t = n.length) != "number") return [n];
          for (u = new Array(t); t--; ) u[t] = n[t];
          return u;
        }
        for (t = arguments.length, u = new Array(t); t--; ) u[t] = arguments[t];
        return u;
      }
      var We = typeof Symbol < "u" ? function(n) {
        return n[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ze = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], In = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ze), je = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function cn(n, t) {
        this.name = n, this.message = t;
      }
      function bn(n, t) {
        return n + ". Errors: " + Object.keys(t).map(function(u) {
          return t[u].toString();
        }).filter(function(u, r, c) {
          return c.indexOf(u) === r;
        }).join(`
`);
      }
      function gn(n, t, u, r) {
        this.failures = t, this.failedKeys = r, this.successCount = u, this.message = bn(n, t);
      }
      function tn(n, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(u) {
          return t[u];
        }), this.failuresByPos = t, this.message = bn(n, this.failures);
      }
      M(cn).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), M(gn).from(cn), M(tn).from(cn);
      var V = In.reduce(function(n, t) {
        return n[t] = t + "Error", n;
      }, {}), _ = cn, Z = In.reduce(function(n, t) {
        var u = t + "Error";
        function r(c, m) {
          this.name = u, c ? typeof c == "string" ? (this.message = "".concat(c).concat(m ? `
 ` + m : ""), this.inner = m || null) : typeof c == "object" && (this.message = "".concat(c.name, " ").concat(c.message), this.inner = c) : (this.message = je[t] || u, this.inner = null);
        }
        return M(r).from(_), n[t] = r, n;
      }, {});
      Z.Syntax = SyntaxError, Z.Type = TypeError, Z.Range = RangeError;
      var ue = Ze.reduce(function(n, t) {
        return n[t + "Error"] = Z[t], n;
      }, {}), Qe = In.reduce(function(n, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (n[t + "Error"] = Z[t]), n;
      }, {});
      function De() {
      }
      function j(n) {
        return n;
      }
      function ie(n, t) {
        return n == null || n === j ? t : function(u) {
          return t(n(u));
        };
      }
      function fe(n, t) {
        return function() {
          n.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function Ce(n, t) {
        return n === De ? t : function() {
          var u = n.apply(this, arguments);
          u !== void 0 && (arguments[0] = u);
          var r = this.onsuccess, c = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var m = t.apply(this, arguments);
          return r && (this.onsuccess = this.onsuccess ? fe(r, this.onsuccess) : r), c && (this.onerror = this.onerror ? fe(c, this.onerror) : c), m !== void 0 ? m : u;
        };
      }
      function Ie(n, t) {
        return n === De ? t : function() {
          n.apply(this, arguments);
          var u = this.onsuccess, r = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), u && (this.onsuccess = this.onsuccess ? fe(u, this.onsuccess) : u), r && (this.onerror = this.onerror ? fe(r, this.onerror) : r);
        };
      }
      function we(n, t) {
        return n === De ? t : function(u) {
          var r = n.apply(this, arguments);
          h(u, r);
          var c = this.onsuccess, m = this.onerror;
          return this.onsuccess = null, this.onerror = null, u = t.apply(this, arguments), c && (this.onsuccess = this.onsuccess ? fe(c, this.onsuccess) : c), m && (this.onerror = this.onerror ? fe(m, this.onerror) : m), r === void 0 ? u === void 0 ? void 0 : u : h(r, u);
        };
      }
      function Ne(n, t) {
        return n === De ? t : function() {
          return t.apply(this, arguments) !== !1 && n.apply(this, arguments);
        };
      }
      function Ee(n, t) {
        return n === De ? t : function() {
          var u = n.apply(this, arguments);
          if (u && typeof u.then == "function") {
            for (var r = this, c = arguments.length, m = new Array(c); c--; ) m[c] = arguments[c];
            return u.then(function() {
              return t.apply(r, m);
            });
          }
          return t.apply(this, arguments);
        };
      }
      Qe.ModifyError = gn, Qe.DexieError = cn, Qe.BulkError = tn;
      var Oe = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function Pe(n) {
        Oe = n;
      }
      var Ke = {}, ke = 100, Ue = typeof Promise > "u" ? [] : function() {
        var n = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [n, x(n), n];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, x(t), n];
      }(), Ze = Ue[0], In = Ue[1], Ue = Ue[2], In = In && In.then, Je = Ze && Ze.constructor, yn = !!Ue, on = function(n, t) {
        Fn.push([n, t]), Tn && (queueMicrotask(Ja), Tn = !1);
      }, Bn = !0, Tn = !0, Dn = [], Nn = [], yl = j, Rn = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: De, pgp: !1, env: {}, finalize: De }, se = Rn, Fn = [], Zn = 0, Il = [];
      function ee(n) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = se;
        if (typeof n != "function") {
          if (n !== Ke) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && qt(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function u(r, c) {
          try {
            c(function(m) {
              if (r._state === null) {
                if (m === r) throw new TypeError("A promise cannot be resolved with itself.");
                var p = r._lib && rl();
                m && typeof m.then == "function" ? u(r, function(g, L) {
                  m instanceof ee ? m._then(g, L) : m.then(g, L);
                }) : (r._state = !0, r._value = m, Xi(r)), p && sl();
              }
            }, qt.bind(null, r));
          } catch (m) {
            qt(r, m);
          }
        }(this, n);
      }
      var Pt = { get: function() {
        var n = se, t = Hl;
        function u(r, c) {
          var m = this, p = !n.global && (n !== se || t !== Hl), g = p && !Kn(), L = new ee(function(O, w) {
            Rt(m, new Yi(Ji(r, n, p, g), Ji(c, n, p, g), O, w, n));
          });
          return this._consoleTask && (L._consoleTask = this._consoleTask), L;
        }
        return u.prototype = Ke, u;
      }, set: function(n) {
        E(this, "then", n && n.prototype === Ke ? Pt : { get: function() {
          return n;
        }, set: Pt.set });
      } };
      function Yi(n, t, u, r, c) {
        this.onFulfilled = typeof n == "function" ? n : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = u, this.reject = r, this.psd = c;
      }
      function qt(n, t) {
        var u, r;
        Nn.push(t), n._state === null && (u = n._lib && rl(), t = yl(t), n._state = !1, n._value = t, r = n, Dn.some(function(c) {
          return c._value === r._value;
        }) || Dn.push(r), Xi(n), u && sl());
      }
      function Xi(n) {
        var t = n._listeners;
        n._listeners = [];
        for (var u = 0, r = t.length; u < r; ++u) Rt(n, t[u]);
        var c = n._PSD;
        --c.ref || c.finalize(), Zn === 0 && (++Zn, on(function() {
          --Zn == 0 && At();
        }, []));
      }
      function Rt(n, t) {
        if (n._state !== null) {
          var u = n._state ? t.onFulfilled : t.onRejected;
          if (u === null) return (n._state ? t.resolve : t.reject)(n._value);
          ++t.psd.ref, ++Zn, on(Qa, [u, n, t]);
        } else n._listeners.push(t);
      }
      function Qa(n, t, u) {
        try {
          var r, c = t._value;
          !t._state && Nn.length && (Nn = []), r = Oe && t._consoleTask ? t._consoleTask.run(function() {
            return n(c);
          }) : n(c), t._state || Nn.indexOf(c) !== -1 || function(m) {
            for (var p = Dn.length; p; ) if (Dn[--p]._value === m._value) return Dn.splice(p, 1);
          }(t), u.resolve(r);
        } catch (m) {
          u.reject(m);
        } finally {
          --Zn == 0 && At(), --u.psd.ref || u.psd.finalize();
        }
      }
      function Ja() {
        Qn(Rn, function() {
          rl() && sl();
        });
      }
      function rl() {
        var n = Bn;
        return Tn = Bn = !1, n;
      }
      function sl() {
        var n, t, u;
        do
          for (; 0 < Fn.length; ) for (n = Fn, Fn = [], u = n.length, t = 0; t < u; ++t) {
            var r = n[t];
            r[0].apply(null, r[1]);
          }
        while (0 < Fn.length);
        Tn = Bn = !0;
      }
      function At() {
        var n = Dn;
        Dn = [], n.forEach(function(r) {
          r._PSD.onunhandled.call(null, r._value, r);
        });
        for (var t = Il.slice(0), u = t.length; u; ) t[--u]();
      }
      function Gl(n) {
        return new ee(Ke, !1, n);
      }
      function Be(n, t) {
        var u = se;
        return function() {
          var r = rl(), c = se;
          try {
            return Gn(u, !0), n.apply(this, arguments);
          } catch (m) {
            t && t(m);
          } finally {
            Gn(c, !1), r && sl();
          }
        };
      }
      q(ee.prototype, { then: Pt, _then: function(n, t) {
        Rt(this, new Yi(null, null, n, t, se));
      }, catch: function(n) {
        if (arguments.length === 1) return this.then(null, n);
        var t = n, u = arguments[1];
        return typeof t == "function" ? this.then(null, function(r) {
          return (r instanceof t ? u : Gl)(r);
        }) : this.then(null, function(r) {
          return (r && r.name === t ? u : Gl)(r);
        });
      }, finally: function(n) {
        return this.then(function(t) {
          return ee.resolve(n()).then(function() {
            return t;
          });
        }, function(t) {
          return ee.resolve(n()).then(function() {
            return Gl(t);
          });
        });
      }, timeout: function(n, t) {
        var u = this;
        return n < 1 / 0 ? new ee(function(r, c) {
          var m = setTimeout(function() {
            return c(new Z.Timeout(t));
          }, n);
          u.then(r, c).finally(clearTimeout.bind(null, m));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && E(ee.prototype, Symbol.toStringTag, "Dexie.Promise"), Rn.env = Qi(), q(ee, { all: function() {
        var n = Ae.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.length === 0 && t([]);
          var r = n.length;
          n.forEach(function(c, m) {
            return ee.resolve(c).then(function(p) {
              n[m] = p, --r || t(n);
            }, u);
          });
        });
      }, resolve: function(n) {
        return n instanceof ee ? n : n && typeof n.then == "function" ? new ee(function(t, u) {
          n.then(t, u);
        }) : new ee(Ke, !0, n);
      }, reject: Gl, race: function() {
        var n = Ae.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.map(function(r) {
            return ee.resolve(r).then(t, u);
          });
        });
      }, PSD: { get: function() {
        return se;
      }, set: function(n) {
        return se = n;
      } }, totalEchoes: { get: function() {
        return Hl;
      } }, newPSD: Un, usePSD: Qn, scheduler: { get: function() {
        return on;
      }, set: function(n) {
        on = n;
      } }, rejectionMapper: { get: function() {
        return yl;
      }, set: function(n) {
        yl = n;
      } }, follow: function(n, t) {
        return new ee(function(u, r) {
          return Un(function(c, m) {
            var p = se;
            p.unhandleds = [], p.onunhandled = m, p.finalize = fe(function() {
              var g, L = this;
              g = function() {
                L.unhandleds.length === 0 ? c() : m(L.unhandleds[0]);
              }, Il.push(function O() {
                g(), Il.splice(Il.indexOf(O), 1);
              }), ++Zn, on(function() {
                --Zn == 0 && At();
              }, []);
            }, p.finalize), n();
          }, t, u, r);
        });
      } }), Je && (Je.allSettled && E(ee, "allSettled", function() {
        var n = Ae.apply(null, arguments).map($l);
        return new ee(function(t) {
          n.length === 0 && t([]);
          var u = n.length, r = new Array(u);
          n.forEach(function(c, m) {
            return ee.resolve(c).then(function(p) {
              return r[m] = { status: "fulfilled", value: p };
            }, function(p) {
              return r[m] = { status: "rejected", reason: p };
            }).then(function() {
              return --u || t(r);
            });
          });
        });
      }), Je.any && typeof AggregateError < "u" && E(ee, "any", function() {
        var n = Ae.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.length === 0 && u(new AggregateError([]));
          var r = n.length, c = new Array(r);
          n.forEach(function(m, p) {
            return ee.resolve(m).then(function(g) {
              return t(g);
            }, function(g) {
              c[p] = g, --r || u(new AggregateError(c));
            });
          });
        });
      }), Je.withResolvers && (ee.withResolvers = Je.withResolvers));
      var en = { awaits: 0, echoes: 0, id: 0 }, er = 0, zl = [], jl = 0, Hl = 0, nr = 0;
      function Un(n, t, u, r) {
        var c = se, m = Object.create(c);
        return m.parent = c, m.ref = 0, m.global = !1, m.id = ++nr, Rn.env, m.env = yn ? { Promise: ee, PromiseProp: { value: ee, configurable: !0, writable: !0 }, all: ee.all, race: ee.race, allSettled: ee.allSettled, any: ee.any, resolve: ee.resolve, reject: ee.reject } : {}, t && h(m, t), ++c.ref, m.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, r = Qn(m, n, u, r), m.ref === 0 && m.finalize(), r;
      }
      function cl() {
        return en.id || (en.id = ++er), ++en.awaits, en.echoes += ke, en.id;
      }
      function Kn() {
        return !!en.awaits && (--en.awaits == 0 && (en.id = 0), en.echoes = en.awaits * ke, !0);
      }
      function $l(n) {
        return en.echoes && n && n.constructor === Je ? (cl(), n.then(function(t) {
          return Kn(), t;
        }, function(t) {
          return Kn(), He(t);
        })) : n;
      }
      function lr() {
        var n = zl[zl.length - 1];
        zl.pop(), Gn(n, !1);
      }
      function Gn(n, t) {
        var u, r = se;
        (t ? !en.echoes || jl++ && n === se : !jl || --jl && n === se) || queueMicrotask(t ? (function(c) {
          ++Hl, en.echoes && --en.echoes != 0 || (en.echoes = en.awaits = en.id = 0), zl.push(se), Gn(c, !0);
        }).bind(null, n) : lr), n !== se && (se = n, r === Rn && (Rn.env = Qi()), yn && (u = Rn.env.Promise, t = n.env, (r.global || n.global) && (Object.defineProperty(o, "Promise", t.PromiseProp), u.all = t.all, u.race = t.race, u.resolve = t.resolve, u.reject = t.reject, t.allSettled && (u.allSettled = t.allSettled), t.any && (u.any = t.any))));
      }
      function Qi() {
        var n = o.Promise;
        return yn ? { Promise: n, PromiseProp: Object.getOwnPropertyDescriptor(o, "Promise"), all: n.all, race: n.race, allSettled: n.allSettled, any: n.any, resolve: n.resolve, reject: n.reject } : {};
      }
      function Qn(n, t, u, r, c) {
        var m = se;
        try {
          return Gn(n, !0), t(u, r, c);
        } finally {
          Gn(m, !1);
        }
      }
      function Ji(n, t, u, r) {
        return typeof n != "function" ? n : function() {
          var c = se;
          u && cl(), Gn(t, !0);
          try {
            return n.apply(this, arguments);
          } finally {
            Gn(c, !1), r && queueMicrotask(Kn);
          }
        };
      }
      function Et(n) {
        Promise === Je && en.echoes === 0 ? jl === 0 ? n() : enqueueNativeMicroTask(n) : setTimeout(n, 0);
      }
      ("" + In).indexOf("[native code]") === -1 && (cl = Kn = De);
      var He = ee.reject, Jn = "", An = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", eu = "String expected.", ol = [], Wl = "__dbnames", _t = "readonly", Nt = "readwrite";
      function el(n, t) {
        return n ? t ? function() {
          return n.apply(this, arguments) && t.apply(this, arguments);
        } : n : t;
      }
      var nu = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Yl(n) {
        return typeof n != "string" || /\./.test(n) ? function(t) {
          return t;
        } : function(t) {
          return t[n] === void 0 && n in t && delete (t = ye(t))[n], t;
        };
      }
      function lu() {
        throw Z.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Te(n, t) {
        try {
          var u = tu(n), r = tu(t);
          if (u !== r) return u === "Array" ? 1 : r === "Array" ? -1 : u === "binary" ? 1 : r === "binary" ? -1 : u === "string" ? 1 : r === "string" ? -1 : u === "Date" ? 1 : r !== "Date" ? NaN : -1;
          switch (u) {
            case "number":
            case "Date":
            case "string":
              return t < n ? 1 : n < t ? -1 : 0;
            case "binary":
              return function(c, m) {
                for (var p = c.length, g = m.length, L = p < g ? p : g, O = 0; O < L; ++O) if (c[O] !== m[O]) return c[O] < m[O] ? -1 : 1;
                return p === g ? 0 : p < g ? -1 : 1;
              }(iu(n), iu(t));
            case "Array":
              return function(c, m) {
                for (var p = c.length, g = m.length, L = p < g ? p : g, O = 0; O < L; ++O) {
                  var w = Te(c[O], m[O]);
                  if (w !== 0) return w;
                }
                return p === g ? 0 : p < g ? -1 : 1;
              }(n, t);
          }
        } catch {
        }
        return NaN;
      }
      function tu(n) {
        var t = typeof n;
        return t != "object" ? t : ArrayBuffer.isView(n) ? "binary" : (n = Se(n), n === "ArrayBuffer" ? "binary" : n);
      }
      function iu(n) {
        return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n);
      }
      function Xl(n, t, u) {
        var r = n.schema.yProps;
        return r ? (t && 0 < u.numFailures && (t = t.filter(function(c, m) {
          return !u.failures[m];
        })), Promise.all(r.map(function(c) {
          return c = c.updatesTable, t ? n.db.table(c).where("k").anyOf(t).delete() : n.db.table(c).clear();
        })).then(function() {
          return u;
        })) : u;
      }
      var uu = (Ve.prototype._trans = function(n, t, u) {
        var r = this._tx || se.trans, c = this.name, m = Oe && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(n === "readonly" ? "read" : "write", " ").concat(this.name));
        function p(O, w, v) {
          if (!v.schema[c]) throw new Z.NotFound("Table " + c + " not part of transaction");
          return t(v.idbtrans, v);
        }
        var g = rl();
        try {
          var L = r && r.db._novip === this.db._novip ? r === se.trans ? r._promise(n, p, u) : Un(function() {
            return r._promise(n, p, u);
          }, { trans: r, transless: se.transless || se }) : function O(w, v, T, D) {
            if (w.idbdb && (w._state.openComplete || se.letThrough || w._vip)) {
              var b = w._createTransaction(v, T, w._dbSchema);
              try {
                b.create(), w._state.PR1398_maxLoop = 3;
              } catch (C) {
                return C.name === V.InvalidState && w.isOpen() && 0 < --w._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), w.close({ disableAutoOpen: !1 }), w.open().then(function() {
                  return O(w, v, T, D);
                })) : He(C);
              }
              return b._promise(v, function(C, S) {
                return Un(function() {
                  return se.trans = b, D(C, S, b);
                });
              }).then(function(C) {
                if (v === "readwrite") try {
                  b.idbtrans.commit();
                } catch {
                }
                return v === "readonly" ? C : b._completion.then(function() {
                  return C;
                });
              });
            }
            if (w._state.openComplete) return He(new Z.DatabaseClosed(w._state.dbOpenError));
            if (!w._state.isBeingOpened) {
              if (!w._state.autoOpen) return He(new Z.DatabaseClosed());
              w.open().catch(De);
            }
            return w._state.dbReadyPromise.then(function() {
              return O(w, v, T, D);
            });
          }(this.db, n, [this.name], p);
          return m && (L._consoleTask = m, L = L.catch(function(O) {
            return console.trace(O), He(O);
          })), L;
        } finally {
          g && sl();
        }
      }, Ve.prototype.get = function(n, t) {
        var u = this;
        return n && n.constructor === Object ? this.where(n).first(t) : n == null ? He(new Z.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(r) {
          return u.core.get({ trans: r, key: n }).then(function(c) {
            return u.hook.reading.fire(c);
          });
        }).then(t);
      }, Ve.prototype.where = function(n) {
        if (typeof n == "string") return new this.db.WhereClause(this, n);
        if (d(n)) return new this.db.WhereClause(this, "[".concat(n.join("+"), "]"));
        var t = f(n);
        if (t.length === 1) return this.where(t[0]).equals(n[t[0]]);
        var u = this.schema.indexes.concat(this.schema.primKey).filter(function(g) {
          if (g.compound && t.every(function(O) {
            return 0 <= g.keyPath.indexOf(O);
          })) {
            for (var L = 0; L < t.length; ++L) if (t.indexOf(g.keyPath[L]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(g, L) {
          return g.keyPath.length - L.keyPath.length;
        })[0];
        if (u && this.db._maxKey !== Jn) {
          var m = u.keyPath.slice(0, t.length);
          return this.where(m).equals(m.map(function(L) {
            return n[L];
          }));
        }
        !u && Oe && console.warn("The query ".concat(JSON.stringify(n), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var r = this.schema.idxByName;
        function c(g, L) {
          return Te(g, L) === 0;
        }
        var p = t.reduce(function(v, L) {
          var O = v[0], w = v[1], v = r[L], T = n[L];
          return [O || v, O || !v ? el(w, v && v.multi ? function(D) {
            return D = ae(D, L), d(D) && D.some(function(b) {
              return c(T, b);
            });
          } : function(D) {
            return c(T, ae(D, L));
          }) : w];
        }, [null, null]), m = p[0], p = p[1];
        return m ? this.where(m.name).equals(n[m.keyPath]).filter(p) : u ? this.filter(p) : this.where(t).equals("");
      }, Ve.prototype.filter = function(n) {
        return this.toCollection().and(n);
      }, Ve.prototype.count = function(n) {
        return this.toCollection().count(n);
      }, Ve.prototype.offset = function(n) {
        return this.toCollection().offset(n);
      }, Ve.prototype.limit = function(n) {
        return this.toCollection().limit(n);
      }, Ve.prototype.each = function(n) {
        return this.toCollection().each(n);
      }, Ve.prototype.toArray = function(n) {
        return this.toCollection().toArray(n);
      }, Ve.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ve.prototype.orderBy = function(n) {
        return new this.db.Collection(new this.db.WhereClause(this, d(n) ? "[".concat(n.join("+"), "]") : n));
      }, Ve.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ve.prototype.mapToClass = function(n) {
        var t, u = this.db, r = this.name;
        function c() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = n).prototype instanceof lu && (function(L, O) {
          if (typeof O != "function" && O !== null) throw new TypeError("Class extends value " + String(O) + " is not a constructor or null");
          function w() {
            this.constructor = L;
          }
          i(L, O), L.prototype = O === null ? Object.create(O) : (w.prototype = O.prototype, new w());
        }(c, t = n), Object.defineProperty(c.prototype, "db", { get: function() {
          return u;
        }, enumerable: !1, configurable: !0 }), c.prototype.table = function() {
          return r;
        }, n = c);
        for (var m = /* @__PURE__ */ new Set(), p = n.prototype; p; p = x(p)) Object.getOwnPropertyNames(p).forEach(function(L) {
          return m.add(L);
        });
        function g(L) {
          if (!L) return L;
          var O, w = Object.create(n.prototype);
          for (O in L) if (!m.has(O)) try {
            w[O] = L[O];
          } catch {
          }
          return w;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = g, this.hook("reading", g), n;
      }, Ve.prototype.defineClass = function() {
        return this.mapToClass(function(n) {
          h(this, n);
        });
      }, Ve.prototype.add = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, m = r.keyPath, p = n;
        return m && c && (p = Yl(m)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "add", keys: t != null ? [t] : null, values: [p] });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (m) try {
            ne(n, m, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.update = function(n, t) {
        return typeof n != "object" || d(n) ? this.where(":id").equals(n).modify(t) : (n = ae(n, this.schema.primKey.keyPath), n === void 0 ? He(new Z.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(n).modify(t));
      }, Ve.prototype.put = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, m = r.keyPath, p = n;
        return m && c && (p = Yl(m)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "put", values: [p], keys: t != null ? [t] : null });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (m) try {
            ne(n, m, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.delete = function(n) {
        var t = this;
        return this._trans("readwrite", function(u) {
          return t.core.mutate({ trans: u, type: "delete", keys: [n] }).then(function(r) {
            return Xl(t, [n], r);
          }).then(function(r) {
            return r.numFailures ? ee.reject(r.failures[0]) : void 0;
          });
        });
      }, Ve.prototype.clear = function() {
        var n = this;
        return this._trans("readwrite", function(t) {
          return n.core.mutate({ trans: t, type: "deleteRange", range: nu }).then(function(u) {
            return Xl(n, null, u);
          });
        }).then(function(t) {
          return t.numFailures ? ee.reject(t.failures[0]) : void 0;
        });
      }, Ve.prototype.bulkGet = function(n) {
        var t = this;
        return this._trans("readonly", function(u) {
          return t.core.getMany({ keys: n, trans: u }).then(function(r) {
            return r.map(function(c) {
              return t.hook.reading.fire(c);
            });
          });
        });
      }, Ve.prototype.bulkAdd = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, m = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new Z.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new Z.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Yl(O)) : n;
          return r.core.mutate({ trans: p, type: "add", keys: c, values: O, wantResults: m }).then(function(b) {
            var v = b.numFailures, T = b.results, D = b.lastResult, b = b.failures;
            if (v === 0) return m ? T : D;
            throw new tn("".concat(r.name, ".bulkAdd(): ").concat(v, " of ").concat(L, " operations failed"), b);
          });
        });
      }, Ve.prototype.bulkPut = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, m = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new Z.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new Z.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Yl(O)) : n;
          return r.core.mutate({ trans: p, type: "put", keys: c, values: O, wantResults: m }).then(function(b) {
            var v = b.numFailures, T = b.results, D = b.lastResult, b = b.failures;
            if (v === 0) return m ? T : D;
            throw new tn("".concat(r.name, ".bulkPut(): ").concat(v, " of ").concat(L, " operations failed"), b);
          });
        });
      }, Ve.prototype.bulkUpdate = function(n) {
        var t = this, u = this.core, r = n.map(function(p) {
          return p.key;
        }), c = n.map(function(p) {
          return p.changes;
        }), m = [];
        return this._trans("readwrite", function(p) {
          return u.getMany({ trans: p, keys: r, cache: "clone" }).then(function(g) {
            var L = [], O = [];
            n.forEach(function(v, T) {
              var D = v.key, b = v.changes, C = g[T];
              if (C) {
                for (var S = 0, P = Object.keys(b); S < P.length; S++) {
                  var A = P[S], N = b[A];
                  if (A === t.schema.primKey.keyPath) {
                    if (Te(N, D) !== 0) throw new Z.Constraint("Cannot update primary key in bulkUpdate()");
                  } else ne(C, A, N);
                }
                m.push(T), L.push(D), O.push(C);
              }
            });
            var w = L.length;
            return u.mutate({ trans: p, type: "put", keys: L, values: O, updates: { keys: r, changeSpecs: c } }).then(function(v) {
              var T = v.numFailures, D = v.failures;
              if (T === 0) return w;
              for (var b = 0, C = Object.keys(D); b < C.length; b++) {
                var S, P = C[b], A = m[Number(P)];
                A != null && (S = D[P], delete D[P], D[A] = S);
              }
              throw new tn("".concat(t.name, ".bulkUpdate(): ").concat(T, " of ").concat(w, " operations failed"), D);
            });
          });
        });
      }, Ve.prototype.bulkDelete = function(n) {
        var t = this, u = n.length;
        return this._trans("readwrite", function(r) {
          return t.core.mutate({ trans: r, type: "delete", keys: n }).then(function(c) {
            return Xl(t, n, c);
          });
        }).then(function(p) {
          var c = p.numFailures, m = p.lastResult, p = p.failures;
          if (c === 0) return m;
          throw new tn("".concat(t.name, ".bulkDelete(): ").concat(c, " of ").concat(u, " operations failed"), p);
        });
      }, Ve);
      function Ve() {
      }
      function Ll(n) {
        function t(p, g) {
          if (g) {
            for (var L = arguments.length, O = new Array(L - 1); --L; ) O[L - 1] = arguments[L];
            return u[p].subscribe.apply(null, O), n;
          }
          if (typeof p == "string") return u[p];
        }
        var u = {};
        t.addEventType = m;
        for (var r = 1, c = arguments.length; r < c; ++r) m(arguments[r]);
        return t;
        function m(p, g, L) {
          if (typeof p != "object") {
            var O;
            g = g || Ne;
            var w = { subscribers: [], fire: L = L || De, subscribe: function(v) {
              w.subscribers.indexOf(v) === -1 && (w.subscribers.push(v), w.fire = g(w.fire, v));
            }, unsubscribe: function(v) {
              w.subscribers = w.subscribers.filter(function(T) {
                return T !== v;
              }), w.fire = w.subscribers.reduce(g, L);
            } };
            return u[p] = t[p] = w;
          }
          f(O = p).forEach(function(v) {
            var T = O[v];
            if (d(T)) m(v, O[v][0], O[v][1]);
            else {
              if (T !== "asap") throw new Z.InvalidArgument("Invalid event config");
              var D = m(v, j, function() {
                for (var b = arguments.length, C = new Array(b); b--; ) C[b] = arguments[b];
                D.subscribers.forEach(function(S) {
                  W(function() {
                    S.apply(null, C);
                  });
                });
              });
            }
          });
        }
      }
      function Dl(n, t) {
        return M(t).from({ prototype: n }), t;
      }
      function ml(n, t) {
        return !(n.filter || n.algorithm || n.or) && (t ? n.justLimit : !n.replayFilter);
      }
      function Ft(n, t) {
        n.filter = el(n.filter, t);
      }
      function Mt(n, t, u) {
        var r = n.replayFilter;
        n.replayFilter = r ? function() {
          return el(r(), t());
        } : t, n.justLimit = u && !r;
      }
      function Ql(n, t) {
        if (n.isPrimKey) return t.primaryKey;
        var u = t.getIndexByKeyPath(n.index);
        if (!u) throw new Z.Schema("KeyPath " + n.index + " on object store " + t.name + " is not indexed");
        return u;
      }
      function au(n, t, u) {
        var r = Ql(n, t.schema);
        return t.openCursor({ trans: u, values: !n.keysOnly, reverse: n.dir === "prev", unique: !!n.unique, query: { index: r, range: n.range } });
      }
      function Jl(n, t, u, r) {
        var c = n.replayFilter ? el(n.filter, n.replayFilter()) : n.filter;
        if (n.or) {
          var m = {}, p = function(g, L, O) {
            var w, v;
            c && !c(L, O, function(T) {
              return L.stop(T);
            }, function(T) {
              return L.fail(T);
            }) || ((v = "" + (w = L.primaryKey)) == "[object ArrayBuffer]" && (v = "" + new Uint8Array(w)), I(m, v) || (m[v] = !0, t(g, L, O)));
          };
          return Promise.all([n.or._iterate(p, u), ru(au(n, r, u), n.algorithm, p, !n.keysOnly && n.valueMapper)]);
        }
        return ru(au(n, r, u), el(n.algorithm, c), t, !n.keysOnly && n.valueMapper);
      }
      function ru(n, t, u, r) {
        var c = Be(r ? function(m, p, g) {
          return u(r(m), p, g);
        } : u);
        return n.then(function(m) {
          if (m) return m.start(function() {
            var p = function() {
              return m.continue();
            };
            t && !t(m, function(g) {
              return p = g;
            }, function(g) {
              m.stop(g), p = De;
            }, function(g) {
              m.fail(g), p = De;
            }) || c(m.value, m, function(g) {
              return p = g;
            }), p();
          });
        });
      }
      var Ol = (su.prototype.execute = function(n) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var u = t.add;
          if (d(u)) return s(s([], d(n) ? n : [], !0), u).sort();
          if (typeof u == "number") return (Number(n) || 0) + u;
          if (typeof u == "bigint") try {
            return BigInt(n) + u;
          } catch {
            return BigInt(0) + u;
          }
          throw new TypeError("Invalid term ".concat(u));
        }
        if (t.remove !== void 0) {
          var r = t.remove;
          if (d(r)) return d(n) ? n.filter(function(c) {
            return !r.includes(c);
          }).sort() : [];
          if (typeof r == "number") return Number(n) - r;
          if (typeof r == "bigint") try {
            return BigInt(n) - r;
          } catch {
            return BigInt(0) - r;
          }
          throw new TypeError("Invalid subtrahend ".concat(r));
        }
        return u = (u = t.replacePrefix) === null || u === void 0 ? void 0 : u[0], u && typeof n == "string" && n.startsWith(u) ? t.replacePrefix[1] + n.substring(u.length) : n;
      }, su);
      function su(n) {
        this["@@propmod"] = n;
      }
      var tr = (Re.prototype._read = function(n, t) {
        var u = this._ctx;
        return u.error ? u.table._trans(null, He.bind(null, u.error)) : u.table._trans("readonly", n).then(t);
      }, Re.prototype._write = function(n) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, He.bind(null, t.error)) : t.table._trans("readwrite", n, "locked");
      }, Re.prototype._addAlgorithm = function(n) {
        var t = this._ctx;
        t.algorithm = el(t.algorithm, n);
      }, Re.prototype._iterate = function(n, t) {
        return Jl(this._ctx, n, t, this._ctx.table.core);
      }, Re.prototype.clone = function(n) {
        var t = Object.create(this.constructor.prototype), u = Object.create(this._ctx);
        return n && h(u, n), t._ctx = u, t;
      }, Re.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Re.prototype.each = function(n) {
        var t = this._ctx;
        return this._read(function(u) {
          return Jl(t, n, u, t.table.core);
        });
      }, Re.prototype.count = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx, c = r.table.core;
          if (ml(r, !0)) return c.count({ trans: u, query: { index: Ql(r, c.schema), range: r.range } }).then(function(p) {
            return Math.min(p, r.limit);
          });
          var m = 0;
          return Jl(r, function() {
            return ++m, !1;
          }, u, c).then(function() {
            return m;
          });
        }).then(n);
      }, Re.prototype.sortBy = function(n, t) {
        var u = n.split(".").reverse(), r = u[0], c = u.length - 1;
        function m(L, O) {
          return O ? m(L[u[O]], O - 1) : L[r];
        }
        var p = this._ctx.dir === "next" ? 1 : -1;
        function g(L, O) {
          return Te(m(L, c), m(O, c)) * p;
        }
        return this.toArray(function(L) {
          return L.sort(g);
        }).then(t);
      }, Re.prototype.toArray = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx;
          if (r.dir === "next" && ml(r, !0) && 0 < r.limit) {
            var c = r.valueMapper, m = Ql(r, r.table.core.schema);
            return r.table.core.query({ trans: u, limit: r.limit, values: !0, query: { index: m, range: r.range } }).then(function(g) {
              return g = g.result, c ? g.map(c) : g;
            });
          }
          var p = [];
          return Jl(r, function(g) {
            return p.push(g);
          }, u, r.table.core).then(function() {
            return p;
          });
        }, n);
      }, Re.prototype.offset = function(n) {
        var t = this._ctx;
        return n <= 0 || (t.offset += n, ml(t) ? Mt(t, function() {
          var u = n;
          return function(r, c) {
            return u === 0 || (u === 1 ? --u : c(function() {
              r.advance(u), u = 0;
            }), !1);
          };
        }) : Mt(t, function() {
          var u = n;
          return function() {
            return --u < 0;
          };
        })), this;
      }, Re.prototype.limit = function(n) {
        return this._ctx.limit = Math.min(this._ctx.limit, n), Mt(this._ctx, function() {
          var t = n;
          return function(u, r, c) {
            return --t <= 0 && r(c), 0 <= t;
          };
        }, !0), this;
      }, Re.prototype.until = function(n, t) {
        return Ft(this._ctx, function(u, r, c) {
          return !n(u.value) || (r(c), t);
        }), this;
      }, Re.prototype.first = function(n) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(n);
      }, Re.prototype.last = function(n) {
        return this.reverse().first(n);
      }, Re.prototype.filter = function(n) {
        var t;
        return Ft(this._ctx, function(u) {
          return n(u.value);
        }), (t = this._ctx).isMatch = el(t.isMatch, n), this;
      }, Re.prototype.and = function(n) {
        return this.filter(n);
      }, Re.prototype.or = function(n) {
        return new this.db.WhereClause(this._ctx.table, n, this);
      }, Re.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Re.prototype.desc = function() {
        return this.reverse();
      }, Re.prototype.eachKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.key, r);
        });
      }, Re.prototype.eachUniqueKey = function(n) {
        return this._ctx.unique = "unique", this.eachKey(n);
      }, Re.prototype.eachPrimaryKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.primaryKey, r);
        });
      }, Re.prototype.keys = function(n) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.key);
        }).then(function() {
          return u;
        }).then(n);
      }, Re.prototype.primaryKeys = function(n) {
        var t = this._ctx;
        if (t.dir === "next" && ml(t, !0) && 0 < t.limit) return this._read(function(r) {
          var c = Ql(t, t.table.core.schema);
          return t.table.core.query({ trans: r, values: !1, limit: t.limit, query: { index: c, range: t.range } });
        }).then(function(r) {
          return r.result;
        }).then(n);
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.primaryKey);
        }).then(function() {
          return u;
        }).then(n);
      }, Re.prototype.uniqueKeys = function(n) {
        return this._ctx.unique = "unique", this.keys(n);
      }, Re.prototype.firstKey = function(n) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(n);
      }, Re.prototype.lastKey = function(n) {
        return this.reverse().firstKey(n);
      }, Re.prototype.distinct = function() {
        var n = this._ctx, n = n.index && n.table.schema.idxByName[n.index];
        if (!n || !n.multi) return this;
        var t = {};
        return Ft(this._ctx, function(c) {
          var r = c.primaryKey.toString(), c = I(t, r);
          return t[r] = !0, !c;
        }), this;
      }, Re.prototype.modify = function(n) {
        var t = this, u = this._ctx;
        return this._write(function(r) {
          var c, m, p;
          p = typeof n == "function" ? n : (c = f(n), m = c.length, function(P) {
            for (var A = !1, N = 0; N < m; ++N) {
              var F = c[N], G = n[F], Y = ae(P, F);
              G instanceof Ol ? (ne(P, F, G.execute(Y)), A = !0) : Y !== G && (ne(P, F, G), A = !0);
            }
            return A;
          });
          var g = u.table.core, v = g.schema.primaryKey, L = v.outbound, O = v.extractKey, w = 200, v = t.db._options.modifyChunkSize;
          v && (w = typeof v == "object" ? v[g.name] || v["*"] || 200 : v);
          function T(P, F) {
            var N = F.failures, F = F.numFailures;
            b += P - F;
            for (var G = 0, Y = f(N); G < Y.length; G++) {
              var H = Y[G];
              D.push(N[H]);
            }
          }
          var D = [], b = 0, C = [], S = n === cu;
          return t.clone().primaryKeys().then(function(P) {
            function A(F) {
              var G = Math.min(w, P.length - F), Y = P.slice(F, F + G);
              return (S ? Promise.resolve([]) : g.getMany({ trans: r, keys: Y, cache: "immutable" })).then(function(H) {
                var $ = [], J = [], Q = L ? [] : null, le = S ? Y : [];
                if (!S) for (var ve = 0; ve < G; ++ve) {
                  var qe = H[ve], he = { value: ye(qe), primKey: P[F + ve] };
                  p.call(he, he.value, he) !== !1 && (he.value == null ? le.push(P[F + ve]) : L || Te(O(qe), O(he.value)) === 0 ? (J.push(he.value), L && Q.push(P[F + ve])) : (le.push(P[F + ve]), $.push(he.value)));
                }
                return Promise.resolve(0 < $.length && g.mutate({ trans: r, type: "add", values: $ }).then(function(Ge) {
                  for (var pe in Ge.failures) le.splice(parseInt(pe), 1);
                  T($.length, Ge);
                })).then(function() {
                  return (0 < J.length || N && typeof n == "object") && g.mutate({ trans: r, type: "put", keys: Q, values: J, criteria: N, changeSpec: typeof n != "function" && n, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return T(J.length, Ge);
                  });
                }).then(function() {
                  return (0 < le.length || N && S) && g.mutate({ trans: r, type: "delete", keys: le, criteria: N, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return Xl(u.table, le, Ge);
                  }).then(function(Ge) {
                    return T(le.length, Ge);
                  });
                }).then(function() {
                  return P.length > F + G && A(F + w);
                });
              });
            }
            var N = ml(u) && u.limit === 1 / 0 && (typeof n != "function" || S) && { index: u.index, range: u.range };
            return A(0).then(function() {
              if (0 < D.length) throw new gn("Error modifying one or more objects", D, b, C);
              return P.length;
            });
          });
        });
      }, Re.prototype.delete = function() {
        var n = this._ctx, t = n.range;
        return !ml(n) || n.table.schema.yProps || !n.isPrimKey && t.type !== 3 ? this.modify(cu) : this._write(function(u) {
          var r = n.table.core.schema.primaryKey, c = t;
          return n.table.core.count({ trans: u, query: { index: r, range: c } }).then(function(m) {
            return n.table.core.mutate({ trans: u, type: "deleteRange", range: c }).then(function(L) {
              var g = L.failures, L = L.numFailures;
              if (L) throw new gn("Could not delete some values", Object.keys(g).map(function(O) {
                return g[O];
              }), m - L);
              return m - L;
            });
          });
        });
      }, Re);
      function Re() {
      }
      var cu = function(n, t) {
        return t.value = null;
      };
      function ir(n, t) {
        return n < t ? -1 : n === t ? 0 : 1;
      }
      function ur(n, t) {
        return t < n ? -1 : n === t ? 0 : 1;
      }
      function pn(n, t, u) {
        return n = n instanceof mu ? new n.Collection(n) : n, n._ctx.error = new (u || TypeError)(t), n;
      }
      function fl(n) {
        return new n.Collection(n, function() {
          return ou("");
        }).limit(0);
      }
      function et(n, t, u, r) {
        var c, m, p, g, L, O, w, v = u.length;
        if (!u.every(function(b) {
          return typeof b == "string";
        })) return pn(n, eu);
        function T(b) {
          c = b === "next" ? function(S) {
            return S.toUpperCase();
          } : function(S) {
            return S.toLowerCase();
          }, m = b === "next" ? function(S) {
            return S.toLowerCase();
          } : function(S) {
            return S.toUpperCase();
          }, p = b === "next" ? ir : ur;
          var C = u.map(function(S) {
            return { lower: m(S), upper: c(S) };
          }).sort(function(S, P) {
            return p(S.lower, P.lower);
          });
          g = C.map(function(S) {
            return S.upper;
          }), L = C.map(function(S) {
            return S.lower;
          }), w = (O = b) === "next" ? "" : r;
        }
        T("next"), n = new n.Collection(n, function() {
          return zn(g[0], L[v - 1] + r);
        }), n._ondirectionchange = function(b) {
          T(b);
        };
        var D = 0;
        return n._addAlgorithm(function(b, C, S) {
          var P = b.key;
          if (typeof P != "string") return !1;
          var A = m(P);
          if (t(A, L, D)) return !0;
          for (var N = null, F = D; F < v; ++F) {
            var G = function(Y, H, $, J, Q, le) {
              for (var ve = Math.min(Y.length, J.length), qe = -1, he = 0; he < ve; ++he) {
                var Ge = H[he];
                if (Ge !== J[he]) return Q(Y[he], $[he]) < 0 ? Y.substr(0, he) + $[he] + $.substr(he + 1) : Q(Y[he], J[he]) < 0 ? Y.substr(0, he) + J[he] + $.substr(he + 1) : 0 <= qe ? Y.substr(0, qe) + H[qe] + $.substr(qe + 1) : null;
                Q(Y[he], Ge) < 0 && (qe = he);
              }
              return ve < J.length && le === "next" ? Y + $.substr(Y.length) : ve < Y.length && le === "prev" ? Y.substr(0, $.length) : qe < 0 ? null : Y.substr(0, qe) + J[qe] + $.substr(qe + 1);
            }(P, A, g[F], L[F], p, O);
            G === null && N === null ? D = F + 1 : (N === null || 0 < p(N, G)) && (N = G);
          }
          return C(N !== null ? function() {
            b.continue(N + w);
          } : S), !1;
        }), n;
      }
      function zn(n, t, u, r) {
        return { type: 2, lower: n, upper: t, lowerOpen: u, upperOpen: r };
      }
      function ou(n) {
        return { type: 1, lower: n, upper: n };
      }
      var mu = (Object.defineProperty(nn.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), nn.prototype.between = function(n, t, u, r) {
        u = u !== !1, r = r === !0;
        try {
          return 0 < this._cmp(n, t) || this._cmp(n, t) === 0 && (u || r) && (!u || !r) ? fl(this) : new this.Collection(this, function() {
            return zn(n, t, !u, !r);
          });
        } catch {
          return pn(this, An);
        }
      }, nn.prototype.equals = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return ou(n);
        });
      }, nn.prototype.above = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return zn(n, void 0, !0);
        });
      }, nn.prototype.aboveOrEqual = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return zn(n, void 0, !1);
        });
      }, nn.prototype.below = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return zn(void 0, n, !1, !0);
        });
      }, nn.prototype.belowOrEqual = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return zn(void 0, n);
        });
      }, nn.prototype.startsWith = function(n) {
        return typeof n != "string" ? pn(this, eu) : this.between(n, n + Jn, !0, !0);
      }, nn.prototype.startsWithIgnoreCase = function(n) {
        return n === "" ? this.startsWith(n) : et(this, function(t, u) {
          return t.indexOf(u[0]) === 0;
        }, [n], Jn);
      }, nn.prototype.equalsIgnoreCase = function(n) {
        return et(this, function(t, u) {
          return t === u[0];
        }, [n], "");
      }, nn.prototype.anyOfIgnoreCase = function() {
        var n = Ae.apply(Le, arguments);
        return n.length === 0 ? fl(this) : et(this, function(t, u) {
          return u.indexOf(t) !== -1;
        }, n, "");
      }, nn.prototype.startsWithAnyOfIgnoreCase = function() {
        var n = Ae.apply(Le, arguments);
        return n.length === 0 ? fl(this) : et(this, function(t, u) {
          return u.some(function(r) {
            return t.indexOf(r) === 0;
          });
        }, n, Jn);
      }, nn.prototype.anyOf = function() {
        var n = this, t = Ae.apply(Le, arguments), u = this._cmp;
        try {
          t.sort(u);
        } catch {
          return pn(this, An);
        }
        if (t.length === 0) return fl(this);
        var r = new this.Collection(this, function() {
          return zn(t[0], t[t.length - 1]);
        });
        r._ondirectionchange = function(m) {
          u = m === "next" ? n._ascending : n._descending, t.sort(u);
        };
        var c = 0;
        return r._addAlgorithm(function(m, p, g) {
          for (var L = m.key; 0 < u(L, t[c]); ) if (++c === t.length) return p(g), !1;
          return u(L, t[c]) === 0 || (p(function() {
            m.continue(t[c]);
          }), !1);
        }), r;
      }, nn.prototype.notEqual = function(n) {
        return this.inAnyRange([[-1 / 0, n], [n, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, nn.prototype.noneOf = function() {
        var n = Ae.apply(Le, arguments);
        if (n.length === 0) return new this.Collection(this);
        try {
          n.sort(this._ascending);
        } catch {
          return pn(this, An);
        }
        var t = n.reduce(function(u, r) {
          return u ? u.concat([[u[u.length - 1][1], r]]) : [[-1 / 0, r]];
        }, null);
        return t.push([n[n.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, nn.prototype.inAnyRange = function(P, t) {
        var u = this, r = this._cmp, c = this._ascending, m = this._descending, p = this._min, g = this._max;
        if (P.length === 0) return fl(this);
        if (!P.every(function(A) {
          return A[0] !== void 0 && A[1] !== void 0 && c(A[0], A[1]) <= 0;
        })) return pn(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Z.InvalidArgument);
        var L = !t || t.includeLowers !== !1, O = t && t.includeUppers === !0, w, v = c;
        function T(A, N) {
          return v(A[0], N[0]);
        }
        try {
          (w = P.reduce(function(A, N) {
            for (var F = 0, G = A.length; F < G; ++F) {
              var Y = A[F];
              if (r(N[0], Y[1]) < 0 && 0 < r(N[1], Y[0])) {
                Y[0] = p(Y[0], N[0]), Y[1] = g(Y[1], N[1]);
                break;
              }
            }
            return F === G && A.push(N), A;
          }, [])).sort(T);
        } catch {
          return pn(this, An);
        }
        var D = 0, b = O ? function(A) {
          return 0 < c(A, w[D][1]);
        } : function(A) {
          return 0 <= c(A, w[D][1]);
        }, C = L ? function(A) {
          return 0 < m(A, w[D][0]);
        } : function(A) {
          return 0 <= m(A, w[D][0]);
        }, S = b, P = new this.Collection(this, function() {
          return zn(w[0][0], w[w.length - 1][1], !L, !O);
        });
        return P._ondirectionchange = function(A) {
          v = A === "next" ? (S = b, c) : (S = C, m), w.sort(T);
        }, P._addAlgorithm(function(A, N, F) {
          for (var G, Y = A.key; S(Y); ) if (++D === w.length) return N(F), !1;
          return !b(G = Y) && !C(G) || (u._cmp(Y, w[D][1]) === 0 || u._cmp(Y, w[D][0]) === 0 || N(function() {
            v === c ? A.continue(w[D][0]) : A.continue(w[D][1]);
          }), !1);
        }), P;
      }, nn.prototype.startsWithAnyOf = function() {
        var n = Ae.apply(Le, arguments);
        return n.every(function(t) {
          return typeof t == "string";
        }) ? n.length === 0 ? fl(this) : this.inAnyRange(n.map(function(t) {
          return [t, t + Jn];
        })) : pn(this, "startsWithAnyOf() only works with strings");
      }, nn);
      function nn() {
      }
      function wn(n) {
        return Be(function(t) {
          return bl(t), n(t.target.error), !1;
        });
      }
      function bl(n) {
        n.stopPropagation && n.stopPropagation(), n.preventDefault && n.preventDefault();
      }
      var wl = "storagemutated", kt = "x-storagemutated-1", jn = Ll(null, wl), ar = (Sn.prototype._lock = function() {
        return K(!se.global), ++this._reculock, this._reculock !== 1 || se.global || (se.lockOwnerFor = this), this;
      }, Sn.prototype._unlock = function() {
        if (K(!se.global), --this._reculock == 0) for (se.global || (se.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var n = this._blockedFuncs.shift();
          try {
            Qn(n[1], n[0]);
          } catch {
          }
        }
        return this;
      }, Sn.prototype._locked = function() {
        return this._reculock && se.lockOwnerFor !== this;
      }, Sn.prototype.create = function(n) {
        var t = this;
        if (!this.mode) return this;
        var u = this.db.idbdb, r = this.db._state.dbOpenError;
        if (K(!this.idbtrans), !n && !u) switch (r && r.name) {
          case "DatabaseClosedError":
            throw new Z.DatabaseClosed(r);
          case "MissingAPIError":
            throw new Z.MissingAPI(r.message, r);
          default:
            throw new Z.OpenFailed(r);
        }
        if (!this.active) throw new Z.TransactionInactive();
        return K(this._completion._state === null), (n = this.idbtrans = n || (this.db.core || u).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Be(function(c) {
          bl(c), t._reject(n.error);
        }), n.onabort = Be(function(c) {
          bl(c), t.active && t._reject(new Z.Abort(n.error)), t.active = !1, t.on("abort").fire(c);
        }), n.oncomplete = Be(function() {
          t.active = !1, t._resolve(), "mutatedParts" in n && jn.storagemutated.fire(n.mutatedParts);
        }), this;
      }, Sn.prototype._promise = function(n, t, u) {
        var r = this;
        if (n === "readwrite" && this.mode !== "readwrite") return He(new Z.ReadOnly("Transaction is readonly"));
        if (!this.active) return He(new Z.TransactionInactive());
        if (this._locked()) return new ee(function(m, p) {
          r._blockedFuncs.push([function() {
            r._promise(n, t, u).then(m, p);
          }, se]);
        });
        if (u) return Un(function() {
          var m = new ee(function(p, g) {
            r._lock();
            var L = t(p, g, r);
            L && L.then && L.then(p, g);
          });
          return m.finally(function() {
            return r._unlock();
          }), m._lib = !0, m;
        });
        var c = new ee(function(m, p) {
          var g = t(m, p, r);
          g && g.then && g.then(m, p);
        });
        return c._lib = !0, c;
      }, Sn.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Sn.prototype.waitFor = function(n) {
        var t, u = this._root(), r = ee.resolve(n);
        u._waitingFor ? u._waitingFor = u._waitingFor.then(function() {
          return r;
        }) : (u._waitingFor = r, u._waitingQueue = [], t = u.idbtrans.objectStore(u.storeNames[0]), function m() {
          for (++u._spinCount; u._waitingQueue.length; ) u._waitingQueue.shift()();
          u._waitingFor && (t.get(-1 / 0).onsuccess = m);
        }());
        var c = u._waitingFor;
        return new ee(function(m, p) {
          r.then(function(g) {
            return u._waitingQueue.push(Be(m.bind(null, g)));
          }, function(g) {
            return u._waitingQueue.push(Be(p.bind(null, g)));
          }).finally(function() {
            u._waitingFor === c && (u._waitingFor = null);
          });
        });
      }, Sn.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new Z.Abort()));
      }, Sn.prototype.table = function(n) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (I(t, n)) return t[n];
        var u = this.schema[n];
        if (!u) throw new Z.NotFound("Table " + n + " not part of transaction");
        return u = new this.db.Table(n, u, this), u.core = this.db.core.table(n), t[n] = u;
      }, Sn);
      function Sn() {
      }
      function Vt(n, t, u, r, c, m, p, g) {
        return { name: n, keyPath: t, unique: u, multi: r, auto: c, compound: m, src: (u && !p ? "&" : "") + (r ? "*" : "") + (c ? "++" : "") + fu(t), type: g };
      }
      function fu(n) {
        return typeof n == "string" ? n : n ? "[" + [].join.call(n, "+") + "]" : "";
      }
      function Bt(n, t, u) {
        return { name: n, primKey: t, indexes: u, mappedClass: null, idxByName: (r = function(c) {
          return [c.name, c];
        }, u.reduce(function(c, m, p) {
          return p = r(m, p), p && (c[p[0]] = p[1]), c;
        }, {})) };
        var r;
      }
      var Sl = function(n) {
        try {
          return n.only([[]]), Sl = function() {
            return [[]];
          }, [[]];
        } catch {
          return Sl = function() {
            return Jn;
          }, Jn;
        }
      };
      function Zt(n) {
        return n == null ? function() {
        } : typeof n == "string" ? (t = n).split(".").length === 1 ? function(u) {
          return u[t];
        } : function(u) {
          return ae(u, t);
        } : function(u) {
          return ae(u, n);
        };
        var t;
      }
      function du(n) {
        return [].slice.call(n);
      }
      var rr = 0;
      function Cl(n) {
        return n == null ? ":id" : typeof n == "string" ? n : "[".concat(n.join("+"), "]");
      }
      function sr(n, t, L) {
        function r(S) {
          if (S.type === 3) return null;
          if (S.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var D = S.lower, b = S.upper, C = S.lowerOpen, S = S.upperOpen;
          return D === void 0 ? b === void 0 ? null : t.upperBound(b, !!S) : b === void 0 ? t.lowerBound(D, !!C) : t.bound(D, b, !!C, !!S);
        }
        function c(T) {
          var D, b = T.name;
          return { name: b, schema: T, mutate: function(C) {
            var S = C.trans, P = C.type, A = C.keys, N = C.values, F = C.range;
            return new Promise(function(G, Y) {
              G = Be(G);
              var H = S.objectStore(b), $ = H.keyPath == null, J = P === "put" || P === "add";
              if (!J && P !== "delete" && P !== "deleteRange") throw new Error("Invalid operation type: " + P);
              var Q, le = (A || N || { length: 1 }).length;
              if (A && N && A.length !== N.length) throw new Error("Given keys array must have same length as given values array.");
              if (le === 0) return G({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ve(mn) {
                ++Ge, bl(mn);
              }
              var qe = [], he = [], Ge = 0;
              if (P === "deleteRange") {
                if (F.type === 4) return G({ numFailures: Ge, failures: he, results: [], lastResult: void 0 });
                F.type === 3 ? qe.push(Q = H.clear()) : qe.push(Q = H.delete(r(F)));
              } else {
                var $ = J ? $ ? [N, A] : [N, null] : [A, null], pe = $[0], an = $[1];
                if (J) for (var rn = 0; rn < le; ++rn) qe.push(Q = an && an[rn] !== void 0 ? H[P](pe[rn], an[rn]) : H[P](pe[rn])), Q.onerror = ve;
                else for (rn = 0; rn < le; ++rn) qe.push(Q = H[P](pe[rn])), Q.onerror = ve;
              }
              function ft(mn) {
                mn = mn.target.result, qe.forEach(function(tl, ui) {
                  return tl.error != null && (he[ui] = tl.error);
                }), G({ numFailures: Ge, failures: he, results: P === "delete" ? A : qe.map(function(tl) {
                  return tl.result;
                }), lastResult: mn });
              }
              Q.onerror = function(mn) {
                ve(mn), ft(mn);
              }, Q.onsuccess = ft;
            });
          }, getMany: function(C) {
            var S = C.trans, P = C.keys;
            return new Promise(function(A, N) {
              A = Be(A);
              for (var F, G = S.objectStore(b), Y = P.length, H = new Array(Y), $ = 0, J = 0, Q = function(qe) {
                qe = qe.target, H[qe._pos] = qe.result, ++J === $ && A(H);
              }, le = wn(N), ve = 0; ve < Y; ++ve) P[ve] != null && ((F = G.get(P[ve]))._pos = ve, F.onsuccess = Q, F.onerror = le, ++$);
              $ === 0 && A(H);
            });
          }, get: function(C) {
            var S = C.trans, P = C.key;
            return new Promise(function(A, N) {
              A = Be(A);
              var F = S.objectStore(b).get(P);
              F.onsuccess = function(G) {
                return A(G.target.result);
              }, F.onerror = wn(N);
            });
          }, query: (D = O, function(C) {
            return new Promise(function(S, P) {
              S = Be(S);
              var A, N, F, $ = C.trans, G = C.values, Y = C.limit, Q = C.query, H = Y === 1 / 0 ? void 0 : Y, J = Q.index, Q = Q.range, $ = $.objectStore(b), J = J.isPrimaryKey ? $ : $.index(J.name), Q = r(Q);
              if (Y === 0) return S({ result: [] });
              D ? ((H = G ? J.getAll(Q, H) : J.getAllKeys(Q, H)).onsuccess = function(le) {
                return S({ result: le.target.result });
              }, H.onerror = wn(P)) : (A = 0, N = !G && "openKeyCursor" in J ? J.openKeyCursor(Q) : J.openCursor(Q), F = [], N.onsuccess = function(le) {
                var ve = N.result;
                return ve ? (F.push(G ? ve.value : ve.primaryKey), ++A === Y ? S({ result: F }) : void ve.continue()) : S({ result: F });
              }, N.onerror = wn(P));
            });
          }), openCursor: function(C) {
            var S = C.trans, P = C.values, A = C.query, N = C.reverse, F = C.unique;
            return new Promise(function(G, Y) {
              G = Be(G);
              var J = A.index, H = A.range, $ = S.objectStore(b), $ = J.isPrimaryKey ? $ : $.index(J.name), J = N ? F ? "prevunique" : "prev" : F ? "nextunique" : "next", Q = !P && "openKeyCursor" in $ ? $.openKeyCursor(r(H), J) : $.openCursor(r(H), J);
              Q.onerror = wn(Y), Q.onsuccess = Be(function(le) {
                var ve, qe, he, Ge, pe = Q.result;
                pe ? (pe.___id = ++rr, pe.done = !1, ve = pe.continue.bind(pe), qe = (qe = pe.continuePrimaryKey) && qe.bind(pe), he = pe.advance.bind(pe), Ge = function() {
                  throw new Error("Cursor not stopped");
                }, pe.trans = S, pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = function() {
                  throw new Error("Cursor not started");
                }, pe.fail = Be(Y), pe.next = function() {
                  var an = this, rn = 1;
                  return this.start(function() {
                    return rn-- ? an.continue() : an.stop();
                  }).then(function() {
                    return an;
                  });
                }, pe.start = function(an) {
                  function rn() {
                    if (Q.result) try {
                      an();
                    } catch (mn) {
                      pe.fail(mn);
                    }
                    else pe.done = !0, pe.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, pe.stop();
                  }
                  var ft = new Promise(function(mn, tl) {
                    mn = Be(mn), Q.onerror = wn(tl), pe.fail = tl, pe.stop = function(ui) {
                      pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = Ge, mn(ui);
                    };
                  });
                  return Q.onsuccess = Be(function(mn) {
                    Q.onsuccess = rn, rn();
                  }), pe.continue = ve, pe.continuePrimaryKey = qe, pe.advance = he, rn(), ft;
                }, G(pe)) : G(null);
              }, Y);
            });
          }, count: function(C) {
            var S = C.query, P = C.trans, A = S.index, N = S.range;
            return new Promise(function(F, G) {
              var Y = P.objectStore(b), H = A.isPrimaryKey ? Y : Y.index(A.name), Y = r(N), H = Y ? H.count(Y) : H.count();
              H.onsuccess = Be(function($) {
                return F($.target.result);
              }), H.onerror = wn(G);
            });
          } };
        }
        var m, p, g, w = (p = L, g = du((m = n).objectStoreNames), { schema: { name: m.name, tables: g.map(function(T) {
          return p.objectStore(T);
        }).map(function(T) {
          var D = T.keyPath, S = T.autoIncrement, b = d(D), C = {}, S = { name: T.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: D == null, compound: b, keyPath: D, autoIncrement: S, unique: !0, extractKey: Zt(D) }, indexes: du(T.indexNames).map(function(P) {
            return T.index(P);
          }).map(function(F) {
            var A = F.name, N = F.unique, G = F.multiEntry, F = F.keyPath, G = { name: A, compound: d(F), keyPath: F, unique: N, multiEntry: G, extractKey: Zt(F) };
            return C[Cl(F)] = G;
          }), getIndexByKeyPath: function(P) {
            return C[Cl(P)];
          } };
          return C[":id"] = S.primaryKey, D != null && (C[Cl(D)] = S.primaryKey), S;
        }) }, hasGetAll: 0 < g.length && "getAll" in p.objectStore(g[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), L = w.schema, O = w.hasGetAll, w = L.tables.map(c), v = {};
        return w.forEach(function(T) {
          return v[T.name] = T;
        }), { stack: "dbcore", transaction: n.transaction.bind(n), table: function(T) {
          if (!v[T]) throw new Error("Table '".concat(T, "' not found"));
          return v[T];
        }, MIN_KEY: -1 / 0, MAX_KEY: Sl(t), schema: L };
      }
      function cr(n, t, u, r) {
        var c = u.IDBKeyRange;
        return u.indexedDB, { dbcore: (r = sr(t, c, r), n.dbcore.reduce(function(m, p) {
          return p = p.create, a(a({}, m), p(m));
        }, r)) };
      }
      function nt(n, r) {
        var u = r.db, r = cr(n._middlewares, u, n._deps, r);
        n.core = r.dbcore, n.tables.forEach(function(c) {
          var m = c.name;
          n.core.schema.tables.some(function(p) {
            return p.name === m;
          }) && (c.core = n.core.table(m), n[m] instanceof n.Table && (n[m].core = c.core));
        });
      }
      function lt(n, t, u, r) {
        u.forEach(function(c) {
          var m = r[c];
          t.forEach(function(p) {
            var g = function L(O, w) {
              return U(O, w) || (O = x(O)) && L(O, w);
            }(p, c);
            (!g || "value" in g && g.value === void 0) && (p === n.Transaction.prototype || p instanceof n.Transaction ? E(p, c, { get: function() {
              return this.table(c);
            }, set: function(L) {
              R(this, c, { value: L, writable: !0, configurable: !0, enumerable: !0 });
            } }) : p[c] = new n.Table(c, m));
          });
        });
      }
      function Ut(n, t) {
        t.forEach(function(u) {
          for (var r in u) u[r] instanceof n.Table && delete u[r];
        });
      }
      function or(n, t) {
        return n._cfg.version - t._cfg.version;
      }
      function mr(n, t, u, r) {
        var c = n._dbSchema;
        u.objectStoreNames.contains("$meta") && !c.$meta && (c.$meta = Bt("$meta", hu("")[0], []), n._storeNames.push("$meta"));
        var m = n._createTransaction("readwrite", n._storeNames, c);
        m.create(u), m._completion.catch(r);
        var p = m._reject.bind(m), g = se.transless || se;
        Un(function() {
          return se.trans = m, se.transless = g, t !== 0 ? (nt(n, u), O = t, ((L = m).storeNames.includes("$meta") ? L.table("$meta").get("version").then(function(w) {
            return w ?? O;
          }) : ee.resolve(O)).then(function(w) {
            return T = w, D = m, b = u, C = [], w = (v = n)._versions, S = v._dbSchema = it(0, v.idbdb, b), (w = w.filter(function(P) {
              return P._cfg.version >= T;
            })).length !== 0 ? (w.forEach(function(P) {
              C.push(function() {
                var A = S, N = P._cfg.dbschema;
                ut(v, A, b), ut(v, N, b), S = v._dbSchema = N;
                var F = Kt(A, N);
                F.add.forEach(function(J) {
                  Gt(b, J[0], J[1].primKey, J[1].indexes);
                }), F.change.forEach(function(J) {
                  if (J.recreate) throw new Z.Upgrade("Not yet support for changing primary key");
                  var Q = b.objectStore(J.name);
                  J.add.forEach(function(le) {
                    return tt(Q, le);
                  }), J.change.forEach(function(le) {
                    Q.deleteIndex(le.name), tt(Q, le);
                  }), J.del.forEach(function(le) {
                    return Q.deleteIndex(le);
                  });
                });
                var G = P._cfg.contentUpgrade;
                if (G && P._cfg.version > T) {
                  nt(v, b), D._memoizedTables = {};
                  var Y = oe(N);
                  F.del.forEach(function(J) {
                    Y[J] = A[J];
                  }), Ut(v, [v.Transaction.prototype]), lt(v, [v.Transaction.prototype], f(Y), Y), D.schema = Y;
                  var H, $ = We(G);
                  return $ && cl(), F = ee.follow(function() {
                    var J;
                    (H = G(D)) && $ && (J = Kn.bind(null, null), H.then(J, J));
                  }), H && typeof H.then == "function" ? ee.resolve(H) : F.then(function() {
                    return H;
                  });
                }
              }), C.push(function(A) {
                var N, F, G = P._cfg.dbschema;
                N = G, F = A, [].slice.call(F.db.objectStoreNames).forEach(function(Y) {
                  return N[Y] == null && F.db.deleteObjectStore(Y);
                }), Ut(v, [v.Transaction.prototype]), lt(v, [v.Transaction.prototype], v._storeNames, v._dbSchema), D.schema = v._dbSchema;
              }), C.push(function(A) {
                v.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(v.idbdb.version / 10) === P._cfg.version ? (v.idbdb.deleteObjectStore("$meta"), delete v._dbSchema.$meta, v._storeNames = v._storeNames.filter(function(N) {
                  return N !== "$meta";
                })) : A.objectStore("$meta").put(P._cfg.version, "version"));
              });
            }), function P() {
              return C.length ? ee.resolve(C.shift()(D.idbtrans)).then(P) : ee.resolve();
            }().then(function() {
              pu(S, b);
            })) : ee.resolve();
            var v, T, D, b, C, S;
          }).catch(p)) : (f(c).forEach(function(w) {
            Gt(u, w, c[w].primKey, c[w].indexes);
          }), nt(n, u), void ee.follow(function() {
            return n.on.populate.fire(m);
          }).catch(p));
          var L, O;
        });
      }
      function fr(n, t) {
        pu(n._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var u = it(0, n.idbdb, t);
        ut(n, n._dbSchema, t);
        for (var r = 0, c = Kt(u, n._dbSchema).change; r < c.length; r++) {
          var m = function(p) {
            if (p.change.length || p.recreate) return console.warn("Unable to patch indexes of table ".concat(p.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var g = t.objectStore(p.name);
            p.add.forEach(function(L) {
              Oe && console.debug("Dexie upgrade patch: Creating missing index ".concat(p.name, ".").concat(L.src)), tt(g, L);
            });
          }(c[r]);
          if (typeof m == "object") return m.value;
        }
      }
      function Kt(n, t) {
        var u, r = { del: [], add: [], change: [] };
        for (u in n) t[u] || r.del.push(u);
        for (u in t) {
          var c = n[u], m = t[u];
          if (c) {
            var p = { name: u, def: m, recreate: !1, del: [], add: [], change: [] };
            if ("" + (c.primKey.keyPath || "") != "" + (m.primKey.keyPath || "") || c.primKey.auto !== m.primKey.auto) p.recreate = !0, r.change.push(p);
            else {
              var g = c.idxByName, L = m.idxByName, O = void 0;
              for (O in g) L[O] || p.del.push(O);
              for (O in L) {
                var w = g[O], v = L[O];
                w ? w.src !== v.src && p.change.push(v) : p.add.push(v);
              }
              (0 < p.del.length || 0 < p.add.length || 0 < p.change.length) && r.change.push(p);
            }
          } else r.add.push([u, m]);
        }
        return r;
      }
      function Gt(n, t, u, r) {
        var c = n.db.createObjectStore(t, u.keyPath ? { keyPath: u.keyPath, autoIncrement: u.auto } : { autoIncrement: u.auto });
        return r.forEach(function(m) {
          return tt(c, m);
        }), c;
      }
      function pu(n, t) {
        f(n).forEach(function(u) {
          t.db.objectStoreNames.contains(u) || (Oe && console.debug("Dexie: Creating missing table", u), Gt(t, u, n[u].primKey, n[u].indexes));
        });
      }
      function tt(n, t) {
        n.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function it(n, t, u) {
        var r = {};
        return X(t.objectStoreNames, 0).forEach(function(c) {
          for (var m = u.objectStore(c), p = Vt(fu(O = m.keyPath), O || "", !0, !1, !!m.autoIncrement, O && typeof O != "string", !0), g = [], L = 0; L < m.indexNames.length; ++L) {
            var w = m.index(m.indexNames[L]), O = w.keyPath, w = Vt(w.name, O, !!w.unique, !!w.multiEntry, !1, O && typeof O != "string", !1);
            g.push(w);
          }
          r[c] = Bt(c, p, g);
        }), r;
      }
      function ut(n, t, u) {
        for (var r = u.db.objectStoreNames, c = 0; c < r.length; ++c) {
          var m = r[c], p = u.objectStore(m);
          n._hasGetAll = "getAll" in p;
          for (var g = 0; g < p.indexNames.length; ++g) {
            var L = p.indexNames[g], O = p.index(L).keyPath, w = typeof O == "string" ? O : "[" + X(O).join("+") + "]";
            !t[m] || (O = t[m].idxByName[w]) && (O.name = L, delete t[m].idxByName[w], t[m].idxByName[L] = O);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && o.WorkerGlobalScope && o instanceof o.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1);
      }
      function hu(n) {
        return n.split(",").map(function(t, u) {
          var m = t.split(":"), r = (c = m[1]) === null || c === void 0 ? void 0 : c.trim(), c = (t = m[0].trim()).replace(/([&*]|\+\+)/g, ""), m = /^\[/.test(c) ? c.match(/^\[(.*)\]$/)[1].split("+") : c;
          return Vt(c, m || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), d(m), u === 0, r);
        });
      }
      var dr = (dl.prototype._createTableSchema = Bt, dl.prototype._parseIndexSyntax = hu, dl.prototype._parseStoresSpec = function(n, t) {
        var u = this;
        f(n).forEach(function(r) {
          if (n[r] !== null) {
            var c = u._parseIndexSyntax(n[r]), m = c.shift();
            if (!m) throw new Z.Schema("Invalid schema for table " + r + ": " + n[r]);
            if (m.unique = !0, m.multi) throw new Z.Schema("Primary key cannot be multiEntry*");
            c.forEach(function(p) {
              if (p.auto) throw new Z.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!p.keyPath) throw new Z.Schema("Index must have a name and cannot be an empty string");
            }), c = u._createTableSchema(r, m, c), t[r] = c;
          }
        });
      }, dl.prototype.stores = function(u) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? h(this._cfg.storesSource, u) : u;
        var u = t._versions, r = {}, c = {};
        return u.forEach(function(m) {
          h(r, m._cfg.storesSource), c = m._cfg.dbschema = {}, m._parseStoresSpec(r, c);
        }), t._dbSchema = c, Ut(t, [t._allTables, t, t.Transaction.prototype]), lt(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], f(c), c), t._storeNames = f(c), this;
      }, dl.prototype.upgrade = function(n) {
        return this._cfg.contentUpgrade = Ee(this._cfg.contentUpgrade || De, n), this;
      }, dl);
      function dl() {
      }
      function zt(n, t) {
        var u = n._dbNamesDB;
        return u || (u = n._dbNamesDB = new En(Wl, { addons: [], indexedDB: n, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), u.table("dbnames");
      }
      function jt(n) {
        return n && typeof n.databases == "function";
      }
      function Ht(n) {
        return Un(function() {
          return se.letThrough = !0, n();
        });
      }
      function $t(n) {
        return !("from" in n);
      }
      var un = function(n, t) {
        if (!this) {
          var u = new un();
          return n && "d" in n && h(u, n), u;
        }
        h(this, arguments.length ? { d: 1, from: n, to: 1 < arguments.length ? t : n } : { d: 0 });
      };
      function Tl(n, t, u) {
        var r = Te(t, u);
        if (!isNaN(r)) {
          if (0 < r) throw RangeError();
          if ($t(n)) return h(n, { from: t, to: u, d: 1 });
          var c = n.l, r = n.r;
          if (Te(u, n.from) < 0) return c ? Tl(c, t, u) : n.l = { from: t, to: u, d: 1, l: null, r: null }, vu(n);
          if (0 < Te(t, n.to)) return r ? Tl(r, t, u) : n.r = { from: t, to: u, d: 1, l: null, r: null }, vu(n);
          Te(t, n.from) < 0 && (n.from = t, n.l = null, n.d = r ? r.d + 1 : 1), 0 < Te(u, n.to) && (n.to = u, n.r = null, n.d = n.l ? n.l.d + 1 : 1), u = !n.r, c && !n.l && Pl(n, c), r && u && Pl(n, r);
        }
      }
      function Pl(n, t) {
        $t(t) || function u(r, L) {
          var m = L.from, p = L.to, g = L.l, L = L.r;
          Tl(r, m, p), g && u(r, g), L && u(r, L);
        }(n, t);
      }
      function gu(n, t) {
        var u = at(t), r = u.next();
        if (r.done) return !1;
        for (var c = r.value, m = at(n), p = m.next(c.from), g = p.value; !r.done && !p.done; ) {
          if (Te(g.from, c.to) <= 0 && 0 <= Te(g.to, c.from)) return !0;
          Te(c.from, g.from) < 0 ? c = (r = u.next(g.from)).value : g = (p = m.next(c.from)).value;
        }
        return !1;
      }
      function at(n) {
        var t = $t(n) ? null : { s: 0, n };
        return { next: function(u) {
          for (var r = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, r) for (; t.n.l && Te(u, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !r || Te(u, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function vu(n) {
        var t, u, r = (((t = n.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((u = n.l) === null || u === void 0 ? void 0 : u.d) || 0), c = 1 < r ? "r" : r < -1 ? "l" : "";
        c && (t = c == "r" ? "l" : "r", u = a({}, n), r = n[c], n.from = r.from, n.to = r.to, n[c] = r[c], u[c] = r[t], (n[t] = u).d = xu(u)), n.d = xu(n);
      }
      function xu(u) {
        var t = u.r, u = u.l;
        return (t ? u ? Math.max(t.d, u.d) : t.d : u ? u.d : 0) + 1;
      }
      function rt(n, t) {
        return f(t).forEach(function(u) {
          n[u] ? Pl(n[u], t[u]) : n[u] = function r(c) {
            var m, p, g = {};
            for (m in c) I(c, m) && (p = c[m], g[m] = !p || typeof p != "object" || be.has(p.constructor) ? p : r(p));
            return g;
          }(t[u]);
        }), n;
      }
      function Wt(n, t) {
        return n.all || t.all || Object.keys(n).some(function(u) {
          return t[u] && gu(t[u], n[u]);
        });
      }
      q(un.prototype, ((In = { add: function(n) {
        return Pl(this, n), this;
      }, addKey: function(n) {
        return Tl(this, n, n), this;
      }, addKeys: function(n) {
        var t = this;
        return n.forEach(function(u) {
          return Tl(t, u, u);
        }), this;
      }, hasKey: function(n) {
        var t = at(this).next(n).value;
        return t && Te(t.from, n) <= 0 && 0 <= Te(t.to, n);
      } })[ge] = function() {
        return at(this);
      }, In));
      var nl = {}, Yt = {}, Xt = !1;
      function st(n) {
        rt(Yt, n), Xt || (Xt = !0, setTimeout(function() {
          Xt = !1, Qt(Yt, !(Yt = {}));
        }, 0));
      }
      function Qt(n, t) {
        t === void 0 && (t = !1);
        var u = /* @__PURE__ */ new Set();
        if (n.all) for (var r = 0, c = Object.values(nl); r < c.length; r++) yu(p = c[r], n, u, t);
        else for (var m in n) {
          var p, g = /^idb\:\/\/(.*)\/(.*)\//.exec(m);
          g && (m = g[1], g = g[2], (p = nl["idb://".concat(m, "/").concat(g)]) && yu(p, n, u, t));
        }
        u.forEach(function(L) {
          return L();
        });
      }
      function yu(n, t, u, r) {
        for (var c = [], m = 0, p = Object.entries(n.queries.query); m < p.length; m++) {
          for (var g = p[m], L = g[0], O = [], w = 0, v = g[1]; w < v.length; w++) {
            var T = v[w];
            Wt(t, T.obsSet) ? T.subscribers.forEach(function(S) {
              return u.add(S);
            }) : r && O.push(T);
          }
          r && c.push([L, O]);
        }
        if (r) for (var D = 0, b = c; D < b.length; D++) {
          var C = b[D], L = C[0], O = C[1];
          n.queries.query[L] = O;
        }
      }
      function pr(n) {
        var t = n._state, u = n._deps.indexedDB;
        if (t.isBeingOpened || n.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? He(t.dbOpenError) : n;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var r = t.openCanceller, c = Math.round(10 * n.verno), m = !1;
        function p() {
          if (t.openCanceller !== r) throw new Z.DatabaseClosed("db.open() was cancelled");
        }
        function g() {
          return new ee(function(T, D) {
            if (p(), !u) throw new Z.MissingAPI();
            var b = n.name, C = t.autoSchema || !c ? u.open(b) : u.open(b, c);
            if (!C) throw new Z.MissingAPI();
            C.onerror = wn(D), C.onblocked = Be(n._fireOnBlocked), C.onupgradeneeded = Be(function(S) {
              var P;
              w = C.transaction, t.autoSchema && !n._options.allowEmptyDB ? (C.onerror = bl, w.abort(), C.result.close(), (P = u.deleteDatabase(b)).onsuccess = P.onerror = Be(function() {
                D(new Z.NoSuchDatabase("Database ".concat(b, " doesnt exist")));
              })) : (w.onerror = wn(D), S = S.oldVersion > Math.pow(2, 62) ? 0 : S.oldVersion, v = S < 1, n.idbdb = C.result, m && fr(n, w), mr(n, S / 10, w, D));
            }, D), C.onsuccess = Be(function() {
              w = null;
              var S, P, A, N, F, G = n.idbdb = C.result, Y = X(G.objectStoreNames);
              if (0 < Y.length) try {
                var H = G.transaction((N = Y).length === 1 ? N[0] : N, "readonly");
                if (t.autoSchema) P = G, A = H, (S = n).verno = P.version / 10, A = S._dbSchema = it(0, P, A), S._storeNames = X(P.objectStoreNames, 0), lt(S, [S._allTables], f(A), A);
                else if (ut(n, n._dbSchema, H), ((F = Kt(it(0, (F = n).idbdb, H), F._dbSchema)).add.length || F.change.some(function($) {
                  return $.add.length || $.change.length;
                })) && !m) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), G.close(), c = G.version + 1, m = !0, T(g());
                nt(n, H);
              } catch {
              }
              ol.push(n), G.onversionchange = Be(function($) {
                t.vcFired = !0, n.on("versionchange").fire($);
              }), G.onclose = Be(function($) {
                n.on("close").fire($);
              }), v && (F = n._deps, H = b, G = F.indexedDB, F = F.IDBKeyRange, jt(G) || H === Wl || zt(G, F).put({ name: H }).catch(De)), T();
            }, D);
          }).catch(function(T) {
            switch (T?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), g();
                break;
              case "VersionError":
                if (0 < c) return c = 0, g();
            }
            return ee.reject(T);
          });
        }
        var L, O = t.dbReadyResolve, w = null, v = !1;
        return ee.race([r, (typeof navigator > "u" ? ee.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(T) {
          function D() {
            return indexedDB.databases().finally(T);
          }
          L = setInterval(D, 100), D();
        }).finally(function() {
          return clearInterval(L);
        }) : Promise.resolve()).then(g)]).then(function() {
          return p(), t.onReadyBeingFired = [], ee.resolve(Ht(function() {
            return n.on.ready.fire(n.vip);
          })).then(function T() {
            if (0 < t.onReadyBeingFired.length) {
              var D = t.onReadyBeingFired.reduce(Ee, De);
              return t.onReadyBeingFired = [], ee.resolve(Ht(function() {
                return D(n.vip);
              })).then(T);
            }
          });
        }).finally(function() {
          t.openCanceller === r && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(T) {
          t.dbOpenError = T;
          try {
            w && w.abort();
          } catch {
          }
          return r === t.openCanceller && n._close(), He(T);
        }).finally(function() {
          t.openComplete = !0, O();
        }).then(function() {
          var T;
          return v && (T = {}, n.tables.forEach(function(D) {
            D.schema.indexes.forEach(function(b) {
              b.name && (T["idb://".concat(n.name, "/").concat(D.name, "/").concat(b.name)] = new un(-1 / 0, [[[]]]));
            }), T["idb://".concat(n.name, "/").concat(D.name, "/")] = T["idb://".concat(n.name, "/").concat(D.name, "/:dels")] = new un(-1 / 0, [[[]]]);
          }), jn(wl).fire(T), Qt(T, !0)), n;
        });
      }
      function Jt(n) {
        function t(m) {
          return n.next(m);
        }
        var u = c(t), r = c(function(m) {
          return n.throw(m);
        });
        function c(m) {
          return function(L) {
            var g = m(L), L = g.value;
            return g.done ? L : L && typeof L.then == "function" ? L.then(u, r) : d(L) ? Promise.all(L).then(u, r) : u(L);
          };
        }
        return c(t)();
      }
      function ct(n, t, u) {
        for (var r = d(n) ? n.slice() : [n], c = 0; c < u; ++c) r.push(t);
        return r;
      }
      var hr = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema, c = {}, m = [];
          function p(v, T, D) {
            var b = Cl(v), C = c[b] = c[b] || [], S = v == null ? 0 : typeof v == "string" ? 1 : v.length, P = 0 < T, P = a(a({}, D), { name: P ? "".concat(b, "(virtual-from:").concat(D.name, ")") : D.name, lowLevelIndex: D, isVirtual: P, keyTail: T, keyLength: S, extractKey: Zt(v), unique: !P && D.unique });
            return C.push(P), P.isPrimaryKey || m.push(P), 1 < S && p(S === 2 ? v[0] : v.slice(0, S - 1), T + 1, D), C.sort(function(A, N) {
              return A.keyTail - N.keyTail;
            }), P;
          }
          t = p(r.primaryKey.keyPath, 0, r.primaryKey), c[":id"] = [t];
          for (var g = 0, L = r.indexes; g < L.length; g++) {
            var O = L[g];
            p(O.keyPath, 0, O);
          }
          function w(v) {
            var T, D = v.query.index;
            return D.isVirtual ? a(a({}, v), { query: { index: D.lowLevelIndex, range: (T = v.query.range, D = D.keyTail, { type: T.type === 1 ? 2 : T.type, lower: ct(T.lower, T.lowerOpen ? n.MAX_KEY : n.MIN_KEY, D), lowerOpen: !0, upper: ct(T.upper, T.upperOpen ? n.MIN_KEY : n.MAX_KEY, D), upperOpen: !0 }) } }) : v;
          }
          return a(a({}, u), { schema: a(a({}, r), { primaryKey: t, indexes: m, getIndexByKeyPath: function(v) {
            return (v = c[Cl(v)]) && v[0];
          } }), count: function(v) {
            return u.count(w(v));
          }, query: function(v) {
            return u.query(w(v));
          }, openCursor: function(v) {
            var T = v.query.index, D = T.keyTail, b = T.isVirtual, C = T.keyLength;
            return b ? u.openCursor(w(v)).then(function(P) {
              return P && S(P);
            }) : u.openCursor(v);
            function S(P) {
              return Object.create(P, { continue: { value: function(A) {
                A != null ? P.continue(ct(A, v.reverse ? n.MAX_KEY : n.MIN_KEY, D)) : v.unique ? P.continue(P.key.slice(0, C).concat(v.reverse ? n.MIN_KEY : n.MAX_KEY, D)) : P.continue();
              } }, continuePrimaryKey: { value: function(A, N) {
                P.continuePrimaryKey(ct(A, n.MAX_KEY, D), N);
              } }, primaryKey: { get: function() {
                return P.primaryKey;
              } }, key: { get: function() {
                var A = P.key;
                return C === 1 ? A[0] : A.slice(0, C);
              } }, value: { get: function() {
                return P.value;
              } } });
            }
          } });
        } });
      } };
      function ei(n, t, u, r) {
        return u = u || {}, r = r || "", f(n).forEach(function(c) {
          var m, p, g;
          I(t, c) ? (m = n[c], p = t[c], typeof m == "object" && typeof p == "object" && m && p ? (g = Se(m)) !== Se(p) ? u[r + c] = t[c] : g === "Object" ? ei(m, p, u, r + c + ".") : m !== p && (u[r + c] = t[c]) : m !== p && (u[r + c] = t[c])) : u[r + c] = void 0;
        }), f(t).forEach(function(c) {
          I(n, c) || (u[r + c] = t[c]);
        }), u;
      }
      function ni(n, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(n.extractKey);
      }
      var gr = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema.primaryKey;
          return a(a({}, u), { mutate: function(c) {
            var m = se.trans, p = m.table(t).hook, g = p.deleting, L = p.creating, O = p.updating;
            switch (c.type) {
              case "add":
                if (L.fire === De) break;
                return m._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "put":
                if (L.fire === De && O.fire === De) break;
                return m._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "delete":
                if (g.fire === De) break;
                return m._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "deleteRange":
                if (g.fire === De) break;
                return m._promise("readwrite", function() {
                  return function v(T, D, b) {
                    return u.query({ trans: T, values: !1, query: { index: r, range: D }, limit: b }).then(function(C) {
                      var S = C.result;
                      return w({ type: "delete", keys: S, trans: T }).then(function(P) {
                        return 0 < P.numFailures ? Promise.reject(P.failures[0]) : S.length < b ? { failures: [], numFailures: 0, lastResult: void 0 } : v(T, a(a({}, D), { lower: S[S.length - 1], lowerOpen: !0 }), b);
                      });
                    });
                  }(c.trans, c.range, 1e4);
                }, !0);
            }
            return u.mutate(c);
            function w(v) {
              var T, D, b, C = se.trans, S = v.keys || ni(r, v);
              if (!S) throw new Error("Keys missing");
              return (v = v.type === "add" || v.type === "put" ? a(a({}, v), { keys: S }) : a({}, v)).type !== "delete" && (v.values = s([], v.values)), v.keys && (v.keys = s([], v.keys)), T = u, b = S, ((D = v).type === "add" ? Promise.resolve([]) : T.getMany({ trans: D.trans, keys: b, cache: "immutable" })).then(function(P) {
                var A = S.map(function(N, F) {
                  var G, Y, H, $ = P[F], J = { onerror: null, onsuccess: null };
                  return v.type === "delete" ? g.fire.call(J, N, $, C) : v.type === "add" || $ === void 0 ? (G = L.fire.call(J, N, v.values[F], C), N == null && G != null && (v.keys[F] = N = G, r.outbound || ne(v.values[F], r.keyPath, N))) : (G = ei($, v.values[F]), (Y = O.fire.call(J, G, N, $, C)) && (H = v.values[F], Object.keys(Y).forEach(function(Q) {
                    I(H, Q) ? H[Q] = Y[Q] : ne(H, Q, Y[Q]);
                  }))), J;
                });
                return u.mutate(v).then(function(N) {
                  for (var F = N.failures, G = N.results, Y = N.numFailures, N = N.lastResult, H = 0; H < S.length; ++H) {
                    var $ = (G || S)[H], J = A[H];
                    $ == null ? J.onerror && J.onerror(F[H]) : J.onsuccess && J.onsuccess(v.type === "put" && P[H] ? v.values[H] : $);
                  }
                  return { failures: F, results: G, numFailures: Y, lastResult: N };
                }).catch(function(N) {
                  return A.forEach(function(F) {
                    return F.onerror && F.onerror(N);
                  }), Promise.reject(N);
                });
              });
            }
          } });
        } });
      } };
      function Iu(n, t, u) {
        try {
          if (!t || t.keys.length < n.length) return null;
          for (var r = [], c = 0, m = 0; c < t.keys.length && m < n.length; ++c) Te(t.keys[c], n[m]) === 0 && (r.push(u ? ye(t.values[c]) : t.values[c]), ++m);
          return r.length === n.length ? r : null;
        } catch {
          return null;
        }
      }
      var vr = { stack: "dbcore", level: -1, create: function(n) {
        return { table: function(t) {
          var u = n.table(t);
          return a(a({}, u), { getMany: function(r) {
            if (!r.cache) return u.getMany(r);
            var c = Iu(r.keys, r.trans._cache, r.cache === "clone");
            return c ? ee.resolve(c) : u.getMany(r).then(function(m) {
              return r.trans._cache = { keys: r.keys, values: r.cache === "clone" ? ye(m) : m }, m;
            });
          }, mutate: function(r) {
            return r.type !== "add" && (r.trans._cache = null), u.mutate(r);
          } });
        } };
      } };
      function Lu(n, t) {
        return n.trans.mode === "readonly" && !!n.subscr && !n.trans.explicit && n.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function Du(n, t) {
        switch (n) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var xr = { stack: "dbcore", level: 0, name: "Observability", create: function(n) {
        var t = n.schema.name, u = new un(n.MIN_KEY, n.MAX_KEY);
        return a(a({}, n), { transaction: function(r, c, m) {
          if (se.subscr && c !== "readonly") throw new Z.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(se.querier));
          return n.transaction(r, c, m);
        }, table: function(r) {
          var c = n.table(r), m = c.schema, p = m.primaryKey, v = m.indexes, g = p.extractKey, L = p.outbound, O = p.autoIncrement && v.filter(function(D) {
            return D.compound && D.keyPath.includes(p.keyPath);
          }), w = a(a({}, c), { mutate: function(D) {
            function b(Q) {
              return Q = "idb://".concat(t, "/").concat(r, "/").concat(Q), N[Q] || (N[Q] = new un());
            }
            var C, S, P, A = D.trans, N = D.mutatedParts || (D.mutatedParts = {}), F = b(""), G = b(":dels"), Y = D.type, J = D.type === "deleteRange" ? [D.range] : D.type === "delete" ? [D.keys] : D.values.length < 50 ? [ni(p, D).filter(function(Q) {
              return Q;
            }), D.values] : [], H = J[0], $ = J[1], J = D.trans._cache;
            return d(H) ? (F.addKeys(H), (J = Y === "delete" || H.length === $.length ? Iu(H, J) : null) || G.addKeys(H), (J || $) && (C = b, S = J, P = $, m.indexes.forEach(function(Q) {
              var le = C(Q.name || "");
              function ve(he) {
                return he != null ? Q.extractKey(he) : null;
              }
              function qe(he) {
                return Q.multiEntry && d(he) ? he.forEach(function(Ge) {
                  return le.addKey(Ge);
                }) : le.addKey(he);
              }
              (S || P).forEach(function(he, an) {
                var pe = S && ve(S[an]), an = P && ve(P[an]);
                Te(pe, an) !== 0 && (pe != null && qe(pe), an != null && qe(an));
              });
            }))) : H ? ($ = { from: ($ = H.lower) !== null && $ !== void 0 ? $ : n.MIN_KEY, to: ($ = H.upper) !== null && $ !== void 0 ? $ : n.MAX_KEY }, G.add($), F.add($)) : (F.add(u), G.add(u), m.indexes.forEach(function(Q) {
              return b(Q.name).add(u);
            })), c.mutate(D).then(function(Q) {
              return !H || D.type !== "add" && D.type !== "put" || (F.addKeys(Q.results), O && O.forEach(function(le) {
                for (var ve = D.values.map(function(pe) {
                  return le.extractKey(pe);
                }), qe = le.keyPath.findIndex(function(pe) {
                  return pe === p.keyPath;
                }), he = 0, Ge = Q.results.length; he < Ge; ++he) ve[he][qe] = Q.results[he];
                b(le.name).addKeys(ve);
              })), A.mutatedParts = rt(A.mutatedParts || {}, N), Q;
            });
          } }), v = function(b) {
            var C = b.query, b = C.index, C = C.range;
            return [b, new un((b = C.lower) !== null && b !== void 0 ? b : n.MIN_KEY, (C = C.upper) !== null && C !== void 0 ? C : n.MAX_KEY)];
          }, T = { get: function(D) {
            return [p, new un(D.key)];
          }, getMany: function(D) {
            return [p, new un().addKeys(D.keys)];
          }, count: v, query: v, openCursor: v };
          return f(T).forEach(function(D) {
            w[D] = function(b) {
              var C = se.subscr, S = !!C, P = Lu(se, c) && Du(D, b) ? b.obsSet = {} : C;
              if (S) {
                var A = function($) {
                  return $ = "idb://".concat(t, "/").concat(r, "/").concat($), P[$] || (P[$] = new un());
                }, N = A(""), F = A(":dels"), C = T[D](b), S = C[0], C = C[1];
                if ((D === "query" && S.isPrimaryKey && !b.values ? F : A(S.name || "")).add(C), !S.isPrimaryKey) {
                  if (D !== "count") {
                    var G = D === "query" && L && b.values && c.query(a(a({}, b), { values: !1 }));
                    return c[D].apply(this, arguments).then(function($) {
                      if (D === "query") {
                        if (L && b.values) return G.then(function(ve) {
                          return ve = ve.result, N.addKeys(ve), $;
                        });
                        var J = b.values ? $.result.map(g) : $.result;
                        (b.values ? N : F).addKeys(J);
                      } else if (D === "openCursor") {
                        var Q = $, le = b.values;
                        return Q && Object.create(Q, { key: { get: function() {
                          return F.addKey(Q.primaryKey), Q.key;
                        } }, primaryKey: { get: function() {
                          var ve = Q.primaryKey;
                          return F.addKey(ve), ve;
                        } }, value: { get: function() {
                          return le && N.addKey(Q.primaryKey), Q.value;
                        } } });
                      }
                      return $;
                    });
                  }
                  F.add(u);
                }
              }
              return c[D].apply(this, arguments);
            };
          }), w;
        } });
      } };
      function Ou(n, t, u) {
        if (u.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var r = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return u.numFailures === r ? null : (t = a({}, t), d(t.keys) && (t.keys = t.keys.filter(function(c, m) {
          return !(m in u.failures);
        })), "values" in t && d(t.values) && (t.values = t.values.filter(function(c, m) {
          return !(m in u.failures);
        })), t);
      }
      function li(n, t) {
        return u = n, ((r = t).lower === void 0 || (r.lowerOpen ? 0 < Te(u, r.lower) : 0 <= Te(u, r.lower))) && (n = n, (t = t).upper === void 0 || (t.upperOpen ? Te(n, t.upper) < 0 : Te(n, t.upper) <= 0));
        var u, r;
      }
      function bu(n, t, T, r, c, m) {
        if (!T || T.length === 0) return n;
        var p = t.query.index, g = p.multiEntry, L = t.query.range, O = r.schema.primaryKey.extractKey, w = p.extractKey, v = (p.lowLevelIndex || p).extractKey, T = T.reduce(function(D, b) {
          var C = D, S = [];
          if (b.type === "add" || b.type === "put") for (var P = new un(), A = b.values.length - 1; 0 <= A; --A) {
            var N, F = b.values[A], G = O(F);
            P.hasKey(G) || (N = w(F), (g && d(N) ? N.some(function(Q) {
              return li(Q, L);
            }) : li(N, L)) && (P.addKey(G), S.push(F)));
          }
          switch (b.type) {
            case "add":
              var Y = new un().addKeys(t.values ? D.map(function(le) {
                return O(le);
              }) : D), C = D.concat(t.values ? S.filter(function(le) {
                return le = O(le), !Y.hasKey(le) && (Y.addKey(le), !0);
              }) : S.map(function(le) {
                return O(le);
              }).filter(function(le) {
                return !Y.hasKey(le) && (Y.addKey(le), !0);
              }));
              break;
            case "put":
              var H = new un().addKeys(b.values.map(function(le) {
                return O(le);
              }));
              C = D.filter(function(le) {
                return !H.hasKey(t.values ? O(le) : le);
              }).concat(t.values ? S : S.map(function(le) {
                return O(le);
              }));
              break;
            case "delete":
              var $ = new un().addKeys(b.keys);
              C = D.filter(function(le) {
                return !$.hasKey(t.values ? O(le) : le);
              });
              break;
            case "deleteRange":
              var J = b.range;
              C = D.filter(function(le) {
                return !li(O(le), J);
              });
          }
          return C;
        }, n);
        return T === n ? n : (T.sort(function(D, b) {
          return Te(v(D), v(b)) || Te(O(D), O(b));
        }), t.limit && t.limit < 1 / 0 && (T.length > t.limit ? T.length = t.limit : n.length === t.limit && T.length < t.limit && (c.dirty = !0)), m ? Object.freeze(T) : T);
      }
      function wu(n, t) {
        return Te(n.lower, t.lower) === 0 && Te(n.upper, t.upper) === 0 && !!n.lowerOpen == !!t.lowerOpen && !!n.upperOpen == !!t.upperOpen;
      }
      function yr(n, t) {
        return function(u, r, c, m) {
          if (u === void 0) return r !== void 0 ? -1 : 0;
          if (r === void 0) return 1;
          if ((r = Te(u, r)) === 0) {
            if (c && m) return 0;
            if (c) return 1;
            if (m) return -1;
          }
          return r;
        }(n.lower, t.lower, n.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(u, r, c, m) {
          if (u === void 0) return r !== void 0 ? 1 : 0;
          if (r === void 0) return -1;
          if ((r = Te(u, r)) === 0) {
            if (c && m) return 0;
            if (c) return -1;
            if (m) return 1;
          }
          return r;
        }(n.upper, t.upper, n.upperOpen, t.upperOpen);
      }
      function Ir(n, t, u, r) {
        n.subscribers.add(u), r.addEventListener("abort", function() {
          var c, m;
          n.subscribers.delete(u), n.subscribers.size === 0 && (c = n, m = t, setTimeout(function() {
            c.subscribers.size === 0 && de(m, c);
          }, 3e3));
        });
      }
      var Lr = { stack: "dbcore", level: 0, name: "Cache", create: function(n) {
        var t = n.schema.name;
        return a(a({}, n), { transaction: function(u, r, c) {
          var m, p, g = n.transaction(u, r, c);
          return r === "readwrite" && (p = (m = new AbortController()).signal, c = function(L) {
            return function() {
              if (m.abort(), r === "readwrite") {
                for (var O = /* @__PURE__ */ new Set(), w = 0, v = u; w < v.length; w++) {
                  var T = v[w], D = nl["idb://".concat(t, "/").concat(T)];
                  if (D) {
                    var b = n.table(T), C = D.optimisticOps.filter(function(le) {
                      return le.trans === g;
                    });
                    if (g._explicit && L && g.mutatedParts) for (var S = 0, P = Object.values(D.queries.query); S < P.length; S++) for (var A = 0, N = (Y = P[S]).slice(); A < N.length; A++) Wt((H = N[A]).obsSet, g.mutatedParts) && (de(Y, H), H.subscribers.forEach(function(le) {
                      return O.add(le);
                    }));
                    else if (0 < C.length) {
                      D.optimisticOps = D.optimisticOps.filter(function(le) {
                        return le.trans !== g;
                      });
                      for (var F = 0, G = Object.values(D.queries.query); F < G.length; F++) for (var Y, H, $, J = 0, Q = (Y = G[F]).slice(); J < Q.length; J++) (H = Q[J]).res != null && g.mutatedParts && (L && !H.dirty ? ($ = Object.isFrozen(H.res), $ = bu(H.res, H.req, C, b, H, $), H.dirty ? (de(Y, H), H.subscribers.forEach(function(le) {
                        return O.add(le);
                      })) : $ !== H.res && (H.res = $, H.promise = ee.resolve({ result: $ }))) : (H.dirty && de(Y, H), H.subscribers.forEach(function(le) {
                        return O.add(le);
                      })));
                    }
                  }
                }
                O.forEach(function(le) {
                  return le();
                });
              }
            };
          }, g.addEventListener("abort", c(!1), { signal: p }), g.addEventListener("error", c(!1), { signal: p }), g.addEventListener("complete", c(!0), { signal: p })), g;
        }, table: function(u) {
          var r = n.table(u), c = r.schema.primaryKey;
          return a(a({}, r), { mutate: function(m) {
            var p = se.trans;
            if (c.outbound || p.db._options.cache === "disabled" || p.explicit || p.idbtrans.mode !== "readwrite") return r.mutate(m);
            var g = nl["idb://".concat(t, "/").concat(u)];
            return g ? (p = r.mutate(m), m.type !== "add" && m.type !== "put" || !(50 <= m.values.length || ni(c, m).some(function(L) {
              return L == null;
            })) ? (g.optimisticOps.push(m), m.mutatedParts && st(m.mutatedParts), p.then(function(L) {
              0 < L.numFailures && (de(g.optimisticOps, m), (L = Ou(0, m, L)) && g.optimisticOps.push(L), m.mutatedParts && st(m.mutatedParts));
            }), p.catch(function() {
              de(g.optimisticOps, m), m.mutatedParts && st(m.mutatedParts);
            })) : p.then(function(L) {
              var O = Ou(0, a(a({}, m), { values: m.values.map(function(w, v) {
                var T;
                return L.failures[v] || (w = (T = c.keyPath) !== null && T !== void 0 && T.includes(".") ? ye(w) : a({}, w), ne(w, c.keyPath, L.results[v])), w;
              }) }), L);
              g.optimisticOps.push(O), queueMicrotask(function() {
                return m.mutatedParts && st(m.mutatedParts);
              });
            }), p) : r.mutate(m);
          }, query: function(m) {
            if (!Lu(se, r) || !Du("query", m)) return r.query(m);
            var p = ((O = se.trans) === null || O === void 0 ? void 0 : O.db._options.cache) === "immutable", v = se, g = v.requery, L = v.signal, O = function(b, C, S, P) {
              var A = nl["idb://".concat(b, "/").concat(C)];
              if (!A) return [];
              if (!(C = A.queries[S])) return [null, !1, A, null];
              var N = C[(P.query ? P.query.index.name : null) || ""];
              if (!N) return [null, !1, A, null];
              switch (S) {
                case "query":
                  var F = N.find(function(G) {
                    return G.req.limit === P.limit && G.req.values === P.values && wu(G.req.query.range, P.query.range);
                  });
                  return F ? [F, !0, A, N] : [N.find(function(G) {
                    return ("limit" in G.req ? G.req.limit : 1 / 0) >= P.limit && (!P.values || G.req.values) && yr(G.req.query.range, P.query.range);
                  }), !1, A, N];
                case "count":
                  return F = N.find(function(G) {
                    return wu(G.req.query.range, P.query.range);
                  }), [F, !!F, A, N];
              }
            }(t, u, "query", m), w = O[0], v = O[1], T = O[2], D = O[3];
            return w && v ? w.obsSet = m.obsSet : (v = r.query(m).then(function(b) {
              var C = b.result;
              if (w && (w.res = C), p) {
                for (var S = 0, P = C.length; S < P; ++S) Object.freeze(C[S]);
                Object.freeze(C);
              } else b.result = ye(C);
              return b;
            }).catch(function(b) {
              return D && w && de(D, w), Promise.reject(b);
            }), w = { obsSet: m.obsSet, promise: v, subscribers: /* @__PURE__ */ new Set(), type: "query", req: m, dirty: !1 }, D ? D.push(w) : (D = [w], (T = T || (nl["idb://".concat(t, "/").concat(u)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[m.query.index.name || ""] = D)), Ir(w, D, g, L), w.promise.then(function(b) {
              return { result: bu(b.result, m, T?.optimisticOps, r, w, p) };
            });
          } });
        } });
      } };
      function ot(n, t) {
        return new Proxy(n, { get: function(u, r, c) {
          return r === "db" ? t : Reflect.get(u, r, c);
        } });
      }
      var En = ($e.prototype.version = function(n) {
        if (isNaN(n) || n < 0.1) throw new Z.Type("Given version is not a positive number");
        if (n = Math.round(10 * n) / 10, this.idbdb || this._state.isBeingOpened) throw new Z.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, n);
        var t = this._versions, u = t.filter(function(r) {
          return r._cfg.version === n;
        })[0];
        return u || (u = new this.Version(n), t.push(u), t.sort(or), u.stores({}), this._state.autoSchema = !1, u);
      }, $e.prototype._whenReady = function(n) {
        var t = this;
        return this.idbdb && (this._state.openComplete || se.letThrough || this._vip) ? n() : new ee(function(u, r) {
          if (t._state.openComplete) return r(new Z.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void r(new Z.DatabaseClosed());
            t.open().catch(De);
          }
          t._state.dbReadyPromise.then(u, r);
        }).then(n);
      }, $e.prototype.use = function(n) {
        var t = n.stack, u = n.create, r = n.level, c = n.name;
        return c && this.unuse({ stack: t, name: c }), n = this._middlewares[t] || (this._middlewares[t] = []), n.push({ stack: t, create: u, level: r ?? 10, name: c }), n.sort(function(m, p) {
          return m.level - p.level;
        }), this;
      }, $e.prototype.unuse = function(n) {
        var t = n.stack, u = n.name, r = n.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(c) {
          return r ? c.create !== r : !!u && c.name !== u;
        })), this;
      }, $e.prototype.open = function() {
        var n = this;
        return Qn(Rn, function() {
          return pr(n);
        });
      }, $e.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var n = this._state, t = ol.indexOf(this);
        if (0 <= t && ol.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        n.isBeingOpened || (n.dbReadyPromise = new ee(function(u) {
          n.dbReadyResolve = u;
        }), n.openCanceller = new ee(function(u, r) {
          n.cancelOpen = r;
        }));
      }, $e.prototype.close = function(u) {
        var t = (u === void 0 ? { disableAutoOpen: !0 } : u).disableAutoOpen, u = this._state;
        t ? (u.isBeingOpened && u.cancelOpen(new Z.DatabaseClosed()), this._close(), u.autoOpen = !1, u.dbOpenError = new Z.DatabaseClosed()) : (this._close(), u.autoOpen = this._options.autoOpen || u.isBeingOpened, u.openComplete = !1, u.dbOpenError = null);
      }, $e.prototype.delete = function(n) {
        var t = this;
        n === void 0 && (n = { disableAutoOpen: !0 });
        var u = 0 < arguments.length && typeof arguments[0] != "object", r = this._state;
        return new ee(function(c, m) {
          function p() {
            t.close(n);
            var g = t._deps.indexedDB.deleteDatabase(t.name);
            g.onsuccess = Be(function() {
              var L, O, w;
              L = t._deps, O = t.name, w = L.indexedDB, L = L.IDBKeyRange, jt(w) || O === Wl || zt(w, L).delete(O).catch(De), c();
            }), g.onerror = wn(m), g.onblocked = t._fireOnBlocked;
          }
          if (u) throw new Z.InvalidArgument("Invalid closeOptions argument to db.delete()");
          r.isBeingOpened ? r.dbReadyPromise.then(p) : p();
        });
      }, $e.prototype.backendDB = function() {
        return this.idbdb;
      }, $e.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, $e.prototype.hasBeenClosed = function() {
        var n = this._state.dbOpenError;
        return n && n.name === "DatabaseClosed";
      }, $e.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, $e.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty($e.prototype, "tables", { get: function() {
        var n = this;
        return f(this._allTables).map(function(t) {
          return n._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), $e.prototype.transaction = function() {
        var n = (function(t, u, r) {
          var c = arguments.length;
          if (c < 2) throw new Z.InvalidArgument("Too few arguments");
          for (var m = new Array(c - 1); --c; ) m[c - 1] = arguments[c];
          return r = m.pop(), [t, me(m), r];
        }).apply(this, arguments);
        return this._transaction.apply(this, n);
      }, $e.prototype._transaction = function(n, t, u) {
        var r = this, c = se.trans;
        c && c.db === this && n.indexOf("!") === -1 || (c = null);
        var m, p, g = n.indexOf("?") !== -1;
        n = n.replace("!", "").replace("?", "");
        try {
          if (p = t.map(function(O) {
            if (O = O instanceof r.Table ? O.name : O, typeof O != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return O;
          }), n == "r" || n === _t) m = _t;
          else {
            if (n != "rw" && n != Nt) throw new Z.InvalidArgument("Invalid transaction mode: " + n);
            m = Nt;
          }
          if (c) {
            if (c.mode === _t && m === Nt) {
              if (!g) throw new Z.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              c = null;
            }
            c && p.forEach(function(O) {
              if (c && c.storeNames.indexOf(O) === -1) {
                if (!g) throw new Z.SubTransaction("Table " + O + " not included in parent transaction.");
                c = null;
              }
            }), g && c && !c.active && (c = null);
          }
        } catch (O) {
          return c ? c._promise(null, function(w, v) {
            v(O);
          }) : He(O);
        }
        var L = (function O(w, v, T, D, b) {
          return ee.resolve().then(function() {
            var C = se.transless || se, S = w._createTransaction(v, T, w._dbSchema, D);
            if (S.explicit = !0, C = { trans: S, transless: C }, D) S.idbtrans = D.idbtrans;
            else try {
              S.create(), S.idbtrans._explicit = !0, w._state.PR1398_maxLoop = 3;
            } catch (N) {
              return N.name === V.InvalidState && w.isOpen() && 0 < --w._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), w.close({ disableAutoOpen: !1 }), w.open().then(function() {
                return O(w, v, T, null, b);
              })) : He(N);
            }
            var P, A = We(b);
            return A && cl(), C = ee.follow(function() {
              var N;
              (P = b.call(S, S)) && (A ? (N = Kn.bind(null, null), P.then(N, N)) : typeof P.next == "function" && typeof P.throw == "function" && (P = Jt(P)));
            }, C), (P && typeof P.then == "function" ? ee.resolve(P).then(function(N) {
              return S.active ? N : He(new Z.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : C.then(function() {
              return P;
            })).then(function(N) {
              return D && S._resolve(), S._completion.then(function() {
                return N;
              });
            }).catch(function(N) {
              return S._reject(N), He(N);
            });
          });
        }).bind(null, this, m, p, c, u);
        return c ? c._promise(m, L, "lock") : se.trans ? Qn(se.transless, function() {
          return r._whenReady(L);
        }) : this._whenReady(L);
      }, $e.prototype.table = function(n) {
        if (!I(this._allTables, n)) throw new Z.InvalidTable("Table ".concat(n, " does not exist"));
        return this._allTables[n];
      }, $e);
      function $e(n, t) {
        var u = this;
        this._middlewares = {}, this.verno = 0;
        var r = $e.dependencies;
        this._options = t = a({ addons: $e.addons, autoOpen: !0, indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, r = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var c, m, p, g, L, O = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: De, dbReadyPromise: null, cancelOpen: De, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        O.dbReadyPromise = new ee(function(v) {
          O.dbReadyResolve = v;
        }), O.openCanceller = new ee(function(v, T) {
          O.cancelOpen = T;
        }), this._state = O, this.name = n, this.on = Ll(this, "populate", "blocked", "versionchange", "close", { ready: [Ee, De] }), this.once = function(v, T) {
          var D = function() {
            for (var b = [], C = 0; C < arguments.length; C++) b[C] = arguments[C];
            u.on(v).unsubscribe(D), T.apply(u, b);
          };
          return u.on(v, D);
        }, this.on.ready.subscribe = B(this.on.ready.subscribe, function(v) {
          return function(T, D) {
            $e.vip(function() {
              var b, C = u._state;
              C.openComplete ? (C.dbOpenError || ee.resolve().then(T), D && v(T)) : C.onReadyBeingFired ? (C.onReadyBeingFired.push(T), D && v(T)) : (v(T), b = u, D || v(function S() {
                b.on.ready.unsubscribe(T), b.on.ready.unsubscribe(S);
              }));
            });
          };
        }), this.Collection = (c = this, Dl(tr.prototype, function(P, S) {
          this.db = c;
          var D = nu, b = null;
          if (S) try {
            D = S();
          } catch (A) {
            b = A;
          }
          var C = P._ctx, S = C.table, P = S.hook.reading.fire;
          this._ctx = { table: S, index: C.index, isPrimKey: !C.index || S.schema.primKey.keyPath && C.index === S.schema.primKey.name, range: D, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: b, or: C.or, valueMapper: P !== j ? P : null };
        })), this.Table = (m = this, Dl(uu.prototype, function(v, T, D) {
          this.db = m, this._tx = D, this.name = v, this.schema = T, this.hook = m._allTables[v] ? m._allTables[v].hook : Ll(null, { creating: [Ce, De], reading: [ie, j], updating: [we, De], deleting: [Ie, De] });
        })), this.Transaction = (p = this, Dl(ar.prototype, function(v, T, D, b, C) {
          var S = this;
          v !== "readonly" && T.forEach(function(P) {
            P = (P = D[P]) === null || P === void 0 ? void 0 : P.yProps, P && (T = T.concat(P.map(function(A) {
              return A.updatesTable;
            })));
          }), this.db = p, this.mode = v, this.storeNames = T, this.schema = D, this.chromeTransactionDurability = b, this.idbtrans = null, this.on = Ll(this, "complete", "error", "abort"), this.parent = C || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ee(function(P, A) {
            S._resolve = P, S._reject = A;
          }), this._completion.then(function() {
            S.active = !1, S.on.complete.fire();
          }, function(P) {
            var A = S.active;
            return S.active = !1, S.on.error.fire(P), S.parent ? S.parent._reject(P) : A && S.idbtrans && S.idbtrans.abort(), He(P);
          });
        })), this.Version = (g = this, Dl(dr.prototype, function(v) {
          this.db = g, this._cfg = { version: v, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (L = this, Dl(mu.prototype, function(v, T, D) {
          if (this.db = L, this._ctx = { table: v, index: T === ":id" ? null : T, or: D }, this._cmp = this._ascending = Te, this._descending = function(b, C) {
            return Te(C, b);
          }, this._max = function(b, C) {
            return 0 < Te(b, C) ? b : C;
          }, this._min = function(b, C) {
            return Te(b, C) < 0 ? b : C;
          }, this._IDBKeyRange = L._deps.IDBKeyRange, !this._IDBKeyRange) throw new Z.MissingAPI();
        })), this.on("versionchange", function(v) {
          0 < v.newVersion ? console.warn("Another connection wants to upgrade database '".concat(u.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(u.name, "'. Closing db now to resume the delete request.")), u.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(v) {
          !v.newVersion || v.newVersion < v.oldVersion ? console.warn("Dexie.delete('".concat(u.name, "') was blocked")) : console.warn("Upgrade '".concat(u.name, "' blocked by other connection holding version ").concat(v.oldVersion / 10));
        }), this._maxKey = Sl(t.IDBKeyRange), this._createTransaction = function(v, T, D, b) {
          return new u.Transaction(v, T, D, u._options.chromeTransactionDurability, b);
        }, this._fireOnBlocked = function(v) {
          u.on("blocked").fire(v), ol.filter(function(T) {
            return T.name === u.name && T !== u && !T._state.vcFired;
          }).map(function(T) {
            return T.on("versionchange").fire(v);
          });
        }, this.use(vr), this.use(Lr), this.use(xr), this.use(hr), this.use(gr);
        var w = new Proxy(this, { get: function(v, T, D) {
          if (T === "_vip") return !0;
          if (T === "table") return function(C) {
            return ot(u.table(C), w);
          };
          var b = Reflect.get(v, T, D);
          return b instanceof uu ? ot(b, w) : T === "tables" ? b.map(function(C) {
            return ot(C, w);
          }) : T === "_createTransaction" ? function() {
            return ot(b.apply(this, arguments), w);
          } : b;
        } });
        this.vip = w, r.forEach(function(v) {
          return v(u);
        });
      }
      var mt, In = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Dr = (ti.prototype.subscribe = function(n, t, u) {
        return this._subscribe(n && typeof n != "function" ? n : { next: n, error: t, complete: u });
      }, ti.prototype[In] = function() {
        return this;
      }, ti);
      function ti(n) {
        this._subscribe = n;
      }
      try {
        mt = { indexedDB: o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB, IDBKeyRange: o.IDBKeyRange || o.webkitIDBKeyRange };
      } catch {
        mt = { indexedDB: null, IDBKeyRange: null };
      }
      function Su(n) {
        var t, u = !1, r = new Dr(function(c) {
          var m = We(n), p, g = !1, L = {}, O = {}, w = { get closed() {
            return g;
          }, unsubscribe: function() {
            g || (g = !0, p && p.abort(), v && jn.storagemutated.unsubscribe(D));
          } };
          c.start && c.start(w);
          var v = !1, T = function() {
            return Et(b);
          }, D = function(C) {
            rt(L, C), Wt(O, L) && T();
          }, b = function() {
            var C, S, P;
            !g && mt.indexedDB && (L = {}, C = {}, p && p.abort(), p = new AbortController(), P = function(A) {
              var N = rl();
              try {
                m && cl();
                var F = Un(n, A);
                return F = m ? F.finally(Kn) : F;
              } finally {
                N && sl();
              }
            }(S = { subscr: C, signal: p.signal, requery: T, querier: n, trans: null }), Promise.resolve(P).then(function(A) {
              u = !0, t = A, g || S.signal.aborted || (L = {}, function(N) {
                for (var F in N) if (I(N, F)) return;
                return 1;
              }(O = C) || v || (jn(wl, D), v = !0), Et(function() {
                return !g && c.next && c.next(A);
              }));
            }, function(A) {
              u = !1, ["DatabaseClosedError", "AbortError"].includes(A?.name) || g || Et(function() {
                g || c.error && c.error(A);
              });
            }));
          };
          return setTimeout(T, 0), w;
        });
        return r.hasValue = function() {
          return u;
        }, r.getValue = function() {
          return t;
        }, r;
      }
      var ll = En;
      function ii(n) {
        var t = Hn;
        try {
          Hn = !0, jn.storagemutated.fire(n), Qt(n, !0);
        } finally {
          Hn = t;
        }
      }
      q(ll, a(a({}, Qe), { delete: function(n) {
        return new ll(n, { addons: [] }).delete();
      }, exists: function(n) {
        return new ll(n, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(n) {
        try {
          return t = ll.dependencies, u = t.indexedDB, t = t.IDBKeyRange, (jt(u) ? Promise.resolve(u.databases()).then(function(r) {
            return r.map(function(c) {
              return c.name;
            }).filter(function(c) {
              return c !== Wl;
            });
          }) : zt(u, t).toCollection().primaryKeys()).then(n);
        } catch {
          return He(new Z.MissingAPI());
        }
        var t, u;
      }, defineClass: function() {
        return function(n) {
          h(this, n);
        };
      }, ignoreTransaction: function(n) {
        return se.trans ? Qn(se.transless, n) : n();
      }, vip: Ht, async: function(n) {
        return function() {
          try {
            var t = Jt(n.apply(this, arguments));
            return t && typeof t.then == "function" ? t : ee.resolve(t);
          } catch (u) {
            return He(u);
          }
        };
      }, spawn: function(n, t, u) {
        try {
          var r = Jt(n.apply(u, t || []));
          return r && typeof r.then == "function" ? r : ee.resolve(r);
        } catch (c) {
          return He(c);
        }
      }, currentTransaction: { get: function() {
        return se.trans || null;
      } }, waitFor: function(n, t) {
        return t = ee.resolve(typeof n == "function" ? ll.ignoreTransaction(n) : n).timeout(t || 6e4), se.trans ? se.trans.waitFor(t) : t;
      }, Promise: ee, debug: { get: function() {
        return Oe;
      }, set: function(n) {
        Pe(n);
      } }, derive: M, extend: h, props: q, override: B, Events: Ll, on: jn, liveQuery: Su, extendObservabilitySet: rt, getByKeyPath: ae, setByKeyPath: ne, delByKeyPath: function(n, t) {
        typeof t == "string" ? ne(n, t, void 0) : "length" in t && [].map.call(t, function(u) {
          ne(n, u, void 0);
        });
      }, shallowClone: oe, deepClone: ye, getObjectDiff: ei, cmp: Te, asap: W, minKey: -1 / 0, addons: [], connections: ol, errnames: V, dependencies: mt, cache: nl, semVer: "4.2.0", version: "4.2.0".split(".").map(function(n) {
        return parseInt(n);
      }).reduce(function(n, t, u) {
        return n + t / Math.pow(10, 2 * u);
      }) })), ll.maxKey = Sl(ll.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (jn(wl, function(n) {
        Hn || (n = new CustomEvent(kt, { detail: n }), Hn = !0, dispatchEvent(n), Hn = !1);
      }), addEventListener(kt, function(n) {
        n = n.detail, Hn || ii(n);
      }));
      var xl, Hn = !1, Cu = function() {
      };
      return typeof BroadcastChannel < "u" && ((Cu = function() {
        (xl = new BroadcastChannel(kt)).onmessage = function(n) {
          return n.data && ii(n.data);
        };
      })(), typeof xl.unref == "function" && xl.unref(), jn(wl, function(n) {
        Hn || xl.postMessage(n);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(n) {
        if (!En.disableBfCache && n.persisted) {
          Oe && console.debug("Dexie: handling persisted pagehide"), xl?.close();
          for (var t = 0, u = ol; t < u.length; t++) u[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(n) {
        !En.disableBfCache && n.persisted && (Oe && console.debug("Dexie: handling persisted pageshow"), Cu(), ii({ all: new un(-1 / 0, [[]]) }));
      })), ee.rejectionMapper = function(n, t) {
        return !n || n instanceof cn || n instanceof TypeError || n instanceof SyntaxError || !n.name || !ue[n.name] ? n : (t = new ue[n.name](t || n.message, n), "stack" in n && E(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, Pe(Oe), a(En, Object.freeze({ __proto__: null, Dexie: En, liveQuery: Su, Entity: lu, cmp: Te, PropModification: Ol, replacePrefix: function(n, t) {
        return new Ol({ replacePrefix: [n, t] });
      }, add: function(n) {
        return new Ol({ add: n });
      }, remove: function(n) {
        return new Ol({ remove: n });
      }, default: En, RangeSet: un, mergeRanges: Pl, rangesOverlap: gu }), { default: En }), En;
    });
  }(wm)), wm.exports;
}
var ED = AD();
const Sm = /* @__PURE__ */ cD(ED), qd = Symbol.for("Dexie"), Ba = globalThis[qd] || (globalThis[qd] = Sm);
if (Sm.semVer !== Ba.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Sm.semVer} and ${Ba.semVer}`);
const {
  liveQuery: CC,
  mergeRanges: TC,
  rangesOverlap: PC,
  RangeSet: qC,
  cmp: RC,
  Entity: AC,
  PropModification: EC,
  replacePrefix: _C,
  add: NC,
  remove: FC,
  DexieYProvider: MC
} = Ba;
class _D extends Ba {
  /**
   * @param {ConstructorParameters<DexieConstructor>[0]} databaseName - Name of the database
   * @param {ConstructorParameters<DexieConstructor>[1]} options - Options for Dexie
   */
  constructor(...l) {
    super(...l), this.upgrade();
  }
  async upgrade() {
    if (this.isOpen()) {
      this.close(), Rd(this), await this.open();
      return;
    }
    Rd(this);
  }
}
function Rd(e) {
  return e.version(1).stores({
    [uc]: qo
  }), e.version(2).stores({
    [uc]: qo,
    [Ro]: Td
  }), e.version(2.1).stores({
    [uc]: qo,
    [Ro]: Td
  }).upgrade((l) => {
    l.table(Ro).toCollection().modify((i) => {
      typeof i.file == "string" && (i.file = new Blob([i.file], { type: "text/xml" }));
    });
  }), e;
}
async function ND(e) {
  const { databaseInstance: l, records: i } = e, a = l.table(uc);
  await l.transaction("rw", a, () => a.bulkAdd(i));
}
async function FD(e) {
  if (await Ba.exists(e))
    return await Ba.delete(e);
}
const MD = {
  useBrowserApi: !0,
  chunkSize: 32 * 1024,
  // 32KB
  batchSize: 2e3
};
async function kD({
  files: e,
  options: l = MD
}) {
  const i = [];
  if (e.length === 0) throw new Error("No files provided for import.");
  for (const a of e) {
    if (!VD(a)) {
      console.error(`Unsupported file type: ${a.name}`);
      continue;
    }
    a.size === 0 && console.warn(`File is empty: ${a.name}`);
    const s = await ZD({ file: a, options: l });
    i.push(s);
  }
  return i;
}
function VD(e) {
  return yD.some((l) => e.name.toLowerCase().endsWith(l));
}
function BD(e) {
  return e.name.replace(/\.[^.]+$/, "");
}
async function ZD(e) {
  const { file: l, options: i } = e;
  try {
    const a = BD(l);
    await FD(a);
    const s = new _D(a);
    return i.useBrowserApi && l.size !== 0 && await UD({
      file: l,
      databaseInstance: s,
      options: {
        chunkSize: i.chunkSize,
        batchSize: i.batchSize
      }
    }), a;
  } catch (a) {
    throw console.error(`Error importing file ${l.name}:`, a), a;
  }
}
async function UD(e) {
  const { file: l, databaseInstance: i, options: a } = e, s = l.stream().getReader(), o = LD(), f = new TextDecoder(), d = new Uint8Array(0);
  return await Cm({ databaseInstance: i, reader: s, sax: o, textDecoder: f, buffer: d, options: a });
}
async function Cm(e) {
  const { databaseInstance: l, reader: i, sax: a, textDecoder: s, buffer: o, options: f } = e, { chunkSize: d, batchSize: h } = f, { done: x, value: y } = await i.read();
  if (x) {
    if (o.length > 0) {
      const q = s.decode(o);
      a.parser.write(q);
    }
    return a.parser.close(), await Ad({
      databaseInstance: l,
      sax: a,
      batchSize: 0
    });
  }
  if (!y)
    return await Cm(e);
  let I = new Uint8Array(o.length + y.length);
  for (I.set(o), I.set(y, o.length); I.length >= d; ) {
    const q = I.slice(0, d);
    I = I.slice(d);
    const R = s.decode(q, { stream: !0 });
    a.parser.write(R), await Ad({
      databaseInstance: l,
      sax: a,
      batchSize: h
    });
  }
  return await Cm({ ...e, buffer: I });
}
async function Ad(e) {
  const { databaseInstance: l, sax: i, batchSize: a } = e;
  if (i.getSize() >= a) {
    const s = i.drainBatch(), o = gD({
      currentBatch: s
    });
    await ND({
      databaseInstance: l,
      records: o
    });
  }
}
function xf(e, l) {
  return $i() ? (ca(e, l), !0) : !1;
}
// @__NO_SIDE_EFFECTS__
function Ed() {
  const e = /* @__PURE__ */ new Set(), l = (o) => {
    e.delete(o);
  };
  return {
    on: (o) => {
      e.add(o);
      const f = () => l(o);
      return xf(f), { off: f };
    },
    off: l,
    trigger: (...o) => Promise.all(Array.from(e).map((f) => f(...o))),
    clear: () => {
      e.clear();
    }
  };
}
const Ao = /* @__PURE__ */ new WeakMap(), KD = /* @__NO_SIDE_EFFECTS__ */ (...e) => {
  var l;
  const i = e[0], a = (l = Xn()) === null || l === void 0 ? void 0 : l.proxy, s = a ?? $i();
  if (s == null && !Xc()) throw new Error("injectLocal must be called in setup");
  return s && Ao.has(s) && i in Ao.get(s) ? Ao.get(s)[i] : Fi(...e);
}, yf = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const GD = Object.prototype.toString, zD = (e) => GD.call(e) === "[object Object]", Zg = () => {
}, jD = (e, l) => Object.prototype.hasOwnProperty.call(e, l);
function HD(...e) {
  if (e.length !== 1) return hs(...e);
  const l = e[0];
  return typeof l == "function" ? Bi(ja(() => ({
    get: l,
    set: Zg
  }))) : Fe(l);
}
function $D(e, l) {
  function i(...a) {
    return new Promise((s, o) => {
      Promise.resolve(e(() => l.apply(this, a), {
        fn: l,
        thisArg: this,
        args: a
      })).then(s).catch(o);
    });
  }
  return i;
}
const Ug = (e) => e();
function WD(e = Ug, l = {}) {
  const { initialState: i = "active" } = l, a = HD(i === "active");
  function s() {
    a.value = !1;
  }
  function o() {
    a.value = !0;
  }
  const f = (...d) => {
    a.value && e(...d);
  };
  return {
    isActive: Bi(a),
    pause: s,
    resume: o,
    eventFilter: f
  };
}
function YD(e, l) {
  var i;
  if (typeof e == "number") return e + l;
  const a = ((i = e.match(/^-?\d+\.?\d*/)) === null || i === void 0 ? void 0 : i[0]) || "", s = e.slice(a.length), o = Number.parseFloat(a) + l;
  return Number.isNaN(o) ? e : o + s;
}
function $r(e) {
  return e.endsWith("rem") ? Number.parseFloat(e) * 16 : Number.parseFloat(e);
}
function Eo(e) {
  return Array.isArray(e) ? e : [e];
}
function XD(e) {
  return Xn();
}
function _d(e) {
  let l = hn(e), i;
  const a = () => {
    l = hn(e), i();
  }, s = ja((o, f) => (i = f, {
    get() {
      return o(), l;
    },
    set(d) {
      l = d, i();
    }
  }));
  return s.reset = a, s;
}
function QD(e, l, i = {}) {
  const { eventFilter: a = Ug, ...s } = i;
  return Cn(e, $D(a, l), s);
}
function JD(e, l, i = {}) {
  const { eventFilter: a, initialState: s = "active", ...o } = i, { eventFilter: f, pause: d, resume: h, isActive: x } = WD(a, { initialState: s });
  return {
    stop: QD(e, l, {
      ...o,
      eventFilter: f
    }),
    pause: d,
    resume: h,
    isActive: x
  };
}
const e0 = JD;
function Kg(e, l = !0, i) {
  XD() ? vl(e, i) : l ? e() : il(e);
}
function n0(e, l, i = {}) {
  const { immediate: a = !0, immediateCallback: s = !1 } = i, o = Fl(!1);
  let f;
  function d() {
    f && (clearTimeout(f), f = void 0);
  }
  function h() {
    o.value = !1, d();
  }
  function x(...y) {
    s && e(), d(), o.value = !0, f = setTimeout(() => {
      o.value = !1, f = void 0, e(...y);
    }, hn(l));
  }
  return a && (o.value = !0, yf && x()), xf(h), {
    isPending: _u(o),
    start: x,
    stop: h
  };
}
function l0(e, l, i) {
  return Cn(e, l, {
    ...i,
    immediate: !0
  });
}
function t0(e, l, i) {
  var a;
  let s;
  Vn(i) ? s = { evaluating: i } : s = i || {};
  const { lazy: o = !1, flush: f = "sync", evaluating: d = void 0, shallow: h = !0, onError: x = (a = globalThis.reportError) !== null && a !== void 0 ? a : Zg } = s, y = Fl(!o), I = h ? Fl(l) : Fe(l);
  let q = 0;
  return Ml(async (R) => {
    if (!y.value) return;
    q++;
    const E = q;
    let M = !1;
    d && Promise.resolve().then(() => {
      d.value = !0;
    });
    try {
      const U = await e((z) => {
        R(() => {
          d && (d.value = !1), M || z();
        });
      });
      E === q && (I.value = U);
    } catch (U) {
      x(U);
    } finally {
      d && E === q && (d.value = !1), M = !0;
    }
  }, { flush: f }), o ? _e(() => (y.value = !0, I.value)) : I;
}
const na = yf ? window : void 0, i0 = yf ? window.document : void 0;
function Gg(e) {
  var l;
  const i = hn(e);
  return (l = i?.$el) !== null && l !== void 0 ? l : i;
}
function Tm(...e) {
  const l = [], i = () => {
    l.forEach((d) => d()), l.length = 0;
  }, a = (d, h, x, y) => (d.addEventListener(h, x, y), () => d.removeEventListener(h, x, y)), s = _e(() => {
    const d = Eo(hn(e[0])).filter((h) => h != null);
    return d.every((h) => typeof h != "string") ? d : void 0;
  }), o = l0(() => {
    var d, h;
    return [
      (d = (h = s.value) === null || h === void 0 ? void 0 : h.map((x) => Gg(x))) !== null && d !== void 0 ? d : [na].filter((x) => x != null),
      Eo(hn(s.value ? e[1] : e[0])),
      Eo(te(s.value ? e[2] : e[1])),
      hn(s.value ? e[3] : e[2])
    ];
  }, ([d, h, x, y]) => {
    if (i(), !d?.length || !h?.length || !x?.length) return;
    const I = zD(y) ? { ...y } : y;
    l.push(...d.flatMap((q) => h.flatMap((R) => x.map((E) => a(q, R, E, I)))));
  }, { flush: "post" }), f = () => {
    o(), i();
  };
  return xf(i), f;
}
// @__NO_SIDE_EFFECTS__
function u0() {
  const e = Fl(!1), l = Xn();
  return l && vl(() => {
    e.value = !0;
  }, l), e;
}
// @__NO_SIDE_EFFECTS__
function a0(e) {
  const l = /* @__PURE__ */ u0();
  return _e(() => (l.value, !!e()));
}
const r0 = Symbol("vueuse-ssr-width");
// @__NO_SIDE_EFFECTS__
function zg() {
  const e = Xc() ? /* @__PURE__ */ KD(r0, null) : null;
  return typeof e == "number" ? e : void 0;
}
function Sr(e, l = {}) {
  const { window: i = na, ssrWidth: a = /* @__PURE__ */ zg() } = l, s = /* @__PURE__ */ a0(() => i && "matchMedia" in i && typeof i.matchMedia == "function"), o = Fl(typeof a == "number"), f = Fl(), d = Fl(!1), h = (x) => {
    d.value = x.matches;
  };
  return Ml(() => {
    if (o.value) {
      o.value = !s.value, d.value = hn(e).split(",").some((x) => {
        const y = x.includes("not all"), I = x.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/), q = x.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        let R = !!(I || q);
        return I && R && (R = a >= $r(I[1])), q && R && (R = a <= $r(q[1])), y ? !R : R;
      });
      return;
    }
    s.value && (f.value = i.matchMedia(hn(e)), d.value = f.value.matches);
  }), Tm(f, "change", h, { passive: !0 }), _e(() => d.value);
}
const s0 = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536
};
// @__NO_SIDE_EFFECTS__
function c0(e, l = {}) {
  function i(R, E) {
    let M = hn(e[hn(R)]);
    return E != null && (M = YD(M, E)), typeof M == "number" && (M = `${M}px`), M;
  }
  const { window: a = na, strategy: s = "min-width", ssrWidth: o = /* @__PURE__ */ zg() } = l, f = typeof o == "number", d = f ? Fl(!1) : { value: !0 };
  f && Kg(() => d.value = !!a);
  function h(R, E) {
    return !d.value && f ? R === "min" ? o >= $r(E) : o <= $r(E) : a ? a.matchMedia(`(${R}-width: ${E})`).matches : !1;
  }
  const x = (R) => Sr(() => `(min-width: ${i(R)})`, l), y = (R) => Sr(() => `(max-width: ${i(R)})`, l), I = Object.keys(e).reduce((R, E) => (Object.defineProperty(R, E, {
    get: () => s === "min-width" ? x(E) : y(E),
    enumerable: !0,
    configurable: !0
  }), R), {});
  function q() {
    const R = Object.keys(e).map((E) => [
      E,
      I[E],
      $r(i(E))
    ]).sort((E, M) => E[2] - M[2]);
    return _e(() => R.filter(([, E]) => E.value).map(([E]) => E));
  }
  return Object.assign(I, {
    greaterOrEqual: x,
    smallerOrEqual: y,
    greater(R) {
      return Sr(() => `(min-width: ${i(R, 0.1)})`, l);
    },
    smaller(R) {
      return Sr(() => `(max-width: ${i(R, -0.1)})`, l);
    },
    between(R, E) {
      return Sr(() => `(min-width: ${i(R)}) and (max-width: ${i(E, -0.1)})`, l);
    },
    isGreater(R) {
      return h("min", i(R, 0.1));
    },
    isGreaterOrEqual(R) {
      return h("min", i(R));
    },
    isSmaller(R) {
      return h("max", i(R, -0.1));
    },
    isSmallerOrEqual(R) {
      return h("max", i(R));
    },
    isInBetween(R, E) {
      return h("min", i(R)) && h("max", i(E, -0.1));
    },
    current: q,
    active() {
      const R = q();
      return _e(() => R.value.length === 0 ? "" : R.value.at(s === "min-width" ? -1 : 0));
    }
  });
}
const Bs = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Zs = "__vueuse_ssr_handlers__", o0 = /* @__PURE__ */ m0();
function m0() {
  return Zs in Bs || (Bs[Zs] = Bs[Zs] || {}), Bs[Zs];
}
function f0(e, l) {
  return o0[e] || l;
}
function d0(e) {
  return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number";
}
const p0 = {
  boolean: {
    read: (e) => e === "true",
    write: (e) => String(e)
  },
  object: {
    read: (e) => JSON.parse(e),
    write: (e) => JSON.stringify(e)
  },
  number: {
    read: (e) => Number.parseFloat(e),
    write: (e) => String(e)
  },
  any: {
    read: (e) => e,
    write: (e) => String(e)
  },
  string: {
    read: (e) => e,
    write: (e) => String(e)
  },
  map: {
    read: (e) => new Map(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e.entries()))
  },
  set: {
    read: (e) => new Set(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e))
  },
  date: {
    read: (e) => new Date(e),
    write: (e) => e.toISOString()
  }
}, Nd = "vueuse-storage";
function h0(e, l, i, a = {}) {
  var s;
  const { flush: o = "pre", deep: f = !0, listenToStorageChanges: d = !0, writeDefaults: h = !0, mergeDefaults: x = !1, shallow: y, window: I = na, eventFilter: q, onError: R = (xe) => {
    console.error(xe);
  }, initOnMounted: E } = a, M = (y ? Fl : Fe)(l), U = _e(() => hn(e));
  if (!i) try {
    i = f0("getDefaultStorage", () => na?.localStorage)();
  } catch (xe) {
    R(xe);
  }
  if (!i) return M;
  const z = hn(l), X = d0(z), B = (s = a.serializer) !== null && s !== void 0 ? s : p0[X], { pause: K, resume: W } = e0(M, (xe) => me(xe), {
    flush: o,
    deep: f,
    eventFilter: q
  });
  Cn(U, () => re(), { flush: o });
  let ae = !1;
  const ne = (xe) => {
    E && !ae || re(xe);
  }, oe = (xe) => {
    E && !ae || ye(xe);
  };
  I && d && (i instanceof Storage ? Tm(I, "storage", ne, { passive: !0 }) : Tm(I, Nd, oe)), E ? Kg(() => {
    ae = !0, re();
  }) : re();
  function k(xe, Se) {
    if (I) {
      const ge = {
        key: U.value,
        oldValue: xe,
        newValue: Se,
        storageArea: i
      };
      I.dispatchEvent(i instanceof Storage ? new StorageEvent("storage", ge) : new CustomEvent(Nd, { detail: ge }));
    }
  }
  function me(xe) {
    try {
      const Se = i.getItem(U.value);
      if (xe == null)
        k(Se, null), i.removeItem(U.value);
      else {
        const ge = B.write(xe);
        Se !== ge && (i.setItem(U.value, ge), k(Se, ge));
      }
    } catch (Se) {
      R(Se);
    }
  }
  function be(xe) {
    const Se = xe ? xe.newValue : i.getItem(U.value);
    if (Se == null)
      return h && z != null && i.setItem(U.value, B.write(z)), z;
    if (!xe && x) {
      const ge = B.read(Se);
      return typeof x == "function" ? x(ge, z) : X === "object" && !Array.isArray(ge) ? {
        ...z,
        ...ge
      } : ge;
    } else return typeof Se != "string" ? Se : B.read(Se);
  }
  function re(xe) {
    if (!(xe && xe.storageArea !== i)) {
      if (xe && xe.key == null) {
        M.value = z;
        return;
      }
      if (!(xe && xe.key !== U.value)) {
        K();
        try {
          const Se = B.write(M.value);
          (xe === void 0 || xe?.newValue !== Se) && (M.value = be(xe));
        } catch (Se) {
          R(Se);
        } finally {
          xe ? il(W) : W();
        }
      }
    }
  }
  function ye(xe) {
    re(xe.detail);
  }
  return M;
}
const g0 = {
  multiple: !0,
  accept: "*",
  reset: !1,
  directory: !1
};
function v0(e) {
  if (!e) return null;
  if (e instanceof FileList) return e;
  const l = new DataTransfer();
  for (const i of e) l.items.add(i);
  return l.files;
}
function x0(e = {}) {
  const { document: l = i0 } = e, i = Fe(v0(e.initialFiles)), { on: a, trigger: s } = /* @__PURE__ */ Ed(), { on: o, trigger: f } = /* @__PURE__ */ Ed(), d = _e(() => {
    var I;
    const q = (I = Gg(e.input)) !== null && I !== void 0 ? I : l ? l.createElement("input") : void 0;
    return q && (q.type = "file", q.onchange = (R) => {
      i.value = R.target.files, s(i.value);
    }, q.oncancel = () => {
      f();
    }), q;
  }), h = () => {
    i.value = null, d.value && d.value.value && (d.value.value = "", s(null));
  }, x = (I) => {
    const q = d.value;
    q && (q.multiple = hn(I.multiple), q.accept = hn(I.accept), q.webkitdirectory = hn(I.directory), jD(I, "capture") && (q.capture = hn(I.capture)));
  }, y = (I) => {
    const q = d.value;
    if (!q) return;
    const R = {
      ...g0,
      ...e,
      ...I
    };
    x(R), hn(R.reset) && h(), q.click();
  };
  return Ml(() => {
    x(e);
  }), {
    files: Bi(i),
    open: y,
    reset: h,
    onCancel: o,
    onChange: a
  };
}
var y0 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function I0(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ac = { exports: {} }, L0 = ac.exports, Fd;
function D0() {
  return Fd || (Fd = 1, function(e, l) {
    (function(i, a) {
      e.exports = a();
    })(L0, function() {
      var i = function(n, t) {
        return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(u, r) {
          u.__proto__ = r;
        } || function(u, r) {
          for (var c in r) Object.prototype.hasOwnProperty.call(r, c) && (u[c] = r[c]);
        })(n, t);
      }, a = function() {
        return (a = Object.assign || function(n) {
          for (var t, u = 1, r = arguments.length; u < r; u++) for (var c in t = arguments[u]) Object.prototype.hasOwnProperty.call(t, c) && (n[c] = t[c]);
          return n;
        }).apply(this, arguments);
      };
      function s(n, t, u) {
        for (var r, c = 0, m = t.length; c < m; c++) !r && c in t || ((r = r || Array.prototype.slice.call(t, 0, c))[c] = t[c]);
        return n.concat(r || Array.prototype.slice.call(t));
      }
      var o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : y0, f = Object.keys, d = Array.isArray;
      function h(n, t) {
        return typeof t != "object" || f(t).forEach(function(u) {
          n[u] = t[u];
        }), n;
      }
      typeof Promise > "u" || o.Promise || (o.Promise = Promise);
      var x = Object.getPrototypeOf, y = {}.hasOwnProperty;
      function I(n, t) {
        return y.call(n, t);
      }
      function q(n, t) {
        typeof t == "function" && (t = t(x(n))), (typeof Reflect > "u" ? f : Reflect.ownKeys)(t).forEach(function(u) {
          E(n, u, t[u]);
        });
      }
      var R = Object.defineProperty;
      function E(n, t, u, r) {
        R(n, t, h(u && I(u, "get") && typeof u.get == "function" ? { get: u.get, set: u.set, configurable: !0 } : { value: u, configurable: !0, writable: !0 }, r));
      }
      function M(n) {
        return { from: function(t) {
          return n.prototype = Object.create(t.prototype), E(n.prototype, "constructor", n), { extend: q.bind(null, n.prototype) };
        } };
      }
      var U = Object.getOwnPropertyDescriptor, z = [].slice;
      function X(n, t, u) {
        return z.call(n, t, u);
      }
      function B(n, t) {
        return t(n);
      }
      function K(n) {
        if (!n) throw new Error("Assertion Failed");
      }
      function W(n) {
        o.setImmediate ? setImmediate(n) : setTimeout(n, 0);
      }
      function ae(n, t) {
        if (typeof t == "string" && I(n, t)) return n[t];
        if (!t) return n;
        if (typeof t != "string") {
          for (var u = [], r = 0, c = t.length; r < c; ++r) {
            var m = ae(n, t[r]);
            u.push(m);
          }
          return u;
        }
        var p = t.indexOf(".");
        if (p !== -1) {
          var g = n[t.substr(0, p)];
          return g == null ? void 0 : ae(g, t.substr(p + 1));
        }
      }
      function ne(n, t, u) {
        if (n && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(n))) if (typeof t != "string" && "length" in t) {
          K(typeof u != "string" && "length" in u);
          for (var r = 0, c = t.length; r < c; ++r) ne(n, t[r], u[r]);
        } else {
          var m, p, g = t.indexOf(".");
          g !== -1 ? (m = t.substr(0, g), (p = t.substr(g + 1)) === "" ? u === void 0 ? d(n) && !isNaN(parseInt(m)) ? n.splice(m, 1) : delete n[m] : n[m] = u : ne(g = !(g = n[m]) || !I(n, m) ? n[m] = {} : g, p, u)) : u === void 0 ? d(n) && !isNaN(parseInt(t)) ? n.splice(t, 1) : delete n[t] : n[t] = u;
        }
      }
      function oe(n) {
        var t, u = {};
        for (t in n) I(n, t) && (u[t] = n[t]);
        return u;
      }
      var k = [].concat;
      function me(n) {
        return k.apply([], n);
      }
      var Ue = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(me([8, 16, 32, 64].map(function(n) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + n + "Array";
        });
      }))).filter(function(n) {
        return o[n];
      }), be = new Set(Ue.map(function(n) {
        return o[n];
      })), re = null;
      function ye(n) {
        return re = /* @__PURE__ */ new WeakMap(), n = function t(u) {
          if (!u || typeof u != "object") return u;
          var r = re.get(u);
          if (r) return r;
          if (d(u)) {
            r = [], re.set(u, r);
            for (var c = 0, m = u.length; c < m; ++c) r.push(t(u[c]));
          } else if (be.has(u.constructor)) r = u;
          else {
            var p, g = x(u);
            for (p in r = g === Object.prototype ? {} : Object.create(g), re.set(u, r), u) I(u, p) && (r[p] = t(u[p]));
          }
          return r;
        }(n), re = null, n;
      }
      var xe = {}.toString;
      function Se(n) {
        return xe.call(n).slice(8, -1);
      }
      var ge = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", ce = typeof ge == "symbol" ? function(n) {
        var t;
        return n != null && (t = n[ge]) && t.apply(n);
      } : function() {
        return null;
      };
      function de(n, t) {
        return t = n.indexOf(t), 0 <= t && n.splice(t, 1), 0 <= t;
      }
      var Le = {};
      function Ae(n) {
        var t, u, r, c;
        if (arguments.length === 1) {
          if (d(n)) return n.slice();
          if (this === Le && typeof n == "string") return [n];
          if (c = ce(n)) {
            for (u = []; !(r = c.next()).done; ) u.push(r.value);
            return u;
          }
          if (n == null) return [n];
          if (typeof (t = n.length) != "number") return [n];
          for (u = new Array(t); t--; ) u[t] = n[t];
          return u;
        }
        for (t = arguments.length, u = new Array(t); t--; ) u[t] = arguments[t];
        return u;
      }
      var We = typeof Symbol < "u" ? function(n) {
        return n[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ze = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], In = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ze), je = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function cn(n, t) {
        this.name = n, this.message = t;
      }
      function bn(n, t) {
        return n + ". Errors: " + Object.keys(t).map(function(u) {
          return t[u].toString();
        }).filter(function(u, r, c) {
          return c.indexOf(u) === r;
        }).join(`
`);
      }
      function gn(n, t, u, r) {
        this.failures = t, this.failedKeys = r, this.successCount = u, this.message = bn(n, t);
      }
      function tn(n, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(u) {
          return t[u];
        }), this.failuresByPos = t, this.message = bn(n, this.failures);
      }
      M(cn).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), M(gn).from(cn), M(tn).from(cn);
      var V = In.reduce(function(n, t) {
        return n[t] = t + "Error", n;
      }, {}), _ = cn, Z = In.reduce(function(n, t) {
        var u = t + "Error";
        function r(c, m) {
          this.name = u, c ? typeof c == "string" ? (this.message = "".concat(c).concat(m ? `
 ` + m : ""), this.inner = m || null) : typeof c == "object" && (this.message = "".concat(c.name, " ").concat(c.message), this.inner = c) : (this.message = je[t] || u, this.inner = null);
        }
        return M(r).from(_), n[t] = r, n;
      }, {});
      Z.Syntax = SyntaxError, Z.Type = TypeError, Z.Range = RangeError;
      var ue = Ze.reduce(function(n, t) {
        return n[t + "Error"] = Z[t], n;
      }, {}), Qe = In.reduce(function(n, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (n[t + "Error"] = Z[t]), n;
      }, {});
      function De() {
      }
      function j(n) {
        return n;
      }
      function ie(n, t) {
        return n == null || n === j ? t : function(u) {
          return t(n(u));
        };
      }
      function fe(n, t) {
        return function() {
          n.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function Ce(n, t) {
        return n === De ? t : function() {
          var u = n.apply(this, arguments);
          u !== void 0 && (arguments[0] = u);
          var r = this.onsuccess, c = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var m = t.apply(this, arguments);
          return r && (this.onsuccess = this.onsuccess ? fe(r, this.onsuccess) : r), c && (this.onerror = this.onerror ? fe(c, this.onerror) : c), m !== void 0 ? m : u;
        };
      }
      function Ie(n, t) {
        return n === De ? t : function() {
          n.apply(this, arguments);
          var u = this.onsuccess, r = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), u && (this.onsuccess = this.onsuccess ? fe(u, this.onsuccess) : u), r && (this.onerror = this.onerror ? fe(r, this.onerror) : r);
        };
      }
      function we(n, t) {
        return n === De ? t : function(u) {
          var r = n.apply(this, arguments);
          h(u, r);
          var c = this.onsuccess, m = this.onerror;
          return this.onsuccess = null, this.onerror = null, u = t.apply(this, arguments), c && (this.onsuccess = this.onsuccess ? fe(c, this.onsuccess) : c), m && (this.onerror = this.onerror ? fe(m, this.onerror) : m), r === void 0 ? u === void 0 ? void 0 : u : h(r, u);
        };
      }
      function Ne(n, t) {
        return n === De ? t : function() {
          return t.apply(this, arguments) !== !1 && n.apply(this, arguments);
        };
      }
      function Ee(n, t) {
        return n === De ? t : function() {
          var u = n.apply(this, arguments);
          if (u && typeof u.then == "function") {
            for (var r = this, c = arguments.length, m = new Array(c); c--; ) m[c] = arguments[c];
            return u.then(function() {
              return t.apply(r, m);
            });
          }
          return t.apply(this, arguments);
        };
      }
      Qe.ModifyError = gn, Qe.DexieError = cn, Qe.BulkError = tn;
      var Oe = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function Pe(n) {
        Oe = n;
      }
      var Ke = {}, ke = 100, Ue = typeof Promise > "u" ? [] : function() {
        var n = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [n, x(n), n];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, x(t), n];
      }(), Ze = Ue[0], In = Ue[1], Ue = Ue[2], In = In && In.then, Je = Ze && Ze.constructor, yn = !!Ue, on = function(n, t) {
        Fn.push([n, t]), Tn && (queueMicrotask(Ja), Tn = !1);
      }, Bn = !0, Tn = !0, Dn = [], Nn = [], yl = j, Rn = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: De, pgp: !1, env: {}, finalize: De }, se = Rn, Fn = [], Zn = 0, Il = [];
      function ee(n) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = se;
        if (typeof n != "function") {
          if (n !== Ke) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && qt(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function u(r, c) {
          try {
            c(function(m) {
              if (r._state === null) {
                if (m === r) throw new TypeError("A promise cannot be resolved with itself.");
                var p = r._lib && rl();
                m && typeof m.then == "function" ? u(r, function(g, L) {
                  m instanceof ee ? m._then(g, L) : m.then(g, L);
                }) : (r._state = !0, r._value = m, Xi(r)), p && sl();
              }
            }, qt.bind(null, r));
          } catch (m) {
            qt(r, m);
          }
        }(this, n);
      }
      var Pt = { get: function() {
        var n = se, t = Hl;
        function u(r, c) {
          var m = this, p = !n.global && (n !== se || t !== Hl), g = p && !Kn(), L = new ee(function(O, w) {
            Rt(m, new Yi(Ji(r, n, p, g), Ji(c, n, p, g), O, w, n));
          });
          return this._consoleTask && (L._consoleTask = this._consoleTask), L;
        }
        return u.prototype = Ke, u;
      }, set: function(n) {
        E(this, "then", n && n.prototype === Ke ? Pt : { get: function() {
          return n;
        }, set: Pt.set });
      } };
      function Yi(n, t, u, r, c) {
        this.onFulfilled = typeof n == "function" ? n : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = u, this.reject = r, this.psd = c;
      }
      function qt(n, t) {
        var u, r;
        Nn.push(t), n._state === null && (u = n._lib && rl(), t = yl(t), n._state = !1, n._value = t, r = n, Dn.some(function(c) {
          return c._value === r._value;
        }) || Dn.push(r), Xi(n), u && sl());
      }
      function Xi(n) {
        var t = n._listeners;
        n._listeners = [];
        for (var u = 0, r = t.length; u < r; ++u) Rt(n, t[u]);
        var c = n._PSD;
        --c.ref || c.finalize(), Zn === 0 && (++Zn, on(function() {
          --Zn == 0 && At();
        }, []));
      }
      function Rt(n, t) {
        if (n._state !== null) {
          var u = n._state ? t.onFulfilled : t.onRejected;
          if (u === null) return (n._state ? t.resolve : t.reject)(n._value);
          ++t.psd.ref, ++Zn, on(Qa, [u, n, t]);
        } else n._listeners.push(t);
      }
      function Qa(n, t, u) {
        try {
          var r, c = t._value;
          !t._state && Nn.length && (Nn = []), r = Oe && t._consoleTask ? t._consoleTask.run(function() {
            return n(c);
          }) : n(c), t._state || Nn.indexOf(c) !== -1 || function(m) {
            for (var p = Dn.length; p; ) if (Dn[--p]._value === m._value) return Dn.splice(p, 1);
          }(t), u.resolve(r);
        } catch (m) {
          u.reject(m);
        } finally {
          --Zn == 0 && At(), --u.psd.ref || u.psd.finalize();
        }
      }
      function Ja() {
        Qn(Rn, function() {
          rl() && sl();
        });
      }
      function rl() {
        var n = Bn;
        return Tn = Bn = !1, n;
      }
      function sl() {
        var n, t, u;
        do
          for (; 0 < Fn.length; ) for (n = Fn, Fn = [], u = n.length, t = 0; t < u; ++t) {
            var r = n[t];
            r[0].apply(null, r[1]);
          }
        while (0 < Fn.length);
        Tn = Bn = !0;
      }
      function At() {
        var n = Dn;
        Dn = [], n.forEach(function(r) {
          r._PSD.onunhandled.call(null, r._value, r);
        });
        for (var t = Il.slice(0), u = t.length; u; ) t[--u]();
      }
      function Gl(n) {
        return new ee(Ke, !1, n);
      }
      function Be(n, t) {
        var u = se;
        return function() {
          var r = rl(), c = se;
          try {
            return Gn(u, !0), n.apply(this, arguments);
          } catch (m) {
            t && t(m);
          } finally {
            Gn(c, !1), r && sl();
          }
        };
      }
      q(ee.prototype, { then: Pt, _then: function(n, t) {
        Rt(this, new Yi(null, null, n, t, se));
      }, catch: function(n) {
        if (arguments.length === 1) return this.then(null, n);
        var t = n, u = arguments[1];
        return typeof t == "function" ? this.then(null, function(r) {
          return (r instanceof t ? u : Gl)(r);
        }) : this.then(null, function(r) {
          return (r && r.name === t ? u : Gl)(r);
        });
      }, finally: function(n) {
        return this.then(function(t) {
          return ee.resolve(n()).then(function() {
            return t;
          });
        }, function(t) {
          return ee.resolve(n()).then(function() {
            return Gl(t);
          });
        });
      }, timeout: function(n, t) {
        var u = this;
        return n < 1 / 0 ? new ee(function(r, c) {
          var m = setTimeout(function() {
            return c(new Z.Timeout(t));
          }, n);
          u.then(r, c).finally(clearTimeout.bind(null, m));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && E(ee.prototype, Symbol.toStringTag, "Dexie.Promise"), Rn.env = Qi(), q(ee, { all: function() {
        var n = Ae.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.length === 0 && t([]);
          var r = n.length;
          n.forEach(function(c, m) {
            return ee.resolve(c).then(function(p) {
              n[m] = p, --r || t(n);
            }, u);
          });
        });
      }, resolve: function(n) {
        return n instanceof ee ? n : n && typeof n.then == "function" ? new ee(function(t, u) {
          n.then(t, u);
        }) : new ee(Ke, !0, n);
      }, reject: Gl, race: function() {
        var n = Ae.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.map(function(r) {
            return ee.resolve(r).then(t, u);
          });
        });
      }, PSD: { get: function() {
        return se;
      }, set: function(n) {
        return se = n;
      } }, totalEchoes: { get: function() {
        return Hl;
      } }, newPSD: Un, usePSD: Qn, scheduler: { get: function() {
        return on;
      }, set: function(n) {
        on = n;
      } }, rejectionMapper: { get: function() {
        return yl;
      }, set: function(n) {
        yl = n;
      } }, follow: function(n, t) {
        return new ee(function(u, r) {
          return Un(function(c, m) {
            var p = se;
            p.unhandleds = [], p.onunhandled = m, p.finalize = fe(function() {
              var g, L = this;
              g = function() {
                L.unhandleds.length === 0 ? c() : m(L.unhandleds[0]);
              }, Il.push(function O() {
                g(), Il.splice(Il.indexOf(O), 1);
              }), ++Zn, on(function() {
                --Zn == 0 && At();
              }, []);
            }, p.finalize), n();
          }, t, u, r);
        });
      } }), Je && (Je.allSettled && E(ee, "allSettled", function() {
        var n = Ae.apply(null, arguments).map($l);
        return new ee(function(t) {
          n.length === 0 && t([]);
          var u = n.length, r = new Array(u);
          n.forEach(function(c, m) {
            return ee.resolve(c).then(function(p) {
              return r[m] = { status: "fulfilled", value: p };
            }, function(p) {
              return r[m] = { status: "rejected", reason: p };
            }).then(function() {
              return --u || t(r);
            });
          });
        });
      }), Je.any && typeof AggregateError < "u" && E(ee, "any", function() {
        var n = Ae.apply(null, arguments).map($l);
        return new ee(function(t, u) {
          n.length === 0 && u(new AggregateError([]));
          var r = n.length, c = new Array(r);
          n.forEach(function(m, p) {
            return ee.resolve(m).then(function(g) {
              return t(g);
            }, function(g) {
              c[p] = g, --r || u(new AggregateError(c));
            });
          });
        });
      }), Je.withResolvers && (ee.withResolvers = Je.withResolvers));
      var en = { awaits: 0, echoes: 0, id: 0 }, er = 0, zl = [], jl = 0, Hl = 0, nr = 0;
      function Un(n, t, u, r) {
        var c = se, m = Object.create(c);
        return m.parent = c, m.ref = 0, m.global = !1, m.id = ++nr, Rn.env, m.env = yn ? { Promise: ee, PromiseProp: { value: ee, configurable: !0, writable: !0 }, all: ee.all, race: ee.race, allSettled: ee.allSettled, any: ee.any, resolve: ee.resolve, reject: ee.reject } : {}, t && h(m, t), ++c.ref, m.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, r = Qn(m, n, u, r), m.ref === 0 && m.finalize(), r;
      }
      function cl() {
        return en.id || (en.id = ++er), ++en.awaits, en.echoes += ke, en.id;
      }
      function Kn() {
        return !!en.awaits && (--en.awaits == 0 && (en.id = 0), en.echoes = en.awaits * ke, !0);
      }
      function $l(n) {
        return en.echoes && n && n.constructor === Je ? (cl(), n.then(function(t) {
          return Kn(), t;
        }, function(t) {
          return Kn(), He(t);
        })) : n;
      }
      function lr() {
        var n = zl[zl.length - 1];
        zl.pop(), Gn(n, !1);
      }
      function Gn(n, t) {
        var u, r = se;
        (t ? !en.echoes || jl++ && n === se : !jl || --jl && n === se) || queueMicrotask(t ? (function(c) {
          ++Hl, en.echoes && --en.echoes != 0 || (en.echoes = en.awaits = en.id = 0), zl.push(se), Gn(c, !0);
        }).bind(null, n) : lr), n !== se && (se = n, r === Rn && (Rn.env = Qi()), yn && (u = Rn.env.Promise, t = n.env, (r.global || n.global) && (Object.defineProperty(o, "Promise", t.PromiseProp), u.all = t.all, u.race = t.race, u.resolve = t.resolve, u.reject = t.reject, t.allSettled && (u.allSettled = t.allSettled), t.any && (u.any = t.any))));
      }
      function Qi() {
        var n = o.Promise;
        return yn ? { Promise: n, PromiseProp: Object.getOwnPropertyDescriptor(o, "Promise"), all: n.all, race: n.race, allSettled: n.allSettled, any: n.any, resolve: n.resolve, reject: n.reject } : {};
      }
      function Qn(n, t, u, r, c) {
        var m = se;
        try {
          return Gn(n, !0), t(u, r, c);
        } finally {
          Gn(m, !1);
        }
      }
      function Ji(n, t, u, r) {
        return typeof n != "function" ? n : function() {
          var c = se;
          u && cl(), Gn(t, !0);
          try {
            return n.apply(this, arguments);
          } finally {
            Gn(c, !1), r && queueMicrotask(Kn);
          }
        };
      }
      function Et(n) {
        Promise === Je && en.echoes === 0 ? jl === 0 ? n() : enqueueNativeMicroTask(n) : setTimeout(n, 0);
      }
      ("" + In).indexOf("[native code]") === -1 && (cl = Kn = De);
      var He = ee.reject, Jn = "", An = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", eu = "String expected.", ol = [], Wl = "__dbnames", _t = "readonly", Nt = "readwrite";
      function el(n, t) {
        return n ? t ? function() {
          return n.apply(this, arguments) && t.apply(this, arguments);
        } : n : t;
      }
      var nu = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Yl(n) {
        return typeof n != "string" || /\./.test(n) ? function(t) {
          return t;
        } : function(t) {
          return t[n] === void 0 && n in t && delete (t = ye(t))[n], t;
        };
      }
      function lu() {
        throw Z.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Te(n, t) {
        try {
          var u = tu(n), r = tu(t);
          if (u !== r) return u === "Array" ? 1 : r === "Array" ? -1 : u === "binary" ? 1 : r === "binary" ? -1 : u === "string" ? 1 : r === "string" ? -1 : u === "Date" ? 1 : r !== "Date" ? NaN : -1;
          switch (u) {
            case "number":
            case "Date":
            case "string":
              return t < n ? 1 : n < t ? -1 : 0;
            case "binary":
              return function(c, m) {
                for (var p = c.length, g = m.length, L = p < g ? p : g, O = 0; O < L; ++O) if (c[O] !== m[O]) return c[O] < m[O] ? -1 : 1;
                return p === g ? 0 : p < g ? -1 : 1;
              }(iu(n), iu(t));
            case "Array":
              return function(c, m) {
                for (var p = c.length, g = m.length, L = p < g ? p : g, O = 0; O < L; ++O) {
                  var w = Te(c[O], m[O]);
                  if (w !== 0) return w;
                }
                return p === g ? 0 : p < g ? -1 : 1;
              }(n, t);
          }
        } catch {
        }
        return NaN;
      }
      function tu(n) {
        var t = typeof n;
        return t != "object" ? t : ArrayBuffer.isView(n) ? "binary" : (n = Se(n), n === "ArrayBuffer" ? "binary" : n);
      }
      function iu(n) {
        return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n);
      }
      function Xl(n, t, u) {
        var r = n.schema.yProps;
        return r ? (t && 0 < u.numFailures && (t = t.filter(function(c, m) {
          return !u.failures[m];
        })), Promise.all(r.map(function(c) {
          return c = c.updatesTable, t ? n.db.table(c).where("k").anyOf(t).delete() : n.db.table(c).clear();
        })).then(function() {
          return u;
        })) : u;
      }
      var uu = (Ve.prototype._trans = function(n, t, u) {
        var r = this._tx || se.trans, c = this.name, m = Oe && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(n === "readonly" ? "read" : "write", " ").concat(this.name));
        function p(O, w, v) {
          if (!v.schema[c]) throw new Z.NotFound("Table " + c + " not part of transaction");
          return t(v.idbtrans, v);
        }
        var g = rl();
        try {
          var L = r && r.db._novip === this.db._novip ? r === se.trans ? r._promise(n, p, u) : Un(function() {
            return r._promise(n, p, u);
          }, { trans: r, transless: se.transless || se }) : function O(w, v, T, D) {
            if (w.idbdb && (w._state.openComplete || se.letThrough || w._vip)) {
              var b = w._createTransaction(v, T, w._dbSchema);
              try {
                b.create(), w._state.PR1398_maxLoop = 3;
              } catch (C) {
                return C.name === V.InvalidState && w.isOpen() && 0 < --w._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), w.close({ disableAutoOpen: !1 }), w.open().then(function() {
                  return O(w, v, T, D);
                })) : He(C);
              }
              return b._promise(v, function(C, S) {
                return Un(function() {
                  return se.trans = b, D(C, S, b);
                });
              }).then(function(C) {
                if (v === "readwrite") try {
                  b.idbtrans.commit();
                } catch {
                }
                return v === "readonly" ? C : b._completion.then(function() {
                  return C;
                });
              });
            }
            if (w._state.openComplete) return He(new Z.DatabaseClosed(w._state.dbOpenError));
            if (!w._state.isBeingOpened) {
              if (!w._state.autoOpen) return He(new Z.DatabaseClosed());
              w.open().catch(De);
            }
            return w._state.dbReadyPromise.then(function() {
              return O(w, v, T, D);
            });
          }(this.db, n, [this.name], p);
          return m && (L._consoleTask = m, L = L.catch(function(O) {
            return console.trace(O), He(O);
          })), L;
        } finally {
          g && sl();
        }
      }, Ve.prototype.get = function(n, t) {
        var u = this;
        return n && n.constructor === Object ? this.where(n).first(t) : n == null ? He(new Z.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(r) {
          return u.core.get({ trans: r, key: n }).then(function(c) {
            return u.hook.reading.fire(c);
          });
        }).then(t);
      }, Ve.prototype.where = function(n) {
        if (typeof n == "string") return new this.db.WhereClause(this, n);
        if (d(n)) return new this.db.WhereClause(this, "[".concat(n.join("+"), "]"));
        var t = f(n);
        if (t.length === 1) return this.where(t[0]).equals(n[t[0]]);
        var u = this.schema.indexes.concat(this.schema.primKey).filter(function(g) {
          if (g.compound && t.every(function(O) {
            return 0 <= g.keyPath.indexOf(O);
          })) {
            for (var L = 0; L < t.length; ++L) if (t.indexOf(g.keyPath[L]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(g, L) {
          return g.keyPath.length - L.keyPath.length;
        })[0];
        if (u && this.db._maxKey !== Jn) {
          var m = u.keyPath.slice(0, t.length);
          return this.where(m).equals(m.map(function(L) {
            return n[L];
          }));
        }
        !u && Oe && console.warn("The query ".concat(JSON.stringify(n), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var r = this.schema.idxByName;
        function c(g, L) {
          return Te(g, L) === 0;
        }
        var p = t.reduce(function(v, L) {
          var O = v[0], w = v[1], v = r[L], T = n[L];
          return [O || v, O || !v ? el(w, v && v.multi ? function(D) {
            return D = ae(D, L), d(D) && D.some(function(b) {
              return c(T, b);
            });
          } : function(D) {
            return c(T, ae(D, L));
          }) : w];
        }, [null, null]), m = p[0], p = p[1];
        return m ? this.where(m.name).equals(n[m.keyPath]).filter(p) : u ? this.filter(p) : this.where(t).equals("");
      }, Ve.prototype.filter = function(n) {
        return this.toCollection().and(n);
      }, Ve.prototype.count = function(n) {
        return this.toCollection().count(n);
      }, Ve.prototype.offset = function(n) {
        return this.toCollection().offset(n);
      }, Ve.prototype.limit = function(n) {
        return this.toCollection().limit(n);
      }, Ve.prototype.each = function(n) {
        return this.toCollection().each(n);
      }, Ve.prototype.toArray = function(n) {
        return this.toCollection().toArray(n);
      }, Ve.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ve.prototype.orderBy = function(n) {
        return new this.db.Collection(new this.db.WhereClause(this, d(n) ? "[".concat(n.join("+"), "]") : n));
      }, Ve.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ve.prototype.mapToClass = function(n) {
        var t, u = this.db, r = this.name;
        function c() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = n).prototype instanceof lu && (function(L, O) {
          if (typeof O != "function" && O !== null) throw new TypeError("Class extends value " + String(O) + " is not a constructor or null");
          function w() {
            this.constructor = L;
          }
          i(L, O), L.prototype = O === null ? Object.create(O) : (w.prototype = O.prototype, new w());
        }(c, t = n), Object.defineProperty(c.prototype, "db", { get: function() {
          return u;
        }, enumerable: !1, configurable: !0 }), c.prototype.table = function() {
          return r;
        }, n = c);
        for (var m = /* @__PURE__ */ new Set(), p = n.prototype; p; p = x(p)) Object.getOwnPropertyNames(p).forEach(function(L) {
          return m.add(L);
        });
        function g(L) {
          if (!L) return L;
          var O, w = Object.create(n.prototype);
          for (O in L) if (!m.has(O)) try {
            w[O] = L[O];
          } catch {
          }
          return w;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = g, this.hook("reading", g), n;
      }, Ve.prototype.defineClass = function() {
        return this.mapToClass(function(n) {
          h(this, n);
        });
      }, Ve.prototype.add = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, m = r.keyPath, p = n;
        return m && c && (p = Yl(m)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "add", keys: t != null ? [t] : null, values: [p] });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (m) try {
            ne(n, m, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.update = function(n, t) {
        return typeof n != "object" || d(n) ? this.where(":id").equals(n).modify(t) : (n = ae(n, this.schema.primKey.keyPath), n === void 0 ? He(new Z.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(n).modify(t));
      }, Ve.prototype.put = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, m = r.keyPath, p = n;
        return m && c && (p = Yl(m)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "put", values: [p], keys: t != null ? [t] : null });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (m) try {
            ne(n, m, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.delete = function(n) {
        var t = this;
        return this._trans("readwrite", function(u) {
          return t.core.mutate({ trans: u, type: "delete", keys: [n] }).then(function(r) {
            return Xl(t, [n], r);
          }).then(function(r) {
            return r.numFailures ? ee.reject(r.failures[0]) : void 0;
          });
        });
      }, Ve.prototype.clear = function() {
        var n = this;
        return this._trans("readwrite", function(t) {
          return n.core.mutate({ trans: t, type: "deleteRange", range: nu }).then(function(u) {
            return Xl(n, null, u);
          });
        }).then(function(t) {
          return t.numFailures ? ee.reject(t.failures[0]) : void 0;
        });
      }, Ve.prototype.bulkGet = function(n) {
        var t = this;
        return this._trans("readonly", function(u) {
          return t.core.getMany({ keys: n, trans: u }).then(function(r) {
            return r.map(function(c) {
              return t.hook.reading.fire(c);
            });
          });
        });
      }, Ve.prototype.bulkAdd = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, m = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new Z.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new Z.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Yl(O)) : n;
          return r.core.mutate({ trans: p, type: "add", keys: c, values: O, wantResults: m }).then(function(b) {
            var v = b.numFailures, T = b.results, D = b.lastResult, b = b.failures;
            if (v === 0) return m ? T : D;
            throw new tn("".concat(r.name, ".bulkAdd(): ").concat(v, " of ").concat(L, " operations failed"), b);
          });
        });
      }, Ve.prototype.bulkPut = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, m = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new Z.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new Z.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Yl(O)) : n;
          return r.core.mutate({ trans: p, type: "put", keys: c, values: O, wantResults: m }).then(function(b) {
            var v = b.numFailures, T = b.results, D = b.lastResult, b = b.failures;
            if (v === 0) return m ? T : D;
            throw new tn("".concat(r.name, ".bulkPut(): ").concat(v, " of ").concat(L, " operations failed"), b);
          });
        });
      }, Ve.prototype.bulkUpdate = function(n) {
        var t = this, u = this.core, r = n.map(function(p) {
          return p.key;
        }), c = n.map(function(p) {
          return p.changes;
        }), m = [];
        return this._trans("readwrite", function(p) {
          return u.getMany({ trans: p, keys: r, cache: "clone" }).then(function(g) {
            var L = [], O = [];
            n.forEach(function(v, T) {
              var D = v.key, b = v.changes, C = g[T];
              if (C) {
                for (var S = 0, P = Object.keys(b); S < P.length; S++) {
                  var A = P[S], N = b[A];
                  if (A === t.schema.primKey.keyPath) {
                    if (Te(N, D) !== 0) throw new Z.Constraint("Cannot update primary key in bulkUpdate()");
                  } else ne(C, A, N);
                }
                m.push(T), L.push(D), O.push(C);
              }
            });
            var w = L.length;
            return u.mutate({ trans: p, type: "put", keys: L, values: O, updates: { keys: r, changeSpecs: c } }).then(function(v) {
              var T = v.numFailures, D = v.failures;
              if (T === 0) return w;
              for (var b = 0, C = Object.keys(D); b < C.length; b++) {
                var S, P = C[b], A = m[Number(P)];
                A != null && (S = D[P], delete D[P], D[A] = S);
              }
              throw new tn("".concat(t.name, ".bulkUpdate(): ").concat(T, " of ").concat(w, " operations failed"), D);
            });
          });
        });
      }, Ve.prototype.bulkDelete = function(n) {
        var t = this, u = n.length;
        return this._trans("readwrite", function(r) {
          return t.core.mutate({ trans: r, type: "delete", keys: n }).then(function(c) {
            return Xl(t, n, c);
          });
        }).then(function(p) {
          var c = p.numFailures, m = p.lastResult, p = p.failures;
          if (c === 0) return m;
          throw new tn("".concat(t.name, ".bulkDelete(): ").concat(c, " of ").concat(u, " operations failed"), p);
        });
      }, Ve);
      function Ve() {
      }
      function Ll(n) {
        function t(p, g) {
          if (g) {
            for (var L = arguments.length, O = new Array(L - 1); --L; ) O[L - 1] = arguments[L];
            return u[p].subscribe.apply(null, O), n;
          }
          if (typeof p == "string") return u[p];
        }
        var u = {};
        t.addEventType = m;
        for (var r = 1, c = arguments.length; r < c; ++r) m(arguments[r]);
        return t;
        function m(p, g, L) {
          if (typeof p != "object") {
            var O;
            g = g || Ne;
            var w = { subscribers: [], fire: L = L || De, subscribe: function(v) {
              w.subscribers.indexOf(v) === -1 && (w.subscribers.push(v), w.fire = g(w.fire, v));
            }, unsubscribe: function(v) {
              w.subscribers = w.subscribers.filter(function(T) {
                return T !== v;
              }), w.fire = w.subscribers.reduce(g, L);
            } };
            return u[p] = t[p] = w;
          }
          f(O = p).forEach(function(v) {
            var T = O[v];
            if (d(T)) m(v, O[v][0], O[v][1]);
            else {
              if (T !== "asap") throw new Z.InvalidArgument("Invalid event config");
              var D = m(v, j, function() {
                for (var b = arguments.length, C = new Array(b); b--; ) C[b] = arguments[b];
                D.subscribers.forEach(function(S) {
                  W(function() {
                    S.apply(null, C);
                  });
                });
              });
            }
          });
        }
      }
      function Dl(n, t) {
        return M(t).from({ prototype: n }), t;
      }
      function ml(n, t) {
        return !(n.filter || n.algorithm || n.or) && (t ? n.justLimit : !n.replayFilter);
      }
      function Ft(n, t) {
        n.filter = el(n.filter, t);
      }
      function Mt(n, t, u) {
        var r = n.replayFilter;
        n.replayFilter = r ? function() {
          return el(r(), t());
        } : t, n.justLimit = u && !r;
      }
      function Ql(n, t) {
        if (n.isPrimKey) return t.primaryKey;
        var u = t.getIndexByKeyPath(n.index);
        if (!u) throw new Z.Schema("KeyPath " + n.index + " on object store " + t.name + " is not indexed");
        return u;
      }
      function au(n, t, u) {
        var r = Ql(n, t.schema);
        return t.openCursor({ trans: u, values: !n.keysOnly, reverse: n.dir === "prev", unique: !!n.unique, query: { index: r, range: n.range } });
      }
      function Jl(n, t, u, r) {
        var c = n.replayFilter ? el(n.filter, n.replayFilter()) : n.filter;
        if (n.or) {
          var m = {}, p = function(g, L, O) {
            var w, v;
            c && !c(L, O, function(T) {
              return L.stop(T);
            }, function(T) {
              return L.fail(T);
            }) || ((v = "" + (w = L.primaryKey)) == "[object ArrayBuffer]" && (v = "" + new Uint8Array(w)), I(m, v) || (m[v] = !0, t(g, L, O)));
          };
          return Promise.all([n.or._iterate(p, u), ru(au(n, r, u), n.algorithm, p, !n.keysOnly && n.valueMapper)]);
        }
        return ru(au(n, r, u), el(n.algorithm, c), t, !n.keysOnly && n.valueMapper);
      }
      function ru(n, t, u, r) {
        var c = Be(r ? function(m, p, g) {
          return u(r(m), p, g);
        } : u);
        return n.then(function(m) {
          if (m) return m.start(function() {
            var p = function() {
              return m.continue();
            };
            t && !t(m, function(g) {
              return p = g;
            }, function(g) {
              m.stop(g), p = De;
            }, function(g) {
              m.fail(g), p = De;
            }) || c(m.value, m, function(g) {
              return p = g;
            }), p();
          });
        });
      }
      var Ol = (su.prototype.execute = function(n) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var u = t.add;
          if (d(u)) return s(s([], d(n) ? n : [], !0), u).sort();
          if (typeof u == "number") return (Number(n) || 0) + u;
          if (typeof u == "bigint") try {
            return BigInt(n) + u;
          } catch {
            return BigInt(0) + u;
          }
          throw new TypeError("Invalid term ".concat(u));
        }
        if (t.remove !== void 0) {
          var r = t.remove;
          if (d(r)) return d(n) ? n.filter(function(c) {
            return !r.includes(c);
          }).sort() : [];
          if (typeof r == "number") return Number(n) - r;
          if (typeof r == "bigint") try {
            return BigInt(n) - r;
          } catch {
            return BigInt(0) - r;
          }
          throw new TypeError("Invalid subtrahend ".concat(r));
        }
        return u = (u = t.replacePrefix) === null || u === void 0 ? void 0 : u[0], u && typeof n == "string" && n.startsWith(u) ? t.replacePrefix[1] + n.substring(u.length) : n;
      }, su);
      function su(n) {
        this["@@propmod"] = n;
      }
      var tr = (Re.prototype._read = function(n, t) {
        var u = this._ctx;
        return u.error ? u.table._trans(null, He.bind(null, u.error)) : u.table._trans("readonly", n).then(t);
      }, Re.prototype._write = function(n) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, He.bind(null, t.error)) : t.table._trans("readwrite", n, "locked");
      }, Re.prototype._addAlgorithm = function(n) {
        var t = this._ctx;
        t.algorithm = el(t.algorithm, n);
      }, Re.prototype._iterate = function(n, t) {
        return Jl(this._ctx, n, t, this._ctx.table.core);
      }, Re.prototype.clone = function(n) {
        var t = Object.create(this.constructor.prototype), u = Object.create(this._ctx);
        return n && h(u, n), t._ctx = u, t;
      }, Re.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Re.prototype.each = function(n) {
        var t = this._ctx;
        return this._read(function(u) {
          return Jl(t, n, u, t.table.core);
        });
      }, Re.prototype.count = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx, c = r.table.core;
          if (ml(r, !0)) return c.count({ trans: u, query: { index: Ql(r, c.schema), range: r.range } }).then(function(p) {
            return Math.min(p, r.limit);
          });
          var m = 0;
          return Jl(r, function() {
            return ++m, !1;
          }, u, c).then(function() {
            return m;
          });
        }).then(n);
      }, Re.prototype.sortBy = function(n, t) {
        var u = n.split(".").reverse(), r = u[0], c = u.length - 1;
        function m(L, O) {
          return O ? m(L[u[O]], O - 1) : L[r];
        }
        var p = this._ctx.dir === "next" ? 1 : -1;
        function g(L, O) {
          return Te(m(L, c), m(O, c)) * p;
        }
        return this.toArray(function(L) {
          return L.sort(g);
        }).then(t);
      }, Re.prototype.toArray = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx;
          if (r.dir === "next" && ml(r, !0) && 0 < r.limit) {
            var c = r.valueMapper, m = Ql(r, r.table.core.schema);
            return r.table.core.query({ trans: u, limit: r.limit, values: !0, query: { index: m, range: r.range } }).then(function(g) {
              return g = g.result, c ? g.map(c) : g;
            });
          }
          var p = [];
          return Jl(r, function(g) {
            return p.push(g);
          }, u, r.table.core).then(function() {
            return p;
          });
        }, n);
      }, Re.prototype.offset = function(n) {
        var t = this._ctx;
        return n <= 0 || (t.offset += n, ml(t) ? Mt(t, function() {
          var u = n;
          return function(r, c) {
            return u === 0 || (u === 1 ? --u : c(function() {
              r.advance(u), u = 0;
            }), !1);
          };
        }) : Mt(t, function() {
          var u = n;
          return function() {
            return --u < 0;
          };
        })), this;
      }, Re.prototype.limit = function(n) {
        return this._ctx.limit = Math.min(this._ctx.limit, n), Mt(this._ctx, function() {
          var t = n;
          return function(u, r, c) {
            return --t <= 0 && r(c), 0 <= t;
          };
        }, !0), this;
      }, Re.prototype.until = function(n, t) {
        return Ft(this._ctx, function(u, r, c) {
          return !n(u.value) || (r(c), t);
        }), this;
      }, Re.prototype.first = function(n) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(n);
      }, Re.prototype.last = function(n) {
        return this.reverse().first(n);
      }, Re.prototype.filter = function(n) {
        var t;
        return Ft(this._ctx, function(u) {
          return n(u.value);
        }), (t = this._ctx).isMatch = el(t.isMatch, n), this;
      }, Re.prototype.and = function(n) {
        return this.filter(n);
      }, Re.prototype.or = function(n) {
        return new this.db.WhereClause(this._ctx.table, n, this);
      }, Re.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Re.prototype.desc = function() {
        return this.reverse();
      }, Re.prototype.eachKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.key, r);
        });
      }, Re.prototype.eachUniqueKey = function(n) {
        return this._ctx.unique = "unique", this.eachKey(n);
      }, Re.prototype.eachPrimaryKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.primaryKey, r);
        });
      }, Re.prototype.keys = function(n) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.key);
        }).then(function() {
          return u;
        }).then(n);
      }, Re.prototype.primaryKeys = function(n) {
        var t = this._ctx;
        if (t.dir === "next" && ml(t, !0) && 0 < t.limit) return this._read(function(r) {
          var c = Ql(t, t.table.core.schema);
          return t.table.core.query({ trans: r, values: !1, limit: t.limit, query: { index: c, range: t.range } });
        }).then(function(r) {
          return r.result;
        }).then(n);
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.primaryKey);
        }).then(function() {
          return u;
        }).then(n);
      }, Re.prototype.uniqueKeys = function(n) {
        return this._ctx.unique = "unique", this.keys(n);
      }, Re.prototype.firstKey = function(n) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(n);
      }, Re.prototype.lastKey = function(n) {
        return this.reverse().firstKey(n);
      }, Re.prototype.distinct = function() {
        var n = this._ctx, n = n.index && n.table.schema.idxByName[n.index];
        if (!n || !n.multi) return this;
        var t = {};
        return Ft(this._ctx, function(c) {
          var r = c.primaryKey.toString(), c = I(t, r);
          return t[r] = !0, !c;
        }), this;
      }, Re.prototype.modify = function(n) {
        var t = this, u = this._ctx;
        return this._write(function(r) {
          var c, m, p;
          p = typeof n == "function" ? n : (c = f(n), m = c.length, function(P) {
            for (var A = !1, N = 0; N < m; ++N) {
              var F = c[N], G = n[F], Y = ae(P, F);
              G instanceof Ol ? (ne(P, F, G.execute(Y)), A = !0) : Y !== G && (ne(P, F, G), A = !0);
            }
            return A;
          });
          var g = u.table.core, v = g.schema.primaryKey, L = v.outbound, O = v.extractKey, w = 200, v = t.db._options.modifyChunkSize;
          v && (w = typeof v == "object" ? v[g.name] || v["*"] || 200 : v);
          function T(P, F) {
            var N = F.failures, F = F.numFailures;
            b += P - F;
            for (var G = 0, Y = f(N); G < Y.length; G++) {
              var H = Y[G];
              D.push(N[H]);
            }
          }
          var D = [], b = 0, C = [], S = n === cu;
          return t.clone().primaryKeys().then(function(P) {
            function A(F) {
              var G = Math.min(w, P.length - F), Y = P.slice(F, F + G);
              return (S ? Promise.resolve([]) : g.getMany({ trans: r, keys: Y, cache: "immutable" })).then(function(H) {
                var $ = [], J = [], Q = L ? [] : null, le = S ? Y : [];
                if (!S) for (var ve = 0; ve < G; ++ve) {
                  var qe = H[ve], he = { value: ye(qe), primKey: P[F + ve] };
                  p.call(he, he.value, he) !== !1 && (he.value == null ? le.push(P[F + ve]) : L || Te(O(qe), O(he.value)) === 0 ? (J.push(he.value), L && Q.push(P[F + ve])) : (le.push(P[F + ve]), $.push(he.value)));
                }
                return Promise.resolve(0 < $.length && g.mutate({ trans: r, type: "add", values: $ }).then(function(Ge) {
                  for (var pe in Ge.failures) le.splice(parseInt(pe), 1);
                  T($.length, Ge);
                })).then(function() {
                  return (0 < J.length || N && typeof n == "object") && g.mutate({ trans: r, type: "put", keys: Q, values: J, criteria: N, changeSpec: typeof n != "function" && n, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return T(J.length, Ge);
                  });
                }).then(function() {
                  return (0 < le.length || N && S) && g.mutate({ trans: r, type: "delete", keys: le, criteria: N, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return Xl(u.table, le, Ge);
                  }).then(function(Ge) {
                    return T(le.length, Ge);
                  });
                }).then(function() {
                  return P.length > F + G && A(F + w);
                });
              });
            }
            var N = ml(u) && u.limit === 1 / 0 && (typeof n != "function" || S) && { index: u.index, range: u.range };
            return A(0).then(function() {
              if (0 < D.length) throw new gn("Error modifying one or more objects", D, b, C);
              return P.length;
            });
          });
        });
      }, Re.prototype.delete = function() {
        var n = this._ctx, t = n.range;
        return !ml(n) || n.table.schema.yProps || !n.isPrimKey && t.type !== 3 ? this.modify(cu) : this._write(function(u) {
          var r = n.table.core.schema.primaryKey, c = t;
          return n.table.core.count({ trans: u, query: { index: r, range: c } }).then(function(m) {
            return n.table.core.mutate({ trans: u, type: "deleteRange", range: c }).then(function(L) {
              var g = L.failures, L = L.numFailures;
              if (L) throw new gn("Could not delete some values", Object.keys(g).map(function(O) {
                return g[O];
              }), m - L);
              return m - L;
            });
          });
        });
      }, Re);
      function Re() {
      }
      var cu = function(n, t) {
        return t.value = null;
      };
      function ir(n, t) {
        return n < t ? -1 : n === t ? 0 : 1;
      }
      function ur(n, t) {
        return t < n ? -1 : n === t ? 0 : 1;
      }
      function pn(n, t, u) {
        return n = n instanceof mu ? new n.Collection(n) : n, n._ctx.error = new (u || TypeError)(t), n;
      }
      function fl(n) {
        return new n.Collection(n, function() {
          return ou("");
        }).limit(0);
      }
      function et(n, t, u, r) {
        var c, m, p, g, L, O, w, v = u.length;
        if (!u.every(function(b) {
          return typeof b == "string";
        })) return pn(n, eu);
        function T(b) {
          c = b === "next" ? function(S) {
            return S.toUpperCase();
          } : function(S) {
            return S.toLowerCase();
          }, m = b === "next" ? function(S) {
            return S.toLowerCase();
          } : function(S) {
            return S.toUpperCase();
          }, p = b === "next" ? ir : ur;
          var C = u.map(function(S) {
            return { lower: m(S), upper: c(S) };
          }).sort(function(S, P) {
            return p(S.lower, P.lower);
          });
          g = C.map(function(S) {
            return S.upper;
          }), L = C.map(function(S) {
            return S.lower;
          }), w = (O = b) === "next" ? "" : r;
        }
        T("next"), n = new n.Collection(n, function() {
          return zn(g[0], L[v - 1] + r);
        }), n._ondirectionchange = function(b) {
          T(b);
        };
        var D = 0;
        return n._addAlgorithm(function(b, C, S) {
          var P = b.key;
          if (typeof P != "string") return !1;
          var A = m(P);
          if (t(A, L, D)) return !0;
          for (var N = null, F = D; F < v; ++F) {
            var G = function(Y, H, $, J, Q, le) {
              for (var ve = Math.min(Y.length, J.length), qe = -1, he = 0; he < ve; ++he) {
                var Ge = H[he];
                if (Ge !== J[he]) return Q(Y[he], $[he]) < 0 ? Y.substr(0, he) + $[he] + $.substr(he + 1) : Q(Y[he], J[he]) < 0 ? Y.substr(0, he) + J[he] + $.substr(he + 1) : 0 <= qe ? Y.substr(0, qe) + H[qe] + $.substr(qe + 1) : null;
                Q(Y[he], Ge) < 0 && (qe = he);
              }
              return ve < J.length && le === "next" ? Y + $.substr(Y.length) : ve < Y.length && le === "prev" ? Y.substr(0, $.length) : qe < 0 ? null : Y.substr(0, qe) + J[qe] + $.substr(qe + 1);
            }(P, A, g[F], L[F], p, O);
            G === null && N === null ? D = F + 1 : (N === null || 0 < p(N, G)) && (N = G);
          }
          return C(N !== null ? function() {
            b.continue(N + w);
          } : S), !1;
        }), n;
      }
      function zn(n, t, u, r) {
        return { type: 2, lower: n, upper: t, lowerOpen: u, upperOpen: r };
      }
      function ou(n) {
        return { type: 1, lower: n, upper: n };
      }
      var mu = (Object.defineProperty(nn.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), nn.prototype.between = function(n, t, u, r) {
        u = u !== !1, r = r === !0;
        try {
          return 0 < this._cmp(n, t) || this._cmp(n, t) === 0 && (u || r) && (!u || !r) ? fl(this) : new this.Collection(this, function() {
            return zn(n, t, !u, !r);
          });
        } catch {
          return pn(this, An);
        }
      }, nn.prototype.equals = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return ou(n);
        });
      }, nn.prototype.above = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return zn(n, void 0, !0);
        });
      }, nn.prototype.aboveOrEqual = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return zn(n, void 0, !1);
        });
      }, nn.prototype.below = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return zn(void 0, n, !1, !0);
        });
      }, nn.prototype.belowOrEqual = function(n) {
        return n == null ? pn(this, An) : new this.Collection(this, function() {
          return zn(void 0, n);
        });
      }, nn.prototype.startsWith = function(n) {
        return typeof n != "string" ? pn(this, eu) : this.between(n, n + Jn, !0, !0);
      }, nn.prototype.startsWithIgnoreCase = function(n) {
        return n === "" ? this.startsWith(n) : et(this, function(t, u) {
          return t.indexOf(u[0]) === 0;
        }, [n], Jn);
      }, nn.prototype.equalsIgnoreCase = function(n) {
        return et(this, function(t, u) {
          return t === u[0];
        }, [n], "");
      }, nn.prototype.anyOfIgnoreCase = function() {
        var n = Ae.apply(Le, arguments);
        return n.length === 0 ? fl(this) : et(this, function(t, u) {
          return u.indexOf(t) !== -1;
        }, n, "");
      }, nn.prototype.startsWithAnyOfIgnoreCase = function() {
        var n = Ae.apply(Le, arguments);
        return n.length === 0 ? fl(this) : et(this, function(t, u) {
          return u.some(function(r) {
            return t.indexOf(r) === 0;
          });
        }, n, Jn);
      }, nn.prototype.anyOf = function() {
        var n = this, t = Ae.apply(Le, arguments), u = this._cmp;
        try {
          t.sort(u);
        } catch {
          return pn(this, An);
        }
        if (t.length === 0) return fl(this);
        var r = new this.Collection(this, function() {
          return zn(t[0], t[t.length - 1]);
        });
        r._ondirectionchange = function(m) {
          u = m === "next" ? n._ascending : n._descending, t.sort(u);
        };
        var c = 0;
        return r._addAlgorithm(function(m, p, g) {
          for (var L = m.key; 0 < u(L, t[c]); ) if (++c === t.length) return p(g), !1;
          return u(L, t[c]) === 0 || (p(function() {
            m.continue(t[c]);
          }), !1);
        }), r;
      }, nn.prototype.notEqual = function(n) {
        return this.inAnyRange([[-1 / 0, n], [n, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, nn.prototype.noneOf = function() {
        var n = Ae.apply(Le, arguments);
        if (n.length === 0) return new this.Collection(this);
        try {
          n.sort(this._ascending);
        } catch {
          return pn(this, An);
        }
        var t = n.reduce(function(u, r) {
          return u ? u.concat([[u[u.length - 1][1], r]]) : [[-1 / 0, r]];
        }, null);
        return t.push([n[n.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, nn.prototype.inAnyRange = function(P, t) {
        var u = this, r = this._cmp, c = this._ascending, m = this._descending, p = this._min, g = this._max;
        if (P.length === 0) return fl(this);
        if (!P.every(function(A) {
          return A[0] !== void 0 && A[1] !== void 0 && c(A[0], A[1]) <= 0;
        })) return pn(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Z.InvalidArgument);
        var L = !t || t.includeLowers !== !1, O = t && t.includeUppers === !0, w, v = c;
        function T(A, N) {
          return v(A[0], N[0]);
        }
        try {
          (w = P.reduce(function(A, N) {
            for (var F = 0, G = A.length; F < G; ++F) {
              var Y = A[F];
              if (r(N[0], Y[1]) < 0 && 0 < r(N[1], Y[0])) {
                Y[0] = p(Y[0], N[0]), Y[1] = g(Y[1], N[1]);
                break;
              }
            }
            return F === G && A.push(N), A;
          }, [])).sort(T);
        } catch {
          return pn(this, An);
        }
        var D = 0, b = O ? function(A) {
          return 0 < c(A, w[D][1]);
        } : function(A) {
          return 0 <= c(A, w[D][1]);
        }, C = L ? function(A) {
          return 0 < m(A, w[D][0]);
        } : function(A) {
          return 0 <= m(A, w[D][0]);
        }, S = b, P = new this.Collection(this, function() {
          return zn(w[0][0], w[w.length - 1][1], !L, !O);
        });
        return P._ondirectionchange = function(A) {
          v = A === "next" ? (S = b, c) : (S = C, m), w.sort(T);
        }, P._addAlgorithm(function(A, N, F) {
          for (var G, Y = A.key; S(Y); ) if (++D === w.length) return N(F), !1;
          return !b(G = Y) && !C(G) || (u._cmp(Y, w[D][1]) === 0 || u._cmp(Y, w[D][0]) === 0 || N(function() {
            v === c ? A.continue(w[D][0]) : A.continue(w[D][1]);
          }), !1);
        }), P;
      }, nn.prototype.startsWithAnyOf = function() {
        var n = Ae.apply(Le, arguments);
        return n.every(function(t) {
          return typeof t == "string";
        }) ? n.length === 0 ? fl(this) : this.inAnyRange(n.map(function(t) {
          return [t, t + Jn];
        })) : pn(this, "startsWithAnyOf() only works with strings");
      }, nn);
      function nn() {
      }
      function wn(n) {
        return Be(function(t) {
          return bl(t), n(t.target.error), !1;
        });
      }
      function bl(n) {
        n.stopPropagation && n.stopPropagation(), n.preventDefault && n.preventDefault();
      }
      var wl = "storagemutated", kt = "x-storagemutated-1", jn = Ll(null, wl), ar = (Sn.prototype._lock = function() {
        return K(!se.global), ++this._reculock, this._reculock !== 1 || se.global || (se.lockOwnerFor = this), this;
      }, Sn.prototype._unlock = function() {
        if (K(!se.global), --this._reculock == 0) for (se.global || (se.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var n = this._blockedFuncs.shift();
          try {
            Qn(n[1], n[0]);
          } catch {
          }
        }
        return this;
      }, Sn.prototype._locked = function() {
        return this._reculock && se.lockOwnerFor !== this;
      }, Sn.prototype.create = function(n) {
        var t = this;
        if (!this.mode) return this;
        var u = this.db.idbdb, r = this.db._state.dbOpenError;
        if (K(!this.idbtrans), !n && !u) switch (r && r.name) {
          case "DatabaseClosedError":
            throw new Z.DatabaseClosed(r);
          case "MissingAPIError":
            throw new Z.MissingAPI(r.message, r);
          default:
            throw new Z.OpenFailed(r);
        }
        if (!this.active) throw new Z.TransactionInactive();
        return K(this._completion._state === null), (n = this.idbtrans = n || (this.db.core || u).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Be(function(c) {
          bl(c), t._reject(n.error);
        }), n.onabort = Be(function(c) {
          bl(c), t.active && t._reject(new Z.Abort(n.error)), t.active = !1, t.on("abort").fire(c);
        }), n.oncomplete = Be(function() {
          t.active = !1, t._resolve(), "mutatedParts" in n && jn.storagemutated.fire(n.mutatedParts);
        }), this;
      }, Sn.prototype._promise = function(n, t, u) {
        var r = this;
        if (n === "readwrite" && this.mode !== "readwrite") return He(new Z.ReadOnly("Transaction is readonly"));
        if (!this.active) return He(new Z.TransactionInactive());
        if (this._locked()) return new ee(function(m, p) {
          r._blockedFuncs.push([function() {
            r._promise(n, t, u).then(m, p);
          }, se]);
        });
        if (u) return Un(function() {
          var m = new ee(function(p, g) {
            r._lock();
            var L = t(p, g, r);
            L && L.then && L.then(p, g);
          });
          return m.finally(function() {
            return r._unlock();
          }), m._lib = !0, m;
        });
        var c = new ee(function(m, p) {
          var g = t(m, p, r);
          g && g.then && g.then(m, p);
        });
        return c._lib = !0, c;
      }, Sn.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Sn.prototype.waitFor = function(n) {
        var t, u = this._root(), r = ee.resolve(n);
        u._waitingFor ? u._waitingFor = u._waitingFor.then(function() {
          return r;
        }) : (u._waitingFor = r, u._waitingQueue = [], t = u.idbtrans.objectStore(u.storeNames[0]), function m() {
          for (++u._spinCount; u._waitingQueue.length; ) u._waitingQueue.shift()();
          u._waitingFor && (t.get(-1 / 0).onsuccess = m);
        }());
        var c = u._waitingFor;
        return new ee(function(m, p) {
          r.then(function(g) {
            return u._waitingQueue.push(Be(m.bind(null, g)));
          }, function(g) {
            return u._waitingQueue.push(Be(p.bind(null, g)));
          }).finally(function() {
            u._waitingFor === c && (u._waitingFor = null);
          });
        });
      }, Sn.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new Z.Abort()));
      }, Sn.prototype.table = function(n) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (I(t, n)) return t[n];
        var u = this.schema[n];
        if (!u) throw new Z.NotFound("Table " + n + " not part of transaction");
        return u = new this.db.Table(n, u, this), u.core = this.db.core.table(n), t[n] = u;
      }, Sn);
      function Sn() {
      }
      function Vt(n, t, u, r, c, m, p, g) {
        return { name: n, keyPath: t, unique: u, multi: r, auto: c, compound: m, src: (u && !p ? "&" : "") + (r ? "*" : "") + (c ? "++" : "") + fu(t), type: g };
      }
      function fu(n) {
        return typeof n == "string" ? n : n ? "[" + [].join.call(n, "+") + "]" : "";
      }
      function Bt(n, t, u) {
        return { name: n, primKey: t, indexes: u, mappedClass: null, idxByName: (r = function(c) {
          return [c.name, c];
        }, u.reduce(function(c, m, p) {
          return p = r(m, p), p && (c[p[0]] = p[1]), c;
        }, {})) };
        var r;
      }
      var Sl = function(n) {
        try {
          return n.only([[]]), Sl = function() {
            return [[]];
          }, [[]];
        } catch {
          return Sl = function() {
            return Jn;
          }, Jn;
        }
      };
      function Zt(n) {
        return n == null ? function() {
        } : typeof n == "string" ? (t = n).split(".").length === 1 ? function(u) {
          return u[t];
        } : function(u) {
          return ae(u, t);
        } : function(u) {
          return ae(u, n);
        };
        var t;
      }
      function du(n) {
        return [].slice.call(n);
      }
      var rr = 0;
      function Cl(n) {
        return n == null ? ":id" : typeof n == "string" ? n : "[".concat(n.join("+"), "]");
      }
      function sr(n, t, L) {
        function r(S) {
          if (S.type === 3) return null;
          if (S.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var D = S.lower, b = S.upper, C = S.lowerOpen, S = S.upperOpen;
          return D === void 0 ? b === void 0 ? null : t.upperBound(b, !!S) : b === void 0 ? t.lowerBound(D, !!C) : t.bound(D, b, !!C, !!S);
        }
        function c(T) {
          var D, b = T.name;
          return { name: b, schema: T, mutate: function(C) {
            var S = C.trans, P = C.type, A = C.keys, N = C.values, F = C.range;
            return new Promise(function(G, Y) {
              G = Be(G);
              var H = S.objectStore(b), $ = H.keyPath == null, J = P === "put" || P === "add";
              if (!J && P !== "delete" && P !== "deleteRange") throw new Error("Invalid operation type: " + P);
              var Q, le = (A || N || { length: 1 }).length;
              if (A && N && A.length !== N.length) throw new Error("Given keys array must have same length as given values array.");
              if (le === 0) return G({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ve(mn) {
                ++Ge, bl(mn);
              }
              var qe = [], he = [], Ge = 0;
              if (P === "deleteRange") {
                if (F.type === 4) return G({ numFailures: Ge, failures: he, results: [], lastResult: void 0 });
                F.type === 3 ? qe.push(Q = H.clear()) : qe.push(Q = H.delete(r(F)));
              } else {
                var $ = J ? $ ? [N, A] : [N, null] : [A, null], pe = $[0], an = $[1];
                if (J) for (var rn = 0; rn < le; ++rn) qe.push(Q = an && an[rn] !== void 0 ? H[P](pe[rn], an[rn]) : H[P](pe[rn])), Q.onerror = ve;
                else for (rn = 0; rn < le; ++rn) qe.push(Q = H[P](pe[rn])), Q.onerror = ve;
              }
              function ft(mn) {
                mn = mn.target.result, qe.forEach(function(tl, ui) {
                  return tl.error != null && (he[ui] = tl.error);
                }), G({ numFailures: Ge, failures: he, results: P === "delete" ? A : qe.map(function(tl) {
                  return tl.result;
                }), lastResult: mn });
              }
              Q.onerror = function(mn) {
                ve(mn), ft(mn);
              }, Q.onsuccess = ft;
            });
          }, getMany: function(C) {
            var S = C.trans, P = C.keys;
            return new Promise(function(A, N) {
              A = Be(A);
              for (var F, G = S.objectStore(b), Y = P.length, H = new Array(Y), $ = 0, J = 0, Q = function(qe) {
                qe = qe.target, H[qe._pos] = qe.result, ++J === $ && A(H);
              }, le = wn(N), ve = 0; ve < Y; ++ve) P[ve] != null && ((F = G.get(P[ve]))._pos = ve, F.onsuccess = Q, F.onerror = le, ++$);
              $ === 0 && A(H);
            });
          }, get: function(C) {
            var S = C.trans, P = C.key;
            return new Promise(function(A, N) {
              A = Be(A);
              var F = S.objectStore(b).get(P);
              F.onsuccess = function(G) {
                return A(G.target.result);
              }, F.onerror = wn(N);
            });
          }, query: (D = O, function(C) {
            return new Promise(function(S, P) {
              S = Be(S);
              var A, N, F, $ = C.trans, G = C.values, Y = C.limit, Q = C.query, H = Y === 1 / 0 ? void 0 : Y, J = Q.index, Q = Q.range, $ = $.objectStore(b), J = J.isPrimaryKey ? $ : $.index(J.name), Q = r(Q);
              if (Y === 0) return S({ result: [] });
              D ? ((H = G ? J.getAll(Q, H) : J.getAllKeys(Q, H)).onsuccess = function(le) {
                return S({ result: le.target.result });
              }, H.onerror = wn(P)) : (A = 0, N = !G && "openKeyCursor" in J ? J.openKeyCursor(Q) : J.openCursor(Q), F = [], N.onsuccess = function(le) {
                var ve = N.result;
                return ve ? (F.push(G ? ve.value : ve.primaryKey), ++A === Y ? S({ result: F }) : void ve.continue()) : S({ result: F });
              }, N.onerror = wn(P));
            });
          }), openCursor: function(C) {
            var S = C.trans, P = C.values, A = C.query, N = C.reverse, F = C.unique;
            return new Promise(function(G, Y) {
              G = Be(G);
              var J = A.index, H = A.range, $ = S.objectStore(b), $ = J.isPrimaryKey ? $ : $.index(J.name), J = N ? F ? "prevunique" : "prev" : F ? "nextunique" : "next", Q = !P && "openKeyCursor" in $ ? $.openKeyCursor(r(H), J) : $.openCursor(r(H), J);
              Q.onerror = wn(Y), Q.onsuccess = Be(function(le) {
                var ve, qe, he, Ge, pe = Q.result;
                pe ? (pe.___id = ++rr, pe.done = !1, ve = pe.continue.bind(pe), qe = (qe = pe.continuePrimaryKey) && qe.bind(pe), he = pe.advance.bind(pe), Ge = function() {
                  throw new Error("Cursor not stopped");
                }, pe.trans = S, pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = function() {
                  throw new Error("Cursor not started");
                }, pe.fail = Be(Y), pe.next = function() {
                  var an = this, rn = 1;
                  return this.start(function() {
                    return rn-- ? an.continue() : an.stop();
                  }).then(function() {
                    return an;
                  });
                }, pe.start = function(an) {
                  function rn() {
                    if (Q.result) try {
                      an();
                    } catch (mn) {
                      pe.fail(mn);
                    }
                    else pe.done = !0, pe.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, pe.stop();
                  }
                  var ft = new Promise(function(mn, tl) {
                    mn = Be(mn), Q.onerror = wn(tl), pe.fail = tl, pe.stop = function(ui) {
                      pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = Ge, mn(ui);
                    };
                  });
                  return Q.onsuccess = Be(function(mn) {
                    Q.onsuccess = rn, rn();
                  }), pe.continue = ve, pe.continuePrimaryKey = qe, pe.advance = he, rn(), ft;
                }, G(pe)) : G(null);
              }, Y);
            });
          }, count: function(C) {
            var S = C.query, P = C.trans, A = S.index, N = S.range;
            return new Promise(function(F, G) {
              var Y = P.objectStore(b), H = A.isPrimaryKey ? Y : Y.index(A.name), Y = r(N), H = Y ? H.count(Y) : H.count();
              H.onsuccess = Be(function($) {
                return F($.target.result);
              }), H.onerror = wn(G);
            });
          } };
        }
        var m, p, g, w = (p = L, g = du((m = n).objectStoreNames), { schema: { name: m.name, tables: g.map(function(T) {
          return p.objectStore(T);
        }).map(function(T) {
          var D = T.keyPath, S = T.autoIncrement, b = d(D), C = {}, S = { name: T.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: D == null, compound: b, keyPath: D, autoIncrement: S, unique: !0, extractKey: Zt(D) }, indexes: du(T.indexNames).map(function(P) {
            return T.index(P);
          }).map(function(F) {
            var A = F.name, N = F.unique, G = F.multiEntry, F = F.keyPath, G = { name: A, compound: d(F), keyPath: F, unique: N, multiEntry: G, extractKey: Zt(F) };
            return C[Cl(F)] = G;
          }), getIndexByKeyPath: function(P) {
            return C[Cl(P)];
          } };
          return C[":id"] = S.primaryKey, D != null && (C[Cl(D)] = S.primaryKey), S;
        }) }, hasGetAll: 0 < g.length && "getAll" in p.objectStore(g[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), L = w.schema, O = w.hasGetAll, w = L.tables.map(c), v = {};
        return w.forEach(function(T) {
          return v[T.name] = T;
        }), { stack: "dbcore", transaction: n.transaction.bind(n), table: function(T) {
          if (!v[T]) throw new Error("Table '".concat(T, "' not found"));
          return v[T];
        }, MIN_KEY: -1 / 0, MAX_KEY: Sl(t), schema: L };
      }
      function cr(n, t, u, r) {
        var c = u.IDBKeyRange;
        return u.indexedDB, { dbcore: (r = sr(t, c, r), n.dbcore.reduce(function(m, p) {
          return p = p.create, a(a({}, m), p(m));
        }, r)) };
      }
      function nt(n, r) {
        var u = r.db, r = cr(n._middlewares, u, n._deps, r);
        n.core = r.dbcore, n.tables.forEach(function(c) {
          var m = c.name;
          n.core.schema.tables.some(function(p) {
            return p.name === m;
          }) && (c.core = n.core.table(m), n[m] instanceof n.Table && (n[m].core = c.core));
        });
      }
      function lt(n, t, u, r) {
        u.forEach(function(c) {
          var m = r[c];
          t.forEach(function(p) {
            var g = function L(O, w) {
              return U(O, w) || (O = x(O)) && L(O, w);
            }(p, c);
            (!g || "value" in g && g.value === void 0) && (p === n.Transaction.prototype || p instanceof n.Transaction ? E(p, c, { get: function() {
              return this.table(c);
            }, set: function(L) {
              R(this, c, { value: L, writable: !0, configurable: !0, enumerable: !0 });
            } }) : p[c] = new n.Table(c, m));
          });
        });
      }
      function Ut(n, t) {
        t.forEach(function(u) {
          for (var r in u) u[r] instanceof n.Table && delete u[r];
        });
      }
      function or(n, t) {
        return n._cfg.version - t._cfg.version;
      }
      function mr(n, t, u, r) {
        var c = n._dbSchema;
        u.objectStoreNames.contains("$meta") && !c.$meta && (c.$meta = Bt("$meta", hu("")[0], []), n._storeNames.push("$meta"));
        var m = n._createTransaction("readwrite", n._storeNames, c);
        m.create(u), m._completion.catch(r);
        var p = m._reject.bind(m), g = se.transless || se;
        Un(function() {
          return se.trans = m, se.transless = g, t !== 0 ? (nt(n, u), O = t, ((L = m).storeNames.includes("$meta") ? L.table("$meta").get("version").then(function(w) {
            return w ?? O;
          }) : ee.resolve(O)).then(function(w) {
            return T = w, D = m, b = u, C = [], w = (v = n)._versions, S = v._dbSchema = it(0, v.idbdb, b), (w = w.filter(function(P) {
              return P._cfg.version >= T;
            })).length !== 0 ? (w.forEach(function(P) {
              C.push(function() {
                var A = S, N = P._cfg.dbschema;
                ut(v, A, b), ut(v, N, b), S = v._dbSchema = N;
                var F = Kt(A, N);
                F.add.forEach(function(J) {
                  Gt(b, J[0], J[1].primKey, J[1].indexes);
                }), F.change.forEach(function(J) {
                  if (J.recreate) throw new Z.Upgrade("Not yet support for changing primary key");
                  var Q = b.objectStore(J.name);
                  J.add.forEach(function(le) {
                    return tt(Q, le);
                  }), J.change.forEach(function(le) {
                    Q.deleteIndex(le.name), tt(Q, le);
                  }), J.del.forEach(function(le) {
                    return Q.deleteIndex(le);
                  });
                });
                var G = P._cfg.contentUpgrade;
                if (G && P._cfg.version > T) {
                  nt(v, b), D._memoizedTables = {};
                  var Y = oe(N);
                  F.del.forEach(function(J) {
                    Y[J] = A[J];
                  }), Ut(v, [v.Transaction.prototype]), lt(v, [v.Transaction.prototype], f(Y), Y), D.schema = Y;
                  var H, $ = We(G);
                  return $ && cl(), F = ee.follow(function() {
                    var J;
                    (H = G(D)) && $ && (J = Kn.bind(null, null), H.then(J, J));
                  }), H && typeof H.then == "function" ? ee.resolve(H) : F.then(function() {
                    return H;
                  });
                }
              }), C.push(function(A) {
                var N, F, G = P._cfg.dbschema;
                N = G, F = A, [].slice.call(F.db.objectStoreNames).forEach(function(Y) {
                  return N[Y] == null && F.db.deleteObjectStore(Y);
                }), Ut(v, [v.Transaction.prototype]), lt(v, [v.Transaction.prototype], v._storeNames, v._dbSchema), D.schema = v._dbSchema;
              }), C.push(function(A) {
                v.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(v.idbdb.version / 10) === P._cfg.version ? (v.idbdb.deleteObjectStore("$meta"), delete v._dbSchema.$meta, v._storeNames = v._storeNames.filter(function(N) {
                  return N !== "$meta";
                })) : A.objectStore("$meta").put(P._cfg.version, "version"));
              });
            }), function P() {
              return C.length ? ee.resolve(C.shift()(D.idbtrans)).then(P) : ee.resolve();
            }().then(function() {
              pu(S, b);
            })) : ee.resolve();
            var v, T, D, b, C, S;
          }).catch(p)) : (f(c).forEach(function(w) {
            Gt(u, w, c[w].primKey, c[w].indexes);
          }), nt(n, u), void ee.follow(function() {
            return n.on.populate.fire(m);
          }).catch(p));
          var L, O;
        });
      }
      function fr(n, t) {
        pu(n._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var u = it(0, n.idbdb, t);
        ut(n, n._dbSchema, t);
        for (var r = 0, c = Kt(u, n._dbSchema).change; r < c.length; r++) {
          var m = function(p) {
            if (p.change.length || p.recreate) return console.warn("Unable to patch indexes of table ".concat(p.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var g = t.objectStore(p.name);
            p.add.forEach(function(L) {
              Oe && console.debug("Dexie upgrade patch: Creating missing index ".concat(p.name, ".").concat(L.src)), tt(g, L);
            });
          }(c[r]);
          if (typeof m == "object") return m.value;
        }
      }
      function Kt(n, t) {
        var u, r = { del: [], add: [], change: [] };
        for (u in n) t[u] || r.del.push(u);
        for (u in t) {
          var c = n[u], m = t[u];
          if (c) {
            var p = { name: u, def: m, recreate: !1, del: [], add: [], change: [] };
            if ("" + (c.primKey.keyPath || "") != "" + (m.primKey.keyPath || "") || c.primKey.auto !== m.primKey.auto) p.recreate = !0, r.change.push(p);
            else {
              var g = c.idxByName, L = m.idxByName, O = void 0;
              for (O in g) L[O] || p.del.push(O);
              for (O in L) {
                var w = g[O], v = L[O];
                w ? w.src !== v.src && p.change.push(v) : p.add.push(v);
              }
              (0 < p.del.length || 0 < p.add.length || 0 < p.change.length) && r.change.push(p);
            }
          } else r.add.push([u, m]);
        }
        return r;
      }
      function Gt(n, t, u, r) {
        var c = n.db.createObjectStore(t, u.keyPath ? { keyPath: u.keyPath, autoIncrement: u.auto } : { autoIncrement: u.auto });
        return r.forEach(function(m) {
          return tt(c, m);
        }), c;
      }
      function pu(n, t) {
        f(n).forEach(function(u) {
          t.db.objectStoreNames.contains(u) || (Oe && console.debug("Dexie: Creating missing table", u), Gt(t, u, n[u].primKey, n[u].indexes));
        });
      }
      function tt(n, t) {
        n.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function it(n, t, u) {
        var r = {};
        return X(t.objectStoreNames, 0).forEach(function(c) {
          for (var m = u.objectStore(c), p = Vt(fu(O = m.keyPath), O || "", !0, !1, !!m.autoIncrement, O && typeof O != "string", !0), g = [], L = 0; L < m.indexNames.length; ++L) {
            var w = m.index(m.indexNames[L]), O = w.keyPath, w = Vt(w.name, O, !!w.unique, !!w.multiEntry, !1, O && typeof O != "string", !1);
            g.push(w);
          }
          r[c] = Bt(c, p, g);
        }), r;
      }
      function ut(n, t, u) {
        for (var r = u.db.objectStoreNames, c = 0; c < r.length; ++c) {
          var m = r[c], p = u.objectStore(m);
          n._hasGetAll = "getAll" in p;
          for (var g = 0; g < p.indexNames.length; ++g) {
            var L = p.indexNames[g], O = p.index(L).keyPath, w = typeof O == "string" ? O : "[" + X(O).join("+") + "]";
            !t[m] || (O = t[m].idxByName[w]) && (O.name = L, delete t[m].idxByName[w], t[m].idxByName[L] = O);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && o.WorkerGlobalScope && o instanceof o.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1);
      }
      function hu(n) {
        return n.split(",").map(function(t, u) {
          var m = t.split(":"), r = (c = m[1]) === null || c === void 0 ? void 0 : c.trim(), c = (t = m[0].trim()).replace(/([&*]|\+\+)/g, ""), m = /^\[/.test(c) ? c.match(/^\[(.*)\]$/)[1].split("+") : c;
          return Vt(c, m || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), d(m), u === 0, r);
        });
      }
      var dr = (dl.prototype._createTableSchema = Bt, dl.prototype._parseIndexSyntax = hu, dl.prototype._parseStoresSpec = function(n, t) {
        var u = this;
        f(n).forEach(function(r) {
          if (n[r] !== null) {
            var c = u._parseIndexSyntax(n[r]), m = c.shift();
            if (!m) throw new Z.Schema("Invalid schema for table " + r + ": " + n[r]);
            if (m.unique = !0, m.multi) throw new Z.Schema("Primary key cannot be multiEntry*");
            c.forEach(function(p) {
              if (p.auto) throw new Z.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!p.keyPath) throw new Z.Schema("Index must have a name and cannot be an empty string");
            }), c = u._createTableSchema(r, m, c), t[r] = c;
          }
        });
      }, dl.prototype.stores = function(u) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? h(this._cfg.storesSource, u) : u;
        var u = t._versions, r = {}, c = {};
        return u.forEach(function(m) {
          h(r, m._cfg.storesSource), c = m._cfg.dbschema = {}, m._parseStoresSpec(r, c);
        }), t._dbSchema = c, Ut(t, [t._allTables, t, t.Transaction.prototype]), lt(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], f(c), c), t._storeNames = f(c), this;
      }, dl.prototype.upgrade = function(n) {
        return this._cfg.contentUpgrade = Ee(this._cfg.contentUpgrade || De, n), this;
      }, dl);
      function dl() {
      }
      function zt(n, t) {
        var u = n._dbNamesDB;
        return u || (u = n._dbNamesDB = new En(Wl, { addons: [], indexedDB: n, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), u.table("dbnames");
      }
      function jt(n) {
        return n && typeof n.databases == "function";
      }
      function Ht(n) {
        return Un(function() {
          return se.letThrough = !0, n();
        });
      }
      function $t(n) {
        return !("from" in n);
      }
      var un = function(n, t) {
        if (!this) {
          var u = new un();
          return n && "d" in n && h(u, n), u;
        }
        h(this, arguments.length ? { d: 1, from: n, to: 1 < arguments.length ? t : n } : { d: 0 });
      };
      function Tl(n, t, u) {
        var r = Te(t, u);
        if (!isNaN(r)) {
          if (0 < r) throw RangeError();
          if ($t(n)) return h(n, { from: t, to: u, d: 1 });
          var c = n.l, r = n.r;
          if (Te(u, n.from) < 0) return c ? Tl(c, t, u) : n.l = { from: t, to: u, d: 1, l: null, r: null }, vu(n);
          if (0 < Te(t, n.to)) return r ? Tl(r, t, u) : n.r = { from: t, to: u, d: 1, l: null, r: null }, vu(n);
          Te(t, n.from) < 0 && (n.from = t, n.l = null, n.d = r ? r.d + 1 : 1), 0 < Te(u, n.to) && (n.to = u, n.r = null, n.d = n.l ? n.l.d + 1 : 1), u = !n.r, c && !n.l && Pl(n, c), r && u && Pl(n, r);
        }
      }
      function Pl(n, t) {
        $t(t) || function u(r, L) {
          var m = L.from, p = L.to, g = L.l, L = L.r;
          Tl(r, m, p), g && u(r, g), L && u(r, L);
        }(n, t);
      }
      function gu(n, t) {
        var u = at(t), r = u.next();
        if (r.done) return !1;
        for (var c = r.value, m = at(n), p = m.next(c.from), g = p.value; !r.done && !p.done; ) {
          if (Te(g.from, c.to) <= 0 && 0 <= Te(g.to, c.from)) return !0;
          Te(c.from, g.from) < 0 ? c = (r = u.next(g.from)).value : g = (p = m.next(c.from)).value;
        }
        return !1;
      }
      function at(n) {
        var t = $t(n) ? null : { s: 0, n };
        return { next: function(u) {
          for (var r = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, r) for (; t.n.l && Te(u, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !r || Te(u, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function vu(n) {
        var t, u, r = (((t = n.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((u = n.l) === null || u === void 0 ? void 0 : u.d) || 0), c = 1 < r ? "r" : r < -1 ? "l" : "";
        c && (t = c == "r" ? "l" : "r", u = a({}, n), r = n[c], n.from = r.from, n.to = r.to, n[c] = r[c], u[c] = r[t], (n[t] = u).d = xu(u)), n.d = xu(n);
      }
      function xu(u) {
        var t = u.r, u = u.l;
        return (t ? u ? Math.max(t.d, u.d) : t.d : u ? u.d : 0) + 1;
      }
      function rt(n, t) {
        return f(t).forEach(function(u) {
          n[u] ? Pl(n[u], t[u]) : n[u] = function r(c) {
            var m, p, g = {};
            for (m in c) I(c, m) && (p = c[m], g[m] = !p || typeof p != "object" || be.has(p.constructor) ? p : r(p));
            return g;
          }(t[u]);
        }), n;
      }
      function Wt(n, t) {
        return n.all || t.all || Object.keys(n).some(function(u) {
          return t[u] && gu(t[u], n[u]);
        });
      }
      q(un.prototype, ((In = { add: function(n) {
        return Pl(this, n), this;
      }, addKey: function(n) {
        return Tl(this, n, n), this;
      }, addKeys: function(n) {
        var t = this;
        return n.forEach(function(u) {
          return Tl(t, u, u);
        }), this;
      }, hasKey: function(n) {
        var t = at(this).next(n).value;
        return t && Te(t.from, n) <= 0 && 0 <= Te(t.to, n);
      } })[ge] = function() {
        return at(this);
      }, In));
      var nl = {}, Yt = {}, Xt = !1;
      function st(n) {
        rt(Yt, n), Xt || (Xt = !0, setTimeout(function() {
          Xt = !1, Qt(Yt, !(Yt = {}));
        }, 0));
      }
      function Qt(n, t) {
        t === void 0 && (t = !1);
        var u = /* @__PURE__ */ new Set();
        if (n.all) for (var r = 0, c = Object.values(nl); r < c.length; r++) yu(p = c[r], n, u, t);
        else for (var m in n) {
          var p, g = /^idb\:\/\/(.*)\/(.*)\//.exec(m);
          g && (m = g[1], g = g[2], (p = nl["idb://".concat(m, "/").concat(g)]) && yu(p, n, u, t));
        }
        u.forEach(function(L) {
          return L();
        });
      }
      function yu(n, t, u, r) {
        for (var c = [], m = 0, p = Object.entries(n.queries.query); m < p.length; m++) {
          for (var g = p[m], L = g[0], O = [], w = 0, v = g[1]; w < v.length; w++) {
            var T = v[w];
            Wt(t, T.obsSet) ? T.subscribers.forEach(function(S) {
              return u.add(S);
            }) : r && O.push(T);
          }
          r && c.push([L, O]);
        }
        if (r) for (var D = 0, b = c; D < b.length; D++) {
          var C = b[D], L = C[0], O = C[1];
          n.queries.query[L] = O;
        }
      }
      function pr(n) {
        var t = n._state, u = n._deps.indexedDB;
        if (t.isBeingOpened || n.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? He(t.dbOpenError) : n;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var r = t.openCanceller, c = Math.round(10 * n.verno), m = !1;
        function p() {
          if (t.openCanceller !== r) throw new Z.DatabaseClosed("db.open() was cancelled");
        }
        function g() {
          return new ee(function(T, D) {
            if (p(), !u) throw new Z.MissingAPI();
            var b = n.name, C = t.autoSchema || !c ? u.open(b) : u.open(b, c);
            if (!C) throw new Z.MissingAPI();
            C.onerror = wn(D), C.onblocked = Be(n._fireOnBlocked), C.onupgradeneeded = Be(function(S) {
              var P;
              w = C.transaction, t.autoSchema && !n._options.allowEmptyDB ? (C.onerror = bl, w.abort(), C.result.close(), (P = u.deleteDatabase(b)).onsuccess = P.onerror = Be(function() {
                D(new Z.NoSuchDatabase("Database ".concat(b, " doesnt exist")));
              })) : (w.onerror = wn(D), S = S.oldVersion > Math.pow(2, 62) ? 0 : S.oldVersion, v = S < 1, n.idbdb = C.result, m && fr(n, w), mr(n, S / 10, w, D));
            }, D), C.onsuccess = Be(function() {
              w = null;
              var S, P, A, N, F, G = n.idbdb = C.result, Y = X(G.objectStoreNames);
              if (0 < Y.length) try {
                var H = G.transaction((N = Y).length === 1 ? N[0] : N, "readonly");
                if (t.autoSchema) P = G, A = H, (S = n).verno = P.version / 10, A = S._dbSchema = it(0, P, A), S._storeNames = X(P.objectStoreNames, 0), lt(S, [S._allTables], f(A), A);
                else if (ut(n, n._dbSchema, H), ((F = Kt(it(0, (F = n).idbdb, H), F._dbSchema)).add.length || F.change.some(function($) {
                  return $.add.length || $.change.length;
                })) && !m) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), G.close(), c = G.version + 1, m = !0, T(g());
                nt(n, H);
              } catch {
              }
              ol.push(n), G.onversionchange = Be(function($) {
                t.vcFired = !0, n.on("versionchange").fire($);
              }), G.onclose = Be(function($) {
                n.on("close").fire($);
              }), v && (F = n._deps, H = b, G = F.indexedDB, F = F.IDBKeyRange, jt(G) || H === Wl || zt(G, F).put({ name: H }).catch(De)), T();
            }, D);
          }).catch(function(T) {
            switch (T?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), g();
                break;
              case "VersionError":
                if (0 < c) return c = 0, g();
            }
            return ee.reject(T);
          });
        }
        var L, O = t.dbReadyResolve, w = null, v = !1;
        return ee.race([r, (typeof navigator > "u" ? ee.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(T) {
          function D() {
            return indexedDB.databases().finally(T);
          }
          L = setInterval(D, 100), D();
        }).finally(function() {
          return clearInterval(L);
        }) : Promise.resolve()).then(g)]).then(function() {
          return p(), t.onReadyBeingFired = [], ee.resolve(Ht(function() {
            return n.on.ready.fire(n.vip);
          })).then(function T() {
            if (0 < t.onReadyBeingFired.length) {
              var D = t.onReadyBeingFired.reduce(Ee, De);
              return t.onReadyBeingFired = [], ee.resolve(Ht(function() {
                return D(n.vip);
              })).then(T);
            }
          });
        }).finally(function() {
          t.openCanceller === r && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(T) {
          t.dbOpenError = T;
          try {
            w && w.abort();
          } catch {
          }
          return r === t.openCanceller && n._close(), He(T);
        }).finally(function() {
          t.openComplete = !0, O();
        }).then(function() {
          var T;
          return v && (T = {}, n.tables.forEach(function(D) {
            D.schema.indexes.forEach(function(b) {
              b.name && (T["idb://".concat(n.name, "/").concat(D.name, "/").concat(b.name)] = new un(-1 / 0, [[[]]]));
            }), T["idb://".concat(n.name, "/").concat(D.name, "/")] = T["idb://".concat(n.name, "/").concat(D.name, "/:dels")] = new un(-1 / 0, [[[]]]);
          }), jn(wl).fire(T), Qt(T, !0)), n;
        });
      }
      function Jt(n) {
        function t(m) {
          return n.next(m);
        }
        var u = c(t), r = c(function(m) {
          return n.throw(m);
        });
        function c(m) {
          return function(L) {
            var g = m(L), L = g.value;
            return g.done ? L : L && typeof L.then == "function" ? L.then(u, r) : d(L) ? Promise.all(L).then(u, r) : u(L);
          };
        }
        return c(t)();
      }
      function ct(n, t, u) {
        for (var r = d(n) ? n.slice() : [n], c = 0; c < u; ++c) r.push(t);
        return r;
      }
      var hr = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema, c = {}, m = [];
          function p(v, T, D) {
            var b = Cl(v), C = c[b] = c[b] || [], S = v == null ? 0 : typeof v == "string" ? 1 : v.length, P = 0 < T, P = a(a({}, D), { name: P ? "".concat(b, "(virtual-from:").concat(D.name, ")") : D.name, lowLevelIndex: D, isVirtual: P, keyTail: T, keyLength: S, extractKey: Zt(v), unique: !P && D.unique });
            return C.push(P), P.isPrimaryKey || m.push(P), 1 < S && p(S === 2 ? v[0] : v.slice(0, S - 1), T + 1, D), C.sort(function(A, N) {
              return A.keyTail - N.keyTail;
            }), P;
          }
          t = p(r.primaryKey.keyPath, 0, r.primaryKey), c[":id"] = [t];
          for (var g = 0, L = r.indexes; g < L.length; g++) {
            var O = L[g];
            p(O.keyPath, 0, O);
          }
          function w(v) {
            var T, D = v.query.index;
            return D.isVirtual ? a(a({}, v), { query: { index: D.lowLevelIndex, range: (T = v.query.range, D = D.keyTail, { type: T.type === 1 ? 2 : T.type, lower: ct(T.lower, T.lowerOpen ? n.MAX_KEY : n.MIN_KEY, D), lowerOpen: !0, upper: ct(T.upper, T.upperOpen ? n.MIN_KEY : n.MAX_KEY, D), upperOpen: !0 }) } }) : v;
          }
          return a(a({}, u), { schema: a(a({}, r), { primaryKey: t, indexes: m, getIndexByKeyPath: function(v) {
            return (v = c[Cl(v)]) && v[0];
          } }), count: function(v) {
            return u.count(w(v));
          }, query: function(v) {
            return u.query(w(v));
          }, openCursor: function(v) {
            var T = v.query.index, D = T.keyTail, b = T.isVirtual, C = T.keyLength;
            return b ? u.openCursor(w(v)).then(function(P) {
              return P && S(P);
            }) : u.openCursor(v);
            function S(P) {
              return Object.create(P, { continue: { value: function(A) {
                A != null ? P.continue(ct(A, v.reverse ? n.MAX_KEY : n.MIN_KEY, D)) : v.unique ? P.continue(P.key.slice(0, C).concat(v.reverse ? n.MIN_KEY : n.MAX_KEY, D)) : P.continue();
              } }, continuePrimaryKey: { value: function(A, N) {
                P.continuePrimaryKey(ct(A, n.MAX_KEY, D), N);
              } }, primaryKey: { get: function() {
                return P.primaryKey;
              } }, key: { get: function() {
                var A = P.key;
                return C === 1 ? A[0] : A.slice(0, C);
              } }, value: { get: function() {
                return P.value;
              } } });
            }
          } });
        } });
      } };
      function ei(n, t, u, r) {
        return u = u || {}, r = r || "", f(n).forEach(function(c) {
          var m, p, g;
          I(t, c) ? (m = n[c], p = t[c], typeof m == "object" && typeof p == "object" && m && p ? (g = Se(m)) !== Se(p) ? u[r + c] = t[c] : g === "Object" ? ei(m, p, u, r + c + ".") : m !== p && (u[r + c] = t[c]) : m !== p && (u[r + c] = t[c])) : u[r + c] = void 0;
        }), f(t).forEach(function(c) {
          I(n, c) || (u[r + c] = t[c]);
        }), u;
      }
      function ni(n, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(n.extractKey);
      }
      var gr = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema.primaryKey;
          return a(a({}, u), { mutate: function(c) {
            var m = se.trans, p = m.table(t).hook, g = p.deleting, L = p.creating, O = p.updating;
            switch (c.type) {
              case "add":
                if (L.fire === De) break;
                return m._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "put":
                if (L.fire === De && O.fire === De) break;
                return m._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "delete":
                if (g.fire === De) break;
                return m._promise("readwrite", function() {
                  return w(c);
                }, !0);
              case "deleteRange":
                if (g.fire === De) break;
                return m._promise("readwrite", function() {
                  return function v(T, D, b) {
                    return u.query({ trans: T, values: !1, query: { index: r, range: D }, limit: b }).then(function(C) {
                      var S = C.result;
                      return w({ type: "delete", keys: S, trans: T }).then(function(P) {
                        return 0 < P.numFailures ? Promise.reject(P.failures[0]) : S.length < b ? { failures: [], numFailures: 0, lastResult: void 0 } : v(T, a(a({}, D), { lower: S[S.length - 1], lowerOpen: !0 }), b);
                      });
                    });
                  }(c.trans, c.range, 1e4);
                }, !0);
            }
            return u.mutate(c);
            function w(v) {
              var T, D, b, C = se.trans, S = v.keys || ni(r, v);
              if (!S) throw new Error("Keys missing");
              return (v = v.type === "add" || v.type === "put" ? a(a({}, v), { keys: S }) : a({}, v)).type !== "delete" && (v.values = s([], v.values)), v.keys && (v.keys = s([], v.keys)), T = u, b = S, ((D = v).type === "add" ? Promise.resolve([]) : T.getMany({ trans: D.trans, keys: b, cache: "immutable" })).then(function(P) {
                var A = S.map(function(N, F) {
                  var G, Y, H, $ = P[F], J = { onerror: null, onsuccess: null };
                  return v.type === "delete" ? g.fire.call(J, N, $, C) : v.type === "add" || $ === void 0 ? (G = L.fire.call(J, N, v.values[F], C), N == null && G != null && (v.keys[F] = N = G, r.outbound || ne(v.values[F], r.keyPath, N))) : (G = ei($, v.values[F]), (Y = O.fire.call(J, G, N, $, C)) && (H = v.values[F], Object.keys(Y).forEach(function(Q) {
                    I(H, Q) ? H[Q] = Y[Q] : ne(H, Q, Y[Q]);
                  }))), J;
                });
                return u.mutate(v).then(function(N) {
                  for (var F = N.failures, G = N.results, Y = N.numFailures, N = N.lastResult, H = 0; H < S.length; ++H) {
                    var $ = (G || S)[H], J = A[H];
                    $ == null ? J.onerror && J.onerror(F[H]) : J.onsuccess && J.onsuccess(v.type === "put" && P[H] ? v.values[H] : $);
                  }
                  return { failures: F, results: G, numFailures: Y, lastResult: N };
                }).catch(function(N) {
                  return A.forEach(function(F) {
                    return F.onerror && F.onerror(N);
                  }), Promise.reject(N);
                });
              });
            }
          } });
        } });
      } };
      function Iu(n, t, u) {
        try {
          if (!t || t.keys.length < n.length) return null;
          for (var r = [], c = 0, m = 0; c < t.keys.length && m < n.length; ++c) Te(t.keys[c], n[m]) === 0 && (r.push(u ? ye(t.values[c]) : t.values[c]), ++m);
          return r.length === n.length ? r : null;
        } catch {
          return null;
        }
      }
      var vr = { stack: "dbcore", level: -1, create: function(n) {
        return { table: function(t) {
          var u = n.table(t);
          return a(a({}, u), { getMany: function(r) {
            if (!r.cache) return u.getMany(r);
            var c = Iu(r.keys, r.trans._cache, r.cache === "clone");
            return c ? ee.resolve(c) : u.getMany(r).then(function(m) {
              return r.trans._cache = { keys: r.keys, values: r.cache === "clone" ? ye(m) : m }, m;
            });
          }, mutate: function(r) {
            return r.type !== "add" && (r.trans._cache = null), u.mutate(r);
          } });
        } };
      } };
      function Lu(n, t) {
        return n.trans.mode === "readonly" && !!n.subscr && !n.trans.explicit && n.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function Du(n, t) {
        switch (n) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var xr = { stack: "dbcore", level: 0, name: "Observability", create: function(n) {
        var t = n.schema.name, u = new un(n.MIN_KEY, n.MAX_KEY);
        return a(a({}, n), { transaction: function(r, c, m) {
          if (se.subscr && c !== "readonly") throw new Z.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(se.querier));
          return n.transaction(r, c, m);
        }, table: function(r) {
          var c = n.table(r), m = c.schema, p = m.primaryKey, v = m.indexes, g = p.extractKey, L = p.outbound, O = p.autoIncrement && v.filter(function(D) {
            return D.compound && D.keyPath.includes(p.keyPath);
          }), w = a(a({}, c), { mutate: function(D) {
            function b(Q) {
              return Q = "idb://".concat(t, "/").concat(r, "/").concat(Q), N[Q] || (N[Q] = new un());
            }
            var C, S, P, A = D.trans, N = D.mutatedParts || (D.mutatedParts = {}), F = b(""), G = b(":dels"), Y = D.type, J = D.type === "deleteRange" ? [D.range] : D.type === "delete" ? [D.keys] : D.values.length < 50 ? [ni(p, D).filter(function(Q) {
              return Q;
            }), D.values] : [], H = J[0], $ = J[1], J = D.trans._cache;
            return d(H) ? (F.addKeys(H), (J = Y === "delete" || H.length === $.length ? Iu(H, J) : null) || G.addKeys(H), (J || $) && (C = b, S = J, P = $, m.indexes.forEach(function(Q) {
              var le = C(Q.name || "");
              function ve(he) {
                return he != null ? Q.extractKey(he) : null;
              }
              function qe(he) {
                return Q.multiEntry && d(he) ? he.forEach(function(Ge) {
                  return le.addKey(Ge);
                }) : le.addKey(he);
              }
              (S || P).forEach(function(he, an) {
                var pe = S && ve(S[an]), an = P && ve(P[an]);
                Te(pe, an) !== 0 && (pe != null && qe(pe), an != null && qe(an));
              });
            }))) : H ? ($ = { from: ($ = H.lower) !== null && $ !== void 0 ? $ : n.MIN_KEY, to: ($ = H.upper) !== null && $ !== void 0 ? $ : n.MAX_KEY }, G.add($), F.add($)) : (F.add(u), G.add(u), m.indexes.forEach(function(Q) {
              return b(Q.name).add(u);
            })), c.mutate(D).then(function(Q) {
              return !H || D.type !== "add" && D.type !== "put" || (F.addKeys(Q.results), O && O.forEach(function(le) {
                for (var ve = D.values.map(function(pe) {
                  return le.extractKey(pe);
                }), qe = le.keyPath.findIndex(function(pe) {
                  return pe === p.keyPath;
                }), he = 0, Ge = Q.results.length; he < Ge; ++he) ve[he][qe] = Q.results[he];
                b(le.name).addKeys(ve);
              })), A.mutatedParts = rt(A.mutatedParts || {}, N), Q;
            });
          } }), v = function(b) {
            var C = b.query, b = C.index, C = C.range;
            return [b, new un((b = C.lower) !== null && b !== void 0 ? b : n.MIN_KEY, (C = C.upper) !== null && C !== void 0 ? C : n.MAX_KEY)];
          }, T = { get: function(D) {
            return [p, new un(D.key)];
          }, getMany: function(D) {
            return [p, new un().addKeys(D.keys)];
          }, count: v, query: v, openCursor: v };
          return f(T).forEach(function(D) {
            w[D] = function(b) {
              var C = se.subscr, S = !!C, P = Lu(se, c) && Du(D, b) ? b.obsSet = {} : C;
              if (S) {
                var A = function($) {
                  return $ = "idb://".concat(t, "/").concat(r, "/").concat($), P[$] || (P[$] = new un());
                }, N = A(""), F = A(":dels"), C = T[D](b), S = C[0], C = C[1];
                if ((D === "query" && S.isPrimaryKey && !b.values ? F : A(S.name || "")).add(C), !S.isPrimaryKey) {
                  if (D !== "count") {
                    var G = D === "query" && L && b.values && c.query(a(a({}, b), { values: !1 }));
                    return c[D].apply(this, arguments).then(function($) {
                      if (D === "query") {
                        if (L && b.values) return G.then(function(ve) {
                          return ve = ve.result, N.addKeys(ve), $;
                        });
                        var J = b.values ? $.result.map(g) : $.result;
                        (b.values ? N : F).addKeys(J);
                      } else if (D === "openCursor") {
                        var Q = $, le = b.values;
                        return Q && Object.create(Q, { key: { get: function() {
                          return F.addKey(Q.primaryKey), Q.key;
                        } }, primaryKey: { get: function() {
                          var ve = Q.primaryKey;
                          return F.addKey(ve), ve;
                        } }, value: { get: function() {
                          return le && N.addKey(Q.primaryKey), Q.value;
                        } } });
                      }
                      return $;
                    });
                  }
                  F.add(u);
                }
              }
              return c[D].apply(this, arguments);
            };
          }), w;
        } });
      } };
      function Ou(n, t, u) {
        if (u.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var r = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return u.numFailures === r ? null : (t = a({}, t), d(t.keys) && (t.keys = t.keys.filter(function(c, m) {
          return !(m in u.failures);
        })), "values" in t && d(t.values) && (t.values = t.values.filter(function(c, m) {
          return !(m in u.failures);
        })), t);
      }
      function li(n, t) {
        return u = n, ((r = t).lower === void 0 || (r.lowerOpen ? 0 < Te(u, r.lower) : 0 <= Te(u, r.lower))) && (n = n, (t = t).upper === void 0 || (t.upperOpen ? Te(n, t.upper) < 0 : Te(n, t.upper) <= 0));
        var u, r;
      }
      function bu(n, t, T, r, c, m) {
        if (!T || T.length === 0) return n;
        var p = t.query.index, g = p.multiEntry, L = t.query.range, O = r.schema.primaryKey.extractKey, w = p.extractKey, v = (p.lowLevelIndex || p).extractKey, T = T.reduce(function(D, b) {
          var C = D, S = [];
          if (b.type === "add" || b.type === "put") for (var P = new un(), A = b.values.length - 1; 0 <= A; --A) {
            var N, F = b.values[A], G = O(F);
            P.hasKey(G) || (N = w(F), (g && d(N) ? N.some(function(Q) {
              return li(Q, L);
            }) : li(N, L)) && (P.addKey(G), S.push(F)));
          }
          switch (b.type) {
            case "add":
              var Y = new un().addKeys(t.values ? D.map(function(le) {
                return O(le);
              }) : D), C = D.concat(t.values ? S.filter(function(le) {
                return le = O(le), !Y.hasKey(le) && (Y.addKey(le), !0);
              }) : S.map(function(le) {
                return O(le);
              }).filter(function(le) {
                return !Y.hasKey(le) && (Y.addKey(le), !0);
              }));
              break;
            case "put":
              var H = new un().addKeys(b.values.map(function(le) {
                return O(le);
              }));
              C = D.filter(function(le) {
                return !H.hasKey(t.values ? O(le) : le);
              }).concat(t.values ? S : S.map(function(le) {
                return O(le);
              }));
              break;
            case "delete":
              var $ = new un().addKeys(b.keys);
              C = D.filter(function(le) {
                return !$.hasKey(t.values ? O(le) : le);
              });
              break;
            case "deleteRange":
              var J = b.range;
              C = D.filter(function(le) {
                return !li(O(le), J);
              });
          }
          return C;
        }, n);
        return T === n ? n : (T.sort(function(D, b) {
          return Te(v(D), v(b)) || Te(O(D), O(b));
        }), t.limit && t.limit < 1 / 0 && (T.length > t.limit ? T.length = t.limit : n.length === t.limit && T.length < t.limit && (c.dirty = !0)), m ? Object.freeze(T) : T);
      }
      function wu(n, t) {
        return Te(n.lower, t.lower) === 0 && Te(n.upper, t.upper) === 0 && !!n.lowerOpen == !!t.lowerOpen && !!n.upperOpen == !!t.upperOpen;
      }
      function yr(n, t) {
        return function(u, r, c, m) {
          if (u === void 0) return r !== void 0 ? -1 : 0;
          if (r === void 0) return 1;
          if ((r = Te(u, r)) === 0) {
            if (c && m) return 0;
            if (c) return 1;
            if (m) return -1;
          }
          return r;
        }(n.lower, t.lower, n.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(u, r, c, m) {
          if (u === void 0) return r !== void 0 ? 1 : 0;
          if (r === void 0) return -1;
          if ((r = Te(u, r)) === 0) {
            if (c && m) return 0;
            if (c) return -1;
            if (m) return 1;
          }
          return r;
        }(n.upper, t.upper, n.upperOpen, t.upperOpen);
      }
      function Ir(n, t, u, r) {
        n.subscribers.add(u), r.addEventListener("abort", function() {
          var c, m;
          n.subscribers.delete(u), n.subscribers.size === 0 && (c = n, m = t, setTimeout(function() {
            c.subscribers.size === 0 && de(m, c);
          }, 3e3));
        });
      }
      var Lr = { stack: "dbcore", level: 0, name: "Cache", create: function(n) {
        var t = n.schema.name;
        return a(a({}, n), { transaction: function(u, r, c) {
          var m, p, g = n.transaction(u, r, c);
          return r === "readwrite" && (p = (m = new AbortController()).signal, c = function(L) {
            return function() {
              if (m.abort(), r === "readwrite") {
                for (var O = /* @__PURE__ */ new Set(), w = 0, v = u; w < v.length; w++) {
                  var T = v[w], D = nl["idb://".concat(t, "/").concat(T)];
                  if (D) {
                    var b = n.table(T), C = D.optimisticOps.filter(function(le) {
                      return le.trans === g;
                    });
                    if (g._explicit && L && g.mutatedParts) for (var S = 0, P = Object.values(D.queries.query); S < P.length; S++) for (var A = 0, N = (Y = P[S]).slice(); A < N.length; A++) Wt((H = N[A]).obsSet, g.mutatedParts) && (de(Y, H), H.subscribers.forEach(function(le) {
                      return O.add(le);
                    }));
                    else if (0 < C.length) {
                      D.optimisticOps = D.optimisticOps.filter(function(le) {
                        return le.trans !== g;
                      });
                      for (var F = 0, G = Object.values(D.queries.query); F < G.length; F++) for (var Y, H, $, J = 0, Q = (Y = G[F]).slice(); J < Q.length; J++) (H = Q[J]).res != null && g.mutatedParts && (L && !H.dirty ? ($ = Object.isFrozen(H.res), $ = bu(H.res, H.req, C, b, H, $), H.dirty ? (de(Y, H), H.subscribers.forEach(function(le) {
                        return O.add(le);
                      })) : $ !== H.res && (H.res = $, H.promise = ee.resolve({ result: $ }))) : (H.dirty && de(Y, H), H.subscribers.forEach(function(le) {
                        return O.add(le);
                      })));
                    }
                  }
                }
                O.forEach(function(le) {
                  return le();
                });
              }
            };
          }, g.addEventListener("abort", c(!1), { signal: p }), g.addEventListener("error", c(!1), { signal: p }), g.addEventListener("complete", c(!0), { signal: p })), g;
        }, table: function(u) {
          var r = n.table(u), c = r.schema.primaryKey;
          return a(a({}, r), { mutate: function(m) {
            var p = se.trans;
            if (c.outbound || p.db._options.cache === "disabled" || p.explicit || p.idbtrans.mode !== "readwrite") return r.mutate(m);
            var g = nl["idb://".concat(t, "/").concat(u)];
            return g ? (p = r.mutate(m), m.type !== "add" && m.type !== "put" || !(50 <= m.values.length || ni(c, m).some(function(L) {
              return L == null;
            })) ? (g.optimisticOps.push(m), m.mutatedParts && st(m.mutatedParts), p.then(function(L) {
              0 < L.numFailures && (de(g.optimisticOps, m), (L = Ou(0, m, L)) && g.optimisticOps.push(L), m.mutatedParts && st(m.mutatedParts));
            }), p.catch(function() {
              de(g.optimisticOps, m), m.mutatedParts && st(m.mutatedParts);
            })) : p.then(function(L) {
              var O = Ou(0, a(a({}, m), { values: m.values.map(function(w, v) {
                var T;
                return L.failures[v] ? w : (w = (T = c.keyPath) !== null && T !== void 0 && T.includes(".") ? ye(w) : a({}, w), ne(w, c.keyPath, L.results[v]), w);
              }) }), L);
              g.optimisticOps.push(O), queueMicrotask(function() {
                return m.mutatedParts && st(m.mutatedParts);
              });
            }), p) : r.mutate(m);
          }, query: function(m) {
            if (!Lu(se, r) || !Du("query", m)) return r.query(m);
            var p = ((O = se.trans) === null || O === void 0 ? void 0 : O.db._options.cache) === "immutable", v = se, g = v.requery, L = v.signal, O = function(b, C, S, P) {
              var A = nl["idb://".concat(b, "/").concat(C)];
              if (!A) return [];
              if (!(C = A.queries[S])) return [null, !1, A, null];
              var N = C[(P.query ? P.query.index.name : null) || ""];
              if (!N) return [null, !1, A, null];
              switch (S) {
                case "query":
                  var F = N.find(function(G) {
                    return G.req.limit === P.limit && G.req.values === P.values && wu(G.req.query.range, P.query.range);
                  });
                  return F ? [F, !0, A, N] : [N.find(function(G) {
                    return ("limit" in G.req ? G.req.limit : 1 / 0) >= P.limit && (!P.values || G.req.values) && yr(G.req.query.range, P.query.range);
                  }), !1, A, N];
                case "count":
                  return F = N.find(function(G) {
                    return wu(G.req.query.range, P.query.range);
                  }), [F, !!F, A, N];
              }
            }(t, u, "query", m), w = O[0], v = O[1], T = O[2], D = O[3];
            return w && v ? w.obsSet = m.obsSet : (v = r.query(m).then(function(b) {
              var C = b.result;
              if (w && (w.res = C), p) {
                for (var S = 0, P = C.length; S < P; ++S) Object.freeze(C[S]);
                Object.freeze(C);
              } else b.result = ye(C);
              return b;
            }).catch(function(b) {
              return D && w && de(D, w), Promise.reject(b);
            }), w = { obsSet: m.obsSet, promise: v, subscribers: /* @__PURE__ */ new Set(), type: "query", req: m, dirty: !1 }, D ? D.push(w) : (D = [w], (T = T || (nl["idb://".concat(t, "/").concat(u)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[m.query.index.name || ""] = D)), Ir(w, D, g, L), w.promise.then(function(b) {
              return { result: bu(b.result, m, T?.optimisticOps, r, w, p) };
            });
          } });
        } });
      } };
      function ot(n, t) {
        return new Proxy(n, { get: function(u, r, c) {
          return r === "db" ? t : Reflect.get(u, r, c);
        } });
      }
      var En = ($e.prototype.version = function(n) {
        if (isNaN(n) || n < 0.1) throw new Z.Type("Given version is not a positive number");
        if (n = Math.round(10 * n) / 10, this.idbdb || this._state.isBeingOpened) throw new Z.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, n);
        var t = this._versions, u = t.filter(function(r) {
          return r._cfg.version === n;
        })[0];
        return u || (u = new this.Version(n), t.push(u), t.sort(or), u.stores({}), this._state.autoSchema = !1, u);
      }, $e.prototype._whenReady = function(n) {
        var t = this;
        return this.idbdb && (this._state.openComplete || se.letThrough || this._vip) ? n() : new ee(function(u, r) {
          if (t._state.openComplete) return r(new Z.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void r(new Z.DatabaseClosed());
            t.open().catch(De);
          }
          t._state.dbReadyPromise.then(u, r);
        }).then(n);
      }, $e.prototype.use = function(n) {
        var t = n.stack, u = n.create, r = n.level, c = n.name;
        return c && this.unuse({ stack: t, name: c }), n = this._middlewares[t] || (this._middlewares[t] = []), n.push({ stack: t, create: u, level: r ?? 10, name: c }), n.sort(function(m, p) {
          return m.level - p.level;
        }), this;
      }, $e.prototype.unuse = function(n) {
        var t = n.stack, u = n.name, r = n.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(c) {
          return r ? c.create !== r : !!u && c.name !== u;
        })), this;
      }, $e.prototype.open = function() {
        var n = this;
        return Qn(Rn, function() {
          return pr(n);
        });
      }, $e.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var n = this._state, t = ol.indexOf(this);
        if (0 <= t && ol.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        n.isBeingOpened || (n.dbReadyPromise = new ee(function(u) {
          n.dbReadyResolve = u;
        }), n.openCanceller = new ee(function(u, r) {
          n.cancelOpen = r;
        }));
      }, $e.prototype.close = function(u) {
        var t = (u === void 0 ? { disableAutoOpen: !0 } : u).disableAutoOpen, u = this._state;
        t ? (u.isBeingOpened && u.cancelOpen(new Z.DatabaseClosed()), this._close(), u.autoOpen = !1, u.dbOpenError = new Z.DatabaseClosed()) : (this._close(), u.autoOpen = this._options.autoOpen || u.isBeingOpened, u.openComplete = !1, u.dbOpenError = null);
      }, $e.prototype.delete = function(n) {
        var t = this;
        n === void 0 && (n = { disableAutoOpen: !0 });
        var u = 0 < arguments.length && typeof arguments[0] != "object", r = this._state;
        return new ee(function(c, m) {
          function p() {
            t.close(n);
            var g = t._deps.indexedDB.deleteDatabase(t.name);
            g.onsuccess = Be(function() {
              var L, O, w;
              L = t._deps, O = t.name, w = L.indexedDB, L = L.IDBKeyRange, jt(w) || O === Wl || zt(w, L).delete(O).catch(De), c();
            }), g.onerror = wn(m), g.onblocked = t._fireOnBlocked;
          }
          if (u) throw new Z.InvalidArgument("Invalid closeOptions argument to db.delete()");
          r.isBeingOpened ? r.dbReadyPromise.then(p) : p();
        });
      }, $e.prototype.backendDB = function() {
        return this.idbdb;
      }, $e.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, $e.prototype.hasBeenClosed = function() {
        var n = this._state.dbOpenError;
        return n && n.name === "DatabaseClosed";
      }, $e.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, $e.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty($e.prototype, "tables", { get: function() {
        var n = this;
        return f(this._allTables).map(function(t) {
          return n._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), $e.prototype.transaction = function() {
        var n = (function(t, u, r) {
          var c = arguments.length;
          if (c < 2) throw new Z.InvalidArgument("Too few arguments");
          for (var m = new Array(c - 1); --c; ) m[c - 1] = arguments[c];
          return r = m.pop(), [t, me(m), r];
        }).apply(this, arguments);
        return this._transaction.apply(this, n);
      }, $e.prototype._transaction = function(n, t, u) {
        var r = this, c = se.trans;
        c && c.db === this && n.indexOf("!") === -1 || (c = null);
        var m, p, g = n.indexOf("?") !== -1;
        n = n.replace("!", "").replace("?", "");
        try {
          if (p = t.map(function(O) {
            if (O = O instanceof r.Table ? O.name : O, typeof O != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return O;
          }), n == "r" || n === _t) m = _t;
          else {
            if (n != "rw" && n != Nt) throw new Z.InvalidArgument("Invalid transaction mode: " + n);
            m = Nt;
          }
          if (c) {
            if (c.mode === _t && m === Nt) {
              if (!g) throw new Z.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              c = null;
            }
            c && p.forEach(function(O) {
              if (c && c.storeNames.indexOf(O) === -1) {
                if (!g) throw new Z.SubTransaction("Table " + O + " not included in parent transaction.");
                c = null;
              }
            }), g && c && !c.active && (c = null);
          }
        } catch (O) {
          return c ? c._promise(null, function(w, v) {
            v(O);
          }) : He(O);
        }
        var L = (function O(w, v, T, D, b) {
          return ee.resolve().then(function() {
            var C = se.transless || se, S = w._createTransaction(v, T, w._dbSchema, D);
            if (S.explicit = !0, C = { trans: S, transless: C }, D) S.idbtrans = D.idbtrans;
            else try {
              S.create(), S.idbtrans._explicit = !0, w._state.PR1398_maxLoop = 3;
            } catch (N) {
              return N.name === V.InvalidState && w.isOpen() && 0 < --w._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), w.close({ disableAutoOpen: !1 }), w.open().then(function() {
                return O(w, v, T, null, b);
              })) : He(N);
            }
            var P, A = We(b);
            return A && cl(), C = ee.follow(function() {
              var N;
              (P = b.call(S, S)) && (A ? (N = Kn.bind(null, null), P.then(N, N)) : typeof P.next == "function" && typeof P.throw == "function" && (P = Jt(P)));
            }, C), (P && typeof P.then == "function" ? ee.resolve(P).then(function(N) {
              return S.active ? N : He(new Z.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : C.then(function() {
              return P;
            })).then(function(N) {
              return D && S._resolve(), S._completion.then(function() {
                return N;
              });
            }).catch(function(N) {
              return S._reject(N), He(N);
            });
          });
        }).bind(null, this, m, p, c, u);
        return c ? c._promise(m, L, "lock") : se.trans ? Qn(se.transless, function() {
          return r._whenReady(L);
        }) : this._whenReady(L);
      }, $e.prototype.table = function(n) {
        if (!I(this._allTables, n)) throw new Z.InvalidTable("Table ".concat(n, " does not exist"));
        return this._allTables[n];
      }, $e);
      function $e(n, t) {
        var u = this;
        this._middlewares = {}, this.verno = 0;
        var r = $e.dependencies;
        this._options = t = a({ addons: $e.addons, autoOpen: !0, indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, r = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var c, m, p, g, L, O = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: De, dbReadyPromise: null, cancelOpen: De, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        O.dbReadyPromise = new ee(function(v) {
          O.dbReadyResolve = v;
        }), O.openCanceller = new ee(function(v, T) {
          O.cancelOpen = T;
        }), this._state = O, this.name = n, this.on = Ll(this, "populate", "blocked", "versionchange", "close", { ready: [Ee, De] }), this.once = function(v, T) {
          var D = function() {
            for (var b = [], C = 0; C < arguments.length; C++) b[C] = arguments[C];
            u.on(v).unsubscribe(D), T.apply(u, b);
          };
          return u.on(v, D);
        }, this.on.ready.subscribe = B(this.on.ready.subscribe, function(v) {
          return function(T, D) {
            $e.vip(function() {
              var b, C = u._state;
              C.openComplete ? (C.dbOpenError || ee.resolve().then(T), D && v(T)) : C.onReadyBeingFired ? (C.onReadyBeingFired.push(T), D && v(T)) : (v(T), b = u, D || v(function S() {
                b.on.ready.unsubscribe(T), b.on.ready.unsubscribe(S);
              }));
            });
          };
        }), this.Collection = (c = this, Dl(tr.prototype, function(P, S) {
          this.db = c;
          var D = nu, b = null;
          if (S) try {
            D = S();
          } catch (A) {
            b = A;
          }
          var C = P._ctx, S = C.table, P = S.hook.reading.fire;
          this._ctx = { table: S, index: C.index, isPrimKey: !C.index || S.schema.primKey.keyPath && C.index === S.schema.primKey.name, range: D, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: b, or: C.or, valueMapper: P !== j ? P : null };
        })), this.Table = (m = this, Dl(uu.prototype, function(v, T, D) {
          this.db = m, this._tx = D, this.name = v, this.schema = T, this.hook = m._allTables[v] ? m._allTables[v].hook : Ll(null, { creating: [Ce, De], reading: [ie, j], updating: [we, De], deleting: [Ie, De] });
        })), this.Transaction = (p = this, Dl(ar.prototype, function(v, T, D, b, C) {
          var S = this;
          v !== "readonly" && T.forEach(function(P) {
            P = (P = D[P]) === null || P === void 0 ? void 0 : P.yProps, P && (T = T.concat(P.map(function(A) {
              return A.updatesTable;
            })));
          }), this.db = p, this.mode = v, this.storeNames = T, this.schema = D, this.chromeTransactionDurability = b, this.idbtrans = null, this.on = Ll(this, "complete", "error", "abort"), this.parent = C || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ee(function(P, A) {
            S._resolve = P, S._reject = A;
          }), this._completion.then(function() {
            S.active = !1, S.on.complete.fire();
          }, function(P) {
            var A = S.active;
            return S.active = !1, S.on.error.fire(P), S.parent ? S.parent._reject(P) : A && S.idbtrans && S.idbtrans.abort(), He(P);
          });
        })), this.Version = (g = this, Dl(dr.prototype, function(v) {
          this.db = g, this._cfg = { version: v, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (L = this, Dl(mu.prototype, function(v, T, D) {
          if (this.db = L, this._ctx = { table: v, index: T === ":id" ? null : T, or: D }, this._cmp = this._ascending = Te, this._descending = function(b, C) {
            return Te(C, b);
          }, this._max = function(b, C) {
            return 0 < Te(b, C) ? b : C;
          }, this._min = function(b, C) {
            return Te(b, C) < 0 ? b : C;
          }, this._IDBKeyRange = L._deps.IDBKeyRange, !this._IDBKeyRange) throw new Z.MissingAPI();
        })), this.on("versionchange", function(v) {
          0 < v.newVersion ? console.warn("Another connection wants to upgrade database '".concat(u.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(u.name, "'. Closing db now to resume the delete request.")), u.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(v) {
          !v.newVersion || v.newVersion < v.oldVersion ? console.warn("Dexie.delete('".concat(u.name, "') was blocked")) : console.warn("Upgrade '".concat(u.name, "' blocked by other connection holding version ").concat(v.oldVersion / 10));
        }), this._maxKey = Sl(t.IDBKeyRange), this._createTransaction = function(v, T, D, b) {
          return new u.Transaction(v, T, D, u._options.chromeTransactionDurability, b);
        }, this._fireOnBlocked = function(v) {
          u.on("blocked").fire(v), ol.filter(function(T) {
            return T.name === u.name && T !== u && !T._state.vcFired;
          }).map(function(T) {
            return T.on("versionchange").fire(v);
          });
        }, this.use(vr), this.use(Lr), this.use(xr), this.use(hr), this.use(gr);
        var w = new Proxy(this, { get: function(v, T, D) {
          if (T === "_vip") return !0;
          if (T === "table") return function(C) {
            return ot(u.table(C), w);
          };
          var b = Reflect.get(v, T, D);
          return b instanceof uu ? ot(b, w) : T === "tables" ? b.map(function(C) {
            return ot(C, w);
          }) : T === "_createTransaction" ? function() {
            return ot(b.apply(this, arguments), w);
          } : b;
        } });
        this.vip = w, r.forEach(function(v) {
          return v(u);
        });
      }
      var mt, In = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Dr = (ti.prototype.subscribe = function(n, t, u) {
        return this._subscribe(n && typeof n != "function" ? n : { next: n, error: t, complete: u });
      }, ti.prototype[In] = function() {
        return this;
      }, ti);
      function ti(n) {
        this._subscribe = n;
      }
      try {
        mt = { indexedDB: o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB, IDBKeyRange: o.IDBKeyRange || o.webkitIDBKeyRange };
      } catch {
        mt = { indexedDB: null, IDBKeyRange: null };
      }
      function Su(n) {
        var t, u = !1, r = new Dr(function(c) {
          var m = We(n), p, g = !1, L = {}, O = {}, w = { get closed() {
            return g;
          }, unsubscribe: function() {
            g || (g = !0, p && p.abort(), v && jn.storagemutated.unsubscribe(D));
          } };
          c.start && c.start(w);
          var v = !1, T = function() {
            return Et(b);
          }, D = function(C) {
            rt(L, C), Wt(O, L) && T();
          }, b = function() {
            var C, S, P;
            !g && mt.indexedDB && (L = {}, C = {}, p && p.abort(), p = new AbortController(), P = function(A) {
              var N = rl();
              try {
                m && cl();
                var F = Un(n, A);
                return F = m ? F.finally(Kn) : F;
              } finally {
                N && sl();
              }
            }(S = { subscr: C, signal: p.signal, requery: T, querier: n, trans: null }), Promise.resolve(P).then(function(A) {
              u = !0, t = A, g || S.signal.aborted || (L = {}, function(N) {
                for (var F in N) if (I(N, F)) return;
                return 1;
              }(O = C) || v || (jn(wl, D), v = !0), Et(function() {
                return !g && c.next && c.next(A);
              }));
            }, function(A) {
              u = !1, ["DatabaseClosedError", "AbortError"].includes(A?.name) || g || Et(function() {
                g || c.error && c.error(A);
              });
            }));
          };
          return setTimeout(T, 0), w;
        });
        return r.hasValue = function() {
          return u;
        }, r.getValue = function() {
          return t;
        }, r;
      }
      var ll = En;
      function ii(n) {
        var t = Hn;
        try {
          Hn = !0, jn.storagemutated.fire(n), Qt(n, !0);
        } finally {
          Hn = t;
        }
      }
      q(ll, a(a({}, Qe), { delete: function(n) {
        return new ll(n, { addons: [] }).delete();
      }, exists: function(n) {
        return new ll(n, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(n) {
        try {
          return t = ll.dependencies, u = t.indexedDB, t = t.IDBKeyRange, (jt(u) ? Promise.resolve(u.databases()).then(function(r) {
            return r.map(function(c) {
              return c.name;
            }).filter(function(c) {
              return c !== Wl;
            });
          }) : zt(u, t).toCollection().primaryKeys()).then(n);
        } catch {
          return He(new Z.MissingAPI());
        }
        var t, u;
      }, defineClass: function() {
        return function(n) {
          h(this, n);
        };
      }, ignoreTransaction: function(n) {
        return se.trans ? Qn(se.transless, n) : n();
      }, vip: Ht, async: function(n) {
        return function() {
          try {
            var t = Jt(n.apply(this, arguments));
            return t && typeof t.then == "function" ? t : ee.resolve(t);
          } catch (u) {
            return He(u);
          }
        };
      }, spawn: function(n, t, u) {
        try {
          var r = Jt(n.apply(u, t || []));
          return r && typeof r.then == "function" ? r : ee.resolve(r);
        } catch (c) {
          return He(c);
        }
      }, currentTransaction: { get: function() {
        return se.trans || null;
      } }, waitFor: function(n, t) {
        return t = ee.resolve(typeof n == "function" ? ll.ignoreTransaction(n) : n).timeout(t || 6e4), se.trans ? se.trans.waitFor(t) : t;
      }, Promise: ee, debug: { get: function() {
        return Oe;
      }, set: function(n) {
        Pe(n);
      } }, derive: M, extend: h, props: q, override: B, Events: Ll, on: jn, liveQuery: Su, extendObservabilitySet: rt, getByKeyPath: ae, setByKeyPath: ne, delByKeyPath: function(n, t) {
        typeof t == "string" ? ne(n, t, void 0) : "length" in t && [].map.call(t, function(u) {
          ne(n, u, void 0);
        });
      }, shallowClone: oe, deepClone: ye, getObjectDiff: ei, cmp: Te, asap: W, minKey: -1 / 0, addons: [], connections: ol, errnames: V, dependencies: mt, cache: nl, semVer: "4.2.0", version: "4.2.0".split(".").map(function(n) {
        return parseInt(n);
      }).reduce(function(n, t, u) {
        return n + t / Math.pow(10, 2 * u);
      }) })), ll.maxKey = Sl(ll.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (jn(wl, function(n) {
        Hn || (n = new CustomEvent(kt, { detail: n }), Hn = !0, dispatchEvent(n), Hn = !1);
      }), addEventListener(kt, function(n) {
        n = n.detail, Hn || ii(n);
      }));
      var xl, Hn = !1, Cu = function() {
      };
      return typeof BroadcastChannel < "u" && ((Cu = function() {
        (xl = new BroadcastChannel(kt)).onmessage = function(n) {
          return n.data && ii(n.data);
        };
      })(), typeof xl.unref == "function" && xl.unref(), jn(wl, function(n) {
        Hn || xl.postMessage(n);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(n) {
        if (!En.disableBfCache && n.persisted) {
          Oe && console.debug("Dexie: handling persisted pagehide"), xl?.close();
          for (var t = 0, u = ol; t < u.length; t++) u[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(n) {
        !En.disableBfCache && n.persisted && (Oe && console.debug("Dexie: handling persisted pageshow"), Cu(), ii({ all: new un(-1 / 0, [[]]) }));
      })), ee.rejectionMapper = function(n, t) {
        return !n || n instanceof cn || n instanceof TypeError || n instanceof SyntaxError || !n.name || !ue[n.name] ? n : (t = new ue[n.name](t || n.message, n), "stack" in n && E(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, Pe(Oe), a(En, Object.freeze({ __proto__: null, Dexie: En, liveQuery: Su, Entity: lu, cmp: Te, PropModification: Ol, replacePrefix: function(n, t) {
        return new Ol({ replacePrefix: [n, t] });
      }, add: function(n) {
        return new Ol({ add: n });
      }, remove: function(n) {
        return new Ol({ remove: n });
      }, default: En, RangeSet: un, mergeRanges: Pl, rangesOverlap: gu }), { default: En }), En;
    });
  }(ac)), ac.exports;
}
var O0 = D0();
const Pm = /* @__PURE__ */ I0(O0), Md = Symbol.for("Dexie"), Tc = globalThis[Md] || (globalThis[Md] = Pm);
if (Pm.semVer !== Tc.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Pm.semVer} and ${Tc.semVer}`);
const {
  liveQuery: b0,
  mergeRanges: kC,
  rangesOverlap: VC,
  RangeSet: BC,
  cmp: ZC,
  Entity: UC,
  PropModification: KC,
  replacePrefix: GC,
  add: zC,
  remove: jC,
  DexieYProvider: HC
} = Tc, Ds = /* @__PURE__ */ lo("s-ied-implementation/primary-sidebar", () => {
  const e = h0(
    "currentActiveIcdDatabaseName",
    "",
    localStorage
  ), l = Fe(null), i = Fe(""), a = Fe();
  function s(x) {
    const { onChange: y, reset: I } = x0({
      multiple: !1,
      accept: ".icd",
      input: x
    });
    y(async (q) => {
      const R = q?.[0];
      if (!R) return;
      const E = await kD({ files: [R] });
      e.value = E[0];
    }), a.value = I;
  }
  async function o() {
    e.value && d();
  }
  async function f(x) {
    if (!e.value) return;
    const y = new File([], e.value + ".icd", {
      type: "application/xml"
    }), I = new DataTransfer();
    I.items.add(y), x.files = I.files;
  }
  async function d() {
    await Tc.delete(e.value), e.value = "", a.value?.();
  }
  async function h() {
    l.value = null, i.value = "", await d();
  }
  return {
    // states
    currentActiveIcdDatabaseName: e,
    selectedSied: l,
    selectedLnodeId: i,
    // actions
    importIcdFile: o,
    resetSelection: h,
    setupFileDialog: s,
    loadIcdFileInMemory: f
  };
}), io = /* @__PURE__ */ lo("s-ied-implementation/global", () => {
  const e = Fe(""), l = _e(
    () => e.value ? bd({ databaseName: e.value, version: Cc }) : null
  ), i = _e(() => {
    const s = Ds(), { currentActiveIcdDatabaseName: o } = Lt(s);
    return o.value ? bd({ databaseName: o.value, version: Cc }) : null;
  });
  async function a(s) {
    e.value = s;
  }
  return {
    // states
    activeFilename: e,
    // getters
    sdkInstance: l,
    icdSdkInstance: i,
    // actions
    initApp: a
  };
});
function kd(e) {
  return typeof e == "string" ? `'${e}'` : new w0().serialize(e);
}
const w0 = /* @__PURE__ */ function() {
  class e {
    #e = /* @__PURE__ */ new Map();
    compare(i, a) {
      const s = typeof i, o = typeof a;
      return s === "string" && o === "string" ? i.localeCompare(a) : s === "number" && o === "number" ? i - a : String.prototype.localeCompare.call(this.serialize(i, !0), this.serialize(a, !0));
    }
    serialize(i, a) {
      if (i === null) return "null";
      switch (typeof i) {
        case "string":
          return a ? i : `'${i}'`;
        case "bigint":
          return `${i}n`;
        case "object":
          return this.$object(i);
        case "function":
          return this.$function(i);
      }
      return String(i);
    }
    serializeObject(i) {
      const a = Object.prototype.toString.call(i);
      if (a !== "[object Object]") return this.serializeBuiltInType(a.length < 10 ? `unknown:${a}` : a.slice(8, -1), i);
      const s = i.constructor, o = s === Object || s === void 0 ? "" : s.name;
      if (o !== "" && globalThis[o] === s) return this.serializeBuiltInType(o, i);
      if (typeof i.toJSON == "function") {
        const f = i.toJSON();
        return o + (f !== null && typeof f == "object" ? this.$object(f) : `(${this.serialize(f)})`);
      }
      return this.serializeObjectEntries(o, Object.entries(i));
    }
    serializeBuiltInType(i, a) {
      const s = this["$" + i];
      if (s) return s.call(this, a);
      if (typeof a?.entries == "function") return this.serializeObjectEntries(i, a.entries());
      throw new Error(`Cannot serialize ${i}`);
    }
    serializeObjectEntries(i, a) {
      const s = Array.from(a).sort((f, d) => this.compare(f[0], d[0]));
      let o = `${i}{`;
      for (let f = 0; f < s.length; f++) {
        const [d, h] = s[f];
        o += `${this.serialize(d, !0)}:${this.serialize(h)}`, f < s.length - 1 && (o += ",");
      }
      return o + "}";
    }
    $object(i) {
      let a = this.#e.get(i);
      return a === void 0 && (this.#e.set(i, `#${this.#e.size}`), a = this.serializeObject(i), this.#e.set(i, a)), a;
    }
    $function(i) {
      const a = Function.prototype.toString.call(i);
      return a.slice(-15) === "[native code] }" ? `${i.name || ""}()[native]` : `${i.name}(${i.length})${a.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(i) {
      let a = "[";
      for (let s = 0; s < i.length; s++) a += this.serialize(i[s]), s < i.length - 1 && (a += ",");
      return a + "]";
    }
    $Date(i) {
      try {
        return `Date(${i.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(i) {
      return `ArrayBuffer[${new Uint8Array(i).join(",")}]`;
    }
    $Set(i) {
      return `Set${this.$Array(Array.from(i).sort((a, s) => this.compare(a, s)))}`;
    }
    $Map(i) {
      return this.serializeObjectEntries("Map", i.entries());
    }
  }
  for (const l of ["Error", "RegExp", "URL"]) e.prototype["$" + l] = function(i) {
    return `${l}(${i})`;
  };
  for (const l of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) e.prototype["$" + l] = function(i) {
    return `${l}[${i.join(",")}]`;
  };
  for (const l of ["BigInt64Array", "BigUint64Array"]) e.prototype["$" + l] = function(i) {
    return `${l}[${i.join("n,")}${i.length > 0 ? "n" : ""}]`;
  };
  return e;
}();
function qm(e, l) {
  return e === l || kd(e) === kd(l);
}
function S0(e, l) {
  if (e.length !== l.length) return !1;
  for (let i = 0; i < e.length; i++) if (e[i] !== l[i]) return !1;
  return !0;
}
function rc(e, l, i) {
  const a = e.findIndex((d) => qm(d, l)), s = e.findIndex((d) => qm(d, i));
  if (a === -1 || s === -1) return [];
  const [o, f] = [a, s].sort((d, h) => d - h);
  return e.slice(o, f + 1);
}
const Os = typeof document < "u";
function vi(e, l) {
  const i = typeof e == "string" && !l ? `${e}Context` : l, a = Symbol(i);
  return [(f) => {
    const d = Fi(a, f);
    if (d || d === null) return d;
    throw new Error(`Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`);
  }, (f) => (Yc(a, f), f)];
}
function Za() {
  let e = document.activeElement;
  if (e == null) return null;
  for (; e != null && e.shadowRoot != null && e.shadowRoot.activeElement != null; ) e = e.shadowRoot.activeElement;
  return e;
}
function rs(e, l, i) {
  const a = i.originalEvent.target, s = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: i
  });
  l && a.addEventListener(e, l, { once: !0 }), a.dispatchEvent(s);
}
function If(e) {
  return e ? e.flatMap((l) => l.type === Mn ? If(l.children) : [l]) : [];
}
const [uo, $C] = vi("ConfigProvider");
function C0(e, l) {
  var i;
  const a = Fl();
  return Ml(() => {
    a.value = e();
  }, {
    ...l,
    flush: (i = void 0) != null ? i : "sync"
  }), Bi(a);
}
function ao(e) {
  return $i() ? (ca(e), !0) : !1;
}
function Wr() {
  const e = /* @__PURE__ */ new Set(), l = (o) => {
    e.delete(o);
  };
  return {
    on: (o) => {
      e.add(o);
      const f = () => l(o);
      return ao(f), {
        off: f
      };
    },
    off: l,
    trigger: (...o) => Promise.all(Array.from(e).map((f) => f(...o))),
    clear: () => {
      e.clear();
    }
  };
}
function T0(e) {
  let l = 0, i, a;
  const s = () => {
    l -= 1, a && l <= 0 && (a.stop(), i = void 0, a = void 0);
  };
  return (...o) => (l += 1, a || (a = Bc(!0), i = a.run(() => e(...o))), ao(s), i);
}
const Wa = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const P0 = (e) => typeof e < "u", q0 = Object.prototype.toString, R0 = (e) => q0.call(e) === "[object Object]", Vd = /* @__PURE__ */ A0();
function A0() {
  var e, l;
  return Wa && ((e = window?.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((l = window?.navigator) == null ? void 0 : l.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function E0(e) {
  return Xn();
}
function _o(e) {
  return Array.isArray(e) ? e : [e];
}
function jg(e, l = 1e4) {
  return ja((i, a) => {
    let s = hn(e), o;
    const f = () => setTimeout(() => {
      s = hn(e), a();
    }, hn(l));
    return ao(() => {
      clearTimeout(o);
    }), {
      get() {
        return i(), s;
      },
      set(d) {
        s = d, a(), clearTimeout(o), o = f();
      }
    };
  });
}
const _0 = hn;
function N0(e, l) {
  E0() && vs(e, l);
}
function F0(e, l, i) {
  return Cn(
    e,
    l,
    {
      ...i,
      immediate: !0
    }
  );
}
const Lf = Wa ? window : void 0;
function ma(e) {
  var l;
  const i = hn(e);
  return (l = i?.$el) != null ? l : i;
}
function Hg(...e) {
  const l = [], i = () => {
    l.forEach((d) => d()), l.length = 0;
  }, a = (d, h, x, y) => (d.addEventListener(h, x, y), () => d.removeEventListener(h, x, y)), s = _e(() => {
    const d = _o(hn(e[0])).filter((h) => h != null);
    return d.every((h) => typeof h != "string") ? d : void 0;
  }), o = F0(
    () => {
      var d, h;
      return [
        (h = (d = s.value) == null ? void 0 : d.map((x) => ma(x))) != null ? h : [Lf].filter((x) => x != null),
        _o(hn(s.value ? e[1] : e[0])),
        _o(te(s.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        hn(s.value ? e[3] : e[2])
      ];
    },
    ([d, h, x, y]) => {
      if (i(), !d?.length || !h?.length || !x?.length)
        return;
      const I = R0(y) ? { ...y } : y;
      l.push(
        ...d.flatMap(
          (q) => h.flatMap(
            (R) => x.map((E) => a(q, R, E, I))
          )
        )
      );
    },
    { flush: "post" }
  ), f = () => {
    o(), i();
  };
  return ao(i), f;
}
function M0(e) {
  return typeof e == "function" ? e : typeof e == "string" ? (l) => l.key === e : Array.isArray(e) ? (l) => e.includes(l.key) : () => !0;
}
function k0(...e) {
  let l, i, a = {};
  e.length === 3 ? (l = e[0], i = e[1], a = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (l = !0, i = e[0], a = e[1]) : (l = e[0], i = e[1]) : (l = !0, i = e[0]);
  const {
    target: s = Lf,
    eventName: o = "keydown",
    passive: f = !1,
    dedupe: d = !1
  } = a, h = M0(l);
  return Hg(s, o, (y) => {
    y.repeat && hn(d) || h(y) && i(y);
  }, f);
}
function V0(e) {
  return JSON.parse(JSON.stringify(e));
}
function Gu(e, l, i, a = {}) {
  var s, o, f;
  const {
    clone: d = !1,
    passive: h = !1,
    eventName: x,
    deep: y = !1,
    defaultValue: I,
    shouldEmit: q
  } = a, R = Xn(), E = i || R?.emit || ((s = R?.$emit) == null ? void 0 : s.bind(R)) || ((f = (o = R?.proxy) == null ? void 0 : o.$emit) == null ? void 0 : f.bind(R?.proxy));
  let M = x;
  l || (l = "modelValue"), M = M || `update:${l.toString()}`;
  const U = (B) => d ? typeof d == "function" ? d(B) : V0(B) : B, z = () => P0(e[l]) ? U(e[l]) : I, X = (B) => {
    q ? q(B) && E(M, B) : E(M, B);
  };
  if (h) {
    const B = z(), K = Fe(B);
    let W = !1;
    return Cn(
      () => e[l],
      (ae) => {
        W || (W = !0, K.value = U(ae), il(() => W = !1));
      }
    ), Cn(
      K,
      (ae) => {
        !W && (ae !== e[l] || y) && X(ae);
      },
      { deep: y }
    ), K;
  } else
    return _e({
      get() {
        return z();
      },
      set(B) {
        X(B);
      }
    });
}
function No(e) {
  if (e === null || typeof e != "object")
    return !1;
  const l = Object.getPrototypeOf(e);
  return l !== null && l !== Object.prototype && Object.getPrototypeOf(l) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0;
}
function Rm(e, l, i = ".", a) {
  if (!No(l))
    return Rm(e, {}, i, a);
  const s = Object.assign({}, l);
  for (const o in e) {
    if (o === "__proto__" || o === "constructor")
      continue;
    const f = e[o];
    f != null && (a && a(s, o, f, i) || (Array.isArray(f) && Array.isArray(s[o]) ? s[o] = [...f, ...s[o]] : No(f) && No(s[o]) ? s[o] = Rm(
      f,
      s[o],
      (i ? `${i}.` : "") + o.toString(),
      a
    ) : s[o] = f));
  }
  return s;
}
function B0(e) {
  return (...l) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    l.reduce((i, a) => Rm(i, a, "", e), {})
  );
}
const Z0 = B0(), U0 = T0(() => {
  const e = Fe(/* @__PURE__ */ new Map()), l = Fe(), i = _e(() => {
    for (const f of e.value.values()) if (f) return !0;
    return !1;
  }), a = uo({ scrollBody: Fe(!0) });
  let s = null;
  const o = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.documentElement.style.removeProperty("--scrollbar-width"), document.body.style.overflow = l.value ?? "", Vd && s?.(), l.value = void 0;
  };
  return Cn(i, (f, d) => {
    if (!Wa) return;
    if (!f) {
      d && o();
      return;
    }
    l.value === void 0 && (l.value = document.body.style.overflow);
    const h = window.innerWidth - document.documentElement.clientWidth, x = {
      padding: h,
      margin: 0
    }, y = a.scrollBody?.value ? typeof a.scrollBody.value == "object" ? Z0({
      padding: a.scrollBody.value.padding === !0 ? h : a.scrollBody.value.padding,
      margin: a.scrollBody.value.margin === !0 ? h : a.scrollBody.value.margin
    }, x) : x : {
      padding: 0,
      margin: 0
    };
    h > 0 && (document.body.style.paddingRight = typeof y.padding == "number" ? `${y.padding}px` : String(y.padding), document.body.style.marginRight = typeof y.margin == "number" ? `${y.margin}px` : String(y.margin), document.documentElement.style.setProperty("--scrollbar-width", `${h}px`), document.body.style.overflow = "hidden"), Vd && (s = Hg(document, "touchmove", (I) => G0(I), { passive: !1 })), il(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }, {
    immediate: !0,
    flush: "sync"
  }), e;
});
function K0(e) {
  const l = Math.random().toString(36).substring(2, 7), i = U0();
  i.value.set(l, e ?? !1);
  const a = _e({
    get: () => i.value.get(l) ?? !1,
    set: (s) => i.value.set(l, s)
  });
  return N0(() => {
    i.value.delete(l);
  }), a;
}
function $g(e) {
  const l = window.getComputedStyle(e);
  if (l.overflowX === "scroll" || l.overflowY === "scroll" || l.overflowX === "auto" && e.clientWidth < e.scrollWidth || l.overflowY === "auto" && e.clientHeight < e.scrollHeight) return !0;
  {
    const i = e.parentNode;
    return !(i instanceof Element) || i.tagName === "BODY" ? !1 : $g(i);
  }
}
function G0(e) {
  const l = e || window.event, i = l.target;
  return i instanceof Element && $g(i) ? !1 : l.touches.length > 1 ? !0 : (l.preventDefault && l.cancelable && l.preventDefault(), !1);
}
function bs(e) {
  const l = uo({ dir: Fe("ltr") });
  return _e(() => e?.value || l.dir?.value || "ltr");
}
function z0(e) {
  const l = Xn(), i = l?.type.emits, a = {};
  return i?.length || console.warn(`No emitted event found. Please check component: ${l?.type.__name}`), i?.forEach((s) => {
    a[qa(gl(s))] = (...o) => e(s, ...o);
  }), a;
}
function j0(e) {
  const l = _e(() => te(e)), i = _e(() => new Intl.Collator("en", {
    usage: "search",
    ...l.value
  }));
  return {
    startsWith: (f, d) => d.length === 0 ? !0 : (f = f.normalize("NFC"), d = d.normalize("NFC"), i.value.compare(f.slice(0, d.length), d) === 0),
    endsWith: (f, d) => d.length === 0 ? !0 : (f = f.normalize("NFC"), d = d.normalize("NFC"), i.value.compare(f.slice(-d.length), d) === 0),
    contains: (f, d) => {
      if (d.length === 0) return !0;
      f = f.normalize("NFC"), d = d.normalize("NFC");
      let h = 0;
      const x = d.length;
      for (; h + x <= f.length; h++) {
        const y = f.slice(h, h + x);
        if (i.value.compare(d, y) === 0) return !0;
      }
      return !1;
    }
  };
}
function H0(e) {
  return _e(() => _0(e) ? !!ma(e)?.closest("form") : !0);
}
function Tt() {
  const e = Xn(), l = Fe(), i = _e(() => ["#text", "#comment"].includes(l.value?.$el.nodeName) ? l.value?.$el.nextElementSibling : ma(l)), a = Object.assign({}, e.exposed), s = {};
  for (const f in e.props) Object.defineProperty(s, f, {
    enumerable: !0,
    configurable: !0,
    get: () => e.props[f]
  });
  if (Object.keys(a).length > 0) for (const f in a) Object.defineProperty(s, f, {
    enumerable: !0,
    configurable: !0,
    get: () => a[f]
  });
  Object.defineProperty(s, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => e.vnode.el
  }), e.exposed = s;
  function o(f) {
    l.value = f, f && (Object.defineProperty(s, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => f instanceof Element ? f : f.$el
    }), e.exposed = s);
  }
  return {
    forwardRef: o,
    currentRef: l,
    currentElement: i
  };
}
function Wg(e) {
  const l = Xn(), i = Object.keys(l?.type.props ?? {}).reduce((s, o) => {
    const f = (l?.type.props[o]).default;
    return f !== void 0 && (s[o] = f), s;
  }, {}), a = hs(e);
  return _e(() => {
    const s = {}, o = l?.vnode.props ?? {};
    return Object.keys(o).forEach((f) => {
      s[gl(f)] = o[f];
    }), Object.keys({
      ...i,
      ...s
    }).reduce((f, d) => (a.value[d] !== void 0 && (f[d] = a.value[d]), f), {});
  });
}
function $0(e, l) {
  const i = Wg(e), a = l ? z0(l) : {};
  return _e(() => ({
    ...i.value,
    ...a
  }));
}
var W0 = function(e) {
  if (typeof document > "u")
    return null;
  var l = Array.isArray(e) ? e[0] : e;
  return l.ownerDocument.body;
}, ya = /* @__PURE__ */ new WeakMap(), Us = /* @__PURE__ */ new WeakMap(), Ks = {}, Fo = 0, Yg = function(e) {
  return e && (e.host || Yg(e.parentNode));
}, Y0 = function(e, l) {
  return l.map(function(i) {
    if (e.contains(i))
      return i;
    var a = Yg(i);
    return a && e.contains(a) ? a : (console.error("aria-hidden", i, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(i) {
    return !!i;
  });
}, X0 = function(e, l, i, a) {
  var s = Y0(l, Array.isArray(e) ? e : [e]);
  Ks[i] || (Ks[i] = /* @__PURE__ */ new WeakMap());
  var o = Ks[i], f = [], d = /* @__PURE__ */ new Set(), h = new Set(s), x = function(I) {
    !I || d.has(I) || (d.add(I), x(I.parentNode));
  };
  s.forEach(x);
  var y = function(I) {
    !I || h.has(I) || Array.prototype.forEach.call(I.children, function(q) {
      if (d.has(q))
        y(q);
      else
        try {
          var R = q.getAttribute(a), E = R !== null && R !== "false", M = (ya.get(q) || 0) + 1, U = (o.get(q) || 0) + 1;
          ya.set(q, M), o.set(q, U), f.push(q), M === 1 && E && Us.set(q, !0), U === 1 && q.setAttribute(i, "true"), E || q.setAttribute(a, "true");
        } catch (z) {
          console.error("aria-hidden: cannot operate on ", q, z);
        }
    });
  };
  return y(l), d.clear(), Fo++, function() {
    f.forEach(function(I) {
      var q = ya.get(I) - 1, R = o.get(I) - 1;
      ya.set(I, q), o.set(I, R), q || (Us.has(I) || I.removeAttribute(a), Us.delete(I)), R || I.removeAttribute(i);
    }), Fo--, Fo || (ya = /* @__PURE__ */ new WeakMap(), ya = /* @__PURE__ */ new WeakMap(), Us = /* @__PURE__ */ new WeakMap(), Ks = {});
  };
}, Q0 = function(e, l, i) {
  i === void 0 && (i = "data-aria-hidden");
  var a = Array.from(Array.isArray(e) ? e : [e]), s = W0(e);
  return s ? (a.push.apply(a, Array.from(s.querySelectorAll("[aria-live], script"))), X0(a, s, i, "aria-hidden")) : function() {
    return null;
  };
};
function J0(e) {
  let l;
  Cn(() => ma(e), (i) => {
    i ? l = Q0(i) : l && l();
  }), Dt(() => {
    l && l();
  });
}
let eO = 0;
function fa(e, l = "reka") {
  if (e) return e;
  if ("useId" in uL) return `${l}-${mh?.()}`;
  const i = uo({ useId: void 0 });
  return i.useId ? `${l}-${i.useId()}` : `${l}-${++eO}`;
}
function nO() {
  return {
    ALT: "Alt",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    ARROW_UP: "ArrowUp",
    BACKSPACE: "Backspace",
    CAPS_LOCK: "CapsLock",
    CONTROL: "Control",
    DELETE: "Delete",
    END: "End",
    ENTER: "Enter",
    ESCAPE: "Escape",
    F1: "F1",
    F10: "F10",
    F11: "F11",
    F12: "F12",
    F2: "F2",
    F3: "F3",
    F4: "F4",
    F5: "F5",
    F6: "F6",
    F7: "F7",
    F8: "F8",
    F9: "F9",
    HOME: "Home",
    META: "Meta",
    PAGE_DOWN: "PageDown",
    PAGE_UP: "PageUp",
    SHIFT: "Shift",
    SPACE: " ",
    TAB: "Tab",
    CTRL: "Control",
    ASTERISK: "*",
    SPACE_CODE: "Space"
  };
}
function lO(e, l) {
  const i = Fe(), a = (o, f) => {
    if (l.multiple && Array.isArray(e.value)) if (l.selectionBehavior === "replace")
      e.value = [o], i.value = o;
    else {
      const d = e.value.findIndex((h) => f(h));
      d !== -1 ? e.value = e.value.filter((h, x) => x !== d) : e.value = [...e.value, o];
    }
    else l.selectionBehavior === "replace" ? e.value = { ...o } : !Array.isArray(e.value) && f(e.value) ? e.value = void 0 : e.value = { ...o };
    return e.value;
  };
  function s(o, f, d, h) {
    if (!i?.value || !l.multiple || !Array.isArray(e.value)) return;
    const y = d().filter((q) => q.ref.dataset.disabled !== "").find((q) => q.ref === f)?.value;
    if (!y) return;
    let I = null;
    switch (o) {
      case "prev":
      case "next": {
        I = rc(h, i.value, y);
        break;
      }
      case "first": {
        I = rc(h, i.value, h?.[0]);
        break;
      }
      case "last": {
        I = rc(h, i.value, h?.[h.length - 1]);
        break;
      }
    }
    e.value = I;
  }
  return {
    firstValue: i,
    onSelectItem: a,
    handleMultipleReplace: s
  };
}
function tO(e) {
  const l = Fe(), i = _e(() => l.value?.width ?? 0), a = _e(() => l.value?.height ?? 0);
  return vl(() => {
    const s = ma(e);
    if (s) {
      l.value = {
        width: s.offsetWidth,
        height: s.offsetHeight
      };
      const o = new ResizeObserver((f) => {
        if (!Array.isArray(f) || !f.length) return;
        const d = f[0];
        let h, x;
        if ("borderBoxSize" in d) {
          const y = d.borderBoxSize, I = Array.isArray(y) ? y[0] : y;
          h = I.inlineSize, x = I.blockSize;
        } else
          h = s.offsetWidth, x = s.offsetHeight;
        l.value = {
          width: h,
          height: x
        };
      });
      return o.observe(s, { box: "border-box" }), () => o.unobserve(s);
    } else l.value = void 0;
  }), {
    width: i,
    height: a
  };
}
function iO(e, l) {
  const i = Fe(e);
  function a(o) {
    return l[i.value][o] ?? i.value;
  }
  return {
    state: i,
    dispatch: (o) => {
      i.value = a(o);
    }
  };
}
function Xg(e) {
  const l = jg("", 1e3);
  return {
    search: l,
    handleTypeaheadSearch: (s, o) => {
      l.value = l.value + s;
      {
        const f = Za(), d = o.map((q) => ({
          ...q,
          textValue: q.value?.textValue ?? q.ref.textContent?.trim() ?? ""
        })), h = d.find((q) => q.ref === f), x = d.map((q) => q.textValue), y = aO(x, l.value, h?.textValue), I = d.find((q) => q.textValue === y);
        return I && I.ref.focus(), I?.ref;
      }
    },
    resetTypeahead: () => {
      l.value = "";
    }
  };
}
function uO(e, l) {
  return e.map((i, a) => e[(l + a) % e.length]);
}
function aO(e, l, i) {
  const s = l.length > 1 && Array.from(l).every((x) => x === l[0]) ? l[0] : l, o = i ? e.indexOf(i) : -1;
  let f = uO(e, Math.max(o, 0));
  s.length === 1 && (f = f.filter((x) => x !== i));
  const h = f.find((x) => x.toLowerCase().startsWith(s.toLowerCase()));
  return h !== i ? h : void 0;
}
function rO(e, l) {
  const i = Fe({}), a = Fe("none"), s = Fe(e), o = e.value ? "mounted" : "unmounted";
  let f;
  const d = l.value?.ownerDocument.defaultView ?? Lf, { state: h, dispatch: x } = iO(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: { MOUNT: "mounted" }
  }), y = (U) => {
    if (Wa) {
      const z = new CustomEvent(U, {
        bubbles: !1,
        cancelable: !1
      });
      l.value?.dispatchEvent(z);
    }
  };
  Cn(e, async (U, z) => {
    const X = z !== U;
    if (await il(), X) {
      const B = a.value, K = Gs(l.value);
      U ? (x("MOUNT"), y("enter"), K === "none" && y("after-enter")) : K === "none" || K === "undefined" || i.value?.display === "none" ? (x("UNMOUNT"), y("leave"), y("after-leave")) : z && B !== K ? (x("ANIMATION_OUT"), y("leave")) : (x("UNMOUNT"), y("after-leave"));
    }
  }, { immediate: !0 });
  const I = (U) => {
    const z = Gs(l.value), X = z.includes(CSS.escape(U.animationName)), B = h.value === "mounted" ? "enter" : "leave";
    if (U.target === l.value && X && (y(`after-${B}`), x("ANIMATION_END"), !s.value)) {
      const K = l.value.style.animationFillMode;
      l.value.style.animationFillMode = "forwards", f = d?.setTimeout(() => {
        l.value?.style.animationFillMode === "forwards" && (l.value.style.animationFillMode = K);
      });
    }
    U.target === l.value && z === "none" && x("ANIMATION_END");
  }, q = (U) => {
    U.target === l.value && (a.value = Gs(l.value));
  }, R = Cn(l, (U, z) => {
    U ? (i.value = getComputedStyle(U), U.addEventListener("animationstart", q), U.addEventListener("animationcancel", I), U.addEventListener("animationend", I)) : (x("ANIMATION_END"), f !== void 0 && d?.clearTimeout(f), z?.removeEventListener("animationstart", q), z?.removeEventListener("animationcancel", I), z?.removeEventListener("animationend", I));
  }, { immediate: !0 }), E = Cn(h, () => {
    const U = Gs(l.value);
    a.value = h.value === "mounted" ? U : "none";
  });
  return Dt(() => {
    R(), E();
  }), { isPresent: _e(() => ["mounted", "unmountSuspended"].includes(h.value)) };
}
function Gs(e) {
  return e && getComputedStyle(e).animationName || "none";
}
var sO = /* @__PURE__ */ dn({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: { type: Boolean }
  },
  slots: {},
  setup(e, { slots: l, expose: i }) {
    const { present: a, forceMount: s } = St(e), o = Fe(), { isPresent: f } = rO(a, o);
    i({ present: f });
    let d = l.default({ present: f.value });
    d = If(d || []);
    const h = Xn();
    if (d && d?.length > 1) {
      const x = h?.parent?.type.name ? `<${h.parent.type.name} />` : "component";
      throw new Error([
        `Detected an invalid children for \`${x}\` for  \`Presence\` component.`,
        "",
        "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
        "You can apply a few solutions:",
        ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map((y) => `  - ${y}`).join(`
`)
      ].join(`
`));
    }
    return () => s.value || a.value || f.value ? gt(l.default({ present: f.value })[0], { ref: (x) => {
      const y = ma(x);
      return typeof y?.hasAttribute > "u" || (y?.hasAttribute("data-reka-popper-content-wrapper") ? o.value = y.firstElementChild : o.value = y), y;
    } }) : null;
  }
});
const Am = /* @__PURE__ */ dn({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(e, { attrs: l, slots: i }) {
    return () => {
      if (!i.default) return null;
      const a = If(i.default()), s = a.findIndex((h) => h.type !== ul);
      if (s === -1) return a;
      const o = a[s];
      delete o.props?.ref;
      const f = o.props ? pl(l, o.props) : l, d = di({
        ...o,
        props: {}
      }, f);
      return a.length === 1 ? d : (a[s] = d, a);
    };
  }
}), cO = [
  "area",
  "img",
  "input"
], al = /* @__PURE__ */ dn({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(e, { attrs: l, slots: i }) {
    const a = e.asChild ? "template" : e.as;
    return typeof a == "string" && cO.includes(a) ? () => gt(a, l) : a !== "template" ? () => gt(e.as, l, { default: i.default }) : () => gt(Am, l, { default: i.default });
  }
});
function zu() {
  const e = Fe(), l = _e(() => ["#text", "#comment"].includes(e.value?.$el.nodeName) ? e.value?.$el.nextElementSibling : ma(e));
  return {
    primitiveElement: e,
    currentElement: l
  };
}
const oO = "dismissableLayer.pointerDownOutside", mO = "dismissableLayer.focusOutside";
function Qg(e, l) {
  const i = l.closest("[data-dismissable-layer]"), a = e.dataset.dismissableLayer === "" ? e : e.querySelector("[data-dismissable-layer]"), s = Array.from(e.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
  return !!(i && (a === i || s.indexOf(a) < s.indexOf(i)));
}
function fO(e, l, i = !0) {
  const a = l?.value?.ownerDocument ?? globalThis?.document, s = Fe(!1), o = Fe(() => {
  });
  return Ml((f) => {
    if (!Wa || !hn(i)) return;
    const d = async (x) => {
      const y = x.target;
      if (!(!l?.value || !y)) {
        if (Qg(l.value, y)) {
          s.value = !1;
          return;
        }
        if (x.target && !s.value) {
          let q = function() {
            rs(oO, e, I);
          };
          const I = { originalEvent: x };
          x.pointerType === "touch" ? (a.removeEventListener("click", o.value), o.value = q, a.addEventListener("click", o.value, { once: !0 })) : q();
        } else a.removeEventListener("click", o.value);
        s.value = !1;
      }
    }, h = window.setTimeout(() => {
      a.addEventListener("pointerdown", d);
    }, 0);
    f(() => {
      window.clearTimeout(h), a.removeEventListener("pointerdown", d), a.removeEventListener("click", o.value);
    });
  }), { onPointerDownCapture: () => {
    hn(i) && (s.value = !0);
  } };
}
function dO(e, l, i = !0) {
  const a = l?.value?.ownerDocument ?? globalThis?.document, s = Fe(!1);
  return Ml((o) => {
    if (!Wa || !hn(i)) return;
    const f = async (d) => {
      if (!l?.value) return;
      await il(), await il();
      const h = d.target;
      !l.value || !h || Qg(l.value, h) || d.target && !s.value && rs(mO, e, { originalEvent: d });
    };
    a.addEventListener("focusin", f), o(() => a.removeEventListener("focusin", f));
  }), {
    onFocusCapture: () => {
      hn(i) && (s.value = !0);
    },
    onBlurCapture: () => {
      hn(i) && (s.value = !1);
    }
  };
}
const Ti = Ga({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var pO = /* @__PURE__ */ dn({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "dismiss"
  ],
  setup(e, { emit: l }) {
    const i = e, a = l, { forwardRef: s, currentElement: o } = Tt(), f = _e(() => o.value?.ownerDocument ?? globalThis.document), d = _e(() => Ti.layersRoot), h = _e(() => o.value ? Array.from(d.value).indexOf(o.value) : -1), x = _e(() => Ti.layersWithOutsidePointerEventsDisabled.size > 0), y = _e(() => {
      const E = Array.from(d.value), [M] = [...Ti.layersWithOutsidePointerEventsDisabled].slice(-1), U = E.indexOf(M);
      return h.value >= U;
    }), I = fO(async (E) => {
      const M = [...Ti.branches].some((U) => U?.contains(E.target));
      !y.value || M || (a("pointerDownOutside", E), a("interactOutside", E), await il(), E.defaultPrevented || a("dismiss"));
    }, o), q = dO((E) => {
      [...Ti.branches].some((U) => U?.contains(E.target)) || (a("focusOutside", E), a("interactOutside", E), E.defaultPrevented || a("dismiss"));
    }, o);
    k0("Escape", (E) => {
      h.value === d.value.size - 1 && (a("escapeKeyDown", E), E.defaultPrevented || a("dismiss"));
    });
    let R;
    return Ml((E) => {
      o.value && (i.disableOutsidePointerEvents && (Ti.layersWithOutsidePointerEventsDisabled.size === 0 && (R = f.value.body.style.pointerEvents, f.value.body.style.pointerEvents = "none"), Ti.layersWithOutsidePointerEventsDisabled.add(o.value)), d.value.add(o.value), E(() => {
        i.disableOutsidePointerEvents && Ti.layersWithOutsidePointerEventsDisabled.size === 1 && (f.value.body.style.pointerEvents = R);
      }));
    }), Ml((E) => {
      E(() => {
        o.value && (d.value.delete(o.value), Ti.layersWithOutsidePointerEventsDisabled.delete(o.value));
      });
    }), (E, M) => (Ye(), xn(te(al), {
      ref: te(s),
      "as-child": E.asChild,
      as: E.as,
      "data-dismissable-layer": "",
      style: Hi({ pointerEvents: x.value ? y.value ? "auto" : "none" : void 0 }),
      onFocusCapture: te(q).onFocusCapture,
      onBlurCapture: te(q).onBlurCapture,
      onPointerdownCapture: te(I).onPointerDownCapture
    }, {
      default: ln(() => [qn(E.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "style",
      "onFocusCapture",
      "onBlurCapture",
      "onPointerdownCapture"
    ]));
  }
}), hO = pO;
const Bd = "data-reka-collection-item";
function Ya(e = {}) {
  const { key: l = "", isProvider: i = !1 } = e, a = `${l}CollectionProvider`;
  let s;
  if (i) {
    const y = Fe(/* @__PURE__ */ new Map());
    s = {
      collectionRef: Fe(),
      itemMap: y
    }, Yc(a, s);
  } else s = Fi(a);
  const o = (y = !1) => {
    const I = s.collectionRef.value;
    if (!I) return [];
    const q = Array.from(I.querySelectorAll(`[${Bd}]`)), E = Array.from(s.itemMap.value.values()).sort((M, U) => q.indexOf(M.ref) - q.indexOf(U.ref));
    return y ? E : E.filter((M) => M.ref.dataset.disabled !== "");
  }, f = /* @__PURE__ */ dn({
    name: "CollectionSlot",
    setup(y, { slots: I }) {
      const { primitiveElement: q, currentElement: R } = zu();
      return Cn(R, () => {
        s.collectionRef.value = R.value;
      }), () => gt(Am, { ref: q }, I);
    }
  }), d = /* @__PURE__ */ dn({
    name: "CollectionItem",
    inheritAttrs: !1,
    props: { value: { validator: () => !0 } },
    setup(y, { slots: I, attrs: q }) {
      const { primitiveElement: R, currentElement: E } = zu();
      return Ml((M) => {
        if (E.value) {
          const U = za(E.value);
          s.itemMap.value.set(U, {
            ref: E.value,
            value: y.value
          }), M(() => s.itemMap.value.delete(U));
        }
      }), () => gt(Am, {
        ...q,
        [Bd]: "",
        ref: R
      }, I);
    }
  }), h = _e(() => Array.from(s.itemMap.value.values())), x = _e(() => s.itemMap.value.size);
  return {
    getItems: o,
    reactiveItems: h,
    itemMapSize: x,
    CollectionSlot: f,
    CollectionItem: d
  };
}
const gO = "rovingFocusGroup.onEntryFocus", vO = {
  bubbles: !1,
  cancelable: !0
}, Jg = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function xO(e, l) {
  return l !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function ev(e, l, i) {
  const a = xO(e.key, i);
  if (!(l === "vertical" && ["ArrowLeft", "ArrowRight"].includes(a)) && !(l === "horizontal" && ["ArrowUp", "ArrowDown"].includes(a)))
    return Jg[a];
}
function nv(e, l = !1) {
  const i = Za();
  for (const a of e)
    if (a === i || (a.focus({ preventScroll: l }), Za() !== i)) return;
}
function yO(e, l) {
  return e.map((i, a) => e[(l + a) % e.length]);
}
const [IO, LO] = vi("RovingFocusGroup");
var DO = /* @__PURE__ */ dn({
  __name: "RovingFocusGroup",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    currentTabStopId: {
      type: [String, null],
      required: !1
    },
    defaultCurrentTabStopId: {
      type: String,
      required: !1
    },
    preventScrollOnEntryFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, { loop: o, orientation: f, dir: d } = St(a), h = bs(d), x = Gu(a, "currentTabStopId", s, {
      defaultValue: a.defaultCurrentTabStopId,
      passive: a.currentTabStopId === void 0
    }), y = Fe(!1), I = Fe(!1), q = Fe(0), { getItems: R, CollectionSlot: E } = Ya({ isProvider: !0 });
    function M(z) {
      const X = !I.value;
      if (z.currentTarget && z.target === z.currentTarget && X && !y.value) {
        const B = new CustomEvent(gO, vO);
        if (z.currentTarget.dispatchEvent(B), s("entryFocus", B), !B.defaultPrevented) {
          const K = R().map((k) => k.ref).filter((k) => k.dataset.disabled !== ""), W = K.find((k) => k.getAttribute("data-active") === ""), ae = K.find((k) => k.getAttribute("data-highlighted") === ""), ne = K.find((k) => k.id === x.value), oe = [
            W,
            ae,
            ne,
            ...K
          ].filter(Boolean);
          nv(oe, a.preventScrollOnEntryFocus);
        }
      }
      I.value = !1;
    }
    function U() {
      setTimeout(() => {
        I.value = !1;
      }, 1);
    }
    return l({ getItems: R }), LO({
      loop: o,
      dir: h,
      orientation: f,
      currentTabStopId: x,
      onItemFocus: (z) => {
        x.value = z;
      },
      onItemShiftTab: () => {
        y.value = !0;
      },
      onFocusableItemAdd: () => {
        q.value++;
      },
      onFocusableItemRemove: () => {
        q.value--;
      }
    }), (z, X) => (Ye(), xn(te(E), null, {
      default: ln(() => [ze(te(al), {
        tabindex: y.value || q.value === 0 ? -1 : 0,
        "data-orientation": te(f),
        as: z.as,
        "as-child": z.asChild,
        dir: te(h),
        style: { outline: "none" },
        onMousedown: X[0] || (X[0] = (B) => I.value = !0),
        onMouseup: U,
        onFocus: M,
        onBlur: X[1] || (X[1] = (B) => y.value = !1)
      }, {
        default: ln(() => [qn(z.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "as",
        "as-child",
        "dir"
      ])]),
      _: 3
    }));
  }
}), OO = DO, bO = /* @__PURE__ */ dn({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {
      type: String,
      required: !1
    },
    focusable: {
      type: Boolean,
      required: !1,
      default: !0
    },
    active: {
      type: Boolean,
      required: !1
    },
    allowShiftKey: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const l = e, i = IO(), a = fa(), s = _e(() => l.tabStopId || a), o = _e(() => i.currentTabStopId.value === s.value), { getItems: f, CollectionItem: d } = Ya();
    vl(() => {
      l.focusable && i.onFocusableItemAdd();
    }), Dt(() => {
      l.focusable && i.onFocusableItemRemove();
    });
    function h(x) {
      if (x.key === "Tab" && x.shiftKey) {
        i.onItemShiftTab();
        return;
      }
      if (x.target !== x.currentTarget) return;
      const y = ev(x, i.orientation.value, i.dir.value);
      if (y !== void 0) {
        if (x.metaKey || x.ctrlKey || x.altKey || !l.allowShiftKey && x.shiftKey) return;
        x.preventDefault();
        let I = [...f().map((q) => q.ref).filter((q) => q.dataset.disabled !== "")];
        if (y === "last") I.reverse();
        else if (y === "prev" || y === "next") {
          y === "prev" && I.reverse();
          const q = I.indexOf(x.currentTarget);
          I = i.loop.value ? yO(I, q + 1) : I.slice(q + 1);
        }
        il(() => nv(I));
      }
    }
    return (x, y) => (Ye(), xn(te(d), null, {
      default: ln(() => [ze(te(al), {
        tabindex: o.value ? 0 : -1,
        "data-orientation": te(i).orientation.value,
        "data-active": x.active ? "" : void 0,
        "data-disabled": x.focusable ? void 0 : "",
        as: x.as,
        "as-child": x.asChild,
        onMousedown: y[0] || (y[0] = (I) => {
          x.focusable ? te(i).onItemFocus(s.value) : I.preventDefault();
        }),
        onFocus: y[1] || (y[1] = (I) => te(i).onItemFocus(s.value)),
        onKeydown: h
      }, {
        default: ln(() => [qn(x.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "data-active",
        "data-disabled",
        "as",
        "as-child"
      ])]),
      _: 3
    }));
  }
}), wO = bO, SO = /* @__PURE__ */ dn({
  __name: "VisuallyHidden",
  props: {
    feature: {
      type: String,
      required: !1,
      default: "focusable"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return (l, i) => (Ye(), xn(te(al), {
      as: l.as,
      "as-child": l.asChild,
      "aria-hidden": l.feature === "focusable" ? "true" : void 0,
      "data-hidden": l.feature === "fully-hidden" ? "" : void 0,
      tabindex: l.feature === "fully-hidden" ? "-1" : void 0,
      style: {
        position: "absolute",
        border: 0,
        width: "1px",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        clipPath: "inset(50%)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        top: "-1px",
        left: "-1px"
      }
    }, {
      default: ln(() => [qn(l.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-hidden",
      "data-hidden",
      "tabindex"
    ]));
  }
}), CO = SO, TO = /* @__PURE__ */ dn({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInputBubble",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const l = e, { primitiveElement: i, currentElement: a } = zu(), s = _e(() => l.checked ?? l.value);
    return Cn(s, (o, f) => {
      if (!a.value) return;
      const d = a.value, h = window.HTMLInputElement.prototype, y = Object.getOwnPropertyDescriptor(h, "value").set;
      if (y && o !== f) {
        const I = new Event("input", { bubbles: !0 }), q = new Event("change", { bubbles: !0 });
        y.call(d, o), d.dispatchEvent(I), d.dispatchEvent(q);
      }
    }), (o, f) => (Ye(), xn(CO, pl({
      ref_key: "primitiveElement",
      ref: i
    }, {
      ...l,
      ...o.$attrs
    }, { as: "input" }), null, 16));
  }
}), Zd = TO, PO = /* @__PURE__ */ dn({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInput",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const l = e, i = _e(() => typeof l.value == "object" && Array.isArray(l.value) && l.value.length === 0 && l.required), a = _e(() => typeof l.value == "string" || typeof l.value == "number" || typeof l.value == "boolean" || l.value === null || l.value === void 0 ? [{
      name: l.name,
      value: l.value
    }] : typeof l.value == "object" && Array.isArray(l.value) ? l.value.flatMap((s, o) => typeof s == "object" ? Object.entries(s).map(([f, d]) => ({
      name: `${l.name}[${o}][${f}]`,
      value: d
    })) : {
      name: `${l.name}[${o}]`,
      value: s
    }) : l.value !== null && typeof l.value == "object" && !Array.isArray(l.value) ? Object.entries(l.value).map(([s, o]) => ({
      name: `${l.name}[${s}]`,
      value: o
    })) : []);
    return (s, o) => (Ye(), Yn(Mn, null, [pi(" We render single input if it's required "), i.value ? (Ye(), xn(Zd, pl({ key: s.name }, {
      ...l,
      ...s.$attrs
    }, {
      name: s.name,
      value: s.value
    }), null, 16, ["name", "value"])) : (Ye(!0), Yn(Mn, { key: 1 }, ys(a.value, (f) => (Ye(), xn(Zd, pl({ key: f.name }, { ref_for: !0 }, {
      ...l,
      ...s.$attrs
    }, {
      name: f.name,
      value: f.value
    }), null, 16, ["name", "value"]))), 128))], 2112));
  }
}), qO = PO;
const [lv, RO] = vi("PopperRoot");
var AO = /* @__PURE__ */ dn({
  inheritAttrs: !1,
  __name: "PopperRoot",
  setup(e) {
    const l = Fe();
    return RO({
      anchor: l,
      onAnchorChange: (i) => l.value = i
    }), (i, a) => qn(i.$slots, "default");
  }
}), EO = AO, _O = /* @__PURE__ */ dn({
  __name: "PopperAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const l = e, { forwardRef: i, currentElement: a } = Tt(), s = lv();
    return cf(() => {
      s.onAnchorChange(l.reference ?? a.value);
    }), (o, f) => (Ye(), xn(te(al), {
      ref: te(i),
      as: o.as,
      "as-child": o.asChild
    }, {
      default: ln(() => [qn(o.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), NO = _O;
function FO(e) {
  return e !== null;
}
function MO(e) {
  return {
    name: "transformOrigin",
    options: e,
    fn(l) {
      const { placement: i, rects: a, middlewareData: s } = l, f = s.arrow?.centerOffset !== 0, d = f ? 0 : e.arrowWidth, h = f ? 0 : e.arrowHeight, [x, y] = Em(i), I = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[y], q = (s.arrow?.x ?? 0) + d / 2, R = (s.arrow?.y ?? 0) + h / 2;
      let E = "", M = "";
      return x === "bottom" ? (E = f ? I : `${q}px`, M = `${-h}px`) : x === "top" ? (E = f ? I : `${q}px`, M = `${a.floating.height + h}px`) : x === "right" ? (E = `${-h}px`, M = f ? I : `${R}px`) : x === "left" && (E = `${a.floating.width + h}px`, M = f ? I : `${R}px`), { data: {
        x: E,
        y: M
      } };
    }
  };
}
function Em(e) {
  const [l, i = "center"] = e.split("-");
  return [l, i];
}
const kO = ["top", "right", "bottom", "left"], ju = Math.min, xt = Math.max, Pc = Math.round, zs = Math.floor, bi = (e) => ({
  x: e,
  y: e
}), VO = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, BO = {
  start: "end",
  end: "start"
};
function _m(e, l, i) {
  return xt(e, ju(l, i));
}
function zi(e, l) {
  return typeof e == "function" ? e(l) : e;
}
function ji(e) {
  return e.split("-")[0];
}
function Xa(e) {
  return e.split("-")[1];
}
function Df(e) {
  return e === "x" ? "y" : "x";
}
function Of(e) {
  return e === "y" ? "height" : "width";
}
const ZO = /* @__PURE__ */ new Set(["top", "bottom"]);
function Oi(e) {
  return ZO.has(ji(e)) ? "y" : "x";
}
function bf(e) {
  return Df(Oi(e));
}
function UO(e, l, i) {
  i === void 0 && (i = !1);
  const a = Xa(e), s = bf(e), o = Of(s);
  let f = s === "x" ? a === (i ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return l.reference[o] > l.floating[o] && (f = qc(f)), [f, qc(f)];
}
function KO(e) {
  const l = qc(e);
  return [Nm(e), l, Nm(l)];
}
function Nm(e) {
  return e.replace(/start|end/g, (l) => BO[l]);
}
const Ud = ["left", "right"], Kd = ["right", "left"], GO = ["top", "bottom"], zO = ["bottom", "top"];
function jO(e, l, i) {
  switch (e) {
    case "top":
    case "bottom":
      return i ? l ? Kd : Ud : l ? Ud : Kd;
    case "left":
    case "right":
      return l ? GO : zO;
    default:
      return [];
  }
}
function HO(e, l, i, a) {
  const s = Xa(e);
  let o = jO(ji(e), i === "start", a);
  return s && (o = o.map((f) => f + "-" + s), l && (o = o.concat(o.map(Nm)))), o;
}
function qc(e) {
  return e.replace(/left|right|bottom|top/g, (l) => VO[l]);
}
function $O(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function tv(e) {
  return typeof e != "number" ? $O(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Rc(e) {
  const {
    x: l,
    y: i,
    width: a,
    height: s
  } = e;
  return {
    width: a,
    height: s,
    top: i,
    left: l,
    right: l + a,
    bottom: i + s,
    x: l,
    y: i
  };
}
function Gd(e, l, i) {
  let {
    reference: a,
    floating: s
  } = e;
  const o = Oi(l), f = bf(l), d = Of(f), h = ji(l), x = o === "y", y = a.x + a.width / 2 - s.width / 2, I = a.y + a.height / 2 - s.height / 2, q = a[d] / 2 - s[d] / 2;
  let R;
  switch (h) {
    case "top":
      R = {
        x: y,
        y: a.y - s.height
      };
      break;
    case "bottom":
      R = {
        x: y,
        y: a.y + a.height
      };
      break;
    case "right":
      R = {
        x: a.x + a.width,
        y: I
      };
      break;
    case "left":
      R = {
        x: a.x - s.width,
        y: I
      };
      break;
    default:
      R = {
        x: a.x,
        y: a.y
      };
  }
  switch (Xa(l)) {
    case "start":
      R[f] -= q * (i && x ? -1 : 1);
      break;
    case "end":
      R[f] += q * (i && x ? -1 : 1);
      break;
  }
  return R;
}
const WO = async (e, l, i) => {
  const {
    placement: a = "bottom",
    strategy: s = "absolute",
    middleware: o = [],
    platform: f
  } = i, d = o.filter(Boolean), h = await (f.isRTL == null ? void 0 : f.isRTL(l));
  let x = await f.getElementRects({
    reference: e,
    floating: l,
    strategy: s
  }), {
    x: y,
    y: I
  } = Gd(x, a, h), q = a, R = {}, E = 0;
  for (let M = 0; M < d.length; M++) {
    const {
      name: U,
      fn: z
    } = d[M], {
      x: X,
      y: B,
      data: K,
      reset: W
    } = await z({
      x: y,
      y: I,
      initialPlacement: a,
      placement: q,
      strategy: s,
      middlewareData: R,
      rects: x,
      platform: f,
      elements: {
        reference: e,
        floating: l
      }
    });
    y = X ?? y, I = B ?? I, R = {
      ...R,
      [U]: {
        ...R[U],
        ...K
      }
    }, W && E <= 50 && (E++, typeof W == "object" && (W.placement && (q = W.placement), W.rects && (x = W.rects === !0 ? await f.getElementRects({
      reference: e,
      floating: l,
      strategy: s
    }) : W.rects), {
      x: y,
      y: I
    } = Gd(x, q, h)), M = -1);
  }
  return {
    x: y,
    y: I,
    placement: q,
    strategy: s,
    middlewareData: R
  };
};
async function ss(e, l) {
  var i;
  l === void 0 && (l = {});
  const {
    x: a,
    y: s,
    platform: o,
    rects: f,
    elements: d,
    strategy: h
  } = e, {
    boundary: x = "clippingAncestors",
    rootBoundary: y = "viewport",
    elementContext: I = "floating",
    altBoundary: q = !1,
    padding: R = 0
  } = zi(l, e), E = tv(R), U = d[q ? I === "floating" ? "reference" : "floating" : I], z = Rc(await o.getClippingRect({
    element: (i = await (o.isElement == null ? void 0 : o.isElement(U))) == null || i ? U : U.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(d.floating)),
    boundary: x,
    rootBoundary: y,
    strategy: h
  })), X = I === "floating" ? {
    x: a,
    y: s,
    width: f.floating.width,
    height: f.floating.height
  } : f.reference, B = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(d.floating)), K = await (o.isElement == null ? void 0 : o.isElement(B)) ? await (o.getScale == null ? void 0 : o.getScale(B)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, W = Rc(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: d,
    rect: X,
    offsetParent: B,
    strategy: h
  }) : X);
  return {
    top: (z.top - W.top + E.top) / K.y,
    bottom: (W.bottom - z.bottom + E.bottom) / K.y,
    left: (z.left - W.left + E.left) / K.x,
    right: (W.right - z.right + E.right) / K.x
  };
}
const YO = (e) => ({
  name: "arrow",
  options: e,
  async fn(l) {
    const {
      x: i,
      y: a,
      placement: s,
      rects: o,
      platform: f,
      elements: d,
      middlewareData: h
    } = l, {
      element: x,
      padding: y = 0
    } = zi(e, l) || {};
    if (x == null)
      return {};
    const I = tv(y), q = {
      x: i,
      y: a
    }, R = bf(s), E = Of(R), M = await f.getDimensions(x), U = R === "y", z = U ? "top" : "left", X = U ? "bottom" : "right", B = U ? "clientHeight" : "clientWidth", K = o.reference[E] + o.reference[R] - q[R] - o.floating[E], W = q[R] - o.reference[R], ae = await (f.getOffsetParent == null ? void 0 : f.getOffsetParent(x));
    let ne = ae ? ae[B] : 0;
    (!ne || !await (f.isElement == null ? void 0 : f.isElement(ae))) && (ne = d.floating[B] || o.floating[E]);
    const oe = K / 2 - W / 2, k = ne / 2 - M[E] / 2 - 1, me = ju(I[z], k), be = ju(I[X], k), re = me, ye = ne - M[E] - be, xe = ne / 2 - M[E] / 2 + oe, Se = _m(re, xe, ye), ge = !h.arrow && Xa(s) != null && xe !== Se && o.reference[E] / 2 - (xe < re ? me : be) - M[E] / 2 < 0, ce = ge ? xe < re ? xe - re : xe - ye : 0;
    return {
      [R]: q[R] + ce,
      data: {
        [R]: Se,
        centerOffset: xe - Se - ce,
        ...ge && {
          alignmentOffset: ce
        }
      },
      reset: ge
    };
  }
}), XO = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(l) {
      var i, a;
      const {
        placement: s,
        middlewareData: o,
        rects: f,
        initialPlacement: d,
        platform: h,
        elements: x
      } = l, {
        mainAxis: y = !0,
        crossAxis: I = !0,
        fallbackPlacements: q,
        fallbackStrategy: R = "bestFit",
        fallbackAxisSideDirection: E = "none",
        flipAlignment: M = !0,
        ...U
      } = zi(e, l);
      if ((i = o.arrow) != null && i.alignmentOffset)
        return {};
      const z = ji(s), X = Oi(d), B = ji(d) === d, K = await (h.isRTL == null ? void 0 : h.isRTL(x.floating)), W = q || (B || !M ? [qc(d)] : KO(d)), ae = E !== "none";
      !q && ae && W.push(...HO(d, M, E, K));
      const ne = [d, ...W], oe = await ss(l, U), k = [];
      let me = ((a = o.flip) == null ? void 0 : a.overflows) || [];
      if (y && k.push(oe[z]), I) {
        const xe = UO(s, f, K);
        k.push(oe[xe[0]], oe[xe[1]]);
      }
      if (me = [...me, {
        placement: s,
        overflows: k
      }], !k.every((xe) => xe <= 0)) {
        var be, re;
        const xe = (((be = o.flip) == null ? void 0 : be.index) || 0) + 1, Se = ne[xe];
        if (Se && (!(I === "alignment" ? X !== Oi(Se) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        me.every((de) => Oi(de.placement) === X ? de.overflows[0] > 0 : !0)))
          return {
            data: {
              index: xe,
              overflows: me
            },
            reset: {
              placement: Se
            }
          };
        let ge = (re = me.filter((ce) => ce.overflows[0] <= 0).sort((ce, de) => ce.overflows[1] - de.overflows[1])[0]) == null ? void 0 : re.placement;
        if (!ge)
          switch (R) {
            case "bestFit": {
              var ye;
              const ce = (ye = me.filter((de) => {
                if (ae) {
                  const Le = Oi(de.placement);
                  return Le === X || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Le === "y";
                }
                return !0;
              }).map((de) => [de.placement, de.overflows.filter((Le) => Le > 0).reduce((Le, Ae) => Le + Ae, 0)]).sort((de, Le) => de[1] - Le[1])[0]) == null ? void 0 : ye[0];
              ce && (ge = ce);
              break;
            }
            case "initialPlacement":
              ge = d;
              break;
          }
        if (s !== ge)
          return {
            reset: {
              placement: ge
            }
          };
      }
      return {};
    }
  };
};
function zd(e, l) {
  return {
    top: e.top - l.height,
    right: e.right - l.width,
    bottom: e.bottom - l.height,
    left: e.left - l.width
  };
}
function jd(e) {
  return kO.some((l) => e[l] >= 0);
}
const QO = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(l) {
      const {
        rects: i
      } = l, {
        strategy: a = "referenceHidden",
        ...s
      } = zi(e, l);
      switch (a) {
        case "referenceHidden": {
          const o = await ss(l, {
            ...s,
            elementContext: "reference"
          }), f = zd(o, i.reference);
          return {
            data: {
              referenceHiddenOffsets: f,
              referenceHidden: jd(f)
            }
          };
        }
        case "escaped": {
          const o = await ss(l, {
            ...s,
            altBoundary: !0
          }), f = zd(o, i.floating);
          return {
            data: {
              escapedOffsets: f,
              escaped: jd(f)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, iv = /* @__PURE__ */ new Set(["left", "top"]);
async function JO(e, l) {
  const {
    placement: i,
    platform: a,
    elements: s
  } = e, o = await (a.isRTL == null ? void 0 : a.isRTL(s.floating)), f = ji(i), d = Xa(i), h = Oi(i) === "y", x = iv.has(f) ? -1 : 1, y = o && h ? -1 : 1, I = zi(l, e);
  let {
    mainAxis: q,
    crossAxis: R,
    alignmentAxis: E
  } = typeof I == "number" ? {
    mainAxis: I,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: I.mainAxis || 0,
    crossAxis: I.crossAxis || 0,
    alignmentAxis: I.alignmentAxis
  };
  return d && typeof E == "number" && (R = d === "end" ? E * -1 : E), h ? {
    x: R * y,
    y: q * x
  } : {
    x: q * x,
    y: R * y
  };
}
const eb = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(l) {
      var i, a;
      const {
        x: s,
        y: o,
        placement: f,
        middlewareData: d
      } = l, h = await JO(l, e);
      return f === ((i = d.offset) == null ? void 0 : i.placement) && (a = d.arrow) != null && a.alignmentOffset ? {} : {
        x: s + h.x,
        y: o + h.y,
        data: {
          ...h,
          placement: f
        }
      };
    }
  };
}, nb = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(l) {
      const {
        x: i,
        y: a,
        placement: s
      } = l, {
        mainAxis: o = !0,
        crossAxis: f = !1,
        limiter: d = {
          fn: (U) => {
            let {
              x: z,
              y: X
            } = U;
            return {
              x: z,
              y: X
            };
          }
        },
        ...h
      } = zi(e, l), x = {
        x: i,
        y: a
      }, y = await ss(l, h), I = Oi(ji(s)), q = Df(I);
      let R = x[q], E = x[I];
      if (o) {
        const U = q === "y" ? "top" : "left", z = q === "y" ? "bottom" : "right", X = R + y[U], B = R - y[z];
        R = _m(X, R, B);
      }
      if (f) {
        const U = I === "y" ? "top" : "left", z = I === "y" ? "bottom" : "right", X = E + y[U], B = E - y[z];
        E = _m(X, E, B);
      }
      const M = d.fn({
        ...l,
        [q]: R,
        [I]: E
      });
      return {
        ...M,
        data: {
          x: M.x - i,
          y: M.y - a,
          enabled: {
            [q]: o,
            [I]: f
          }
        }
      };
    }
  };
}, lb = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(l) {
      const {
        x: i,
        y: a,
        placement: s,
        rects: o,
        middlewareData: f
      } = l, {
        offset: d = 0,
        mainAxis: h = !0,
        crossAxis: x = !0
      } = zi(e, l), y = {
        x: i,
        y: a
      }, I = Oi(s), q = Df(I);
      let R = y[q], E = y[I];
      const M = zi(d, l), U = typeof M == "number" ? {
        mainAxis: M,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...M
      };
      if (h) {
        const B = q === "y" ? "height" : "width", K = o.reference[q] - o.floating[B] + U.mainAxis, W = o.reference[q] + o.reference[B] - U.mainAxis;
        R < K ? R = K : R > W && (R = W);
      }
      if (x) {
        var z, X;
        const B = q === "y" ? "width" : "height", K = iv.has(ji(s)), W = o.reference[I] - o.floating[B] + (K && ((z = f.offset) == null ? void 0 : z[I]) || 0) + (K ? 0 : U.crossAxis), ae = o.reference[I] + o.reference[B] + (K ? 0 : ((X = f.offset) == null ? void 0 : X[I]) || 0) - (K ? U.crossAxis : 0);
        E < W ? E = W : E > ae && (E = ae);
      }
      return {
        [q]: R,
        [I]: E
      };
    }
  };
}, tb = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(l) {
      var i, a;
      const {
        placement: s,
        rects: o,
        platform: f,
        elements: d
      } = l, {
        apply: h = () => {
        },
        ...x
      } = zi(e, l), y = await ss(l, x), I = ji(s), q = Xa(s), R = Oi(s) === "y", {
        width: E,
        height: M
      } = o.floating;
      let U, z;
      I === "top" || I === "bottom" ? (U = I, z = q === (await (f.isRTL == null ? void 0 : f.isRTL(d.floating)) ? "start" : "end") ? "left" : "right") : (z = I, U = q === "end" ? "top" : "bottom");
      const X = M - y.top - y.bottom, B = E - y.left - y.right, K = ju(M - y[U], X), W = ju(E - y[z], B), ae = !l.middlewareData.shift;
      let ne = K, oe = W;
      if ((i = l.middlewareData.shift) != null && i.enabled.x && (oe = B), (a = l.middlewareData.shift) != null && a.enabled.y && (ne = X), ae && !q) {
        const me = xt(y.left, 0), be = xt(y.right, 0), re = xt(y.top, 0), ye = xt(y.bottom, 0);
        R ? oe = E - 2 * (me !== 0 || be !== 0 ? me + be : xt(y.left, y.right)) : ne = M - 2 * (re !== 0 || ye !== 0 ? re + ye : xt(y.top, y.bottom));
      }
      await h({
        ...l,
        availableWidth: oe,
        availableHeight: ne
      });
      const k = await f.getDimensions(d.floating);
      return E !== k.width || M !== k.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function ro() {
  return typeof window < "u";
}
function da(e) {
  return wf(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function It(e) {
  var l;
  return (e == null || (l = e.ownerDocument) == null ? void 0 : l.defaultView) || window;
}
function Si(e) {
  var l;
  return (l = (wf(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : l.documentElement;
}
function wf(e) {
  return ro() ? e instanceof Node || e instanceof It(e).Node : !1;
}
function hi(e) {
  return ro() ? e instanceof Element || e instanceof It(e).Element : !1;
}
function wi(e) {
  return ro() ? e instanceof HTMLElement || e instanceof It(e).HTMLElement : !1;
}
function Hd(e) {
  return !ro() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof It(e).ShadowRoot;
}
const ib = /* @__PURE__ */ new Set(["inline", "contents"]);
function ws(e) {
  const {
    overflow: l,
    overflowX: i,
    overflowY: a,
    display: s
  } = gi(e);
  return /auto|scroll|overlay|hidden|clip/.test(l + a + i) && !ib.has(s);
}
const ub = /* @__PURE__ */ new Set(["table", "td", "th"]);
function ab(e) {
  return ub.has(da(e));
}
const rb = [":popover-open", ":modal"];
function so(e) {
  return rb.some((l) => {
    try {
      return e.matches(l);
    } catch {
      return !1;
    }
  });
}
const sb = ["transform", "translate", "scale", "rotate", "perspective"], cb = ["transform", "translate", "scale", "rotate", "perspective", "filter"], ob = ["paint", "layout", "strict", "content"];
function Sf(e) {
  const l = Cf(), i = hi(e) ? gi(e) : e;
  return sb.some((a) => i[a] ? i[a] !== "none" : !1) || (i.containerType ? i.containerType !== "normal" : !1) || !l && (i.backdropFilter ? i.backdropFilter !== "none" : !1) || !l && (i.filter ? i.filter !== "none" : !1) || cb.some((a) => (i.willChange || "").includes(a)) || ob.some((a) => (i.contain || "").includes(a));
}
function mb(e) {
  let l = Hu(e);
  for (; wi(l) && !Ua(l); ) {
    if (Sf(l))
      return l;
    if (so(l))
      return null;
    l = Hu(l);
  }
  return null;
}
function Cf() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const fb = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Ua(e) {
  return fb.has(da(e));
}
function gi(e) {
  return It(e).getComputedStyle(e);
}
function co(e) {
  return hi(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Hu(e) {
  if (da(e) === "html")
    return e;
  const l = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Hd(e) && e.host || // Fallback.
    Si(e)
  );
  return Hd(l) ? l.host : l;
}
function uv(e) {
  const l = Hu(e);
  return Ua(l) ? e.ownerDocument ? e.ownerDocument.body : e.body : wi(l) && ws(l) ? l : uv(l);
}
function cs(e, l, i) {
  var a;
  l === void 0 && (l = []), i === void 0 && (i = !0);
  const s = uv(e), o = s === ((a = e.ownerDocument) == null ? void 0 : a.body), f = It(s);
  if (o) {
    const d = Fm(f);
    return l.concat(f, f.visualViewport || [], ws(s) ? s : [], d && i ? cs(d) : []);
  }
  return l.concat(s, cs(s, [], i));
}
function Fm(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function av(e) {
  const l = gi(e);
  let i = parseFloat(l.width) || 0, a = parseFloat(l.height) || 0;
  const s = wi(e), o = s ? e.offsetWidth : i, f = s ? e.offsetHeight : a, d = Pc(i) !== o || Pc(a) !== f;
  return d && (i = o, a = f), {
    width: i,
    height: a,
    $: d
  };
}
function Tf(e) {
  return hi(e) ? e : e.contextElement;
}
function Na(e) {
  const l = Tf(e);
  if (!wi(l))
    return bi(1);
  const i = l.getBoundingClientRect(), {
    width: a,
    height: s,
    $: o
  } = av(l);
  let f = (o ? Pc(i.width) : i.width) / a, d = (o ? Pc(i.height) : i.height) / s;
  return (!f || !Number.isFinite(f)) && (f = 1), (!d || !Number.isFinite(d)) && (d = 1), {
    x: f,
    y: d
  };
}
const db = /* @__PURE__ */ bi(0);
function rv(e) {
  const l = It(e);
  return !Cf() || !l.visualViewport ? db : {
    x: l.visualViewport.offsetLeft,
    y: l.visualViewport.offsetTop
  };
}
function pb(e, l, i) {
  return l === void 0 && (l = !1), !i || l && i !== It(e) ? !1 : l;
}
function ra(e, l, i, a) {
  l === void 0 && (l = !1), i === void 0 && (i = !1);
  const s = e.getBoundingClientRect(), o = Tf(e);
  let f = bi(1);
  l && (a ? hi(a) && (f = Na(a)) : f = Na(e));
  const d = pb(o, i, a) ? rv(o) : bi(0);
  let h = (s.left + d.x) / f.x, x = (s.top + d.y) / f.y, y = s.width / f.x, I = s.height / f.y;
  if (o) {
    const q = It(o), R = a && hi(a) ? It(a) : a;
    let E = q, M = Fm(E);
    for (; M && a && R !== E; ) {
      const U = Na(M), z = M.getBoundingClientRect(), X = gi(M), B = z.left + (M.clientLeft + parseFloat(X.paddingLeft)) * U.x, K = z.top + (M.clientTop + parseFloat(X.paddingTop)) * U.y;
      h *= U.x, x *= U.y, y *= U.x, I *= U.y, h += B, x += K, E = It(M), M = Fm(E);
    }
  }
  return Rc({
    width: y,
    height: I,
    x: h,
    y: x
  });
}
function oo(e, l) {
  const i = co(e).scrollLeft;
  return l ? l.left + i : ra(Si(e)).left + i;
}
function sv(e, l) {
  const i = e.getBoundingClientRect(), a = i.left + l.scrollLeft - oo(e, i), s = i.top + l.scrollTop;
  return {
    x: a,
    y: s
  };
}
function hb(e) {
  let {
    elements: l,
    rect: i,
    offsetParent: a,
    strategy: s
  } = e;
  const o = s === "fixed", f = Si(a), d = l ? so(l.floating) : !1;
  if (a === f || d && o)
    return i;
  let h = {
    scrollLeft: 0,
    scrollTop: 0
  }, x = bi(1);
  const y = bi(0), I = wi(a);
  if ((I || !I && !o) && ((da(a) !== "body" || ws(f)) && (h = co(a)), wi(a))) {
    const R = ra(a);
    x = Na(a), y.x = R.x + a.clientLeft, y.y = R.y + a.clientTop;
  }
  const q = f && !I && !o ? sv(f, h) : bi(0);
  return {
    width: i.width * x.x,
    height: i.height * x.y,
    x: i.x * x.x - h.scrollLeft * x.x + y.x + q.x,
    y: i.y * x.y - h.scrollTop * x.y + y.y + q.y
  };
}
function gb(e) {
  return Array.from(e.getClientRects());
}
function vb(e) {
  const l = Si(e), i = co(e), a = e.ownerDocument.body, s = xt(l.scrollWidth, l.clientWidth, a.scrollWidth, a.clientWidth), o = xt(l.scrollHeight, l.clientHeight, a.scrollHeight, a.clientHeight);
  let f = -i.scrollLeft + oo(e);
  const d = -i.scrollTop;
  return gi(a).direction === "rtl" && (f += xt(l.clientWidth, a.clientWidth) - s), {
    width: s,
    height: o,
    x: f,
    y: d
  };
}
const $d = 25;
function xb(e, l) {
  const i = It(e), a = Si(e), s = i.visualViewport;
  let o = a.clientWidth, f = a.clientHeight, d = 0, h = 0;
  if (s) {
    o = s.width, f = s.height;
    const y = Cf();
    (!y || y && l === "fixed") && (d = s.offsetLeft, h = s.offsetTop);
  }
  const x = oo(a);
  if (x <= 0) {
    const y = a.ownerDocument, I = y.body, q = getComputedStyle(I), R = y.compatMode === "CSS1Compat" && parseFloat(q.marginLeft) + parseFloat(q.marginRight) || 0, E = Math.abs(a.clientWidth - I.clientWidth - R);
    E <= $d && (o -= E);
  } else x <= $d && (o += x);
  return {
    width: o,
    height: f,
    x: d,
    y: h
  };
}
const yb = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function Ib(e, l) {
  const i = ra(e, !0, l === "fixed"), a = i.top + e.clientTop, s = i.left + e.clientLeft, o = wi(e) ? Na(e) : bi(1), f = e.clientWidth * o.x, d = e.clientHeight * o.y, h = s * o.x, x = a * o.y;
  return {
    width: f,
    height: d,
    x: h,
    y: x
  };
}
function Wd(e, l, i) {
  let a;
  if (l === "viewport")
    a = xb(e, i);
  else if (l === "document")
    a = vb(Si(e));
  else if (hi(l))
    a = Ib(l, i);
  else {
    const s = rv(e);
    a = {
      x: l.x - s.x,
      y: l.y - s.y,
      width: l.width,
      height: l.height
    };
  }
  return Rc(a);
}
function cv(e, l) {
  const i = Hu(e);
  return i === l || !hi(i) || Ua(i) ? !1 : gi(i).position === "fixed" || cv(i, l);
}
function Lb(e, l) {
  const i = l.get(e);
  if (i)
    return i;
  let a = cs(e, [], !1).filter((d) => hi(d) && da(d) !== "body"), s = null;
  const o = gi(e).position === "fixed";
  let f = o ? Hu(e) : e;
  for (; hi(f) && !Ua(f); ) {
    const d = gi(f), h = Sf(f);
    !h && d.position === "fixed" && (s = null), (o ? !h && !s : !h && d.position === "static" && !!s && yb.has(s.position) || ws(f) && !h && cv(e, f)) ? a = a.filter((y) => y !== f) : s = d, f = Hu(f);
  }
  return l.set(e, a), a;
}
function Db(e) {
  let {
    element: l,
    boundary: i,
    rootBoundary: a,
    strategy: s
  } = e;
  const f = [...i === "clippingAncestors" ? so(l) ? [] : Lb(l, this._c) : [].concat(i), a], d = f[0], h = f.reduce((x, y) => {
    const I = Wd(l, y, s);
    return x.top = xt(I.top, x.top), x.right = ju(I.right, x.right), x.bottom = ju(I.bottom, x.bottom), x.left = xt(I.left, x.left), x;
  }, Wd(l, d, s));
  return {
    width: h.right - h.left,
    height: h.bottom - h.top,
    x: h.left,
    y: h.top
  };
}
function Ob(e) {
  const {
    width: l,
    height: i
  } = av(e);
  return {
    width: l,
    height: i
  };
}
function bb(e, l, i) {
  const a = wi(l), s = Si(l), o = i === "fixed", f = ra(e, !0, o, l);
  let d = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const h = bi(0);
  function x() {
    h.x = oo(s);
  }
  if (a || !a && !o)
    if ((da(l) !== "body" || ws(s)) && (d = co(l)), a) {
      const R = ra(l, !0, o, l);
      h.x = R.x + l.clientLeft, h.y = R.y + l.clientTop;
    } else s && x();
  o && !a && s && x();
  const y = s && !a && !o ? sv(s, d) : bi(0), I = f.left + d.scrollLeft - h.x - y.x, q = f.top + d.scrollTop - h.y - y.y;
  return {
    x: I,
    y: q,
    width: f.width,
    height: f.height
  };
}
function Mo(e) {
  return gi(e).position === "static";
}
function Yd(e, l) {
  if (!wi(e) || gi(e).position === "fixed")
    return null;
  if (l)
    return l(e);
  let i = e.offsetParent;
  return Si(e) === i && (i = i.ownerDocument.body), i;
}
function ov(e, l) {
  const i = It(e);
  if (so(e))
    return i;
  if (!wi(e)) {
    let s = Hu(e);
    for (; s && !Ua(s); ) {
      if (hi(s) && !Mo(s))
        return s;
      s = Hu(s);
    }
    return i;
  }
  let a = Yd(e, l);
  for (; a && ab(a) && Mo(a); )
    a = Yd(a, l);
  return a && Ua(a) && Mo(a) && !Sf(a) ? i : a || mb(e) || i;
}
const wb = async function(e) {
  const l = this.getOffsetParent || ov, i = this.getDimensions, a = await i(e.floating);
  return {
    reference: bb(e.reference, await l(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: a.width,
      height: a.height
    }
  };
};
function Sb(e) {
  return gi(e).direction === "rtl";
}
const Cb = {
  convertOffsetParentRelativeRectToViewportRelativeRect: hb,
  getDocumentElement: Si,
  getClippingRect: Db,
  getOffsetParent: ov,
  getElementRects: wb,
  getClientRects: gb,
  getDimensions: Ob,
  getScale: Na,
  isElement: hi,
  isRTL: Sb
};
function mv(e, l) {
  return e.x === l.x && e.y === l.y && e.width === l.width && e.height === l.height;
}
function Tb(e, l) {
  let i = null, a;
  const s = Si(e);
  function o() {
    var d;
    clearTimeout(a), (d = i) == null || d.disconnect(), i = null;
  }
  function f(d, h) {
    d === void 0 && (d = !1), h === void 0 && (h = 1), o();
    const x = e.getBoundingClientRect(), {
      left: y,
      top: I,
      width: q,
      height: R
    } = x;
    if (d || l(), !q || !R)
      return;
    const E = zs(I), M = zs(s.clientWidth - (y + q)), U = zs(s.clientHeight - (I + R)), z = zs(y), B = {
      rootMargin: -E + "px " + -M + "px " + -U + "px " + -z + "px",
      threshold: xt(0, ju(1, h)) || 1
    };
    let K = !0;
    function W(ae) {
      const ne = ae[0].intersectionRatio;
      if (ne !== h) {
        if (!K)
          return f();
        ne ? f(!1, ne) : a = setTimeout(() => {
          f(!1, 1e-7);
        }, 1e3);
      }
      ne === 1 && !mv(x, e.getBoundingClientRect()) && f(), K = !1;
    }
    try {
      i = new IntersectionObserver(W, {
        ...B,
        // Handle <iframe>s
        root: s.ownerDocument
      });
    } catch {
      i = new IntersectionObserver(W, B);
    }
    i.observe(e);
  }
  return f(!0), o;
}
function Pb(e, l, i, a) {
  a === void 0 && (a = {});
  const {
    ancestorScroll: s = !0,
    ancestorResize: o = !0,
    elementResize: f = typeof ResizeObserver == "function",
    layoutShift: d = typeof IntersectionObserver == "function",
    animationFrame: h = !1
  } = a, x = Tf(e), y = s || o ? [...x ? cs(x) : [], ...cs(l)] : [];
  y.forEach((z) => {
    s && z.addEventListener("scroll", i, {
      passive: !0
    }), o && z.addEventListener("resize", i);
  });
  const I = x && d ? Tb(x, i) : null;
  let q = -1, R = null;
  f && (R = new ResizeObserver((z) => {
    let [X] = z;
    X && X.target === x && R && (R.unobserve(l), cancelAnimationFrame(q), q = requestAnimationFrame(() => {
      var B;
      (B = R) == null || B.observe(l);
    })), i();
  }), x && !h && R.observe(x), R.observe(l));
  let E, M = h ? ra(e) : null;
  h && U();
  function U() {
    const z = ra(e);
    M && !mv(M, z) && i(), M = z, E = requestAnimationFrame(U);
  }
  return i(), () => {
    var z;
    y.forEach((X) => {
      s && X.removeEventListener("scroll", i), o && X.removeEventListener("resize", i);
    }), I?.(), (z = R) == null || z.disconnect(), R = null, h && cancelAnimationFrame(E);
  };
}
const qb = eb, Rb = nb, Xd = XO, Ab = tb, Eb = QO, _b = YO, Nb = lb, Fb = (e, l, i) => {
  const a = /* @__PURE__ */ new Map(), s = {
    platform: Cb,
    ...i
  }, o = {
    ...s.platform,
    _c: a
  };
  return WO(e, l, {
    ...s,
    platform: o
  });
};
function Mb(e) {
  return e != null && typeof e == "object" && "$el" in e;
}
function Mm(e) {
  if (Mb(e)) {
    const l = e.$el;
    return wf(l) && da(l) === "#comment" ? null : l;
  }
  return e;
}
function ba(e) {
  return typeof e == "function" ? e() : te(e);
}
function kb(e) {
  return {
    name: "arrow",
    options: e,
    fn(l) {
      const i = Mm(ba(e.element));
      return i == null ? {} : _b({
        element: i,
        padding: e.padding
      }).fn(l);
    }
  };
}
function fv(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Qd(e, l) {
  const i = fv(e);
  return Math.round(l * i) / i;
}
function Vb(e, l, i) {
  i === void 0 && (i = {});
  const a = i.whileElementsMounted, s = _e(() => {
    var ne;
    return (ne = ba(i.open)) != null ? ne : !0;
  }), o = _e(() => ba(i.middleware)), f = _e(() => {
    var ne;
    return (ne = ba(i.placement)) != null ? ne : "bottom";
  }), d = _e(() => {
    var ne;
    return (ne = ba(i.strategy)) != null ? ne : "absolute";
  }), h = _e(() => {
    var ne;
    return (ne = ba(i.transform)) != null ? ne : !0;
  }), x = _e(() => Mm(e.value)), y = _e(() => Mm(l.value)), I = Fe(0), q = Fe(0), R = Fe(d.value), E = Fe(f.value), M = Fl({}), U = Fe(!1), z = _e(() => {
    const ne = {
      position: R.value,
      left: "0",
      top: "0"
    };
    if (!y.value)
      return ne;
    const oe = Qd(y.value, I.value), k = Qd(y.value, q.value);
    return h.value ? {
      ...ne,
      transform: "translate(" + oe + "px, " + k + "px)",
      ...fv(y.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: R.value,
      left: oe + "px",
      top: k + "px"
    };
  });
  let X;
  function B() {
    if (x.value == null || y.value == null)
      return;
    const ne = s.value;
    Fb(x.value, y.value, {
      middleware: o.value,
      placement: f.value,
      strategy: d.value
    }).then((oe) => {
      I.value = oe.x, q.value = oe.y, R.value = oe.strategy, E.value = oe.placement, M.value = oe.middlewareData, U.value = ne !== !1;
    });
  }
  function K() {
    typeof X == "function" && (X(), X = void 0);
  }
  function W() {
    if (K(), a === void 0) {
      B();
      return;
    }
    if (x.value != null && y.value != null) {
      X = a(x.value, y.value, B);
      return;
    }
  }
  function ae() {
    s.value || (U.value = !1);
  }
  return Cn([o, f, d, s], B, {
    flush: "sync"
  }), Cn([x, y], W, {
    flush: "sync"
  }), Cn(s, ae, {
    flush: "sync"
  }), $i() && ca(K), {
    x: _u(I),
    y: _u(q),
    strategy: _u(R),
    placement: _u(E),
    middlewareData: _u(M),
    isPositioned: _u(U),
    floatingStyles: z,
    update: B
  };
}
const Bb = {
  side: "bottom",
  sideOffset: 0,
  sideFlip: !0,
  align: "center",
  alignOffset: 0,
  alignFlip: !0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [WC, Zb] = vi("PopperContent");
var Ub = /* @__PURE__ */ dn({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ Dh({
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ...Bb }),
  emits: ["placed"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = lv(), { forwardRef: o, currentElement: f } = Tt(), d = Fe(), h = Fe(), { width: x, height: y } = tO(h), I = _e(() => i.side + (i.align !== "center" ? `-${i.align}` : "")), q = _e(() => typeof i.collisionPadding == "number" ? i.collisionPadding : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...i.collisionPadding
    }), R = _e(() => Array.isArray(i.collisionBoundary) ? i.collisionBoundary : [i.collisionBoundary]), E = _e(() => ({
      padding: q.value,
      boundary: R.value.filter(FO),
      altBoundary: R.value.length > 0
    })), M = _e(() => ({
      mainAxis: i.sideFlip,
      crossAxis: i.alignFlip
    })), U = C0(() => [
      qb({
        mainAxis: i.sideOffset + y.value,
        alignmentAxis: i.alignOffset
      }),
      i.prioritizePosition && i.avoidCollisions && Xd({
        ...E.value,
        ...M.value
      }),
      i.avoidCollisions && Rb({
        mainAxis: !0,
        crossAxis: !!i.prioritizePosition,
        limiter: i.sticky === "partial" ? Nb() : void 0,
        ...E.value
      }),
      !i.prioritizePosition && i.avoidCollisions && Xd({
        ...E.value,
        ...M.value
      }),
      Ab({
        ...E.value,
        apply: ({ elements: re, rects: ye, availableWidth: xe, availableHeight: Se }) => {
          const { width: ge, height: ce } = ye.reference, de = re.floating.style;
          de.setProperty("--reka-popper-available-width", `${xe}px`), de.setProperty("--reka-popper-available-height", `${Se}px`), de.setProperty("--reka-popper-anchor-width", `${ge}px`), de.setProperty("--reka-popper-anchor-height", `${ce}px`);
        }
      }),
      h.value && kb({
        element: h.value,
        padding: i.arrowPadding
      }),
      MO({
        arrowWidth: x.value,
        arrowHeight: y.value
      }),
      i.hideWhenDetached && Eb({
        strategy: "referenceHidden",
        ...E.value
      })
    ]), z = _e(() => i.reference ?? s.anchor.value), { floatingStyles: X, placement: B, isPositioned: K, middlewareData: W } = Vb(z, d, {
      strategy: i.positionStrategy,
      placement: I,
      whileElementsMounted: (...re) => Pb(...re, {
        layoutShift: !i.disableUpdateOnLayoutShift,
        animationFrame: i.updatePositionStrategy === "always"
      }),
      middleware: U
    }), ae = _e(() => Em(B.value)[0]), ne = _e(() => Em(B.value)[1]);
    cf(() => {
      K.value && a("placed");
    });
    const oe = _e(() => W.value.arrow?.centerOffset !== 0), k = Fe("");
    Ml(() => {
      f.value && (k.value = window.getComputedStyle(f.value).zIndex);
    });
    const me = _e(() => W.value.arrow?.x ?? 0), be = _e(() => W.value.arrow?.y ?? 0);
    return Zb({
      placedSide: ae,
      onArrowChange: (re) => h.value = re,
      arrowX: me,
      arrowY: be,
      shouldHideArrow: oe
    }), (re, ye) => (Ye(), Yn("div", {
      ref_key: "floatingRef",
      ref: d,
      "data-reka-popper-content-wrapper": "",
      style: Hi({
        ...te(X),
        transform: te(K) ? te(X).transform : "translate(0, -200%)",
        minWidth: "max-content",
        zIndex: k.value,
        "--reka-popper-transform-origin": [te(W).transformOrigin?.x, te(W).transformOrigin?.y].join(" "),
        ...te(W).hide?.referenceHidden && {
          visibility: "hidden",
          pointerEvents: "none"
        }
      })
    }, [ze(te(al), pl({ ref: te(o) }, re.$attrs, {
      "as-child": i.asChild,
      as: re.as,
      "data-side": ae.value,
      "data-align": ne.value,
      style: { animation: te(K) ? void 0 : "none" }
    }), {
      default: ln(() => [qn(re.$slots, "default")]),
      _: 3
    }, 16, [
      "as-child",
      "as",
      "data-side",
      "data-align",
      "style"
    ])], 4));
  }
}), Kb = Ub, Gb = /* @__PURE__ */ dn({
  __name: "ComboboxAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { forwardRef: l } = Tt();
    return (i, a) => (Ye(), xn(te(NO), {
      "as-child": "",
      reference: i.reference
    }, {
      default: ln(() => [ze(te(al), pl({
        ref: te(l),
        "as-child": i.asChild,
        as: i.as
      }, i.$attrs), {
        default: ln(() => [qn(i.$slots, "default")]),
        _: 3
      }, 16, ["as-child", "as"])]),
      _: 3
    }, 8, ["reference"]));
  }
}), zb = Gb;
function jb(e, l, i) {
  return e === void 0 ? !1 : Array.isArray(e) ? e.some((a) => Yr(a, l, i)) : Yr(e, l, i);
}
function Yr(e, l, i) {
  return e === void 0 || l === void 0 ? !1 : typeof e == "string" ? e === l : typeof i == "function" ? i(e, l) : typeof i == "string" ? e?.[i] === l?.[i] : qm(e, l);
}
const [mo, Hb] = vi("ListboxRoot");
var $b = /* @__PURE__ */ dn({
  __name: "ListboxRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    selectionBehavior: {
      type: String,
      required: !1,
      default: "toggle"
    },
    highlightOnHover: {
      type: Boolean,
      required: !1
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "entryFocus",
    "leave"
  ],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, { multiple: o, highlightOnHover: f, orientation: d, disabled: h, selectionBehavior: x, dir: y } = St(a), { getItems: I } = Ya({ isProvider: !0 }), { handleTypeaheadSearch: q } = Xg(), { primitiveElement: R, currentElement: E } = zu(), M = nO(), U = bs(y), z = H0(E), X = Fe(), B = Fe(!1), K = Fe(!0), W = Gu(a, "modelValue", s, {
      defaultValue: a.defaultValue ?? (o.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    });
    function ae(V) {
      if (B.value = !0, a.multiple) {
        const _ = Array.isArray(W.value) ? [...W.value] : [], Z = _.findIndex((ue) => Yr(ue, V, a.by));
        a.selectionBehavior === "toggle" ? (Z === -1 ? _.push(V) : _.splice(Z, 1), W.value = _) : (W.value = [V], X.value = V);
      } else a.selectionBehavior === "toggle" && Yr(W.value, V, a.by) ? W.value = void 0 : W.value = V;
      setTimeout(() => {
        B.value = !1;
      }, 1);
    }
    const ne = Fe(null), oe = Fe(null), k = Fe(!1), me = Fe(!1), be = Wr(), re = Wr(), ye = Wr();
    function xe() {
      return I().map((V) => V.ref).filter((V) => V.dataset.disabled !== "");
    }
    function Se(V, _ = !0) {
      if (!V) return;
      ne.value = V, K.value && ne.value.focus(), _ && ne.value.scrollIntoView({ block: "nearest" });
      const Z = I().find((ue) => ue.ref === V);
      s("highlight", Z);
    }
    function ge(V) {
      if (k.value) ye.trigger(V);
      else {
        const _ = I().find((Z) => Yr(Z.value, V, a.by));
        _ && (ne.value = _.ref, Se(_.ref));
      }
    }
    function ce(V) {
      ne.value && ne.value.isConnected && (V.preventDefault(), V.stopPropagation(), me.value || ne.value.click());
    }
    function de(V) {
      if (K.value) {
        if (B.value = !0, k.value) re.trigger(V);
        else {
          const _ = V.altKey || V.ctrlKey || V.metaKey;
          if (_ && V.key === "a" && o.value) {
            const Z = I(), ue = Z.map((Qe) => Qe.value);
            W.value = [...ue], V.preventDefault(), Se(Z[Z.length - 1].ref);
          } else if (!_) {
            const Z = q(V.key, I());
            Z && Se(Z);
          }
        }
        setTimeout(() => {
          B.value = !1;
        }, 1);
      }
    }
    function Le() {
      me.value = !0;
    }
    function Ae() {
      il(() => {
        me.value = !1;
      });
    }
    function We() {
      il(() => {
        const V = new KeyboardEvent("keydown", { key: "PageUp" });
        bn(V);
      });
    }
    function je(V) {
      const _ = ne.value;
      _?.isConnected && (oe.value = _), ne.value = null, s("leave", V);
    }
    function cn(V) {
      const _ = new CustomEvent("listbox.entryFocus", {
        bubbles: !1,
        cancelable: !0
      });
      if (V.currentTarget?.dispatchEvent(_), s("entryFocus", _), !_.defaultPrevented)
        if (oe.value) Se(oe.value);
        else {
          const Z = xe()?.[0];
          Se(Z);
        }
    }
    function bn(V) {
      const _ = ev(V, d.value, U.value);
      if (!_) return;
      let Z = xe();
      if (ne.value) {
        if (_ === "last") Z.reverse();
        else if (_ === "prev" || _ === "next") {
          _ === "prev" && Z.reverse();
          const ue = Z.indexOf(ne.value);
          Z = Z.slice(ue + 1);
        }
        gn(V, Z[0]);
      }
      if (Z.length) {
        const ue = !ne.value && _ === "prev" ? Z.length - 1 : 0;
        Se(Z[ue]);
      }
      if (k.value) return re.trigger(V);
    }
    function gn(V, _) {
      if (!(k.value || a.selectionBehavior !== "replace" || !o.value || !Array.isArray(W.value) || (V.altKey || V.ctrlKey || V.metaKey) && !V.shiftKey) && V.shiftKey) {
        const ue = I().filter((j) => j.ref.dataset.disabled !== "");
        let Qe = ue.find((j) => j.ref === _)?.value;
        if (V.key === M.END ? Qe = ue[ue.length - 1].value : V.key === M.HOME && (Qe = ue[0].value), !Qe || !X.value) return;
        const De = rc(ue.map((j) => j.value), X.value, Qe);
        W.value = De;
      }
    }
    async function tn(V) {
      if (await il(), k.value) be.trigger(V);
      else {
        const _ = xe(), Z = _.find((ue) => ue.dataset.state === "checked");
        Z ? Se(Z) : _.length && Se(_[0]);
      }
    }
    return Cn(W, () => {
      B.value || il(() => {
        tn();
      });
    }, {
      immediate: !0,
      deep: !0
    }), l({
      highlightedElement: ne,
      highlightItem: ge,
      highlightFirstItem: We,
      highlightSelected: tn,
      getItems: I
    }), Hb({
      modelValue: W,
      onValueChange: ae,
      multiple: o,
      orientation: d,
      dir: U,
      disabled: h,
      highlightOnHover: f,
      highlightedElement: ne,
      isVirtual: k,
      virtualFocusHook: be,
      virtualKeydownHook: re,
      virtualHighlightHook: ye,
      by: a.by,
      firstValue: X,
      selectionBehavior: x,
      focusable: K,
      onLeave: je,
      onEnter: cn,
      changeHighlight: Se,
      onKeydownEnter: ce,
      onKeydownNavigation: bn,
      onKeydownTypeAhead: de,
      onCompositionStart: Le,
      onCompositionEnd: Ae,
      highlightFirstItem: We
    }), (V, _) => (Ye(), xn(te(al), {
      ref_key: "primitiveElement",
      ref: R,
      as: V.as,
      "as-child": V.asChild,
      dir: te(U),
      "data-disabled": te(h) ? "" : void 0,
      onPointerleave: je,
      onFocusout: _[0] || (_[0] = async (Z) => {
        const ue = Z.relatedTarget || Z.target;
        await il(), ne.value && te(E) && !te(E).contains(ue) && je(Z);
      })
    }, {
      default: ln(() => [qn(V.$slots, "default", { modelValue: te(W) }), te(z) && V.name ? (Ye(), xn(te(qO), {
        key: 0,
        name: V.name,
        value: te(W),
        disabled: te(h),
        required: V.required
      }, null, 8, [
        "name",
        "value",
        "disabled",
        "required"
      ])) : pi("v-if", !0)]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "dir",
      "data-disabled"
    ]));
  }
}), Wb = $b, Yb = /* @__PURE__ */ dn({
  __name: "ListboxContent",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { CollectionSlot: l } = Ya(), i = mo(), a = jg(!1, 10);
    return (s, o) => (Ye(), xn(te(l), null, {
      default: ln(() => [ze(te(al), {
        role: "listbox",
        as: s.as,
        "as-child": s.asChild,
        tabindex: te(i).focusable.value ? te(i).highlightedElement.value ? "-1" : "0" : void 0,
        "aria-orientation": te(i).orientation.value,
        "aria-multiselectable": !!te(i).multiple.value,
        "data-orientation": te(i).orientation.value,
        onMousedown: o[0] || (o[0] = si((f) => a.value = !0, ["left"])),
        onFocus: o[1] || (o[1] = (f) => {
          te(a) || te(i).onEnter(f);
        }),
        onKeydown: [
          o[2] || (o[2] = mi((f) => {
            te(i).orientation.value === "vertical" && (f.key === "ArrowLeft" || f.key === "ArrowRight") || te(i).orientation.value === "horizontal" && (f.key === "ArrowUp" || f.key === "ArrowDown") || (f.preventDefault(), te(i).focusable.value && te(i).onKeydownNavigation(f));
          }, [
            "down",
            "up",
            "left",
            "right",
            "home",
            "end"
          ])),
          mi(te(i).onKeydownEnter, ["enter"]),
          te(i).onKeydownTypeAhead
        ]
      }, {
        default: ln(() => [qn(s.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "tabindex",
        "aria-orientation",
        "aria-multiselectable",
        "data-orientation",
        "onKeydown"
      ])]),
      _: 3
    }));
  }
}), Xb = Yb, Qb = /* @__PURE__ */ dn({
  __name: "ListboxFilter",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: l }) {
    const i = e, s = Gu(i, "modelValue", l, {
      defaultValue: "",
      passive: i.modelValue === void 0
    }), o = mo(), { primitiveElement: f, currentElement: d } = zu(), h = _e(() => i.disabled || o.disabled.value || !1), x = Fe();
    return of(() => x.value = o.highlightedElement.value?.id), vl(() => {
      o.focusable.value = !1, setTimeout(() => {
        i.autoFocus && d.value?.focus();
      }, 1);
    }), Dt(() => {
      o.focusable.value = !0;
    }), (y, I) => (Ye(), xn(te(al), {
      ref_key: "primitiveElement",
      ref: f,
      as: y.as,
      "as-child": y.asChild,
      value: te(s),
      disabled: h.value ? "" : void 0,
      "data-disabled": h.value ? "" : void 0,
      "aria-disabled": h.value ?? void 0,
      "aria-activedescendant": x.value,
      type: "text",
      onKeydown: [mi(si(te(o).onKeydownNavigation, ["prevent"]), [
        "down",
        "up",
        "home",
        "end"
      ]), mi(te(o).onKeydownEnter, ["enter"])],
      onInput: I[0] || (I[0] = (q) => {
        s.value = q.target.value, te(o).highlightFirstItem();
      }),
      onCompositionstart: te(o).onCompositionStart,
      onCompositionend: te(o).onCompositionEnd
    }, {
      default: ln(() => [qn(y.$slots, "default", { modelValue: te(s) })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "value",
      "disabled",
      "data-disabled",
      "aria-disabled",
      "aria-activedescendant",
      "onKeydown",
      "onCompositionstart",
      "onCompositionend"
    ]));
  }
}), Jb = Qb;
const ew = "listbox.select", [nw, lw] = vi("ListboxItem");
var tw = /* @__PURE__ */ dn({
  __name: "ListboxItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: ["select"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = fa(void 0, "reka-listbox-item"), { CollectionItem: o } = Ya(), { forwardRef: f, currentElement: d } = Tt(), h = mo(), x = _e(() => d.value === h.highlightedElement.value), y = _e(() => jb(h.modelValue.value, i.value, h.by)), I = _e(() => h.disabled.value || i.disabled);
    async function q(E) {
      a("select", E), !E?.defaultPrevented && !I.value && E && (h.onValueChange(i.value), h.changeHighlight(d.value));
    }
    function R(E) {
      const M = {
        originalEvent: E,
        value: i.value
      };
      rs(ew, q, M);
    }
    return lw({ isSelected: y }), (E, M) => (Ye(), xn(te(o), { value: E.value }, {
      default: ln(() => [Jh([x.value, y.value], () => ze(te(al), pl({ id: te(s) }, E.$attrs, {
        ref: te(f),
        role: "option",
        tabindex: te(h).focusable.value ? x.value ? "0" : "-1" : -1,
        "aria-selected": y.value,
        as: E.as,
        "as-child": E.asChild,
        disabled: I.value ? "" : void 0,
        "data-disabled": I.value ? "" : void 0,
        "data-highlighted": x.value ? "" : void 0,
        "data-state": y.value ? "checked" : "unchecked",
        onClick: R,
        onKeydown: mi(si(R, ["prevent"]), ["space"]),
        onPointermove: M[0] || (M[0] = (U) => {
          te(h).highlightedElement.value !== te(d) && (te(h).highlightOnHover.value ? te(h).changeHighlight(te(d), !1) : te(h).focusable.value || te(h).changeHighlight(te(d), !1));
        })
      }), {
        default: ln(() => [qn(E.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "tabindex",
        "aria-selected",
        "as",
        "as-child",
        "disabled",
        "data-disabled",
        "data-highlighted",
        "data-state",
        "onKeydown"
      ]), M, 1)]),
      _: 3
    }, 8, ["value"]));
  }
}), iw = tw, uw = /* @__PURE__ */ dn({
  __name: "ListboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const l = e;
    Tt();
    const i = nw();
    return (a, s) => te(i).isSelected.value ? (Ye(), xn(te(al), pl({
      key: 0,
      "aria-hidden": "true"
    }, l), {
      default: ln(() => [qn(a.$slots, "default")]),
      _: 3
    }, 16)) : pi("v-if", !0);
  }
}), aw = uw;
const [pa, rw] = vi("ComboboxRoot");
var sw = /* @__PURE__ */ dn({
  __name: "ComboboxRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    resetSearchTermOnBlur: {
      type: Boolean,
      required: !1,
      default: !0
    },
    resetSearchTermOnSelect: {
      type: Boolean,
      required: !1,
      default: !0
    },
    openOnFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    openOnClick: {
      type: Boolean,
      required: !1,
      default: !1
    },
    ignoreFilter: {
      type: Boolean,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    highlightOnHover: {
      type: Boolean,
      required: !1
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "update:open"
  ],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, { primitiveElement: o, currentElement: f } = zu(), { multiple: d, disabled: h, ignoreFilter: x, resetSearchTermOnSelect: y, openOnFocus: I, openOnClick: q, dir: R } = St(a), E = bs(R), M = Gu(a, "modelValue", s, {
      defaultValue: a.defaultValue ?? (d.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    }), U = Gu(a, "open", s, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    });
    async function z(xe) {
      U.value = xe, be.value = "", xe ? (await il(), o.value?.highlightSelected(), B.value = !0) : B.value = !1, W.value?.focus(), setTimeout(() => {
        !xe && a.resetSearchTermOnBlur && X.trigger();
      }, 1);
    }
    const X = Wr(), B = Fe(!1), K = Fe(!1), W = Fe(), ae = Fe(), ne = _e(() => o.value?.highlightedElement ?? void 0), oe = Fe(/* @__PURE__ */ new Map()), k = Fe(/* @__PURE__ */ new Map()), { contains: me } = j0({ sensitivity: "base" }), be = Fe(""), re = _e((xe) => {
      if (!be.value || a.ignoreFilter || K.value) return {
        count: oe.value.size,
        items: xe?.items ?? /* @__PURE__ */ new Map(),
        groups: xe?.groups ?? new Set(k.value.keys())
      };
      let Se = 0;
      const ge = /* @__PURE__ */ new Map(), ce = /* @__PURE__ */ new Set();
      for (const [de, Le] of oe.value) {
        const Ae = me(Le, be.value);
        ge.set(de, Ae ? 1 : 0), Ae && Se++;
      }
      for (const [de, Le] of k.value) for (const Ae of Le) if (ge.get(Ae) > 0) {
        ce.add(de);
        break;
      }
      return {
        count: Se,
        items: ge,
        groups: ce
      };
    }), ye = Xn();
    return vl(() => {
      ye?.exposed && (ye.exposed.highlightItem = o.value?.highlightItem, ye.exposed.highlightFirstItem = o.value?.highlightFirstItem, ye.exposed.highlightSelected = o.value?.highlightSelected);
    }), l({
      filtered: re,
      highlightedElement: ne,
      highlightItem: o.value?.highlightItem,
      highlightFirstItem: o.value?.highlightFirstItem,
      highlightSelected: o.value?.highlightSelected
    }), rw({
      modelValue: M,
      multiple: d,
      disabled: h,
      open: U,
      onOpenChange: z,
      contentId: "",
      isUserInputted: B,
      isVirtual: K,
      inputElement: W,
      highlightedElement: ne,
      onInputElementChange: (xe) => W.value = xe,
      triggerElement: ae,
      onTriggerElementChange: (xe) => ae.value = xe,
      parentElement: f,
      resetSearchTermOnSelect: y,
      onResetSearchTerm: X.on,
      allItems: oe,
      allGroups: k,
      filterSearch: be,
      filterState: re,
      ignoreFilter: x,
      openOnFocus: I,
      openOnClick: q
    }), (xe, Se) => (Ye(), xn(te(EO), null, {
      default: ln(() => [ze(te(Wb), pl({
        ref_key: "primitiveElement",
        ref: o
      }, xe.$attrs, {
        modelValue: te(M),
        "onUpdate:modelValue": Se[0] || (Se[0] = (ge) => Vn(M) ? M.value = ge : null),
        style: { pointerEvents: te(U) ? "auto" : void 0 },
        as: xe.as,
        "as-child": xe.asChild,
        dir: te(E),
        multiple: te(d),
        name: xe.name,
        required: xe.required,
        disabled: te(h),
        "highlight-on-hover": !0,
        by: a.by,
        onHighlight: Se[1] || (Se[1] = (ge) => s("highlight", ge))
      }), {
        default: ln(() => [qn(xe.$slots, "default", {
          open: te(U),
          modelValue: te(M)
        })]),
        _: 3
      }, 16, [
        "modelValue",
        "style",
        "as",
        "as-child",
        "dir",
        "multiple",
        "name",
        "required",
        "disabled",
        "by"
      ])]),
      _: 3
    }));
  }
}), cw = sw;
const [YC, ow] = vi("ComboboxContent");
var mw = /* @__PURE__ */ dn({
  __name: "ComboboxContentImpl",
  props: {
    position: {
      type: String,
      required: !1,
      default: "inline"
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: l }) {
    const i = e, a = l, { position: s } = St(i), o = pa(), { forwardRef: f, currentElement: d } = Tt();
    K0(i.bodyLock), J0(o.parentElement);
    const h = _e(() => i.position === "popper" ? i : {}), x = Wg(h.value), y = {
      boxSizing: "border-box",
      "--reka-combobox-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-combobox-content-available-width": "var(--reka-popper-available-width)",
      "--reka-combobox-content-available-height": "var(--reka-popper-available-height)",
      "--reka-combobox-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-combobox-trigger-height": "var(--reka-popper-anchor-height)"
    };
    ow({ position: s });
    const I = Fe(!1);
    return vl(() => {
      o.inputElement.value && (I.value = d.value.contains(o.inputElement.value), I.value && o.inputElement.value.focus());
    }), Dt(() => {
      I.value && o.triggerElement.value?.focus();
    }), (q, R) => (Ye(), xn(te(Xb), { "as-child": "" }, {
      default: ln(() => [ze(te(hO), {
        "as-child": "",
        "disable-outside-pointer-events": q.disableOutsidePointerEvents,
        onDismiss: R[0] || (R[0] = (E) => te(o).onOpenChange(!1)),
        onFocusOutside: R[1] || (R[1] = (E) => {
          te(o).parentElement.value?.contains(E.target) && E.preventDefault(), a("focusOutside", E);
        }),
        onInteractOutside: R[2] || (R[2] = (E) => a("interactOutside", E)),
        onEscapeKeyDown: R[3] || (R[3] = (E) => a("escapeKeyDown", E)),
        onPointerDownOutside: R[4] || (R[4] = (E) => {
          te(o).parentElement.value?.contains(E.target) && E.preventDefault(), a("pointerDownOutside", E);
        })
      }, {
        default: ln(() => [(Ye(), xn(xs(te(s) === "popper" ? te(Kb) : te(al)), pl({
          ...q.$attrs,
          ...te(x)
        }, {
          id: te(o).contentId,
          ref: te(f),
          "data-state": te(o).open.value ? "open" : "closed",
          style: {
            display: "flex",
            flexDirection: "column",
            outline: "none",
            ...te(s) === "popper" ? y : {}
          }
        }), {
          default: ln(() => [qn(q.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "data-state",
          "style"
        ]))]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }));
  }
}), fw = mw, dw = /* @__PURE__ */ dn({
  __name: "ComboboxContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    position: {
      type: String,
      required: !1
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: l }) {
    const s = $0(e, l), { forwardRef: o } = Tt(), f = pa();
    return f.contentId ||= fa(void 0, "reka-combobox-content"), (d, h) => (Ye(), xn(te(sO), { present: d.forceMount || te(f).open.value }, {
      default: ln(() => [ze(fw, pl({
        ...te(s),
        ...d.$attrs
      }, { ref: te(o) }), {
        default: ln(() => [qn(d.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"]));
  }
}), pw = dw, hw = /* @__PURE__ */ dn({
  __name: "ComboboxEmpty",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const l = e, i = pa(), a = _e(() => i.ignoreFilter.value ? i.allItems.value.size === 0 : i.filterState.value.count === 0);
    return (s, o) => a.value ? (Ye(), xn(te(al), kc(pl({ key: 0 }, l)), {
      default: ln(() => [qn(s.$slots, "default", {}, () => [o[0] || (o[0] = Gi("No options"))])]),
      _: 3
    }, 16)) : pi("v-if", !0);
  }
}), gw = hw;
const [vw, XC] = vi("ComboboxGroup");
var xw = /* @__PURE__ */ dn({
  __name: "ComboboxInput",
  props: {
    displayValue: {
      type: Function,
      required: !1
    },
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = pa(), o = mo(), { primitiveElement: f, currentElement: d } = zu(), h = Gu(i, "modelValue", a, { passive: i.modelValue === void 0 });
    vl(() => {
      d.value && s.onInputElementChange(d.value);
    });
    function x(E) {
      s.open.value || s.onOpenChange(!0);
    }
    function y(E) {
      const M = E.target;
      s.open.value ? s.filterSearch.value = M.value : (s.onOpenChange(!0), il(() => {
        M.value && (s.filterSearch.value = M.value, o.highlightFirstItem());
      }));
    }
    function I() {
      s.openOnFocus.value && !s.open.value && s.onOpenChange(!0);
    }
    function q() {
      s.openOnClick.value && !s.open.value && s.onOpenChange(!0);
    }
    function R() {
      const E = s.modelValue.value;
      i.displayValue ? h.value = i.displayValue(E) : !s.multiple.value && E && !Array.isArray(E) && typeof E != "object" ? h.value = E.toString() : h.value = "", il(() => {
        h.value = h.value;
      });
    }
    return s.onResetSearchTerm(() => {
      R();
    }), Cn(s.modelValue, async () => {
      !s.isUserInputted.value && s.resetSearchTermOnSelect.value && R();
    }, {
      immediate: !0,
      deep: !0
    }), Cn(s.filterState, () => {
      !s.isVirtual.value && !s.highlightedElement.value && o.highlightFirstItem();
    }), (E, M) => (Ye(), xn(te(Jb), {
      ref_key: "primitiveElement",
      ref: f,
      modelValue: te(h),
      "onUpdate:modelValue": M[0] || (M[0] = (U) => Vn(h) ? h.value = U : null),
      as: E.as,
      "as-child": E.asChild,
      "auto-focus": E.autoFocus,
      disabled: E.disabled,
      "aria-expanded": te(s).open.value,
      "aria-controls": te(s).contentId,
      "aria-autocomplete": "list",
      role: "combobox",
      autocomplete: "off",
      onClick: q,
      onInput: y,
      onKeydown: mi(si(x, ["prevent"]), ["down", "up"]),
      onFocus: I
    }, {
      default: ln(() => [qn(E.$slots, "default")]),
      _: 3
    }, 8, [
      "modelValue",
      "as",
      "as-child",
      "auto-focus",
      "disabled",
      "aria-expanded",
      "aria-controls",
      "onKeydown"
    ]));
  }
}), yw = xw, Iw = /* @__PURE__ */ dn({
  __name: "ComboboxItem",
  props: {
    textValue: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = fa(void 0, "reka-combobox-item"), o = pa(), f = vw(null), { primitiveElement: d, currentElement: h } = zu();
    if (i.value === "") throw new Error("A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.");
    const x = _e(() => {
      if (o.isVirtual.value || o.ignoreFilter.value || !o.filterSearch.value) return !0;
      {
        const y = o.filterState.value.items.get(s);
        return y === void 0 ? !0 : y > 0;
      }
    });
    return vl(() => {
      o.allItems.value.set(s, i.textValue || h.value.textContent || h.value.innerText);
      const y = f?.id;
      y && (o.allGroups.value.has(y) ? o.allGroups.value.get(y)?.add(s) : o.allGroups.value.set(y, /* @__PURE__ */ new Set([s])));
    }), Dt(() => {
      o.allItems.value.delete(s);
    }), (y, I) => x.value ? (Ye(), xn(te(iw), pl({ key: 0 }, i, {
      id: te(s),
      ref_key: "primitiveElement",
      ref: d,
      disabled: te(o).disabled.value || y.disabled,
      onSelect: I[0] || (I[0] = (q) => {
        a("select", q), !q.defaultPrevented && !te(o).multiple.value && !y.disabled && !te(o).disabled.value && (q.preventDefault(), te(o).onOpenChange(!1), te(o).modelValue.value = i.value);
      })
    }), {
      default: ln(() => [qn(y.$slots, "default", {}, () => [Gi(Ul(y.value), 1)])]),
      _: 3
    }, 16, ["id", "disabled"])) : pi("v-if", !0);
  }
}), Lw = Iw, Dw = /* @__PURE__ */ dn({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const l = e;
    return (i, a) => (Ye(), xn(te(aw), kc(mf(l)), {
      default: ln(() => [qn(i.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ow = Dw, bw = /* @__PURE__ */ dn({
  __name: "ComboboxTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const l = e, { forwardRef: i, currentElement: a } = Tt(), s = pa(), o = _e(() => l.disabled || s.disabled.value || !1);
    return vl(() => {
      a.value && s.onTriggerElementChange(a.value);
    }), (f, d) => (Ye(), xn(te(al), pl(l, {
      ref: te(i),
      type: f.as === "button" ? "button" : void 0,
      tabindex: "-1",
      "aria-label": "Show popup",
      "aria-haspopup": "listbox",
      "aria-expanded": te(s).open.value,
      "aria-controls": te(s).contentId,
      "data-state": te(s).open.value ? "open" : "closed",
      disabled: o.value,
      "data-disabled": o.value ? "" : void 0,
      "aria-disabled": o.value ?? void 0,
      onClick: d[0] || (d[0] = (h) => te(s).onOpenChange(!te(s).open.value))
    }), {
      default: ln(() => [qn(f.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "aria-expanded",
      "aria-controls",
      "data-state",
      "disabled",
      "data-disabled",
      "aria-disabled"
    ]));
  }
}), ww = bw;
function dv(e) {
  const l = uo({ nonce: Fe() });
  return _e(() => e?.value || l.nonce?.value);
}
var Sw = /* @__PURE__ */ dn({
  __name: "ComboboxViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const l = e, { forwardRef: i } = Tt(), { nonce: a } = St(l), s = dv(a), o = pa();
    return (f, d) => (Ye(), Yn(Mn, null, [ze(te(al), pl({
      ...f.$attrs,
      ...l
    }, {
      ref: te(i),
      "data-reka-combobox-viewport": "",
      role: "presentation",
      style: {
        position: "relative",
        flex: te(o).isVirtual.value ? void 0 : 1,
        overflow: "auto"
      }
    }), {
      default: ln(() => [qn(f.$slots, "default")]),
      _: 3
    }, 16, ["style"]), ze(te(al), {
      as: "style",
      nonce: te(s)
    }, {
      default: ln(() => d[0] || (d[0] = [Gi(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-combobox-viewport]::-webkit-scrollbar { display: none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), Cw = Sw;
function vn(e, l = "Assertion failed!") {
  if (!e)
    throw console.error(l), new Error(l);
}
function pv(e, l = document) {
  if (!Os) return null;
  if (l instanceof HTMLElement && l?.dataset?.panelGroupId === e) return l;
  const i = l.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return i || null;
}
function fo(e, l = document) {
  if (!Os) return null;
  const i = l.querySelector(`[data-panel-resize-handle-id="${e}"]`);
  return i || null;
}
function hv(e, l, i = document) {
  return Os ? os(e, i).findIndex((o) => o.getAttribute("data-panel-resize-handle-id") === l) ?? null : null;
}
function os(e, l = document) {
  return Os ? Array.from(l.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${e}"]`)) : [];
}
function Tw(e, l, i, a = document) {
  const s = fo(l, a), o = os(e, a), f = s ? o.indexOf(s) : -1, d = i[f]?.id ?? null, h = i[f + 1]?.id ?? null;
  return [d, h];
}
function gv(e) {
  return e.type === "keydown";
}
function vv(e) {
  return e.type.startsWith("mouse");
}
function xv(e) {
  return e.type.startsWith("touch");
}
function po(e) {
  if (vv(e)) return {
    x: e.clientX,
    y: e.clientY
  };
  if (xv(e)) {
    const l = e.touches[0];
    if (l && l.clientX && l.clientY) return {
      x: l.clientX,
      y: l.clientY
    };
  }
  return {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
  };
}
function yv(e, l) {
  const i = e === "horizontal", { x: a, y: s } = po(l);
  return i ? a : s;
}
function Pw(e, l, i, a, s) {
  const o = i === "horizontal", f = fo(l, s);
  vn(f);
  const d = f.getAttribute("data-panel-group-id");
  vn(d);
  const { initialCursorPosition: h } = a, x = yv(i, e), y = pv(d, s);
  vn(y);
  const I = y.getBoundingClientRect(), q = o ? I.width : I.height;
  return (x - h) / q * 100;
}
function qw(e, l, i, a, s, o) {
  if (gv(e)) {
    const f = i === "horizontal";
    let d = 0;
    e.shiftKey ? d = 100 : d = s ?? 10;
    let h = 0;
    switch (e.key) {
      case "ArrowDown":
        h = f ? 0 : d;
        break;
      case "ArrowLeft":
        h = f ? -d : 0;
        break;
      case "ArrowRight":
        h = f ? d : 0;
        break;
      case "ArrowUp":
        h = f ? 0 : -d;
        break;
      case "End":
        h = 100;
        break;
      case "Home":
        h = -100;
        break;
    }
    return h;
  } else
    return a == null ? 0 : Pw(e, l, i, a, o);
}
function Rw({ layout: e, panelsArray: l, pivotIndices: i }) {
  let a = 0, s = 100, o = 0, f = 0;
  const d = i[0];
  vn(d != null), l.forEach((I, q) => {
    const { constraints: R } = I, { maxSize: E = 100, minSize: M = 0 } = R;
    q === d ? (a = M, s = E) : (o += M, f += E);
  });
  const h = Math.min(s, 100 - o), x = Math.max(a, 100 - f), y = e[d];
  return {
    valueMax: h,
    valueMin: x,
    valueNow: y
  };
}
function Aw({ panelDataArray: e }) {
  const l = Array.from({ length: e.length }), i = e.map((o) => o.constraints);
  let a = 0, s = 100;
  for (let o = 0; o < e.length; o++) {
    const f = i[o];
    vn(f);
    const { defaultSize: d } = f;
    d != null && (a++, l[o] = d, s -= d);
  }
  for (let o = 0; o < e.length; o++) {
    const f = i[o];
    vn(f);
    const { defaultSize: d } = f;
    if (d != null) continue;
    const h = e.length - a, x = s / h;
    a++, l[o] = x, s -= x;
  }
  return l;
}
function Cr(e, l, i) {
  l.forEach((a, s) => {
    const o = e[s];
    vn(o);
    const { callbacks: f, constraints: d, id: h } = o, { collapsedSize: x = 0, collapsible: y } = d, I = i[h];
    if (I == null || a !== I) {
      i[h] = a;
      const { onCollapse: q, onExpand: R, onResize: E } = f;
      E && E(a, I), y && (q || R) && (R && (I == null || I === x) && a !== x && R(), q && (I == null || I !== x) && a === x && q());
    }
  });
}
function Ew(e, l = 10) {
  let i = null;
  return (...s) => {
    i !== null && clearTimeout(i), i = setTimeout(() => {
      e(...s);
    }, l);
  };
}
const Pf = 10;
function ms(e, l, i = Pf) {
  e = Number.parseFloat(e.toFixed(i)), l = Number.parseFloat(l.toFixed(i));
  const a = e - l;
  return a === 0 ? 0 : a > 0 ? 1 : -1;
}
function vt(e, l, i) {
  return ms(e, l, i) === 0;
}
function Sa({ panelConstraints: e, panelIndex: l, size: i }) {
  const a = e[l];
  vn(a != null);
  const { collapsedSize: s = 0, collapsible: o, maxSize: f = 100, minSize: d = 0 } = a;
  if (ms(i, d) < 0) if (o) {
    const h = (s + d) / 2;
    ms(i, h) < 0 ? i = s : i = d;
  } else i = d;
  return i = Math.min(f, i), i = Number.parseFloat(i.toFixed(Pf)), i;
}
function js(e, l) {
  if (e.length !== l.length) return !1;
  for (let i = 0; i < e.length; i++) if (e[i] !== l[i]) return !1;
  return !0;
}
function kr({ delta: e, layout: l, panelConstraints: i, pivotIndices: a, trigger: s }) {
  if (vt(e, 0)) return l;
  const o = [...l], [f, d] = a;
  vn(f != null), vn(d != null);
  let h = 0;
  if (s === "keyboard") {
    {
      const y = e < 0 ? d : f, I = i[y];
      if (vn(I), I.collapsible) {
        const q = l[y];
        vn(q != null);
        const R = i[y];
        vn(R);
        const { collapsedSize: E = 0, minSize: M = 0 } = R;
        if (vt(q, E)) {
          const U = M - q;
          ms(U, Math.abs(e)) > 0 && (e = e < 0 ? 0 - U : U);
        }
      }
    }
    {
      const y = e < 0 ? f : d, I = i[y];
      vn(I);
      const { collapsible: q } = I;
      if (q) {
        const R = l[y];
        vn(R != null);
        const E = i[y];
        vn(E);
        const { collapsedSize: M = 0, minSize: U = 0 } = E;
        if (vt(R, U)) {
          const z = R - M;
          ms(z, Math.abs(e)) > 0 && (e = e < 0 ? 0 - z : z);
        }
      }
    }
  }
  {
    const y = e < 0 ? 1 : -1;
    let I = e < 0 ? d : f, q = 0;
    for (; ; ) {
      const E = l[I];
      vn(E != null);
      const U = Sa({
        panelConstraints: i,
        panelIndex: I,
        size: 100
      }) - E;
      if (q += U, I += y, I < 0 || I >= i.length) break;
    }
    const R = Math.min(Math.abs(e), Math.abs(q));
    e = e < 0 ? 0 - R : R;
  }
  {
    let I = e < 0 ? f : d;
    for (; I >= 0 && I < i.length; ) {
      const q = Math.abs(e) - Math.abs(h), R = l[I];
      vn(R != null);
      const E = R - q, M = Sa({
        panelConstraints: i,
        panelIndex: I,
        size: E
      });
      if (!vt(R, M) && (h += R - M, o[I] = M, h.toPrecision(3).localeCompare(Math.abs(e).toPrecision(3), void 0, { numeric: !0 }) >= 0))
        break;
      e < 0 ? I-- : I++;
    }
  }
  if (vt(h, 0)) return l;
  {
    const y = e < 0 ? d : f, I = l[y];
    vn(I != null);
    const q = I + h, R = Sa({
      panelConstraints: i,
      panelIndex: y,
      size: q
    });
    if (o[y] = R, !vt(R, q)) {
      let E = q - R, U = e < 0 ? d : f;
      for (; U >= 0 && U < i.length; ) {
        const z = o[U];
        vn(z != null);
        const X = z + E, B = Sa({
          panelConstraints: i,
          panelIndex: U,
          size: X
        });
        if (vt(z, B) || (E -= B - z, o[U] = B), vt(E, 0)) break;
        e > 0 ? U-- : U++;
      }
    }
  }
  const x = o.reduce((y, I) => I + y, 0);
  return vt(x, 100) ? o : l;
}
function Iv(e, l, i) {
  const a = hv(e, l, i);
  return a != null ? [a, a + 1] : [-1, -1];
}
function _w(e, l, i) {
  return e.x < l.x + l.width && e.x + e.width > l.x && e.y < l.y + l.height && e.y + e.height > l.y;
}
function Nw(e, l) {
  if (e === l) throw new Error("Cannot compare node with itself");
  const i = {
    a: np(e),
    b: np(l)
  };
  let a;
  for (; i.a.at(-1) === i.b.at(-1); )
    e = i.a.pop(), l = i.b.pop(), a = e;
  vn(a);
  const s = {
    a: ep(Jd(i.a)),
    b: ep(Jd(i.b))
  };
  if (s.a === s.b) {
    const o = a.childNodes, f = {
      a: i.a.at(-1),
      b: i.b.at(-1)
    };
    let d = o.length;
    for (; d--; ) {
      const h = o[d];
      if (h === f.a) return 1;
      if (h === f.b) return -1;
    }
  }
  return Math.sign(s.a - s.b);
}
const Fw = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function Mw(e) {
  const l = getComputedStyle(Lv(e)).display;
  return l === "flex" || l === "inline-flex";
}
function kw(e) {
  const l = getComputedStyle(e);
  return !!(l.position === "fixed" || l.zIndex !== "auto" && (l.position !== "static" || Mw(e)) || +l.opacity < 1 || "transform" in l && l.transform !== "none" || "webkitTransform" in l && l.webkitTransform !== "none" || "mixBlendMode" in l && l.mixBlendMode !== "normal" || "filter" in l && l.filter !== "none" || "webkitFilter" in l && l.webkitFilter !== "none" || "isolation" in l && l.isolation === "isolate" || Fw.test(l.willChange) || l.webkitOverflowScrolling === "touch");
}
function Jd(e) {
  let l = e.length;
  for (; l--; ) {
    const i = e[l];
    if (vn(i), kw(i)) return i;
  }
  return null;
}
function ep(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function np(e) {
  const l = [];
  for (; e; )
    l.push(e), e = Lv(e);
  return l;
}
function Lv(e) {
  return e.parentNode instanceof DocumentFragment && e.parentNode?.host || e.parentNode;
}
const Dv = 1, Ov = 2, bv = 4, wv = 8;
function Vw() {
  if (typeof matchMedia == "function") return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
const Bw = Vw() === "coarse", $u = [];
let ho = !1;
const ku = /* @__PURE__ */ new Map(), go = /* @__PURE__ */ new Map(), fs = /* @__PURE__ */ new Set();
function Zw(e, l, i, a, s, o) {
  const { ownerDocument: f } = l, d = {
    direction: i,
    element: l,
    hitAreaMargins: a,
    nonce: s,
    setResizeHandlerState: o
  }, h = ku.get(f) ?? 0;
  return ku.set(f, h + 1), fs.add(d), Ac(), function() {
    go.delete(e), fs.delete(d);
    const y = ku.get(f) ?? 1;
    ku.set(f, y - 1), Ac(), Cv(), y === 1 && ku.delete(f);
  };
}
function Hs(e) {
  const { target: l } = e, { x: i, y: a } = po(e);
  ho = !0, qf({
    target: l,
    x: i,
    y: a
  }), Ac(), $u.length > 0 && (Rf("down", e), e.preventDefault());
}
function Pu(e) {
  const { x: l, y: i } = po(e);
  if (!ho) {
    const { target: a } = e;
    qf({
      target: a,
      x: l,
      y: i
    });
  }
  Rf("move", e), Sv(), $u.length > 0 && e.preventDefault();
}
function qu(e) {
  const { target: l } = e, { x: i, y: a } = po(e);
  go.clear(), ho = !1, $u.length > 0 && e.preventDefault(), Rf("up", e), qf({
    target: l,
    x: i,
    y: a
  }), Sv(), Ac();
}
function qf({ target: e, x: l, y: i }) {
  $u.splice(0);
  let a = null;
  e instanceof HTMLElement && (a = e), fs.forEach((s) => {
    const { element: o, hitAreaMargins: f } = s, d = o.getBoundingClientRect(), { bottom: h, left: x, right: y, top: I } = d, q = Bw ? f.coarse : f.fine;
    if (l >= x - q && l <= y + q && i >= I - q && i <= h + q) {
      if (a !== null && o !== a && !o.contains(a) && !a.contains(o) && Nw(a, o) > 0) {
        let E = a, M = !1;
        for (; E && !E.contains(o); ) {
          if (_w(E.getBoundingClientRect(), d)) {
            M = !0;
            break;
          }
          E = E.parentElement;
        }
        if (M) return;
      }
      $u.push(s);
    }
  });
}
function ko(e, l) {
  go.set(e, l);
}
function Sv() {
  let e = !1, l = !1, i;
  $u.forEach((s) => {
    const { direction: o, nonce: f } = s;
    o.value === "horizontal" ? e = !0 : l = !0, i = f.value;
  });
  let a = 0;
  go.forEach((s) => {
    a |= s;
  }), e && l ? Vo("intersection", a, i) : e ? Vo("horizontal", a, i) : l ? Vo("vertical", a, i) : Cv();
}
function Ac() {
  ku.forEach((e, l) => {
    const { body: i } = l;
    i.removeEventListener("contextmenu", qu), i.removeEventListener("mousedown", Hs), i.removeEventListener("mouseleave", Pu), i.removeEventListener("mousemove", Pu), i.removeEventListener("touchmove", Pu), i.removeEventListener("touchstart", Hs);
  }), window.removeEventListener("mouseup", qu), window.removeEventListener("touchcancel", qu), window.removeEventListener("touchend", qu), fs.size > 0 && (ho ? ($u.length > 0 && ku.forEach((e, l) => {
    const { body: i } = l;
    e > 0 && (i.addEventListener("contextmenu", qu), i.addEventListener("mouseleave", Pu), i.addEventListener("mousemove", Pu), i.addEventListener("touchmove", Pu, { passive: !1 }));
  }), window.addEventListener("mouseup", qu), window.addEventListener("touchcancel", qu), window.addEventListener("touchend", qu)) : ku.forEach((e, l) => {
    const { body: i } = l;
    e > 0 && (i.addEventListener("mousedown", Hs), i.addEventListener("mousemove", Pu), i.addEventListener("touchmove", Pu, { passive: !1 }), i.addEventListener("touchstart", Hs));
  }));
}
function Rf(e, l) {
  fs.forEach((i) => {
    const { setResizeHandlerState: a } = i, s = $u.includes(i);
    a(e, s, l);
  });
}
let km = null, Vu = null;
function Uw(e, l) {
  if (l) {
    const i = (l & Dv) !== 0, a = (l & Ov) !== 0, s = (l & bv) !== 0, o = (l & wv) !== 0;
    if (i) return s ? "se-resize" : o ? "ne-resize" : "e-resize";
    if (a) return s ? "sw-resize" : o ? "nw-resize" : "w-resize";
    if (s) return "s-resize";
    if (o) return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function Cv() {
  Vu !== null && (document.head.removeChild(Vu), km = null, Vu = null);
}
function Vo(e, l, i) {
  const a = Uw(e, l);
  km !== a && (km = a, Vu === null && (Vu = document.createElement("style"), i && (Vu.nonce = i), document.head.appendChild(Vu)), Vu.innerHTML = `*{cursor: ${a}!important;}`);
}
function Kw({ defaultSize: e, dragState: l, layout: i, panelData: a, panelIndex: s, precision: o = 3 }) {
  const f = i[s];
  let d;
  return f == null ? d = e !== void 0 ? e.toPrecision(o) : "1" : a.length === 1 ? d = "1" : d = f.toPrecision(o), {
    flexBasis: 0,
    flexGrow: d,
    flexShrink: 1,
    overflow: "hidden",
    pointerEvents: l !== null ? "none" : void 0
  };
}
function Gw({ layout: e, panelConstraints: l }) {
  const i = [...e], a = i.reduce((o, f) => o + f, 0);
  if (i.length !== l.length) throw new Error(`Invalid ${l.length} panel layout: ${i.map((o) => `${o}%`).join(", ")}`);
  if (!vt(a, 100)) {
    console.warn(`WARNING: Invalid layout total size: ${i.map((o) => `${o}%`).join(", ")}. Layout normalization will be applied.`);
    for (let o = 0; o < l.length; o++) {
      const f = i[o];
      vn(f != null);
      const d = 100 / a * f;
      i[o] = d;
    }
  }
  let s = 0;
  for (let o = 0; o < l.length; o++) {
    const f = i[o];
    vn(f != null);
    const d = Sa({
      panelConstraints: l,
      panelIndex: o,
      size: f
    });
    f !== d && (s += f - d, i[o] = d);
  }
  if (!vt(s, 0)) for (let o = 0; o < l.length; o++) {
    const f = i[o];
    vn(f != null);
    const d = f + s, h = Sa({
      panelConstraints: l,
      panelIndex: o,
      size: d
    });
    if (f !== h && (s -= h - f, i[o] = h, vt(s, 0)))
      break;
  }
  return i;
}
function zw({ eagerValuesRef: e, groupId: l, layout: i, panelDataArray: a, panelGroupElement: s, setLayout: o }) {
  Ml((f) => {
    const d = s.value;
    if (!d) return;
    const h = os(l, d);
    for (let x = 0; x < a.length - 1; x++) {
      const { valueMax: y, valueMin: I, valueNow: q } = Rw({
        layout: i.value,
        panelsArray: a,
        pivotIndices: [x, x + 1]
      }), R = h[x];
      if (R != null) {
        const E = a[x];
        vn(E), R.setAttribute("aria-controls", E.id), R.setAttribute("aria-valuemax", `${Math.round(y)}`), R.setAttribute("aria-valuemin", `${Math.round(I)}`), R.setAttribute("aria-valuenow", q != null ? `${Math.round(q)}` : "");
      }
    }
    f(() => {
      h.forEach((x) => {
        x.removeAttribute("aria-controls"), x.removeAttribute("aria-valuemax"), x.removeAttribute("aria-valuemin"), x.removeAttribute("aria-valuenow");
      });
    });
  }), Ml((f) => {
    const d = s.value;
    if (!d) return;
    const h = e.value;
    vn(h);
    const { panelDataArray: x } = h, y = pv(l, d);
    vn(y != null, `No group found for id "${l}"`);
    const I = os(l, d);
    vn(I);
    const q = I.map((R) => {
      const E = R.getAttribute("data-panel-resize-handle-id");
      vn(E);
      const [M, U] = Tw(l, E, x, d);
      if (M == null || U == null) return () => {
      };
      const z = (X) => {
        if (!X.defaultPrevented)
          switch (X.key) {
            case "Enter": {
              X.preventDefault();
              const B = x.findIndex((K) => K.id === M);
              if (B >= 0) {
                const K = x[B];
                vn(K);
                const W = i.value[B], { collapsedSize: ae = 0, collapsible: ne, minSize: oe = 0 } = K.constraints;
                if (W != null && ne) {
                  const k = kr({
                    delta: vt(W, ae) ? oe - ae : ae - W,
                    layout: i.value,
                    panelConstraints: x.map((me) => me.constraints),
                    pivotIndices: Iv(l, E, d),
                    trigger: "keyboard"
                  });
                  i.value !== k && o(k);
                }
              }
              break;
            }
          }
      };
      return R.addEventListener("keydown", z), () => {
        R.removeEventListener("keydown", z);
      };
    });
    f(() => {
      q.forEach((R) => R());
    });
  });
}
function lp(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (l) => localStorage.getItem(l), e.setItem = (l, i) => {
        localStorage.setItem(l, i);
      };
    else throw new TypeError("localStorage not supported in this environment");
  } catch (l) {
    console.error(l), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function Tv(e) {
  return `reka:${e}`;
}
function Pv(e) {
  return e.map((l) => {
    const { constraints: i, id: a, idIsFromProps: s, order: o } = l;
    return s ? a : o ? `${o}:${JSON.stringify(i)}` : JSON.stringify(i);
  }).sort((l, i) => l.localeCompare(i)).join(",");
}
function qv(e, l) {
  try {
    const i = Tv(e), a = l.getItem(i);
    if (a) {
      const s = JSON.parse(a);
      if (typeof s == "object" && s != null) return s;
    }
  } catch {
  }
  return null;
}
function jw(e, l, i) {
  const a = qv(e, i) ?? {}, s = Pv(l);
  return a[s] ?? null;
}
function Hw(e, l, i, a, s) {
  const o = Tv(e), f = Pv(l), d = qv(e, s) ?? {};
  d[f] = {
    expandToSizes: Object.fromEntries(i.entries()),
    layout: a
  };
  try {
    s.setItem(o, JSON.stringify(d));
  } catch (h) {
    console.error(h);
  }
}
const $w = 100, Vr = {
  getItem: (e) => (lp(Vr), Vr.getItem(e)),
  setItem: (e, l) => {
    lp(Vr), Vr.setItem(e, l);
  }
}, [Rv, Ww] = vi("PanelGroup");
var Yw = /* @__PURE__ */ dn({
  __name: "SplitterGroup",
  props: {
    id: {
      type: [String, null],
      required: !1
    },
    autoSaveId: {
      type: [String, null],
      required: !1,
      default: null
    },
    direction: {
      type: String,
      required: !0
    },
    keyboardResizeBy: {
      type: [Number, null],
      required: !1,
      default: 10
    },
    storage: {
      type: Object,
      required: !1,
      default: () => Vr
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["layout"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = {}, { direction: o } = St(i), f = fa(i.id, "reka-splitter-group"), d = bs(), { forwardRef: h, currentElement: x } = Tt(), y = Fe(null), I = Fe([]), q = Fe({}), R = Fe(/* @__PURE__ */ new Map()), E = Fe(0), M = _e(() => ({
      autoSaveId: i.autoSaveId,
      direction: i.direction,
      dragState: y.value,
      id: f,
      keyboardResizeBy: i.keyboardResizeBy,
      storage: i.storage
    })), U = Fe({
      layout: I.value,
      panelDataArray: [],
      panelDataArrayChanged: !1
    }), z = (ce) => I.value = ce;
    zw({
      eagerValuesRef: U,
      groupId: f,
      layout: I,
      panelDataArray: U.value.panelDataArray,
      setLayout: z,
      panelGroupElement: x
    }), Ml(() => {
      const { panelDataArray: ce } = U.value, { autoSaveId: de } = i;
      if (de) {
        if (I.value.length === 0 || I.value.length !== ce.length) return;
        let Le = s[de];
        Le || (Le = Ew(Hw, $w), s[de] = Le);
        const Ae = [...ce], We = new Map(R.value);
        Le(de, Ae, We, I.value, i.storage);
      }
    });
    function X(ce, de) {
      const { panelDataArray: Le } = U.value, Ae = Se(Le, ce);
      return Kw({
        defaultSize: de,
        dragState: y.value,
        layout: I.value,
        panelData: Le,
        panelIndex: Ae
      });
    }
    function B(ce) {
      const { panelDataArray: de } = U.value;
      de.push(ce), de.sort((Le, Ae) => {
        const We = Le.order, je = Ae.order;
        return We == null && je == null ? 0 : We == null ? -1 : je == null ? 1 : We - je;
      }), U.value.panelDataArrayChanged = !0;
    }
    Cn(() => U.value.panelDataArrayChanged, () => {
      if (U.value.panelDataArrayChanged) {
        U.value.panelDataArrayChanged = !1;
        const { autoSaveId: ce, storage: de } = M.value, { layout: Le, panelDataArray: Ae } = U.value;
        let We = null;
        if (ce) {
          const cn = jw(ce, Ae, de);
          cn && (R.value = new Map(Object.entries(cn.expandToSizes)), We = cn.layout);
        }
        We === null && (We = Aw({ panelDataArray: Ae }));
        const je = Gw({
          layout: We,
          panelConstraints: Ae.map((cn) => cn.constraints)
        });
        S0(Le, je) || (z(je), U.value.layout = je, a("layout", je), Cr(Ae, je, q.value));
      }
    });
    function K(ce) {
      return function(Le) {
        Le.preventDefault();
        const Ae = x.value;
        if (!Ae) return () => null;
        const { direction: We, dragState: je, id: cn, keyboardResizeBy: bn } = M.value, { layout: gn, panelDataArray: tn } = U.value, { initialLayout: V } = je ?? {}, _ = Iv(cn, ce, Ae);
        let Z = qw(Le, ce, We, je, bn, Ae);
        if (Z === 0) return;
        const ue = We === "horizontal";
        d.value === "rtl" && ue && (Z = -Z);
        const Qe = tn.map((ie) => ie.constraints), De = kr({
          delta: Z,
          layout: V ?? gn,
          panelConstraints: Qe,
          pivotIndices: _,
          trigger: gv(Le) ? "keyboard" : "mouse-or-touch"
        }), j = !js(gn, De);
        (vv(Le) || xv(Le)) && E.value !== Z && (E.value = Z, j ? ko(ce, 0) : ue ? ko(ce, Z < 0 ? Dv : Ov) : ko(ce, Z < 0 ? bv : wv)), j && (z(De), U.value.layout = De, a("layout", De), Cr(tn, De, q.value));
      };
    }
    function W(ce, de) {
      const { layout: Le, panelDataArray: Ae } = U.value, We = Ae.map((V) => V.constraints), { panelSize: je, pivotIndices: cn } = ge(Ae, ce, Le);
      vn(je != null);
      const gn = Se(Ae, ce) === Ae.length - 1 ? je - de : de - je, tn = kr({
        delta: gn,
        layout: Le,
        panelConstraints: We,
        pivotIndices: cn,
        trigger: "imperative-api"
      });
      js(Le, tn) || (z(tn), U.value.layout = tn, a("layout", tn), Cr(Ae, tn, q.value));
    }
    function ae(ce, de) {
      const { layout: Le, panelDataArray: Ae } = U.value, We = Se(Ae, ce);
      Ae[We] = ce, U.value.panelDataArrayChanged = !0;
      const { collapsedSize: je = 0, collapsible: cn } = de, { collapsedSize: bn = 0, collapsible: gn, maxSize: tn = 100, minSize: V = 0 } = ce.constraints, { panelSize: _ } = ge(Ae, ce, Le);
      _ !== null && (cn && gn && _ === je ? je !== bn && W(ce, bn) : _ < V ? W(ce, V) : _ > tn && W(ce, tn));
    }
    function ne(ce, de) {
      const { direction: Le } = M.value, { layout: Ae } = U.value;
      if (!x.value) return;
      const We = fo(ce, x.value);
      vn(We);
      const je = yv(Le, de);
      y.value = {
        dragHandleId: ce,
        dragHandleRect: We.getBoundingClientRect(),
        initialCursorPosition: je,
        initialLayout: Ae
      };
    }
    function oe() {
      y.value = null;
    }
    function k(ce) {
      const { panelDataArray: de } = U.value, Le = Se(de, ce);
      Le >= 0 && (de.splice(Le, 1), delete q.value[ce.id], U.value.panelDataArrayChanged = !0);
    }
    function me(ce) {
      const { layout: de, panelDataArray: Le } = U.value;
      if (ce.constraints.collapsible) {
        const Ae = Le.map((bn) => bn.constraints), { collapsedSize: We = 0, panelSize: je, pivotIndices: cn } = ge(Le, ce, de);
        if (vn(je != null, `Panel size not found for panel "${ce.id}"`), je !== We) {
          R.value.set(ce.id, je);
          const gn = Se(Le, ce) === Le.length - 1 ? je - We : We - je, tn = kr({
            delta: gn,
            layout: de,
            panelConstraints: Ae,
            pivotIndices: cn,
            trigger: "imperative-api"
          });
          js(de, tn) || (z(tn), U.value.layout = tn, a("layout", tn), Cr(Le, tn, q.value));
        }
      }
    }
    function be(ce) {
      const { layout: de, panelDataArray: Le } = U.value;
      if (ce.constraints.collapsible) {
        const Ae = Le.map((gn) => gn.constraints), { collapsedSize: We = 0, panelSize: je, minSize: cn = 0, pivotIndices: bn } = ge(Le, ce, de);
        if (je === We) {
          const gn = R.value.get(ce.id), tn = gn != null && gn >= cn ? gn : cn, _ = Se(Le, ce) === Le.length - 1 ? je - tn : tn - je, Z = kr({
            delta: _,
            layout: de,
            panelConstraints: Ae,
            pivotIndices: bn,
            trigger: "imperative-api"
          });
          js(de, Z) || (z(Z), U.value.layout = Z, a("layout", Z), Cr(Le, Z, q.value));
        }
      }
    }
    function re(ce) {
      const { layout: de, panelDataArray: Le } = U.value, { panelSize: Ae } = ge(Le, ce, de);
      return vn(Ae != null, `Panel size not found for panel "${ce.id}"`), Ae;
    }
    function ye(ce) {
      const { layout: de, panelDataArray: Le } = U.value, { collapsedSize: Ae = 0, collapsible: We, panelSize: je } = ge(Le, ce, de);
      return We ? je === void 0 ? ce.constraints.defaultSize === ce.constraints.collapsedSize : je === Ae : !1;
    }
    function xe(ce) {
      const { layout: de, panelDataArray: Le } = U.value, { collapsedSize: Ae = 0, collapsible: We, panelSize: je } = ge(Le, ce, de);
      return vn(je != null, `Panel size not found for panel "${ce.id}"`), !We || je > Ae;
    }
    Ww({
      direction: o,
      dragState: y.value,
      groupId: f,
      reevaluatePanelConstraints: ae,
      registerPanel: B,
      registerResizeHandle: K,
      resizePanel: W,
      startDragging: ne,
      stopDragging: oe,
      unregisterPanel: k,
      panelGroupElement: x,
      collapsePanel: me,
      expandPanel: be,
      isPanelCollapsed: ye,
      isPanelExpanded: xe,
      getPanelSize: re,
      getPanelStyle: X
    });
    function Se(ce, de) {
      return ce.findIndex((Le) => Le === de || Le.id === de.id);
    }
    function ge(ce, de, Le) {
      const Ae = Se(ce, de), je = Ae === ce.length - 1 ? [Ae - 1, Ae] : [Ae, Ae + 1], cn = Le[Ae];
      return {
        ...de.constraints,
        panelSize: cn,
        pivotIndices: je
      };
    }
    return (ce, de) => (Ye(), xn(te(al), {
      ref: te(h),
      as: ce.as,
      "as-child": ce.asChild,
      style: Hi({
        display: "flex",
        flexDirection: te(o) === "horizontal" ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
      }),
      "data-panel-group": "",
      "data-orientation": te(o),
      "data-panel-group-id": te(f)
    }, {
      default: ln(() => [qn(ce.$slots, "default", { layout: I.value })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "style",
      "data-orientation",
      "data-panel-group-id"
    ]));
  }
}), Xw = Yw, Qw = /* @__PURE__ */ dn({
  __name: "SplitterPanel",
  props: {
    collapsedSize: {
      type: Number,
      required: !1
    },
    collapsible: {
      type: Boolean,
      required: !1
    },
    defaultSize: {
      type: Number,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    maxSize: {
      type: Number,
      required: !1
    },
    minSize: {
      type: Number,
      required: !1
    },
    order: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "collapse",
    "expand",
    "resize"
  ],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, o = Rv();
    if (o === null) throw new Error("SplitterPanel components must be rendered within a SplitterGroup container");
    const { collapsePanel: f, expandPanel: d, getPanelSize: h, getPanelStyle: x, isPanelCollapsed: y, resizePanel: I, groupId: q, reevaluatePanelConstraints: R, registerPanel: E, unregisterPanel: M } = o, U = fa(a.id, "reka-splitter-panel"), z = _e(() => ({
      callbacks: {
        onCollapse: () => s("collapse"),
        onExpand: () => s("expand"),
        onResize: (...oe) => s("resize", ...oe)
      },
      constraints: {
        collapsedSize: a.collapsedSize && Number.parseFloat(a.collapsedSize.toFixed(Pf)),
        collapsible: a.collapsible,
        defaultSize: a.defaultSize,
        maxSize: a.maxSize,
        minSize: a.minSize
      },
      id: U,
      idIsFromProps: a.id !== void 0,
      order: a.order
    }));
    Cn(() => z.value.constraints, (oe, k) => {
      (k.collapsedSize !== oe.collapsedSize || k.collapsible !== oe.collapsible || k.maxSize !== oe.maxSize || k.minSize !== oe.minSize) && R(z.value, k);
    }, { deep: !0 }), vl(() => {
      E(z.value);
    }), Dt(() => {
      M(z.value);
    });
    const X = _e(() => x(z.value, a.defaultSize)), B = _e(() => y(z.value)), K = _e(() => !B.value);
    function W() {
      f(z.value);
    }
    function ae() {
      d(z.value);
    }
    function ne(oe) {
      I(z.value, oe);
    }
    return l({
      collapse: W,
      expand: ae,
      getSize() {
        return h(z.value);
      },
      resize: ne,
      isCollapsed: B,
      isExpanded: K
    }), (oe, k) => (Ye(), xn(te(al), {
      id: te(U),
      style: Hi(X.value),
      as: oe.as,
      "as-child": oe.asChild,
      "data-panel": "",
      "data-panel-collapsible": oe.collapsible || void 0,
      "data-panel-group-id": te(q),
      "data-panel-id": te(U),
      "data-panel-size": Number.parseFloat(`${X.value.flexGrow}`).toFixed(1),
      "data-state": oe.collapsible ? B.value ? "collapsed" : "expanded" : void 0
    }, {
      default: ln(() => [qn(oe.$slots, "default", {
        isCollapsed: B.value,
        isExpanded: K.value,
        expand: ae,
        collapse: W,
        resize: ne
      })]),
      _: 3
    }, 8, [
      "id",
      "style",
      "as",
      "as-child",
      "data-panel-collapsible",
      "data-panel-group-id",
      "data-panel-id",
      "data-panel-size",
      "data-state"
    ]));
  }
}), tp = Qw;
function Jw({ disabled: e, handleId: l, resizeHandler: i, panelGroupElement: a }) {
  Ml((s) => {
    const o = a.value;
    if (e.value || i.value === null || o === null) return;
    const f = fo(l, o);
    if (f == null) return;
    const d = (h) => {
      if (!h.defaultPrevented)
        switch (h.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            h.preventDefault(), i.value?.(h);
            break;
          }
          case "F6": {
            h.preventDefault();
            const x = f.getAttribute("data-panel-group-id");
            vn(x);
            const y = os(x, o), I = hv(x, l, o);
            vn(I !== null);
            const q = h.shiftKey ? I > 0 ? I - 1 : y.length - 1 : I + 1 < y.length ? I + 1 : 0;
            y[q].focus();
            break;
          }
        }
    };
    f.addEventListener("keydown", d), s(() => {
      f.removeEventListener("keydown", d);
    });
  });
}
var eS = /* @__PURE__ */ dn({
  __name: "SplitterResizeHandle",
  props: {
    id: {
      type: String,
      required: !1
    },
    hitAreaMargins: {
      type: Object,
      required: !1
    },
    tabindex: {
      type: Number,
      required: !1,
      default: 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["dragging"],
  setup(e, { emit: l }) {
    const i = e, a = l, { forwardRef: s, currentElement: o } = Tt(), { disabled: f } = St(i), d = Rv();
    if (d === null) throw new Error("PanelResizeHandle components must be rendered within a PanelGroup container");
    const { direction: h, groupId: x, registerResizeHandle: y, startDragging: I, stopDragging: q, panelGroupElement: R } = d, E = fa(i.id, "reka-splitter-resize-handle"), M = Fe("inactive"), U = Fe(!1), z = Fe(null), { nonce: X } = St(i), B = dv(X);
    return Cn(f, () => {
      Os && (f.value ? z.value = null : z.value = y(E));
    }, { immediate: !0 }), Ml((K) => {
      if (f.value || z.value === null) return;
      const W = o.value;
      if (!W) return;
      vn(W);
      const ae = (ne, oe, k) => {
        if (oe) switch (ne) {
          case "down": {
            M.value = "drag", I(E, k), a("dragging", !0);
            break;
          }
          case "move": {
            M.value !== "drag" && (M.value = "hover"), z.value?.(k);
            break;
          }
          case "up": {
            M.value = "hover", q(), a("dragging", !1);
            break;
          }
        }
        else M.value = "inactive";
      };
      K(Zw(E, W, h, {
        coarse: i.hitAreaMargins?.coarse ?? 15,
        fine: i.hitAreaMargins?.fine ?? 5
      }, B, ae));
    }), Jw({
      disabled: f,
      resizeHandler: z,
      handleId: E,
      panelGroupElement: R
    }), (K, W) => (Ye(), xn(te(al), {
      id: te(E),
      ref: te(s),
      style: {
        touchAction: "none",
        userSelect: "none"
      },
      as: K.as,
      "as-child": K.asChild,
      role: "separator",
      "data-resize-handle": "",
      tabindex: K.tabindex,
      "data-state": M.value,
      "data-disabled": te(f) ? "" : void 0,
      "data-orientation": te(h),
      "data-panel-group-id": te(x),
      "data-resize-handle-active": M.value === "drag" ? "pointer" : U.value ? "keyboard" : void 0,
      "data-resize-handle-state": M.value,
      "data-panel-resize-handle-enabled": !te(f),
      "data-panel-resize-handle-id": te(E),
      onBlur: W[0] || (W[0] = (ae) => U.value = !1),
      onFocus: W[1] || (W[1] = (ae) => U.value = !1)
    }, {
      default: ln(() => [qn(K.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "tabindex",
      "data-state",
      "data-disabled",
      "data-orientation",
      "data-panel-group-id",
      "data-resize-handle-active",
      "data-resize-handle-state",
      "data-panel-resize-handle-enabled",
      "data-panel-resize-handle-id"
    ]));
  }
}), nS = eS;
function Ec(e) {
  return e.reduce((l, i) => (l.push(i), i.children && l.push(...Ec(i.children)), l), []);
}
const [lS, tS] = vi("TreeRoot");
var iS = /* @__PURE__ */ dn({
  __name: "TreeRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    items: {
      type: Array,
      required: !1
    },
    expanded: {
      type: Array,
      required: !1
    },
    defaultExpanded: {
      type: Array,
      required: !1
    },
    getKey: {
      type: Function,
      required: !0
    },
    getChildren: {
      type: Function,
      required: !1,
      default: (e) => e.children
    },
    selectionBehavior: {
      type: String,
      required: !1,
      default: "toggle"
    },
    multiple: {
      type: Boolean,
      required: !1,
      skipCheck: !0
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    propagateSelect: {
      type: Boolean,
      required: !1
    },
    bubbleSelect: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "ul"
    }
  },
  emits: ["update:modelValue", "update:expanded"],
  setup(e, { emit: l }) {
    const i = e, a = l, { items: s, multiple: o, disabled: f, propagateSelect: d, dir: h, bubbleSelect: x } = St(i), { handleTypeaheadSearch: y } = Xg(), I = bs(h), q = Fe(), R = Fe(!1), E = Wr(), M = Gu(i, "modelValue", a, {
      defaultValue: i.defaultValue ?? (o.value ? [] : void 0),
      passive: !0,
      deep: !0
    }), U = Gu(i, "expanded", a, {
      defaultValue: i.defaultExpanded ?? [],
      passive: i.expanded === void 0,
      deep: !0
    }), { onSelectItem: z, handleMultipleReplace: X } = lO(M, i), B = _e(() => o.value && Array.isArray(M.value) ? M.value.map((k) => i.getKey(k)) : [i.getKey(M.value ?? {})]);
    function K(k, me = 1, be) {
      return k.reduce((re, ye, xe) => {
        const Se = i.getKey(ye), ge = i.getChildren(ye), ce = U.value.includes(Se), de = {
          _id: Se,
          value: ye,
          index: xe,
          level: me,
          parentItem: be,
          hasChildren: !!ge,
          bind: {
            value: ye,
            level: me,
            "aria-setsize": k.length,
            "aria-posinset": xe + 1
          }
        };
        return re.push(de), ge && ce && re.push(...K(ge, me + 1, ye)), re;
      }, []);
    }
    const W = _e(() => {
      const k = i.items;
      return U.value.map((me) => me), K(k ?? []);
    });
    function ae(k) {
      if (R.value) E.trigger(k);
      else {
        const me = q.value?.getItems() ?? [];
        y(k.key, me);
      }
    }
    function ne(k) {
      if (R.value) return;
      const me = Jg[k.key];
      il(() => {
        X(me, Za(), q.value?.getItems, W.value.map((be) => be.value));
      });
    }
    function oe(k) {
      if (k.parentItem != null && Array.isArray(M.value) && i.multiple) {
        const me = W.value.find((be) => k.parentItem != null && i.getKey(be.value) === i.getKey(k.parentItem));
        me != null && (i.getChildren(me.value)?.every((re) => M.value.find((ye) => i.getKey(ye) === i.getKey(re))) ? M.value = [...M.value, me.value] : M.value = M.value.filter((re) => i.getKey(re) !== i.getKey(me.value)), oe(me));
      }
    }
    return tS({
      modelValue: M,
      selectedKeys: B,
      onSelect: (k) => {
        const me = (re) => i.getKey(re ?? {}) === i.getKey(k), be = i.multiple && Array.isArray(M.value) ? M.value?.findIndex(me) !== -1 : void 0;
        if (z(k, me), i.bubbleSelect && i.multiple && Array.isArray(M.value)) {
          const re = W.value.find((ye) => i.getKey(ye.value) === i.getKey(k));
          re != null && oe(re);
        }
        if (i.propagateSelect && i.multiple && Array.isArray(M.value)) {
          const re = Ec(i.getChildren(k) ?? []);
          be ? M.value = [...M.value].filter((ye) => !re.some((xe) => i.getKey(ye ?? {}) === i.getKey(xe))) : M.value = [...M.value, ...re];
        }
      },
      expanded: U,
      onToggle(k) {
        if (!(k ? i.getChildren(k) : void 0)) return;
        const be = i.getKey(k) ?? k;
        U.value.includes(be) ? U.value = U.value.filter((re) => re !== be) : U.value.push(be);
      },
      getKey: i.getKey,
      getChildren: i.getChildren,
      items: s,
      expandedItems: W,
      disabled: f,
      multiple: o,
      dir: I,
      propagateSelect: d,
      bubbleSelect: x,
      isVirtual: R,
      virtualKeydownHook: E,
      handleMultipleReplace: X
    }), (k, me) => (Ye(), xn(te(OO), {
      ref_key: "rovingFocusGroupRef",
      ref: q,
      "as-child": "",
      orientation: "vertical",
      dir: te(I)
    }, {
      default: ln(() => [ze(te(al), {
        role: "tree",
        as: k.as,
        "as-child": k.asChild,
        "aria-multiselectable": te(o) ? !0 : void 0,
        onKeydown: [ae, mi(si(ne, ["shift"]), ["up", "down"])]
      }, {
        default: ln(() => [qn(k.$slots, "default", {
          flattenItems: W.value,
          modelValue: te(M),
          expanded: te(U)
        })]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-multiselectable",
        "onKeydown"
      ])]),
      _: 3
    }, 8, ["dir"]));
  }
}), uS = iS;
const aS = "tree.select", rS = "tree.toggle";
var sS = /* @__PURE__ */ dn({
  inheritAttrs: !1,
  __name: "TreeItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    level: {
      type: Number,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "li"
    }
  },
  emits: ["select", "toggle"],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, o = lS(), { getItems: f } = Ya(), d = _e(() => !!o.getChildren(a.value)), h = _e(() => {
      const z = o.getKey(a.value);
      return o.expanded.value.includes(z);
    }), x = _e(() => {
      const z = o.getKey(a.value);
      return o.selectedKeys.value.includes(z);
    }), y = _e(() => {
      if (o.bubbleSelect.value && d.value && Array.isArray(o.modelValue.value)) {
        const z = Ec(o.getChildren(a.value) || []);
        return z.some((X) => o.modelValue.value.find((B) => o.getKey(B) === o.getKey(X))) && !z.every((X) => o.modelValue.value.find((B) => o.getKey(B) === o.getKey(X)));
      } else return o.propagateSelect.value && x.value && d.value && Array.isArray(o.modelValue.value) ? !Ec(o.getChildren(a.value) || []).every((X) => o.modelValue.value.find((B) => o.getKey(B) === o.getKey(X))) : void 0;
    });
    function I(z) {
      if (d.value)
        if (h.value) {
          const X = f().map((ne) => ne.ref), B = Za(), K = X.indexOf(B), ae = [...X].slice(K).find((ne) => Number(ne.getAttribute("data-indent")) === a.level + 1);
          ae && ae.focus();
        } else U(z);
    }
    function q(z) {
      if (h.value) U(z);
      else {
        const X = f().map((ne) => ne.ref), B = Za(), K = X.indexOf(B), ae = [...X].slice(0, K).reverse().find((ne) => Number(ne.getAttribute("data-indent")) === a.level - 1);
        ae && ae.focus();
      }
    }
    async function R(z) {
      s("select", z), !z?.defaultPrevented && o.onSelect(a.value);
    }
    async function E(z) {
      s("toggle", z), !z?.defaultPrevented && o.onToggle(a.value);
    }
    async function M(z) {
      if (!z) return;
      const X = {
        originalEvent: z,
        value: a.value,
        isExpanded: h.value,
        isSelected: x.value
      };
      rs(aS, R, X);
    }
    async function U(z) {
      if (!z) return;
      const X = {
        originalEvent: z,
        value: a.value,
        isExpanded: h.value,
        isSelected: x.value
      };
      rs(rS, E, X);
    }
    return l({
      isExpanded: h,
      isSelected: x,
      isIndeterminate: y,
      handleToggle: () => o.onToggle(a.value),
      handleSelect: () => o.onSelect(a.value)
    }), (z, X) => (Ye(), xn(te(wO), {
      "as-child": "",
      value: z.value,
      "allow-shift-key": ""
    }, {
      default: ln(() => [ze(te(al), pl(z.$attrs, {
        role: "treeitem",
        as: z.as,
        "as-child": z.asChild,
        "aria-selected": x.value,
        "aria-expanded": d.value ? h.value : void 0,
        "aria-level": z.level,
        "data-indent": z.level,
        "data-selected": x.value ? "" : void 0,
        "data-expanded": h.value ? "" : void 0,
        onKeydown: [
          mi(si(M, ["self", "prevent"]), ["enter", "space"]),
          X[0] || (X[0] = mi(si((B) => te(o).dir.value === "ltr" ? I(B) : q(B), ["prevent"]), ["right"])),
          X[1] || (X[1] = mi(si((B) => te(o).dir.value === "ltr" ? q(B) : I(B), ["prevent"]), ["left"]))
        ],
        onClick: X[2] || (X[2] = si((B) => {
          M(B), U(B);
        }, ["stop"]))
      }), {
        default: ln(() => [qn(z.$slots, "default", {
          isExpanded: h.value,
          isSelected: x.value,
          isIndeterminate: y.value,
          handleSelect: () => te(o).onSelect(z.value),
          handleToggle: () => te(o).onToggle(z.value)
        })]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "aria-selected",
        "aria-expanded",
        "aria-level",
        "data-indent",
        "data-selected",
        "data-expanded",
        "onKeydown"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), cS = sS;
const oS = { class: "layout w-screen h-screen" }, mS = { class: "w-screen h-screen overflow-hidden" }, fS = /* @__PURE__ */ dn({
  __name: "app-layout",
  setup(e) {
    const l = /* @__PURE__ */ c0(s0), i = _e(() => l.greater("2xl").value ? 20 : l.greater("xl").value ? 25 : l.greater("lg").value ? 30 : l.greater("md").value ? 35 : 0);
    return (a, s) => (Ye(), Yn("div", oS, [
      fn("div", mS, [
        ze(te(Xw), {
          direction: "horizontal",
          class: "h-full"
        }, {
          default: ln(() => [
            ze(te(tp), {
              class: "border-e h-full",
              "default-size": i.value
            }, {
              default: ln(() => [
                qn(a.$slots, "primary-sidebar", {}, void 0, !0)
              ]),
              _: 3
            }, 8, ["default-size"]),
            ze(te(nS), { class: "w-1" }),
            ze(te(tp), { class: "h-full" }, {
              default: ln(() => [
                qn(a.$slots, "main-area", {}, void 0, !0)
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ])
    ]));
  }
}), ha = (e, l) => {
  const i = e.__vccOpts || e;
  for (const [a, s] of l)
    i[a] = s;
  return i;
}, dS = /* @__PURE__ */ ha(fS, [["__scopeId", "data-v-30346480"]]);
function Xu(e, l) {
  if (!e)
    throw new Error("Unexpected Error!");
}
const Ss = /* @__PURE__ */ lo("s-ied-implementation/dialog", () => {
  const e = {
    component: void 0,
    props: void 0,
    isLoading: void 0
  }, l = Fe(), i = Fl(e);
  function a() {
    i.value = e;
  }
  function s() {
    l.value?.close(), n0(() => {
      a();
    }, 300);
  }
  function o(f) {
    const { component: d, props: h, isLoading: x } = f;
    if (!d) throw new Error("Dialog component is undefined");
    i.value = {
      component: za(d),
      props: h,
      isLoading: x
    }, l.value?.showModal();
  }
  return {
    // states
    dialogRef: l,
    currentDialog: i,
    // actions
    hardReset: a,
    handleClose: s,
    setCurrentDialog: o
  };
});
function Cs(e) {
  const { attributes: l, keys: i } = e, a = [];
  for (const s of i) a.push(l[s]);
  return a.join(".");
}
function $s(e) {
  const { sdkInstance: l, records: i, keyAttributes: a } = e, s = /* @__PURE__ */ new Map();
  for (const o of i) {
    const f = Cs({
      attributes: l.utils.getAttributesValuesByName({
        attributes: o.attributes
      }),
      keys: a
    });
    f && !s.has(f) && s.set(f, o);
  }
  return s;
}
function pS(e) {
  const { sdkInstance: l, localLnode: i, icdLNodeSpecNamingMap: a } = e, s = i.treeChildren.find(
    (d) => d.tagName === "LNodeSpecNaming"
  );
  if (!s) return;
  const o = Cs({
    attributes: l.utils.getAttributesValuesByName({
      attributes: s.attributes
    }),
    keys: ["sLdInst", "sPrefix", "sLnClass", "sLnInst"]
  });
  if (!o)
    return {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    };
  const f = a.get(o);
  return {
    total: 1,
    perfectMatches: f ? [{ local: s, icd: f }] : [],
    manualMatches: [],
    noMatches: f ? [] : [s]
  };
}
function hS(e) {
  const { localLnode: l, matchingIcdLn: i } = e;
  return {
    total: 1,
    perfectMatches: i ? [{ local: l, icd: i }] : [],
    manualMatches: [],
    noMatches: i ? [] : [l]
  };
}
function gS(e) {
  const { sdkInstance: l, localLnode: i, icdSourceRefMap: a } = e, s = [], o = i.treeChildren.filter(
    (f) => f.tagName === "SourceRef"
  );
  for (const f of o) {
    const d = Cs({
      attributes: l.utils.getAttributesValuesByName({
        attributes: f.attributes
      }),
      keys: ["input", "inputInst", "pDA"]
    });
    if (!d) {
      s.push({
        total: 0,
        perfectMatches: [],
        manualMatches: [],
        noMatches: []
      });
      continue;
    }
    const h = a.get(d);
    s.push({
      total: 1,
      perfectMatches: h ? [{ local: f, icd: h }] : [],
      manualMatches: [],
      noMatches: h ? [] : [f]
    });
  }
  return s;
}
function vS(e) {
  const { sdkInstance: l, localLnode: i, icdControlRefMap: a } = e, s = [], o = i.treeChildren.filter(
    (f) => f.tagName === "ControlRef"
  );
  for (const f of o) {
    const d = Cs({
      attributes: l.utils.getAttributesValuesByName({
        attributes: f.attributes
      }),
      keys: ["output", "outputInst"]
    });
    if (!d) {
      s.push({
        total: 0,
        perfectMatches: [],
        manualMatches: [],
        noMatches: []
      });
      continue;
    }
    const h = a.get(d);
    s.push({
      total: 1,
      perfectMatches: h ? [{ local: f, icd: h }] : [],
      manualMatches: [],
      noMatches: h ? [] : [f]
    });
  }
  return s;
}
function xS(e) {
  const { sdkInstance: l, localDataModel: i, icdDataModel: a } = e, s = {
    total: 0,
    perfectMatches: [],
    manualMatches: [],
    noMatches: []
  }, o = [], { LNodeType: f = [], DOType: d = [] } = l.utils.groupRecordsByTagName(i), { LNodeType: h = [], DOType: x = [] } = l.utils.groupRecordsByTagName(a), y = f[0];
  if (!y) throw new Error("No LNodeType found in local data model");
  const I = h[0];
  if (!I) throw new Error("No LNodeType found in ICD data model");
  const q = y.treeChildren.filter(
    (M) => M.tagName === "DO"
  ), R = I.treeChildren.filter((M) => M.tagName === "DO");
  for (const M of q) {
    s.total++;
    const U = l.utils.getAttributeValueByName({
      attributes: M.attributes,
      name: "name"
    }), z = R.find(
      (B) => l.utils.getAttributeValueByName({
        attributes: B.attributes,
        name: "name"
      }) === U
    );
    z ? s.perfectMatches.push({
      local: M,
      icd: z
    }) : s.noMatches.push(M);
    const X = yS({
      sdkInstance: l,
      localDo: M,
      matchingIcdDo: z,
      localDoTypes: d,
      icdDoTypes: x
    });
    o.push(X);
  }
  const E = {
    total: o.reduce((M, U) => M + U.total, 0),
    perfectMatches: o.flatMap((M) => M.perfectMatches),
    manualMatches: o.flatMap((M) => M.manualMatches),
    noMatches: o.flatMap((M) => M.noMatches)
  };
  return { doMetrics: s, daMetrics: E };
}
function yS(e) {
  const { sdkInstance: l, localDo: i, matchingIcdDo: a, localDoTypes: s, icdDoTypes: o } = e, f = {
    total: 0,
    perfectMatches: [],
    manualMatches: [],
    noMatches: []
  }, d = l.utils.resolveDataModelRootElementReference({
    source: i,
    targets: s
  });
  if (!d) return f;
  const h = d.treeChildren.filter((y) => y.tagName === "DA");
  let x = [];
  if (a) {
    const y = l.utils.resolveDataModelRootElementReference({
      source: a,
      targets: o
    });
    y && (x = y.treeChildren.filter((I) => I.tagName === "DA"));
  }
  for (const y of h) {
    f.total++;
    const I = l.utils.getAttributeValueByName({
      attributes: y.attributes,
      name: "name"
    }), q = x.find(
      (R) => l.utils.getAttributeValueByName({
        attributes: R.attributes,
        name: "name"
      }) === I
    );
    q ? f.perfectMatches.push({
      local: y,
      icd: q
    }) : f.noMatches.push(y);
  }
  return f;
}
function IS(e) {
  const { sdkInstance: l, localDataModel: i } = e, a = i.filter((y) => y.tagName === "LNodeType");
  let s = 0, o = 0;
  const f = [], d = [];
  for (const y of a) {
    const I = y.treeChildren.filter((q) => q.tagName === "DO");
    s += I.length, f.push(...I);
    for (const q of I) {
      const R = l.utils.resolveDataModelRootElementReference({
        source: q,
        targets: i.filter((E) => E.tagName === "DOType")
      });
      if (R) {
        const E = R.treeChildren.filter((M) => M.tagName === "DA");
        o += E.length, d.push(...E);
      }
    }
  }
  return { doMetrics: {
    total: s,
    perfectMatches: [],
    manualMatches: [],
    noMatches: f
  }, daMetrics: {
    total: o,
    perfectMatches: [],
    manualMatches: [],
    noMatches: d
  } };
}
function Ia(e) {
  return {
    total: e.reduce((l, i) => l + i.total, 0),
    perfectMatches: e.flatMap((l) => l.perfectMatches),
    manualMatches: e.flatMap((l) => l.manualMatches),
    noMatches: e.flatMap((l) => l.noMatches)
  };
}
const ip = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), LS = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (l, i, a) => a ? a.toUpperCase() : i.toLowerCase()
), DS = (e) => {
  const l = LS(e);
  return l.charAt(0).toUpperCase() + l.slice(1);
}, OS = (...e) => e.filter((l, i, a) => !!l && l.trim() !== "" && a.indexOf(l) === i).join(" ").trim(), up = (e) => e === "";
var Tr = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
const bS = ({
  name: e,
  iconNode: l,
  absoluteStrokeWidth: i,
  "absolute-stroke-width": a,
  strokeWidth: s,
  "stroke-width": o,
  size: f = Tr.width,
  color: d = Tr.stroke,
  ...h
}, { slots: x }) => gt(
  "svg",
  {
    ...Tr,
    ...h,
    width: f,
    height: f,
    stroke: d,
    "stroke-width": up(i) || up(a) || i === !0 || a === !0 ? Number(s || o || Tr["stroke-width"]) * 24 / Number(f) : s || o || Tr["stroke-width"],
    class: OS(
      "lucide",
      h.class,
      ...e ? [`lucide-${ip(DS(e))}-icon`, `lucide-${ip(e)}`] : ["lucide-icon"]
    )
  },
  [...l.map((y) => gt(...y)), ...x.default ? [x.default()] : []]
);
const Ts = (e, l) => (i, { slots: a, attrs: s }) => gt(
  bS,
  {
    ...s,
    ...i,
    iconNode: l,
    name: e
  },
  a
);
const ap = Ts("check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
const wS = Ts("chevron-down", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
const Av = Ts("circle-x", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
  ["path", { d: "m9 9 6 6", key: "z0biqf" }]
]);
const SS = Ts("trash-2", [
  ["path", { d: "M10 11v6", key: "nco0om" }],
  ["path", { d: "M14 11v6", key: "outv1u" }],
  ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6", key: "miytrc" }],
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2", key: "e791ji" }]
]);
const CS = Ts("x", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), TS = { class: "flex flex-col gap-5" }, PS = {
  key: 0,
  role: "alert",
  class: "alert alert-error alert-soft"
}, qS = /* @__PURE__ */ dn({
  __name: "mapping-error",
  setup(e) {
    const l = Ss(), i = Ps(), { error: a } = Lt(i);
    function s() {
      a.value = null, l.handleClose();
    }
    return (o, f) => (Ye(), Yn("div", TS, [
      te(a) ? (Ye(), Yn("div", PS, [
        ze(te(Av)),
        fn("span", null, Ul(te(a)), 1)
      ])) : pi("", !0),
      fn("button", {
        class: "btn-close self-end",
        onClick: s
      }, "Close")
    ]));
  }
}), RS = /* @__PURE__ */ ha(qS, [["__scopeId", "data-v-dadc7e4b"]]), AS = { class: "flex flex-col items-center gap-4 w-full justify-center mt-24" }, ES = {
  key: 0,
  class: "progress progress-primary w-56"
}, _S = ["value"], NS = { class: "font-bold" }, FS = { class: "mt-10 w-full" }, MS = { class: "modal-action" }, kS = ["disabled"], VS = /* @__PURE__ */ dn({
  __name: "mapping-loader",
  setup(e) {
    const l = Ps(), i = Ss(), { progress: a, isLoading: s } = Lt(l);
    function o() {
      i.handleClose(), s.value = !1;
    }
    const f = _e(() => a.value.total === 0 ? 0 : Math.round(a.value.current / a.value.total * 100));
    return (d, h) => (Ye(), Yn("div", AS, [
      f.value === 0 || te(a).scope !== "commit" ? (Ye(), Yn("progress", ES)) : (Ye(), Yn("progress", {
        key: 1,
        class: "progress progress-primary w-56",
        value: f.value,
        max: "100"
      }, null, 8, _S)),
      fn("span", NS, Ul(f.value === 100 && te(a).scope === "commit" ? "Mapping applied successfully!" : te(a).message), 1),
      fn("footer", FS, [
        fn("div", MS, [
          fn("button", {
            class: "btn-close",
            onClick: o,
            disabled: f.value < 100
          }, [
            fn("span", {
              class: Bl([f.value < 100 ? "loading loading-spinner" : ""])
            }, null, 2),
            h[0] || (h[0] = Gi(" Close ", -1))
          ], 8, kS)
        ])
      ])
    ]));
  }
}), BS = /* @__PURE__ */ ha(VS, [["__scopeId", "data-v-154446ae"]]);
function Ev(e) {
  return $i() ? (ca(e), !0) : !1;
}
const _v = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const ZS = Object.prototype.toString, US = (e) => ZS.call(e) === "[object Object]", KS = () => {
}, rp = /* @__PURE__ */ GS();
function GS() {
  var e, l;
  return _v && ((e = window?.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((l = window?.navigator) == null ? void 0 : l.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function zS(...e) {
  if (e.length !== 1)
    return hs(...e);
  const l = e[0];
  return typeof l == "function" ? Bi(ja(() => ({ get: l, set: KS }))) : Fe(l);
}
function Bo(e) {
  return Array.isArray(e) ? e : [e];
}
function jS(e, l, i) {
  return Cn(
    e,
    l,
    {
      ...i,
      immediate: !0
    }
  );
}
const HS = _v ? window : void 0;
function $S(e) {
  var l;
  const i = hn(e);
  return (l = i?.$el) != null ? l : i;
}
function WS(...e) {
  const l = [], i = () => {
    l.forEach((d) => d()), l.length = 0;
  }, a = (d, h, x, y) => (d.addEventListener(h, x, y), () => d.removeEventListener(h, x, y)), s = _e(() => {
    const d = Bo(hn(e[0])).filter((h) => h != null);
    return d.every((h) => typeof h != "string") ? d : void 0;
  }), o = jS(
    () => {
      var d, h;
      return [
        (h = (d = s.value) == null ? void 0 : d.map((x) => $S(x))) != null ? h : [HS].filter((x) => x != null),
        Bo(hn(s.value ? e[1] : e[0])),
        Bo(te(s.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        hn(s.value ? e[3] : e[2])
      ];
    },
    ([d, h, x, y]) => {
      if (i(), !d?.length || !h?.length || !x?.length)
        return;
      const I = US(y) ? { ...y } : y;
      l.push(
        ...d.flatMap(
          (q) => h.flatMap(
            (R) => x.map((E) => a(q, R, E, I))
          )
        )
      );
    },
    { flush: "post" }
  ), f = () => {
    o(), i();
  };
  return Ev(i), f;
}
function Zo(e) {
  return typeof Window < "u" && e instanceof Window ? e.document.documentElement : typeof Document < "u" && e instanceof Document ? e.documentElement : e;
}
function Nv(e) {
  const l = window.getComputedStyle(e);
  if (l.overflowX === "scroll" || l.overflowY === "scroll" || l.overflowX === "auto" && e.clientWidth < e.scrollWidth || l.overflowY === "auto" && e.clientHeight < e.scrollHeight)
    return !0;
  {
    const i = e.parentNode;
    return !i || i.tagName === "BODY" ? !1 : Nv(i);
  }
}
function YS(e) {
  const l = e || window.event, i = l.target;
  return Nv(i) ? !1 : l.touches.length > 1 ? !0 : (l.preventDefault && l.preventDefault(), !1);
}
const Uo = /* @__PURE__ */ new WeakMap();
function XS(e, l = !1) {
  const i = Fl(l);
  let a = null, s = "";
  Cn(zS(e), (d) => {
    const h = Zo(hn(d));
    if (h) {
      const x = h;
      if (Uo.get(x) || Uo.set(x, x.style.overflow), x.style.overflow !== "hidden" && (s = x.style.overflow), x.style.overflow === "hidden")
        return i.value = !0;
      if (i.value)
        return x.style.overflow = "hidden";
    }
  }, {
    immediate: !0
  });
  const o = () => {
    const d = Zo(hn(e));
    !d || i.value || (rp && (a = WS(
      d,
      "touchmove",
      (h) => {
        YS(h);
      },
      { passive: !1 }
    )), d.style.overflow = "hidden", i.value = !0);
  }, f = () => {
    const d = Zo(hn(e));
    !d || !i.value || (rp && a?.(), d.style.overflow = s, Uo.delete(d), i.value = !1);
  };
  return Ev(f), _e({
    get() {
      return i.value;
    },
    set(d) {
      d ? o() : f();
    }
  });
}
function QS() {
  let e = !1;
  const l = Fl(!1);
  return (i, a) => {
    if (l.value = a.value, e)
      return;
    e = !0;
    const s = XS(i, a.value);
    Cn(l, (o) => s.value = o);
  };
}
QS();
const sp = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), JS = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (l, i, a) => a ? a.toUpperCase() : i.toLowerCase()
), e1 = (e) => {
  const l = JS(e);
  return l.charAt(0).toUpperCase() + l.slice(1);
}, n1 = (...e) => e.filter((l, i, a) => !!l && l.trim() !== "" && a.indexOf(l) === i).join(" ").trim(), cp = (e) => e === "";
var Pr = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
const l1 = ({
  name: e,
  iconNode: l,
  absoluteStrokeWidth: i,
  "absolute-stroke-width": a,
  strokeWidth: s,
  "stroke-width": o,
  size: f = Pr.width,
  color: d = Pr.stroke,
  ...h
}, { slots: x }) => gt(
  "svg",
  {
    ...Pr,
    ...h,
    width: f,
    height: f,
    stroke: d,
    "stroke-width": cp(i) || cp(a) || i === !0 || a === !0 ? Number(s || o || Pr["stroke-width"]) * 24 / Number(f) : s || o || Pr["stroke-width"],
    class: n1(
      "lucide",
      h.class,
      ...e ? [`lucide-${sp(e1(e))}-icon`, `lucide-${sp(e)}`] : ["lucide-icon"]
    )
  },
  [...l.map((y) => gt(...y)), ...x.default ? [x.default()] : []]
);
const Me = (e, l) => (i, { slots: a, attrs: s }) => gt(
  l1,
  {
    ...s,
    ...i,
    iconNode: l,
    name: e
  },
  a
);
const Ko = Me("activity", [
  [
    "path",
    {
      d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",
      key: "169zse"
    }
  ]
]);
const Go = Me("zap", [
  [
    "path",
    {
      d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
      key: "1xq2db"
    }
  ]
]);
const xi = Me("arrow-right", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);
const t1 = Me("variable", [
  ["path", { d: "M8 21s-4-3-4-9 4-9 4-9", key: "uto9ud" }],
  ["path", { d: "M16 3s4 3 4 9-4 9-4 9", key: "4w2vsq" }],
  ["line", { x1: "15", x2: "9", y1: "9", y2: "15", key: "f7djnv" }],
  ["line", { x1: "9", x2: "15", y1: "9", y2: "15", key: "1shsy8" }]
]);
const zo = Me("square-pen", [
  ["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7", key: "1m0v6g" }],
  [
    "path",
    {
      d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",
      key: "ohrbg2"
    }
  ]
]);
const i1 = Me("hash", [
  ["line", { x1: "4", x2: "20", y1: "9", y2: "9", key: "4lhtct" }],
  ["line", { x1: "4", x2: "20", y1: "15", y2: "15", key: "vyu0kd" }],
  ["line", { x1: "10", x2: "8", y1: "3", y2: "21", key: "1ggp8o" }],
  ["line", { x1: "16", x2: "14", y1: "3", y2: "21", key: "weycgp" }]
]);
const u1 = Me("rotate-cw", [
  ["path", { d: "M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8", key: "1p45f6" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }]
]);
const a1 = Me("timer", [
  ["line", { x1: "10", x2: "14", y1: "2", y2: "2", key: "14vaq8" }],
  ["line", { x1: "12", x2: "15", y1: "14", y2: "11", key: "17fdiu" }],
  ["circle", { cx: "12", cy: "14", r: "8", key: "1e1u0o" }]
]);
const qr = Me("clock", [
  ["path", { d: "M12 6v6l4 2", key: "mmk7yg" }],
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
]);
const op = Me("type", [
  ["path", { d: "M12 4v16", key: "1654pz" }],
  ["path", { d: "M4 7V5a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v2", key: "e0r10z" }],
  ["path", { d: "M9 20h6", key: "s66wpe" }]
]);
const r1 = Me("terminal", [
  ["path", { d: "M12 19h8", key: "baeox8" }],
  ["path", { d: "m4 17 6-6-6-6", key: "1yngyt" }]
]);
const mp = Me("toggle-right", [
  ["circle", { cx: "15", cy: "12", r: "3", key: "1afu0r" }],
  ["rect", { width: "20", height: "14", x: "2", y: "5", rx: "7", key: "g7kal2" }]
]);
const fp = Me("users", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["path", { d: "M16 3.128a4 4 0 0 1 0 7.744", key: "16gr8j" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
]);
const s1 = Me("building", [
  ["path", { d: "M12 10h.01", key: "1nrarc" }],
  ["path", { d: "M12 14h.01", key: "1etili" }],
  ["path", { d: "M12 6h.01", key: "1vi96p" }],
  ["path", { d: "M16 10h.01", key: "1m94wz" }],
  ["path", { d: "M16 14h.01", key: "1gbofw" }],
  ["path", { d: "M16 6h.01", key: "1x0f13" }],
  ["path", { d: "M8 10h.01", key: "19clt8" }],
  ["path", { d: "M8 14h.01", key: "6423bh" }],
  ["path", { d: "M8 6h.01", key: "1dz90k" }],
  ["path", { d: "M9 22v-3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3", key: "cabbwy" }],
  ["rect", { x: "4", y: "2", width: "16", height: "20", rx: "2", key: "1uxh74" }]
]);
const dp = Me("user-check", [
  ["path", { d: "m16 11 2 2 4-4", key: "9rsbq5" }],
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
]);
const jo = Me("user", [
  ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
  ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]
]);
const Rr = Me("network", [
  ["rect", { x: "16", y: "16", width: "6", height: "6", rx: "1", key: "4q2zg0" }],
  ["rect", { x: "2", y: "16", width: "6", height: "6", rx: "1", key: "8cvhb9" }],
  ["rect", { x: "9", y: "2", width: "6", height: "6", rx: "1", key: "1egb70" }],
  ["path", { d: "M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3", key: "1jsf9p" }],
  ["path", { d: "M12 12V8", key: "2874zd" }]
]);
const Ar = Me("file-text", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
]);
const Ws = Me("square", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }]
]);
const Ys = Me("cpu", [
  ["path", { d: "M12 20v2", key: "1lh1kg" }],
  ["path", { d: "M12 2v2", key: "tus03m" }],
  ["path", { d: "M17 20v2", key: "1rnc9c" }],
  ["path", { d: "M17 2v2", key: "11trls" }],
  ["path", { d: "M2 12h2", key: "1t8f8n" }],
  ["path", { d: "M2 17h2", key: "7oei6x" }],
  ["path", { d: "M2 7h2", key: "asdhe0" }],
  ["path", { d: "M20 12h2", key: "1q8mjw" }],
  ["path", { d: "M20 17h2", key: "1fpfkl" }],
  ["path", { d: "M20 7h2", key: "1o8tra" }],
  ["path", { d: "M7 20v2", key: "4gnj0m" }],
  ["path", { d: "M7 2v2", key: "1i4yhu" }],
  ["rect", { x: "4", y: "4", width: "16", height: "16", rx: "2", key: "1vbyd7" }],
  ["rect", { x: "8", y: "8", width: "8", height: "8", rx: "1", key: "z9xiuo" }]
]);
const pp = Me("circle-check-big", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
const Qu = Me("tag", [
  [
    "path",
    {
      d: "M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z",
      key: "vktsd0"
    }
  ],
  ["circle", { cx: "7.5", cy: "7.5", r: ".5", fill: "currentColor", key: "kqv944" }]
]);
const Ho = Me("files", [
  [
    "path",
    {
      d: "M15 2a2 2 0 0 1 1.414.586l4 4A2 2 0 0 1 21 8v7a2 2 0 0 1-2 2h-8a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z",
      key: "1vo8kb"
    }
  ],
  ["path", { d: "M15 2v4a2 2 0 0 0 2 2h4", key: "sud9ri" }],
  ["path", { d: "M5 7a2 2 0 0 0-2 2v11a2 2 0 0 0 2 2h8a2 2 0 0 0 1.732-1", key: "l4dndm" }]
]);
const hp = Me("square-check-big", [
  [
    "path",
    { d: "M21 10.656V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h12.344", key: "2acyp4" }
  ],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
const $o = Me("gauge", [
  ["path", { d: "m12 14 4-4", key: "9kzdfg" }],
  ["path", { d: "M3.34 19a10 10 0 1 1 17.32 0", key: "19p75a" }]
]);
const c1 = Me("radio", [
  ["path", { d: "M16.247 7.761a6 6 0 0 1 0 8.478", key: "1fwjs5" }],
  ["path", { d: "M19.075 4.933a10 10 0 0 1 0 14.134", key: "ehdyv1" }],
  ["path", { d: "M4.925 19.067a10 10 0 0 1 0-14.134", key: "1q22gi" }],
  ["path", { d: "M7.753 16.239a6 6 0 0 1 0-8.478", key: "r2q7qm" }],
  ["circle", { cx: "12", cy: "12", r: "2", key: "1c9p78" }]
]);
const gp = Me("group", [
  ["path", { d: "M3 7V5c0-1.1.9-2 2-2h2", key: "adw53z" }],
  ["path", { d: "M17 3h2c1.1 0 2 .9 2 2v2", key: "an4l38" }],
  ["path", { d: "M21 17v2c0 1.1-.9 2-2 2h-2", key: "144t0e" }],
  ["path", { d: "M7 21H5c-1.1 0-2-.9-2-2v-2", key: "rtnfgi" }],
  ["rect", { width: "7", height: "5", x: "7", y: "7", rx: "1", key: "1eyiv7" }],
  ["rect", { width: "7", height: "5", x: "10", y: "12", rx: "1", key: "1qlmkx" }]
]);
const La = Me("gamepad-2", [
  ["line", { x1: "6", x2: "10", y1: "11", y2: "11", key: "1gktln" }],
  ["line", { x1: "8", x2: "8", y1: "9", y2: "13", key: "qnk9ow" }],
  ["line", { x1: "15", x2: "15.01", y1: "12", y2: "12", key: "krot7o" }],
  ["line", { x1: "18", x2: "18.01", y1: "10", y2: "10", key: "1lcuu1" }],
  [
    "path",
    {
      d: "M17.32 5H6.68a4 4 0 0 0-3.978 3.59c-.006.052-.01.101-.017.152C2.604 9.416 2 14.456 2 16a3 3 0 0 0 3 3c1 0 1.5-.5 2-1l1.414-1.414A2 2 0 0 1 9.828 16h4.344a2 2 0 0 1 1.414.586L17 18c.5.5 1 1 2 1a3 3 0 0 0 3-3c0-1.545-.604-6.584-.685-7.258-.007-.05-.011-.1-.017-.151A4 4 0 0 0 17.32 5z",
      key: "mfqc10"
    }
  ]
]);
const Xs = Me("upload", [
  ["path", { d: "M12 3v12", key: "1x0j5s" }],
  ["path", { d: "m17 8-5-5-5 5", key: "7q97r8" }],
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }]
]);
const o1 = Me("hand-platter", [
  ["path", { d: "M12 3V2", key: "ar7q03" }],
  [
    "path",
    {
      d: "m15.4 17.4 3.2-2.8a2 2 0 1 1 2.8 2.9l-3.6 3.3c-.7.8-1.7 1.2-2.8 1.2h-4c-1.1 0-2.1-.4-2.8-1.2l-1.302-1.464A1 1 0 0 0 6.151 19H5",
      key: "n2g93r"
    }
  ],
  ["path", { d: "M2 14h12a2 2 0 0 1 0 4h-2", key: "1o2jem" }],
  ["path", { d: "M4 10h16", key: "img6z1" }],
  ["path", { d: "M5 10a7 7 0 0 1 14 0", key: "1ega1o" }],
  ["path", { d: "M5 14v6a1 1 0 0 1-1 1H2", key: "1hescx" }]
]);
const vp = Me("list", [
  ["path", { d: "M3 5h.01", key: "18ugdj" }],
  ["path", { d: "M3 12h.01", key: "nlz23k" }],
  ["path", { d: "M3 19h.01", key: "noohij" }],
  ["path", { d: "M8 5h13", key: "1pao27" }],
  ["path", { d: "M8 12h13", key: "1za7za" }],
  ["path", { d: "M8 19h13", key: "m83p4d" }]
]);
const Wo = Me("server", [
  ["rect", { width: "20", height: "8", x: "2", y: "2", rx: "2", ry: "2", key: "ngkwjq" }],
  ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2", ry: "2", key: "iecqi9" }],
  ["line", { x1: "6", x2: "6.01", y1: "6", y2: "6", key: "16zg32" }],
  ["line", { x1: "6", x2: "6.01", y1: "18", y2: "18", key: "nzw8ys" }]
]);
const Ju = Me("shield", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ]
]);
const Qs = Me("external-link", [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
]);
const Yo = Me("shield-check", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ],
  ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
]);
const Er = Me("send", [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
]);
const ai = Me("settings", [
  [
    "path",
    {
      d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
      key: "1i5ecw"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
const Ru = Me("sliders-vertical", [
  ["path", { d: "M10 8h4", key: "1sr2af" }],
  ["path", { d: "M12 21v-9", key: "17s77i" }],
  ["path", { d: "M12 8V3", key: "13r4qs" }],
  ["path", { d: "M17 16h4", key: "h1uq16" }],
  ["path", { d: "M19 12V3", key: "o1uvq1" }],
  ["path", { d: "M19 21v-5", key: "qua636" }],
  ["path", { d: "M3 14h4", key: "bcjad9" }],
  ["path", { d: "M5 10V3", key: "cb8scm" }],
  ["path", { d: "M5 21v-7", key: "1w1uti" }]
]);
const ea = Me("database", [
  ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3", key: "msslwz" }],
  ["path", { d: "M3 5V19A9 3 0 0 0 21 19V5", key: "1wlel7" }],
  ["path", { d: "M3 12A9 3 0 0 0 21 12", key: "mv7ke4" }]
]);
const _r = Me("box", [
  [
    "path",
    {
      d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",
      key: "hh9hay"
    }
  ],
  ["path", { d: "m3.3 7 8.7 5 8.7-5", key: "g66t2b" }],
  ["path", { d: "M12 22V12", key: "d0xqtd" }]
]);
const m1 = Me("file-code", [
  ["path", { d: "M10 12.5 8 15l2 2.5", key: "1tg20x" }],
  ["path", { d: "m14 12.5 2 2.5-2 2.5", key: "yinavb" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z", key: "1mlx9k" }]
]);
const f1 = Me("package", [
  [
    "path",
    {
      d: "M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z",
      key: "1a0edw"
    }
  ],
  ["path", { d: "M12 22V12", key: "d0xqtd" }],
  ["polyline", { points: "3.29 7 12 12 20.71 7", key: "ousv84" }],
  ["path", { d: "m7.5 4.27 9 5.15", key: "1c824w" }]
]);
const d1 = Me("shield-alert", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ],
  ["path", { d: "M12 8v4", key: "1got3b" }],
  ["path", { d: "M12 16h.01", key: "1drbdi" }]
]);
const Xo = Me("folder-open", [
  [
    "path",
    {
      d: "m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2",
      key: "usdka0"
    }
  ]
]);
const Js = Me("layers", [
  [
    "path",
    {
      d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",
      key: "zw3jo"
    }
  ],
  [
    "path",
    {
      d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",
      key: "1wduqc"
    }
  ],
  [
    "path",
    {
      d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",
      key: "kqbvx6"
    }
  ]
]);
const p1 = Me("repeat", [
  ["path", { d: "m17 2 4 4-4 4", key: "nntrym" }],
  ["path", { d: "M3 11v-1a4 4 0 0 1 4-4h14", key: "84bu3i" }],
  ["path", { d: "m7 22-4-4 4-4", key: "1wqhfi" }],
  ["path", { d: "M21 13v1a4 4 0 0 1-4 4H3", key: "1rx37r" }]
]);
const h1 = Me("play", [
  [
    "path",
    {
      d: "M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z",
      key: "10ikf1"
    }
  ]
]);
const g1 = Me("lock", [
  ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
  ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]
]);
const v1 = Me("battery-charging", [
  ["path", { d: "m11 7-3 5h4l-3 5", key: "b4a64w" }],
  ["path", { d: "M14.856 6H16a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.935", key: "lre1cr" }],
  ["path", { d: "M22 14v-4", key: "14q9d5" }],
  ["path", { d: "M5.14 18H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h2.936", key: "13q5k0" }]
]);
const xp = Me("link-2", [
  ["path", { d: "M9 17H7A5 5 0 0 1 7 7h2", key: "8i5ue5" }],
  ["path", { d: "M15 7h2a5 5 0 1 1 0 10h-2", key: "1b9ql8" }],
  ["line", { x1: "8", x2: "16", y1: "12", y2: "12", key: "1jonct" }]
]);
const yp = Me("link", [
  ["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71", key: "1cjeqo" }],
  ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71", key: "19qd67" }]
]);
const x1 = Me("cable", [
  [
    "path",
    { d: "M17 19a1 1 0 0 1-1-1v-2a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2a1 1 0 0 1-1 1z", key: "trhst0" }
  ],
  ["path", { d: "M17 21v-2", key: "ds4u3f" }],
  ["path", { d: "M19 14V6.5a1 1 0 0 0-7 0v11a1 1 0 0 1-7 0V10", key: "1mo9zo" }],
  ["path", { d: "M21 21v-2", key: "eo0ou" }],
  ["path", { d: "M3 5V3", key: "1k5hjh" }],
  [
    "path",
    { d: "M4 10a2 2 0 0 1-2-2V6a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2a2 2 0 0 1-2 2z", key: "1dd30t" }
  ],
  ["path", { d: "M7 5V3", key: "1t1388" }]
]);
const Qo = Me("arrow-up", [
  ["path", { d: "m5 12 7-7 7 7", key: "hav0vg" }],
  ["path", { d: "M12 19V5", key: "x0mq9r" }]
]);
const Nr = Me("arrow-up-right", [
  ["path", { d: "M7 7h10v10", key: "1tivn9" }],
  ["path", { d: "M7 17 17 7", key: "1vkiza" }]
]);
const Ip = Me("file", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }]
]);
const y1 = Me("minus", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
const I1 = Me("tags", [
  [
    "path",
    {
      d: "M13.172 2a2 2 0 0 1 1.414.586l6.71 6.71a2.4 2.4 0 0 1 0 3.408l-4.592 4.592a2.4 2.4 0 0 1-3.408 0l-6.71-6.71A2 2 0 0 1 6 9.172V3a1 1 0 0 1 1-1z",
      key: "16rjxf"
    }
  ],
  [
    "path",
    { d: "M2 7v6.172a2 2 0 0 0 .586 1.414l6.71 6.71a2.4 2.4 0 0 0 3.191.193", key: "178nd4" }
  ],
  ["circle", { cx: "10.5", cy: "6.5", r: ".5", fill: "currentColor", key: "12ikhr" }]
]);
const Jo = Me("arrow-down", [
  ["path", { d: "M12 5v14", key: "s699le" }],
  ["path", { d: "m19 12-7 7-7-7", key: "1idqje" }]
]);
const em = Me("git-branch", [
  ["line", { x1: "6", x2: "6", y1: "3", y2: "15", key: "17qcm7" }],
  ["circle", { cx: "18", cy: "6", r: "3", key: "1h7g24" }],
  ["circle", { cx: "6", cy: "18", r: "3", key: "fqmcym" }],
  ["path", { d: "M18 9a9 9 0 0 1-9 9", key: "n2h4wq" }]
]);
const L1 = Me("hard-drive", [
  ["line", { x1: "22", x2: "2", y1: "12", y2: "12", key: "1y58io" }],
  [
    "path",
    {
      d: "M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z",
      key: "oot6mr"
    }
  ],
  ["line", { x1: "6", x2: "6.01", y1: "16", y2: "16", key: "sgf278" }],
  ["line", { x1: "10", x2: "10.01", y1: "16", y2: "16", key: "1l4acy" }]
]);
const Lp = Me("globe", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }],
  ["path", { d: "M2 12h20", key: "9i4pu4" }]
]);
const Dp = Me("key", [
  ["path", { d: "m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4", key: "g0fldk" }],
  ["path", { d: "m21 2-9.6 9.6", key: "1j0ho8" }],
  ["circle", { cx: "7.5", cy: "15.5", r: "5.5", key: "yqb3hr" }]
]);
const D1 = Me("history", [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
  ["path", { d: "M12 7v5l4 2", key: "1fdv2h" }]
]);
const O1 = Me("heading", [
  ["path", { d: "M6 12h12", key: "8npq4p" }],
  ["path", { d: "M6 20V4", key: "1w1bmo" }],
  ["path", { d: "M18 20V4", key: "o2hl4u" }]
]);
const Op = Me("folder", [
  [
    "path",
    {
      d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z",
      key: "1kt360"
    }
  ]
]);
const b1 = Me("git-fork", [
  ["circle", { cx: "12", cy: "18", r: "3", key: "1mpf1b" }],
  ["circle", { cx: "6", cy: "6", r: "3", key: "1lh9wr" }],
  ["circle", { cx: "18", cy: "6", r: "3", key: "1h7g24" }],
  ["path", { d: "M18 9v2c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V9", key: "1uq4wg" }],
  ["path", { d: "M12 12v3", key: "158kv8" }]
]);
const bp = Me("user-cog", [
  ["path", { d: "M10 15H6a4 4 0 0 0-4 4v2", key: "1nfge6" }],
  ["path", { d: "m14.305 16.53.923-.382", key: "1itpsq" }],
  ["path", { d: "m15.228 13.852-.923-.383", key: "eplpkm" }],
  ["path", { d: "m16.852 12.228-.383-.923", key: "13v3q0" }],
  ["path", { d: "m16.852 17.772-.383.924", key: "1i8mnm" }],
  ["path", { d: "m19.148 12.228.383-.923", key: "1q8j1v" }],
  ["path", { d: "m19.53 18.696-.382-.924", key: "vk1qj3" }],
  ["path", { d: "m20.772 13.852.924-.383", key: "n880s0" }],
  ["path", { d: "m20.772 16.148.924.383", key: "1g6xey" }],
  ["circle", { cx: "18", cy: "15", r: "3", key: "gjjjvw" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
]);
const wp = Me("square-function", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["path", { d: "M9 17c2 0 2.8-1 2.8-2.8V10c0-2 1-3.3 3.2-3", key: "m1af9g" }],
  ["path", { d: "M9 11.2h5.7", key: "3zgcl2" }]
]);
const w1 = Me("list-ordered", [
  ["path", { d: "M11 5h10", key: "1cz7ny" }],
  ["path", { d: "M11 12h10", key: "1438ji" }],
  ["path", { d: "M11 19h10", key: "11t30w" }],
  ["path", { d: "M4 4h1v5", key: "10yrso" }],
  ["path", { d: "M4 9h2", key: "r1h2o0" }],
  ["path", { d: "M6.5 20H3.4c0-1 2.6-1.925 2.6-3.5a1.5 1.5 0 0 0-2.6-1.02", key: "xtkcd5" }]
]);
const S1 = Me("table-2", [
  [
    "path",
    {
      d: "M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18",
      key: "gugj83"
    }
  ]
]);
const C1 = Me("layout-template", [
  ["rect", { width: "18", height: "7", x: "3", y: "3", rx: "1", key: "f1a2em" }],
  ["rect", { width: "9", height: "7", x: "3", y: "14", rx: "1", key: "jqznyg" }],
  ["rect", { width: "5", height: "7", x: "16", y: "14", rx: "1", key: "q5h2i8" }]
]);
const T1 = Me("table", [
  ["path", { d: "M12 3v18", key: "108xh3" }],
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M3 9h18", key: "1pudct" }],
  ["path", { d: "M3 15h18", key: "5xshup" }]
]);
const P1 = Me("gamepad", [
  ["line", { x1: "6", x2: "10", y1: "12", y2: "12", key: "161bw2" }],
  ["line", { x1: "8", x2: "8", y1: "10", y2: "14", key: "1i6ji0" }],
  ["line", { x1: "15", x2: "15.01", y1: "13", y2: "13", key: "dqpgro" }],
  ["line", { x1: "18", x2: "18.01", y1: "11", y2: "11", key: "meh2c" }],
  ["rect", { width: "20", height: "12", x: "2", y: "6", rx: "2", key: "9lu3g6" }]
]);
const q1 = Me("plug-zap", [
  [
    "path",
    { d: "M6.3 20.3a2.4 2.4 0 0 0 3.4 0L12 18l-6-6-2.3 2.3a2.4 2.4 0 0 0 0 3.4Z", key: "goz73y" }
  ],
  ["path", { d: "m2 22 3-3", key: "19mgm9" }],
  ["path", { d: "M7.5 13.5 10 11", key: "7xgeeb" }],
  ["path", { d: "M10.5 16.5 13 14", key: "10btkg" }],
  ["path", { d: "m18 3-4 4h6l-4 4", key: "16psg9" }]
]);
const R1 = Me("wifi", [
  ["path", { d: "M12 20h.01", key: "zekei9" }],
  ["path", { d: "M2 8.82a15 15 0 0 1 20 0", key: "dnpr2z" }],
  ["path", { d: "M5 12.859a10 10 0 0 1 14 0", key: "1x1e6c" }],
  ["path", { d: "M8.5 16.429a5 5 0 0 1 7 0", key: "1bycff" }]
]);
const Sp = Me("binary", [
  ["rect", { x: "14", y: "14", width: "4", height: "6", rx: "2", key: "p02svl" }],
  ["rect", { x: "6", y: "4", width: "4", height: "6", rx: "2", key: "xm4xkj" }],
  ["path", { d: "M6 20h4", key: "1i6q5t" }],
  ["path", { d: "M14 10h4", key: "ru81e7" }],
  ["path", { d: "M6 14h2v6", key: "16z9wg" }],
  ["path", { d: "M14 4h2v6", key: "1idq9u" }]
]);
const A1 = Me("layout-grid", [
  ["rect", { width: "7", height: "7", x: "3", y: "3", rx: "1", key: "1g98yp" }],
  ["rect", { width: "7", height: "7", x: "14", y: "3", rx: "1", key: "6d4xhi" }],
  ["rect", { width: "7", height: "7", x: "14", y: "14", rx: "1", key: "nxv5o0" }],
  ["rect", { width: "7", height: "7", x: "3", y: "14", rx: "1", key: "1bb6yr" }]
]);
const E1 = Me("columns-2", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M12 3v18", key: "108xh3" }]
]);
const _1 = Me("app-window", [
  ["rect", { x: "2", y: "4", width: "20", height: "16", rx: "2", key: "izxlao" }],
  ["path", { d: "M10 4v4", key: "pp8u80" }],
  ["path", { d: "M2 8h20", key: "d11cs7" }],
  ["path", { d: "M6 4v4", key: "1svtjw" }]
]);
const N1 = Me("map-pin", [
  [
    "path",
    {
      d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
      key: "1r0f0z"
    }
  ],
  ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]
]);
const F1 = Me("plug", [
  ["path", { d: "M12 22v-5", key: "1ega77" }],
  ["path", { d: "M9 8V2", key: "14iosj" }],
  ["path", { d: "M15 8V2", key: "18g5xt" }],
  ["path", { d: "M18 8v5a4 4 0 0 1-4 4h-4a4 4 0 0 1-4-4V8Z", key: "osxo6l" }]
]), Vm = {
  AccessControl: Yo,
  AccessPoint: F1,
  Address: N1,
  AllocationRole: bp,
  AllocationRoleRef: dp,
  AnalogueWiringParameters: Ko,
  AnalogueWiringParametersRef: Ko,
  Application: _1,
  ApplicationSclRef: Qs,
  Association: yp,
  Authentication: Dp,
  BDA: ea,
  Bay: E1,
  BayType: A1,
  BehaviorDescription: Ar,
  BehaviorDescriptionRef: Ar,
  BehaviorReference: xi,
  BinaryWiringParameters: Sp,
  BinaryWiringParametersRef: Sp,
  BitRate: $o,
  CheckoutID: pp,
  ClientLN: fp,
  ClientServices: Wo,
  CommProt: Ju,
  Communication: R1,
  CommunicationServiceSpecifications: Rr,
  ConductingEquipment: Go,
  ConfDataSet: ai,
  ConfLNs: ai,
  ConfLdName: ai,
  ConfLogControl: ai,
  ConfReportControl: ai,
  ConfSG: ai,
  ConfSigRef: ai,
  ConnectedAP: q1,
  ConnectivityNode: em,
  ControlRef: La,
  ControllingLNode: P1,
  DA: ea,
  DAI: ea,
  DAS: ea,
  DAType: Js,
  DO: _r,
  DOI: _r,
  DOS: _r,
  DOType: Js,
  DataObjectDirectory: Op,
  DataSet: T1,
  DataSetDirectory: Xo,
  DataTypeTemplates: C1,
  DynAssociation: xp,
  DynDataSet: S1,
  EnumType: vp,
  EnumVal: w1,
  EqFunction: wp,
  EqSubFunction: Ws,
  ExtCtrl: Qs,
  ExtRef: Nr,
  FCDA: ea,
  FileHandling: Ip,
  Function: wp,
  FunctionCatRef: Qu,
  FunctionCategory: Qu,
  FunctionCategoryRef: Qu,
  FunctionRef: xi,
  FunctionRole: bp,
  FunctionRoleContent: jo,
  FunctionSclRef: Qs,
  FunctionTemplate: Ar,
  FunctionalSubVariant: em,
  FunctionalVariant: b1,
  FunctionalVariantGroup: gp,
  FunctionalVariantRef: xi,
  GOOSE: Er,
  GOOSEMcSecurity: Yo,
  GOOSESecurity: Ju,
  GSE: Er,
  GSEControl: La,
  GSEDir: Op,
  GSESettings: ai,
  GSSE: Er,
  GeneralEquipment: Ys,
  GetCBValues: Xs,
  GetDataObjectDefinition: Xs,
  GetDataSetValue: Xs,
  GetDirectory: Xo,
  GooseParameters: Ru,
  GooseParametersRef: Ru,
  Header: O1,
  History: D1,
  Hitem: qr,
  IED: Ys,
  IEDName: Qu,
  IEDSourceFiles: Ho,
  InputVar: Jo,
  InputVarRef: Nr,
  Inputs: Jo,
  IssuerName: jo,
  KDC: Dp,
  L2CommParameters: Rr,
  L3IPv4CommParameters: Lp,
  L3IPv6CommParameters: Lp,
  LDevice: L1,
  LN: _r,
  LN0: Ws,
  LNode: em,
  LNodeDataRef: xi,
  LNodeInputRef: Nr,
  LNodeInputs: Jo,
  LNodeOutputRef: Nr,
  LNodeOutputs: Qo,
  LNodeSpecNaming: Qu,
  LNodeType: Js,
  Label: Qu,
  Labels: I1,
  Line: y1,
  Log: Ar,
  LogControl: La,
  LogParameters: Ru,
  LogParametersRef: Ru,
  LogSettings: ai,
  MaxTime: qr,
  McSecurity: Ju,
  MinRequestedSCDFile: Ip,
  MinRequestedSCDFiles: Ho,
  MinTime: qr,
  MultiAPPerSubNet: Rr,
  NeutralPoint: Ws,
  OptFields: hp,
  OutputVar: Qo,
  OutputVarRef: Nr,
  Outputs: Qo,
  P: op,
  PhysConn: x1,
  PowerSystemRelation: yp,
  PowerSystemRelationRef: xi,
  PowerSystemRelations: xp,
  PowerTransformer: v1,
  Private: g1,
  Process: h1,
  ProcessEcho: p1,
  ProcessResource: Ys,
  ProcessResourceRef: xi,
  ProcessResources: Js,
  Project: Xo,
  ProjectProcessReference: xi,
  ProtNs: Ju,
  Protocol: Rr,
  ReadWrite: zo,
  RedProt: d1,
  ReportControl: La,
  ReportParameters: Ru,
  ReportParametersRef: Ru,
  ReportSettings: ai,
  Resource: f1,
  RptEnabled: mp,
  SCL: m1,
  SCSM: Ju,
  SDI: ea,
  SDO: _r,
  SDS: ea,
  SGEdit: zo,
  SMV: Er,
  SMVParameters: Ru,
  SMVParametersRef: Ru,
  SMVSecurity: Ju,
  SMVSettings: ai,
  SMVsc: Er,
  SVMcSecurity: Yo,
  SampledValueControl: La,
  SamplesPerSec: $o,
  SclFileReference: Qs,
  SecPerSamples: qr,
  Security: Ju,
  Server: Wo,
  ServerAt: Wo,
  ServiceSpecifications: vp,
  Services: o1,
  SetDataSetValue: Xs,
  SettingControl: La,
  SettingGroups: gp,
  SignalRole: c1,
  SmpRate: $o,
  SmvOpts: hp,
  SourceFiles: Ho,
  SourceRef: xi,
  SubCategory: Qu,
  SubCheckoutID: pp,
  SubEquipment: Ys,
  SubFunction: Ws,
  SubFunctionTemplate: Ar,
  SubNetwork: Rr,
  Subject: jo,
  SubscriberLNode: dp,
  Substation: s1,
  SupSubscription: fp,
  TapChanger: mp,
  Terminal: r1,
  Text: op,
  TimeSyncProt: qr,
  TimerActivatedControl: a1,
  TransformerWinding: u1,
  TrgOps: Go,
  Val: i1,
  ValueHandling: zo,
  Variable: t1,
  VariableApplyTo: xi,
  VariableRef: xi,
  Voltage: Go,
  VoltageLevel: Ko
}, M1 = { class: "list-row items-center" }, k1 = { class: "avatar avatar-placeholder hidden sm:block" }, V1 = { class: "flex gap-2 mt-2" }, B1 = { class: "mt-10" }, Z1 = {
  key: 0,
  role: "alert",
  class: "alert alert-error alert-soft mt-10"
}, U1 = { class: "modal-action" }, K1 = ["disabled"], G1 = /* @__PURE__ */ dn({
  __name: "mapping-metrics",
  setup(e) {
    const l = Ps(), i = Ss(), { metrics: a } = Lt(l), s = _e(() => {
      const d = a.value.LNodeSpecNaming.total === a.value.LNodeSpecNaming.perfectMatches.length, h = a.value.LNode.total === a.value.LNode.perfectMatches.length;
      return d && h;
    });
    async function o() {
      await l.applyMapping();
    }
    function f(d) {
      return d.total === d.perfectMatches.length;
    }
    return (d, h) => (Ye(), Yn(Mn, null, [
      (Ye(!0), Yn(Mn, null, ys(te(a), (x, y) => (Ye(), Yn("ul", {
        key: y,
        class: "list"
      }, [
        fn("li", M1, [
          fn("div", k1, [
            fn("div", {
              class: Bl(["w-12 rounded-full", {
                "bg-base-300 text-base-content": f(x),
                "bg-red-100 bg-soft text-error": !f(x)
              }])
            }, [
              (Ye(), xn(xs(te(Vm)[y]), { class: "size-6" }))
            ], 2)
          ]),
          fn("div", null, [
            fn("span", {
              class: Bl(["font-bold", {
                "text-error": !f(x)
              }])
            }, Ul(y) + " matches: ", 3),
            fn("div", V1, [
              fn("span", {
                class: Bl(["badge badge-neutral w-max", {
                  "badge-soft": f(x),
                  "text-neutral-content": !f(x)
                }])
              }, " Total: " + Ul(x.total), 3),
              fn("span", {
                class: Bl(["badge badge-primary w-max", {
                  "text-primary-content": f(x),
                  "badge-soft": !f(x)
                }])
              }, " Perfect: " + Ul(x.perfectMatches.length), 3),
              fn("span", {
                class: Bl(["badge badge-warning w-max", {
                  "text-warning-content": !f(x) && x.manualMatches.length,
                  "badge-soft": f(x) || !x.manualMatches.length
                }])
              }, " Manual: " + Ul(x.manualMatches.length), 3),
              fn("span", {
                class: Bl(["badge badge-error w-max", {
                  "text-error-content": !f(x) && x.noMatches.length,
                  "badge-soft": f(x) || !x.noMatches.length
                }])
              }, " None: " + Ul(x.noMatches.length), 3)
            ])
          ])
        ])
      ]))), 128)),
      fn("footer", B1, [
        h[2] || (h[2] = fn("span", null, "Do you want to proceed with the mapping?", -1)),
        s.value ? pi("", !0) : (Ye(), Yn("div", Z1, [
          ze(te(Av)),
          h[1] || (h[1] = fn("span", null, "Only perfect matches on LNodeSpecNaming and LNode/LN are supported for now.", -1))
        ])),
        fn("div", U1, [
          fn("button", {
            class: "btn-no",
            onClick: h[0] || (h[0] = //@ts-ignore
            (...x) => te(i).handleClose && te(i).handleClose(...x))
          }, "No"),
          fn("button", {
            class: "btn-yes",
            onClick: o,
            disabled: !s.value
          }, "Yes", 8, K1)
        ])
      ])
    ], 64));
  }
}), z1 = /* @__PURE__ */ ha(G1, [["__scopeId", "data-v-6ff5041e"]]), j1 = { key: 0 }, H1 = { key: 1 }, $1 = { key: "loader" }, W1 = /* @__PURE__ */ dn({
  __name: "mapping-validation-dialog",
  setup(e) {
    const l = Ps(), { isLoading: i, error: a } = Lt(l);
    return (s, o) => (Ye(), Yn(Mn, null, [
      o[0] || (o[0] = fn("h1", { class: "text-2xl font-black mb-5" }, "Mapping Validation", -1)),
      ze(ug, {
        name: "fade-slide",
        mode: "out-in"
      }, {
        default: ln(() => [
          !te(i) && te(a) ? (Ye(), Yn("div", j1, [
            ze(RS)
          ])) : !te(i) && !te(a) ? (Ye(), Yn("div", H1, [
            ze(z1)
          ])) : (Ye(), Yn("div", $1, [
            ze(BS)
          ]))
        ]),
        _: 1
      })
    ], 64));
  }
}), Y1 = /* @__PURE__ */ ha(W1, [["__scopeId", "data-v-d327a7a1"]]), Ps = /* @__PURE__ */ lo("s-ied-implementation/mapping", () => {
  const e = io(), { sdkInstance: l, icdSdkInstance: i } = Lt(e), a = Ds(), { selectedSied: s } = Lt(a), o = _d({
    LNodeSpecNaming: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    LNode: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    DO: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    DA: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    SourceRef: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    ControlRef: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    }
  }), f = Fe([]), d = Fe(!1), h = Fe(null), x = _d({
    current: 0,
    total: 0,
    message: "Building...",
    scope: void 0
  });
  function y(M) {
    const { current: U, total: z, message: X, scope: B } = M;
    x.value = {
      current: U,
      total: z,
      message: `${X} (${U} / ${z})`,
      scope: B
    };
  }
  async function I() {
    if (!l.value || !i.value)
      throw new Error("SDK instance is not initialized");
    const M = Ss();
    o.reset(), o.value = await q({
      sdkInstance: l.value,
      icdSdkInstance: i.value,
      selectedSied: s.value
    }), M.setCurrentDialog({
      component: Y1,
      props: {},
      isLoading: _e(() => d.value)
    });
  }
  async function q(M) {
    const { sdkInstance: U, icdSdkInstance: z, selectedSied: X } = M;
    Xu(X);
    const B = (await U.api.fromRoot().getChildren({
      filter: {
        pick: ["LNode", "LNodeSpecNaming", "SourceRef", "ControlRef"]
      }
    })).treeChildren, K = (await z.api.fromRoot().getChildren({
      filter: {
        pick: ["LN", "LNode", "LNodeSpecNaming", "SourceRef", "ControlRef"]
      }
    })).treeChildren, { LNode: W = [] } = U.utils.groupRecordsByTagName(B), { LN: ae = [], LNode: ne = [] } = z.utils.groupRecordsByTagName(K), oe = await R({
      sdkInstance: U,
      icdSdkInstance: z,
      selectedSied: X,
      localLnodes: W,
      icdLns: ae,
      icdLnodes: ne
    });
    return {
      LNodeSpecNaming: oe.lNodeSpecNamingMetrics,
      LNode: oe.lNodeToLnMetrics,
      DO: oe.doMetrics,
      DA: oe.daMetrics,
      SourceRef: oe.sourceRefMetrics,
      ControlRef: oe.controlRefMetrics
    };
  }
  async function R(M) {
    const { sdkInstance: U, icdSdkInstance: z, selectedSied: X, localLnodes: B, icdLns: K, icdLnodes: W } = M, {
      SourceRef: ae = [],
      ControlRef: ne = [],
      LNodeSpecNaming: oe = []
    } = z.utils.groupRecordsByTagName(W.flatMap((Le) => Le.treeChildren)), k = $s({
      sdkInstance: U,
      records: oe,
      keyAttributes: ["sLdInst", "sPrefix", "sLnClass", "sLnInst"]
    }), me = $s({
      sdkInstance: U,
      records: K,
      keyAttributes: ["prefix", "lnClass", "inst"]
    }), be = $s({
      sdkInstance: U,
      records: ae,
      keyAttributes: ["input", "inputInst", "pDA"]
    }), re = $s({
      sdkInstance: U,
      records: ne,
      keyAttributes: ["output", "outputInst"]
    }), ye = [], xe = [], Se = [], ge = [], ce = [], de = [];
    for (const Le of B) {
      const { iedName: Ae } = U.utils.getAttributesValuesByName({
        attributes: Le.attributes
      }), { name: We } = U.utils.getAttributesValuesByName({
        attributes: X.attributes
      });
      if (!(Ae === We)) continue;
      const cn = Cs({
        attributes: U.utils.getAttributesValuesByName({
          attributes: Le.attributes
        }),
        keys: ["prefix", "lnClass", "lnInst"]
      }), bn = cn ? me.get(cn) : void 0, gn = pS({
        sdkInstance: U,
        localLnode: Le,
        icdLNodeSpecNamingMap: k
      });
      gn && ye.push(gn);
      const tn = hS({
        localLnode: Le,
        matchingIcdLn: bn
      });
      xe.push(tn);
      const _ = (await U.api.fromElement({ tagName: "LNode", id: Le.id }).resolveDataModel().getContext()).currentFocus, Z = U.utils.toDataModelRecords({
        version: Cc,
        records: _.treeChildren
      });
      if (Xu(
        Z.length > 0,
        `Local LNode with id ${Le.id} has no resolved data model`
      ), bn) {
        const j = (await z.api.fromElement({ tagName: "LN", id: bn.id }).resolveDataModel().getContext()).currentFocus, ie = z.utils.toDataModelRecords({
          version: Cc,
          records: j.treeChildren
        });
        if (!ie.length)
          throw new Error(`ICD LN with id ${bn.id} has no resolved data model`);
        f.value.push(...ie);
        const { doMetrics: fe, daMetrics: Ce } = xS({
          sdkInstance: U,
          localDataModel: Z,
          icdDataModel: ie
        });
        Se.push(fe), ge.push(Ce);
      } else {
        const { doMetrics: De, daMetrics: j } = IS({
          sdkInstance: U,
          localDataModel: Z
        });
        Se.push(De), ge.push(j);
        continue;
      }
      const ue = gS({
        sdkInstance: U,
        localLnode: Le,
        icdSourceRefMap: be
      });
      ce.push(...ue);
      const Qe = vS({
        sdkInstance: U,
        localLnode: Le,
        icdControlRefMap: re
      });
      de.push(...Qe);
    }
    return {
      lNodeSpecNamingMetrics: Ia(ye),
      lNodeToLnMetrics: Ia(xe),
      doMetrics: Ia(Se),
      daMetrics: Ia(ge),
      sourceRefMetrics: Ia(ce),
      controlRefMetrics: Ia(de)
    };
  }
  async function E() {
    try {
      d.value = !0, h.value = null, x.reset(), Xu(l.value, "Local SDK instance is not initialized"), Xu(i.value, "ICD SDK instance is not initialized"), Xu(s.value, "Selected SIED is not initialized");
      let M = l.value.api.fromRoot({
        onProgress: ({ current: W, total: ae, message: ne, scope: oe }) => y({
          current: W,
          total: ae,
          message: `${ne}`,
          scope: oe
        })
      });
      if (!(o.value.LNodeSpecNaming.total === o.value.LNodeSpecNaming.perfectMatches.length)) {
        h.value = "LNodeSpecNaming has unmatched items - not supported yet";
        return;
      }
      for (const W of o.value.LNode.perfectMatches) {
        const { local: ae, icd: ne } = W;
        Xu(ne.parent, "ICD LN has no parent LDevice");
        const oe = await i.value.api.getElement({
          tagName: "LDevice",
          id: ne.parent.id
        });
        if (!oe) throw new Error("ICD LDevice not found");
        const k = i.value.utils.getAttributeValueByName({
          attributes: oe.attributes,
          name: "inst"
        }), me = i.value.utils.getAttributesValuesByName({
          attributes: ne.attributes
        });
        M = M.goToElement({
          tagName: "LNode",
          id: ae.id
        }).update({
          attributes: [
            { name: "ldInst", value: k },
            { name: "lnClass", value: me.lnClass },
            { name: "prefix", value: me.prefix },
            { name: "lnInst", value: me.inst }
          ]
        }).goToElement({ tagName: "SCL" });
      }
      for (const W of o.value.SourceRef.perfectMatches) {
        const { local: ae, icd: ne } = W;
        M = M.goToElement({
          tagName: "SourceRef",
          id: ae.id
        }).update({
          attributes: [
            {
              name: "extRefAddr",
              value: ne.attributes.find((oe) => oe.name === "extRefAddr")?.value
            }
            // will be implemente later
            // {
            // 	name: 'extRefUuid',
            // 	value: icd.attributes.find((a) => a.name === 'extRefUuid')?.value,
            // },
          ]
        }).goToElement({ tagName: "SCL" });
      }
      for (const W of o.value.ControlRef.perfectMatches) {
        const { local: ae, icd: ne } = W;
        M = M.goToElement({
          tagName: "ControlRef",
          id: ae.id
        }).update({
          attributes: [
            {
              name: "extCtrlAddr",
              value: ne.attributes.find((oe) => oe.name === "extCtrlAddr")?.value
            }
            // wil be implemented later
            // {
            // 	name: 'extCtrlUuid',
            // 	value: icd.attributes.find((a) => a.name === 'extCtrlUuid')?.value,
            // },
          ]
        }).goToElement({ tagName: "SCL" });
      }
      const z = await i.value.api.fromRoot().getChildren({ filter: { pick: [{ tagName: "IED", deep: !0 }] } });
      if (!z.treeChildren.length || !z.treeChildren[0] || z.treeChildren.length !== 1)
        throw new Error("ICD should have one IED to map from");
      const B = (await l.value.api.fromElement({ tagName: "Communication" }).getChildren({
        filter: { pick: ["SubNetwork"] }
      })).treeChildren.find(
        (W) => W.attributes.some(
          (ae) => ae.name === "name" && ae.value === "Default_Subnet"
        )
      )?.id;
      Xu(B, "Default_Subnet SubNetwork not found in Communication"), await M.deepCloneChild({
        record: z.treeChildren[0],
        setFocus: !0
      }).update({
        attributes: [
          {
            name: "name",
            value: s.value.attributes.find((W) => W.name === "name")?.value || ""
          }
        ]
      }).attachAllAccessPointToSubNetwork({ subnetworkId: B }).goToElement({
        tagName: "DataTypeTemplates"
      }).addToDataModel({
        dataModel: f.value
      }).goToElement({
        tagName: "IED",
        id: s.value.id
      }).delete().commit(), a.resetSelection();
    } catch (M) {
      throw d.value = !1, h.value = M instanceof Error ? M.message : String(M), console.error("Error during applyMapping:", M), M;
    }
  }
  return {
    // states
    metrics: o,
    icdLnodeTypes: f,
    isLoading: d,
    error: h,
    progress: x,
    // actions
    openDialogToValidateMapping: I,
    gatherMetrics: q,
    calculateLNodeNestedMetrics: R,
    applyMapping: E
  };
});
function X1(e) {
  return $i() ? (ca(e), !0) : !1;
}
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
function Q1(e, l) {
  const i = Fe(void 0), a = e.subscribe({
    next: (s) => i.value = s,
    error: void 0
  });
  return X1(() => {
    a.unsubscribe();
  }), i;
}
const J1 = { class: "pl-2" }, eC = /* @__PURE__ */ dn({
  __name: "element-tree",
  setup(e) {
    const l = io(), i = Ds(), { sdkInstance: a } = Lt(l), { selectedLnodeId: s } = Lt(i), o = t0(async () => {
      if (!a.value) return [];
      const h = await a.value.api.fromRoot().getChildren({
        filter: {
          pick: ["Substation", "VoltageLevel", "Bay", "Function", "SubFunction", "LNode"]
        }
      });
      function x(y) {
        return {
          tag: y.tagName,
          id: y.id,
          ...y.treeChildren.length && {
            children: y.treeChildren.map((I) => x(I))
          }
        };
      }
      return [x(h)];
    }), f = _e(() => o.value?.find((h) => h.tag === "SCL")?.id);
    function d(h) {
      h.value.tag === "LNode" && (s.value = h.value.id);
    }
    return (h, x) => f.value ? (Ye(), xn(te(uS), {
      key: 0,
      class: "list-none select-none w-full text-stone-700 p-2 text-sm font-medium",
      items: te(o),
      "get-key": (y) => y.id,
      "default-expanded": [f.value],
      "propagate-select": ""
    }, {
      default: ln(({ flattenItems: y }) => [
        (Ye(!0), Yn(Mn, null, ys(y, (I) => (Ye(), xn(te(cS), pl({
          key: I.value.id,
          style: { "padding-left": `${I.level - 0.5}rem` }
        }, { ref_for: !0 }, I.bind, {
          class: "flex items-center py-1 px-2 my-0.5 rounded outline-none focus:ring-primary focus:ring-2 data-[selected]:bg-primary/20",
          onSelect: (q) => d(I)
        }), {
          default: ln(() => [
            te(Vm)[I.value.tag] ? (Ye(), xn(xs(te(Vm)[I.value.tag]), {
              key: 0,
              class: "h-4 w-4"
            })) : pi("", !0),
            fn("div", J1, Ul(I.value.tag), 1)
          ]),
          _: 2
        }, 1040, ["style", "onSelect"]))), 128))
      ]),
      _: 1
    }, 8, ["items", "get-key", "default-expanded"])) : pi("", !0);
  }
}), nC = { class: "h-full overflow-auto" }, lC = { class: "p-2 space-y-5" }, tC = { class: "flex items-center text-sm font-medium" }, iC = { class: "flex items-center justify-between text-sm font-medium" }, uC = { class: "flex gap-2" }, aC = {
  class: "btn btn-primary text-primary-content flex-2/3",
  type: "submit"
}, rC = { class: "pb-20" }, sC = /* @__PURE__ */ dn({
  __name: "custom-sidebar",
  setup(e) {
    const l = io(), i = Ds(), a = Ps(), { sdkInstance: s } = Lt(l), { selectedSied: o } = Lt(i), f = Jm("icdInputRef"), d = b0(() => s.value ? s.value.database.sclElements.where("tagName").equals("IED").toArray() : []), h = Q1(d), x = _e(() => h.value ? h.value?.filter(
      (q) => q.attributes.some(
        (R) => R.name === "manufacturer" && R.value === "S_IED"
      )
    ) || [] : []);
    function y(I) {
      return I?.attributes.find((q) => q.name === "name")?.value || "";
    }
    return vl(() => {
      f.value && (i.setupFileDialog(f.value), i.loadIcdFileInMemory(f.value));
    }), Dt(() => {
      i.resetSelection();
    }), (I, q) => (Ye(), Yn("aside", nC, [
      fn("form", {
        class: "sticky top-0 bg-base-100 pb-2",
        method: "dialog",
        onSubmit: q[3] || (q[3] = si(
          //@ts-ignore
          (...R) => te(a).openDialogToValidateMapping && te(a).openDialogToValidateMapping(...R),
          ["stop"]
        ))
      }, [
        fn("div", lC, [
          fn("div", tC, [
            q[4] || (q[4] = fn("label", {
              class: "min-w-fit mr-5",
              for: "selected-ied-name"
            }, "S-IED Name", -1)),
            ze(te(cw), {
              class: "dropdown w-full",
              modelValue: te(o),
              "onUpdate:modelValue": q[0] || (q[0] = (R) => Vn(o) ? o.value = R : null)
            }, {
              default: ln(() => [
                ze(te(zb), { class: "combobox-anchor" }, {
                  default: ln(() => [
                    ze(te(yw), {
                      required: "",
                      id: "selected-ied-name",
                      name: "selectedIedName",
                      class: "input-ghost outline-none",
                      placeholder: "Search by name...",
                      "display-value": (R) => y(R)
                    }, null, 8, ["display-value"]),
                    ze(te(ww), null, {
                      default: ln(() => [
                        ze(te(wS), { class: "h-4 w-4 text-primary cursor-pointer" })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                ze(te(pw), { class: "dropdown-content mt-2 bg-base-100 rounded-box w-full shadow-sm" }, {
                  default: ln(() => [
                    ze(te(Cw), { class: "p-[5px]" }, {
                      default: ln(() => [
                        ze(te(gw), { class: "text-base-content text-xs font-medium text-center py-2" }),
                        (Ye(!0), Yn(Mn, null, ys(x.value, (R) => (Ye(), xn(te(Lw), {
                          key: R.id,
                          value: R,
                          class: "combobox-item"
                        }, {
                          default: ln(() => [
                            ze(te(Ow), { class: "absolute left-0 w-[25px] inline-flex items-center justify-center" }, {
                              default: ln(() => [
                                ze(te(ap), { class: "h-3 w-3" })
                              ]),
                              _: 1
                            }),
                            fn("span", null, Ul(y(R)), 1)
                          ]),
                          _: 2
                        }, 1032, ["value"]))), 128))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["modelValue"])
          ]),
          fn("div", iC, [
            q[5] || (q[5] = fn("label", {
              class: "min-w-fit mr-5",
              for: "selected-icd-file"
            }, "ICD", -1)),
            fn("input", {
              required: "",
              id: "selected-icd-file",
              name: "selectedIcdFile",
              ref_key: "icdInputRef",
              ref: f,
              type: "file",
              class: "file-input file-input-primary w-full",
              onClick: q[1] || (q[1] = (R) => te(i).importIcdFile())
            }, null, 512)
          ]),
          fn("div", uC, [
            fn("button", {
              class: "btn-remove-reset",
              type: "reset",
              onClick: q[2] || (q[2] = //@ts-ignore
              (...R) => te(i).resetSelection && te(i).resetSelection(...R))
            }, [
              ze(te(SS), { class: "h-4 w-4" }),
              q[6] || (q[6] = Gi(" Reset ", -1))
            ]),
            fn("button", aC, [
              ze(te(ap), { class: "h-4 w-4" }),
              q[7] || (q[7] = Gi(" Validate mapping ", -1))
            ])
          ])
        ]),
        q[8] || (q[8] = fn("div", { class: "border-b mt-2" }, null, -1))
      ], 32),
      fn("div", rC, [
        ze(eC)
      ])
    ]));
  }
}), cC = /* @__PURE__ */ ha(sC, [["__scopeId", "data-v-ee976485"]]), oC = { class: "flex flex-col gap-2 p-4" }, mC = /* @__PURE__ */ dn({
  __name: "main-area",
  setup(e) {
    const l = Ds(), { selectedLnodeId: i, selectedSied: a, currentActiveIcdDatabaseName: s } = Lt(l), o = _e(() => a.value?.attributes.find((h) => h.name === "name")?.value || "None"), f = _e(() => s.value || "None"), d = _e(() => i.value || "None");
    return (h, x) => (Ye(), Yn("div", oC, [
      fn("span", {
        class: Bl(o.value === "None" ? "text-error" : "")
      }, " Selected S-IED: " + Ul(o.value), 3),
      fn("span", {
        class: Bl(f.value === "None" ? "text-error" : "")
      }, " Selected ICD: " + Ul(f.value), 3),
      fn("span", {
        class: Bl(d.value === "None" ? "text-error" : "")
      }, " Selected LNode: " + Ul(d.value), 3)
    ]));
  }
}), fC = { class: "modal-box max-w-136" }, dC = ["disabled"], pC = /* @__PURE__ */ dn({
  __name: "dialog-container",
  setup(e) {
    const l = Ss(), { currentDialog: i } = Lt(l), a = Jm("dialogRef");
    return vl(() => {
      a.value && (l.dialogRef = a.value);
    }), (s, o) => (Ye(), Yn("dialog", {
      class: "modal",
      ref: "dialogRef",
      onCancel: o[1] || (o[1] = (f) => te(i).isLoading?.value ? f.preventDefault() : null)
    }, [
      fn("div", fC, [
        fn("button", {
          class: "dialog-button",
          onClick: o[0] || (o[0] = //@ts-ignore
          (...f) => te(l).handleClose && te(l).handleClose(...f)),
          disabled: te(i).isLoading?.value
        }, [
          ze(te(CS), { class: "h-4 w-4" })
        ], 8, dC),
        te(i).component ? (Ye(), xn(xs(te(i).component), kc(pl({ key: 0 }, te(i).props)), null, 16)) : pi("", !0)
      ])
    ], 544));
  }
}), hC = /* @__PURE__ */ ha(pC, [["__scopeId", "data-v-0ea1d8af"]]), gC = /* @__PURE__ */ dn({
  __name: "app",
  props: {
    api: {}
  },
  setup(e) {
    const l = e, i = io(), a = Fe();
    return vl(() => {
      a.value = l.api.activeFileName.subscribe(
        (s) => {
          s && i.initApp(s);
        }
      ), l.api.activeFileName.value && i.initApp(l.api.activeFileName.value);
    }), Dt(() => {
      a.value?.();
    }), (s, o) => (Ye(), Yn(Mn, null, [
      ze(dS, null, {
        "primary-sidebar": ln(() => [
          ze(cC)
        ]),
        "main-area": ln(() => [
          ze(mC)
        ]),
        _: 1
      }),
      ze(hC)
    ], 64));
  }
});
function QC(e, l) {
  if (!document.getElementById(e)) {
    console.error({ msg: "could not found root element", rootId: e });
    return;
  }
  const a = wc(gC, { api: l });
  return a.use(aL()), a.mount(`#${e}`), a.unmount;
}
export {
  QC as default
};
