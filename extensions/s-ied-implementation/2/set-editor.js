(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode(`.layout[data-v-bf5a22d1]{display:grid;height:100vh;grid-template-rows:auto 1fr;grid-template-columns:4rem 1fr}.menubar[data-v-bf5a22d1]{grid-column-start:1;grid-column-end:5}.activity-bar[data-v-bf5a22d1]{padding:.5rem}@layer daisyui.component{:where(.btn-no[data-v-e1223411]){width:unset}.btn-no[data-v-e1223411]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-e1223411]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-no[data-v-e1223411]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-e1223411]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-no[data-v-e1223411]{--btn-noise:var(--fx-noise)}.prose .btn-no[data-v-e1223411]{text-decoration-line:none}@media (hover:hover){.btn-no[data-v-e1223411]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-e1223411]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-no[data-v-e1223411]:focus-visible,.btn-no[data-v-e1223411]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-no[data-v-e1223411]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-e1223411]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-no[data-v-e1223411]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-e1223411]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-no[data-v-e1223411]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-no[data-v-e1223411]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-no[data-v-e1223411]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-no[data-v-e1223411]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}:where(.btn-yes[data-v-e1223411]){width:unset}.btn-yes[data-v-e1223411]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-e1223411]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-yes[data-v-e1223411]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-e1223411]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-yes[data-v-e1223411]{--btn-noise:var(--fx-noise)}.prose .btn-yes[data-v-e1223411]{text-decoration-line:none}@media (hover:hover){.btn-yes[data-v-e1223411]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-e1223411]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-yes[data-v-e1223411]:focus-visible,.btn-yes[data-v-e1223411]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-yes[data-v-e1223411]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-e1223411]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-yes[data-v-e1223411]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-e1223411]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-yes[data-v-e1223411]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-yes[data-v-e1223411]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-yes[data-v-e1223411]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-yes[data-v-e1223411]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}}@layer daisyui.modifier{.btn-no[data-v-e1223411]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-e1223411]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-no[data-v-e1223411]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-no[data-v-e1223411]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-e1223411]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-no[data-v-e1223411]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-e1223411]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-no[data-v-e1223411]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[data-v-e1223411]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-no[disabled][data-v-e1223411]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[disabled][data-v-e1223411]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-no[disabled][data-v-e1223411]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-no[disabled][data-v-e1223411]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[disabled][data-v-e1223411]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-no[disabled][data-v-e1223411]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-no[disabled][data-v-e1223411]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-no[disabled][data-v-e1223411]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-no[disabled][data-v-e1223411]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-no[data-v-e1223411]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}@media (hover:none){.btn-no[data-v-e1223411]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}}.btn-no[data-v-e1223411]{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.btn-yes[data-v-e1223411]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-e1223411]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-yes[data-v-e1223411]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-yes[data-v-e1223411]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-e1223411]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-yes[data-v-e1223411]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-e1223411]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-yes[data-v-e1223411]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[data-v-e1223411]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-yes[disabled][data-v-e1223411]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[disabled][data-v-e1223411]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-yes[disabled][data-v-e1223411]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-yes[disabled][data-v-e1223411]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[disabled][data-v-e1223411]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-yes[disabled][data-v-e1223411]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-yes[disabled][data-v-e1223411]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-yes[disabled][data-v-e1223411]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-yes[disabled][data-v-e1223411]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-yes[data-v-e1223411]{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.badge-soft[data-v-e1223411]{color:var(--badge-color,var(--color-base-content));background-color:var(--badge-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.badge-soft[data-v-e1223411]{background-color:color-mix(in oklab,var(--badge-color,var(--color-base-content))8%,var(--color-base-100))}}.badge-soft[data-v-e1223411]{border-color:var(--badge-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.badge-soft[data-v-e1223411]{border-color:color-mix(in oklab,var(--badge-color,var(--color-base-content))10%,var(--color-base-100))}}.badge-soft[data-v-e1223411]{background-image:none}.badge-warn[data-v-e1223411]{--badge-color:var(--color-neutral);--badge-fg:var(--color-neutral-content)}}@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){[data-v-ba54a0ea],[data-v-ba54a0ea]:before,[data-v-ba54a0ea]:after,[data-v-ba54a0ea]::backdrop{--tw-leading:initial}}}@layer daisyui.component{.combobox-anchor[data-v-ba54a0ea]{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);font-size:max(var(--font-size,.875rem),.875rem);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.combobox-anchor[data-v-ba54a0ea]{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.combobox-anchor[data-v-ba54a0ea]{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.combobox-anchor[data-v-ba54a0ea]{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.combobox-anchor[data-v-ba54a0ea]:where(input){display:inline-flex}.combobox-anchor[data-v-ba54a0ea] :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.combobox-anchor[data-v-ba54a0ea] :where(input):focus,.combobox-anchor[data-v-ba54a0ea] :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.combobox-anchor[data-v-ba54a0ea] :where(input):focus,.combobox-anchor[data-v-ba54a0ea] :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.combobox-anchor[data-v-ba54a0ea] :where(input[type=url]),.combobox-anchor[data-v-ba54a0ea] :where(input[type=email]){direction:ltr}.combobox-anchor[data-v-ba54a0ea] :where(input[type=date]){display:inline-flex}.combobox-anchor[data-v-ba54a0ea]:focus,.combobox-anchor[data-v-ba54a0ea]:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.combobox-anchor[data-v-ba54a0ea]:focus,.combobox-anchor[data-v-ba54a0ea]:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.combobox-anchor[data-v-ba54a0ea]:focus,.combobox-anchor[data-v-ba54a0ea]:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}@media (pointer:coarse){@supports (-webkit-touch-callout:none){.combobox-anchor[data-v-ba54a0ea]:focus,.combobox-anchor[data-v-ba54a0ea]:focus-within{--font-size:1rem}}}.combobox-anchor[data-v-ba54a0ea]:has(>input[disabled]),.combobox-anchor[data-v-ba54a0ea]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ba54a0ea]{cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.combobox-anchor[data-v-ba54a0ea]:has(>input[disabled]),.combobox-anchor[data-v-ba54a0ea]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ba54a0ea]{color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.combobox-anchor[data-v-ba54a0ea]:has(>input[disabled]),.combobox-anchor[data-v-ba54a0ea]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ba54a0ea])::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.combobox-anchor[data-v-ba54a0ea]:has(>input[disabled]),.combobox-anchor[data-v-ba54a0ea]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ba54a0ea])::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.combobox-anchor[data-v-ba54a0ea]:has(>input[disabled]),.combobox-anchor[data-v-ba54a0ea]:is(:disabled,[disabled]),fieldset:disabled .combobox-anchor[data-v-ba54a0ea]{box-shadow:none}.combobox-anchor:has(>input[disabled])>input[disabled][data-v-ba54a0ea]{cursor:not-allowed}.combobox-anchor[data-v-ba54a0ea]::-webkit-date-and-time-value{text-align:inherit}.combobox-anchor[type=number][data-v-ba54a0ea]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.combobox-anchor[data-v-ba54a0ea]::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.combobox-anchor[data-v-ba54a0ea]:has(>input[type=date]) :where(input[type=date]){webkit-appearance:none;appearance:none;display:inline-flex}.combobox-anchor:has(>input[type=date]) input[type=date][data-v-ba54a0ea]::-webkit-calendar-picker-indicator{cursor:pointer;width:1em;height:1em;position:absolute;inset-inline-end:.75em}:where(.btn-remove-reset[data-v-ba54a0ea]){width:unset}.btn-remove-reset[data-v-ba54a0ea]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ba54a0ea]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-remove-reset[data-v-ba54a0ea]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ba54a0ea]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-remove-reset[data-v-ba54a0ea]{--btn-noise:var(--fx-noise)}.prose .btn-remove-reset[data-v-ba54a0ea]{text-decoration-line:none}@media (hover:hover){.btn-remove-reset[data-v-ba54a0ea]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ba54a0ea]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-remove-reset[data-v-ba54a0ea]:focus-visible,.btn-remove-reset[data-v-ba54a0ea]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-remove-reset[data-v-ba54a0ea]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ba54a0ea]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-remove-reset[data-v-ba54a0ea]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ba54a0ea]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-remove-reset[data-v-ba54a0ea]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-remove-reset[data-v-ba54a0ea]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-remove-reset[data-v-ba54a0ea]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-remove-reset[data-v-ba54a0ea]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}:where(.btn-import-icd[data-v-ba54a0ea]){width:unset}.btn-import-icd[data-v-ba54a0ea]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ba54a0ea]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn-import-icd[data-v-ba54a0ea]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ba54a0ea]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn-import-icd[data-v-ba54a0ea]{--btn-noise:var(--fx-noise)}.prose .btn-import-icd[data-v-ba54a0ea]{text-decoration-line:none}@media (hover:hover){.btn-import-icd[data-v-ba54a0ea]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ba54a0ea]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn-import-icd[data-v-ba54a0ea]:focus-visible,.btn-import-icd[data-v-ba54a0ea]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn-import-icd[data-v-ba54a0ea]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ba54a0ea]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn-import-icd[data-v-ba54a0ea]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ba54a0ea]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-import-icd[data-v-ba54a0ea]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn-import-icd[data-v-ba54a0ea]:is(input[type=checkbox],input[type=radio]){appearance:none}.btn-import-icd[data-v-ba54a0ea]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn-import-icd[data-v-ba54a0ea]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}}.combobox-anchor[data-v-ba54a0ea]{width:100%}@layer daisyui.modifier{.combobox-anchor[data-v-ba54a0ea],.combobox-anchor[data-v-ba54a0ea]:focus,.combobox-anchor[data-v-ba54a0ea]:focus-within{--input-color:var(--color-primary)}.btn-remove-reset[data-v-ba54a0ea]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ba54a0ea]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-remove-reset[data-v-ba54a0ea]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-remove-reset[data-v-ba54a0ea]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ba54a0ea]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-remove-reset[data-v-ba54a0ea]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ba54a0ea]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-remove-reset[data-v-ba54a0ea]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[data-v-ba54a0ea]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-remove-reset[disabled][data-v-ba54a0ea]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[disabled][data-v-ba54a0ea]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-remove-reset[disabled][data-v-ba54a0ea]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-remove-reset[disabled][data-v-ba54a0ea]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[disabled][data-v-ba54a0ea]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-remove-reset[disabled][data-v-ba54a0ea]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[disabled][data-v-ba54a0ea]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-remove-reset[disabled][data-v-ba54a0ea]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-remove-reset[disabled][data-v-ba54a0ea]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-remove-reset[data-v-ba54a0ea]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}@media (hover:none){.btn-remove-reset[data-v-ba54a0ea]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}}.btn-remove-reset[data-v-ba54a0ea]{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.btn-import-icd[data-v-ba54a0ea]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ba54a0ea]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-import-icd[data-v-ba54a0ea]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn-import-icd[data-v-ba54a0ea]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ba54a0ea]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-import-icd[data-v-ba54a0ea]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ba54a0ea]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-import-icd[data-v-ba54a0ea]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[data-v-ba54a0ea]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-import-icd[disabled][data-v-ba54a0ea]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[disabled][data-v-ba54a0ea]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn-import-icd[disabled][data-v-ba54a0ea]:not(.btn-link,.btn-ghost){box-shadow:none}.btn-import-icd[disabled][data-v-ba54a0ea]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[disabled][data-v-ba54a0ea]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn-import-icd[disabled][data-v-ba54a0ea]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[disabled][data-v-ba54a0ea]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn-import-icd[disabled][data-v-ba54a0ea]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn-import-icd[disabled][data-v-ba54a0ea]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn-import-icd[data-v-ba54a0ea]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}@media (hover:none){.btn-import-icd[data-v-ba54a0ea]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}}.btn-import-icd[data-v-ba54a0ea]{--fontsize:.75rem;--btn-p:.75rem;--size:calc(var(--size-field,.25rem)*8);--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}}.combobox-item[data-v-ba54a0ea]{cursor:pointer;height:25px;font-size:var(--text-xs,.75rem);line-height:var(--tw-leading,var(--text-xs--line-height,calc(1/.75)));--tw-leading:1;-webkit-user-select:none;user-select:none;border-radius:3px;justify-content:space-between;align-items:center;padding-left:25px;padding-right:35px;line-height:1;display:flex;position:relative}.combobox-item[data-disabled][data-v-ba54a0ea]{pointer-events:none;color:var(--color-base-content)}.combobox-item[data-highlighted][data-v-ba54a0ea]{background-color:var(--color-primary);color:var(--color-primary-content);--tw-outline-style:none;outline-style:none}.btn-remove-reset[data-v-ba54a0ea]{flex:33.3333%}@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){[data-v-83dde715],[data-v-83dde715]:before,[data-v-83dde715]:after,[data-v-83dde715]::backdrop{--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000}}}@layer daisyui.component{:where(.dialog-button[data-v-83dde715]){width:unset}.dialog-button[data-v-83dde715]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-83dde715]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.dialog-button[data-v-83dde715]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-83dde715]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.dialog-button[data-v-83dde715]{--btn-noise:var(--fx-noise)}.prose .dialog-button[data-v-83dde715]{text-decoration-line:none}@media (hover:hover){.dialog-button[data-v-83dde715]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-83dde715]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.dialog-button[data-v-83dde715]:focus-visible,.dialog-button[data-v-83dde715]:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.dialog-button[data-v-83dde715]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-83dde715]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.dialog-button[data-v-83dde715]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-83dde715]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.dialog-button[data-v-83dde715]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.dialog-button[data-v-83dde715]:is(input[type=checkbox],input[type=radio]){appearance:none}.dialog-button[data-v-83dde715]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.dialog-button[data-v-83dde715]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}}@layer daisyui.modifier{.dialog-button[data-v-83dde715]:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-83dde715]:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.dialog-button[data-v-83dde715]:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.dialog-button[data-v-83dde715]:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-83dde715]:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.dialog-button[data-v-83dde715]:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-83dde715]:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.dialog-button[data-v-83dde715]:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-83dde715]:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.dialog-button[disabled][data-v-83dde715]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[disabled][data-v-83dde715]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.dialog-button[disabled][data-v-83dde715]:not(.btn-link,.btn-ghost){box-shadow:none}.dialog-button[disabled][data-v-83dde715]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[disabled][data-v-83dde715]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.dialog-button[disabled][data-v-83dde715]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.dialog-button[disabled][data-v-83dde715]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.dialog-button[disabled][data-v-83dde715]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.dialog-button[disabled][data-v-83dde715]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.dialog-button[data-v-83dde715]{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.dialog-button[data-v-83dde715]:not(.btn-active,:hover,:active:focus,:focus-visible){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none}.dialog-button[data-v-83dde715]:not(.btn-active,:hover,:active:focus,:focus-visible):not(:disabled,[disabled],.btn-disabled){--btn-fg:currentColor;outline-color:currentColor}@media (hover:none){.dialog-button[data-v-83dde715]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none;--btn-fg:currentColor}}.dialog-button[data-v-83dde715]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-fg:var(--btn-color,var(--color-base-content));--btn-bg:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-83dde715]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-content))8%,var(--color-base-100))}}.dialog-button[data-v-83dde715]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-83dde715]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-content))10%,var(--color-base-100))}}.dialog-button[data-v-83dde715]:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-noise:none}@media (hover:none){.dialog-button[data-v-83dde715]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-fg:var(--btn-color,var(--color-base-content));--btn-bg:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-83dde715]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-content))8%,var(--color-base-100))}}.dialog-button[data-v-83dde715]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.dialog-button[data-v-83dde715]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-content))10%,var(--color-base-100))}}.dialog-button[data-v-83dde715]:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-noise:none}}.dialog-button[data-v-83dde715]{--fontsize:.75rem;--btn-p:.75rem;--size:calc(var(--size-field,.25rem)*8);--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}}.dialog-button[data-v-83dde715]{top:calc(var(--spacing,.25rem)*2);right:calc(var(--spacing,.25rem)*2);--tw-shadow:0 0 #0000;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow);position:absolute}@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-space-y-reverse:0;--tw-border-style:solid;--tw-leading:initial;--tw-font-weight:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-100:oklch(93.6% .032 17.717);--color-stone-700:oklch(37.4% .01 67.558);--color-black:#000;--spacing:.25rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--font-weight-medium:500;--font-weight-bold:700;--font-weight-black:900;--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E");scrollbar-color:currentColor #0000}@supports (color:color-mix(in lab,red,red)){:root{scrollbar-color:color-mix(in oklch,currentColor 35%,#0000)#0000}}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),oklch(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}@supports (width:if(else: 1px)) and (animation-timeline:scroll()){:root{animation:forwards set-page-has-scroll;animation-timeline:scroll()}@keyframes set-page-has-scroll{0%,to{--page-has-scroll:1}}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:if(style(--page-has-scroll: 1): stable; else: unset)}}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:where(:root),:root:has(input.theme-controller[value=ocean-light]:checked),[data-theme=ocean-light]{color-scheme:light;--color-base-100:oklch(98% 0 0);--color-base-200:oklch(97% 0 0);--color-base-300:oklch(92% 0 0);--color-base-content:oklch(37% 0 0);--color-primary:oklch(58.13% .0903 209.8);--color-primary-content:oklch(100% 0 0);--color-secondary:oklch(65.24% .0821 207.95);--color-secondary-content:oklch(100% 0 0);--color-accent:oklch(60% .118 184.704);--color-accent-content:oklch(98% .001 106.423);--color-neutral:oklch(55% .013 58.071);--color-neutral-content:oklch(98% .031 120.757);--color-info:oklch(70% .165 254.624);--color-info-content:oklch(98% .001 106.423);--color-success:oklch(72% .219 149.579);--color-success-content:oklch(98% .001 106.423);--color-warning:oklch(87% .169 91.605);--color-warning-content:oklch(98% .001 106.423);--color-error:oklch(63% .237 25.331);--color-error-content:oklch(98% .001 106.423);--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-content)}}@layer components;@layer utilities{@layer daisyui.component{.modal{pointer-events:none;visibility:hidden;width:100%;max-width:none;height:100%;max-height:none;color:inherit;transition:visibility .3s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;overscroll-behavior:contain;z-index:999;scrollbar-gutter:auto;background-color:#0000;place-items:center;margin:0;padding:0;display:grid;position:fixed;inset:0;overflow:clip}.modal::backdrop{display:none}.dropdown{position-area:var(--anchor-v,bottom)var(--anchor-h,span-right);display:inline-block;position:relative}.dropdown>:not(summary):focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.dropdown>:not(summary):focus{outline-offset:2px;outline:2px solid #0000}}.dropdown .dropdown-content{position:absolute}.dropdown:not(details,.dropdown-open,.dropdown-hover:hover,:focus-within) .dropdown-content,.dropdown.dropdown-hover:not(:hover) [tabindex]:first-child:focus:not(:focus-visible)~.dropdown-content{transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover],.dropdown .dropdown-content{z-index:999}@media (prefers-reduced-motion:no-preference){.dropdown[popover],.dropdown .dropdown-content{transition-behavior:allow-discrete;transition-property:opacity,scale,display;transition-duration:.2s;transition-timing-function:cubic-bezier(.4,0,.2,1);animation:.2s dropdown}}@starting-style{.dropdown[popover],.dropdown .dropdown-content{opacity:0;scale:95%}}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within)>[tabindex]:first-child{pointer-events:none}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within) .dropdown-content{opacity:1}.dropdown.dropdown-hover:hover .dropdown-content{opacity:1;scale:100%}.dropdown:is(details) summary::-webkit-details-marker{display:none}:is(.dropdown.dropdown-open,.dropdown:focus,.dropdown:focus-within) .dropdown-content{scale:100%}.dropdown:where([popover]){background:0 0}.dropdown[popover]{color:inherit;position:fixed}@supports not (position-area:bottom){.dropdown[popover]{margin:auto}.dropdown[popover].dropdown-open:not(:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover]::backdrop{background-color:oklab(0% none none/.3)}}.dropdown[popover]:not(.dropdown-open,:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}:where(.btn){width:unset}.btn{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn{--btn-noise:var(--fx-noise)}.prose .btn{text-decoration-line:none}@media (hover:hover){.btn:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn:focus-visible,.btn:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn:is(input[type=checkbox],input[type=radio]){appearance:none}.btn:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.list{flex-direction:column;font-size:.875rem;display:flex}.list .list-row{--list-grid-cols:minmax(0,auto)1fr;border-radius:var(--radius-box);word-break:break-word;grid-auto-flow:column;grid-template-columns:var(--list-grid-cols);gap:1rem;padding:1rem;display:grid;position:relative}:is(.list>:not(:last-child).list-row,.list>:not(:last-child) .list-row):after{content:"";border-bottom:var(--border)solid;inset-inline:var(--radius-box);border-color:var(--color-base-content);position:absolute;bottom:0}@supports (color:color-mix(in lab,red,red)){:is(.list>:not(:last-child).list-row,.list>:not(:last-child) .list-row):after{border-color:color-mix(in oklab,var(--color-base-content)5%,transparent)}}.input{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);font-size:max(var(--font-size,.875rem),.875rem);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.input:where(input){display:inline-flex}.input :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.input :where(input):focus,.input :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.input :where(input):focus,.input :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.input :where(input[type=url]),.input :where(input[type=email]){direction:ltr}.input :where(input[type=date]){display:inline-flex}.input:focus,.input:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.input:focus,.input:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.input:focus,.input:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}@media (pointer:coarse){@supports (-webkit-touch-callout:none){.input:focus,.input:focus-within{--font-size:1rem}}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input{cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input{color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input)::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input)::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input{box-shadow:none}.input:has(>input[disabled])>input[disabled]{cursor:not-allowed}.input::-webkit-date-and-time-value{text-align:inherit}.input[type=number]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.input::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.input:has(>input[type=date]) :where(input[type=date]){webkit-appearance:none;appearance:none;display:inline-flex}.input:has(>input[type=date]) input[type=date]::-webkit-calendar-picker-indicator{cursor:pointer;width:1em;height:1em;position:absolute;inset-inline-end:.75em}.avatar{vertical-align:middle;display:inline-flex;position:relative}.avatar>div{aspect-ratio:1;display:block;overflow:hidden}.avatar img{object-fit:cover;width:100%;height:100%}.file-input{cursor:pointer;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;webkit-user-select:none;-webkit-user-select:none;user-select:none;width:clamp(3rem,20rem,100%);height:var(--size);border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));align-items:center;padding-inline-end:.75rem;font-size:.875rem;line-height:2;display:inline-flex}@supports (color:color-mix(in lab,red,red)){.file-input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.file-input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.file-input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.file-input::file-selector-button{cursor:pointer;webkit-user-select:none;-webkit-user-select:none;user-select:none;height:calc(100% + var(--border)*2);margin-inline-end:1rem;margin-block:calc(var(--border)*-1);color:var(--btn-fg);border-width:var(--border);border-style:solid;border-color:var(--btn-border);background-color:var(--btn-bg);background-size:calc(var(--noise)*100%);background-image:var(--btn-noise);text-shadow:0 .5px oklch(1 0 0/calc(var(--depth)*.15));box-shadow:0 .5px 0 .5px #fff inset,var(--btn-shadow);border-start-start-radius:calc(var(--join-ss,var(--radius-field) - var(--border)));border-end-start-radius:calc(var(--join-es,var(--radius-field) - var(--border)));margin-inline-start:calc(var(--border)*-1);padding-inline:1rem;font-size:.875rem;font-weight:600}@supports (color:color-mix(in lab,red,red)){.file-input::file-selector-button{box-shadow:0 .5px 0 .5px color-mix(in oklab,color-mix(in oklab,white 30%,var(--btn-bg))calc(var(--depth)*20%),#0000) inset,var(--btn-shadow)}}.file-input::file-selector-button{--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-border:var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.file-input::file-selector-button{--btn-border:color-mix(in oklab,var(--btn-bg),#000 5%)}}.file-input::file-selector-button{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.file-input::file-selector-button{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)30%,#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)30%,#0000)}}.file-input::file-selector-button{--btn-noise:var(--fx-noise)}.file-input:focus{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.file-input:focus{box-shadow:0 1px color-mix(in oklab,var(--input-color)10%,#0000)}}.file-input:focus{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate}.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200)}:is(.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]){box-shadow:none;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]){color:color-mix(in oklch,var(--color-base-content)20%,#0000)}}:is(.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]))::file-selector-button{cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.file-input:has(>input[disabled]),.file-input:is(:disabled,[disabled]))::file-selector-button{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}.modal-box{background-color:var(--color-base-100);border-top-left-radius:var(--modal-tl,var(--radius-box));border-top-right-radius:var(--modal-tr,var(--radius-box));border-bottom-left-radius:var(--modal-bl,var(--radius-box));border-bottom-right-radius:var(--modal-br,var(--radius-box));opacity:0;overscroll-behavior:contain;grid-row-start:1;grid-column-start:1;width:91.6667%;max-width:32rem;max-height:100vh;padding:1.5rem;transition:translate .3s ease-out,scale .3s ease-out,opacity .2s ease-out 50ms,box-shadow .3s ease-out;overflow-y:auto;scale:95%;box-shadow:0 25px 50px -12px #00000040}.divider{white-space:nowrap;height:1rem;margin:var(--divider-m,1rem 0);--divider-color:var(--color-base-content);flex-direction:row;align-self:stretch;align-items:center;display:flex}@supports (color:color-mix(in lab,red,red)){.divider{--divider-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.divider:before,.divider:after{content:"";background-color:var(--divider-color);flex-grow:1;width:100%;height:.125rem}@media print{.divider:before,.divider:after{border:.5px solid}}.divider:not(:empty){gap:1rem}.filter{flex-wrap:wrap;display:flex}.filter input[type=radio]{width:auto}.filter input{opacity:1;transition:margin .1s,opacity .3s,padding .3s,border-width .1s;overflow:hidden;scale:1}.filter input:not(:last-child){margin-inline-end:.25rem}.filter input.filter-reset{aspect-ratio:1}.filter input.filter-reset:after{content:""}.filter:not(:has(input:checked:not(.filter-reset))) .filter-reset,.filter:not(:has(input:checked:not(.filter-reset))) input[type=reset],.filter:has(input:checked:not(.filter-reset)) input:not(:checked,.filter-reset,input[type=reset]){opacity:0;border-width:0;width:0;margin-inline:0;padding-inline:0;scale:0}.modal-action{justify-content:flex-end;gap:.5rem;margin-top:1.5rem;display:flex}.status{aspect-ratio:1;border-radius:var(--radius-selector);background-color:var(--color-base-content);width:.5rem;height:.5rem;display:inline-block}@supports (color:color-mix(in lab,red,red)){.status{background-color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.status{vertical-align:middle;color:#0000004d;background-position:50%;background-repeat:no-repeat}@supports (color:color-mix(in lab,red,red)){.status{color:color-mix(in oklab,var(--color-black)30%,transparent)}}.status{background-image:radial-gradient(circle at 35% 30%,oklch(1 0 0/calc(var(--depth)*.5)),#0000);box-shadow:0 2px 3px -1px}@supports (color:color-mix(in lab,red,red)){.status{box-shadow:0 2px 3px -1px color-mix(in oklab,currentColor calc(var(--depth)*100%),#0000)}}.badge{border-radius:var(--radius-selector);vertical-align:middle;color:var(--badge-fg);border:var(--border)solid var(--badge-color,var(--color-base-200));width:fit-content;padding-inline:calc(.25rem*3 - var(--border));background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);background-color:var(--badge-bg);--badge-bg:var(--badge-color,var(--color-base-100));--badge-fg:var(--color-base-content);--size:calc(var(--size-selector,.25rem)*6);height:var(--size);justify-content:center;align-items:center;gap:.5rem;font-size:.875rem;display:inline-flex}}@layer daisyui.modifier{.modal.modal-open,.modal[open],.modal:target,.modal-toggle:checked+.modal{pointer-events:auto;visibility:visible;opacity:1;transition:visibility 0s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;background-color:#0006}:is(.modal.modal-open,.modal[open],.modal:target,.modal-toggle:checked+.modal) .modal-box{opacity:1;translate:0;scale:1}@starting-style{.modal.modal-open,.modal[open],.modal:target,.modal-toggle:checked+.modal{opacity:0}}.btn:disabled:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:disabled:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn:disabled:not(.btn-link,.btn-ghost){box-shadow:none}.btn:disabled{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:disabled{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn:disabled:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn:disabled:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn:disabled:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:disabled:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn[disabled]:not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn[disabled]:not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn[disabled]:not(.btn-link,.btn-ghost){box-shadow:none}.btn[disabled]{pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn[disabled]{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn[disabled]:hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn[disabled]:hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn[disabled]:hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn[disabled]:hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.list .list-row:has(.list-col-grow:first-child){--list-grid-cols:1fr}.list .list-row:has(.list-col-grow:nth-child(2)){--list-grid-cols:minmax(0,auto)1fr}.list .list-row:has(.list-col-grow:nth-child(3)){--list-grid-cols:minmax(0,auto)minmax(0,auto)1fr}.list .list-row:has(.list-col-grow:nth-child(4)){--list-grid-cols:minmax(0,auto)minmax(0,auto)minmax(0,auto)1fr}.list .list-row:has(.list-col-grow:nth-child(5)){--list-grid-cols:minmax(0,auto)minmax(0,auto)minmax(0,auto)minmax(0,auto)1fr}.list .list-row:has(.list-col-grow:nth-child(6)){--list-grid-cols:minmax(0,auto)minmax(0,auto)minmax(0,auto)minmax(0,auto)minmax(0,auto)1fr}.list .list-row :not(.list-col-wrap){grid-row-start:1}.avatar-placeholder>div{justify-content:center;align-items:center;display:flex}.btn-circle{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.badge-soft{color:var(--badge-color,var(--color-base-content));background-color:var(--badge-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.badge-soft{background-color:color-mix(in oklab,var(--badge-color,var(--color-base-content))8%,var(--color-base-100))}}.badge-soft{border-color:var(--badge-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.badge-soft{border-color:color-mix(in oklab,var(--badge-color,var(--color-base-content))10%,var(--color-base-100))}}.badge-soft{background-image:none}.input-ghost{box-shadow:none;background-color:#0000;border-color:#0000}.input-ghost:focus,.input-ghost:focus-within{background-color:var(--color-base-100);color:var(--color-base-content);box-shadow:none;border-color:#0000}.file-input-primary{--btn-color:var(--color-primary)}.file-input-primary::file-selector-button{color:var(--color-primary-content)}.file-input-primary,.file-input-primary:focus,.file-input-primary:focus-within{--input-color:var(--color-primary)}.btn-ghost:not(.btn-active,:hover,:active:focus,:focus-visible){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none}.btn-ghost:not(.btn-active,:hover,:active:focus,:focus-visible):not(:disabled,[disabled],.btn-disabled){--btn-fg:currentColor;outline-color:currentColor}@media (hover:none){.btn-ghost:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none;--btn-fg:currentColor}}.btn-outline:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}@media (hover:none){.btn-outline:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled,:checked){--btn-shadow:"";--btn-bg:#0000;--btn-fg:var(--btn-color);--btn-border:var(--btn-color);--btn-noise:none}}.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-fg:var(--btn-color,var(--color-base-content));--btn-bg:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-content))8%,var(--color-base-100))}}.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-content))10%,var(--color-base-100))}}.btn-soft:not(.btn-active,:hover,:active:focus,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-noise:none}@media (hover:none){.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-fg:var(--btn-color,var(--color-base-content));--btn-bg:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-content))8%,var(--color-base-100))}}.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:var(--btn-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-content))10%,var(--color-base-100))}}.btn-soft:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-noise:none}}.btn-sm{--fontsize:.75rem;--btn-p:.75rem;--size:calc(var(--size-field,.25rem)*8)}.badge-error{--badge-color:var(--color-error);--badge-fg:var(--color-error-content)}.badge-neutral{--badge-color:var(--color-neutral);--badge-fg:var(--color-neutral-content)}.badge-primary{--badge-color:var(--color-primary);--badge-fg:var(--color-primary-content)}.badge-warning{--badge-color:var(--color-warning);--badge-fg:var(--color-warning-content)}.btn-primary{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.input-primary,.input-primary:focus,.input-primary:focus-within{--input-color:var(--color-primary)}}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.top-0{top:calc(var(--spacing)*0)}.top-2{top:calc(var(--spacing)*2)}.right-2{right:calc(var(--spacing)*2)}.left-0{left:calc(var(--spacing)*0)}.my-0\\.5{margin-block:calc(var(--spacing)*.5)}.mt-2{margin-top:calc(var(--spacing)*2)}.mt-10{margin-top:calc(var(--spacing)*10)}.mr-5{margin-right:calc(var(--spacing)*5)}.mb-5{margin-bottom:calc(var(--spacing)*5)}.flex{display:flex}.hidden{display:none}.inline-flex{display:inline-flex}.size-6{width:calc(var(--spacing)*6);height:calc(var(--spacing)*6)}.h-3{height:calc(var(--spacing)*3)}.h-4{height:calc(var(--spacing)*4)}.h-\\[25px\\]{height:25px}.h-full{height:100%}.h-screen{height:100vh}.w-1{width:calc(var(--spacing)*1)}.w-3{width:calc(var(--spacing)*3)}.w-4{width:calc(var(--spacing)*4)}.w-12{width:calc(var(--spacing)*12)}.w-\\[25px\\]{width:25px}.w-full{width:100%}.w-max{width:max-content}.w-screen{width:100vw}.max-w-136{max-width:calc(var(--spacing)*136)}.min-w-fit{min-width:fit-content}.flex-2\\/3{flex:66.6667%}.cursor-pointer{cursor:pointer}.list-none{list-style-type:none}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.gap-2{gap:calc(var(--spacing)*2)}:where(.space-y-5>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*5)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*5)*calc(1 - var(--tw-space-y-reverse)))}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.rounded{border-radius:.25rem}.rounded-\\[3px\\]{border-radius:3px}.rounded-box{border-radius:var(--radius-box)}.rounded-full{border-radius:3.40282e38px}.border{border-style:var(--tw-border-style);border-width:1px}.bg-base-100{background-color:var(--color-base-100)}.bg-base-300{background-color:var(--color-base-300)}.bg-red-100{background-color:var(--color-red-100)}.p-2{padding:calc(var(--spacing)*2)}.p-4{padding:calc(var(--spacing)*4)}.p-\\[5px\\]{padding:5px}.px-2{padding-inline:calc(var(--spacing)*2)}.py-1{padding-block:calc(var(--spacing)*1)}.py-2{padding-block:calc(var(--spacing)*2)}.pr-\\[35px\\]{padding-right:35px}.pb-2{padding-bottom:calc(var(--spacing)*2)}.pb-20{padding-bottom:calc(var(--spacing)*20)}.pl-2{padding-left:calc(var(--spacing)*2)}.pl-\\[25px\\]{padding-left:25px}.text-center{text-align:center}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.leading-none{--tw-leading:1;line-height:1}.font-black{--tw-font-weight:var(--font-weight-black);font-weight:var(--font-weight-black)}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.text-base-content{color:var(--color-base-content)}.text-error{color:var(--color-error)}.text-error-content{color:var(--color-error-content)}.text-neutral-content{color:var(--color-neutral-content)}.text-primary{color:var(--color-primary)}.text-primary-content{color:var(--color-primary-content)}.text-stone-700{color:var(--color-stone-700)}.text-warning-content{color:var(--color-warning-content)}.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.outline-none{--tw-outline-style:none;outline-style:none}.select-none{-webkit-user-select:none;user-select:none}.focus\\:ring-2:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\\:ring-primary:focus{--tw-ring-color:var(--color-primary)}.data-\\[disabled\\]\\:pointer-events-none[data-disabled]{pointer-events:none}.data-\\[disabled\\]\\:text-base-content[data-disabled]{color:var(--color-base-content)}.data-\\[highlighted\\]\\:bg-primary[data-highlighted]{background-color:var(--color-primary)}.data-\\[highlighted\\]\\:outline-none[data-highlighted]{--tw-outline-style:none;outline-style:none}.data-\\[selected\\]\\:bg-primary\\/20[data-selected]{background-color:var(--color-primary)}@supports (color:color-mix(in lab,red,red)){.data-\\[selected\\]\\:bg-primary\\/20[data-selected]{background-color:color-mix(in oklab,var(--color-primary)20%,transparent)}}@media (min-width:40rem){.sm\\:block{display:block}}}:root{--color-ocean-gray-00:#fff;--color-ocean-gray-25:#fafbfb;--color-ocean-gray-50:#f5f6f7;--color-ocean-gray-75:#eaeeef;--color-ocean-gray-100:#e1e4e6;--color-ocean-gray-150:#c6ced1;--color-ocean-gray-200:#bac1c4;--color-ocean-gray-250:#9fadb2;--color-ocean-gray-300:#889499;--color-ocean-gray-350:#72858c;--color-ocean-gray-400:#617177;--color-ocean-gray-450:#3f555e;--color-ocean-gray-500:#394d55;--color-ocean-gray-550:#34464d;--color-ocean-gray-600:#2e3e44;--color-ocean-gray-650:#27353b;--color-ocean-gray-700:#222e33;--color-ocean-gray-750:#1f272b;--color-ocean-gray-800:#171f22;--color-ocean-gray-850:#11171a;--color-ocean-gray-900:#0b0f11;--color-chart-1:#f7931e;--color-chart-2:#40535b;--color-chart-3:#2798aa;--color-chart-4:#6da89c;--color-chart-5:#a4cadd;--color-chart-6:#97b42d;--color-chart-7:#ffcb05;--color-chart-8:#ee652e;--color-chart-9:#528694;--color-chart-10:#a10f3b}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes progress{50%{background-position-x:-115%}}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}`)),document.head.appendChild(o)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
// @__NO_SIDE_EFFECTS__
function Tc(e) {
  const l = /* @__PURE__ */ Object.create(null);
  for (const i of e.split(",")) l[i] = 1;
  return (i) => i in l;
}
const On = {}, wa = [], Dt = () => {
}, wp = () => !1, os = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // uppercase letter
(e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Fm = (e) => e.startsWith("onUpdate:"), Mn = Object.assign, Mm = (e, l) => {
  const i = e.indexOf(l);
  i > -1 && e.splice(i, 1);
}, Ev = Object.prototype.hasOwnProperty, qn = (e, l) => Ev.call(e, l), We = Array.isArray, ba = (e) => Ba(e) === "[object Map]", ra = (e) => Ba(e) === "[object Set]", qf = (e) => Ba(e) === "[object Date]", _v = (e) => Ba(e) === "[object RegExp]", sn = (e) => typeof e == "function", Wn = (e) => typeof e == "string", mi = (e) => typeof e == "symbol", _n = (e) => e !== null && typeof e == "object", km = (e) => (_n(e) || sn(e)) && sn(e.then) && sn(e.catch), bp = Object.prototype.toString, Ba = (e) => bp.call(e), Nv = (e) => Ba(e).slice(8, -1), qc = (e) => Ba(e) === "[object Object]", Vm = (e) => Wn(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Sa = /* @__PURE__ */ Tc(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Pc = (e) => {
  const l = /* @__PURE__ */ Object.create(null);
  return (i) => l[i] || (l[i] = e(i));
}, Fv = /-\w/g, hl = Pc(
  (e) => e.replace(Fv, (l) => l.slice(1).toUpperCase())
), Mv = /\B([A-Z])/g, dt = Pc(
  (e) => e.replace(Mv, "-$1").toLowerCase()
), ms = Pc((e) => e.charAt(0).toUpperCase() + e.slice(1)), Ca = Pc(
  (e) => e ? `on${ms(e)}` : ""
), Ml = (e, l) => !Object.is(e, l), Ta = (e, ...l) => {
  for (let i = 0; i < e.length; i++)
    e[i](...l);
}, Sp = (e, l, i, a = !1) => {
  Object.defineProperty(e, l, {
    configurable: !0,
    enumerable: !1,
    writable: a,
    value: i
  });
}, lc = (e) => {
  const l = parseFloat(e);
  return isNaN(l) ? e : l;
}, tc = (e) => {
  const l = Wn(e) ? Number(e) : NaN;
  return isNaN(l) ? e : l;
};
let Pf;
const Rc = () => Pf || (Pf = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}), kv = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol", Vv = /* @__PURE__ */ Tc(kv);
function Gi(e) {
  if (We(e)) {
    const l = {};
    for (let i = 0; i < e.length; i++) {
      const a = e[i], s = Wn(a) ? Kv(a) : Gi(a);
      if (s)
        for (const o in s)
          l[o] = s[o];
    }
    return l;
  } else if (Wn(e) || _n(e))
    return e;
}
const Bv = /;(?![^(]*\))/g, Zv = /:([^]+)/, Uv = /\/\*[^]*?\*\//g;
function Kv(e) {
  const l = {};
  return e.replace(Uv, "").split(Bv).forEach((i) => {
    if (i) {
      const a = i.split(Zv);
      a.length > 1 && (l[a[0].trim()] = a[1].trim());
    }
  }), l;
}
function mt(e) {
  let l = "";
  if (Wn(e))
    l = e;
  else if (We(e))
    for (let i = 0; i < e.length; i++) {
      const a = mt(e[i]);
      a && (l += a + " ");
    }
  else if (_n(e))
    for (const i in e)
      e[i] && (l += i + " ");
  return l.trim();
}
function Ac(e) {
  if (!e) return null;
  let { class: l, style: i } = e;
  return l && !Wn(l) && (e.class = mt(l)), i && (e.style = Gi(i)), e;
}
const Gv = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", zv = /* @__PURE__ */ Tc(Gv);
function Cp(e) {
  return !!e || e === "";
}
function jv(e, l) {
  if (e.length !== l.length) return !1;
  let i = !0;
  for (let a = 0; i && a < e.length; a++)
    i = Vu(e[a], l[a]);
  return i;
}
function Vu(e, l) {
  if (e === l) return !0;
  let i = qf(e), a = qf(l);
  if (i || a)
    return i && a ? e.getTime() === l.getTime() : !1;
  if (i = mi(e), a = mi(l), i || a)
    return e === l;
  if (i = We(e), a = We(l), i || a)
    return i && a ? jv(e, l) : !1;
  if (i = _n(e), a = _n(l), i || a) {
    if (!i || !a)
      return !1;
    const s = Object.keys(e).length, o = Object.keys(l).length;
    if (s !== o)
      return !1;
    for (const f in e) {
      const d = e.hasOwnProperty(f), h = l.hasOwnProperty(f);
      if (d && !h || !d && h || !Vu(e[f], l[f]))
        return !1;
    }
  }
  return String(e) === String(l);
}
function Ec(e, l) {
  return e.findIndex((i) => Vu(i, l));
}
const Tp = (e) => !!(e && e.__v_isRef === !0), xt = (e) => Wn(e) ? e : e == null ? "" : We(e) || _n(e) && (e.toString === bp || !sn(e.toString)) ? Tp(e) ? xt(e.value) : JSON.stringify(e, qp, 2) : String(e), qp = (e, l) => Tp(l) ? qp(e, l.value) : ba(l) ? {
  [`Map(${l.size})`]: [...l.entries()].reduce(
    (i, [a, s], o) => (i[fo(a, o) + " =>"] = s, i),
    {}
  )
} : ra(l) ? {
  [`Set(${l.size})`]: [...l.values()].map((i) => fo(i))
} : mi(l) ? fo(l) : _n(l) && !We(l) && !qc(l) ? String(l) : l, fo = (e, l = "") => {
  var i;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    mi(e) ? `Symbol(${(i = e.description) != null ? i : l})` : e
  );
};
function Hv(e) {
  return e == null ? "initial" : typeof e == "string" ? e === "" ? " " : e : String(e);
}
let Al;
class Bm {
  constructor(l = !1) {
    this.detached = l, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Al, !l && Al && (this.index = (Al.scopes || (Al.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let l, i;
      if (this.scopes)
        for (l = 0, i = this.scopes.length; l < i; l++)
          this.scopes[l].pause();
      for (l = 0, i = this.effects.length; l < i; l++)
        this.effects[l].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let l, i;
      if (this.scopes)
        for (l = 0, i = this.scopes.length; l < i; l++)
          this.scopes[l].resume();
      for (l = 0, i = this.effects.length; l < i; l++)
        this.effects[l].resume();
    }
  }
  run(l) {
    if (this._active) {
      const i = Al;
      try {
        return Al = this, l();
      } finally {
        Al = i;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = Al, Al = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (Al = this.prevScope, this.prevScope = void 0);
  }
  stop(l) {
    if (this._active) {
      this._active = !1;
      let i, a;
      for (i = 0, a = this.effects.length; i < a; i++)
        this.effects[i].stop();
      for (this.effects.length = 0, i = 0, a = this.cleanups.length; i < a; i++)
        this.cleanups[i]();
      if (this.cleanups.length = 0, this.scopes) {
        for (i = 0, a = this.scopes.length; i < a; i++)
          this.scopes[i].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !l) {
        const s = this.parent.scopes.pop();
        s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function _c(e) {
  return new Bm(e);
}
function Hu() {
  return Al;
}
function Za(e, l = !1) {
  Al && Al.cleanups.push(e);
}
let $n;
const po = /* @__PURE__ */ new WeakSet();
class Wr {
  constructor(l) {
    this.fn = l, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Al && Al.active && Al.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, po.has(this) && (po.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Rp(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Rf(this), Ap(this);
    const l = $n, i = si;
    $n = this, si = !0;
    try {
      return this.fn();
    } finally {
      Ep(this), $n = l, si = i, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let l = this.deps; l; l = l.nextDep)
        Km(l);
      this.deps = this.depsTail = void 0, Rf(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? po.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Xo(this) && this.run();
  }
  get dirty() {
    return Xo(this);
  }
}
let Pp = 0, kr, Vr;
function Rp(e, l = !1) {
  if (e.flags |= 8, l) {
    e.next = Vr, Vr = e;
    return;
  }
  e.next = kr, kr = e;
}
function Zm() {
  Pp++;
}
function Um() {
  if (--Pp > 0)
    return;
  if (Vr) {
    let l = Vr;
    for (Vr = void 0; l; ) {
      const i = l.next;
      l.next = void 0, l.flags &= -9, l = i;
    }
  }
  let e;
  for (; kr; ) {
    let l = kr;
    for (kr = void 0; l; ) {
      const i = l.next;
      if (l.next = void 0, l.flags &= -9, l.flags & 1)
        try {
          l.trigger();
        } catch (a) {
          e || (e = a);
        }
      l = i;
    }
  }
  if (e) throw e;
}
function Ap(e) {
  for (let l = e.deps; l; l = l.nextDep)
    l.version = -1, l.prevActiveLink = l.dep.activeLink, l.dep.activeLink = l;
}
function Ep(e) {
  let l, i = e.depsTail, a = i;
  for (; a; ) {
    const s = a.prevDep;
    a.version === -1 ? (a === i && (i = s), Km(a), $v(a)) : l = a, a.dep.activeLink = a.prevActiveLink, a.prevActiveLink = void 0, a = s;
  }
  e.deps = l, e.depsTail = i;
}
function Xo(e) {
  for (let l = e.deps; l; l = l.nextDep)
    if (l.dep.version !== l.version || l.dep.computed && (_p(l.dep.computed) || l.dep.version !== l.version))
      return !0;
  return !!e._dirty;
}
function _p(e) {
  if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === Yr) || (e.globalVersion = Yr, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !Xo(e))))
    return;
  e.flags |= 2;
  const l = e.dep, i = $n, a = si;
  $n = e, si = !0;
  try {
    Ap(e);
    const s = e.fn(e._value);
    (l.version === 0 || Ml(s, e._value)) && (e.flags |= 128, e._value = s, l.version++);
  } catch (s) {
    throw l.version++, s;
  } finally {
    $n = i, si = a, Ep(e), e.flags &= -3;
  }
}
function Km(e, l = !1) {
  const { dep: i, prevSub: a, nextSub: s } = e;
  if (a && (a.nextSub = s, e.prevSub = void 0), s && (s.prevSub = a, e.nextSub = void 0), i.subs === e && (i.subs = a, !a && i.computed)) {
    i.computed.flags &= -5;
    for (let o = i.computed.deps; o; o = o.nextDep)
      Km(o, !0);
  }
  !l && !--i.sc && i.map && i.map.delete(i.key);
}
function $v(e) {
  const { prevDep: l, nextDep: i } = e;
  l && (l.nextDep = i, e.prevDep = void 0), i && (i.prevDep = l, e.nextDep = void 0);
}
function Wv(e, l) {
  e.effect instanceof Wr && (e = e.effect.fn);
  const i = new Wr(e);
  l && Mn(i, l);
  try {
    i.run();
  } catch (s) {
    throw i.stop(), s;
  }
  const a = i.run.bind(i);
  return a.effect = i, a;
}
function Yv(e) {
  e.effect.stop();
}
let si = !0;
const Np = [];
function Ni() {
  Np.push(si), si = !1;
}
function Fi() {
  const e = Np.pop();
  si = e === void 0 ? !0 : e;
}
function Rf(e) {
  const { cleanup: l } = e;
  if (e.cleanup = void 0, l) {
    const i = $n;
    $n = void 0;
    try {
      l();
    } finally {
      $n = i;
    }
  }
}
let Yr = 0;
class Xv {
  constructor(l, i) {
    this.sub = l, this.dep = i, this.version = i.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Nc {
  // TODO isolatedDeclarations "__v_skip"
  constructor(l) {
    this.computed = l, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(l) {
    if (!$n || !si || $n === this.computed)
      return;
    let i = this.activeLink;
    if (i === void 0 || i.sub !== $n)
      i = this.activeLink = new Xv($n, this), $n.deps ? (i.prevDep = $n.depsTail, $n.depsTail.nextDep = i, $n.depsTail = i) : $n.deps = $n.depsTail = i, Fp(i);
    else if (i.version === -1 && (i.version = this.version, i.nextDep)) {
      const a = i.nextDep;
      a.prevDep = i.prevDep, i.prevDep && (i.prevDep.nextDep = a), i.prevDep = $n.depsTail, i.nextDep = void 0, $n.depsTail.nextDep = i, $n.depsTail = i, $n.deps === i && ($n.deps = a);
    }
    return i;
  }
  trigger(l) {
    this.version++, Yr++, this.notify(l);
  }
  notify(l) {
    Zm();
    try {
      for (let i = this.subs; i; i = i.prevSub)
        i.sub.notify() && i.sub.dep.notify();
    } finally {
      Um();
    }
  }
}
function Fp(e) {
  if (e.dep.sc++, e.sub.flags & 4) {
    const l = e.dep.computed;
    if (l && !e.dep.subs) {
      l.flags |= 20;
      for (let a = l.deps; a; a = a.nextDep)
        Fp(a);
    }
    const i = e.dep.subs;
    i !== e && (e.prevSub = i, i && (i.nextSub = e)), e.dep.subs = e;
  }
}
const ic = /* @__PURE__ */ new WeakMap(), ea = Symbol(
  ""
), Qo = Symbol(
  ""
), Xr = Symbol(
  ""
);
function El(e, l, i) {
  if (si && $n) {
    let a = ic.get(e);
    a || ic.set(e, a = /* @__PURE__ */ new Map());
    let s = a.get(i);
    s || (a.set(i, s = new Nc()), s.map = a, s.key = i), s.track();
  }
}
function Pi(e, l, i, a, s, o) {
  const f = ic.get(e);
  if (!f) {
    Yr++;
    return;
  }
  const d = (h) => {
    h && h.trigger();
  };
  if (Zm(), l === "clear")
    f.forEach(d);
  else {
    const h = We(e), I = h && Vm(i);
    if (h && i === "length") {
      const x = Number(a);
      f.forEach((y, P) => {
        (P === "length" || P === Xr || !mi(P) && P >= x) && d(y);
      });
    } else
      switch ((i !== void 0 || f.has(void 0)) && d(f.get(i)), I && d(f.get(Xr)), l) {
        case "add":
          h ? I && d(f.get("length")) : (d(f.get(ea)), ba(e) && d(f.get(Qo)));
          break;
        case "delete":
          h || (d(f.get(ea)), ba(e) && d(f.get(Qo)));
          break;
        case "set":
          ba(e) && d(f.get(ea));
          break;
      }
  }
  Um();
}
function Qv(e, l) {
  const i = ic.get(e);
  return i && i.get(l);
}
function da(e) {
  const l = Ln(e);
  return l === e ? l : (El(l, "iterate", Xr), yt(e) ? l : l.map(ql));
}
function Fc(e) {
  return El(e = Ln(e), "iterate", Xr), e;
}
const Jv = {
  __proto__: null,
  [Symbol.iterator]() {
    return ho(this, Symbol.iterator, ql);
  },
  concat(...e) {
    return da(this).concat(
      ...e.map((l) => We(l) ? da(l) : l)
    );
  },
  entries() {
    return ho(this, "entries", (e) => (e[1] = ql(e[1]), e));
  },
  every(e, l) {
    return Si(this, "every", e, l, void 0, arguments);
  },
  filter(e, l) {
    return Si(this, "filter", e, l, (i) => i.map(ql), arguments);
  },
  find(e, l) {
    return Si(this, "find", e, l, ql, arguments);
  },
  findIndex(e, l) {
    return Si(this, "findIndex", e, l, void 0, arguments);
  },
  findLast(e, l) {
    return Si(this, "findLast", e, l, ql, arguments);
  },
  findLastIndex(e, l) {
    return Si(this, "findLastIndex", e, l, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(e, l) {
    return Si(this, "forEach", e, l, void 0, arguments);
  },
  includes(...e) {
    return go(this, "includes", e);
  },
  indexOf(...e) {
    return go(this, "indexOf", e);
  },
  join(e) {
    return da(this).join(e);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...e) {
    return go(this, "lastIndexOf", e);
  },
  map(e, l) {
    return Si(this, "map", e, l, void 0, arguments);
  },
  pop() {
    return Lr(this, "pop");
  },
  push(...e) {
    return Lr(this, "push", e);
  },
  reduce(e, ...l) {
    return Af(this, "reduce", e, l);
  },
  reduceRight(e, ...l) {
    return Af(this, "reduceRight", e, l);
  },
  shift() {
    return Lr(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(e, l) {
    return Si(this, "some", e, l, void 0, arguments);
  },
  splice(...e) {
    return Lr(this, "splice", e);
  },
  toReversed() {
    return da(this).toReversed();
  },
  toSorted(e) {
    return da(this).toSorted(e);
  },
  toSpliced(...e) {
    return da(this).toSpliced(...e);
  },
  unshift(...e) {
    return Lr(this, "unshift", e);
  },
  values() {
    return ho(this, "values", ql);
  }
};
function ho(e, l, i) {
  const a = Fc(e), s = a[l]();
  return a !== e && !yt(e) && (s._next = s.next, s.next = () => {
    const o = s._next();
    return o.done || (o.value = i(o.value)), o;
  }), s;
}
const ex = Array.prototype;
function Si(e, l, i, a, s, o) {
  const f = Fc(e), d = f !== e && !yt(e), h = f[l];
  if (h !== ex[l]) {
    const y = h.apply(e, o);
    return d ? ql(y) : y;
  }
  let I = i;
  f !== e && (d ? I = function(y, P) {
    return i.call(this, ql(y), P, e);
  } : i.length > 2 && (I = function(y, P) {
    return i.call(this, y, P, e);
  }));
  const x = h.call(f, I, a);
  return d && s ? s(x) : x;
}
function Af(e, l, i, a) {
  const s = Fc(e);
  let o = i;
  return s !== e && (yt(e) ? i.length > 3 && (o = function(f, d, h) {
    return i.call(this, f, d, h, e);
  }) : o = function(f, d, h) {
    return i.call(this, f, ql(d), h, e);
  }), s[l](o, ...a);
}
function go(e, l, i) {
  const a = Ln(e);
  El(a, "iterate", Xr);
  const s = a[l](...i);
  return (s === -1 || s === !1) && Vc(i[0]) ? (i[0] = Ln(i[0]), a[l](...i)) : s;
}
function Lr(e, l, i = []) {
  Ni(), Zm();
  const a = Ln(e)[l].apply(e, i);
  return Um(), Fi(), a;
}
const nx = /* @__PURE__ */ Tc("__proto__,__v_isRef,__isVue"), Mp = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(mi)
);
function lx(e) {
  mi(e) || (e = String(e));
  const l = Ln(this);
  return El(l, "has", e), l.hasOwnProperty(e);
}
class kp {
  constructor(l = !1, i = !1) {
    this._isReadonly = l, this._isShallow = i;
  }
  get(l, i, a) {
    if (i === "__v_skip") return l.__v_skip;
    const s = this._isReadonly, o = this._isShallow;
    if (i === "__v_isReactive")
      return !s;
    if (i === "__v_isReadonly")
      return s;
    if (i === "__v_isShallow")
      return o;
    if (i === "__v_raw")
      return a === (s ? o ? Gp : Kp : o ? Up : Zp).get(l) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(l) === Object.getPrototypeOf(a) ? l : void 0;
    const f = We(l);
    if (!s) {
      let h;
      if (f && (h = Jv[i]))
        return h;
      if (i === "hasOwnProperty")
        return lx;
    }
    const d = Reflect.get(
      l,
      i,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      kn(l) ? l : a
    );
    if ((mi(i) ? Mp.has(i) : nx(i)) || (s || El(l, "get", i), o))
      return d;
    if (kn(d)) {
      const h = f && Vm(i) ? d : d.value;
      return s && _n(h) ? Mi(h) : h;
    }
    return _n(d) ? s ? Mi(d) : Ua(d) : d;
  }
}
class Vp extends kp {
  constructor(l = !1) {
    super(!1, l);
  }
  set(l, i, a, s) {
    let o = l[i];
    if (!this._isShallow) {
      const h = ki(o);
      if (!yt(a) && !ki(a) && (o = Ln(o), a = Ln(a)), !We(l) && kn(o) && !kn(a))
        return h || (o.value = a), !0;
    }
    const f = We(l) && Vm(i) ? Number(i) < l.length : qn(l, i), d = Reflect.set(
      l,
      i,
      a,
      kn(l) ? l : s
    );
    return l === Ln(s) && (f ? Ml(a, o) && Pi(l, "set", i, a) : Pi(l, "add", i, a)), d;
  }
  deleteProperty(l, i) {
    const a = qn(l, i);
    l[i];
    const s = Reflect.deleteProperty(l, i);
    return s && a && Pi(l, "delete", i, void 0), s;
  }
  has(l, i) {
    const a = Reflect.has(l, i);
    return (!mi(i) || !Mp.has(i)) && El(l, "has", i), a;
  }
  ownKeys(l) {
    return El(
      l,
      "iterate",
      We(l) ? "length" : ea
    ), Reflect.ownKeys(l);
  }
}
class Bp extends kp {
  constructor(l = !1) {
    super(!0, l);
  }
  set(l, i) {
    return !0;
  }
  deleteProperty(l, i) {
    return !0;
  }
}
const tx = /* @__PURE__ */ new Vp(), ix = /* @__PURE__ */ new Bp(), ux = /* @__PURE__ */ new Vp(!0), ax = /* @__PURE__ */ new Bp(!0), Jo = (e) => e, ws = (e) => Reflect.getPrototypeOf(e);
function rx(e, l, i) {
  return function(...a) {
    const s = this.__v_raw, o = Ln(s), f = ba(o), d = e === "entries" || e === Symbol.iterator && f, h = e === "keys" && f, I = s[e](...a), x = i ? Jo : l ? uc : ql;
    return !l && El(
      o,
      "iterate",
      h ? Qo : ea
    ), {
      // iterator protocol
      next() {
        const { value: y, done: P } = I.next();
        return P ? { value: y, done: P } : {
          value: d ? [x(y[0]), x(y[1])] : x(y),
          done: P
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function bs(e) {
  return function(...l) {
    return e === "delete" ? !1 : e === "clear" ? void 0 : this;
  };
}
function sx(e, l) {
  const i = {
    get(s) {
      const o = this.__v_raw, f = Ln(o), d = Ln(s);
      e || (Ml(s, d) && El(f, "get", s), El(f, "get", d));
      const { has: h } = ws(f), I = l ? Jo : e ? uc : ql;
      if (h.call(f, s))
        return I(o.get(s));
      if (h.call(f, d))
        return I(o.get(d));
      o !== f && o.get(s);
    },
    get size() {
      const s = this.__v_raw;
      return !e && El(Ln(s), "iterate", ea), s.size;
    },
    has(s) {
      const o = this.__v_raw, f = Ln(o), d = Ln(s);
      return e || (Ml(s, d) && El(f, "has", s), El(f, "has", d)), s === d ? o.has(s) : o.has(s) || o.has(d);
    },
    forEach(s, o) {
      const f = this, d = f.__v_raw, h = Ln(d), I = l ? Jo : e ? uc : ql;
      return !e && El(h, "iterate", ea), d.forEach((x, y) => s.call(o, I(x), I(y), f));
    }
  };
  return Mn(
    i,
    e ? {
      add: bs("add"),
      set: bs("set"),
      delete: bs("delete"),
      clear: bs("clear")
    } : {
      add(s) {
        !l && !yt(s) && !ki(s) && (s = Ln(s));
        const o = Ln(this);
        return ws(o).has.call(o, s) || (o.add(s), Pi(o, "add", s, s)), this;
      },
      set(s, o) {
        !l && !yt(o) && !ki(o) && (o = Ln(o));
        const f = Ln(this), { has: d, get: h } = ws(f);
        let I = d.call(f, s);
        I || (s = Ln(s), I = d.call(f, s));
        const x = h.call(f, s);
        return f.set(s, o), I ? Ml(o, x) && Pi(f, "set", s, o) : Pi(f, "add", s, o), this;
      },
      delete(s) {
        const o = Ln(this), { has: f, get: d } = ws(o);
        let h = f.call(o, s);
        h || (s = Ln(s), h = f.call(o, s)), d && d.call(o, s);
        const I = o.delete(s);
        return h && Pi(o, "delete", s, void 0), I;
      },
      clear() {
        const s = Ln(this), o = s.size !== 0, f = s.clear();
        return o && Pi(
          s,
          "clear",
          void 0,
          void 0
        ), f;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((s) => {
    i[s] = rx(s, e, l);
  }), i;
}
function Mc(e, l) {
  const i = sx(e, l);
  return (a, s, o) => s === "__v_isReactive" ? !e : s === "__v_isReadonly" ? e : s === "__v_raw" ? a : Reflect.get(
    qn(i, s) && s in a ? i : a,
    s,
    o
  );
}
const cx = {
  get: /* @__PURE__ */ Mc(!1, !1)
}, ox = {
  get: /* @__PURE__ */ Mc(!1, !0)
}, mx = {
  get: /* @__PURE__ */ Mc(!0, !1)
}, fx = {
  get: /* @__PURE__ */ Mc(!0, !0)
}, Zp = /* @__PURE__ */ new WeakMap(), Up = /* @__PURE__ */ new WeakMap(), Kp = /* @__PURE__ */ new WeakMap(), Gp = /* @__PURE__ */ new WeakMap();
function dx(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function px(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : dx(Nv(e));
}
function Ua(e) {
  return ki(e) ? e : kc(
    e,
    !1,
    tx,
    cx,
    Zp
  );
}
function zp(e) {
  return kc(
    e,
    !1,
    ux,
    ox,
    Up
  );
}
function Mi(e) {
  return kc(
    e,
    !0,
    ix,
    mx,
    Kp
  );
}
function Pu(e) {
  return kc(
    e,
    !0,
    ax,
    fx,
    Gp
  );
}
function kc(e, l, i, a, s) {
  if (!_n(e) || e.__v_raw && !(l && e.__v_isReactive))
    return e;
  const o = px(e);
  if (o === 0)
    return e;
  const f = s.get(e);
  if (f)
    return f;
  const d = new Proxy(
    e,
    o === 2 ? a : i
  );
  return s.set(e, d), d;
}
function ci(e) {
  return ki(e) ? ci(e.__v_raw) : !!(e && e.__v_isReactive);
}
function ki(e) {
  return !!(e && e.__v_isReadonly);
}
function yt(e) {
  return !!(e && e.__v_isShallow);
}
function Vc(e) {
  return e ? !!e.__v_raw : !1;
}
function Ln(e) {
  const l = e && e.__v_raw;
  return l ? Ln(l) : e;
}
function Ka(e) {
  return !qn(e, "__v_skip") && Object.isExtensible(e) && Sp(e, "__v_skip", !0), e;
}
const ql = (e) => _n(e) ? Ua(e) : e, uc = (e) => _n(e) ? Mi(e) : e;
function kn(e) {
  return e ? e.__v_isRef === !0 : !1;
}
function Me(e) {
  return jp(e, !1);
}
function Vl(e) {
  return jp(e, !0);
}
function jp(e, l) {
  return kn(e) ? e : new hx(e, l);
}
class hx {
  constructor(l, i) {
    this.dep = new Nc(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = i ? l : Ln(l), this._value = i ? l : ql(l), this.__v_isShallow = i;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(l) {
    const i = this._rawValue, a = this.__v_isShallow || yt(l) || ki(l);
    l = a ? l : Ln(l), Ml(l, i) && (this._rawValue = l, this._value = a ? l : ql(l), this.dep.trigger());
  }
}
function gx(e) {
  e.dep && e.dep.trigger();
}
function ue(e) {
  return kn(e) ? e.value : e;
}
function pn(e) {
  return sn(e) ? e() : ue(e);
}
const vx = {
  get: (e, l, i) => l === "__v_raw" ? e : ue(Reflect.get(e, l, i)),
  set: (e, l, i, a) => {
    const s = e[l];
    return kn(s) && !kn(i) ? (s.value = i, !0) : Reflect.set(e, l, i, a);
  }
};
function Gm(e) {
  return ci(e) ? e : new Proxy(e, vx);
}
class xx {
  constructor(l) {
    this.__v_isRef = !0, this._value = void 0;
    const i = this.dep = new Nc(), { get: a, set: s } = l(i.track.bind(i), i.trigger.bind(i));
    this._get = a, this._set = s;
  }
  get value() {
    return this._value = this._get();
  }
  set value(l) {
    this._set(l);
  }
}
function Ga(e) {
  return new xx(e);
}
function wt(e) {
  const l = We(e) ? new Array(e.length) : {};
  for (const i in e)
    l[i] = Hp(e, i);
  return l;
}
class yx {
  constructor(l, i, a) {
    this._object = l, this._key = i, this._defaultValue = a, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const l = this._object[this._key];
    return this._value = l === void 0 ? this._defaultValue : l;
  }
  set value(l) {
    this._object[this._key] = l;
  }
  get dep() {
    return Qv(Ln(this._object), this._key);
  }
}
class Ix {
  constructor(l) {
    this._getter = l, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function fs(e, l, i) {
  return kn(e) ? e : sn(e) ? new Ix(e) : _n(e) && arguments.length > 1 ? Hp(e, l, i) : Me(e);
}
function Hp(e, l, i) {
  const a = e[l];
  return kn(a) ? a : new yx(e, l, i);
}
class Lx {
  constructor(l, i, a) {
    this.fn = l, this.setter = i, this._value = void 0, this.dep = new Nc(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Yr - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !i, this.isSSR = a;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    $n !== this)
      return Rp(this, !0), !0;
  }
  get value() {
    const l = this.dep.track();
    return _p(this), l && (l.version = this.dep.version), this._value;
  }
  set value(l) {
    this.setter && this.setter(l);
  }
}
function Dx(e, l, i = !1) {
  let a, s;
  return sn(e) ? a = e : (a = e.get, s = e.set), new Lx(a, s, i);
}
const Ox = {
  GET: "get",
  HAS: "has",
  ITERATE: "iterate"
}, wx = {
  SET: "set",
  ADD: "add",
  DELETE: "delete",
  CLEAR: "clear"
}, Ss = {}, ac = /* @__PURE__ */ new WeakMap();
let Ru;
function bx() {
  return Ru;
}
function $p(e, l = !1, i = Ru) {
  if (i) {
    let a = ac.get(i);
    a || ac.set(i, a = []), a.push(e);
  }
}
function Sx(e, l, i = On) {
  const { immediate: a, deep: s, once: o, scheduler: f, augmentJob: d, call: h } = i, I = (G) => s ? G : yt(G) || s === !1 || s === 0 ? Ri(G, 1) : Ri(G);
  let x, y, P, E, R = !1, V = !1;
  if (kn(e) ? (y = () => e.value, R = yt(e)) : ci(e) ? (y = () => I(e), R = !0) : We(e) ? (V = !0, R = e.some((G) => ci(G) || yt(G)), y = () => e.map((G) => {
    if (kn(G))
      return G.value;
    if (ci(G))
      return I(G);
    if (sn(G))
      return h ? h(G, 2) : G();
  })) : sn(e) ? l ? y = h ? () => h(e, 2) : e : y = () => {
    if (P) {
      Ni();
      try {
        P();
      } finally {
        Fi();
      }
    }
    const G = Ru;
    Ru = x;
    try {
      return h ? h(e, 3, [E]) : e(E);
    } finally {
      Ru = G;
    }
  } : y = Dt, l && s) {
    const G = y, Y = s === !0 ? 1 / 0 : s;
    y = () => Ri(G(), Y);
  }
  const K = Hu(), $ = () => {
    x.stop(), K && K.active && Mm(K.effects, x);
  };
  if (o && l) {
    const G = l;
    l = (...Y) => {
      G(...Y), $();
    };
  }
  let Q = V ? new Array(e.length).fill(Ss) : Ss;
  const Z = (G) => {
    if (!(!(x.flags & 1) || !x.dirty && !G))
      if (l) {
        const Y = x.run();
        if (s || R || (V ? Y.some((se, te) => Ml(se, Q[te])) : Ml(Y, Q))) {
          P && P();
          const se = Ru;
          Ru = x;
          try {
            const te = [
              Y,
              // pass undefined as the old value when it's changed for the first time
              Q === Ss ? void 0 : V && Q[0] === Ss ? [] : Q,
              E
            ];
            Q = Y, h ? h(l, 3, te) : (
              // @ts-expect-error
              l(...te)
            );
          } finally {
            Ru = se;
          }
        }
      } else
        x.run();
  };
  return d && d(Z), x = new Wr(y), x.scheduler = f ? () => f(Z, !1) : Z, E = (G) => $p(G, !1, x), P = x.onStop = () => {
    const G = ac.get(x);
    if (G) {
      if (h)
        h(G, 4);
      else
        for (const Y of G) Y();
      ac.delete(x);
    }
  }, l ? a ? Z(!0) : Q = x.run() : f ? f(Z.bind(null, !0), !0) : x.run(), $.pause = x.pause.bind(x), $.resume = x.resume.bind(x), $.stop = $, $;
}
function Ri(e, l = 1 / 0, i) {
  if (l <= 0 || !_n(e) || e.__v_skip || (i = i || /* @__PURE__ */ new Map(), (i.get(e) || 0) >= l))
    return e;
  if (i.set(e, l), l--, kn(e))
    Ri(e.value, l, i);
  else if (We(e))
    for (let a = 0; a < e.length; a++)
      Ri(e[a], l, i);
  else if (ra(e) || ba(e))
    e.forEach((a) => {
      Ri(a, l, i);
    });
  else if (qc(e)) {
    for (const a in e)
      Ri(e[a], l, i);
    for (const a of Object.getOwnPropertySymbols(e))
      Object.prototype.propertyIsEnumerable.call(e, a) && Ri(e[a], l, i);
  }
  return e;
}
const Wp = [];
function Cx(e) {
  Wp.push(e);
}
function Tx() {
  Wp.pop();
}
function qx(e, l) {
}
const Px = {
  SETUP_FUNCTION: 0,
  0: "SETUP_FUNCTION",
  RENDER_FUNCTION: 1,
  1: "RENDER_FUNCTION",
  NATIVE_EVENT_HANDLER: 5,
  5: "NATIVE_EVENT_HANDLER",
  COMPONENT_EVENT_HANDLER: 6,
  6: "COMPONENT_EVENT_HANDLER",
  VNODE_HOOK: 7,
  7: "VNODE_HOOK",
  DIRECTIVE_HOOK: 8,
  8: "DIRECTIVE_HOOK",
  TRANSITION_HOOK: 9,
  9: "TRANSITION_HOOK",
  APP_ERROR_HANDLER: 10,
  10: "APP_ERROR_HANDLER",
  APP_WARN_HANDLER: 11,
  11: "APP_WARN_HANDLER",
  FUNCTION_REF: 12,
  12: "FUNCTION_REF",
  ASYNC_COMPONENT_LOADER: 13,
  13: "ASYNC_COMPONENT_LOADER",
  SCHEDULER: 14,
  14: "SCHEDULER",
  COMPONENT_UPDATE: 15,
  15: "COMPONENT_UPDATE",
  APP_UNMOUNT_CLEANUP: 16,
  16: "APP_UNMOUNT_CLEANUP"
}, Rx = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function"
};
function za(e, l, i, a) {
  try {
    return a ? e(...a) : e();
  } catch (s) {
    sa(s, l, i);
  }
}
function bt(e, l, i, a) {
  if (sn(e)) {
    const s = za(e, l, i, a);
    return s && km(s) && s.catch((o) => {
      sa(o, l, i);
    }), s;
  }
  if (We(e)) {
    const s = [];
    for (let o = 0; o < e.length; o++)
      s.push(bt(e[o], l, i, a));
    return s;
  }
}
function sa(e, l, i, a = !0) {
  const s = l ? l.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: f } = l && l.appContext.config || On;
  if (l) {
    let d = l.parent;
    const h = l.proxy, I = `https://vuejs.org/error-reference/#runtime-${i}`;
    for (; d; ) {
      const x = d.ec;
      if (x) {
        for (let y = 0; y < x.length; y++)
          if (x[y](e, h, I) === !1)
            return;
      }
      d = d.parent;
    }
    if (o) {
      Ni(), za(o, null, 10, [
        e,
        h,
        I
      ]), Fi();
      return;
    }
  }
  Ax(e, i, s, a, f);
}
function Ax(e, l, i, a = !0, s = !1) {
  if (s)
    throw e;
  console.error(e);
}
const kl = [];
let xi = -1;
const qa = [];
let Au = null, ya = 0;
const Yp = /* @__PURE__ */ Promise.resolve();
let rc = null;
function tl(e) {
  const l = rc || Yp;
  return e ? l.then(this ? e.bind(this) : e) : l;
}
function Ex(e) {
  let l = xi + 1, i = kl.length;
  for (; l < i; ) {
    const a = l + i >>> 1, s = kl[a], o = Jr(s);
    o < e || o === e && s.flags & 2 ? l = a + 1 : i = a;
  }
  return l;
}
function zm(e) {
  if (!(e.flags & 1)) {
    const l = Jr(e), i = kl[kl.length - 1];
    !i || // fast path when the job id is larger than the tail
    !(e.flags & 2) && l >= Jr(i) ? kl.push(e) : kl.splice(Ex(l), 0, e), e.flags |= 1, Xp();
  }
}
function Xp() {
  rc || (rc = Yp.then(Qp));
}
function Qr(e) {
  We(e) ? qa.push(...e) : Au && e.id === -1 ? Au.splice(ya + 1, 0, e) : e.flags & 1 || (qa.push(e), e.flags |= 1), Xp();
}
function Ef(e, l, i = xi + 1) {
  for (; i < kl.length; i++) {
    const a = kl[i];
    if (a && a.flags & 2) {
      if (e && a.id !== e.uid)
        continue;
      kl.splice(i, 1), i--, a.flags & 4 && (a.flags &= -2), a(), a.flags & 4 || (a.flags &= -2);
    }
  }
}
function sc(e) {
  if (qa.length) {
    const l = [...new Set(qa)].sort(
      (i, a) => Jr(i) - Jr(a)
    );
    if (qa.length = 0, Au) {
      Au.push(...l);
      return;
    }
    for (Au = l, ya = 0; ya < Au.length; ya++) {
      const i = Au[ya];
      i.flags & 4 && (i.flags &= -2), i.flags & 8 || i(), i.flags &= -2;
    }
    Au = null, ya = 0;
  }
}
const Jr = (e) => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;
function Qp(e) {
  try {
    for (xi = 0; xi < kl.length; xi++) {
      const l = kl[xi];
      l && !(l.flags & 8) && (l.flags & 4 && (l.flags &= -2), za(
        l,
        l.i,
        l.i ? 15 : 14
      ), l.flags & 4 || (l.flags &= -2));
    }
  } finally {
    for (; xi < kl.length; xi++) {
      const l = kl[xi];
      l && (l.flags &= -2);
    }
    xi = -1, kl.length = 0, sc(), rc = null, (kl.length || qa.length) && Qp();
  }
}
let Ia, Cs = [];
function Jp(e, l) {
  var i, a;
  Ia = e, Ia ? (Ia.enabled = !0, Cs.forEach(({ event: s, args: o }) => Ia.emit(s, ...o)), Cs = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((a = (i = window.navigator) == null ? void 0 : i.userAgent) != null && a.includes("jsdom")) ? ((l.__VUE_DEVTOOLS_HOOK_REPLAY__ = l.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((o) => {
    Jp(o, l);
  }), setTimeout(() => {
    Ia || (l.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Cs = []);
  }, 3e3)) : Cs = [];
}
let Rl = null, Bc = null;
function es(e) {
  const l = Rl;
  return Rl = e, Bc = e && e.type.__scopeId || null, l;
}
function _x(e) {
  Bc = e;
}
function Nx() {
  Bc = null;
}
const Fx = (e) => nn;
function nn(e, l = Rl, i) {
  if (!l || e._n)
    return e;
  const a = (...s) => {
    a._d && ts(-1);
    const o = es(l);
    let f;
    try {
      f = e(...s);
    } finally {
      es(o), a._d && ts(1);
    }
    return f;
  };
  return a._n = !0, a._c = !0, a._d = !0, a;
}
function Mx(e, l) {
  if (Rl === null)
    return e;
  const i = xs(Rl), a = e.dirs || (e.dirs = []);
  for (let s = 0; s < l.length; s++) {
    let [o, f, d, h = On] = l[s];
    o && (sn(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Ri(f), a.push({
      dir: o,
      instance: i,
      value: f,
      oldValue: void 0,
      arg: d,
      modifiers: h
    }));
  }
  return e;
}
function yi(e, l, i, a) {
  const s = e.dirs, o = l && l.dirs;
  for (let f = 0; f < s.length; f++) {
    const d = s[f];
    o && (d.oldValue = o[f].value);
    let h = d.dir[a];
    h && (Ni(), bt(h, i, 8, [
      e.el,
      d,
      e,
      l
    ]), Fi());
  }
}
const eh = Symbol("_vte"), nh = (e) => e.__isTeleport, Br = (e) => e && (e.disabled || e.disabled === ""), _f = (e) => e && (e.defer || e.defer === ""), Nf = (e) => typeof SVGElement < "u" && e instanceof SVGElement, Ff = (e) => typeof MathMLElement == "function" && e instanceof MathMLElement, em = (e, l) => {
  const i = e && e.to;
  return Wn(i) ? l ? l(i) : null : i;
}, lh = {
  name: "Teleport",
  __isTeleport: !0,
  process(e, l, i, a, s, o, f, d, h, I) {
    const {
      mc: x,
      pc: y,
      pbc: P,
      o: { insert: E, querySelector: R, createText: V, createComment: K }
    } = I, $ = Br(l.props);
    let { shapeFlag: Q, children: Z, dynamicChildren: G } = l;
    if (e == null) {
      const Y = l.el = V(""), se = l.anchor = V("");
      E(Y, i, a), E(se, i, a);
      const te = (M, oe) => {
        Q & 16 && x(
          Z,
          M,
          oe,
          s,
          o,
          f,
          d,
          h
        );
      }, fe = () => {
        const M = l.target = em(l.props, R), oe = th(M, l, V, E);
        M && (f !== "svg" && Nf(M) ? f = "svg" : f !== "mathml" && Ff(M) && (f = "mathml"), s && s.isCE && (s.ce._teleportTargets || (s.ce._teleportTargets = /* @__PURE__ */ new Set())).add(M), $ || (te(M, oe), $s(l, !1)));
      };
      $ && (te(i, se), $s(l, !0)), _f(l.props) ? (l.el.__isMounted = !1, pl(() => {
        fe(), delete l.el.__isMounted;
      }, o)) : fe();
    } else {
      if (_f(l.props) && e.el.__isMounted === !1) {
        pl(() => {
          lh.process(
            e,
            l,
            i,
            a,
            s,
            o,
            f,
            d,
            h,
            I
          );
        }, o);
        return;
      }
      l.el = e.el, l.targetStart = e.targetStart;
      const Y = l.anchor = e.anchor, se = l.target = e.target, te = l.targetAnchor = e.targetAnchor, fe = Br(e.props), M = fe ? i : se, oe = fe ? Y : te;
      if (f === "svg" || Nf(se) ? f = "svg" : (f === "mathml" || Ff(se)) && (f = "mathml"), G ? (P(
        e.dynamicChildren,
        G,
        M,
        s,
        o,
        f,
        d
      ), tf(e, l, !0)) : h || y(
        e,
        l,
        M,
        oe,
        s,
        o,
        f,
        d,
        !1
      ), $)
        fe ? l.props && e.props && l.props.to !== e.props.to && (l.props.to = e.props.to) : Ts(
          l,
          i,
          Y,
          I,
          1
        );
      else if ((l.props && l.props.to) !== (e.props && e.props.to)) {
        const Le = l.target = em(
          l.props,
          R
        );
        Le && Ts(
          l,
          Le,
          null,
          I,
          0
        );
      } else fe && Ts(
        l,
        se,
        te,
        I,
        1
      );
      $s(l, $);
    }
  },
  remove(e, l, i, { um: a, o: { remove: s } }, o) {
    const {
      shapeFlag: f,
      children: d,
      anchor: h,
      targetStart: I,
      targetAnchor: x,
      target: y,
      props: P
    } = e;
    if (y && (s(I), s(x)), o && s(h), f & 16) {
      const E = o || !Br(P);
      for (let R = 0; R < d.length; R++) {
        const V = d[R];
        a(
          V,
          l,
          i,
          E,
          !!V.dynamicChildren
        );
      }
    }
  },
  move: Ts,
  hydrate: kx
};
function Ts(e, l, i, { o: { insert: a }, m: s }, o = 2) {
  o === 0 && a(e.targetAnchor, l, i);
  const { el: f, anchor: d, shapeFlag: h, children: I, props: x } = e, y = o === 2;
  if (y && a(f, l, i), (!y || Br(x)) && h & 16)
    for (let P = 0; P < I.length; P++)
      s(
        I[P],
        l,
        i,
        2
      );
  y && a(d, l, i);
}
function kx(e, l, i, a, s, o, {
  o: { nextSibling: f, parentNode: d, querySelector: h, insert: I, createText: x }
}, y) {
  function P(V, K, $, Q) {
    K.anchor = y(
      f(V),
      K,
      d(V),
      i,
      a,
      s,
      o
    ), K.targetStart = $, K.targetAnchor = Q;
  }
  const E = l.target = em(
    l.props,
    h
  ), R = Br(l.props);
  if (E) {
    const V = E._lpa || E.firstChild;
    if (l.shapeFlag & 16)
      if (R)
        P(
          e,
          l,
          V,
          V && f(V)
        );
      else {
        l.anchor = f(e);
        let K = V;
        for (; K; ) {
          if (K && K.nodeType === 8) {
            if (K.data === "teleport start anchor")
              l.targetStart = K;
            else if (K.data === "teleport anchor") {
              l.targetAnchor = K, E._lpa = l.targetAnchor && f(l.targetAnchor);
              break;
            }
          }
          K = f(K);
        }
        l.targetAnchor || th(E, l, x, I), y(
          V && f(V),
          l,
          E,
          i,
          a,
          s,
          o
        );
      }
    $s(l, R);
  } else R && l.shapeFlag & 16 && P(e, l, e, f(e));
  return l.anchor && f(l.anchor);
}
const Vx = lh;
function $s(e, l) {
  const i = e.ctx;
  if (i && i.ut) {
    let a, s;
    for (l ? (a = e.el, s = e.anchor) : (a = e.targetStart, s = e.targetAnchor); a && a !== s; )
      a.nodeType === 1 && a.setAttribute("data-v-owner", i.uid), a = a.nextSibling;
    i.ut();
  }
}
function th(e, l, i, a) {
  const s = l.targetStart = i(""), o = l.targetAnchor = i("");
  return s[eh] = o, e && (a(s, e), a(o, e)), o;
}
const qi = Symbol("_leaveCb"), qs = Symbol("_enterCb");
function jm() {
  const e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return vl(() => {
    e.isMounted = !0;
  }), ps(() => {
    e.isUnmounting = !0;
  }), e;
}
const Lt = [Function, Array], Hm = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: Lt,
  onEnter: Lt,
  onAfterEnter: Lt,
  onEnterCancelled: Lt,
  // leave
  onBeforeLeave: Lt,
  onLeave: Lt,
  onAfterLeave: Lt,
  onLeaveCancelled: Lt,
  // appear
  onBeforeAppear: Lt,
  onAppear: Lt,
  onAfterAppear: Lt,
  onAppearCancelled: Lt
}, ih = (e) => {
  const l = e.subTree;
  return l.component ? ih(l.component) : l;
}, Bx = {
  name: "BaseTransition",
  props: Hm,
  setup(e, { slots: l }) {
    const i = Yn(), a = jm();
    return () => {
      const s = l.default && Zc(l.default(), !0);
      if (!s || !s.length)
        return;
      const o = uh(s), f = Ln(e), { mode: d } = f;
      if (a.isLeaving)
        return vo(o);
      const h = Mf(o);
      if (!h)
        return vo(o);
      let I = Ea(
        h,
        f,
        a,
        i,
        // #11061, ensure enterHooks is fresh after clone
        (y) => I = y
      );
      h.type !== il && Vi(h, I);
      let x = i.subTree && Mf(i.subTree);
      if (x && x.type !== il && !ai(x, h) && ih(i).type !== il) {
        let y = Ea(
          x,
          f,
          a,
          i
        );
        if (Vi(x, y), d === "out-in" && h.type !== il)
          return a.isLeaving = !0, y.afterLeave = () => {
            a.isLeaving = !1, i.job.flags & 8 || i.update(), delete y.afterLeave, x = void 0;
          }, vo(o);
        d === "in-out" && h.type !== il ? y.delayLeave = (P, E, R) => {
          const V = rh(
            a,
            x
          );
          V[String(x.key)] = x, P[qi] = () => {
            E(), P[qi] = void 0, delete I.delayedLeave, x = void 0;
          }, I.delayedLeave = () => {
            R(), delete I.delayedLeave, x = void 0;
          };
        } : x = void 0;
      } else x && (x = void 0);
      return o;
    };
  }
};
function uh(e) {
  let l = e[0];
  if (e.length > 1) {
    for (const i of e)
      if (i.type !== il) {
        l = i;
        break;
      }
  }
  return l;
}
const ah = Bx;
function rh(e, l) {
  const { leavingVNodes: i } = e;
  let a = i.get(l.type);
  return a || (a = /* @__PURE__ */ Object.create(null), i.set(l.type, a)), a;
}
function Ea(e, l, i, a, s) {
  const {
    appear: o,
    mode: f,
    persisted: d = !1,
    onBeforeEnter: h,
    onEnter: I,
    onAfterEnter: x,
    onEnterCancelled: y,
    onBeforeLeave: P,
    onLeave: E,
    onAfterLeave: R,
    onLeaveCancelled: V,
    onBeforeAppear: K,
    onAppear: $,
    onAfterAppear: Q,
    onAppearCancelled: Z
  } = l, G = String(e.key), Y = rh(i, e), se = (M, oe) => {
    M && bt(
      M,
      a,
      9,
      oe
    );
  }, te = (M, oe) => {
    const Le = oe[1];
    se(M, oe), We(M) ? M.every((ae) => ae.length <= 1) && Le() : M.length <= 1 && Le();
  }, fe = {
    mode: f,
    persisted: d,
    beforeEnter(M) {
      let oe = h;
      if (!i.isMounted)
        if (o)
          oe = K || h;
        else
          return;
      M[qi] && M[qi](
        !0
        /* cancelled */
      );
      const Le = Y[G];
      Le && ai(e, Le) && Le.el[qi] && Le.el[qi](), se(oe, [M]);
    },
    enter(M) {
      let oe = I, Le = x, ae = y;
      if (!i.isMounted)
        if (o)
          oe = $ || I, Le = Q || x, ae = Z || y;
        else
          return;
      let ye = !1;
      const he = M[qs] = (Ce) => {
        ye || (ye = !0, Ce ? se(ae, [M]) : se(Le, [M]), fe.delayedLeave && fe.delayedLeave(), M[qs] = void 0);
      };
      oe ? te(oe, [M, he]) : he();
    },
    leave(M, oe) {
      const Le = String(e.key);
      if (M[qs] && M[qs](
        !0
        /* cancelled */
      ), i.isUnmounting)
        return oe();
      se(P, [M]);
      let ae = !1;
      const ye = M[qi] = (he) => {
        ae || (ae = !0, oe(), he ? se(V, [M]) : se(R, [M]), M[qi] = void 0, Y[Le] === e && delete Y[Le]);
      };
      Y[Le] = e, E ? te(E, [M, ye]) : ye();
    },
    clone(M) {
      const oe = Ea(
        M,
        l,
        i,
        a,
        s
      );
      return s && s(oe), oe;
    }
  };
  return fe;
}
function vo(e) {
  if (ds(e))
    return e = fi(e), e.children = null, e;
}
function Mf(e) {
  if (!ds(e))
    return nh(e.type) && e.children ? uh(e.children) : e;
  if (e.component)
    return e.component.subTree;
  const { shapeFlag: l, children: i } = e;
  if (i) {
    if (l & 16)
      return i[0];
    if (l & 32 && sn(i.default))
      return i.default();
  }
}
function Vi(e, l) {
  e.shapeFlag & 6 && e.component ? (e.transition = l, Vi(e.component.subTree, l)) : e.shapeFlag & 128 ? (e.ssContent.transition = l.clone(e.ssContent), e.ssFallback.transition = l.clone(e.ssFallback)) : e.transition = l;
}
function Zc(e, l = !1, i) {
  let a = [], s = 0;
  for (let o = 0; o < e.length; o++) {
    let f = e[o];
    const d = i == null ? f.key : String(i) + String(f.key != null ? f.key : o);
    f.type === Vn ? (f.patchFlag & 128 && s++, a = a.concat(
      Zc(f.children, l, d)
    )) : (l || f.type !== il) && a.push(d != null ? fi(f, { key: d }) : f);
  }
  if (s > 1)
    for (let o = 0; o < a.length; o++)
      a[o].patchFlag = -2;
  return a;
}
// @__NO_SIDE_EFFECTS__
function fn(e, l) {
  return sn(e) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Mn({ name: e.name }, l, { setup: e })
  ) : e;
}
function sh() {
  const e = Yn();
  return e ? (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++ : "";
}
function $m(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
}
function Wm(e) {
  const l = Yn(), i = Vl(null);
  if (l) {
    const s = l.refs === On ? l.refs = {} : l.refs;
    Object.defineProperty(s, e, {
      enumerable: !0,
      get: () => i.value,
      set: (o) => i.value = o
    });
  }
  return i;
}
const cc = /* @__PURE__ */ new WeakMap();
function Pa(e, l, i, a, s = !1) {
  if (We(e)) {
    e.forEach(
      (R, V) => Pa(
        R,
        l && (We(l) ? l[V] : l),
        i,
        a,
        s
      )
    );
    return;
  }
  if (Mu(a) && !s) {
    a.shapeFlag & 512 && a.type.__asyncResolved && a.component.subTree.component && Pa(e, l, i, a.component.subTree);
    return;
  }
  const o = a.shapeFlag & 4 ? xs(a.component) : a.el, f = s ? null : o, { i: d, r: h } = e, I = l && l.r, x = d.refs === On ? d.refs = {} : d.refs, y = d.setupState, P = Ln(y), E = y === On ? wp : (R) => qn(P, R);
  if (I != null && I !== h) {
    if (kf(l), Wn(I))
      x[I] = null, E(I) && (y[I] = null);
    else if (kn(I)) {
      I.value = null;
      const R = l;
      R.k && (x[R.k] = null);
    }
  }
  if (sn(h))
    za(h, d, 12, [f, x]);
  else {
    const R = Wn(h), V = kn(h);
    if (R || V) {
      const K = () => {
        if (e.f) {
          const $ = R ? E(h) ? y[h] : x[h] : h.value;
          if (s)
            We($) && Mm($, o);
          else if (We($))
            $.includes(o) || $.push(o);
          else if (R)
            x[h] = [o], E(h) && (y[h] = x[h]);
          else {
            const Q = [o];
            h.value = Q, e.k && (x[e.k] = Q);
          }
        } else R ? (x[h] = f, E(h) && (y[h] = f)) : V && (h.value = f, e.k && (x[e.k] = f));
      };
      if (f) {
        const $ = () => {
          K(), cc.delete(e);
        };
        $.id = -1, cc.set(e, $), pl($, i);
      } else
        kf(e), K();
    }
  }
}
function kf(e) {
  const l = cc.get(e);
  l && (l.flags |= 8, cc.delete(e));
}
let Vf = !1;
const pa = () => {
  Vf || (console.error("Hydration completed but contains mismatches."), Vf = !0);
}, Zx = (e) => e.namespaceURI.includes("svg") && e.tagName !== "foreignObject", Ux = (e) => e.namespaceURI.includes("MathML"), Ps = (e) => {
  if (e.nodeType === 1) {
    if (Zx(e)) return "svg";
    if (Ux(e)) return "mathml";
  }
}, Da = (e) => e.nodeType === 8;
function Kx(e) {
  const {
    mt: l,
    p: i,
    o: {
      patchProp: a,
      createText: s,
      nextSibling: o,
      parentNode: f,
      remove: d,
      insert: h,
      createComment: I
    }
  } = e, x = (Z, G) => {
    if (!G.hasChildNodes()) {
      i(null, Z, G), sc(), G._vnode = Z;
      return;
    }
    y(G.firstChild, Z, null, null, null), sc(), G._vnode = Z;
  }, y = (Z, G, Y, se, te, fe = !1) => {
    fe = fe || !!G.dynamicChildren;
    const M = Da(Z) && Z.data === "[", oe = () => V(
      Z,
      G,
      Y,
      se,
      te,
      M
    ), { type: Le, ref: ae, shapeFlag: ye, patchFlag: he } = G;
    let Ce = Z.nodeType;
    G.el = Z, he === -2 && (fe = !1, G.dynamicChildren = null);
    let xe = null;
    switch (Le) {
      case ku:
        Ce !== 3 ? G.children === "" ? (h(G.el = s(""), f(Z), Z), xe = Z) : xe = oe() : (Z.data !== G.children && (pa(), Z.data = G.children), xe = o(Z));
        break;
      case il:
        Q(Z) ? (xe = o(Z), $(
          G.el = Z.content.firstChild,
          Z,
          Y
        )) : Ce !== 8 || M ? xe = oe() : xe = o(Z);
        break;
      case la:
        if (M && (Z = o(Z), Ce = Z.nodeType), Ce === 1 || Ce === 3) {
          xe = Z;
          const ce = !G.children.length;
          for (let de = 0; de < G.staticCount; de++)
            ce && (G.children += xe.nodeType === 1 ? xe.outerHTML : xe.data), de === G.staticCount - 1 && (G.anchor = xe), xe = o(xe);
          return M ? o(xe) : xe;
        } else
          oe();
        break;
      case Vn:
        M ? xe = R(
          Z,
          G,
          Y,
          se,
          te,
          fe
        ) : xe = oe();
        break;
      default:
        if (ye & 1)
          (Ce !== 1 || G.type.toLowerCase() !== Z.tagName.toLowerCase()) && !Q(Z) ? xe = oe() : xe = P(
            Z,
            G,
            Y,
            se,
            te,
            fe
          );
        else if (ye & 6) {
          G.slotScopeIds = te;
          const ce = f(Z);
          if (M ? xe = K(Z) : Da(Z) && Z.data === "teleport start" ? xe = K(Z, Z.data, "teleport end") : xe = o(Z), l(
            G,
            ce,
            null,
            Y,
            se,
            Ps(ce),
            fe
          ), Mu(G) && !G.type.__asyncResolved) {
            let de;
            M ? (de = Ye(Vn), de.anchor = xe ? xe.previousSibling : ce.lastChild) : de = Z.nodeType === 3 ? Bu("") : Ye("div"), de.el = Z, G.component.subTree = de;
          }
        } else ye & 64 ? Ce !== 8 ? xe = oe() : xe = G.type.hydrate(
          Z,
          G,
          Y,
          se,
          te,
          fe,
          e,
          E
        ) : ye & 128 && (xe = G.type.hydrate(
          Z,
          G,
          Y,
          se,
          Ps(f(Z)),
          te,
          fe,
          e,
          y
        ));
    }
    return ae != null && Pa(ae, null, se, G), xe;
  }, P = (Z, G, Y, se, te, fe) => {
    fe = fe || !!G.dynamicChildren;
    const { type: M, props: oe, patchFlag: Le, shapeFlag: ae, dirs: ye, transition: he } = G, Ce = M === "input" || M === "option";
    if (Ce || Le !== -1) {
      ye && yi(G, null, Y, "created");
      let xe = !1;
      if (Q(Z)) {
        xe = Eh(
          null,
          // no need check parentSuspense in hydration
          he
        ) && Y && Y.vnode.props && Y.vnode.props.appear;
        const de = Z.content.firstChild;
        if (xe) {
          const we = de.getAttribute("class");
          we && (de.$cls = we), he.beforeEnter(de);
        }
        $(de, Z, Y), G.el = Z = de;
      }
      if (ae & 16 && // skip if element has innerHTML / textContent
      !(oe && (oe.innerHTML || oe.textContent))) {
        let de = E(
          Z.firstChild,
          G,
          Z,
          Y,
          se,
          te,
          fe
        );
        for (; de; ) {
          Rs(
            Z,
            1
            /* CHILDREN */
          ) || pa();
          const we = de;
          de = de.nextSibling, d(we);
        }
      } else if (ae & 8) {
        let de = G.children;
        de[0] === `
` && (Z.tagName === "PRE" || Z.tagName === "TEXTAREA") && (de = de.slice(1)), Z.textContent !== de && (Rs(
          Z,
          0
          /* TEXT */
        ) || pa(), Z.textContent = G.children);
      }
      if (oe) {
        if (Ce || !fe || Le & 48) {
          const de = Z.tagName.includes("-");
          for (const we in oe)
            (Ce && (we.endsWith("value") || we === "indeterminate") || os(we) && !Sa(we) || // force hydrate v-bind with .prop modifiers
            we[0] === "." || de) && a(Z, we, null, oe[we], void 0, Y);
        } else if (oe.onClick)
          a(
            Z,
            "onClick",
            null,
            oe.onClick,
            void 0,
            Y
          );
        else if (Le & 4 && ci(oe.style))
          for (const de in oe.style) oe.style[de];
      }
      let ce;
      (ce = oe && oe.onVnodeBeforeMount) && ot(ce, Y, G), ye && yi(G, null, Y, "beforeMount"), ((ce = oe && oe.onVnodeMounted) || ye || xe) && Zh(() => {
        ce && ot(ce, Y, G), xe && he.enter(Z), ye && yi(G, null, Y, "mounted");
      }, se);
    }
    return Z.nextSibling;
  }, E = (Z, G, Y, se, te, fe, M) => {
    M = M || !!G.dynamicChildren;
    const oe = G.children, Le = oe.length;
    for (let ae = 0; ae < Le; ae++) {
      const ye = M ? oe[ae] : oe[ae] = ft(oe[ae]), he = ye.type === ku;
      Z ? (he && !M && ae + 1 < Le && ft(oe[ae + 1]).type === ku && (h(
        s(
          Z.data.slice(ye.children.length)
        ),
        Y,
        o(Z)
      ), Z.data = ye.children), Z = y(
        Z,
        ye,
        se,
        te,
        fe,
        M
      )) : he && !ye.children ? h(ye.el = s(""), Y) : (Rs(
        Y,
        1
        /* CHILDREN */
      ) || pa(), i(
        null,
        ye,
        Y,
        null,
        se,
        te,
        Ps(Y),
        fe
      ));
    }
    return Z;
  }, R = (Z, G, Y, se, te, fe) => {
    const { slotScopeIds: M } = G;
    M && (te = te ? te.concat(M) : M);
    const oe = f(Z), Le = E(
      o(Z),
      G,
      oe,
      Y,
      se,
      te,
      fe
    );
    return Le && Da(Le) && Le.data === "]" ? o(G.anchor = Le) : (pa(), h(G.anchor = I("]"), oe, Le), Le);
  }, V = (Z, G, Y, se, te, fe) => {
    if (Rs(
      Z.parentElement,
      1
      /* CHILDREN */
    ) || pa(), G.el = null, fe) {
      const Le = K(Z);
      for (; ; ) {
        const ae = o(Z);
        if (ae && ae !== Le)
          d(ae);
        else
          break;
      }
    }
    const M = o(Z), oe = f(Z);
    return d(Z), i(
      null,
      G,
      oe,
      M,
      Y,
      se,
      Ps(oe),
      te
    ), Y && (Y.vnode.el = G.el, Hc(Y, G.el)), M;
  }, K = (Z, G = "[", Y = "]") => {
    let se = 0;
    for (; Z; )
      if (Z = o(Z), Z && Da(Z) && (Z.data === G && se++, Z.data === Y)) {
        if (se === 0)
          return o(Z);
        se--;
      }
    return Z;
  }, $ = (Z, G, Y) => {
    const se = G.parentNode;
    se && se.replaceChild(Z, G);
    let te = Y;
    for (; te; )
      te.vnode.el === G && (te.vnode.el = te.subTree.el = Z), te = te.parent;
  }, Q = (Z) => Z.nodeType === 1 && Z.tagName === "TEMPLATE";
  return [x, y];
}
const Bf = "data-allow-mismatch", Gx = {
  0: "text",
  1: "children",
  2: "class",
  3: "style",
  4: "attribute"
};
function Rs(e, l) {
  if (l === 0 || l === 1)
    for (; e && !e.hasAttribute(Bf); )
      e = e.parentElement;
  const i = e && e.getAttribute(Bf);
  if (i == null)
    return !1;
  if (i === "")
    return !0;
  {
    const a = i.split(",");
    return l === 0 && a.includes("children") ? !0 : a.includes(Gx[l]);
  }
}
const zx = Rc().requestIdleCallback || ((e) => setTimeout(e, 1)), jx = Rc().cancelIdleCallback || ((e) => clearTimeout(e)), Hx = (e = 1e4) => (l) => {
  const i = zx(l, { timeout: e });
  return () => jx(i);
};
function $x(e) {
  const { top: l, left: i, bottom: a, right: s } = e.getBoundingClientRect(), { innerHeight: o, innerWidth: f } = window;
  return (l > 0 && l < o || a > 0 && a < o) && (i > 0 && i < f || s > 0 && s < f);
}
const Wx = (e) => (l, i) => {
  const a = new IntersectionObserver((s) => {
    for (const o of s)
      if (o.isIntersecting) {
        a.disconnect(), l();
        break;
      }
  }, e);
  return i((s) => {
    if (s instanceof Element) {
      if ($x(s))
        return l(), a.disconnect(), !1;
      a.observe(s);
    }
  }), () => a.disconnect();
}, Yx = (e) => (l) => {
  if (e) {
    const i = matchMedia(e);
    if (i.matches)
      l();
    else
      return i.addEventListener("change", l, { once: !0 }), () => i.removeEventListener("change", l);
  }
}, Xx = (e = []) => (l, i) => {
  Wn(e) && (e = [e]);
  let a = !1;
  const s = (f) => {
    a || (a = !0, o(), l(), f.target.dispatchEvent(new f.constructor(f.type, f)));
  }, o = () => {
    i((f) => {
      for (const d of e)
        f.removeEventListener(d, s);
    });
  };
  return i((f) => {
    for (const d of e)
      f.addEventListener(d, s, { once: !0 });
  }), o;
};
function Qx(e, l) {
  if (Da(e) && e.data === "[") {
    let i = 1, a = e.nextSibling;
    for (; a; ) {
      if (a.nodeType === 1) {
        if (l(a) === !1)
          break;
      } else if (Da(a))
        if (a.data === "]") {
          if (--i === 0) break;
        } else a.data === "[" && i++;
      a = a.nextSibling;
    }
  } else
    l(e);
}
const Mu = (e) => !!e.type.__asyncLoader;
// @__NO_SIDE_EFFECTS__
function Jx(e) {
  sn(e) && (e = { loader: e });
  const {
    loader: l,
    loadingComponent: i,
    errorComponent: a,
    delay: s = 200,
    hydrate: o,
    timeout: f,
    // undefined = never times out
    suspensible: d = !0,
    onError: h
  } = e;
  let I = null, x, y = 0;
  const P = () => (y++, I = null, E()), E = () => {
    let R;
    return I || (R = I = l().catch((V) => {
      if (V = V instanceof Error ? V : new Error(String(V)), h)
        return new Promise((K, $) => {
          h(V, () => K(P()), () => $(V), y + 1);
        });
      throw V;
    }).then((V) => R !== I && I ? I : (V && (V.__esModule || V[Symbol.toStringTag] === "Module") && (V = V.default), x = V, V)));
  };
  return /* @__PURE__ */ fn({
    name: "AsyncComponentWrapper",
    __asyncLoader: E,
    __asyncHydrate(R, V, K) {
      let $ = !1;
      (V.bu || (V.bu = [])).push(() => $ = !0);
      const Q = () => {
        $ || K();
      }, Z = o ? () => {
        const G = o(
          Q,
          (Y) => Qx(R, Y)
        );
        G && (V.bum || (V.bum = [])).push(G);
      } : Q;
      x ? Z() : E().then(() => !V.isUnmounted && Z());
    },
    get __asyncResolved() {
      return x;
    },
    setup() {
      const R = Pl;
      if ($m(R), x)
        return () => xo(x, R);
      const V = (Z) => {
        I = null, sa(
          Z,
          R,
          13,
          !a
        );
      };
      if (d && R.suspense || _a)
        return E().then((Z) => () => xo(Z, R)).catch((Z) => (V(Z), () => a ? Ye(a, {
          error: Z
        }) : null));
      const K = Me(!1), $ = Me(), Q = Me(!!s);
      return s && setTimeout(() => {
        Q.value = !1;
      }, s), f != null && setTimeout(() => {
        if (!K.value && !$.value) {
          const Z = new Error(
            `Async component timed out after ${f}ms.`
          );
          V(Z), $.value = Z;
        }
      }, f), E().then(() => {
        K.value = !0, R.parent && ds(R.parent.vnode) && R.parent.update();
      }).catch((Z) => {
        V(Z), $.value = Z;
      }), () => {
        if (K.value && x)
          return xo(x, R);
        if ($.value && a)
          return Ye(a, {
            error: $.value
          });
        if (i && !Q.value)
          return Ye(i);
      };
    }
  });
}
function xo(e, l) {
  const { ref: i, props: a, children: s, ce: o } = l.vnode, f = Ye(e, a, s);
  return f.ref = i, f.ce = o, delete l.vnode.ce, f;
}
const ds = (e) => e.type.__isKeepAlive, ey = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: !0,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(e, { slots: l }) {
    const i = Yn(), a = i.ctx;
    if (!a.renderer)
      return () => {
        const Q = l.default && l.default();
        return Q && Q.length === 1 ? Q[0] : Q;
      };
    const s = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Set();
    let f = null;
    const d = i.suspense, {
      renderer: {
        p: h,
        m: I,
        um: x,
        o: { createElement: y }
      }
    } = a, P = y("div");
    a.activate = (Q, Z, G, Y, se) => {
      const te = Q.component;
      I(Q, Z, G, 0, d), h(
        te.vnode,
        Q,
        Z,
        G,
        te,
        d,
        Y,
        Q.slotScopeIds,
        se
      ), pl(() => {
        te.isDeactivated = !1, te.a && Ta(te.a);
        const fe = Q.props && Q.props.onVnodeMounted;
        fe && ot(fe, te.parent, Q);
      }, d);
    }, a.deactivate = (Q) => {
      const Z = Q.component;
      mc(Z.m), mc(Z.a), I(Q, P, null, 1, d), pl(() => {
        Z.da && Ta(Z.da);
        const G = Q.props && Q.props.onVnodeUnmounted;
        G && ot(G, Z.parent, Q), Z.isDeactivated = !0;
      }, d);
    };
    function E(Q) {
      yo(Q), x(Q, i, d, !0);
    }
    function R(Q) {
      s.forEach((Z, G) => {
        const Y = mm(Z.type);
        Y && !Q(Y) && V(G);
      });
    }
    function V(Q) {
      const Z = s.get(Q);
      Z && (!f || !ai(Z, f)) ? E(Z) : f && yo(f), s.delete(Q), o.delete(Q);
    }
    Sn(
      () => [e.include, e.exclude],
      ([Q, Z]) => {
        Q && R((G) => _r(Q, G)), Z && R((G) => !_r(Z, G));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: !0 }
    );
    let K = null;
    const $ = () => {
      K != null && (fc(i.subTree.type) ? pl(() => {
        s.set(K, As(i.subTree));
      }, i.subTree.suspense) : s.set(K, As(i.subTree)));
    };
    return vl($), Kc($), ps(() => {
      s.forEach((Q) => {
        const { subTree: Z, suspense: G } = i, Y = As(Z);
        if (Q.type === Y.type && Q.key === Y.key) {
          yo(Y);
          const se = Y.component.da;
          se && pl(se, G);
          return;
        }
        E(Q);
      });
    }), () => {
      if (K = null, !l.default)
        return f = null;
      const Q = l.default(), Z = Q[0];
      if (Q.length > 1)
        return f = null, Q;
      if (!Bi(Z) || !(Z.shapeFlag & 4) && !(Z.shapeFlag & 128))
        return f = null, Z;
      let G = As(Z);
      if (G.type === il)
        return f = null, G;
      const Y = G.type, se = mm(
        Mu(G) ? G.type.__asyncResolved || {} : Y
      ), { include: te, exclude: fe, max: M } = e;
      if (te && (!se || !_r(te, se)) || fe && se && _r(fe, se))
        return G.shapeFlag &= -257, f = G, Z;
      const oe = G.key == null ? Y : G.key, Le = s.get(oe);
      return G.el && (G = fi(G), Z.shapeFlag & 128 && (Z.ssContent = G)), K = oe, Le ? (G.el = Le.el, G.component = Le.component, G.transition && Vi(G, G.transition), G.shapeFlag |= 512, o.delete(oe), o.add(oe)) : (o.add(oe), M && o.size > parseInt(M, 10) && V(o.values().next().value)), G.shapeFlag |= 256, f = G, fc(Z.type) ? Z : G;
    };
  }
}, ny = ey;
function _r(e, l) {
  return We(e) ? e.some((i) => _r(i, l)) : Wn(e) ? e.split(",").includes(l) : _v(e) ? (e.lastIndex = 0, e.test(l)) : !1;
}
function ch(e, l) {
  mh(e, "a", l);
}
function oh(e, l) {
  mh(e, "da", l);
}
function mh(e, l, i = Pl) {
  const a = e.__wdc || (e.__wdc = () => {
    let s = i;
    for (; s; ) {
      if (s.isDeactivated)
        return;
      s = s.parent;
    }
    return e();
  });
  if (Uc(l, a, i), i) {
    let s = i.parent;
    for (; s && s.parent; )
      ds(s.parent.vnode) && ly(a, l, i, s), s = s.parent;
  }
}
function ly(e, l, i, a) {
  const s = Uc(
    l,
    e,
    a,
    !0
    /* prepend */
  );
  St(() => {
    Mm(a[l], s);
  }, i);
}
function yo(e) {
  e.shapeFlag &= -257, e.shapeFlag &= -513;
}
function As(e) {
  return e.shapeFlag & 128 ? e.ssContent : e;
}
function Uc(e, l, i = Pl, a = !1) {
  if (i) {
    const s = i[e] || (i[e] = []), o = l.__weh || (l.__weh = (...f) => {
      Ni();
      const d = ia(i), h = bt(l, i, e, f);
      return d(), Fi(), h;
    });
    return a ? s.unshift(o) : s.push(o), o;
  }
}
const zi = (e) => (l, i = Pl) => {
  (!_a || e === "sp") && Uc(e, (...a) => l(...a), i);
}, fh = zi("bm"), vl = zi("m"), Ym = zi(
  "bu"
), Kc = zi("u"), ps = zi(
  "bum"
), St = zi("um"), dh = zi(
  "sp"
), ph = zi("rtg"), hh = zi("rtc");
function gh(e, l = Pl) {
  Uc("ec", e, l);
}
const Xm = "components", ty = "directives";
function iy(e, l) {
  return Qm(Xm, e, !0, l) || e;
}
const vh = Symbol.for("v-ndc");
function hs(e) {
  return Wn(e) ? Qm(Xm, e, !1) || e : e || vh;
}
function uy(e) {
  return Qm(ty, e);
}
function Qm(e, l, i = !0, a = !1) {
  const s = Rl || Pl;
  if (s) {
    const o = s.type;
    if (e === Xm) {
      const d = mm(
        o,
        !1
      );
      if (d && (d === l || d === hl(l) || d === ms(hl(l))))
        return o;
    }
    const f = (
      // local registration
      // check instance[type] first which is resolved for options API
      Zf(s[e] || o[e], l) || // global registration
      Zf(s.appContext[e], l)
    );
    return !f && a ? o : f;
  }
}
function Zf(e, l) {
  return e && (e[l] || e[hl(l)] || e[ms(hl(l))]);
}
function gs(e, l, i, a) {
  let s;
  const o = i && i[a], f = We(e);
  if (f || Wn(e)) {
    const d = f && ci(e);
    let h = !1, I = !1;
    d && (h = !yt(e), I = ki(e), e = Fc(e)), s = new Array(e.length);
    for (let x = 0, y = e.length; x < y; x++)
      s[x] = l(
        h ? I ? uc(ql(e[x])) : ql(e[x]) : e[x],
        x,
        void 0,
        o && o[x]
      );
  } else if (typeof e == "number") {
    s = new Array(e);
    for (let d = 0; d < e; d++)
      s[d] = l(d + 1, d, void 0, o && o[d]);
  } else if (_n(e))
    if (e[Symbol.iterator])
      s = Array.from(
        e,
        (d, h) => l(d, h, void 0, o && o[h])
      );
    else {
      const d = Object.keys(e);
      s = new Array(d.length);
      for (let h = 0, I = d.length; h < I; h++) {
        const x = d[h];
        s[h] = l(e[x], x, h, o && o[h]);
      }
    }
  else
    s = [];
  return i && (i[a] = s), s;
}
function ay(e, l) {
  for (let i = 0; i < l.length; i++) {
    const a = l[i];
    if (We(a))
      for (let s = 0; s < a.length; s++)
        e[a[s].name] = a[s].fn;
    else a && (e[a.name] = a.key ? (...s) => {
      const o = a.fn(...s);
      return o && (o.key = a.key), o;
    } : a.fn);
  }
  return e;
}
function Pn(e, l, i = {}, a, s) {
  if (Rl.ce || Rl.parent && Mu(Rl.parent) && Rl.parent.ce) {
    const I = Object.keys(i).length > 0;
    return l !== "default" && (i.name = l), tn(), vn(
      Vn,
      null,
      [Ye("slot", i, a && a())],
      I ? -2 : 64
    );
  }
  let o = e[l];
  o && o._c && (o._d = !1), tn();
  const f = o && Jm(o(i)), d = i.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  f && f.key, h = vn(
    Vn,
    {
      key: (d && !mi(d) ? d : `_${l}`) + // #7256 force differentiate fallback content from actual content
      (!f && a ? "_fb" : "")
    },
    f || (a ? a() : []),
    f && e._ === 1 ? 64 : -2
  );
  return !s && h.scopeId && (h.slotScopeIds = [h.scopeId + "-s"]), o && o._c && (o._d = !0), h;
}
function Jm(e) {
  return e.some((l) => Bi(l) ? !(l.type === il || l.type === Vn && !Jm(l.children)) : !0) ? e : null;
}
function ry(e, l) {
  const i = {};
  for (const a in e)
    i[l && /[A-Z]/.test(a) ? `on:${a}` : Ca(a)] = e[a];
  return i;
}
const nm = (e) => e ? jh(e) ? xs(e) : nm(e.parent) : null, Zr = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Mn(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => e.props,
    $attrs: (e) => e.attrs,
    $slots: (e) => e.slots,
    $refs: (e) => e.refs,
    $parent: (e) => nm(e.parent),
    $root: (e) => nm(e.root),
    $host: (e) => e.ce,
    $emit: (e) => e.emit,
    $options: (e) => ef(e),
    $forceUpdate: (e) => e.f || (e.f = () => {
      zm(e.update);
    }),
    $nextTick: (e) => e.n || (e.n = tl.bind(e.proxy)),
    $watch: (e) => Ny.bind(e)
  })
), Io = (e, l) => e !== On && !e.__isScriptSetup && qn(e, l), lm = {
  get({ _: e }, l) {
    if (l === "__v_skip")
      return !0;
    const { ctx: i, setupState: a, data: s, props: o, accessCache: f, type: d, appContext: h } = e;
    let I;
    if (l[0] !== "$") {
      const E = f[l];
      if (E !== void 0)
        switch (E) {
          case 1:
            return a[l];
          case 2:
            return s[l];
          case 4:
            return i[l];
          case 3:
            return o[l];
        }
      else {
        if (Io(a, l))
          return f[l] = 1, a[l];
        if (s !== On && qn(s, l))
          return f[l] = 2, s[l];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (I = e.propsOptions[0]) && qn(I, l)
        )
          return f[l] = 3, o[l];
        if (i !== On && qn(i, l))
          return f[l] = 4, i[l];
        tm && (f[l] = 0);
      }
    }
    const x = Zr[l];
    let y, P;
    if (x)
      return l === "$attrs" && El(e.attrs, "get", ""), x(e);
    if (
      // css module (injected by vue-loader)
      (y = d.__cssModules) && (y = y[l])
    )
      return y;
    if (i !== On && qn(i, l))
      return f[l] = 4, i[l];
    if (
      // global properties
      P = h.config.globalProperties, qn(P, l)
    )
      return P[l];
  },
  set({ _: e }, l, i) {
    const { data: a, setupState: s, ctx: o } = e;
    return Io(s, l) ? (s[l] = i, !0) : a !== On && qn(a, l) ? (a[l] = i, !0) : qn(e.props, l) || l[0] === "$" && l.slice(1) in e ? !1 : (o[l] = i, !0);
  },
  has({
    _: { data: e, setupState: l, accessCache: i, ctx: a, appContext: s, propsOptions: o, type: f }
  }, d) {
    let h, I;
    return !!(i[d] || e !== On && d[0] !== "$" && qn(e, d) || Io(l, d) || (h = o[0]) && qn(h, d) || qn(a, d) || qn(Zr, d) || qn(s.config.globalProperties, d) || (I = f.__cssModules) && I[d]);
  },
  defineProperty(e, l, i) {
    return i.get != null ? e._.accessCache[l] = 0 : qn(i, "value") && this.set(e, l, i.value, null), Reflect.defineProperty(e, l, i);
  }
}, sy = /* @__PURE__ */ Mn({}, lm, {
  get(e, l) {
    if (l !== Symbol.unscopables)
      return lm.get(e, l, e);
  },
  has(e, l) {
    return l[0] !== "_" && !Vv(l);
  }
});
function cy() {
  return null;
}
function oy() {
  return null;
}
function my(e) {
}
function fy(e) {
}
function dy() {
  return null;
}
function py() {
}
function hy(e, l) {
  return null;
}
function gy() {
  return xh().slots;
}
function vy() {
  return xh().attrs;
}
function xh(e) {
  const l = Yn();
  return l.setupContext || (l.setupContext = Wh(l));
}
function ns(e) {
  return We(e) ? e.reduce(
    (l, i) => (l[i] = null, l),
    {}
  ) : e;
}
function yh(e, l) {
  const i = ns(e);
  for (const a in l) {
    if (a.startsWith("__skip")) continue;
    let s = i[a];
    s ? We(s) || sn(s) ? s = i[a] = { type: s, default: l[a] } : s.default = l[a] : s === null && (s = i[a] = { default: l[a] }), s && l[`__skip_${a}`] && (s.skipFactory = !0);
  }
  return i;
}
function xy(e, l) {
  return !e || !l ? e || l : We(e) && We(l) ? e.concat(l) : Mn({}, ns(e), ns(l));
}
function yy(e, l) {
  const i = {};
  for (const a in e)
    l.includes(a) || Object.defineProperty(i, a, {
      enumerable: !0,
      get: () => e[a]
    });
  return i;
}
function Iy(e) {
  const l = Yn();
  let i = e();
  return sm(), km(i) && (i = i.catch((a) => {
    throw ia(l), a;
  })), [i, () => ia(l)];
}
let tm = !0;
function Ly(e) {
  const l = ef(e), i = e.proxy, a = e.ctx;
  tm = !1, l.beforeCreate && Uf(l.beforeCreate, e, "bc");
  const {
    // state
    data: s,
    computed: o,
    methods: f,
    watch: d,
    provide: h,
    inject: I,
    // lifecycle
    created: x,
    beforeMount: y,
    mounted: P,
    beforeUpdate: E,
    updated: R,
    activated: V,
    deactivated: K,
    beforeDestroy: $,
    beforeUnmount: Q,
    destroyed: Z,
    unmounted: G,
    render: Y,
    renderTracked: se,
    renderTriggered: te,
    errorCaptured: fe,
    serverPrefetch: M,
    // public API
    expose: oe,
    inheritAttrs: Le,
    // assets
    components: ae,
    directives: ye,
    filters: he
  } = l;
  if (I && Dy(I, a, null), f)
    for (const ce in f) {
      const de = f[ce];
      sn(de) && (a[ce] = de.bind(i));
    }
  if (s) {
    const ce = s.call(i, i);
    _n(ce) && (e.data = Ua(ce));
  }
  if (tm = !0, o)
    for (const ce in o) {
      const de = o[ce], we = sn(de) ? de.bind(i, i) : sn(de.get) ? de.get.bind(i, i) : Dt, Ae = !sn(de) && sn(de.set) ? de.set.bind(i) : Dt, $e = _e({
        get: we,
        set: Ae
      });
      Object.defineProperty(a, ce, {
        enumerable: !0,
        configurable: !0,
        get: () => $e.value,
        set: (ze) => $e.value = ze
      });
    }
  if (d)
    for (const ce in d)
      Ih(d[ce], a, i, ce);
  if (h) {
    const ce = sn(h) ? h.call(i) : h;
    Reflect.ownKeys(ce).forEach((de) => {
      Gc(de, ce[de]);
    });
  }
  x && Uf(x, e, "c");
  function xe(ce, de) {
    We(de) ? de.forEach((we) => ce(we.bind(i))) : de && ce(de.bind(i));
  }
  if (xe(fh, y), xe(vl, P), xe(Ym, E), xe(Kc, R), xe(ch, V), xe(oh, K), xe(gh, fe), xe(hh, se), xe(ph, te), xe(ps, Q), xe(St, G), xe(dh, M), We(oe))
    if (oe.length) {
      const ce = e.exposed || (e.exposed = {});
      oe.forEach((de) => {
        Object.defineProperty(ce, de, {
          get: () => i[de],
          set: (we) => i[de] = we,
          enumerable: !0
        });
      });
    } else e.exposed || (e.exposed = {});
  Y && e.render === Dt && (e.render = Y), Le != null && (e.inheritAttrs = Le), ae && (e.components = ae), ye && (e.directives = ye), M && $m(e);
}
function Dy(e, l, i = Dt) {
  We(e) && (e = im(e));
  for (const a in e) {
    const s = e[a];
    let o;
    _n(s) ? "default" in s ? o = Ei(
      s.from || a,
      s.default,
      !0
    ) : o = Ei(s.from || a) : o = Ei(s), kn(o) ? Object.defineProperty(l, a, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (f) => o.value = f
    }) : l[a] = o;
  }
}
function Uf(e, l, i) {
  bt(
    We(e) ? e.map((a) => a.bind(l.proxy)) : e.bind(l.proxy),
    l,
    i
  );
}
function Ih(e, l, i, a) {
  let s = a.includes(".") ? Mh(i, a) : () => i[a];
  if (Wn(e)) {
    const o = l[e];
    sn(o) && Sn(s, o);
  } else if (sn(e))
    Sn(s, e.bind(i));
  else if (_n(e))
    if (We(e))
      e.forEach((o) => Ih(o, l, i, a));
    else {
      const o = sn(e.handler) ? e.handler.bind(i) : l[e.handler];
      sn(o) && Sn(s, o, e);
    }
}
function ef(e) {
  const l = e.type, { mixins: i, extends: a } = l, {
    mixins: s,
    optionsCache: o,
    config: { optionMergeStrategies: f }
  } = e.appContext, d = o.get(l);
  let h;
  return d ? h = d : !s.length && !i && !a ? h = l : (h = {}, s.length && s.forEach(
    (I) => oc(h, I, f, !0)
  ), oc(h, l, f)), _n(l) && o.set(l, h), h;
}
function oc(e, l, i, a = !1) {
  const { mixins: s, extends: o } = l;
  o && oc(e, o, i, !0), s && s.forEach(
    (f) => oc(e, f, i, !0)
  );
  for (const f in l)
    if (!(a && f === "expose")) {
      const d = Oy[f] || i && i[f];
      e[f] = d ? d(e[f], l[f]) : l[f];
    }
  return e;
}
const Oy = {
  data: Kf,
  props: Gf,
  emits: Gf,
  // objects
  methods: Nr,
  computed: Nr,
  // lifecycle
  beforeCreate: Fl,
  created: Fl,
  beforeMount: Fl,
  mounted: Fl,
  beforeUpdate: Fl,
  updated: Fl,
  beforeDestroy: Fl,
  beforeUnmount: Fl,
  destroyed: Fl,
  unmounted: Fl,
  activated: Fl,
  deactivated: Fl,
  errorCaptured: Fl,
  serverPrefetch: Fl,
  // assets
  components: Nr,
  directives: Nr,
  // watch
  watch: by,
  // provide / inject
  provide: Kf,
  inject: wy
};
function Kf(e, l) {
  return l ? e ? function() {
    return Mn(
      sn(e) ? e.call(this, this) : e,
      sn(l) ? l.call(this, this) : l
    );
  } : l : e;
}
function wy(e, l) {
  return Nr(im(e), im(l));
}
function im(e) {
  if (We(e)) {
    const l = {};
    for (let i = 0; i < e.length; i++)
      l[e[i]] = e[i];
    return l;
  }
  return e;
}
function Fl(e, l) {
  return e ? [...new Set([].concat(e, l))] : l;
}
function Nr(e, l) {
  return e ? Mn(/* @__PURE__ */ Object.create(null), e, l) : l;
}
function Gf(e, l) {
  return e ? We(e) && We(l) ? [.../* @__PURE__ */ new Set([...e, ...l])] : Mn(
    /* @__PURE__ */ Object.create(null),
    ns(e),
    ns(l ?? {})
  ) : l;
}
function by(e, l) {
  if (!e) return l;
  if (!l) return e;
  const i = Mn(/* @__PURE__ */ Object.create(null), e);
  for (const a in l)
    i[a] = Fl(e[a], l[a]);
  return i;
}
function Lh() {
  return {
    app: null,
    config: {
      isNativeTag: wp,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let Sy = 0;
function Cy(e, l) {
  return function(a, s = null) {
    sn(a) || (a = Mn({}, a)), s != null && !_n(s) && (s = null);
    const o = Lh(), f = /* @__PURE__ */ new WeakSet(), d = [];
    let h = !1;
    const I = o.app = {
      _uid: Sy++,
      _component: a,
      _props: s,
      _container: null,
      _context: o,
      _instance: null,
      version: Qh,
      get config() {
        return o.config;
      },
      set config(x) {
      },
      use(x, ...y) {
        return f.has(x) || (x && sn(x.install) ? (f.add(x), x.install(I, ...y)) : sn(x) && (f.add(x), x(I, ...y))), I;
      },
      mixin(x) {
        return o.mixins.includes(x) || o.mixins.push(x), I;
      },
      component(x, y) {
        return y ? (o.components[x] = y, I) : o.components[x];
      },
      directive(x, y) {
        return y ? (o.directives[x] = y, I) : o.directives[x];
      },
      mount(x, y, P) {
        if (!h) {
          const E = I._ceVNode || Ye(a, s);
          return E.appContext = o, P === !0 ? P = "svg" : P === !1 && (P = void 0), y && l ? l(E, x) : e(E, x, P), h = !0, I._container = x, x.__vue_app__ = I, xs(E.component);
        }
      },
      onUnmount(x) {
        d.push(x);
      },
      unmount() {
        h && (bt(
          d,
          I._instance,
          16
        ), e(null, I._container), delete I._container.__vue_app__);
      },
      provide(x, y) {
        return o.provides[x] = y, I;
      },
      runWithContext(x) {
        const y = na;
        na = I;
        try {
          return x();
        } finally {
          na = y;
        }
      }
    };
    return I;
  };
}
let na = null;
function Gc(e, l) {
  if (Pl) {
    let i = Pl.provides;
    const a = Pl.parent && Pl.parent.provides;
    a === i && (i = Pl.provides = Object.create(a)), i[e] = l;
  }
}
function Ei(e, l, i = !1) {
  const a = Yn();
  if (a || na) {
    let s = na ? na._context.provides : a ? a.parent == null || a.ce ? a.vnode.appContext && a.vnode.appContext.provides : a.parent.provides : void 0;
    if (s && e in s)
      return s[e];
    if (arguments.length > 1)
      return i && sn(l) ? l.call(a && a.proxy) : l;
  }
}
function zc() {
  return !!(Yn() || na);
}
const Dh = {}, Oh = () => Object.create(Dh), wh = (e) => Object.getPrototypeOf(e) === Dh;
function Ty(e, l, i, a = !1) {
  const s = {}, o = Oh();
  e.propsDefaults = /* @__PURE__ */ Object.create(null), bh(e, l, s, o);
  for (const f in e.propsOptions[0])
    f in s || (s[f] = void 0);
  i ? e.props = a ? s : zp(s) : e.type.props ? e.props = s : e.props = o, e.attrs = o;
}
function qy(e, l, i, a) {
  const {
    props: s,
    attrs: o,
    vnode: { patchFlag: f }
  } = e, d = Ln(s), [h] = e.propsOptions;
  let I = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (a || f > 0) && !(f & 16)
  ) {
    if (f & 8) {
      const x = e.vnode.dynamicProps;
      for (let y = 0; y < x.length; y++) {
        let P = x[y];
        if (jc(e.emitsOptions, P))
          continue;
        const E = l[P];
        if (h)
          if (qn(o, P))
            E !== o[P] && (o[P] = E, I = !0);
          else {
            const R = hl(P);
            s[R] = um(
              h,
              d,
              R,
              E,
              e,
              !1
            );
          }
        else
          E !== o[P] && (o[P] = E, I = !0);
      }
    }
  } else {
    bh(e, l, s, o) && (I = !0);
    let x;
    for (const y in d)
      (!l || // for camelCase
      !qn(l, y) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((x = dt(y)) === y || !qn(l, x))) && (h ? i && // for camelCase
      (i[y] !== void 0 || // for kebab-case
      i[x] !== void 0) && (s[y] = um(
        h,
        d,
        y,
        void 0,
        e,
        !0
      )) : delete s[y]);
    if (o !== d)
      for (const y in o)
        (!l || !qn(l, y)) && (delete o[y], I = !0);
  }
  I && Pi(e.attrs, "set", "");
}
function bh(e, l, i, a) {
  const [s, o] = e.propsOptions;
  let f = !1, d;
  if (l)
    for (let h in l) {
      if (Sa(h))
        continue;
      const I = l[h];
      let x;
      s && qn(s, x = hl(h)) ? !o || !o.includes(x) ? i[x] = I : (d || (d = {}))[x] = I : jc(e.emitsOptions, h) || (!(h in a) || I !== a[h]) && (a[h] = I, f = !0);
    }
  if (o) {
    const h = Ln(i), I = d || On;
    for (let x = 0; x < o.length; x++) {
      const y = o[x];
      i[y] = um(
        s,
        h,
        y,
        I[y],
        e,
        !qn(I, y)
      );
    }
  }
  return f;
}
function um(e, l, i, a, s, o) {
  const f = e[i];
  if (f != null) {
    const d = qn(f, "default");
    if (d && a === void 0) {
      const h = f.default;
      if (f.type !== Function && !f.skipFactory && sn(h)) {
        const { propsDefaults: I } = s;
        if (i in I)
          a = I[i];
        else {
          const x = ia(s);
          a = I[i] = h.call(
            null,
            l
          ), x();
        }
      } else
        a = h;
      s.ce && s.ce._setProp(i, a);
    }
    f[
      0
      /* shouldCast */
    ] && (o && !d ? a = !1 : f[
      1
      /* shouldCastTrue */
    ] && (a === "" || a === dt(i)) && (a = !0));
  }
  return a;
}
const Py = /* @__PURE__ */ new WeakMap();
function Sh(e, l, i = !1) {
  const a = i ? Py : l.propsCache, s = a.get(e);
  if (s)
    return s;
  const o = e.props, f = {}, d = [];
  let h = !1;
  if (!sn(e)) {
    const x = (y) => {
      h = !0;
      const [P, E] = Sh(y, l, !0);
      Mn(f, P), E && d.push(...E);
    };
    !i && l.mixins.length && l.mixins.forEach(x), e.extends && x(e.extends), e.mixins && e.mixins.forEach(x);
  }
  if (!o && !h)
    return _n(e) && a.set(e, wa), wa;
  if (We(o))
    for (let x = 0; x < o.length; x++) {
      const y = hl(o[x]);
      zf(y) && (f[y] = On);
    }
  else if (o)
    for (const x in o) {
      const y = hl(x);
      if (zf(y)) {
        const P = o[x], E = f[y] = We(P) || sn(P) ? { type: P } : Mn({}, P), R = E.type;
        let V = !1, K = !0;
        if (We(R))
          for (let $ = 0; $ < R.length; ++$) {
            const Q = R[$], Z = sn(Q) && Q.name;
            if (Z === "Boolean") {
              V = !0;
              break;
            } else Z === "String" && (K = !1);
          }
        else
          V = sn(R) && R.name === "Boolean";
        E[
          0
          /* shouldCast */
        ] = V, E[
          1
          /* shouldCastTrue */
        ] = K, (V || qn(E, "default")) && d.push(y);
      }
    }
  const I = [f, d];
  return _n(e) && a.set(e, I), I;
}
function zf(e) {
  return e[0] !== "$" && !Sa(e);
}
const nf = (e) => e === "_" || e === "_ctx" || e === "$stable", lf = (e) => We(e) ? e.map(ft) : [ft(e)], Ry = (e, l, i) => {
  if (l._n)
    return l;
  const a = nn((...s) => lf(l(...s)), i);
  return a._c = !1, a;
}, Ch = (e, l, i) => {
  const a = e._ctx;
  for (const s in e) {
    if (nf(s)) continue;
    const o = e[s];
    if (sn(o))
      l[s] = Ry(s, o, a);
    else if (o != null) {
      const f = lf(o);
      l[s] = () => f;
    }
  }
}, Th = (e, l) => {
  const i = lf(l);
  e.slots.default = () => i;
}, qh = (e, l, i) => {
  for (const a in l)
    (i || !nf(a)) && (e[a] = l[a]);
}, Ay = (e, l, i) => {
  const a = e.slots = Oh();
  if (e.vnode.shapeFlag & 32) {
    const s = l._;
    s ? (qh(a, l, i), i && Sp(a, "_", s, !0)) : Ch(l, a);
  } else l && Th(e, l);
}, Ey = (e, l, i) => {
  const { vnode: a, slots: s } = e;
  let o = !0, f = On;
  if (a.shapeFlag & 32) {
    const d = l._;
    d ? i && d === 1 ? o = !1 : qh(s, l, i) : (o = !l.$stable, Ch(l, s)), f = l;
  } else l && (Th(e, l), f = { default: 1 });
  if (o)
    for (const d in s)
      !nf(d) && f[d] == null && delete s[d];
}, pl = Zh;
function Ph(e) {
  return Ah(e);
}
function Rh(e) {
  return Ah(e, Kx);
}
function Ah(e, l) {
  const i = Rc();
  i.__VUE__ = !0;
  const {
    insert: a,
    remove: s,
    patchProp: o,
    createElement: f,
    createText: d,
    createComment: h,
    setText: I,
    setElementText: x,
    parentNode: y,
    nextSibling: P,
    setScopeId: E = Dt,
    insertStaticContent: R
  } = e, V = (j, ie, me, Te = null, Ie = null, be = null, Ne = void 0, Ee = null, Oe = !!ie.dynamicChildren) => {
    if (j === ie)
      return;
    j && !ai(j, ie) && (Te = k(j), ze(j, Ie, be, !0), j = null), ie.patchFlag === -2 && (Oe = !1, ie.dynamicChildren = null);
    const { type: qe, ref: Ke, shapeFlag: ke } = ie;
    switch (qe) {
      case ku:
        K(j, ie, me, Te);
        break;
      case il:
        $(j, ie, me, Te);
        break;
      case la:
        j == null && Q(ie, me, Te, Ne);
        break;
      case Vn:
        ae(
          j,
          ie,
          me,
          Te,
          Ie,
          be,
          Ne,
          Ee,
          Oe
        );
        break;
      default:
        ke & 1 ? Y(
          j,
          ie,
          me,
          Te,
          Ie,
          be,
          Ne,
          Ee,
          Oe
        ) : ke & 6 ? ye(
          j,
          ie,
          me,
          Te,
          Ie,
          be,
          Ne,
          Ee,
          Oe
        ) : (ke & 64 || ke & 128) && qe.process(
          j,
          ie,
          me,
          Te,
          Ie,
          be,
          Ne,
          Ee,
          Oe,
          le
        );
    }
    Ke != null && Ie ? Pa(Ke, j && j.ref, be, ie || j, !ie) : Ke == null && j && j.ref != null && Pa(j.ref, null, be, j, !0);
  }, K = (j, ie, me, Te) => {
    if (j == null)
      a(
        ie.el = d(ie.children),
        me,
        Te
      );
    else {
      const Ie = ie.el = j.el;
      ie.children !== j.children && I(Ie, ie.children);
    }
  }, $ = (j, ie, me, Te) => {
    j == null ? a(
      ie.el = h(ie.children || ""),
      me,
      Te
    ) : ie.el = j.el;
  }, Q = (j, ie, me, Te) => {
    [j.el, j.anchor] = R(
      j.children,
      ie,
      me,
      Te,
      j.el,
      j.anchor
    );
  }, Z = ({ el: j, anchor: ie }, me, Te) => {
    let Ie;
    for (; j && j !== ie; )
      Ie = P(j), a(j, me, Te), j = Ie;
    a(ie, me, Te);
  }, G = ({ el: j, anchor: ie }) => {
    let me;
    for (; j && j !== ie; )
      me = P(j), s(j), j = me;
    s(ie);
  }, Y = (j, ie, me, Te, Ie, be, Ne, Ee, Oe) => {
    ie.type === "svg" ? Ne = "svg" : ie.type === "math" && (Ne = "mathml"), j == null ? se(
      ie,
      me,
      Te,
      Ie,
      be,
      Ne,
      Ee,
      Oe
    ) : M(
      j,
      ie,
      Ie,
      be,
      Ne,
      Ee,
      Oe
    );
  }, se = (j, ie, me, Te, Ie, be, Ne, Ee) => {
    let Oe, qe;
    const { props: Ke, shapeFlag: ke, transition: Ze, dirs: Ue } = j;
    if (Oe = j.el = f(
      j.type,
      be,
      Ke && Ke.is,
      Ke
    ), ke & 8 ? x(Oe, j.children) : ke & 16 && fe(
      j.children,
      Oe,
      null,
      Te,
      Ie,
      Lo(j, be),
      Ne,
      Ee
    ), Ue && yi(j, null, Te, "created"), te(Oe, j, j.scopeId, Ne, Te), Ke) {
      for (const yn in Ke)
        yn !== "value" && !Sa(yn) && o(Oe, yn, null, Ke[yn], be, Te);
      "value" in Ke && o(Oe, "value", null, Ke.value, be), (qe = Ke.onVnodeBeforeMount) && ot(qe, Te, j);
    }
    Ue && yi(j, null, Te, "beforeMount");
    const Qe = Eh(Ie, Ze);
    Qe && Ze.beforeEnter(Oe), a(Oe, ie, me), ((qe = Ke && Ke.onVnodeMounted) || Qe || Ue) && pl(() => {
      qe && ot(qe, Te, j), Qe && Ze.enter(Oe), Ue && yi(j, null, Te, "mounted");
    }, Ie);
  }, te = (j, ie, me, Te, Ie) => {
    if (me && E(j, me), Te)
      for (let be = 0; be < Te.length; be++)
        E(j, Te[be]);
    if (Ie) {
      let be = Ie.subTree;
      if (ie === be || fc(be.type) && (be.ssContent === ie || be.ssFallback === ie)) {
        const Ne = Ie.vnode;
        te(
          j,
          Ne,
          Ne.scopeId,
          Ne.slotScopeIds,
          Ie.parent
        );
      }
    }
  }, fe = (j, ie, me, Te, Ie, be, Ne, Ee, Oe = 0) => {
    for (let qe = Oe; qe < j.length; qe++) {
      const Ke = j[qe] = Ee ? Eu(j[qe]) : ft(j[qe]);
      V(
        null,
        Ke,
        ie,
        me,
        Te,
        Ie,
        be,
        Ne,
        Ee
      );
    }
  }, M = (j, ie, me, Te, Ie, be, Ne) => {
    const Ee = ie.el = j.el;
    let { patchFlag: Oe, dynamicChildren: qe, dirs: Ke } = ie;
    Oe |= j.patchFlag & 16;
    const ke = j.props || On, Ze = ie.props || On;
    let Ue;
    if (me && $u(me, !1), (Ue = Ze.onVnodeBeforeUpdate) && ot(Ue, me, ie, j), Ke && yi(ie, j, me, "beforeUpdate"), me && $u(me, !0), (ke.innerHTML && Ze.innerHTML == null || ke.textContent && Ze.textContent == null) && x(Ee, ""), qe ? oe(
      j.dynamicChildren,
      qe,
      Ee,
      me,
      Te,
      Lo(ie, Ie),
      be
    ) : Ne || de(
      j,
      ie,
      Ee,
      null,
      me,
      Te,
      Lo(ie, Ie),
      be,
      !1
    ), Oe > 0) {
      if (Oe & 16)
        Le(Ee, ke, Ze, me, Ie);
      else if (Oe & 2 && ke.class !== Ze.class && o(Ee, "class", null, Ze.class, Ie), Oe & 4 && o(Ee, "style", ke.style, Ze.style, Ie), Oe & 8) {
        const Qe = ie.dynamicProps;
        for (let yn = 0; yn < Qe.length; yn++) {
          const on = Qe[yn], Bn = ke[on], Tn = Ze[on];
          (Tn !== Bn || on === "value") && o(Ee, on, Bn, Tn, Ie, me);
        }
      }
      Oe & 1 && j.children !== ie.children && x(Ee, ie.children);
    } else !Ne && qe == null && Le(Ee, ke, Ze, me, Ie);
    ((Ue = Ze.onVnodeUpdated) || Ke) && pl(() => {
      Ue && ot(Ue, me, ie, j), Ke && yi(ie, j, me, "updated");
    }, Te);
  }, oe = (j, ie, me, Te, Ie, be, Ne) => {
    for (let Ee = 0; Ee < ie.length; Ee++) {
      const Oe = j[Ee], qe = ie[Ee], Ke = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        Oe.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (Oe.type === Vn || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !ai(Oe, qe) || // - In the case of a component, it could contain anything.
        Oe.shapeFlag & 198) ? y(Oe.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          me
        )
      );
      V(
        Oe,
        qe,
        Ke,
        null,
        Te,
        Ie,
        be,
        Ne,
        !0
      );
    }
  }, Le = (j, ie, me, Te, Ie) => {
    if (ie !== me) {
      if (ie !== On)
        for (const be in ie)
          !Sa(be) && !(be in me) && o(
            j,
            be,
            ie[be],
            null,
            Ie,
            Te
          );
      for (const be in me) {
        if (Sa(be)) continue;
        const Ne = me[be], Ee = ie[be];
        Ne !== Ee && be !== "value" && o(j, be, Ee, Ne, Ie, Te);
      }
      "value" in me && o(j, "value", ie.value, me.value, Ie);
    }
  }, ae = (j, ie, me, Te, Ie, be, Ne, Ee, Oe) => {
    const qe = ie.el = j ? j.el : d(""), Ke = ie.anchor = j ? j.anchor : d("");
    let { patchFlag: ke, dynamicChildren: Ze, slotScopeIds: Ue } = ie;
    Ue && (Ee = Ee ? Ee.concat(Ue) : Ue), j == null ? (a(qe, me, Te), a(Ke, me, Te), fe(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      ie.children || [],
      me,
      Ke,
      Ie,
      be,
      Ne,
      Ee,
      Oe
    )) : ke > 0 && ke & 64 && Ze && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    j.dynamicChildren ? (oe(
      j.dynamicChildren,
      Ze,
      me,
      Ie,
      be,
      Ne,
      Ee
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (ie.key != null || Ie && ie === Ie.subTree) && tf(
      j,
      ie,
      !0
      /* shallow */
    )) : de(
      j,
      ie,
      me,
      Ke,
      Ie,
      be,
      Ne,
      Ee,
      Oe
    );
  }, ye = (j, ie, me, Te, Ie, be, Ne, Ee, Oe) => {
    ie.slotScopeIds = Ee, j == null ? ie.shapeFlag & 512 ? Ie.ctx.activate(
      ie,
      me,
      Te,
      Ne,
      Oe
    ) : he(
      ie,
      me,
      Te,
      Ie,
      be,
      Ne,
      Oe
    ) : Ce(j, ie, Oe);
  }, he = (j, ie, me, Te, Ie, be, Ne) => {
    const Ee = j.component = zh(
      j,
      Te,
      Ie
    );
    if (ds(j) && (Ee.ctx.renderer = le), Hh(Ee, !1, Ne), Ee.asyncDep) {
      if (Ie && Ie.registerDep(Ee, xe, Ne), !j.el) {
        const Oe = Ee.subTree = Ye(il);
        $(null, Oe, ie, me), j.placeholder = Oe.el;
      }
    } else
      xe(
        Ee,
        j,
        ie,
        me,
        Ie,
        be,
        Ne
      );
  }, Ce = (j, ie, me) => {
    const Te = ie.component = j.component;
    if (Uy(j, ie, me))
      if (Te.asyncDep && !Te.asyncResolved) {
        ce(Te, ie, me);
        return;
      } else
        Te.next = ie, Te.update();
    else
      ie.el = j.el, Te.vnode = ie;
  }, xe = (j, ie, me, Te, Ie, be, Ne) => {
    const Ee = () => {
      if (j.isMounted) {
        let { next: ke, bu: Ze, u: Ue, parent: Qe, vnode: yn } = j;
        {
          const Nn = _h(j);
          if (Nn) {
            ke && (ke.el = yn.el, ce(j, ke, Ne)), Nn.asyncDep.then(() => {
              j.isUnmounted || Ee();
            });
            return;
          }
        }
        let on = ke, Bn;
        $u(j, !1), ke ? (ke.el = yn.el, ce(j, ke, Ne)) : ke = yn, Ze && Ta(Ze), (Bn = ke.props && ke.props.onVnodeBeforeUpdate) && ot(Bn, Qe, ke, yn), $u(j, !0);
        const Tn = Ws(j), Dn = j.subTree;
        j.subTree = Tn, V(
          Dn,
          Tn,
          // parent may have changed if it's in a teleport
          y(Dn.el),
          // anchor may have changed if it's in a fragment
          k(Dn),
          j,
          Ie,
          be
        ), ke.el = Tn.el, on === null && Hc(j, Tn.el), Ue && pl(Ue, Ie), (Bn = ke.props && ke.props.onVnodeUpdated) && pl(
          () => ot(Bn, Qe, ke, yn),
          Ie
        );
      } else {
        let ke;
        const { el: Ze, props: Ue } = ie, { bm: Qe, m: yn, parent: on, root: Bn, type: Tn } = j, Dn = Mu(ie);
        if ($u(j, !1), Qe && Ta(Qe), !Dn && (ke = Ue && Ue.onVnodeBeforeMount) && ot(ke, on, ie), $u(j, !0), Ze && De) {
          const Nn = () => {
            j.subTree = Ws(j), De(
              Ze,
              j.subTree,
              j,
              Ie,
              null
            );
          };
          Dn && Tn.__asyncHydrate ? Tn.__asyncHydrate(
            Ze,
            j,
            Nn
          ) : Nn();
        } else {
          Bn.ce && // @ts-expect-error _def is private
          Bn.ce._def.shadowRoot !== !1 && Bn.ce._injectChildStyle(Tn);
          const Nn = j.subTree = Ws(j);
          V(
            null,
            Nn,
            me,
            Te,
            j,
            Ie,
            be
          ), ie.el = Nn.el;
        }
        if (yn && pl(yn, Ie), !Dn && (ke = Ue && Ue.onVnodeMounted)) {
          const Nn = ie;
          pl(
            () => ot(ke, on, Nn),
            Ie
          );
        }
        (ie.shapeFlag & 256 || on && Mu(on.vnode) && on.vnode.shapeFlag & 256) && j.a && pl(j.a, Ie), j.isMounted = !0, ie = me = Te = null;
      }
    };
    j.scope.on();
    const Oe = j.effect = new Wr(Ee);
    j.scope.off();
    const qe = j.update = Oe.run.bind(Oe), Ke = j.job = Oe.runIfDirty.bind(Oe);
    Ke.i = j, Ke.id = j.uid, Oe.scheduler = () => zm(Ke), $u(j, !0), qe();
  }, ce = (j, ie, me) => {
    ie.component = j;
    const Te = j.vnode.props;
    j.vnode = ie, j.next = null, qy(j, ie.props, Te, me), Ey(j, ie.children, me), Ni(), Ef(j), Fi();
  }, de = (j, ie, me, Te, Ie, be, Ne, Ee, Oe = !1) => {
    const qe = j && j.children, Ke = j ? j.shapeFlag : 0, ke = ie.children, { patchFlag: Ze, shapeFlag: Ue } = ie;
    if (Ze > 0) {
      if (Ze & 128) {
        Ae(
          qe,
          ke,
          me,
          Te,
          Ie,
          be,
          Ne,
          Ee,
          Oe
        );
        return;
      } else if (Ze & 256) {
        we(
          qe,
          ke,
          me,
          Te,
          Ie,
          be,
          Ne,
          Ee,
          Oe
        );
        return;
      }
    }
    Ue & 8 ? (Ke & 16 && ln(qe, Ie, be), ke !== qe && x(me, ke)) : Ke & 16 ? Ue & 16 ? Ae(
      qe,
      ke,
      me,
      Te,
      Ie,
      be,
      Ne,
      Ee,
      Oe
    ) : ln(qe, Ie, be, !0) : (Ke & 8 && x(me, ""), Ue & 16 && fe(
      ke,
      me,
      Te,
      Ie,
      be,
      Ne,
      Ee,
      Oe
    ));
  }, we = (j, ie, me, Te, Ie, be, Ne, Ee, Oe) => {
    j = j || wa, ie = ie || wa;
    const qe = j.length, Ke = ie.length, ke = Math.min(qe, Ke);
    let Ze;
    for (Ze = 0; Ze < ke; Ze++) {
      const Ue = ie[Ze] = Oe ? Eu(ie[Ze]) : ft(ie[Ze]);
      V(
        j[Ze],
        Ue,
        me,
        null,
        Ie,
        be,
        Ne,
        Ee,
        Oe
      );
    }
    qe > Ke ? ln(
      j,
      Ie,
      be,
      !0,
      !1,
      ke
    ) : fe(
      ie,
      me,
      Te,
      Ie,
      be,
      Ne,
      Ee,
      Oe,
      ke
    );
  }, Ae = (j, ie, me, Te, Ie, be, Ne, Ee, Oe) => {
    let qe = 0;
    const Ke = ie.length;
    let ke = j.length - 1, Ze = Ke - 1;
    for (; qe <= ke && qe <= Ze; ) {
      const Ue = j[qe], Qe = ie[qe] = Oe ? Eu(ie[qe]) : ft(ie[qe]);
      if (ai(Ue, Qe))
        V(
          Ue,
          Qe,
          me,
          null,
          Ie,
          be,
          Ne,
          Ee,
          Oe
        );
      else
        break;
      qe++;
    }
    for (; qe <= ke && qe <= Ze; ) {
      const Ue = j[ke], Qe = ie[Ze] = Oe ? Eu(ie[Ze]) : ft(ie[Ze]);
      if (ai(Ue, Qe))
        V(
          Ue,
          Qe,
          me,
          null,
          Ie,
          be,
          Ne,
          Ee,
          Oe
        );
      else
        break;
      ke--, Ze--;
    }
    if (qe > ke) {
      if (qe <= Ze) {
        const Ue = Ze + 1, Qe = Ue < Ke ? ie[Ue].el : Te;
        for (; qe <= Ze; )
          V(
            null,
            ie[qe] = Oe ? Eu(ie[qe]) : ft(ie[qe]),
            me,
            Qe,
            Ie,
            be,
            Ne,
            Ee,
            Oe
          ), qe++;
      }
    } else if (qe > Ze)
      for (; qe <= ke; )
        ze(j[qe], Ie, be, !0), qe++;
    else {
      const Ue = qe, Qe = qe, yn = /* @__PURE__ */ new Map();
      for (qe = Qe; qe <= Ze; qe++) {
        const re = ie[qe] = Oe ? Eu(ie[qe]) : ft(ie[qe]);
        re.key != null && yn.set(re.key, qe);
      }
      let on, Bn = 0;
      const Tn = Ze - Qe + 1;
      let Dn = !1, Nn = 0;
      const xl = new Array(Tn);
      for (qe = 0; qe < Tn; qe++) xl[qe] = 0;
      for (qe = Ue; qe <= ke; qe++) {
        const re = j[qe];
        if (Bn >= Tn) {
          ze(re, Ie, be, !0);
          continue;
        }
        let Fn;
        if (re.key != null)
          Fn = yn.get(re.key);
        else
          for (on = Qe; on <= Ze; on++)
            if (xl[on - Qe] === 0 && ai(re, ie[on])) {
              Fn = on;
              break;
            }
        Fn === void 0 ? ze(re, Ie, be, !0) : (xl[Fn - Qe] = qe + 1, Fn >= Nn ? Nn = Fn : Dn = !0, V(
          re,
          ie[Fn],
          me,
          null,
          Ie,
          be,
          Ne,
          Ee,
          Oe
        ), Bn++);
      }
      const Rn = Dn ? _y(xl) : wa;
      for (on = Rn.length - 1, qe = Tn - 1; qe >= 0; qe--) {
        const re = Qe + qe, Fn = ie[re], Zn = ie[re + 1], yl = re + 1 < Ke ? (
          // #13559, fallback to el placeholder for unresolved async component
          Zn.el || Zn.placeholder
        ) : Te;
        xl[qe] === 0 ? V(
          null,
          Fn,
          me,
          yl,
          Ie,
          be,
          Ne,
          Ee,
          Oe
        ) : Dn && (on < 0 || qe !== Rn[on] ? $e(Fn, me, yl, 2) : on--);
      }
    }
  }, $e = (j, ie, me, Te, Ie = null) => {
    const { el: be, type: Ne, transition: Ee, children: Oe, shapeFlag: qe } = j;
    if (qe & 6) {
      $e(j.component.subTree, ie, me, Te);
      return;
    }
    if (qe & 128) {
      j.suspense.move(ie, me, Te);
      return;
    }
    if (qe & 64) {
      Ne.move(j, ie, me, le);
      return;
    }
    if (Ne === Vn) {
      a(be, ie, me);
      for (let ke = 0; ke < Oe.length; ke++)
        $e(Oe[ke], ie, me, Te);
      a(j.anchor, ie, me);
      return;
    }
    if (Ne === la) {
      Z(j, ie, me);
      return;
    }
    if (Te !== 2 && qe & 1 && Ee)
      if (Te === 0)
        Ee.beforeEnter(be), a(be, ie, me), pl(() => Ee.enter(be), Ie);
      else {
        const { leave: ke, delayLeave: Ze, afterLeave: Ue } = Ee, Qe = () => {
          j.ctx.isUnmounted ? s(be) : a(be, ie, me);
        }, yn = () => {
          be._isLeaving && be[qi](
            !0
            /* cancelled */
          ), ke(be, () => {
            Qe(), Ue && Ue();
          });
        };
        Ze ? Ze(be, Qe, yn) : yn();
      }
    else
      a(be, ie, me);
  }, ze = (j, ie, me, Te = !1, Ie = !1) => {
    const {
      type: be,
      props: Ne,
      ref: Ee,
      children: Oe,
      dynamicChildren: qe,
      shapeFlag: Ke,
      patchFlag: ke,
      dirs: Ze,
      cacheIndex: Ue
    } = j;
    if (ke === -2 && (Ie = !1), Ee != null && (Ni(), Pa(Ee, null, me, j, !0), Fi()), Ue != null && (ie.renderCache[Ue] = void 0), Ke & 256) {
      ie.ctx.deactivate(j);
      return;
    }
    const Qe = Ke & 1 && Ze, yn = !Mu(j);
    let on;
    if (yn && (on = Ne && Ne.onVnodeBeforeUnmount) && ot(on, ie, j), Ke & 6)
      xn(j.component, me, Te);
    else {
      if (Ke & 128) {
        j.suspense.unmount(me, Te);
        return;
      }
      Qe && yi(j, null, ie, "beforeUnmount"), Ke & 64 ? j.type.remove(
        j,
        ie,
        me,
        le,
        Te
      ) : qe && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !qe.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (be !== Vn || ke > 0 && ke & 64) ? ln(
        qe,
        ie,
        me,
        !1,
        !0
      ) : (be === Vn && ke & 384 || !Ie && Ke & 16) && ln(Oe, ie, me), Te && cn(j);
    }
    (yn && (on = Ne && Ne.onVnodeUnmounted) || Qe) && pl(() => {
      on && ot(on, ie, j), Qe && yi(j, null, ie, "unmounted");
    }, me);
  }, cn = (j) => {
    const { type: ie, el: me, anchor: Te, transition: Ie } = j;
    if (ie === Vn) {
      Cn(me, Te);
      return;
    }
    if (ie === la) {
      G(j);
      return;
    }
    const be = () => {
      s(me), Ie && !Ie.persisted && Ie.afterLeave && Ie.afterLeave();
    };
    if (j.shapeFlag & 1 && Ie && !Ie.persisted) {
      const { leave: Ne, delayLeave: Ee } = Ie, Oe = () => Ne(me, be);
      Ee ? Ee(j.el, be, Oe) : Oe();
    } else
      be();
  }, Cn = (j, ie) => {
    let me;
    for (; j !== ie; )
      me = P(j), s(j), j = me;
    s(ie);
  }, xn = (j, ie, me) => {
    const { bum: Te, scope: Ie, job: be, subTree: Ne, um: Ee, m: Oe, a: qe } = j;
    mc(Oe), mc(qe), Te && Ta(Te), Ie.stop(), be && (be.flags |= 8, ze(Ne, j, ie, me)), Ee && pl(Ee, ie), pl(() => {
      j.isUnmounted = !0;
    }, ie);
  }, ln = (j, ie, me, Te = !1, Ie = !1, be = 0) => {
    for (let Ne = be; Ne < j.length; Ne++)
      ze(j[Ne], ie, me, Te, Ie);
  }, k = (j) => {
    if (j.shapeFlag & 6)
      return k(j.component.subTree);
    if (j.shapeFlag & 128)
      return j.suspense.next();
    const ie = P(j.anchor || j.el), me = ie && ie[eh];
    return me ? P(me) : ie;
  };
  let _ = !1;
  const B = (j, ie, me) => {
    j == null ? ie._vnode && ze(ie._vnode, null, null, !0) : V(
      ie._vnode || null,
      j,
      ie,
      null,
      null,
      null,
      me
    ), ie._vnode = j, _ || (_ = !0, Ef(), sc(), _ = !1);
  }, le = {
    p: V,
    um: ze,
    m: $e,
    r: cn,
    mt: he,
    mc: fe,
    pc: de,
    pbc: oe,
    n: k,
    o: e
  };
  let Xe, De;
  return l && ([Xe, De] = l(
    le
  )), {
    render: B,
    hydrate: Xe,
    createApp: Cy(B, Xe)
  };
}
function Lo({ type: e, props: l }, i) {
  return i === "svg" && e === "foreignObject" || i === "mathml" && e === "annotation-xml" && l && l.encoding && l.encoding.includes("html") ? void 0 : i;
}
function $u({ effect: e, job: l }, i) {
  i ? (e.flags |= 32, l.flags |= 4) : (e.flags &= -33, l.flags &= -5);
}
function Eh(e, l) {
  return (!e || e && !e.pendingBranch) && l && !l.persisted;
}
function tf(e, l, i = !1) {
  const a = e.children, s = l.children;
  if (We(a) && We(s))
    for (let o = 0; o < a.length; o++) {
      const f = a[o];
      let d = s[o];
      d.shapeFlag & 1 && !d.dynamicChildren && ((d.patchFlag <= 0 || d.patchFlag === 32) && (d = s[o] = Eu(s[o]), d.el = f.el), !i && d.patchFlag !== -2 && tf(f, d)), d.type === ku && // avoid cached text nodes retaining detached dom nodes
      d.patchFlag !== -1 && (d.el = f.el), d.type === il && !d.el && (d.el = f.el);
    }
}
function _y(e) {
  const l = e.slice(), i = [0];
  let a, s, o, f, d;
  const h = e.length;
  for (a = 0; a < h; a++) {
    const I = e[a];
    if (I !== 0) {
      if (s = i[i.length - 1], e[s] < I) {
        l[a] = s, i.push(a);
        continue;
      }
      for (o = 0, f = i.length - 1; o < f; )
        d = o + f >> 1, e[i[d]] < I ? o = d + 1 : f = d;
      I < e[i[o]] && (o > 0 && (l[a] = i[o - 1]), i[o] = a);
    }
  }
  for (o = i.length, f = i[o - 1]; o-- > 0; )
    i[o] = f, f = l[f];
  return i;
}
function _h(e) {
  const l = e.subTree.component;
  if (l)
    return l.asyncDep && !l.asyncResolved ? l : _h(l);
}
function mc(e) {
  if (e)
    for (let l = 0; l < e.length; l++)
      e[l].flags |= 8;
}
const Nh = Symbol.for("v-scx"), Fh = () => Ei(Nh);
function Nl(e, l) {
  return vs(e, null, l);
}
function uf(e, l) {
  return vs(
    e,
    null,
    { flush: "post" }
  );
}
function af(e, l) {
  return vs(
    e,
    null,
    { flush: "sync" }
  );
}
function Sn(e, l, i) {
  return vs(e, l, i);
}
function vs(e, l, i = On) {
  const { immediate: a, deep: s, flush: o, once: f } = i, d = Mn({}, i), h = l && a || !l && o !== "post";
  let I;
  if (_a) {
    if (o === "sync") {
      const E = Fh();
      I = E.__watcherHandles || (E.__watcherHandles = []);
    } else if (!h) {
      const E = () => {
      };
      return E.stop = Dt, E.resume = Dt, E.pause = Dt, E;
    }
  }
  const x = Pl;
  d.call = (E, R, V) => bt(E, x, R, V);
  let y = !1;
  o === "post" ? d.scheduler = (E) => {
    pl(E, x && x.suspense);
  } : o !== "sync" && (y = !0, d.scheduler = (E, R) => {
    R ? E() : zm(E);
  }), d.augmentJob = (E) => {
    l && (E.flags |= 4), y && (E.flags |= 2, x && (E.id = x.uid, E.i = x));
  };
  const P = Sx(e, l, d);
  return _a && (I ? I.push(P) : h && P()), P;
}
function Ny(e, l, i) {
  const a = this.proxy, s = Wn(e) ? e.includes(".") ? Mh(a, e) : () => a[e] : e.bind(a, a);
  let o;
  sn(l) ? o = l : (o = l.handler, i = l);
  const f = ia(this), d = vs(s, o.bind(a), i);
  return f(), d;
}
function Mh(e, l) {
  const i = l.split(".");
  return () => {
    let a = e;
    for (let s = 0; s < i.length && a; s++)
      a = a[i[s]];
    return a;
  };
}
function Fy(e, l, i = On) {
  const a = Yn(), s = hl(l), o = dt(l), f = kh(e, s), d = Ga((h, I) => {
    let x, y = On, P;
    return af(() => {
      const E = e[s];
      Ml(x, E) && (x = E, I());
    }), {
      get() {
        return h(), i.get ? i.get(x) : x;
      },
      set(E) {
        const R = i.set ? i.set(E) : E;
        if (!Ml(R, x) && !(y !== On && Ml(E, y)))
          return;
        const V = a.vnode.props;
        V && // check if parent has passed v-model
        (l in V || s in V || o in V) && (`onUpdate:${l}` in V || `onUpdate:${s}` in V || `onUpdate:${o}` in V) || (x = E, I()), a.emit(`update:${l}`, R), Ml(E, R) && Ml(E, y) && !Ml(R, P) && I(), y = E, P = R;
      }
    };
  });
  return d[Symbol.iterator] = () => {
    let h = 0;
    return {
      next() {
        return h < 2 ? { value: h++ ? f || On : d, done: !1 } : { done: !0 };
      }
    };
  }, d;
}
const kh = (e, l) => l === "modelValue" || l === "model-value" ? e.modelModifiers : e[`${l}Modifiers`] || e[`${hl(l)}Modifiers`] || e[`${dt(l)}Modifiers`];
function My(e, l, ...i) {
  if (e.isUnmounted) return;
  const a = e.vnode.props || On;
  let s = i;
  const o = l.startsWith("update:"), f = o && kh(a, l.slice(7));
  f && (f.trim && (s = i.map((x) => Wn(x) ? x.trim() : x)), f.number && (s = i.map(lc)));
  let d, h = a[d = Ca(l)] || // also try camelCase event handler (#2249)
  a[d = Ca(hl(l))];
  !h && o && (h = a[d = Ca(dt(l))]), h && bt(
    h,
    e,
    6,
    s
  );
  const I = a[d + "Once"];
  if (I) {
    if (!e.emitted)
      e.emitted = {};
    else if (e.emitted[d])
      return;
    e.emitted[d] = !0, bt(
      I,
      e,
      6,
      s
    );
  }
}
const ky = /* @__PURE__ */ new WeakMap();
function Vh(e, l, i = !1) {
  const a = i ? ky : l.emitsCache, s = a.get(e);
  if (s !== void 0)
    return s;
  const o = e.emits;
  let f = {}, d = !1;
  if (!sn(e)) {
    const h = (I) => {
      const x = Vh(I, l, !0);
      x && (d = !0, Mn(f, x));
    };
    !i && l.mixins.length && l.mixins.forEach(h), e.extends && h(e.extends), e.mixins && e.mixins.forEach(h);
  }
  return !o && !d ? (_n(e) && a.set(e, null), null) : (We(o) ? o.forEach((h) => f[h] = null) : Mn(f, o), _n(e) && a.set(e, f), f);
}
function jc(e, l) {
  return !e || !os(l) ? !1 : (l = l.slice(2).replace(/Once$/, ""), qn(e, l[0].toLowerCase() + l.slice(1)) || qn(e, dt(l)) || qn(e, l));
}
function Ws(e) {
  const {
    type: l,
    vnode: i,
    proxy: a,
    withProxy: s,
    propsOptions: [o],
    slots: f,
    attrs: d,
    emit: h,
    render: I,
    renderCache: x,
    props: y,
    data: P,
    setupState: E,
    ctx: R,
    inheritAttrs: V
  } = e, K = es(e);
  let $, Q;
  try {
    if (i.shapeFlag & 4) {
      const G = s || a, Y = G;
      $ = ft(
        I.call(
          Y,
          G,
          x,
          y,
          E,
          P,
          R
        )
      ), Q = d;
    } else {
      const G = l;
      $ = ft(
        G.length > 1 ? G(
          y,
          { attrs: d, slots: f, emit: h }
        ) : G(
          y,
          null
        )
      ), Q = l.props ? d : By(d);
    }
  } catch (G) {
    Ur.length = 0, sa(G, e, 1), $ = Ye(il);
  }
  let Z = $;
  if (Q && V !== !1) {
    const G = Object.keys(Q), { shapeFlag: Y } = Z;
    G.length && Y & 7 && (o && G.some(Fm) && (Q = Zy(
      Q,
      o
    )), Z = fi(Z, Q, !1, !0));
  }
  return i.dirs && (Z = fi(Z, null, !1, !0), Z.dirs = Z.dirs ? Z.dirs.concat(i.dirs) : i.dirs), i.transition && Vi(Z, i.transition), $ = Z, es(K), $;
}
function Vy(e, l = !0) {
  let i;
  for (let a = 0; a < e.length; a++) {
    const s = e[a];
    if (Bi(s)) {
      if (s.type !== il || s.children === "v-if") {
        if (i)
          return;
        i = s;
      }
    } else
      return;
  }
  return i;
}
const By = (e) => {
  let l;
  for (const i in e)
    (i === "class" || i === "style" || os(i)) && ((l || (l = {}))[i] = e[i]);
  return l;
}, Zy = (e, l) => {
  const i = {};
  for (const a in e)
    (!Fm(a) || !(a.slice(9) in l)) && (i[a] = e[a]);
  return i;
};
function Uy(e, l, i) {
  const { props: a, children: s, component: o } = e, { props: f, children: d, patchFlag: h } = l, I = o.emitsOptions;
  if (l.dirs || l.transition)
    return !0;
  if (i && h >= 0) {
    if (h & 1024)
      return !0;
    if (h & 16)
      return a ? jf(a, f, I) : !!f;
    if (h & 8) {
      const x = l.dynamicProps;
      for (let y = 0; y < x.length; y++) {
        const P = x[y];
        if (f[P] !== a[P] && !jc(I, P))
          return !0;
      }
    }
  } else
    return (s || d) && (!d || !d.$stable) ? !0 : a === f ? !1 : a ? f ? jf(a, f, I) : !0 : !!f;
  return !1;
}
function jf(e, l, i) {
  const a = Object.keys(l);
  if (a.length !== Object.keys(e).length)
    return !0;
  for (let s = 0; s < a.length; s++) {
    const o = a[s];
    if (l[o] !== e[o] && !jc(i, o))
      return !0;
  }
  return !1;
}
function Hc({ vnode: e, parent: l }, i) {
  for (; l; ) {
    const a = l.subTree;
    if (a.suspense && a.suspense.activeBranch === e && (a.el = e.el), a === e)
      (e = l.vnode).el = i, l = l.parent;
    else
      break;
  }
}
const fc = (e) => e.__isSuspense;
let am = 0;
const Ky = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: !0,
  process(e, l, i, a, s, o, f, d, h, I) {
    if (e == null)
      zy(
        l,
        i,
        a,
        s,
        o,
        f,
        d,
        h,
        I
      );
    else {
      if (o && o.deps > 0 && !e.suspense.isInFallback) {
        l.suspense = e.suspense, l.suspense.vnode = l, l.el = e.el;
        return;
      }
      jy(
        e,
        l,
        i,
        a,
        s,
        f,
        d,
        h,
        I
      );
    }
  },
  hydrate: Hy,
  normalize: $y
}, Gy = Ky;
function ls(e, l) {
  const i = e.props && e.props[l];
  sn(i) && i();
}
function zy(e, l, i, a, s, o, f, d, h) {
  const {
    p: I,
    o: { createElement: x }
  } = h, y = x("div"), P = e.suspense = Bh(
    e,
    s,
    a,
    l,
    y,
    i,
    o,
    f,
    d,
    h
  );
  I(
    null,
    P.pendingBranch = e.ssContent,
    y,
    null,
    a,
    P,
    o,
    f
  ), P.deps > 0 ? (ls(e, "onPending"), ls(e, "onFallback"), I(
    null,
    e.ssFallback,
    l,
    i,
    a,
    null,
    // fallback tree will not have suspense context
    o,
    f
  ), Ra(P, e.ssFallback)) : P.resolve(!1, !0);
}
function jy(e, l, i, a, s, o, f, d, { p: h, um: I, o: { createElement: x } }) {
  const y = l.suspense = e.suspense;
  y.vnode = l, l.el = e.el;
  const P = l.ssContent, E = l.ssFallback, { activeBranch: R, pendingBranch: V, isInFallback: K, isHydrating: $ } = y;
  if (V)
    y.pendingBranch = P, ai(V, P) ? (h(
      V,
      P,
      y.hiddenContainer,
      null,
      s,
      y,
      o,
      f,
      d
    ), y.deps <= 0 ? y.resolve() : K && ($ || (h(
      R,
      E,
      i,
      a,
      s,
      null,
      // fallback tree will not have suspense context
      o,
      f,
      d
    ), Ra(y, E)))) : (y.pendingId = am++, $ ? (y.isHydrating = !1, y.activeBranch = V) : I(V, s, y), y.deps = 0, y.effects.length = 0, y.hiddenContainer = x("div"), K ? (h(
      null,
      P,
      y.hiddenContainer,
      null,
      s,
      y,
      o,
      f,
      d
    ), y.deps <= 0 ? y.resolve() : (h(
      R,
      E,
      i,
      a,
      s,
      null,
      // fallback tree will not have suspense context
      o,
      f,
      d
    ), Ra(y, E))) : R && ai(R, P) ? (h(
      R,
      P,
      i,
      a,
      s,
      y,
      o,
      f,
      d
    ), y.resolve(!0)) : (h(
      null,
      P,
      y.hiddenContainer,
      null,
      s,
      y,
      o,
      f,
      d
    ), y.deps <= 0 && y.resolve()));
  else if (R && ai(R, P))
    h(
      R,
      P,
      i,
      a,
      s,
      y,
      o,
      f,
      d
    ), Ra(y, P);
  else if (ls(l, "onPending"), y.pendingBranch = P, P.shapeFlag & 512 ? y.pendingId = P.component.suspenseId : y.pendingId = am++, h(
    null,
    P,
    y.hiddenContainer,
    null,
    s,
    y,
    o,
    f,
    d
  ), y.deps <= 0)
    y.resolve();
  else {
    const { timeout: Q, pendingId: Z } = y;
    Q > 0 ? setTimeout(() => {
      y.pendingId === Z && y.fallback(E);
    }, Q) : Q === 0 && y.fallback(E);
  }
}
function Bh(e, l, i, a, s, o, f, d, h, I, x = !1) {
  const {
    p: y,
    m: P,
    um: E,
    n: R,
    o: { parentNode: V, remove: K }
  } = I;
  let $;
  const Q = Wy(e);
  Q && l && l.pendingBranch && ($ = l.pendingId, l.deps++);
  const Z = e.props ? tc(e.props.timeout) : void 0, G = o, Y = {
    vnode: e,
    parent: l,
    parentComponent: i,
    namespace: f,
    container: a,
    hiddenContainer: s,
    deps: 0,
    pendingId: am++,
    timeout: typeof Z == "number" ? Z : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !x,
    isHydrating: x,
    isUnmounted: !1,
    effects: [],
    resolve(se = !1, te = !1) {
      const {
        vnode: fe,
        activeBranch: M,
        pendingBranch: oe,
        pendingId: Le,
        effects: ae,
        parentComponent: ye,
        container: he
      } = Y;
      let Ce = !1;
      Y.isHydrating ? Y.isHydrating = !1 : se || (Ce = M && oe.transition && oe.transition.mode === "out-in", Ce && (M.transition.afterLeave = () => {
        Le === Y.pendingId && (P(
          oe,
          he,
          o === G ? R(M) : o,
          0
        ), Qr(ae));
      }), M && (V(M.el) === he && (o = R(M)), E(M, ye, Y, !0)), Ce || P(oe, he, o, 0)), Ra(Y, oe), Y.pendingBranch = null, Y.isInFallback = !1;
      let xe = Y.parent, ce = !1;
      for (; xe; ) {
        if (xe.pendingBranch) {
          xe.effects.push(...ae), ce = !0;
          break;
        }
        xe = xe.parent;
      }
      !ce && !Ce && Qr(ae), Y.effects = [], Q && l && l.pendingBranch && $ === l.pendingId && (l.deps--, l.deps === 0 && !te && l.resolve()), ls(fe, "onResolve");
    },
    fallback(se) {
      if (!Y.pendingBranch)
        return;
      const { vnode: te, activeBranch: fe, parentComponent: M, container: oe, namespace: Le } = Y;
      ls(te, "onFallback");
      const ae = R(fe), ye = () => {
        Y.isInFallback && (y(
          null,
          se,
          oe,
          ae,
          M,
          null,
          // fallback tree will not have suspense context
          Le,
          d,
          h
        ), Ra(Y, se));
      }, he = se.transition && se.transition.mode === "out-in";
      he && (fe.transition.afterLeave = ye), Y.isInFallback = !0, E(
        fe,
        M,
        null,
        // no suspense so unmount hooks fire now
        !0
        // shouldRemove
      ), he || ye();
    },
    move(se, te, fe) {
      Y.activeBranch && P(Y.activeBranch, se, te, fe), Y.container = se;
    },
    next() {
      return Y.activeBranch && R(Y.activeBranch);
    },
    registerDep(se, te, fe) {
      const M = !!Y.pendingBranch;
      M && Y.deps++;
      const oe = se.vnode.el;
      se.asyncDep.catch((Le) => {
        sa(Le, se, 0);
      }).then((Le) => {
        if (se.isUnmounted || Y.isUnmounted || Y.pendingId !== se.suspenseId)
          return;
        se.asyncResolved = !0;
        const { vnode: ae } = se;
        cm(se, Le, !1), oe && (ae.el = oe);
        const ye = !oe && se.subTree.el;
        te(
          se,
          ae,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          V(oe || se.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          oe ? null : R(se.subTree),
          Y,
          f,
          fe
        ), ye && K(ye), Hc(se, ae.el), M && --Y.deps === 0 && Y.resolve();
      });
    },
    unmount(se, te) {
      Y.isUnmounted = !0, Y.activeBranch && E(
        Y.activeBranch,
        i,
        se,
        te
      ), Y.pendingBranch && E(
        Y.pendingBranch,
        i,
        se,
        te
      );
    }
  };
  return Y;
}
function Hy(e, l, i, a, s, o, f, d, h) {
  const I = l.suspense = Bh(
    l,
    a,
    i,
    e.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    s,
    o,
    f,
    d,
    !0
  ), x = h(
    e,
    I.pendingBranch = l.ssContent,
    i,
    I,
    o,
    f
  );
  return I.deps === 0 && I.resolve(!1, !0), x;
}
function $y(e) {
  const { shapeFlag: l, children: i } = e, a = l & 32;
  e.ssContent = Hf(
    a ? i.default : i
  ), e.ssFallback = a ? Hf(i.fallback) : Ye(il);
}
function Hf(e) {
  let l;
  if (sn(e)) {
    const i = ta && e._c;
    i && (e._d = !1, tn()), e = e(), i && (e._d = !0, l = _l, Uh());
  }
  return We(e) && (e = Vy(e)), e = ft(e), l && !e.dynamicChildren && (e.dynamicChildren = l.filter((i) => i !== e)), e;
}
function Zh(e, l) {
  l && l.pendingBranch ? We(e) ? l.effects.push(...e) : l.effects.push(e) : Qr(e);
}
function Ra(e, l) {
  e.activeBranch = l;
  const { vnode: i, parentComponent: a } = e;
  let s = l.el;
  for (; !s && l.component; )
    l = l.component.subTree, s = l.el;
  i.el = s, a && a.subTree === i && (a.vnode.el = s, Hc(a, s));
}
function Wy(e) {
  const l = e.props && e.props.suspensible;
  return l != null && l !== !1;
}
const Vn = Symbol.for("v-fgt"), ku = Symbol.for("v-txt"), il = Symbol.for("v-cmt"), la = Symbol.for("v-stc"), Ur = [];
let _l = null;
function tn(e = !1) {
  Ur.push(_l = e ? null : []);
}
function Uh() {
  Ur.pop(), _l = Ur[Ur.length - 1] || null;
}
let ta = 1;
function ts(e, l = !1) {
  ta += e, e < 0 && _l && l && (_l.hasOnce = !0);
}
function Kh(e) {
  return e.dynamicChildren = ta > 0 ? _l || wa : null, Uh(), ta > 0 && _l && _l.push(e), e;
}
function Bl(e, l, i, a, s, o) {
  return Kh(
    hn(
      e,
      l,
      i,
      a,
      s,
      o,
      !0
    )
  );
}
function vn(e, l, i, a, s) {
  return Kh(
    Ye(
      e,
      l,
      i,
      a,
      s,
      !0
    )
  );
}
function Bi(e) {
  return e ? e.__v_isVNode === !0 : !1;
}
function ai(e, l) {
  return e.type === l.type && e.key === l.key;
}
function Yy(e) {
}
const Gh = ({ key: e }) => e ?? null, Ys = ({
  ref: e,
  ref_key: l,
  ref_for: i
}) => (typeof e == "number" && (e = "" + e), e != null ? Wn(e) || kn(e) || sn(e) ? { i: Rl, r: e, k: l, f: !!i } : e : null);
function hn(e, l = null, i = null, a = 0, s = null, o = e === Vn ? 0 : 1, f = !1, d = !1) {
  const h = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: l,
    key: l && Gh(l),
    ref: l && Ys(l),
    scopeId: Bc,
    slotScopeIds: null,
    children: i,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: a,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: Rl
  };
  return d ? (sf(h, i), o & 128 && e.normalize(h)) : i && (h.shapeFlag |= Wn(i) ? 8 : 16), ta > 0 && // avoid a block node from tracking itself
  !f && // has current parent block
  _l && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (h.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  h.patchFlag !== 32 && _l.push(h), h;
}
const Ye = Xy;
function Xy(e, l = null, i = null, a = 0, s = null, o = !1) {
  if ((!e || e === vh) && (e = il), Bi(e)) {
    const d = fi(
      e,
      l,
      !0
      /* mergeRef: true */
    );
    return i && sf(d, i), ta > 0 && !o && _l && (d.shapeFlag & 6 ? _l[_l.indexOf(e)] = d : _l.push(d)), d.patchFlag = -2, d;
  }
  if (uI(e) && (e = e.__vccOpts), l) {
    l = rf(l);
    let { class: d, style: h } = l;
    d && !Wn(d) && (l.class = mt(d)), _n(h) && (Vc(h) && !We(h) && (h = Mn({}, h)), l.style = Gi(h));
  }
  const f = Wn(e) ? 1 : fc(e) ? 128 : nh(e) ? 64 : _n(e) ? 4 : sn(e) ? 2 : 0;
  return hn(
    e,
    l,
    i,
    a,
    s,
    f,
    o,
    !0
  );
}
function rf(e) {
  return e ? Vc(e) || wh(e) ? Mn({}, e) : e : null;
}
function fi(e, l, i = !1, a = !1) {
  const { props: s, ref: o, patchFlag: f, children: d, transition: h } = e, I = l ? dl(s || {}, l) : s, x = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: I,
    key: I && Gh(I),
    ref: l && l.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      i && o ? We(o) ? o.concat(Ys(l)) : [o, Ys(l)] : Ys(l)
    ) : o,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: d,
    target: e.target,
    targetStart: e.targetStart,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: l && e.type !== Vn ? f === -1 ? 16 : f | 16 : f,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: h,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && fi(e.ssContent),
    ssFallback: e.ssFallback && fi(e.ssFallback),
    placeholder: e.placeholder,
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
  return h && a && Vi(
    x,
    h.clone(x)
  ), x;
}
function Bu(e = " ", l = 0) {
  return Ye(ku, null, e, l);
}
function Qy(e, l) {
  const i = Ye(la, null, e);
  return i.staticCount = l, i;
}
function Zi(e = "", l = !1) {
  return l ? (tn(), vn(il, null, e)) : Ye(il, null, e);
}
function ft(e) {
  return e == null || typeof e == "boolean" ? Ye(il) : We(e) ? Ye(
    Vn,
    null,
    // #3666, avoid reference pollution when reusing vnode
    e.slice()
  ) : Bi(e) ? Eu(e) : Ye(ku, null, String(e));
}
function Eu(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : fi(e);
}
function sf(e, l) {
  let i = 0;
  const { shapeFlag: a } = e;
  if (l == null)
    l = null;
  else if (We(l))
    i = 16;
  else if (typeof l == "object")
    if (a & 65) {
      const s = l.default;
      s && (s._c && (s._d = !1), sf(e, s()), s._c && (s._d = !0));
      return;
    } else {
      i = 32;
      const s = l._;
      !s && !wh(l) ? l._ctx = Rl : s === 3 && Rl && (Rl.slots._ === 1 ? l._ = 1 : (l._ = 2, e.patchFlag |= 1024));
    }
  else sn(l) ? (l = { default: l, _ctx: Rl }, i = 32) : (l = String(l), a & 64 ? (i = 16, l = [Bu(l)]) : i = 8);
  e.children = l, e.shapeFlag |= i;
}
function dl(...e) {
  const l = {};
  for (let i = 0; i < e.length; i++) {
    const a = e[i];
    for (const s in a)
      if (s === "class")
        l.class !== a.class && (l.class = mt([l.class, a.class]));
      else if (s === "style")
        l.style = Gi([l.style, a.style]);
      else if (os(s)) {
        const o = l[s], f = a[s];
        f && o !== f && !(We(o) && o.includes(f)) && (l[s] = o ? [].concat(o, f) : f);
      } else s !== "" && (l[s] = a[s]);
  }
  return l;
}
function ot(e, l, i, a = null) {
  bt(e, l, 7, [
    i,
    a
  ]);
}
const Jy = Lh();
let eI = 0;
function zh(e, l, i) {
  const a = e.type, s = (l ? l.appContext : e.appContext) || Jy, o = {
    uid: eI++,
    vnode: e,
    type: a,
    parent: l,
    appContext: s,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Bm(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: l ? l.provides : Object.create(s.provides),
    ids: l ? l.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Sh(a, s),
    emitsOptions: Vh(a, s),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: On,
    // inheritAttrs
    inheritAttrs: a.inheritAttrs,
    // state
    ctx: On,
    data: On,
    props: On,
    attrs: On,
    slots: On,
    refs: On,
    setupState: On,
    setupContext: null,
    // suspense related
    suspense: i,
    suspenseId: i ? i.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return o.ctx = { _: o }, o.root = l ? l.root : o, o.emit = My.bind(null, o), e.ce && e.ce(o), o;
}
let Pl = null;
const Yn = () => Pl || Rl;
let dc, rm;
{
  const e = Rc(), l = (i, a) => {
    let s;
    return (s = e[i]) || (s = e[i] = []), s.push(a), (o) => {
      s.length > 1 ? s.forEach((f) => f(o)) : s[0](o);
    };
  };
  dc = l(
    "__VUE_INSTANCE_SETTERS__",
    (i) => Pl = i
  ), rm = l(
    "__VUE_SSR_SETTERS__",
    (i) => _a = i
  );
}
const ia = (e) => {
  const l = Pl;
  return dc(e), e.scope.on(), () => {
    e.scope.off(), dc(l);
  };
}, sm = () => {
  Pl && Pl.scope.off(), dc(null);
};
function jh(e) {
  return e.vnode.shapeFlag & 4;
}
let _a = !1;
function Hh(e, l = !1, i = !1) {
  l && rm(l);
  const { props: a, children: s } = e.vnode, o = jh(e);
  Ty(e, a, o, l), Ay(e, s, i || l);
  const f = o ? nI(e, l) : void 0;
  return l && rm(!1), f;
}
function nI(e, l) {
  const i = e.type;
  e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = new Proxy(e.ctx, lm);
  const { setup: a } = i;
  if (a) {
    Ni();
    const s = e.setupContext = a.length > 1 ? Wh(e) : null, o = ia(e), f = za(
      a,
      e,
      0,
      [
        e.props,
        s
      ]
    ), d = km(f);
    if (Fi(), o(), (d || e.sp) && !Mu(e) && $m(e), d) {
      if (f.then(sm, sm), l)
        return f.then((h) => {
          cm(e, h, l);
        }).catch((h) => {
          sa(h, e, 0);
        });
      e.asyncDep = f;
    } else
      cm(e, f, l);
  } else
    $h(e, l);
}
function cm(e, l, i) {
  sn(l) ? e.type.__ssrInlineRender ? e.ssrRender = l : e.render = l : _n(l) && (e.setupState = Gm(l)), $h(e, i);
}
let pc, om;
function lI(e) {
  pc = e, om = (l) => {
    l.render._rc && (l.withProxy = new Proxy(l.ctx, sy));
  };
}
const tI = () => !pc;
function $h(e, l, i) {
  const a = e.type;
  if (!e.render) {
    if (!l && pc && !a.render) {
      const s = a.template || ef(e).template;
      if (s) {
        const { isCustomElement: o, compilerOptions: f } = e.appContext.config, { delimiters: d, compilerOptions: h } = a, I = Mn(
          Mn(
            {
              isCustomElement: o,
              delimiters: d
            },
            f
          ),
          h
        );
        a.render = pc(s, I);
      }
    }
    e.render = a.render || Dt, om && om(e);
  }
  {
    const s = ia(e);
    Ni();
    try {
      Ly(e);
    } finally {
      Fi(), s();
    }
  }
}
const iI = {
  get(e, l) {
    return El(e, "get", ""), e[l];
  }
};
function Wh(e) {
  const l = (i) => {
    e.exposed = i || {};
  };
  return {
    attrs: new Proxy(e.attrs, iI),
    slots: e.slots,
    emit: e.emit,
    expose: l
  };
}
function xs(e) {
  return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Gm(Ka(e.exposed)), {
    get(l, i) {
      if (i in l)
        return l[i];
      if (i in Zr)
        return Zr[i](e);
    },
    has(l, i) {
      return i in l || i in Zr;
    }
  })) : e.proxy;
}
function mm(e, l = !0) {
  return sn(e) ? e.displayName || e.name : e.name || l && e.__name;
}
function uI(e) {
  return sn(e) && "__vccOpts" in e;
}
const _e = (e, l) => Dx(e, l, _a);
function pt(e, l, i) {
  try {
    ts(-1);
    const a = arguments.length;
    return a === 2 ? _n(l) && !We(l) ? Bi(l) ? Ye(e, null, [l]) : Ye(e, l) : Ye(e, null, l) : (a > 3 ? i = Array.prototype.slice.call(arguments, 2) : a === 3 && Bi(i) && (i = [i]), Ye(e, l, i));
  } finally {
    ts(1);
  }
}
function aI() {
}
function Yh(e, l, i, a) {
  const s = i[a];
  if (s && Xh(s, e))
    return s;
  const o = l();
  return o.memo = e.slice(), o.cacheIndex = a, i[a] = o;
}
function Xh(e, l) {
  const i = e.memo;
  if (i.length != l.length)
    return !1;
  for (let a = 0; a < i.length; a++)
    if (Ml(i[a], l[a]))
      return !1;
  return ta > 0 && _l && _l.push(e), !0;
}
const Qh = "3.5.22", rI = Dt, sI = Rx, cI = Ia, oI = Jp, mI = {
  createComponentInstance: zh,
  setupComponent: Hh,
  renderComponentRoot: Ws,
  setCurrentRenderingInstance: es,
  isVNode: Bi,
  normalizeVNode: ft,
  getComponentPublicInstance: xs,
  ensureValidVNode: Jm,
  pushWarningContext: Cx,
  popWarningContext: Tx
}, fI = mI, dI = null, pI = null, hI = null;
let fm;
const $f = typeof window < "u" && window.trustedTypes;
if ($f)
  try {
    fm = /* @__PURE__ */ $f.createPolicy("vue", {
      createHTML: (e) => e
    });
  } catch {
  }
const Jh = fm ? (e) => fm.createHTML(e) : (e) => e, gI = "http://www.w3.org/2000/svg", vI = "http://www.w3.org/1998/Math/MathML", Ti = typeof document < "u" ? document : null, Wf = Ti && /* @__PURE__ */ Ti.createElement("template"), xI = {
  insert: (e, l, i) => {
    l.insertBefore(e, i || null);
  },
  remove: (e) => {
    const l = e.parentNode;
    l && l.removeChild(e);
  },
  createElement: (e, l, i, a) => {
    const s = l === "svg" ? Ti.createElementNS(gI, e) : l === "mathml" ? Ti.createElementNS(vI, e) : i ? Ti.createElement(e, { is: i }) : Ti.createElement(e);
    return e === "select" && a && a.multiple != null && s.setAttribute("multiple", a.multiple), s;
  },
  createText: (e) => Ti.createTextNode(e),
  createComment: (e) => Ti.createComment(e),
  setText: (e, l) => {
    e.nodeValue = l;
  },
  setElementText: (e, l) => {
    e.textContent = l;
  },
  parentNode: (e) => e.parentNode,
  nextSibling: (e) => e.nextSibling,
  querySelector: (e) => Ti.querySelector(e),
  setScopeId(e, l) {
    e.setAttribute(l, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(e, l, i, a, s, o) {
    const f = i ? i.previousSibling : l.lastChild;
    if (s && (s === o || s.nextSibling))
      for (; l.insertBefore(s.cloneNode(!0), i), !(s === o || !(s = s.nextSibling)); )
        ;
    else {
      Wf.innerHTML = Jh(
        a === "svg" ? `<svg>${e}</svg>` : a === "mathml" ? `<math>${e}</math>` : e
      );
      const d = Wf.content;
      if (a === "svg" || a === "mathml") {
        const h = d.firstChild;
        for (; h.firstChild; )
          d.appendChild(h.firstChild);
        d.removeChild(h);
      }
      l.insertBefore(d, i);
    }
    return [
      // first
      f ? f.nextSibling : l.firstChild,
      // last
      i ? i.previousSibling : l.lastChild
    ];
  }
}, wu = "transition", Dr = "animation", Na = Symbol("_vtc"), eg = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, ng = /* @__PURE__ */ Mn(
  {},
  Hm,
  eg
), yI = (e) => (e.displayName = "Transition", e.props = ng, e), II = /* @__PURE__ */ yI(
  (e, { slots: l }) => pt(ah, lg(e), l)
), Wu = (e, l = []) => {
  We(e) ? e.forEach((i) => i(...l)) : e && e(...l);
}, Yf = (e) => e ? We(e) ? e.some((l) => l.length > 1) : e.length > 1 : !1;
function lg(e) {
  const l = {};
  for (const ae in e)
    ae in eg || (l[ae] = e[ae]);
  if (e.css === !1)
    return l;
  const {
    name: i = "v",
    type: a,
    duration: s,
    enterFromClass: o = `${i}-enter-from`,
    enterActiveClass: f = `${i}-enter-active`,
    enterToClass: d = `${i}-enter-to`,
    appearFromClass: h = o,
    appearActiveClass: I = f,
    appearToClass: x = d,
    leaveFromClass: y = `${i}-leave-from`,
    leaveActiveClass: P = `${i}-leave-active`,
    leaveToClass: E = `${i}-leave-to`
  } = e, R = LI(s), V = R && R[0], K = R && R[1], {
    onBeforeEnter: $,
    onEnter: Q,
    onEnterCancelled: Z,
    onLeave: G,
    onLeaveCancelled: Y,
    onBeforeAppear: se = $,
    onAppear: te = Q,
    onAppearCancelled: fe = Z
  } = l, M = (ae, ye, he, Ce) => {
    ae._enterCancelled = Ce, Tu(ae, ye ? x : d), Tu(ae, ye ? I : f), he && he();
  }, oe = (ae, ye) => {
    ae._isLeaving = !1, Tu(ae, y), Tu(ae, E), Tu(ae, P), ye && ye();
  }, Le = (ae) => (ye, he) => {
    const Ce = ae ? te : Q, xe = () => M(ye, ae, he);
    Wu(Ce, [ye, xe]), Xf(() => {
      Tu(ye, ae ? h : o), vi(ye, ae ? x : d), Yf(Ce) || Qf(ye, a, V, xe);
    });
  };
  return Mn(l, {
    onBeforeEnter(ae) {
      Wu($, [ae]), vi(ae, o), vi(ae, f);
    },
    onBeforeAppear(ae) {
      Wu(se, [ae]), vi(ae, h), vi(ae, I);
    },
    onEnter: Le(!1),
    onAppear: Le(!0),
    onLeave(ae, ye) {
      ae._isLeaving = !0;
      const he = () => oe(ae, ye);
      vi(ae, y), ae._enterCancelled ? (vi(ae, P), dm(ae)) : (dm(ae), vi(ae, P)), Xf(() => {
        ae._isLeaving && (Tu(ae, y), vi(ae, E), Yf(G) || Qf(ae, a, K, he));
      }), Wu(G, [ae, he]);
    },
    onEnterCancelled(ae) {
      M(ae, !1, void 0, !0), Wu(Z, [ae]);
    },
    onAppearCancelled(ae) {
      M(ae, !0, void 0, !0), Wu(fe, [ae]);
    },
    onLeaveCancelled(ae) {
      oe(ae), Wu(Y, [ae]);
    }
  });
}
function LI(e) {
  if (e == null)
    return null;
  if (_n(e))
    return [Do(e.enter), Do(e.leave)];
  {
    const l = Do(e);
    return [l, l];
  }
}
function Do(e) {
  return tc(e);
}
function vi(e, l) {
  l.split(/\s+/).forEach((i) => i && e.classList.add(i)), (e[Na] || (e[Na] = /* @__PURE__ */ new Set())).add(l);
}
function Tu(e, l) {
  l.split(/\s+/).forEach((a) => a && e.classList.remove(a));
  const i = e[Na];
  i && (i.delete(l), i.size || (e[Na] = void 0));
}
function Xf(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e);
  });
}
let DI = 0;
function Qf(e, l, i, a) {
  const s = e._endId = ++DI, o = () => {
    s === e._endId && a();
  };
  if (i != null)
    return setTimeout(o, i);
  const { type: f, timeout: d, propCount: h } = tg(e, l);
  if (!f)
    return a();
  const I = f + "end";
  let x = 0;
  const y = () => {
    e.removeEventListener(I, P), o();
  }, P = (E) => {
    E.target === e && ++x >= h && y();
  };
  setTimeout(() => {
    x < h && y();
  }, d + 1), e.addEventListener(I, P);
}
function tg(e, l) {
  const i = window.getComputedStyle(e), a = (R) => (i[R] || "").split(", "), s = a(`${wu}Delay`), o = a(`${wu}Duration`), f = Jf(s, o), d = a(`${Dr}Delay`), h = a(`${Dr}Duration`), I = Jf(d, h);
  let x = null, y = 0, P = 0;
  l === wu ? f > 0 && (x = wu, y = f, P = o.length) : l === Dr ? I > 0 && (x = Dr, y = I, P = h.length) : (y = Math.max(f, I), x = y > 0 ? f > I ? wu : Dr : null, P = x ? x === wu ? o.length : h.length : 0);
  const E = x === wu && /\b(?:transform|all)(?:,|$)/.test(
    a(`${wu}Property`).toString()
  );
  return {
    type: x,
    timeout: y,
    propCount: P,
    hasTransform: E
  };
}
function Jf(e, l) {
  for (; e.length < l.length; )
    e = e.concat(e);
  return Math.max(...l.map((i, a) => ed(i) + ed(e[a])));
}
function ed(e) {
  return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3;
}
function dm(e) {
  return (e ? e.ownerDocument : document).body.offsetHeight;
}
function OI(e, l, i) {
  const a = e[Na];
  a && (l = (l ? [l, ...a] : [...a]).join(" ")), l == null ? e.removeAttribute("class") : i ? e.setAttribute("class", l) : e.className = l;
}
const hc = Symbol("_vod"), ig = Symbol("_vsh"), ug = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(e, { value: l }, { transition: i }) {
    e[hc] = e.style.display === "none" ? "" : e.style.display, i && l ? i.beforeEnter(e) : Or(e, l);
  },
  mounted(e, { value: l }, { transition: i }) {
    i && l && i.enter(e);
  },
  updated(e, { value: l, oldValue: i }, { transition: a }) {
    !l != !i && (a ? l ? (a.beforeEnter(e), Or(e, !0), a.enter(e)) : a.leave(e, () => {
      Or(e, !1);
    }) : Or(e, l));
  },
  beforeUnmount(e, { value: l }) {
    Or(e, l);
  }
};
function Or(e, l) {
  e.style.display = l ? e[hc] : "none", e[ig] = !l;
}
function wI() {
  ug.getSSRProps = ({ value: e }) => {
    if (!e)
      return { style: { display: "none" } };
  };
}
const ag = Symbol("");
function bI(e) {
  const l = Yn();
  if (!l)
    return;
  const i = l.ut = (s = e(l.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${l.uid}"]`)
    ).forEach((o) => gc(o, s));
  }, a = () => {
    const s = e(l.proxy);
    l.ce ? gc(l.ce, s) : pm(l.subTree, s), i(s);
  };
  Ym(() => {
    Qr(a);
  }), vl(() => {
    Sn(a, Dt, { flush: "post" });
    const s = new MutationObserver(a);
    s.observe(l.subTree.el.parentNode, { childList: !0 }), St(() => s.disconnect());
  });
}
function pm(e, l) {
  if (e.shapeFlag & 128) {
    const i = e.suspense;
    e = i.activeBranch, i.pendingBranch && !i.isHydrating && i.effects.push(() => {
      pm(i.activeBranch, l);
    });
  }
  for (; e.component; )
    e = e.component.subTree;
  if (e.shapeFlag & 1 && e.el)
    gc(e.el, l);
  else if (e.type === Vn)
    e.children.forEach((i) => pm(i, l));
  else if (e.type === la) {
    let { el: i, anchor: a } = e;
    for (; i && (gc(i, l), i !== a); )
      i = i.nextSibling;
  }
}
function gc(e, l) {
  if (e.nodeType === 1) {
    const i = e.style;
    let a = "";
    for (const s in l) {
      const o = Hv(l[s]);
      i.setProperty(`--${s}`, o), a += `--${s}: ${o};`;
    }
    i[ag] = a;
  }
}
const SI = /(?:^|;)\s*display\s*:/;
function CI(e, l, i) {
  const a = e.style, s = Wn(i);
  let o = !1;
  if (i && !s) {
    if (l)
      if (Wn(l))
        for (const f of l.split(";")) {
          const d = f.slice(0, f.indexOf(":")).trim();
          i[d] == null && Xs(a, d, "");
        }
      else
        for (const f in l)
          i[f] == null && Xs(a, f, "");
    for (const f in i)
      f === "display" && (o = !0), Xs(a, f, i[f]);
  } else if (s) {
    if (l !== i) {
      const f = a[ag];
      f && (i += ";" + f), a.cssText = i, o = SI.test(i);
    }
  } else l && e.removeAttribute("style");
  hc in e && (e[hc] = o ? a.display : "", e[ig] && (a.display = "none"));
}
const nd = /\s*!important$/;
function Xs(e, l, i) {
  if (We(i))
    i.forEach((a) => Xs(e, l, a));
  else if (i == null && (i = ""), l.startsWith("--"))
    e.setProperty(l, i);
  else {
    const a = TI(e, l);
    nd.test(i) ? e.setProperty(
      dt(a),
      i.replace(nd, ""),
      "important"
    ) : e[a] = i;
  }
}
const ld = ["Webkit", "Moz", "ms"], Oo = {};
function TI(e, l) {
  const i = Oo[l];
  if (i)
    return i;
  let a = hl(l);
  if (a !== "filter" && a in e)
    return Oo[l] = a;
  a = ms(a);
  for (let s = 0; s < ld.length; s++) {
    const o = ld[s] + a;
    if (o in e)
      return Oo[l] = o;
  }
  return l;
}
const td = "http://www.w3.org/1999/xlink";
function id(e, l, i, a, s, o = zv(l)) {
  a && l.startsWith("xlink:") ? i == null ? e.removeAttributeNS(td, l.slice(6, l.length)) : e.setAttributeNS(td, l, i) : i == null || o && !Cp(i) ? e.removeAttribute(l) : e.setAttribute(
    l,
    o ? "" : mi(i) ? String(i) : i
  );
}
function ud(e, l, i, a, s) {
  if (l === "innerHTML" || l === "textContent") {
    i != null && (e[l] = l === "innerHTML" ? Jh(i) : i);
    return;
  }
  const o = e.tagName;
  if (l === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const d = o === "OPTION" ? e.getAttribute("value") || "" : e.value, h = i == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      e.type === "checkbox" ? "on" : ""
    ) : String(i);
    (d !== h || !("_value" in e)) && (e.value = h), i == null && e.removeAttribute(l), e._value = i;
    return;
  }
  let f = !1;
  if (i === "" || i == null) {
    const d = typeof e[l];
    d === "boolean" ? i = Cp(i) : i == null && d === "string" ? (i = "", f = !0) : d === "number" && (i = 0, f = !0);
  }
  try {
    e[l] = i;
  } catch {
  }
  f && e.removeAttribute(s || l);
}
function Ai(e, l, i, a) {
  e.addEventListener(l, i, a);
}
function qI(e, l, i, a) {
  e.removeEventListener(l, i, a);
}
const ad = Symbol("_vei");
function PI(e, l, i, a, s = null) {
  const o = e[ad] || (e[ad] = {}), f = o[l];
  if (a && f)
    f.value = a;
  else {
    const [d, h] = RI(l);
    if (a) {
      const I = o[l] = _I(
        a,
        s
      );
      Ai(e, d, I, h);
    } else f && (qI(e, d, f, h), o[l] = void 0);
  }
}
const rd = /(?:Once|Passive|Capture)$/;
function RI(e) {
  let l;
  if (rd.test(e)) {
    l = {};
    let a;
    for (; a = e.match(rd); )
      e = e.slice(0, e.length - a[0].length), l[a[0].toLowerCase()] = !0;
  }
  return [e[2] === ":" ? e.slice(3) : dt(e.slice(2)), l];
}
let wo = 0;
const AI = /* @__PURE__ */ Promise.resolve(), EI = () => wo || (AI.then(() => wo = 0), wo = Date.now());
function _I(e, l) {
  const i = (a) => {
    if (!a._vts)
      a._vts = Date.now();
    else if (a._vts <= i.attached)
      return;
    bt(
      NI(a, i.value),
      l,
      5,
      [a]
    );
  };
  return i.value = e, i.attached = EI(), i;
}
function NI(e, l) {
  if (We(l)) {
    const i = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      i.call(e), e._stopped = !0;
    }, l.map(
      (a) => (s) => !s._stopped && a && a(s)
    );
  } else
    return l;
}
const sd = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // lowercase letter
e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, FI = (e, l, i, a, s, o) => {
  const f = s === "svg";
  l === "class" ? OI(e, a, f) : l === "style" ? CI(e, i, a) : os(l) ? Fm(l) || PI(e, l, i, a, o) : (l[0] === "." ? (l = l.slice(1), !0) : l[0] === "^" ? (l = l.slice(1), !1) : MI(e, l, a, f)) ? (ud(e, l, a), !e.tagName.includes("-") && (l === "value" || l === "checked" || l === "selected") && id(e, l, a, f, o, l !== "value")) : /* #11081 force set props for possible async custom element */ e._isVueCE && (/[A-Z]/.test(l) || !Wn(a)) ? ud(e, hl(l), a, o, l) : (l === "true-value" ? e._trueValue = a : l === "false-value" && (e._falseValue = a), id(e, l, a, f));
};
function MI(e, l, i, a) {
  if (a)
    return !!(l === "innerHTML" || l === "textContent" || l in e && sd(l) && sn(i));
  if (l === "spellcheck" || l === "draggable" || l === "translate" || l === "autocorrect" || l === "form" || l === "list" && e.tagName === "INPUT" || l === "type" && e.tagName === "TEXTAREA")
    return !1;
  if (l === "width" || l === "height") {
    const s = e.tagName;
    if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE")
      return !1;
  }
  return sd(l) && Wn(i) ? !1 : l in e;
}
const cd = {};
// @__NO_SIDE_EFFECTS__
function rg(e, l, i) {
  let a = /* @__PURE__ */ fn(e, l);
  qc(a) && (a = Mn({}, a, l));
  class s extends $c {
    constructor(f) {
      super(a, f, i);
    }
  }
  return s.def = a, s;
}
const kI = /* @__NO_SIDE_EFFECTS__ */ (e, l) => /* @__PURE__ */ rg(e, l, yg), VI = typeof HTMLElement < "u" ? HTMLElement : class {
};
class $c extends VI {
  constructor(l, i = {}, a = yc) {
    super(), this._def = l, this._props = i, this._createApp = a, this._isVueCE = !0, this._instance = null, this._app = null, this._nonce = this._def.nonce, this._connected = !1, this._resolved = !1, this._numberProps = null, this._styleChildren = /* @__PURE__ */ new WeakSet(), this._ob = null, this.shadowRoot && a !== yc ? this._root = this.shadowRoot : l.shadowRoot !== !1 ? (this.attachShadow(
      Mn({}, l.shadowRootOptions, {
        mode: "open"
      })
    ), this._root = this.shadowRoot) : this._root = this;
  }
  connectedCallback() {
    if (!this.isConnected) return;
    !this.shadowRoot && !this._resolved && this._parseSlots(), this._connected = !0;
    let l = this;
    for (; l = l && (l.parentNode || l.host); )
      if (l instanceof $c) {
        this._parent = l;
        break;
      }
    this._instance || (this._resolved ? this._mount(this._def) : l && l._pendingResolve ? this._pendingResolve = l._pendingResolve.then(() => {
      this._pendingResolve = void 0, this._resolveDef();
    }) : this._resolveDef());
  }
  _setParent(l = this._parent) {
    l && (this._instance.parent = l._instance, this._inheritParentContext(l));
  }
  _inheritParentContext(l = this._parent) {
    l && this._app && Object.setPrototypeOf(
      this._app._context.provides,
      l._instance.provides
    );
  }
  disconnectedCallback() {
    this._connected = !1, tl(() => {
      this._connected || (this._ob && (this._ob.disconnect(), this._ob = null), this._app && this._app.unmount(), this._instance && (this._instance.ce = void 0), this._app = this._instance = null, this._teleportTargets && (this._teleportTargets.clear(), this._teleportTargets = void 0));
    });
  }
  _processMutations(l) {
    for (const i of l)
      this._setAttr(i.attributeName);
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    if (this._pendingResolve)
      return;
    for (let a = 0; a < this.attributes.length; a++)
      this._setAttr(this.attributes[a].name);
    this._ob = new MutationObserver(this._processMutations.bind(this)), this._ob.observe(this, { attributes: !0 });
    const l = (a, s = !1) => {
      this._resolved = !0, this._pendingResolve = void 0;
      const { props: o, styles: f } = a;
      let d;
      if (o && !We(o))
        for (const h in o) {
          const I = o[h];
          (I === Number || I && I.type === Number) && (h in this._props && (this._props[h] = tc(this._props[h])), (d || (d = /* @__PURE__ */ Object.create(null)))[hl(h)] = !0);
        }
      this._numberProps = d, this._resolveProps(a), this.shadowRoot && this._applyStyles(f), this._mount(a);
    }, i = this._def.__asyncLoader;
    i ? this._pendingResolve = i().then((a) => {
      a.configureApp = this._def.configureApp, l(this._def = a, !0);
    }) : l(this._def);
  }
  _mount(l) {
    this._app = this._createApp(l), this._inheritParentContext(), l.configureApp && l.configureApp(this._app), this._app._ceVNode = this._createVNode(), this._app.mount(this._root);
    const i = this._instance && this._instance.exposed;
    if (i)
      for (const a in i)
        qn(this, a) || Object.defineProperty(this, a, {
          // unwrap ref to be consistent with public instance behavior
          get: () => ue(i[a])
        });
  }
  _resolveProps(l) {
    const { props: i } = l, a = We(i) ? i : Object.keys(i || {});
    for (const s of Object.keys(this))
      s[0] !== "_" && a.includes(s) && this._setProp(s, this[s]);
    for (const s of a.map(hl))
      Object.defineProperty(this, s, {
        get() {
          return this._getProp(s);
        },
        set(o) {
          this._setProp(s, o, !0, !0);
        }
      });
  }
  _setAttr(l) {
    if (l.startsWith("data-v-")) return;
    const i = this.hasAttribute(l);
    let a = i ? this.getAttribute(l) : cd;
    const s = hl(l);
    i && this._numberProps && this._numberProps[s] && (a = tc(a)), this._setProp(s, a, !1, !0);
  }
  /**
   * @internal
   */
  _getProp(l) {
    return this._props[l];
  }
  /**
   * @internal
   */
  _setProp(l, i, a = !0, s = !1) {
    if (i !== this._props[l] && (i === cd ? delete this._props[l] : (this._props[l] = i, l === "key" && this._app && (this._app._ceVNode.key = i)), s && this._instance && this._update(), a)) {
      const o = this._ob;
      o && (this._processMutations(o.takeRecords()), o.disconnect()), i === !0 ? this.setAttribute(dt(l), "") : typeof i == "string" || typeof i == "number" ? this.setAttribute(dt(l), i + "") : i || this.removeAttribute(dt(l)), o && o.observe(this, { attributes: !0 });
    }
  }
  _update() {
    const l = this._createVNode();
    this._app && (l.appContext = this._app._context), xg(l, this._root);
  }
  _createVNode() {
    const l = {};
    this.shadowRoot || (l.onVnodeMounted = l.onVnodeUpdated = this._renderSlots.bind(this));
    const i = Ye(this._def, Mn(l, this._props));
    return this._instance || (i.ce = (a) => {
      this._instance = a, a.ce = this, a.isCE = !0;
      const s = (o, f) => {
        this.dispatchEvent(
          new CustomEvent(
            o,
            qc(f[0]) ? Mn({ detail: f }, f[0]) : { detail: f }
          )
        );
      };
      a.emit = (o, ...f) => {
        s(o, f), dt(o) !== o && s(dt(o), f);
      }, this._setParent();
    }), i;
  }
  _applyStyles(l, i) {
    if (!l) return;
    if (i) {
      if (i === this._def || this._styleChildren.has(i))
        return;
      this._styleChildren.add(i);
    }
    const a = this._nonce;
    for (let s = l.length - 1; s >= 0; s--) {
      const o = document.createElement("style");
      a && o.setAttribute("nonce", a), o.textContent = l[s], this.shadowRoot.prepend(o);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _parseSlots() {
    const l = this._slots = {};
    let i;
    for (; i = this.firstChild; ) {
      const a = i.nodeType === 1 && i.getAttribute("slot") || "default";
      (l[a] || (l[a] = [])).push(i), this.removeChild(i);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _renderSlots() {
    const l = this._getSlots(), i = this._instance.type.__scopeId;
    for (let a = 0; a < l.length; a++) {
      const s = l[a], o = s.getAttribute("name") || "default", f = this._slots[o], d = s.parentNode;
      if (f)
        for (const h of f) {
          if (i && h.nodeType === 1) {
            const I = i + "-s", x = document.createTreeWalker(h, 1);
            h.setAttribute(I, "");
            let y;
            for (; y = x.nextNode(); )
              y.setAttribute(I, "");
          }
          d.insertBefore(h, s);
        }
      else
        for (; s.firstChild; ) d.insertBefore(s.firstChild, s);
      d.removeChild(s);
    }
  }
  /**
   * @internal
   */
  _getSlots() {
    const l = [this];
    return this._teleportTargets && l.push(...this._teleportTargets), l.reduce((i, a) => (i.push(...Array.from(a.querySelectorAll("slot"))), i), []);
  }
  /**
   * @internal
   */
  _injectChildStyle(l) {
    this._applyStyles(l.styles, l);
  }
  /**
   * @internal
   */
  _removeChildStyle(l) {
  }
}
function sg(e) {
  const l = Yn(), i = l && l.ce;
  return i || null;
}
function BI() {
  const e = sg();
  return e && e.shadowRoot;
}
function ZI(e = "$style") {
  {
    const l = Yn();
    if (!l)
      return On;
    const i = l.type.__cssModules;
    if (!i)
      return On;
    const a = i[e];
    return a || On;
  }
}
const cg = /* @__PURE__ */ new WeakMap(), og = /* @__PURE__ */ new WeakMap(), vc = Symbol("_moveCb"), od = Symbol("_enterCb"), UI = (e) => (delete e.props.mode, e), KI = /* @__PURE__ */ UI({
  name: "TransitionGroup",
  props: /* @__PURE__ */ Mn({}, ng, {
    tag: String,
    moveClass: String
  }),
  setup(e, { slots: l }) {
    const i = Yn(), a = jm();
    let s, o;
    return Kc(() => {
      if (!s.length)
        return;
      const f = e.moveClass || `${e.name || "v"}-move`;
      if (!$I(
        s[0].el,
        i.vnode.el,
        f
      )) {
        s = [];
        return;
      }
      s.forEach(zI), s.forEach(jI);
      const d = s.filter(HI);
      dm(i.vnode.el), d.forEach((h) => {
        const I = h.el, x = I.style;
        vi(I, f), x.transform = x.webkitTransform = x.transitionDuration = "";
        const y = I[vc] = (P) => {
          P && P.target !== I || (!P || P.propertyName.endsWith("transform")) && (I.removeEventListener("transitionend", y), I[vc] = null, Tu(I, f));
        };
        I.addEventListener("transitionend", y);
      }), s = [];
    }), () => {
      const f = Ln(e), d = lg(f);
      let h = f.tag || Vn;
      if (s = [], o)
        for (let I = 0; I < o.length; I++) {
          const x = o[I];
          x.el && x.el instanceof Element && (s.push(x), Vi(
            x,
            Ea(
              x,
              d,
              a,
              i
            )
          ), cg.set(
            x,
            x.el.getBoundingClientRect()
          ));
        }
      o = l.default ? Zc(l.default()) : [];
      for (let I = 0; I < o.length; I++) {
        const x = o[I];
        x.key != null && Vi(
          x,
          Ea(x, d, a, i)
        );
      }
      return Ye(h, null, o);
    };
  }
}), GI = KI;
function zI(e) {
  const l = e.el;
  l[vc] && l[vc](), l[od] && l[od]();
}
function jI(e) {
  og.set(e, e.el.getBoundingClientRect());
}
function HI(e) {
  const l = cg.get(e), i = og.get(e), a = l.left - i.left, s = l.top - i.top;
  if (a || s) {
    const o = e.el.style;
    return o.transform = o.webkitTransform = `translate(${a}px,${s}px)`, o.transitionDuration = "0s", e;
  }
}
function $I(e, l, i) {
  const a = e.cloneNode(), s = e[Na];
  s && s.forEach((d) => {
    d.split(/\s+/).forEach((h) => h && a.classList.remove(h));
  }), i.split(/\s+/).forEach((d) => d && a.classList.add(d)), a.style.display = "none";
  const o = l.nodeType === 1 ? l : l.parentNode;
  o.appendChild(a);
  const { hasTransform: f } = tg(a);
  return o.removeChild(a), f;
}
const Zu = (e) => {
  const l = e.props["onUpdate:modelValue"] || !1;
  return We(l) ? (i) => Ta(l, i) : l;
};
function WI(e) {
  e.target.composing = !0;
}
function md(e) {
  const l = e.target;
  l.composing && (l.composing = !1, l.dispatchEvent(new Event("input")));
}
const Ot = Symbol("_assign"), xc = {
  created(e, { modifiers: { lazy: l, trim: i, number: a } }, s) {
    e[Ot] = Zu(s);
    const o = a || s.props && s.props.type === "number";
    Ai(e, l ? "change" : "input", (f) => {
      if (f.target.composing) return;
      let d = e.value;
      i && (d = d.trim()), o && (d = lc(d)), e[Ot](d);
    }), i && Ai(e, "change", () => {
      e.value = e.value.trim();
    }), l || (Ai(e, "compositionstart", WI), Ai(e, "compositionend", md), Ai(e, "change", md));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(e, { value: l }) {
    e.value = l ?? "";
  },
  beforeUpdate(e, { value: l, oldValue: i, modifiers: { lazy: a, trim: s, number: o } }, f) {
    if (e[Ot] = Zu(f), e.composing) return;
    const d = (o || e.type === "number") && !/^0\d/.test(e.value) ? lc(e.value) : e.value, h = l ?? "";
    d !== h && (document.activeElement === e && e.type !== "range" && (a && l === i || s && e.value.trim() === h) || (e.value = h));
  }
}, cf = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(e, l, i) {
    e[Ot] = Zu(i), Ai(e, "change", () => {
      const a = e._modelValue, s = Fa(e), o = e.checked, f = e[Ot];
      if (We(a)) {
        const d = Ec(a, s), h = d !== -1;
        if (o && !h)
          f(a.concat(s));
        else if (!o && h) {
          const I = [...a];
          I.splice(d, 1), f(I);
        }
      } else if (ra(a)) {
        const d = new Set(a);
        o ? d.add(s) : d.delete(s), f(d);
      } else
        f(fg(e, o));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: fd,
  beforeUpdate(e, l, i) {
    e[Ot] = Zu(i), fd(e, l, i);
  }
};
function fd(e, { value: l, oldValue: i }, a) {
  e._modelValue = l;
  let s;
  if (We(l))
    s = Ec(l, a.props.value) > -1;
  else if (ra(l))
    s = l.has(a.props.value);
  else {
    if (l === i) return;
    s = Vu(l, fg(e, !0));
  }
  e.checked !== s && (e.checked = s);
}
const of = {
  created(e, { value: l }, i) {
    e.checked = Vu(l, i.props.value), e[Ot] = Zu(i), Ai(e, "change", () => {
      e[Ot](Fa(e));
    });
  },
  beforeUpdate(e, { value: l, oldValue: i }, a) {
    e[Ot] = Zu(a), l !== i && (e.checked = Vu(l, a.props.value));
  }
}, mg = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(e, { value: l, modifiers: { number: i } }, a) {
    const s = ra(l);
    Ai(e, "change", () => {
      const o = Array.prototype.filter.call(e.options, (f) => f.selected).map(
        (f) => i ? lc(Fa(f)) : Fa(f)
      );
      e[Ot](
        e.multiple ? s ? new Set(o) : o : o[0]
      ), e._assigning = !0, tl(() => {
        e._assigning = !1;
      });
    }), e[Ot] = Zu(a);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(e, { value: l }) {
    dd(e, l);
  },
  beforeUpdate(e, l, i) {
    e[Ot] = Zu(i);
  },
  updated(e, { value: l }) {
    e._assigning || dd(e, l);
  }
};
function dd(e, l) {
  const i = e.multiple, a = We(l);
  if (!(i && !a && !ra(l))) {
    for (let s = 0, o = e.options.length; s < o; s++) {
      const f = e.options[s], d = Fa(f);
      if (i)
        if (a) {
          const h = typeof d;
          h === "string" || h === "number" ? f.selected = l.some((I) => String(I) === String(d)) : f.selected = Ec(l, d) > -1;
        } else
          f.selected = l.has(d);
      else if (Vu(Fa(f), l)) {
        e.selectedIndex !== s && (e.selectedIndex = s);
        return;
      }
    }
    !i && e.selectedIndex !== -1 && (e.selectedIndex = -1);
  }
}
function Fa(e) {
  return "_value" in e ? e._value : e.value;
}
function fg(e, l) {
  const i = l ? "_trueValue" : "_falseValue";
  return i in e ? e[i] : l;
}
const dg = {
  created(e, l, i) {
    Es(e, l, i, null, "created");
  },
  mounted(e, l, i) {
    Es(e, l, i, null, "mounted");
  },
  beforeUpdate(e, l, i, a) {
    Es(e, l, i, a, "beforeUpdate");
  },
  updated(e, l, i, a) {
    Es(e, l, i, a, "updated");
  }
};
function pg(e, l) {
  switch (e) {
    case "SELECT":
      return mg;
    case "TEXTAREA":
      return xc;
    default:
      switch (l) {
        case "checkbox":
          return cf;
        case "radio":
          return of;
        default:
          return xc;
      }
  }
}
function Es(e, l, i, a, s) {
  const f = pg(
    e.tagName,
    i.props && i.props.type
  )[s];
  f && f(e, l, i, a);
}
function YI() {
  xc.getSSRProps = ({ value: e }) => ({ value: e }), of.getSSRProps = ({ value: e }, l) => {
    if (l.props && Vu(l.props.value, e))
      return { checked: !0 };
  }, cf.getSSRProps = ({ value: e }, l) => {
    if (We(e)) {
      if (l.props && Ec(e, l.props.value) > -1)
        return { checked: !0 };
    } else if (ra(e)) {
      if (l.props && e.has(l.props.value))
        return { checked: !0 };
    } else if (e)
      return { checked: !0 };
  }, dg.getSSRProps = (e, l) => {
    if (typeof l.type != "string")
      return;
    const i = pg(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      l.type.toUpperCase(),
      l.props && l.props.type
    );
    if (i.getSSRProps)
      return i.getSSRProps(e, l);
  };
}
const XI = ["ctrl", "shift", "alt", "meta"], QI = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, l) => XI.some((i) => e[`${i}Key`] && !l.includes(i))
}, ri = (e, l) => {
  const i = e._withMods || (e._withMods = {}), a = l.join(".");
  return i[a] || (i[a] = (s, ...o) => {
    for (let f = 0; f < l.length; f++) {
      const d = QI[l[f]];
      if (d && d(s, l)) return;
    }
    return e(s, ...o);
  });
}, JI = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, oi = (e, l) => {
  const i = e._withKeys || (e._withKeys = {}), a = l.join(".");
  return i[a] || (i[a] = (s) => {
    if (!("key" in s))
      return;
    const o = dt(s.key);
    if (l.some(
      (f) => f === o || JI[f] === o
    ))
      return e(s);
  });
}, hg = /* @__PURE__ */ Mn({ patchProp: FI }, xI);
let Kr, pd = !1;
function gg() {
  return Kr || (Kr = Ph(hg));
}
function vg() {
  return Kr = pd ? Kr : Rh(hg), pd = !0, Kr;
}
const xg = (...e) => {
  gg().render(...e);
}, eL = (...e) => {
  vg().hydrate(...e);
}, yc = (...e) => {
  const l = gg().createApp(...e), { mount: i } = l;
  return l.mount = (a) => {
    const s = Lg(a);
    if (!s) return;
    const o = l._component;
    !sn(o) && !o.render && !o.template && (o.template = s.innerHTML), s.nodeType === 1 && (s.textContent = "");
    const f = i(s, !1, Ig(s));
    return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), f;
  }, l;
}, yg = (...e) => {
  const l = vg().createApp(...e), { mount: i } = l;
  return l.mount = (a) => {
    const s = Lg(a);
    if (s)
      return i(s, !0, Ig(s));
  }, l;
};
function Ig(e) {
  if (e instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement)
    return "mathml";
}
function Lg(e) {
  return Wn(e) ? document.querySelector(e) : e;
}
let hd = !1;
const nL = () => {
  hd || (hd = !0, YI(), wI());
};
const lL = () => {
}, tL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition: ah,
  BaseTransitionPropsValidators: Hm,
  Comment: il,
  DeprecationTypes: hI,
  EffectScope: Bm,
  ErrorCodes: Px,
  ErrorTypeStrings: sI,
  Fragment: Vn,
  KeepAlive: ny,
  ReactiveEffect: Wr,
  Static: la,
  Suspense: Gy,
  Teleport: Vx,
  Text: ku,
  TrackOpTypes: Ox,
  Transition: II,
  TransitionGroup: GI,
  TriggerOpTypes: wx,
  VueElement: $c,
  assertNumber: qx,
  callWithAsyncErrorHandling: bt,
  callWithErrorHandling: za,
  camelize: hl,
  capitalize: ms,
  cloneVNode: fi,
  compatUtils: pI,
  compile: lL,
  computed: _e,
  createApp: yc,
  createBlock: vn,
  createCommentVNode: Zi,
  createElementBlock: Bl,
  createElementVNode: hn,
  createHydrationRenderer: Rh,
  createPropsRestProxy: yy,
  createRenderer: Ph,
  createSSRApp: yg,
  createSlots: ay,
  createStaticVNode: Qy,
  createTextVNode: Bu,
  createVNode: Ye,
  customRef: Ga,
  defineAsyncComponent: Jx,
  defineComponent: fn,
  defineCustomElement: rg,
  defineEmits: oy,
  defineExpose: my,
  defineModel: py,
  defineOptions: fy,
  defineProps: cy,
  defineSSRCustomElement: kI,
  defineSlots: dy,
  devtools: cI,
  effect: Wv,
  effectScope: _c,
  getCurrentInstance: Yn,
  getCurrentScope: Hu,
  getCurrentWatcher: bx,
  getTransitionRawChildren: Zc,
  guardReactiveProps: rf,
  h: pt,
  handleError: sa,
  hasInjectionContext: zc,
  hydrate: eL,
  hydrateOnIdle: Hx,
  hydrateOnInteraction: Xx,
  hydrateOnMediaQuery: Yx,
  hydrateOnVisible: Wx,
  initCustomFormatter: aI,
  initDirectivesForSSR: nL,
  inject: Ei,
  isMemoSame: Xh,
  isProxy: Vc,
  isReactive: ci,
  isReadonly: ki,
  isRef: kn,
  isRuntimeOnly: tI,
  isShallow: yt,
  isVNode: Bi,
  markRaw: Ka,
  mergeDefaults: yh,
  mergeModels: xy,
  mergeProps: dl,
  nextTick: tl,
  normalizeClass: mt,
  normalizeProps: Ac,
  normalizeStyle: Gi,
  onActivated: ch,
  onBeforeMount: fh,
  onBeforeUnmount: ps,
  onBeforeUpdate: Ym,
  onDeactivated: oh,
  onErrorCaptured: gh,
  onMounted: vl,
  onRenderTracked: hh,
  onRenderTriggered: ph,
  onScopeDispose: Za,
  onServerPrefetch: dh,
  onUnmounted: St,
  onUpdated: Kc,
  onWatcherCleanup: $p,
  openBlock: tn,
  popScopeId: Nx,
  provide: Gc,
  proxyRefs: Gm,
  pushScopeId: _x,
  queuePostFlushCb: Qr,
  reactive: Ua,
  readonly: Mi,
  ref: Me,
  registerRuntimeCompiler: lI,
  render: xg,
  renderList: gs,
  renderSlot: Pn,
  resolveComponent: iy,
  resolveDirective: uy,
  resolveDynamicComponent: hs,
  resolveFilter: dI,
  resolveTransitionHooks: Ea,
  setBlockTracking: ts,
  setDevtoolsHook: oI,
  setTransitionHooks: Vi,
  shallowReactive: zp,
  shallowReadonly: Pu,
  shallowRef: Vl,
  ssrContextKey: Nh,
  ssrUtils: fI,
  stop: Yv,
  toDisplayString: xt,
  toHandlerKey: Ca,
  toHandlers: ry,
  toRaw: Ln,
  toRef: fs,
  toRefs: wt,
  toValue: pn,
  transformVNodeArgs: Yy,
  triggerRef: gx,
  unref: ue,
  useAttrs: vy,
  useCssModule: ZI,
  useCssVars: bI,
  useHost: sg,
  useId: sh,
  useModel: Fy,
  useSSRContext: Fh,
  useShadowRoot: BI,
  useSlots: gy,
  useTemplateRef: Wm,
  useTransitionState: jm,
  vModelCheckbox: cf,
  vModelDynamic: dg,
  vModelRadio: of,
  vModelSelect: mg,
  vModelText: xc,
  vShow: ug,
  version: Qh,
  warn: rI,
  watch: Sn,
  watchEffect: Nl,
  watchPostEffect: uf,
  watchSyncEffect: af,
  withAsyncContext: Iy,
  withCtx: nn,
  withDefaults: hy,
  withDirectives: Mx,
  withKeys: oi,
  withMemo: Yh,
  withModifiers: ri,
  withScopeId: Fx
}, Symbol.toStringTag, { value: "Module" }));
let Dg;
const Wc = (e) => Dg = e, Og = (
  /* istanbul ignore next */
  Symbol()
);
function hm(e) {
  return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function";
}
var Gr;
(function(e) {
  e.direct = "direct", e.patchObject = "patch object", e.patchFunction = "patch function";
})(Gr || (Gr = {}));
function iL() {
  const e = _c(!0), l = e.run(() => Me({}));
  let i = [], a = [];
  const s = Ka({
    install(o) {
      Wc(s), s._a = o, o.provide(Og, s), o.config.globalProperties.$pinia = s, a.forEach((f) => i.push(f)), a = [];
    },
    use(o) {
      return this._a ? i.push(o) : a.push(o), this;
    },
    _p: i,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: e,
    _s: /* @__PURE__ */ new Map(),
    state: l
  });
  return s;
}
const wg = () => {
};
function gd(e, l, i, a = wg) {
  e.add(l);
  const s = () => {
    e.delete(l) && a();
  };
  return !i && Hu() && Za(s), s;
}
function ha(e, ...l) {
  e.forEach((i) => {
    i(...l);
  });
}
const uL = (e) => e(), vd = Symbol(), bo = Symbol();
function gm(e, l) {
  e instanceof Map && l instanceof Map ? l.forEach((i, a) => e.set(a, i)) : e instanceof Set && l instanceof Set && l.forEach(e.add, e);
  for (const i in l) {
    if (!l.hasOwnProperty(i))
      continue;
    const a = l[i], s = e[i];
    hm(s) && hm(a) && e.hasOwnProperty(i) && !kn(a) && !ci(a) ? e[i] = gm(s, a) : e[i] = a;
  }
  return e;
}
const aL = (
  /* istanbul ignore next */
  Symbol()
);
function rL(e) {
  return !hm(e) || !Object.prototype.hasOwnProperty.call(e, aL);
}
const { assign: qu } = Object;
function sL(e) {
  return !!(kn(e) && e.effect);
}
function cL(e, l, i, a) {
  const { state: s, actions: o, getters: f } = l, d = i.state.value[e];
  let h;
  function I() {
    d || (i.state.value[e] = s ? s() : {});
    const x = wt(i.state.value[e]);
    return qu(x, o, Object.keys(f || {}).reduce((y, P) => (y[P] = Ka(_e(() => {
      Wc(i);
      const E = i._s.get(e);
      return f[P].call(E, E);
    })), y), {}));
  }
  return h = bg(e, I, l, i, a, !0), h;
}
function bg(e, l, i = {}, a, s, o) {
  let f;
  const d = qu({ actions: {} }, i), h = { deep: !0 };
  let I, x, y = /* @__PURE__ */ new Set(), P = /* @__PURE__ */ new Set(), E;
  const R = a.state.value[e];
  !o && !R && (a.state.value[e] = {}), Me({});
  let V;
  function K(fe) {
    let M;
    I = x = !1, typeof fe == "function" ? (fe(a.state.value[e]), M = {
      type: Gr.patchFunction,
      storeId: e,
      events: E
    }) : (gm(a.state.value[e], fe), M = {
      type: Gr.patchObject,
      payload: fe,
      storeId: e,
      events: E
    });
    const oe = V = Symbol();
    tl().then(() => {
      V === oe && (I = !0);
    }), x = !0, ha(y, M, a.state.value[e]);
  }
  const $ = o ? function() {
    const { state: M } = i, oe = M ? M() : {};
    this.$patch((Le) => {
      qu(Le, oe);
    });
  } : (
    /* istanbul ignore next */
    wg
  );
  function Q() {
    f.stop(), y.clear(), P.clear(), a._s.delete(e);
  }
  const Z = (fe, M = "") => {
    if (vd in fe)
      return fe[bo] = M, fe;
    const oe = function() {
      Wc(a);
      const Le = Array.from(arguments), ae = /* @__PURE__ */ new Set(), ye = /* @__PURE__ */ new Set();
      function he(ce) {
        ae.add(ce);
      }
      function Ce(ce) {
        ye.add(ce);
      }
      ha(P, {
        args: Le,
        name: oe[bo],
        store: Y,
        after: he,
        onError: Ce
      });
      let xe;
      try {
        xe = fe.apply(this && this.$id === e ? this : Y, Le);
      } catch (ce) {
        throw ha(ye, ce), ce;
      }
      return xe instanceof Promise ? xe.then((ce) => (ha(ae, ce), ce)).catch((ce) => (ha(ye, ce), Promise.reject(ce))) : (ha(ae, xe), xe);
    };
    return oe[vd] = !0, oe[bo] = M, oe;
  }, G = {
    _p: a,
    // _s: scope,
    $id: e,
    $onAction: gd.bind(null, P),
    $patch: K,
    $reset: $,
    $subscribe(fe, M = {}) {
      const oe = gd(y, fe, M.detached, () => Le()), Le = f.run(() => Sn(() => a.state.value[e], (ae) => {
        (M.flush === "sync" ? x : I) && fe({
          storeId: e,
          type: Gr.direct,
          events: E
        }, ae);
      }, qu({}, h, M)));
      return oe;
    },
    $dispose: Q
  }, Y = Ua(G);
  a._s.set(e, Y);
  const te = (a._a && a._a.runWithContext || uL)(() => a._e.run(() => (f = _c()).run(() => l({ action: Z }))));
  for (const fe in te) {
    const M = te[fe];
    if (kn(M) && !sL(M) || ci(M))
      o || (R && rL(M) && (kn(M) ? M.value = R[fe] : gm(M, R[fe])), a.state.value[e][fe] = M);
    else if (typeof M == "function") {
      const oe = Z(M, fe);
      te[fe] = oe, d.actions[fe] = M;
    }
  }
  return qu(Y, te), qu(Ln(Y), te), Object.defineProperty(Y, "$state", {
    get: () => a.state.value[e],
    set: (fe) => {
      K((M) => {
        qu(M, fe);
      });
    }
  }), a._p.forEach((fe) => {
    qu(Y, f.run(() => fe({
      store: Y,
      app: a._a,
      pinia: a,
      options: d
    })));
  }), R && o && i.hydrate && i.hydrate(Y.$state, R), I = !0, x = !0, Y;
}
// @__NO_SIDE_EFFECTS__
function Yc(e, l, i) {
  let a;
  const s = typeof l == "function";
  a = s ? i : l;
  function o(f, d) {
    const h = zc();
    return f = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    f || (h ? Ei(Og, null) : null), f && Wc(f), f = Dg, f._s.has(e) || (s ? bg(e, l, a, f) : cL(e, a, f)), f._s.get(e);
  }
  return o.$id = e, o;
}
function Oi(e) {
  const l = Ln(e), i = {};
  for (const a in l) {
    const s = l[a];
    s.effect ? i[a] = // ...
    _e({
      get: () => e[a],
      set(o) {
        e[a] = o;
      }
    }) : (kn(s) || ci(s)) && (i[a] = // ---
    fs(e, a));
  }
  return i;
}
const oL = {
  FunctionCategory: {
    tag: "FunctionCategory",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Category of functions. To be added to Process, Line, Substation, VoltageLevel and Bay SCL elements

Category of functions. To be added to Process, Line, Substation, VoltageLevel and Bay SCL elements`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SubCategory", "FunctionCatRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubCategory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FunctionCatRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProcessResources: {
    tag: "ProcessResources",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `List of Process Resources related to a function. to be added to the SCL elements Function, SubFunction, EqFunction and EqSubFunction

List of Process Resources related to a function. to be added to the SCL elements Function, SubFunction, EqFunction and EqSubFunction`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "ProcessResource"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessResource: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueResource",
              kind: "unique",
              paths: [["Resource"]],
              deep: !1,
              attributes: ["resInst"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniquePR",
        kind: "unique",
        paths: [["ProcessResource"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PowerSystemRelations: {
    tag: "PowerSystemRelations",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Functional relation from a Function/SubFunction to another element of the process

Functional relation from a Function/SubFunction to another element of the process`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "PowerSystemRelation"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        PowerSystemRelation: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniquePSR",
        kind: "unique",
        paths: [["PowerSystemRelation"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeInputs: {
    tag: "LNodeInputs",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `List of specification inputs of the given LNode. To be added at LNode level

List of specification inputs of the given LNode. To be added at LNode level`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SourceRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SourceRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueSourceRef",
        kind: "unique",
        paths: [["SourceRef"]],
        deep: !1,
        attributes: ["input", "inputInst", "pDA"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeOutputs: {
    tag: "LNodeOutputs",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `List of specification outputs of the given LNode. To be added at LNode level

List of specification outputs of the given LNode. To be added at LNode level`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "ControlRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ControlRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueControlRef",
        kind: "unique",
        paths: [["ControlRef"]],
        deep: !1,
        attributes: ["output", "outputInst"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProcessEcho: {
    tag: "ProcessEcho",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Definition of an echo LNode, mirroring the DO of another LNode

Definition of an echo LNode, mirroring the DO of another LNode`,
    parents: ["DAS", "DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "source", "sourceDaName", "sourceDoName", "sourceLNodeUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceDaName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceLNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeSpecNaming: {
    tag: "LNodeSpecNaming",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `LNode user specification. To be added to LNode SCL element

LNode user specification. To be added to LNode SCL element`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["sIedName", "sLdInst", "sLnClass", "sLnInst", "sPrefix"],
      details: {
        sIedName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "None",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sLdInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sLnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sLnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sPrefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DOS: {
    tag: "DOS",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Data Object specification. To be added to LNode SCL element

Data Object specification. To be added to LNode SCL element`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "mappedDoName", "mappedLnUuid", "name"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedLnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 12,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "SDS",
        "DAS",
        "SubscriberLNode",
        "ControllingLNode",
        "ProcessEcho",
        "LogParametersRef",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SDS: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueSDS_DASinSDS",
              kind: "unique",
              paths: [["DAS|.", "SDS"]],
              deep: !1,
              attributes: ["name", "ix"],
              refer: null,
              text: !1
            }
          ]
        },
        DAS: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubscriberLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ControllingLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessEcho: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDOS",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "SDS",
            "DAS",
            "SubscriberLNode",
            "ControllingLNode",
            "ProcessEcho",
            "LogParametersRef"
          ]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueSDS_DASinDOS",
        kind: "unique",
        paths: [["DAS|.", "SDS"]],
        deep: !1,
        attributes: ["name", "ix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionSclRef: {
    tag: "FunctionSclRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to the FSD files used to create a Function. Could be added under Function/SubFunction/EqFunction/EqSubFunction

Reference to the FSD files used to create a Function. Could be added under Function/SubFunction/EqFunction/EqSubFunction`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SclFileReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SclFileReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  CheckoutID: {
    tag: "CheckoutID",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Element used by an IED to indicates that a file has been imported to give engineering rights on this IED. This is opening a transaction between both projects to lock it on first project until the checkout is given back from current project, which then lock the IED locally

Element used by an IED to indicates that a file has been imported to give engineering rights on this IED. This is opening a transaction between both projects to lock it on first project until the checkout is given back from current project, which then lock the IED locally`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "desc",
        "engRight",
        "fileName",
        "fileType",
        "fileUuid",
        "headerId",
        "revision",
        "version",
        "when"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        engRight: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["full", "fix", "dataflow"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["SED", "SCC", "ICD", "IID", "CID", "SSD", "SCD"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        headerId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["SubCheckoutID"],
      details: {
        SubCheckoutID: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tSclFileUUIDCheckoutRestriction",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Variable: {
    tag: "Variable",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `A Variable is a way to define a global variable which can be modified by a user and applied to a list of SCL attributes

A Variable is a way to define a global variable which can be modified by a user and applied to a list of SCL attributes`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid", "value"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "VariableApplyTo"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        VariableApplyTo: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  CommunicationServiceSpecifications: {
    tag: "CommunicationServiceSpecifications",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `The CommunicationServiceSpecifications is containing parameters used to create control blocks during implementation

The CommunicationServiceSpecifications is containing parameters used to create control blocks during implementation`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "GooseParameters", "SMVParameters", "ReportParameters"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GooseParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["GooseParameters", "SMVParameters", "ReportParameters"]
        }
      ]
    },
    constraints: [
      {
        name: "commServiceSpecKey",
        kind: "key",
        paths: [["*"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ServiceSpecifications: {
    tag: "ServiceSpecifications",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `The ServiceSpecification is containing parameters used to create control blocks or physical interface (LPDI/LPDO) during implementation

The ServiceSpecification is containing parameters used to create control blocks or physical interface (LPDI/LPDO) during implementation`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "GooseParameters",
        "SMVParameters",
        "ReportParameters",
        "BinaryWiringParameters",
        "AnalogueWiringParameters",
        "LogParameters"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GooseParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        AnalogueWiringParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "GooseParameters",
            "SMVParameters",
            "ReportParameters",
            "BinaryWiringParameters",
            "AnalogueWiringParameters",
            "LogParameters"
          ]
        }
      ]
    },
    constraints: [
      {
        name: "serviceSpecKey",
        kind: "key",
        paths: [["*"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BayType: {
    tag: "BayType",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Bay type element is keeping value of the type. It's a free string

Bay type element is keeping value of the type. It's a free string`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tBayType",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AllocationRole: {
    tag: "AllocationRole",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Definition of an allocation role allowing definition of possible allocation to devices type without using virtual IED

Definition of an allocation role allowing definition of possible allocation to devices type without using virtual IED`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Application: {
    tag: "Application",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Application definition to be added at Process, Substation, Voltage Level or Bay level

Application definition to be added at Process, Substation, Voltage Level or Bay level`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "FunctionRole",
        "FunctionalVariant",
        "FunctionalVariantGroup",
        "AllocationRoleRef",
        "ApplicationSclRef"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionRole: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueRoleContent",
              kind: "unique",
              paths: [["FunctionRoleContent"]],
              deep: !1,
              attributes: ["roleInst"],
              refer: null,
              text: !1
            }
          ]
        },
        FunctionalVariant: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FunctionalVariantGroup: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        AllocationRoleRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ApplicationSclRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BehaviorDescription: {
    tag: "BehaviorDescription",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Element allowing to describe the behavior its parent (Application, Bay, Function, LN...)

Element allowing to describe the behavior its parent (Application, Bay, Function, LN...)`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "desc",
        "fileReference",
        "format",
        "isSimulation",
        "isSpecification",
        "name",
        "originUuid",
        "templateUuid",
        "uuid"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileReference: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        format: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["IEC 61131", "Textual", "Graphic"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        isSimulation: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        isSpecification: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "InputVar", "OutputVar", "BehaviorReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        InputVar: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        OutputVar: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        BehaviorReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInBehaviorDescription",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["varName"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Project: {
    tag: "Project",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Element allowing to define a project, to identify the project and the process elements defined by this project

Element allowing to define a project, to identify the project and the process elements defined by this project`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "ProjectProcessReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProjectProcessReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionTemplate: {
    tag: "FunctionTemplate",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Base element for FSD format, will be used as a template element for Function/SubFunction or EqFunction/EqSubFunction

Base element for FSD format, will be used as a template element for Function/SubFunction or EqFunction/EqSubFunction`,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "LNode", "SubFunctionTemplate", "GeneralEquipment", "ConductingEquipment"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SubFunctionTemplate: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInSubFuncTemplate",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGEFuncTemplate",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipmentOfFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInCondEqTemplate",
              kind: "unique",
              paths: [["SubEquipment|.", "EqFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "t6-100LNodeContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SCL: {
    tag: "SCL",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: [],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["release", "revision", "version"],
      details: {
        release: {
          required: !0,
          default: "5",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 255,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: "C",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z]", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: "2007",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["2[0-2][0-9]{2}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Header",
        "Substation",
        "Communication",
        "IED",
        "DataTypeTemplates",
        "Line",
        "Process"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Header: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueHitem",
              kind: "unique",
              paths: [["History", "Hitem"]],
              deep: !1,
              attributes: ["version", "revision"],
              refer: null,
              text: !1
            }
          ]
        },
        Substation: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Communication: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        IED: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DataTypeTemplates: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Line: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Process: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "SubstationKey",
        kind: "key",
        paths: [["Substation|.", "Process|.", "Line"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "IEDKey",
        kind: "key",
        paths: [["IED"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "LNodeTypeKey",
        kind: "key",
        paths: [["DataTypeTemplates", "LNodeType"]],
        deep: !1,
        attributes: ["id", "lnClass"],
        refer: null,
        text: !1
      },
      {
        name: "ConnectivityNodeKey",
        kind: "key",
        paths: [["ConnectivityNode"]],
        deep: !0,
        attributes: ["pathName"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueHitem",
        kind: "unique",
        paths: [["History", "Hitem"]],
        deep: !1,
        attributes: ["version", "revision"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueUUID",
        kind: "unique",
        paths: [["*"]],
        deep: !0,
        attributes: ["uuid"],
        refer: null,
        text: !1
      },
      {
        name: "ref2LNodeTypeDomain1",
        kind: "keyref",
        paths: [["IED", "AccessPoint", "LN"]],
        deep: !1,
        attributes: ["lnType", "lnClass"],
        refer: "LNodeTypeKey",
        text: !1
      },
      {
        name: "ref2LNodeTypeDomain2",
        kind: "keyref",
        paths: [["IED", "AccessPoint", "Server", "LDevice", "LN"]],
        deep: !1,
        attributes: ["lnType", "lnClass"],
        refer: "LNodeTypeKey",
        text: !1
      },
      {
        name: "ref2LNodeTypeLLN0",
        kind: "keyref",
        paths: [["IED", "AccessPoint", "Server", "LDevice", "LN0"]],
        deep: !1,
        attributes: ["lnType", "lnClass"],
        refer: "LNodeTypeKey",
        text: !1
      },
      {
        name: "refConnectedAP2IED",
        kind: "keyref",
        paths: [["Communication", "SubNetwork", "ConnectedAP"]],
        deep: !1,
        attributes: ["iedName"],
        refer: "IEDKey",
        text: !1
      },
      {
        name: "ref2SubstationFromTerminal",
        kind: "keyref",
        paths: [["Terminal"]],
        deep: !0,
        attributes: ["substationName"],
        refer: "scl:SubstationKey",
        text: !1
      }
    ],
    value: {
      type: "tBaseElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Substation: {
    tag: "Substation",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Process", "SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "PowerTransformer",
        "GeneralEquipment",
        "VoltageLevel",
        "Function"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        PowerTransformer: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInPowerTransformer",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTR",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        VoltageLevel: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueChildNameInVoltageLevel",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueLNodeInVoltageLevel",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunctionSS",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInSubstationFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInSubstation",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInSubstation",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Process: {
    tag: "Process",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Process", "SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "GeneralEquipment",
        "Function",
        "ConductingEquipment",
        "Substation",
        "Line",
        "Process"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment2",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE2",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFunction",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Substation: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueChildNameInProcessSubstation",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueLNodeInProcessSubstation",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Line: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Process: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueChildNameInSubProcess",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueLNodeInSubProcess",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInProcess",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInProcess",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tGeneralEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Line: {
    tag: "Line",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Process", "SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "nomFreq", "numPhases", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nomFreq: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: "0",
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        numPhases: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 255,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "GeneralEquipment",
        "Function",
        "Voltage",
        "ConductingEquipment",
        "ConnectivityNode"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment2",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE2",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFunction",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        Voltage: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConductingEquipment: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        },
        ConnectivityNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInLine",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInLine",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tGeneralEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LN0: {
    tag: "LN0",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["LDevice"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "inst", "lnClass", "lnType", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inst: {
          required: !0,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: "LLN0",
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "DataSet",
        "ReportControl",
        "LogControl",
        "DOI",
        "Inputs",
        "Outputs",
        "Log",
        "Labels",
        "GSEControl",
        "SampledValueControl",
        "SettingControl"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DataSet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ReportControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LogControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DOI: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueSDI_DAIinDOI",
              kind: "unique",
              paths: [["DAI|.", "SDI"]],
              deep: !1,
              attributes: ["name", "ix"],
              refer: null,
              text: !1
            }
          ]
        },
        Inputs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Outputs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Log: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLN",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        GSEControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SampledValueControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SettingControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "DataSetKeyLN0",
        kind: "key",
        paths: [["DataSet"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueReportControlInLN0",
        kind: "unique",
        paths: [["ReportControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLogControlInLN0",
        kind: "unique",
        paths: [["LogControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueGSEControlInLN0",
        kind: "unique",
        paths: [["GSEControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueSampledValueControlInLN0",
        kind: "unique",
        paths: [["SampledValueControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueDOIinLN0",
        kind: "unique",
        paths: [["DOI"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLogInLN0",
        kind: "unique",
        paths: [["Log"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "ref2DataSetReportLN0",
        kind: "keyref",
        paths: [["ReportControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyLN0",
        text: !1
      },
      {
        name: "ref2DataSetLogLN0",
        kind: "keyref",
        paths: [["LogControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyLN0",
        text: !1
      },
      {
        name: "ref2DataSetGSELN0",
        kind: "keyref",
        paths: [["GSEControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyLN0",
        text: !1
      },
      {
        name: "ref2DataSetSVLN0",
        kind: "keyref",
        paths: [["SampledValueControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyLN0",
        text: !1
      }
    ],
    value: {
      type: "tLN0",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LN: {
    tag: "LN",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["AccessPoint", "LDevice"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "inst", "lnClass", "lnType", "prefix", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "DataSet",
        "ReportControl",
        "LogControl",
        "DOI",
        "Inputs",
        "Outputs",
        "Log",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DataSet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ReportControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LogControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DOI: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueSDI_DAIinDOI",
              kind: "unique",
              paths: [["DAI|.", "SDI"]],
              deep: !1,
              attributes: ["name", "ix"],
              refer: null,
              text: !1
            }
          ]
        },
        Inputs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Outputs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Log: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLN",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "DataSetKeyInLN",
        kind: "key",
        paths: [["DataSet"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueReportControlInLN",
        kind: "unique",
        paths: [["ReportControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLogControlInLN",
        kind: "unique",
        paths: [["LogControl"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueDOIinLN",
        kind: "unique",
        paths: [["DOI"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLogInLN",
        kind: "unique",
        paths: [["Log"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "ref2DataSetReport",
        kind: "keyref",
        paths: [["ReportControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyInLN",
        text: !1
      },
      {
        name: "ref2DataSetLog",
        kind: "keyref",
        paths: [["LogControl"]],
        deep: !1,
        attributes: ["datSet"],
        refer: "DataSetKeyInLN",
        text: !1
      }
    ],
    value: {
      type: "tAnyLN",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  IED: {
    tag: "IED",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "configVersion",
        "desc",
        "engRight",
        "manufacturer",
        "name",
        "originalSclRelease",
        "originalSclRevision",
        "originalSclVersion",
        "owner",
        "templateUuid",
        "type",
        "uuid"
      ],
      details: {
        configVersion: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        engRight: {
          required: !1,
          default: "full",
          namespace: null,
          validation: {
            enumeration: ["full", "fix", "dataflow"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        manufacturer: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originalSclRelease: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 255,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originalSclRevision: {
          required: !1,
          default: "A",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z]", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originalSclVersion: {
          required: !1,
          default: "2003",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["2[0-2][0-9]{2}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        owner: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Services",
        "AccessPoint",
        "KDC",
        "IEDSourceFiles",
        "MinRequestedSCDFiles",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Services: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        AccessPoint: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNInAccessPoint",
              kind: "unique",
              paths: [["LN"]],
              deep: !1,
              attributes: ["inst", "lnClass", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        KDC: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        IEDSourceFiles: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        MinRequestedSCDFiles: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueProjectInReqSCD",
              kind: "unique",
              paths: [["MinRequestedSCDFile"]],
              deep: !1,
              attributes: ["fileUuid"],
              refer: null,
              text: !1
            }
          ]
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInIED",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "LDeviceInIEDKey",
        kind: "key",
        paths: [["AccessPoint", "Server", "LDevice"]],
        deep: !1,
        attributes: ["inst"],
        refer: null,
        text: !1
      },
      {
        name: "AccessPointInIEDKey",
        kind: "key",
        paths: [["AccessPoint"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "ref2LDeviceInDataSetForFCDAinLN",
        kind: "keyref",
        paths: [["AccessPoint", "Server", "LDevice", "LN", "DataSet", "FCDA"]],
        deep: !1,
        attributes: ["ldInst"],
        refer: "LDeviceInIEDKey",
        text: !1
      },
      {
        name: "ref2LDeviceInDataSetForFCDAinLN0",
        kind: "keyref",
        paths: [["AccessPoint", "Server", "LDevice", "LN0", "DataSet", "FCDA"]],
        deep: !1,
        attributes: ["ldInst"],
        refer: "LDeviceInIEDKey",
        text: !1
      },
      {
        name: "ServerAtRef2AccessPoint",
        kind: "keyref",
        paths: [["AccessPoint", "ServerAt"]],
        deep: !1,
        attributes: ["apName"],
        refer: "AccessPointInIEDKey",
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Communication: {
    tag: "Communication",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SubNetwork"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SubNetwork: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueConnectedAP",
              kind: "unique",
              paths: [["ConnectedAP"]],
              deep: !1,
              attributes: ["iedName", "apName"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueSubNetwork",
        kind: "unique",
        paths: [["SubNetwork"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DataTypeTemplates: {
    tag: "DataTypeTemplates",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: ["LNodeType", "DOType", "DAType", "EnumType"],
      details: {
        LNodeType: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueDOInLNodeType",
              kind: "unique",
              paths: [["DO"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        DOType: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueDAorSDOInDOType",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        DAType: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueBDAInDAType",
              kind: "unique",
              paths: [["BDA"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueProtNs",
              kind: "unique",
              paths: [["ProtNs"]],
              deep: !1,
              attributes: ["type"],
              refer: null,
              text: !1
            }
          ]
        },
        EnumType: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueOrdInEnumType",
              kind: "unique",
              paths: [["EnumVal"]],
              deep: !1,
              attributes: ["ord"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueEnumValue",
              kind: "unique",
              paths: [["EnumVal"]],
              deep: !1,
              attributes: [],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "DOTypeKey",
        kind: "key",
        paths: [["DOType"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      },
      {
        name: "EnumTypeDATypeKey",
        kind: "key",
        paths: [["DAType | scl:EnumType"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueDTT_ID",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["id"],
        refer: null,
        text: !1
      },
      {
        name: "ref2DOType",
        kind: "keyref",
        paths: [["LNodeType", "DO"]],
        deep: !1,
        attributes: ["type"],
        refer: "DOTypeKey",
        text: !1
      },
      {
        name: "ref2DOTypeForSDO",
        kind: "keyref",
        paths: [["DOType", "SDO"]],
        deep: !1,
        attributes: ["type"],
        refer: "DOTypeKey",
        text: !1
      },
      {
        name: "ref2EnumTypeDAType",
        kind: "keyref",
        paths: [["DOType", "DA | scl:DAType", "BDA"]],
        deep: !1,
        attributes: ["type"],
        refer: "scl:EnumTypeDATypeKey",
        text: !1
      }
    ],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Text: {
    tag: "Text",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: [
      "AccessPoint",
      "AllocationRole",
      "AllocationRoleRef",
      "AnalogueWiringParameters",
      "AnalogueWiringParametersRef",
      "Application",
      "ApplicationSclRef",
      "BDA",
      "Bay",
      "BehaviorDescription",
      "BehaviorDescriptionRef",
      "BehaviorReference",
      "BinaryWiringParameters",
      "BinaryWiringParametersRef",
      "Communication",
      "CommunicationServiceSpecifications",
      "ConductingEquipment",
      "ConnectedAP",
      "ConnectivityNode",
      "ControlRef",
      "ControllingLNode",
      "DA",
      "DAI",
      "DAS",
      "DAType",
      "DO",
      "DOI",
      "DOS",
      "DOType",
      "DataSet",
      "EnumType",
      "EqFunction",
      "EqSubFunction",
      "ExtCtrl",
      "ExtRef",
      "Function",
      "FunctionCatRef",
      "FunctionCategory",
      "FunctionCategoryRef",
      "FunctionRef",
      "FunctionRole",
      "FunctionRoleContent",
      "FunctionSclRef",
      "FunctionTemplate",
      "FunctionalSubVariant",
      "FunctionalVariant",
      "FunctionalVariantGroup",
      "FunctionalVariantRef",
      "GOOSESecurity",
      "GSE",
      "GSEControl",
      "GeneralEquipment",
      "GooseParameters",
      "GooseParametersRef",
      "Header",
      "IED",
      "IEDSourceFiles",
      "InputVar",
      "InputVarRef",
      "Inputs",
      "L2CommParameters",
      "L3IPv4CommParameters",
      "L3IPv6CommParameters",
      "LDevice",
      "LN",
      "LN0",
      "LNode",
      "LNodeDataRef",
      "LNodeInputRef",
      "LNodeInputs",
      "LNodeOutputRef",
      "LNodeOutputs",
      "LNodeSpecNaming",
      "LNodeType",
      "Labels",
      "Line",
      "Log",
      "LogControl",
      "LogParameters",
      "LogParametersRef",
      "MinRequestedSCDFiles",
      "NeutralPoint",
      "OutputVar",
      "OutputVarRef",
      "Outputs",
      "PhysConn",
      "PowerSystemRelation",
      "PowerSystemRelationRef",
      "PowerSystemRelations",
      "PowerTransformer",
      "Process",
      "ProcessEcho",
      "ProcessResource",
      "ProcessResourceRef",
      "ProcessResources",
      "Project",
      "ProjectProcessReference",
      "ReportControl",
      "ReportParameters",
      "ReportParametersRef",
      "RptEnabled",
      "SCL",
      "SDI",
      "SDO",
      "SDS",
      "SMV",
      "SMVParameters",
      "SMVParametersRef",
      "SMVSecurity",
      "SampledValueControl",
      "SclFileReference",
      "Server",
      "ServerAt",
      "ServiceSpecifications",
      "SettingControl",
      "SignalRole",
      "SourceFiles",
      "SourceRef",
      "SubCategory",
      "SubEquipment",
      "SubFunction",
      "SubFunctionTemplate",
      "SubNetwork",
      "SubscriberLNode",
      "Substation",
      "TapChanger",
      "Terminal",
      "TransformerWinding",
      "Variable",
      "VariableApplyTo",
      "VariableRef",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["source"],
      details: {
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tAnyContentFromOtherNamespace",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubCategory: {
    tag: "SubCategory",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Recursive definition of function category

Recursive definition of function category`,
    parents: ["FunctionCategory", "SubCategory"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SubCategory", "FunctionCatRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubCategory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FunctionCatRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionCatRef: {
    tag: "FunctionCatRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a function which is part of the current category

Reference to a function which is part of the current category`,
    parents: ["FunctionCategory", "SubCategory"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["function", "functionUuid"],
      details: {
        function: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProcessResource: {
    tag: "ProcessResource",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["ProcessResources"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cardinality",
        "desc",
        "max",
        "name",
        "originUuid",
        "selector",
        "templateUuid",
        "uuid"
      ],
      details: {
        cardinality: {
          required: !1,
          default: "1..1",
          namespace: null,
          validation: {
            enumeration: ["0..1", "1..1", "0..n", "1..n"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 2,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        selector: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Resource"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Resource: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueResource",
        kind: "unique",
        paths: [["Resource"]],
        deep: !1,
        attributes: ["resInst"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PowerSystemRelation: {
    tag: "PowerSystemRelation",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["PowerSystemRelations"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "desc",
        "name",
        "originUuid",
        "relation",
        "relationUuid",
        "selector",
        "templateUuid",
        "uuid"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        relation: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        relationUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        selector: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SourceRef: {
    tag: "SourceRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a data in the process

Reference to a data in the process`,
    parents: ["LNodeInputs"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "desc",
        "extRefAddr",
        "extRefUuid",
        "input",
        "inputInst",
        "originUuid",
        "pDA",
        "pDO",
        "pLN",
        "resourceName",
        "resourceUuid",
        "service",
        "source",
        "sourceDaName",
        "sourceDoName",
        "sourceLNodeUuid",
        "templateUuid",
        "uuid"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        extRefAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        extRefUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        input: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inputInst: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDA: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDO: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        service: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Poll", "Report", "GOOSE", "SMV", "Wired", "Internal"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceDaName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceLNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "GooseParametersRef",
        "SMVParametersRef",
        "ReportParametersRef",
        "BinaryWiringParametersRef",
        "AnalogueWiringParametersRef"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GooseParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        AnalogueWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: [
            "GooseParametersRef",
            "SMVParametersRef",
            "ReportParametersRef",
            "BinaryWiringParametersRef",
            "AnalogueWiringParametersRef"
          ]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tLinkFCDARef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ControlRef: {
    tag: "ControlRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a control data in the process

Reference to a control data in the process`,
    parents: ["LNodeOutputs"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "controlled",
        "controlledDoName",
        "controlledLNodeUuid",
        "desc",
        "extCtrlAddr",
        "extCtrlUuid",
        "originUuid",
        "output",
        "outputInst",
        "pDO",
        "pLN",
        "resourceName",
        "resourceUuid",
        "templateUuid",
        "uuid"
      ],
      details: {
        controlled: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        controlledDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        controlledLNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        extCtrlAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        extCtrlUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        output: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outputInst: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDO: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "BinaryWiringParametersRef", "AnalogueWiringParametersRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        AnalogueWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["BinaryWiringParametersRef", "AnalogueWiringParametersRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tLinkFCDRef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SDS: {
    tag: "SDS",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of a sub-Data Object

Specification of a sub-Data Object`,
    parents: ["DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "ix", "mappedDoName", "mappedLnUuid", "name"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedDoName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedLnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "SDS",
        "DAS",
        "SubscriberLNode",
        "ControllingLNode",
        "ProcessEcho",
        "LogParametersRef",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SDS: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        DAS: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubscriberLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ControllingLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessEcho: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInSDS",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "SDS",
            "DAS",
            "SubscriberLNode",
            "ControllingLNode",
            "ProcessEcho",
            "LogParametersRef"
          ]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueSDS_DASinSDS",
        kind: "unique",
        paths: [["DAS|.", "SDS"]],
        deep: !1,
        attributes: ["name", "ix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DAS: {
    tag: "DAS",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of a Data attribute

Specification of a Data attribute`,
    parents: ["DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "ix", "mappedDaName", "mappedLnUuid", "name", "valImport", "valKind"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedDaName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(([A-Za-z][0-9A-Za-z_]{0,63})/([A-Za-z][0-9A-Za-z_]{0,63})/((LLN0|([A-Za-z][0-9A-Za-z_]{0,10})?[A-Z]{4}[0-9]{1,12}))\\.)?([A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?)\\.([a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*)"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mappedLnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valImport: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valKind: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Spec", "Conf", "RO", "Set"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "SubscriberLNode",
        "ControllingLNode",
        "ProcessEcho",
        "LogParametersRef",
        "Val",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SubscriberLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ControllingLNode: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessEcho: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Val: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDAS",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "SubscriberLNode",
            "ControllingLNode",
            "ProcessEcho",
            "LogParametersRef",
            "Val",
            "Labels"
          ]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubscriberLNode: {
    tag: "SubscriberLNode",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["DAS", "DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "inputName", "pLN", "resourceName", "resourceUuid", "service"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inputName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        service: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Poll", "Report", "GOOSE", "SMV", "Wired", "Internal"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "GooseParametersRef",
        "SMVParametersRef",
        "ReportParametersRef",
        "BinaryWiringParametersRef"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GooseParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: [
            "GooseParametersRef",
            "SMVParametersRef",
            "ReportParametersRef",
            "BinaryWiringParametersRef"
          ]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ControllingLNode: {
    tag: "ControllingLNode",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["DAS", "DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "outputName", "pLN", "resourceName", "resourceUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outputName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "BinaryWiringParametersRef", "AnalogueWiringParametersRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        BinaryWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        AnalogueWiringParametersRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["BinaryWiringParametersRef", "AnalogueWiringParametersRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LogParametersRef: {
    tag: "LogParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the Log parameters expected for the current DOS when Log capability is required

Specification of the Log parameters expected for the current DOS when Log capability is required`,
    parents: ["DAS", "DOS", "SDS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Labels: {
    tag: "Labels",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: [
      "AccessPoint",
      "BDA",
      "Bay",
      "ConductingEquipment",
      "ConnectivityNode",
      "DA",
      "DAI",
      "DAS",
      "DAType",
      "DO",
      "DOI",
      "DOS",
      "DOType",
      "EqFunction",
      "EqSubFunction",
      "Function",
      "GOOSESecurity",
      "GeneralEquipment",
      "IED",
      "LDevice",
      "LN",
      "LN0",
      "LNode",
      "LNodeType",
      "Line",
      "PowerTransformer",
      "Process",
      "SDI",
      "SDO",
      "SDS",
      "SMVSecurity",
      "SubEquipment",
      "SubFunction",
      "SubNetwork",
      "Substation",
      "TapChanger",
      "TransformerWinding",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Label"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Label: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLabel",
        kind: "unique",
        paths: [["Label"]],
        deep: !1,
        attributes: ["id", "lang"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SclFileReference: {
    tag: "SclFileReference",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["ApplicationSclRef", "FunctionSclRef", "IEDSourceFiles", "SourceFiles"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "fileName", "fileType", "fileUuid", "revision", "version", "when"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["ICD", "IID", "CID", "SSD", "SCD", "SED"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubCheckoutID: {
    tag: "SubCheckoutID",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `When an IED is checkedout for a collaborative work by an SCC, it may be required to give right to a subpart of the collaborative project. So a CheckoutID may have an additional SubCheckoutID giving IED to nother project

When an IED is checkedout for a collaborative work by an SCC, it may be required to give right to a subpart of the collaborative project. So a CheckoutID may have an additional SubCheckoutID giving IED to nother project`,
    parents: ["CheckoutID", "SubCheckoutID"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "desc",
        "engRight",
        "fileName",
        "fileType",
        "fileUuid",
        "headerId",
        "revision",
        "version",
        "when"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        engRight: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["full", "fix", "dataflow"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["SED", "SCC", "ICD", "IID", "CID", "SSD", "SCD"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        headerId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["SubCheckoutID"],
      details: {
        SubCheckoutID: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tSclFileUUIDCheckoutRestriction",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  VariableApplyTo: {
    tag: "VariableApplyTo",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["Variable"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "attribute",
        "daName",
        "defaultValue",
        "desc",
        "doName",
        "element",
        "elementUuid",
        "format",
        "sGroup"
      ],
      details: {
        attribute: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        defaultValue: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        element: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        elementUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        format: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sGroup: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GooseParameters: {
    tag: "GooseParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["cbName", "desc", "dsName", "goId", "id", "maxTime", "minTime", "securityEnabled"],
      details: {
        cbName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        goId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxTime: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        minTime: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        securityEnabled: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "L2CommParameters", "L3IPv4CommParameters", "L3IPv6CommParameters"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        L2CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        L3IPv4CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        L3IPv6CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["L2CommParameters", "L3IPv4CommParameters", "L3IPv6CommParameters"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tControlBlockParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVParameters: {
    tag: "SMVParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cbName",
        "desc",
        "dsName",
        "id",
        "multicast",
        "nofASDU",
        "securityEnabled",
        "smpMod",
        "smpRate",
        "smvId"
      ],
      details: {
        cbName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        multicast: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nofASDU: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        securityEnabled: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpMod: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["SmpPerPeriod", "SmpPerSec", "SecPerSmp"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpRate: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smvId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "L2CommParameters", "L3IPv4CommParameters", "L3IPv6CommParameters"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        L2CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        L3IPv4CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        L3IPv6CommParameters: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["L2CommParameters", "L3IPv4CommParameters", "L3IPv6CommParameters"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tControlBlockParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReportParameters: {
    tag: "ReportParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["bufTime", "buffered", "cbName", "desc", "dsName", "id", "intgPd"],
      details: {
        bufTime: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        buffered: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlBlockParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BinaryWiringParameters: {
    tag: "BinaryWiringParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "debTm",
        "desc",
        "fastOutput",
        "id",
        "inpNam",
        "inpRef",
        "outNam",
        "outOffDl",
        "outOnDl",
        "outRef",
        "outTyp",
        "vInOff",
        "vInOn"
      ],
      details: {
        debTm: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fastOutput: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inpNam: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inpRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outNam: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outOffDl: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outOnDl: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outTyp: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Normally open", "Normally closed", "Change over"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vInOff: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vInOn: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tWiringParameters",
      validation: {
        enumeration: ["Normally open", "Normally closed", "Change over"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AnalogueWiringParameters: {
    tag: "AnalogueWiringParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "dsgInp", "fctInp", "id", "inpNam", "inpRef"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsgInp: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fctInp: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inpNam: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inpRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tWiringParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LogParameters: {
    tag: "LogParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["ServiceSpecifications"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cbName",
        "desc",
        "dsName",
        "id",
        "intgPd",
        "logEna",
        "logLdInst",
        "logLnClass",
        "logLnInst",
        "logName",
        "logPrefix",
        "reasonCode"
      ],
      details: {
        cbName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dsName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logEna: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logLdInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logLnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logLnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logPrefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        reasonCode: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlBlockParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionRef: {
    tag: "FunctionRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a function definition attached to current allocation role

Reference to a function definition attached to current allocation role`,
    parents: ["AllocationRole", "FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "function", "functionUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        function: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef", "SignalRole"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SignalRole: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionRole: {
    tag: "FunctionRole",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Role attached to the application type

Role attached to the application type`,
    parents: ["Application"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cardinality",
        "desc",
        "max",
        "name",
        "originUuid",
        "selector",
        "templateUuid",
        "type",
        "uuid"
      ],
      details: {
        cardinality: {
          required: !1,
          default: "1..1",
          namespace: null,
          validation: {
            enumeration: ["0..1", "1..1", "0..n", "1..n"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 2,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        selector: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef", "FunctionRoleContent"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FunctionRoleContent: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        },
        {
          minOccurrence: 1,
          maxOccurrence: null,
          options: ["FunctionRoleContent"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueRoleContent",
        kind: "unique",
        paths: [["FunctionRoleContent"]],
        deep: !1,
        attributes: ["roleInst"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionalVariant: {
    tag: "FunctionalVariant",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Variant attached to the application type

Variant attached to the application type`,
    parents: ["Application", "FunctionalVariantGroup"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "isBaseline", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        isBaseline: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalSubVariant", "VariableRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalSubVariant: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        VariableRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalSubVariant", "VariableRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tAbstractFunctionalVariant",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionalVariantGroup: {
    tag: "FunctionalVariantGroup",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Group of variants attached to the application type

Group of variants attached to the application type`,
    parents: ["Application"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariant"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariant: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AllocationRoleRef: {
    tag: "AllocationRoleRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Allocation role attached to the application type

Allocation role attached to the application type`,
    parents: ["Application"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["allocationRole", "allocationRoleUuid", "desc"],
      details: {
        allocationRole: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        allocationRoleUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ApplicationSclRef: {
    tag: "ApplicationSclRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to the ASD files used to create an Application

Reference to the ASD files used to create an Application`,
    parents: ["Application"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "SclFileReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SclFileReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  InputVar: {
    tag: "InputVar",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Input variable used in the behavior description

Input variable used in the behavior description`,
    parents: ["BehaviorDescription"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "daName",
        "dataName",
        "desc",
        "doName",
        "inputName",
        "inputUuid",
        "lnodeUuid",
        "value",
        "varName"
      ],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inputName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inputUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        varName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tLogicVarRef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  OutputVar: {
    tag: "OutputVar",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Output variable used in the behavior description

Output variable used in the behavior description`,
    parents: ["BehaviorDescription"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "daName",
        "dataName",
        "desc",
        "doName",
        "lnodeUuid",
        "outputName",
        "outputUuid",
        "value",
        "varName"
      ],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outputName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        outputUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        varName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tLogicVarRef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BehaviorReference: {
    tag: "BehaviorReference",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a behavior description when for example a manufacturer wants to indicate its implementation of a user specification described by another behavior description

Reference to a behavior description when for example a manufacturer wants to indicate its implementation of a user specification described by another behavior description`,
    parents: ["BehaviorDescription"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["behaviorReference", "behaviorUuid", "desc"],
      details: {
        behaviorReference: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        behaviorUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProjectProcessReference: {
    tag: "ProjectProcessReference",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to the process elements belonging to the current project

Reference to the process elements belonging to the current project`,
    parents: ["Project"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "processReference", "processUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processReference: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNode: {
    tag: "LNode",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: [
      "Bay",
      "ConductingEquipment",
      "ConnectivityNode",
      "EqFunction",
      "EqSubFunction",
      "Function",
      "FunctionTemplate",
      "GeneralEquipment",
      "Line",
      "PowerTransformer",
      "Process",
      "SubEquipment",
      "SubFunction",
      "SubFunctionTemplate",
      "Substation",
      "TapChanger",
      "TransformerWinding",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "desc",
        "iedName",
        "ldInst",
        "lnClass",
        "lnInst",
        "lnType",
        "lnUuid",
        "prefix",
        "templateUuid",
        "uuid"
      ],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !1,
          default: "None",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "None",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 0,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnType: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLNode",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubFunctionTemplate: {
    tag: "SubFunctionTemplate",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["FunctionTemplate", "SubFunctionTemplate"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "LNode", "GeneralEquipment", "ConductingEquipment", "SubFunctionTemplate"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfSubFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGESubFuncTemplate",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipmentOfSubFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubEquipmentSubFuncTemplate",
              kind: "unique",
              paths: [["SubEquipment"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        SubFunctionTemplate: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubSubFunctionTemplate",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubSubFuncTemplate",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInSubFunctionTemplate",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInSubFuncTemplate",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "t6-100LNodeContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GeneralEquipment: {
    tag: "GeneralEquipment",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: [
      "Bay",
      "EqFunction",
      "EqSubFunction",
      "Function",
      "FunctionTemplate",
      "Line",
      "Process",
      "SubFunction",
      "SubFunctionTemplate",
      "Substation",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["AXN", "BAT", "MOT", "FAN", "FIL", "PMP", "TNK", "VLV"],
            pattern: ["\\i\\c*", "E[A-Z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 3,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "EqFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForGE",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForGE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInGeneralEquipment",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInGE",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipment",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConductingEquipment: {
    tag: "ConductingEquipment",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: [
      "Bay",
      "Function",
      "FunctionTemplate",
      "Line",
      "Process",
      "SubFunction",
      "SubFunctionTemplate"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "CBR",
              "DIS",
              "VTR",
              "CTR",
              "GEN",
              "CAP",
              "REA",
              "CON",
              "MOT",
              "EFN",
              "PSH",
              "BAT",
              "BSH",
              "CAB",
              "GIL",
              "LIN",
              "RES",
              "RRC",
              "SAR",
              "TCF",
              "TCR",
              "IFL",
              "FAN",
              "SCR",
              "SMC",
              "PMP"
            ],
            pattern: ["\\i\\c*", "E[A-Z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 3,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "Terminal", "SubEquipment", "EqFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Terminal: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 2
          },
          constraints: null
        },
        SubEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInACESubEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForCE",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForCE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tAbstractConductingEquipment",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Private: {
    tag: "Private",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: [
      "AccessPoint",
      "BDA",
      "Bay",
      "Communication",
      "ConductingEquipment",
      "ConnectedAP",
      "ConnectivityNode",
      "DA",
      "DAI",
      "DAType",
      "DO",
      "DOI",
      "DOType",
      "DataSet",
      "EnumType",
      "EqFunction",
      "EqSubFunction",
      "ExtCtrl",
      "ExtRef",
      "Function",
      "GOOSESecurity",
      "GSE",
      "GSEControl",
      "GeneralEquipment",
      "IED",
      "IEDSourceFiles",
      "Inputs",
      "LDevice",
      "LN",
      "LN0",
      "LNode",
      "LNodeType",
      "Labels",
      "Line",
      "Log",
      "LogControl",
      "MinRequestedSCDFiles",
      "NeutralPoint",
      "Outputs",
      "PhysConn",
      "PowerTransformer",
      "Process",
      "ReportControl",
      "RptEnabled",
      "SCL",
      "SDI",
      "SDO",
      "SMV",
      "SMVSecurity",
      "SampledValueControl",
      "SclFileReference",
      "Server",
      "ServerAt",
      "SettingControl",
      "SourceFiles",
      "SubEquipment",
      "SubFunction",
      "SubNetwork",
      "Substation",
      "TapChanger",
      "Terminal",
      "TransformerWinding",
      "VoltageLevel"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["source", "type"],
      details: {
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tAnyContentFromOtherNamespace",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Header: {
    tag: "Header",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["SCL"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "baseUuid",
        "fileType",
        "id",
        "nameStructure",
        "revision",
        "toolID",
        "uuid",
        "version"
      ],
      details: {
        baseUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["ICD", "IID", "CID", "SSD", "SCD", "SED"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nameStructure: {
          required: !1,
          default: "IEDName",
          namespace: null,
          validation: {
            enumeration: ["IEDName"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        toolID: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: ["Text", "History", "SourceFiles"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        History: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SourceFiles: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueHitem",
        kind: "unique",
        paths: [["History", "Hitem"]],
        deep: !1,
        attributes: ["version", "revision"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: null,
      validation: {
        enumeration: ["IEDName"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PowerTransformer: {
    tag: "PowerTransformer",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Bay", "Substation", "VoltageLevel"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: "PTR",
          namespace: null,
          validation: {
            enumeration: ["PTR"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "TransformerWinding",
        "SubEquipment",
        "EqFunction"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        TransformerWinding: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInTransformerWinding",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTW",
              kind: "unique",
              paths: [["SubEquipment|.", "TapChanger|.", "EqFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        SubEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubEquipmentPTR",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTRSubEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForPTR",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForPTR",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInPowerTransformer",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInPTR",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipment",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  VoltageLevel: {
    tag: "VoltageLevel",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Substation"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "nomFreq", "numPhases", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nomFreq: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: "0",
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        numPhases: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 255,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "PowerTransformer",
        "GeneralEquipment",
        "Voltage",
        "Bay",
        "Function"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        PowerTransformer: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInPowerTransformer",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTR",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        Voltage: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Bay: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueChildNameInBay",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueLNodeInBay",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunctionVL",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInVoltageLevelFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInVoltageLevel",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInVoltageLevel",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Function: {
    tag: "Function",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Bay", "Line", "Process", "Substation", "VoltageLevel"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "SubFunction",
        "GeneralEquipment",
        "ConductingEquipment"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SubFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInSubFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGEFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipmentOfFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInCondEq",
              kind: "unique",
              paths: [["SubEquipment|.", "EqFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInFunctionSS",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInSubstationFunc",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tPowerSystemResource",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Voltage: {
    tag: "Voltage",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Line", "VoltageLevel"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["multiplier", "unit"],
      details: {
        multiplier: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: [
              "",
              "m",
              "k",
              "M",
              "mu",
              "y",
              "z",
              "a",
              "f",
              "p",
              "n",
              "c",
              "d",
              "da",
              "h",
              "G",
              "T",
              "P",
              "E",
              "Z",
              "Y"
            ],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unit: {
          required: !0,
          default: "V",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConnectivityNode: {
    tag: "ConnectivityNode",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Bay", "Line"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "pathName", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pathName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+/.+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tLNodeContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DataSet: {
    tag: "DataSet",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "FCDA"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        FCDA: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 1,
          maxOccurrence: null,
          options: ["FCDA"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReportControl: {
    tag: "ReportControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bufTime",
        "buffered",
        "confRev",
        "datSet",
        "desc",
        "indexed",
        "intgPd",
        "name",
        "rptID",
        "templateUuid",
        "uuid"
      ],
      details: {
        bufTime: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        buffered: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        confRev: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        indexed: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rptID: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[ -~]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 129,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "TrgOps", "OptFields", "RptEnabled"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        TrgOps: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        OptFields: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        RptEnabled: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlWithTriggerOpt",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LogControl: {
    tag: "LogControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bufTime",
        "datSet",
        "desc",
        "intgPd",
        "ldInst",
        "lnClass",
        "lnInst",
        "logEna",
        "logName",
        "name",
        "prefix",
        "reasonCode",
        "templateUuid",
        "uuid"
      ],
      details: {
        bufTime: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: "LLN0",
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logEna: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        reasonCode: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "TrgOps"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        TrgOps: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlWithTriggerOpt",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DOI: {
    tag: "DOI",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["accessControl", "desc", "ix", "name"],
      details: {
        accessControl: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 12,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SDI", "DAI", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SDI: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueSDI_DAIinSDI",
              kind: "unique",
              paths: [["DAI|.", "SDI"]],
              deep: !1,
              attributes: ["name", "ix"],
              refer: null,
              text: !1
            }
          ]
        },
        DAI: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelinDOI",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["SDI", "DAI"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueSDI_DAIinDOI",
        kind: "unique",
        paths: [["DAI|.", "SDI"]],
        deep: !1,
        attributes: ["name", "ix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Inputs: {
    tag: "Inputs",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "ExtRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ExtRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Outputs: {
    tag: "Outputs",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "ExtCtrl"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ExtCtrl: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Log: {
    tag: "Log",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["LN", "LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSEControl: {
    tag: "GSEControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "appID",
        "confRev",
        "datSet",
        "desc",
        "fixedOffs",
        "name",
        "securityEnable",
        "templateUuid",
        "type",
        "uuid"
      ],
      details: {
        appID: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[ -~]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 129,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        confRev: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fixedOffs: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        securityEnable: {
          required: !1,
          default: "None",
          namespace: null,
          validation: {
            enumeration: ["None", "Signature", "SignatureAndEncryption"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: "GOOSE",
          namespace: null,
          validation: {
            enumeration: ["GSSE", "GOOSE"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "IEDName", "Protocol"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        IEDName: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Protocol: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlWithIEDName",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SampledValueControl: {
    tag: "SampledValueControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "confRev",
        "datSet",
        "desc",
        "multicast",
        "name",
        "nofASDU",
        "securityEnable",
        "smpMod",
        "smpRate",
        "smvID",
        "templateUuid",
        "uuid"
      ],
      details: {
        confRev: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        multicast: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nofASDU: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        securityEnable: {
          required: !1,
          default: "None",
          namespace: null,
          validation: {
            enumeration: ["None", "Signature", "SignatureAndEncryption"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpMod: {
          required: !1,
          default: "SmpPerPeriod",
          namespace: null,
          validation: {
            enumeration: ["SmpPerPeriod", "SmpPerSec", "SecPerSmp"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpRate: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smvID: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[ -~]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 129,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "IEDName", "SmvOpts", "Protocol"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        IEDName: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SmvOpts: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Protocol: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlWithIEDName",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SettingControl: {
    tag: "SettingControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["LN0"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["actSG", "desc", "numOfSGs", "resvTms"],
      details: {
        actSG: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        numOfSGs: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resvTms: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 65535,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Services: {
    tag: "Services",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["AccessPoint", "IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["nameLength"],
      details: {
        nameLength: {
          required: !1,
          default: "32",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["32", "64", "6[5-9]", "[7-9]\\d", "[1-9]\\d\\d+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [
        "DynAssociation",
        "SettingGroups",
        "GetDirectory",
        "GetDataObjectDefinition",
        "DataObjectDirectory",
        "GetDataSetValue",
        "SetDataSetValue",
        "DataSetDirectory",
        "ConfDataSet",
        "DynDataSet",
        "ReadWrite",
        "TimerActivatedControl",
        "ConfReportControl",
        "GetCBValues",
        "ConfLogControl",
        "ReportSettings",
        "LogSettings",
        "GSESettings",
        "SMVSettings",
        "GSEDir",
        "GOOSE",
        "GSSE",
        "SMVsc",
        "FileHandling",
        "ConfLNs",
        "ClientServices",
        "ConfLdName",
        "SupSubscription",
        "ConfSigRef",
        "ValueHandling",
        "RedProt",
        "TimeSyncProt",
        "CommProt",
        "SCSM",
        "Security",
        "MultiAPPerSubNet"
      ],
      details: {
        DynAssociation: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SettingGroups: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GetDirectory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GetDataObjectDefinition: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        DataObjectDirectory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GetDataSetValue: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SetDataSetValue: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        DataSetDirectory: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfDataSet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        DynDataSet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReadWrite: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        TimerActivatedControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfReportControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GetCBValues: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfLogControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ReportSettings: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        LogSettings: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GSESettings: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVSettings: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GSEDir: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GOOSE: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GSSE: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SMVsc: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FileHandling: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfLNs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ClientServices: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfLdName: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SupSubscription: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfSigRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ValueHandling: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        RedProt: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        TimeSyncProt: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        CommProt: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SCSM: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Security: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        MultiAPPerSubNet: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AccessPoint: {
    tag: "AccessPoint",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["clock", "desc", "kdc", "name", "router", "templateUuid", "uuid"],
      details: {
        clock: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        kdc: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        router: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Server",
        "LN",
        "ServerAt",
        "Services",
        "GOOSESecurity",
        "SMVSecurity",
        "Labels"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Server: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueAssociationInServer",
              kind: "unique",
              paths: [["Association"]],
              deep: !1,
              attributes: ["associationID"],
              refer: null,
              text: !1
            }
          ]
        },
        LN: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        },
        ServerAt: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Services: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GOOSESecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 7
          },
          constraints: null
        },
        SMVSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 7
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInAP",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: 1,
          options: ["Server", "LN", "ServerAt"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueLNInAccessPoint",
        kind: "unique",
        paths: [["LN"]],
        deep: !1,
        attributes: ["inst", "lnClass", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  KDC: {
    tag: "KDC",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["apName", "apUuid", "iedName"],
      details: {
        apName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        apUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  IEDSourceFiles: {
    tag: "IEDSourceFiles",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SclFileReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SclFileReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MinRequestedSCDFiles: {
    tag: "MinRequestedSCDFiles",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["IED"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "MinRequestedSCDFile"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        MinRequestedSCDFile: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueProjectInReqSCD",
        kind: "unique",
        paths: [["MinRequestedSCDFile"]],
        deep: !1,
        attributes: ["fileUuid"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tBaseElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubNetwork: {
    tag: "SubNetwork",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Communication"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["8-MMS", "8-XMPP"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "BitRate", "ConnectedAP"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        BitRate: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConnectedAP: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueGSEinConnectedAP",
              kind: "unique",
              paths: [["GSE"]],
              deep: !1,
              attributes: ["cbName", "ldInst"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSMVinConnectedAP",
              kind: "unique",
              paths: [["SMV"]],
              deep: !1,
              attributes: ["cbName", "ldInst"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueConnectedAP",
        kind: "unique",
        paths: [["ConnectedAP"]],
        deep: !1,
        attributes: ["iedName", "apName"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeType: {
    tag: "LNodeType",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["DataTypeTemplates"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "id", "iedType", "lnClass"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedType: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "DO", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        DO: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLNType",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueDOInLNodeType",
        kind: "unique",
        paths: [["DO"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tIDNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DOType: {
    tag: "DOType",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["DataTypeTemplates"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["cdc", "desc", "id", "iedType"],
      details: {
        cdc: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "SPS",
              "DPS",
              "INS",
              "ENS",
              "ACT",
              "ACD",
              "SEC",
              "BCR",
              "HST",
              "VSS",
              "MV",
              "CMV",
              "SAV",
              "WYE",
              "DEL",
              "SEQ",
              "HMV",
              "HWYE",
              "HDEL",
              "SPC",
              "DPC",
              "INC",
              "ENC",
              "BSC",
              "ISC",
              "APC",
              "BAC",
              "SPG",
              "ING",
              "ENG",
              "ORG",
              "TSG",
              "CUG",
              "VSG",
              "ASG",
              "CURVE",
              "CSG",
              "DPL",
              "LPL",
              "CSD",
              "CST",
              "BTS",
              "UTS",
              "LTS",
              "GTS",
              "MTS",
              "NTS",
              "STS",
              "CTS",
              "OTS",
              "VSD",
              "ORS",
              "TCS"
            ],
            pattern: ["\\i\\c*", "[A-Za-z]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 5,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedType: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SDO", "DA", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SDO: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        DA: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueProtNsInDA",
              kind: "unique",
              paths: [["ProtNs"]],
              deep: !1,
              attributes: ["type"],
              refer: null,
              text: !1
            }
          ]
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDOType",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["SDO", "DA"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueDAorSDOInDOType",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tIDNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DAType: {
    tag: "DAType",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["DataTypeTemplates"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "id", "iedType"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedType: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "BDA", "ProtNs", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        BDA: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        },
        ProtNs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDAType",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueBDAInDAType",
        kind: "unique",
        paths: [["BDA"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueProtNs",
        kind: "unique",
        paths: [["ProtNs"]],
        deep: !1,
        attributes: ["type"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tIDNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  EnumType: {
    tag: "EnumType",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["DataTypeTemplates"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "EnumVal"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        EnumVal: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: ["[\\p{IsBasicLatin}\\p{IsLatin-1Supplement}]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 127,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueOrdInEnumType",
        kind: "unique",
        paths: [["EnumVal"]],
        deep: !1,
        attributes: ["ord"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueEnumValue",
        kind: "unique",
        paths: [["EnumVal"]],
        deep: !1,
        attributes: [],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tIDNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Resource: {
    tag: "Resource",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `resource bound to this element could be multi

resource bound to this element could be multi`,
    parents: ["ProcessResource"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["resInst", "source", "sourceUuid"],
      details: {
        resInst: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        source: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "normalizedString",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GooseParametersRef: {
    tag: "GooseParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the communication parameters expected for the current SourceRef when ServiceType is GOOSE

Specification of the communication parameters expected for the current SourceRef when ServiceType is GOOSE`,
    parents: ["SourceRef", "SubscriberLNode"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVParametersRef: {
    tag: "SMVParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the communication parameters expected for the current SourceRef when ServiceType is SMV

Specification of the communication parameters expected for the current SourceRef when ServiceType is SMV`,
    parents: ["SourceRef", "SubscriberLNode"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReportParametersRef: {
    tag: "ReportParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the communication parameters expected for the current SourceRef when ServiceType is Report

Specification of the communication parameters expected for the current SourceRef when ServiceType is Report`,
    parents: ["SourceRef", "SubscriberLNode"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BinaryWiringParametersRef: {
    tag: "BinaryWiringParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the binary wiring parameters expected for the current SourceRef when ServiceType is Wired

Specification of the binary wiring parameters expected for the current SourceRef when ServiceType is Wired`,
    parents: ["ControlRef", "ControllingLNode", "SourceRef", "SubscriberLNode"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AnalogueWiringParametersRef: {
    tag: "AnalogueWiringParametersRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Specification of the analogue wiring parameters expected for the current SourceRef when ServiceType is Wired

Specification of the analogue wiring parameters expected for the current SourceRef when ServiceType is Wired`,
    parents: ["ControlRef", "ControllingLNode", "SourceRef"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "id"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        id: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElementWithDesc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Val: {
    tag: "Val",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["BDA", "DA", "DAI", "DAS"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["sGroup"],
      details: {
        sGroup: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "normalizedString",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Label: {
    tag: "Label",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Labels"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["id", "lang"],
      details: {
        id: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\S+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lang: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "normalizedString",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  L2CommParameters: {
    tag: "L2CommParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["GooseParameters", "SMVParameters"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["appId", "desc", "macAddr", "vlanId", "vlanPriority"],
      details: {
        appId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        macAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}\\-[0-9A-F]{2}"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanPriority: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-7]"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tCommParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  L3IPv4CommParameters: {
    tag: "L3IPv4CommParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["GooseParameters", "SMVParameters"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["IPv4", "IPv4-IGMPv3Src", "appId", "desc", "vlanId", "vlanPriority"],
      details: {
        IPv4: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        "IPv4-IGMPv3Src": {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        appId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanPriority: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-7]"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tCommParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  L3IPv6CommParameters: {
    tag: "L3IPv6CommParameters",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: null,
    parents: ["GooseParameters", "SMVParameters"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["IPv6", "IPv6-IGMPv3Src", "appId", "desc", "vlanId", "vlanPriority"],
      details: {
        IPv6: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["([0-9a-f]{1,4}:){7}[0-9a-f]{1,4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        "IPv6-IGMPv3Src": {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["([0-9a-f]{1,4}:){7}[0-9a-f]{1,4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        appId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{4}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanId: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-F]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        vlanPriority: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-7]"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tCommParameters",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionalVariantRef: {
    tag: "FunctionalVariantRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Ref to a functional variant of the Application

Ref to a functional variant of the Application`,
    parents: [
      "AllocationRoleRef",
      "BehaviorDescriptionRef",
      "FunctionCategoryRef",
      "FunctionRef",
      "FunctionRole",
      "InputVarRef",
      "LNodeDataRef",
      "LNodeInputRef",
      "LNodeOutputRef",
      "OutputVarRef",
      "PowerSystemRelationRef",
      "ProcessResourceRef",
      "SignalRole",
      "VariableRef"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["functionalVariant", "functionalVariantUuid", "update"],
      details: {
        functionalVariant: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionalVariantUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        update: {
          required: !1,
          default: "add",
          namespace: null,
          validation: {
            enumeration: ["add", "remove"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: ["add", "remove"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SignalRole: {
    tag: "SignalRole",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Signal list attached to the referenced function in the context of the cureent Role definition

Signal list attached to the referenced function in the context of the cureent Role definition`,
    parents: ["FunctionRef"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef", "LNodeInputRef", "LNodeOutputRef", "LNodeDataRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LNodeInputRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LNodeOutputRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LNodeDataRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionRoleContent: {
    tag: "FunctionRoleContent",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `an instance of the current role. In case of application type definition, instance 1 is the default instance

an instance of the current role. In case of application type definition, instance 1 is the default instance`,
    parents: ["FunctionRole"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["roleInst"],
      details: {
        roleInst: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 1,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "FunctionRef",
        "BehaviorDescriptionRef",
        "ProcessResourceRef",
        "VariableRef",
        "FunctionCategoryRef",
        "PowerSystemRelationRef"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        BehaviorDescriptionRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        ProcessResourceRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        VariableRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionCategoryRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        PowerSystemRelationRef: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: [
            "FunctionRef",
            "BehaviorDescriptionRef",
            "ProcessResourceRef",
            "VariableRef",
            "FunctionCategoryRef",
            "PowerSystemRelationRef"
          ]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tBaseExtensionElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionalSubVariant: {
    tag: "FunctionalSubVariant",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Sub variant of the current variant

Sub variant of the current variant`,
    parents: ["FunctionalSubVariant", "FunctionalVariant"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "isBaseline", "name", "originUuid", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        isBaseline: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        originUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalSubVariant", "VariableRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalSubVariant: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        VariableRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalSubVariant", "VariableRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tAbstractFunctionalVariant",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  VariableRef: {
    tag: "VariableRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a variable attached to current variant, to parameterize the instance with the value defined in the reference

Reference to a variable attached to current variant, to parameterize the instance with the value defined in the reference`,
    parents: ["FunctionRoleContent", "FunctionalSubVariant", "FunctionalVariant"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "value", "variable", "variableUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        variable: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        variableUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tVariableRef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  EqFunction: {
    tag: "EqFunction",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: [
      "ConductingEquipment",
      "GeneralEquipment",
      "PowerTransformer",
      "SubEquipment",
      "TapChanger",
      "TransformerWinding"
    ],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "GeneralEquipment", "EqSubFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfFuncForEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGEFuncForEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqSubFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubFuncForEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubFuncForEquipment",
              kind: "unique",
              paths: [["EqSubFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInFuncForGE",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInFuncForGE",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tAbstractEqFuncSubFunc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Terminal: {
    tag: "Terminal",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["ConductingEquipment", "TransformerWinding"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bayName",
        "cNodeName",
        "cNodeUuid",
        "connectivityNode",
        "desc",
        "lineName",
        "name",
        "processName",
        "substationName",
        "voltageLevelName"
      ],
      details: {
        bayName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cNodeName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        connectivityNode: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+/.+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lineName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        substationName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        voltageLevelName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubEquipment: {
    tag: "SubEquipment",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["ConductingEquipment", "PowerTransformer", "TapChanger", "TransformerWinding"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "phase", "templateUuid", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        phase: {
          required: !1,
          default: "none",
          namespace: null,
          validation: {
            enumeration: ["A", "B", "C", "N", "all", "none", "AB", "BC", "CA"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "EqFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForSubEq",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForSubEq",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInSubEquipment",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInACESubEquipment",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tPowerSystemResource",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  History: {
    tag: "History",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Header"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: ["Hitem"],
      details: {
        Hitem: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SourceFiles: {
    tag: "SourceFiles",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Header", "Hitem"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SclFileReference"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SclFileReference: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tBaseElement",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TransformerWinding: {
    tag: "TransformerWinding",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["PowerTransformer"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: "PTW",
          namespace: null,
          validation: {
            enumeration: ["PTW"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "Terminal",
        "SubEquipment",
        "TapChanger",
        "NeutralPoint",
        "EqFunction"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Terminal: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 2
          },
          constraints: null
        },
        SubEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInACESubEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        TapChanger: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLNodeInTapChanger",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInLTC",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        NeutralPoint: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForPTW",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForPTW",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInTransformerWinding",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInPTW",
        kind: "unique",
        paths: [["SubEquipment|.", "TapChanger|.", "EqFunction"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tAbstractConductingEquipment",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Bay: {
    tag: "Bay",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["VoltageLevel"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "PowerTransformer",
        "GeneralEquipment",
        "ConductingEquipment",
        "ConnectivityNode",
        "Function"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        PowerTransformer: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInPowerTransformer",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInPTR",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGE",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInCE",
              kind: "unique",
              paths: [["SubEquipment|.", "EqFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConnectivityNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConnectivityNode",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Function: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFunctionB",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInBayFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueChildNameInBay",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueLNodeInBay",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tEquipmentContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SubFunction: {
    tag: "SubFunction",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Function", "SubFunction"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [
        "Text",
        "Private",
        "Labels",
        "LNode",
        "GeneralEquipment",
        "ConductingEquipment",
        "SubFunction"
      ],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfSubFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGESubFunc",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        ConductingEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInConductingEquipmentOfSubFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubEquipmentSubFunc",
              kind: "unique",
              paths: [["SubEquipment"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        SubFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubSubFunction",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubSubFunc",
              kind: "unique",
              paths: [["SubFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInSubFunction",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInSubFunc",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tPowerSystemResource",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FCDA: {
    tag: "FCDA",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["DataSet"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["daName", "doName", "fc", "ix", "ldInst", "lnClass", "lnInst", "lnUuid", "prefix"],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fc: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "ST",
              "MX",
              "CO",
              "SP",
              "SG",
              "SE",
              "SV",
              "CF",
              "DC",
              "EX",
              "SR",
              "BL",
              "OR"
            ],
            pattern: ["\\i\\c*", "[A-Z]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 2,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TrgOps: {
    tag: "TrgOps",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["LogControl", "ReportControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["dchg", "dupd", "gi", "period", "qchg"],
      details: {
        dchg: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dupd: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        gi: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        period: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        qchg: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  OptFields: {
    tag: "OptFields",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["ReportControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "bufOvfl",
        "configRef",
        "dataRef",
        "dataSet",
        "entryID",
        "reasonCode",
        "seqNum",
        "timeStamp"
      ],
      details: {
        bufOvfl: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        configRef: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataRef: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataSet: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        entryID: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        reasonCode: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        seqNum: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        timeStamp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  RptEnabled: {
    tag: "RptEnabled",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["ReportControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "max"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !1,
          default: "1",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "ClientLN"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        ClientLN: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SDI: {
    tag: "SDI",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["DOI", "SDI"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "ix", "name", "sAddr"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "SDI", "DAI", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SDI: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        DAI: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelinSDI",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["SDI", "DAI"]
        }
      ]
    },
    constraints: [
      {
        name: "uniqueSDI_DAIinSDI",
        kind: "unique",
        paths: [["DAI|.", "SDI"]],
        deep: !1,
        attributes: ["name", "ix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DAI: {
    tag: "DAI",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["DOI", "SDI"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "ix", "name", "sAddr", "valImport", "valKind"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valImport: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valKind: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Spec", "Conf", "RO", "Set"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Val", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Val: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelinDAI",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ExtRef: {
    tag: "ExtRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Inputs"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "daName",
        "desc",
        "doName",
        "iedName",
        "intAddr",
        "ldInst",
        "lnClass",
        "lnInst",
        "lnUuid",
        "pDA",
        "pDO",
        "pLN",
        "pServT",
        "prefix",
        "serviceType",
        "srcCBName",
        "srcCBUuid",
        "srcLDInst",
        "srcLNClass",
        "srcLNInst",
        "srcPrefix",
        "templateUuid",
        "uuid"
      ],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "@",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDA: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDO: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pServT: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Poll", "Report", "GOOSE", "SMV"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        serviceType: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Poll", "Report", "GOOSE", "SMV"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcCBName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcCBUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcLDInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcLNClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcLNInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        srcPrefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tDORef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ExtCtrl: {
    tag: "ExtCtrl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Outputs"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "apRef",
        "checkInterlock",
        "checkSynchrocheck",
        "desc",
        "doName",
        "iedName",
        "intAddr",
        "ldInst",
        "lnClass",
        "lnInst",
        "lnUuid",
        "pDO",
        "pLN",
        "prefix",
        "templateUuid",
        "uuid"
      ],
      details: {
        apRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        checkInterlock: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: ["true", "false", "conserve"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        checkSynchrocheck: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: ["true", "false", "conserve"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "@",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pDO: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pLN: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tDORef",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  IEDName: {
    tag: "IEDName",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["GSEControl", "SampledValueControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["apRef", "apUuid", "ldInst", "ldUuid", "lnClass", "lnInst", "lnUuid", "prefix"],
      details: {
        apRef: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        apUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tIEDName",
      validation: {
        enumeration: null,
        pattern: [
          "[A-Za-z][0-9A-Za-z_]{0,2}",
          "[A-Za-z][0-9A-Za-z_]{4,63}",
          "[A-MO-Za-z][0-9A-Za-z_]{3}",
          "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
          "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
          "Non[0-9A-Za-df-z_]",
          "[A-Za-z][0-9A-Za-z_]*",
          "\\i\\c*"
        ],
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: 64,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Protocol: {
    tag: "Protocol",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["GSEControl", "SampledValueControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["mustUnderstand"],
      details: {
        mustUnderstand: {
          required: !0,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "normalizedString",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SmvOpts: {
    tag: "SmvOpts",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["SampledValueControl"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "dataSet",
        "refreshTime",
        "sampleMode",
        "sampleRate",
        "sampleSynchronized",
        "security",
        "synchSourceId",
        "timestamp"
      ],
      details: {
        dataSet: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        refreshTime: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sampleMode: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sampleRate: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sampleSynchronized: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        security: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        synchSourceId: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        timestamp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DynAssociation: {
    tag: "DynAssociation",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max"],
      details: {
        max: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SettingGroups: {
    tag: "SettingGroups",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: ["SGEdit", "ConfSG"],
      details: {
        SGEdit: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        ConfSG: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GetDirectory: {
    tag: "GetDirectory",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GetDataObjectDefinition: {
    tag: "GetDataObjectDefinition",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DataObjectDirectory: {
    tag: "DataObjectDirectory",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GetDataSetValue: {
    tag: "GetDataSetValue",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SetDataSetValue: {
    tag: "SetDataSetValue",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DataSetDirectory: {
    tag: "DataSetDirectory",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfDataSet: {
    tag: "ConfDataSet",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max", "maxAttributes", "modify"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxAttributes: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        modify: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMaxAndMaxAttributes",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DynDataSet: {
    tag: "DynDataSet",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max", "maxAttributes"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxAttributes: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMax",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReadWrite: {
    tag: "ReadWrite",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TimerActivatedControl: {
    tag: "TimerActivatedControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfReportControl: {
    tag: "ConfReportControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["bufConf", "bufMode", "max", "maxBuf"],
      details: {
        bufConf: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        bufMode: {
          required: !1,
          default: "both",
          namespace: null,
          validation: {
            enumeration: ["unbuffered", "buffered", "both"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxBuf: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMax",
      validation: {
        enumeration: ["unbuffered", "buffered", "both"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GetCBValues: {
    tag: "GetCBValues",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfLogControl: {
    tag: "ConfLogControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ReportSettings: {
    tag: "ReportSettings",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "bufTime",
        "cbName",
        "datSet",
        "intgPd",
        "optFields",
        "owner",
        "resvTms",
        "rptID",
        "trgOps"
      ],
      details: {
        bufTime: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbName: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        optFields: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        owner: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        resvTms: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rptID: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        trgOps: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceSettings",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LogSettings: {
    tag: "LogSettings",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["cbName", "datSet", "intgPd", "logEna", "trgOps"],
      details: {
        cbName: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        intgPd: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        logEna: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        trgOps: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceSettings",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSESettings: {
    tag: "GSESettings",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["appID", "cbName", "datSet", "dataLabel", "kdaParticipant"],
      details: {
        appID: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbName: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dataLabel: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        kdaParticipant: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: ["McSecurity"],
      details: {
        McSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceSettings",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVSettings: {
    tag: "SMVSettings",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "cbName",
        "datSet",
        "kdaParticipant",
        "nofASDU",
        "optFields",
        "pdcTimeStamp",
        "samplesPerSec",
        "smpRate",
        "svID",
        "synchSrcId"
      ],
      details: {
        cbName: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        datSet: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        kdaParticipant: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        nofASDU: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        optFields: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        pdcTimeStamp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        samplesPerSec: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        smpRate: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        svID: {
          required: !1,
          default: "Fix",
          namespace: null,
          validation: {
            enumeration: ["Dyn", "Conf", "Fix"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        synchSrcId: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: ["SmpRate", "SamplesPerSec", "SecPerSamples", "McSecurity"],
      details: {
        SmpRate: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SamplesPerSec: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        SecPerSamples: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        McSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 1,
          maxOccurrence: null,
          options: ["SmpRate", "SamplesPerSec", "SecPerSamples"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tServiceSettings",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSEDir: {
    tag: "GSEDir",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GOOSE: {
    tag: "GOOSE",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["fixedOffs", "goose", "max", "rGOOSE"],
      details: {
        fixedOffs: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        goose: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rGOOSE: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMax",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSSE: {
    tag: "GSSE",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVsc: {
    tag: "SMVsc",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["delivery", "deliveryConf", "max", "rSV", "sv"],
      details: {
        delivery: {
          required: !1,
          default: "multicast",
          namespace: null,
          validation: {
            enumeration: ["unicast", "multicast", "both"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        deliveryConf: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rSV: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sv: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceWithMax",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FileHandling: {
    tag: "FileHandling",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["ftp", "ftps", "mms"],
      details: {
        ftp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ftps: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        mms: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfLNs: {
    tag: "ConfLNs",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["fixLnInst", "fixPrefix"],
      details: {
        fixLnInst: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fixPrefix: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ClientServices: {
    tag: "ClientServices",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "acceptServerInitiatedAssociation",
        "bufReport",
        "goose",
        "gsse",
        "maxAttributes",
        "maxGOOSE",
        "maxReports",
        "maxSMV",
        "noIctBinding",
        "rGOOSE",
        "rSV",
        "readLog",
        "supportsLdName",
        "sv",
        "unbufReport"
      ],
      details: {
        acceptServerInitiatedAssociation: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        bufReport: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        goose: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        gsse: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxAttributes: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxGOOSE: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxReports: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxSMV: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        noIctBinding: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rGOOSE: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rSV: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        readLog: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        supportsLdName: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sv: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unbufReport: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: ["TimeSyncProt", "GOOSEMcSecurity", "SVMcSecurity", "Security"],
      details: {
        TimeSyncProt: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GOOSEMcSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        SVMcSecurity: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Security: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfLdName: {
    tag: "ConfLdName",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SupSubscription: {
    tag: "SupSubscription",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["maxGo", "maxSv"],
      details: {
        maxGo: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        maxSv: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfSigRef: {
    tag: "ConfSigRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["max"],
      details: {
        max: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ValueHandling: {
    tag: "ValueHandling",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["setToRO"],
      details: {
        setToRO: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  RedProt: {
    tag: "RedProt",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["hsr", "prp", "rstp"],
      details: {
        hsr: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        rstp: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TimeSyncProt: {
    tag: "TimeSyncProt",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["ClientServices", "Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["c37_238", "iec61850_9_3", "other", "sntp"],
      details: {
        c37_238: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iec61850_9_3: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        other: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sntp: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  CommProt: {
    tag: "CommProt",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["ipv6"],
      details: {
        ipv6: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SCSM: {
    tag: "SCSM",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["iec61850_8_1", "iec61850_8_2", "serverAssociationInitiation"],
      details: {
        iec61850_8_1: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iec61850_8_2: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        serverAssociationInitiation: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Security: {
    tag: "Security",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["ClientServices", "Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["ACSEAuthentication", "E2ESecurity"],
      details: {
        ACSEAuthentication: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        E2ESecurity: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MultiAPPerSubNet: {
    tag: "MultiAPPerSubNet",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Services"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Server: {
    tag: "Server",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["AccessPoint"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "timeout"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        timeout: {
          required: !1,
          default: "30",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Authentication", "LDevice", "Association"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Authentication: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LDevice: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNInLDevice",
              kind: "unique",
              paths: [["LN"]],
              deep: !1,
              attributes: ["inst", "lnClass", "prefix"],
              refer: null,
              text: !1
            }
          ]
        },
        Association: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueAssociationInServer",
        kind: "unique",
        paths: [["Association"]],
        deep: !1,
        attributes: ["associationID"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ServerAt: {
    tag: "ServerAt",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["AccessPoint"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["apName", "apUuid", "desc"],
      details: {
        apName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        apUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GOOSESecurity: {
    tag: "GOOSESecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["AccessPoint"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "serialNumber", "templateUuid", "uuid", "xferNumber"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        serialNumber: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        xferNumber: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "Subject", "IssuerName"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        Subject: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        IssuerName: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMVSecurity: {
    tag: "SMVSecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["AccessPoint"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "serialNumber", "templateUuid", "uuid", "xferNumber"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        serialNumber: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        xferNumber: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "Subject", "IssuerName"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        Subject: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        IssuerName: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MinRequestedSCDFile: {
    tag: "MinRequestedSCDFile",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["MinRequestedSCDFiles"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "fileName", "fileType", "fileUuid", "revision", "version", "when"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["SCD", "ICD", "IID", "CID", "SSD", "SED"],
            pattern: ["\\i\\c*", "[A-Z]{3}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fileUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tSclFileUUIDReference",
      validation: {
        enumeration: ["SCD"],
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BitRate: {
    tag: "BitRate",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["SubNetwork"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["multiplier", "unit"],
      details: {
        multiplier: {
          required: !1,
          default: "M",
          namespace: null,
          validation: {
            enumeration: [
              "",
              "m",
              "k",
              "M",
              "mu",
              "y",
              "z",
              "a",
              "f",
              "p",
              "n",
              "c",
              "d",
              "da",
              "h",
              "G",
              "T",
              "P",
              "E",
              "Z",
              "Y"
            ],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unit: {
          required: !1,
          default: "b/s",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "decimal",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConnectedAP: {
    tag: "ConnectedAP",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["SubNetwork"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["apName", "apUuid", "desc", "iedName", "redProt"],
      details: {
        apName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        apUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        redProt: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["none", "hsr", "prp", "rstp"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Address", "GSE", "SMV", "PhysConn"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Address: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        GSE: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SMV: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        PhysConn: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniquePTypeInPhysConn",
              kind: "unique",
              paths: [["P"]],
              deep: !1,
              attributes: ["type"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueGSEinConnectedAP",
        kind: "unique",
        paths: [["GSE"]],
        deep: !1,
        attributes: ["cbName", "ldInst"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueSMVinConnectedAP",
        kind: "unique",
        paths: [["SMV"]],
        deep: !1,
        attributes: ["cbName", "ldInst"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DO: {
    tag: "DO",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["LNodeType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["accessControl", "desc", "name", "transient", "type"],
      details: {
        accessControl: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 12,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        transient: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDO",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SDO: {
    tag: "SDO",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["DOType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["count", "desc", "name", "type"],
      details: {
        count: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[a-z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[a-z][0-9A-Za-z]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInSDO",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  DA: {
    tag: "DA",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["DOType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bType",
        "count",
        "dchg",
        "desc",
        "dupd",
        "fc",
        "name",
        "qchg",
        "sAddr",
        "type",
        "valImport",
        "valKind"
      ],
      details: {
        bType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "BOOLEAN",
              "INT8",
              "INT16",
              "INT24",
              "INT32",
              "INT64",
              "INT128",
              "INT8U",
              "INT16U",
              "INT24U",
              "INT32U",
              "FLOAT32",
              "FLOAT64",
              "Enum",
              "Dbpos",
              "Tcmd",
              "Quality",
              "Timestamp",
              "VisString32",
              "VisString64",
              "VisString65",
              "VisString129",
              "VisString255",
              "Octet64",
              "Unicode255",
              "Struct",
              "EntryTime",
              "Check",
              "ObjRef",
              "Currency",
              "PhyComAddr",
              "TrgOps",
              "OptFlds",
              "SvOptFlds",
              "LogOptFlds",
              "EntryID",
              "Octet6",
              "Octet16"
            ],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        count: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dchg: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        dupd: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        fc: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "ST",
              "MX",
              "CO",
              "SP",
              "SG",
              "SE",
              "SV",
              "CF",
              "DC",
              "EX",
              "SR",
              "BL",
              "OR"
            ],
            pattern: ["\\i\\c*", "[A-Z]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: 2,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        qchg: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valImport: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valKind: {
          required: !1,
          default: "Set",
          namespace: null,
          validation: {
            enumeration: ["Spec", "Conf", "RO", "Set"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Val", "Labels", "ProtNs"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Val: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDA",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        ProtNs: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueProtNsInDA",
        kind: "unique",
        paths: [["ProtNs"]],
        deep: !1,
        attributes: ["type"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tAbstractDataAttribute",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BDA: {
    tag: "BDA",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["DAType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["bType", "count", "desc", "name", "sAddr", "type", "valImport", "valKind"],
      details: {
        bType: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "BOOLEAN",
              "INT8",
              "INT16",
              "INT24",
              "INT32",
              "INT64",
              "INT128",
              "INT8U",
              "INT16U",
              "INT24U",
              "INT32U",
              "FLOAT32",
              "FLOAT64",
              "Enum",
              "Dbpos",
              "Tcmd",
              "Quality",
              "Timestamp",
              "VisString32",
              "VisString64",
              "VisString65",
              "VisString129",
              "VisString255",
              "Octet64",
              "Unicode255",
              "Struct",
              "EntryTime",
              "Check",
              "ObjRef",
              "Currency",
              "PhyComAddr",
              "TrgOps",
              "OptFlds",
              "SvOptFlds",
              "LogOptFlds",
              "EntryID",
              "Octet6",
              "Octet16"
            ],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        count: {
          required: !1,
          default: "0",
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: 0,
            maxInclusive: 4294967295,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "T",
              "Test",
              "Check",
              "SIUnit",
              "Oper",
              "SBO",
              "SBOw",
              "Cancel",
              "Addr",
              "PRIORITY",
              "VID",
              "APPID",
              "TransportInUse",
              "IPClassOfTraffic",
              "IPv6FlowLabel",
              "IPAddressLength",
              "IPAddress"
            ],
            pattern: ["\\i\\c*", "[a-z][0-9A-Za-z]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 60,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sAddr: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 255,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valImport: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        valKind: {
          required: !1,
          default: "Set",
          namespace: null,
          validation: {
            enumeration: ["Spec", "Conf", "RO", "Set"],
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Val", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Val: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInDA",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tAbstractDataAttribute",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProtNs: {
    tag: "ProtNs",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["DA", "DAType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["type"],
      details: {
        type: {
          required: !1,
          default: "8-MMS",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tNamespaceName",
      validation: {
        enumeration: null,
        pattern: ["[ -~]+:20\\d\\d[A-Z]?"],
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  EnumVal: {
    tag: "EnumVal",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["EnumType"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "ord"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ord: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: -2147483648,
            maxInclusive: 2147483647,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tEnumStringValue",
      validation: {
        enumeration: null,
        pattern: ["[\\p{IsBasicLatin}\\p{IsLatin-1Supplement}]*"],
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: 127,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeInputRef: {
    tag: "LNodeInputRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to SourceRefs belonging to current role

Reference to SourceRefs belonging to current role`,
    parents: ["SignalRole"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "sourceRef", "sourceRefUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        sourceRefUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeOutputRef: {
    tag: "LNodeOutputRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to ControlRefs belonging to current role

Reference to ControlRefs belonging to current role`,
    parents: ["SignalRole"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["controlRef", "controlRefUuid", "desc"],
      details: {
        controlRef: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        controlRefUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LNodeDataRef: {
    tag: "LNodeDataRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to Data belonging to current role

Reference to Data belonging to current role`,
    parents: ["SignalRole"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["daName", "data", "desc", "doName", "lnodeUuid"],
      details: {
        daName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?(\\.[a-zA-Z][a-zA-Z0-9]*(\\([0-9]+\\))?)*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        data: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        doName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Z][0-9A-Za-z]{0,11}(\\.[a-z][0-9A-Za-z]*(\\([0-9]+\\))?)?"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  BehaviorDescriptionRef: {
    tag: "BehaviorDescriptionRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a behavior description attached to current role

Reference to a behavior description attached to current role`,
    parents: ["FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["behaviorDescription", "behaviorDescriptionUuid", "desc"],
      details: {
        behaviorDescription: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        behaviorDescriptionUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef", "InputVarRef", "OutputVarRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        InputVarRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        OutputVarRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        },
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["InputVarRef", "OutputVarRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ProcessResourceRef: {
    tag: "ProcessResourceRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a process resource attached to current role

Reference to a process resource attached to current role`,
    parents: ["FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "processResource", "processResourceUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processResource: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processResourceUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  FunctionCategoryRef: {
    tag: "FunctionCategoryRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a function category attached to current role

Reference to a function category attached to current role`,
    parents: ["FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "functionCategory", "functionCategoryUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionCategory: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        functionCategoryUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PowerSystemRelationRef: {
    tag: "PowerSystemRelationRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to a power system relation attached to current role

Reference to a power system relation attached to current role`,
    parents: ["FunctionRoleContent"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "powerSystemRelation", "powerSystemRelationUuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        powerSystemRelation: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        powerSystemRelationUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  EqSubFunction: {
    tag: "EqSubFunction",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["EqFunction", "EqSubFunction"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "GeneralEquipment", "EqSubFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        GeneralEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInGeneralEquipmentOfFuncForEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInGEFuncForEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqSubFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubFuncForEquipment",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueSubFuncForEquipment",
              kind: "unique",
              paths: [["EqSubFunction"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInSubFuncForEquipment",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueSubFuncForEquipment",
        kind: "unique",
        paths: [["EqSubFunction"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tAbstractEqFuncSubFunc",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Hitem: {
    tag: "Hitem",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["History"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["revision", "version", "what", "when", "who", "why"],
      details: {
        revision: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        version: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        what: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        when: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        who: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        why: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["SourceFiles"],
      details: {
        SourceFiles: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tAnyContentFromOtherNamespace",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  TapChanger: {
    tag: "TapChanger",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["TransformerWinding"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "name", "templateUuid", "type", "uuid", "virtual"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: "LTC",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        virtual: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Labels", "LNode", "SubEquipment", "EqFunction"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabel",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        },
        LNode: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        SubEquipment: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInSubEquipmentLTC",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInLTCSubEquipment",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        },
        EqFunction: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: [
            {
              name: "uniqueLNodeInFuncForLTC",
              kind: "unique",
              paths: [["LNode"]],
              deep: !1,
              attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
              refer: null,
              text: !1
            },
            {
              name: "uniqueChildNameInFuncForLTC",
              kind: "unique",
              paths: [["*"]],
              deep: !1,
              attributes: ["name"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNodeInTapChanger",
        kind: "unique",
        paths: [["LNode"]],
        deep: !1,
        attributes: ["lnInst", "lnClass", "iedName", "ldInst", "prefix"],
        refer: null,
        text: !1
      },
      {
        name: "uniqueChildNameInLTC",
        kind: "unique",
        paths: [["*"]],
        deep: !1,
        attributes: ["name"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tPowerSystemResource",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  NeutralPoint: {
    tag: "NeutralPoint",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["TransformerWinding"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [
        "bayName",
        "cNodeName",
        "cNodeUuid",
        "connectivityNode",
        "desc",
        "lineName",
        "name",
        "processName",
        "substationName",
        "voltageLevelName"
      ],
      details: {
        bayName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cNodeName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cNodeUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        connectivityNode: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+/.+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lineName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        name: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        processName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        substationName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        voltageLevelName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ClientLN: {
    tag: "ClientLN",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["RptEnabled"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["apRef", "desc", "iedName", "ldInst", "lnClass", "lnInst", "lnUuid", "prefix"],
      details: {
        apRef: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 0,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SGEdit: {
    tag: "SGEdit",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["SettingGroups"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["resvTms"],
      details: {
        resvTms: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  ConfSG: {
    tag: "ConfSG",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["SettingGroups"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["resvTms"],
      details: {
        resvTms: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tServiceYesNo",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  McSecurity: {
    tag: "McSecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["GSESettings", "SMVSettings"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["encryption", "signature"],
      details: {
        encryption: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        signature: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SmpRate: {
    tag: "SmpRate",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["SMVSettings"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: 0,
        maxInclusive: 4294967295,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SamplesPerSec: {
    tag: "SamplesPerSec",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["SMVSettings"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: 0,
        maxInclusive: 4294967295,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SecPerSamples: {
    tag: "SecPerSamples",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["SMVSettings"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: 0,
        maxInclusive: 4294967295,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GOOSEMcSecurity: {
    tag: "GOOSEMcSecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["ClientServices"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["encryption", "signature"],
      details: {
        encryption: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        signature: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SVMcSecurity: {
    tag: "SVMcSecurity",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["ClientServices"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["encryption", "signature"],
      details: {
        encryption: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        signature: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Authentication: {
    tag: "Authentication",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Server"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["certificate", "none", "password", "strong", "weak"],
      details: {
        certificate: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        none: {
          required: !1,
          default: "true",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        password: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        strong: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        weak: {
          required: !1,
          default: "false",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  LDevice: {
    tag: "LDevice",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Server"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "inst", "ldName", "templateUuid", "uuid"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        inst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldName: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        templateUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        uuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "LN0", "LN", "AccessControl", "Labels"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        LN0: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: 1
          },
          constraints: null
        },
        LN: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        AccessControl: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Labels: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: [
            {
              name: "uniqueLabelInLD",
              kind: "unique",
              paths: [["Label"]],
              deep: !1,
              attributes: ["id", "lang"],
              refer: null,
              text: !1
            }
          ]
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniqueLNInLDevice",
        kind: "unique",
        paths: [["LN"]],
        deep: !1,
        attributes: ["inst", "lnClass", "prefix"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Association: {
    tag: "Association",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Server"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [
        "apRef",
        "associationID",
        "desc",
        "iedName",
        "initiator",
        "kind",
        "ldInst",
        "lnClass",
        "lnInst",
        "lnUuid",
        "prefix"
      ],
      details: {
        apRef: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        associationID: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9A-Za-z]+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        iedName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [
              "[A-Za-z][0-9A-Za-z_]{0,2}",
              "[A-Za-z][0-9A-Za-z_]{4,63}",
              "[A-MO-Za-z][0-9A-Za-z_]{3}",
              "N[0-9A-Za-np-z_][0-9A-Za-z_]{2}",
              "No[0-9A-Za-mo-z_][0-9A-Za-z_]",
              "Non[0-9A-Za-df-z_]",
              "[A-Za-z][0-9A-Za-z_]*",
              "\\i\\c*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        initiator: {
          required: !1,
          default: "client",
          namespace: null,
          validation: {
            enumeration: ["client", "server"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        kind: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["pre-established", "predefined"],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnClass: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "LLN0",
              "LPHD",
              "LCCH",
              "LGOS",
              "LSVS",
              "LTIM",
              "LTMS",
              "LTRK",
              "ANCR",
              "ARCO",
              "ARIS",
              "ATCC",
              "AVCO",
              "CALH",
              "CCGR",
              "CILO",
              "CPOW",
              "CSWI",
              "CSYN",
              "FCNT",
              "FCSD",
              "FFIL",
              "FLIM",
              "FPID",
              "FRMP",
              "FSPT",
              "FXOT",
              "FXUT",
              "GAPC",
              "GGIO",
              "GLOG",
              "GSAL",
              "IARC",
              "IHMI",
              "ISAF",
              "ITCI",
              "ITMI",
              "ITPC",
              "KFAN",
              "KFIL",
              "KPMP",
              "KTNK",
              "KVLV",
              "MDIF",
              "MENV",
              "MFLK",
              "MHAI",
              "MHAN",
              "MHYD",
              "MMDC",
              "MMET",
              "MMTN",
              "MMTR",
              "MMXN",
              "MMXU",
              "MSQI",
              "MSTA",
              "PDIF",
              "PDIR",
              "PDIS",
              "PDOP",
              "PDUP",
              "PFRC",
              "PHAR",
              "PHIZ",
              "PIOC",
              "PMRI",
              "PMSS",
              "POPF",
              "PPAM",
              "PRTR",
              "PSCH",
              "PSDE",
              "PTEF",
              "PTHF",
              "PTOC",
              "PTOF",
              "PTOV",
              "PTRC",
              "PTTR",
              "PTUC",
              "PTUF",
              "PTUV",
              "PUPF",
              "PVOC",
              "PVPH",
              "PZSU",
              "QFVR",
              "QITR",
              "QIUB",
              "QVTR",
              "QVUB",
              "QVVR",
              "RADR",
              "RBDR",
              "RBRF",
              "RDIR",
              "RDRE",
              "RDRS",
              "RFLO",
              "RMXU",
              "RPSB",
              "RREC",
              "RSYN",
              "SARC",
              "SCBR",
              "SIMG",
              "SIML",
              "SLTC",
              "SOPM",
              "SPDC",
              "SPTR",
              "SSWI",
              "STMP",
              "SVBR",
              "TANG",
              "TAXD",
              "TCTR",
              "TDST",
              "TFLW",
              "TFRQ",
              "TGSN",
              "THUM",
              "TLVL",
              "TMGF",
              "TMVM",
              "TPOS",
              "TPRS",
              "TRTN",
              "TSND",
              "TTMP",
              "TTNS",
              "TVBR",
              "TVTR",
              "TWPH",
              "XCBR",
              "XSWI",
              "YEFN",
              "YLTC",
              "YPSH",
              "YPTR",
              "ZAXN",
              "ZBAT",
              "ZBSH",
              "ZCAB",
              "ZCAP",
              "ZCON",
              "ZGEN",
              "ZGIL",
              "ZLIN",
              "ZMOT",
              "ZREA",
              "ZRES",
              "ZRRC",
              "ZSAR",
              "ZSCR",
              "ZSMC",
              "ZTCF",
              "ZTCR"
            ],
            pattern: [
              "[A-Z]+",
              "L[A-Z]*",
              "LLN0",
              "\\i\\c*",
              "A[A-Z]*",
              "C[A-Z]*",
              "F[A-Z]*",
              "G[A-Z]*",
              "I[A-Z]*",
              "K[A-Z]*",
              "M[A-Z]*",
              "P[A-Z]*",
              "Q[A-Z]*",
              "R[A-Z]*",
              "S[A-Z]*",
              "T[A-Z]*",
              "X[A-Z]*",
              "Y[A-Z]*",
              "Z[A-Z]*"
            ],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9]{1,12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 0,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        lnUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        prefix: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 11,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Subject: {
    tag: "Subject",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["GOOSESecurity", "SMVSecurity"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["commonName", "idHierarchy"],
      details: {
        commonName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["none", "CN=.+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 4,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        idHierarchy: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  IssuerName: {
    tag: "IssuerName",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["GOOSESecurity", "SMVSecurity"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["commonName", "idHierarchy"],
      details: {
        commonName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["none", "CN=.+"],
            minInclusive: null,
            maxInclusive: null,
            minLength: 4,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        idHierarchy: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  Address: {
    tag: "Address",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["ConnectedAP", "GSE", "SMV"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !1,
      sequence: ["P"],
      details: {
        P: {
          required: !0,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 1,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: null,
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  GSE: {
    tag: "GSE",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["ConnectedAP"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["cbName", "cbUuid", "desc", "ldInst"],
      details: {
        cbName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Address", "MinTime", "MaxTime"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Address: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        MinTime: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        MaxTime: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlBlock",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  SMV: {
    tag: "SMV",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["ConnectedAP"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["cbName", "cbUuid", "desc", "ldInst"],
      details: {
        cbName: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z][0-9A-Za-z_]*", "\\i\\c*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 32,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        cbUuid: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "preserve",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        ldInst: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: ["[A-Za-z0-9][0-9A-Za-z_]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: 64,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "Address"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        Address: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [],
    value: {
      type: "tControlBlock",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  PhysConn: {
    tag: "PhysConn",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["ConnectedAP"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: ["desc", "type"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: ["Connection", "RedConn"],
            pattern: ["[A-Z][0-9A-Za-z\\-]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "Private", "P"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        Private: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        },
        P: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: 1,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: []
    },
    constraints: [
      {
        name: "uniquePTypeInPhysConn",
        kind: "unique",
        paths: [["P"]],
        deep: !1,
        attributes: ["type"],
        refer: null,
        text: !1
      }
    ],
    value: {
      type: "tUnNaming",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  InputVarRef: {
    tag: "InputVarRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to InputVar belonging to current behavior description

Reference to InputVar belonging to current behavior description`,
    parents: ["BehaviorDescriptionRef"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "value", "variable"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        variable: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  OutputVarRef: {
    tag: "OutputVarRef",
    namespace: {
      uri: "http://www.iec.ch/61850/2019/SCL/6-100",
      prefix: "eIEC61850-6-100"
    },
    documentation: `Reference to OutputVar belonging to current behavior description

Reference to OutputVar belonging to current behavior description`,
    parents: ["BehaviorDescriptionRef"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["desc", "value", "variable"],
      details: {
        desc: {
          required: !1,
          default: "",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        value: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        variable: {
          required: !1,
          default: null,
          namespace: null,
          validation: {
            enumeration: null,
            pattern: [".+(/.+)*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !0,
      sequence: ["Text", "FunctionalVariantRef"],
      details: {
        Text: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: 1
          },
          constraints: null
        },
        FunctionalVariantRef: {
          required: !1,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: null,
            assertions: null,
            minOccurrence: 0,
            maxOccurrence: null
          },
          constraints: null
        }
      },
      choices: [
        {
          minOccurrence: 0,
          maxOccurrence: null,
          options: ["FunctionalVariantRef"]
        }
      ]
    },
    constraints: [],
    value: {
      type: "tFunctionalVariantRefContainer",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  AccessControl: {
    tag: "AccessControl",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["LDevice"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !0,
      sequence: [],
      details: {}
    },
    subElements: {
      any: !0,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tAnyContentFromOtherNamespace",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: null,
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  P: {
    tag: "P",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["Address", "PhysConn"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["type"],
      details: {
        type: {
          required: !0,
          default: null,
          namespace: null,
          validation: {
            enumeration: [
              "IP",
              "IP-SUBNET",
              "IP-GATEWAY",
              "OSI-NSAP",
              "OSI-TSEL",
              "OSI-SSEL",
              "OSI-PSEL",
              "OSI-AP-Title",
              "OSI-AP-Invoke",
              "OSI-AE-Qualifier",
              "OSI-AE-Invoke",
              "MAC-Address",
              "APPID",
              "VLAN-PRIORITY",
              "VLAN-ID",
              "SNTP-Port",
              "MMS-Port",
              "DNSName",
              "IPv6FlowLabel",
              "IPv6ClassOfTraffic",
              "C37-118-IP-Port",
              "IP-UDP-PORT",
              "IP-TCP-PORT",
              "IPv6",
              "IPv6-SUBNET",
              "IPv6-GATEWAY",
              "IPv6-IGMPv3Src",
              "IP-IGMPv3Src",
              "IP-ClassOfTraffic"
            ],
            pattern: ["\\i\\c*", "[A-Z][0-9A-Za-z\\-]*"],
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "tPAddr",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: 1,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "replace",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MinTime: {
    tag: "MinTime",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["GSE"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["multiplier", "unit"],
      details: {
        multiplier: {
          required: !1,
          default: "m",
          namespace: null,
          validation: {
            enumeration: [
              "",
              "m",
              "k",
              "M",
              "mu",
              "y",
              "z",
              "a",
              "f",
              "p",
              "n",
              "c",
              "d",
              "da",
              "h",
              "G",
              "T",
              "P",
              "E",
              "Z",
              "Y"
            ],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unit: {
          required: !1,
          default: "s",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "decimal",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  },
  MaxTime: {
    tag: "MaxTime",
    namespace: {
      uri: "http://www.iec.ch/61850/2003/SCL",
      prefix: "scl"
    },
    documentation: null,
    parents: ["GSE"],
    validation: {
      enumeration: null,
      pattern: null,
      minInclusive: null,
      maxInclusive: null,
      minLength: null,
      maxLength: null,
      fractionDigits: null,
      totalDigits: null,
      whitespace: null,
      assertions: null,
      minOccurrence: null,
      maxOccurrence: null
    },
    attributes: {
      any: !1,
      sequence: ["multiplier", "unit"],
      details: {
        multiplier: {
          required: !1,
          default: "m",
          namespace: null,
          validation: {
            enumeration: [
              "",
              "m",
              "k",
              "M",
              "mu",
              "y",
              "z",
              "a",
              "f",
              "p",
              "n",
              "c",
              "d",
              "da",
              "h",
              "G",
              "T",
              "P",
              "E",
              "Z",
              "Y"
            ],
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "replace",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        },
        unit: {
          required: !1,
          default: "s",
          namespace: null,
          validation: {
            enumeration: null,
            pattern: null,
            minInclusive: null,
            maxInclusive: null,
            minLength: null,
            maxLength: null,
            fractionDigits: null,
            totalDigits: null,
            whitespace: "collapse",
            assertions: null,
            minOccurrence: null,
            maxOccurrence: null
          }
        }
      }
    },
    subElements: {
      any: !1,
      sequence: [],
      details: {},
      choices: []
    },
    constraints: [],
    value: {
      type: "decimal",
      validation: {
        enumeration: null,
        pattern: null,
        minInclusive: null,
        maxInclusive: null,
        minLength: null,
        maxLength: null,
        fractionDigits: null,
        totalDigits: null,
        whitespace: "collapse",
        assertions: null,
        minOccurrence: null,
        maxOccurrence: null
      }
    }
  }
}, mL = [
  "AccessControl",
  "AccessPoint",
  "Address",
  "AllocationRole",
  "AllocationRoleRef",
  "AnalogueWiringParameters",
  "AnalogueWiringParametersRef",
  "Application",
  "ApplicationSclRef",
  "Association",
  "Authentication",
  "BDA",
  "Bay",
  "BayType",
  "BehaviorDescription",
  "BehaviorDescriptionRef",
  "BehaviorReference",
  "BinaryWiringParameters",
  "BinaryWiringParametersRef",
  "BitRate",
  "CheckoutID",
  "ClientLN",
  "ClientServices",
  "CommProt",
  "Communication",
  "CommunicationServiceSpecifications",
  "ConductingEquipment",
  "ConfDataSet",
  "ConfLNs",
  "ConfLdName",
  "ConfLogControl",
  "ConfReportControl",
  "ConfSG",
  "ConfSigRef",
  "ConnectedAP",
  "ConnectivityNode",
  "ControlRef",
  "ControllingLNode",
  "DA",
  "DAI",
  "DAS",
  "DAType",
  "DO",
  "DOI",
  "DOS",
  "DOType",
  "DataObjectDirectory",
  "DataSet",
  "DataSetDirectory",
  "DataTypeTemplates",
  "DynAssociation",
  "DynDataSet",
  "EnumType",
  "EnumVal",
  "EqFunction",
  "EqSubFunction",
  "ExtCtrl",
  "ExtRef",
  "FCDA",
  "FileHandling",
  "Function",
  "FunctionCatRef",
  "FunctionCategory",
  "FunctionCategoryRef",
  "FunctionRef",
  "FunctionRole",
  "FunctionRoleContent",
  "FunctionSclRef",
  "FunctionTemplate",
  "FunctionalSubVariant",
  "FunctionalVariant",
  "FunctionalVariantGroup",
  "FunctionalVariantRef",
  "GOOSE",
  "GOOSEMcSecurity",
  "GOOSESecurity",
  "GSE",
  "GSEControl",
  "GSEDir",
  "GSESettings",
  "GSSE",
  "GeneralEquipment",
  "GetCBValues",
  "GetDataObjectDefinition",
  "GetDataSetValue",
  "GetDirectory",
  "GooseParameters",
  "GooseParametersRef",
  "Header",
  "History",
  "Hitem",
  "IED",
  "IEDName",
  "IEDSourceFiles",
  "InputVar",
  "InputVarRef",
  "Inputs",
  "IssuerName",
  "KDC",
  "L2CommParameters",
  "L3IPv4CommParameters",
  "L3IPv6CommParameters",
  "LDevice",
  "LN",
  "LN0",
  "LNode",
  "LNodeDataRef",
  "LNodeInputRef",
  "LNodeInputs",
  "LNodeOutputRef",
  "LNodeOutputs",
  "LNodeSpecNaming",
  "LNodeType",
  "Label",
  "Labels",
  "Line",
  "Log",
  "LogControl",
  "LogParameters",
  "LogParametersRef",
  "LogSettings",
  "MaxTime",
  "McSecurity",
  "MinRequestedSCDFile",
  "MinRequestedSCDFiles",
  "MinTime",
  "MultiAPPerSubNet",
  "NeutralPoint",
  "OptFields",
  "OutputVar",
  "OutputVarRef",
  "Outputs",
  "P",
  "PhysConn",
  "PowerSystemRelation",
  "PowerSystemRelationRef",
  "PowerSystemRelations",
  "PowerTransformer",
  "Private",
  "Process",
  "ProcessEcho",
  "ProcessResource",
  "ProcessResourceRef",
  "ProcessResources",
  "Project",
  "ProjectProcessReference",
  "ProtNs",
  "Protocol",
  "ReadWrite",
  "RedProt",
  "ReportControl",
  "ReportParameters",
  "ReportParametersRef",
  "ReportSettings",
  "Resource",
  "RptEnabled",
  "SCL",
  "SCSM",
  "SDI",
  "SDO",
  "SDS",
  "SGEdit",
  "SMV",
  "SMVParameters",
  "SMVParametersRef",
  "SMVSecurity",
  "SMVSettings",
  "SMVsc",
  "SVMcSecurity",
  "SampledValueControl",
  "SamplesPerSec",
  "SclFileReference",
  "SecPerSamples",
  "Security",
  "Server",
  "ServerAt",
  "ServiceSpecifications",
  "Services",
  "SetDataSetValue",
  "SettingControl",
  "SettingGroups",
  "SignalRole",
  "SmpRate",
  "SmvOpts",
  "SourceFiles",
  "SourceRef",
  "SubCategory",
  "SubCheckoutID",
  "SubEquipment",
  "SubFunction",
  "SubFunctionTemplate",
  "SubNetwork",
  "Subject",
  "SubscriberLNode",
  "Substation",
  "SupSubscription",
  "TapChanger",
  "Terminal",
  "Text",
  "TimeSyncProt",
  "TimerActivatedControl",
  "TransformerWinding",
  "TrgOps",
  "Val",
  "ValueHandling",
  "Variable",
  "VariableApplyTo",
  "VariableRef",
  "Voltage",
  "VoltageLevel"
], fL = {
  AccessControl: [],
  AccessPoint: ["name"],
  Address: [],
  AllocationRole: ["name"],
  AllocationRoleRef: [],
  AnalogueWiringParameters: ["id"],
  AnalogueWiringParametersRef: ["id"],
  Application: ["name"],
  ApplicationSclRef: [],
  Association: ["apRef", "iedName", "kind", "ldInst", "lnClass", "lnInst"],
  Authentication: [],
  BDA: ["bType", "name"],
  Bay: ["name"],
  BayType: [],
  BehaviorDescription: ["name"],
  BehaviorDescriptionRef: [],
  BehaviorReference: [],
  BinaryWiringParameters: ["id"],
  BinaryWiringParametersRef: ["id"],
  BitRate: [],
  CheckoutID: ["fileType", "revision", "version"],
  ClientLN: ["apRef", "iedName", "ldInst", "lnClass", "lnInst"],
  ClientServices: [],
  CommProt: [],
  Communication: [],
  CommunicationServiceSpecifications: [],
  ConductingEquipment: ["name", "type"],
  ConfDataSet: ["max"],
  ConfLNs: [],
  ConfLdName: [],
  ConfLogControl: ["max"],
  ConfReportControl: ["max"],
  ConfSG: [],
  ConfSigRef: ["max"],
  ConnectedAP: ["apName", "iedName"],
  ConnectivityNode: ["name", "pathName"],
  ControlRef: ["output"],
  ControllingLNode: ["outputName"],
  DA: ["bType", "fc", "name"],
  DAI: ["name"],
  DAS: ["name"],
  DAType: ["id"],
  DO: ["name", "type"],
  DOI: ["name"],
  DOS: ["name"],
  DOType: ["cdc", "id"],
  DataObjectDirectory: [],
  DataSet: ["name"],
  DataSetDirectory: [],
  DataTypeTemplates: [],
  DynAssociation: [],
  DynDataSet: ["max"],
  EnumType: ["id"],
  EnumVal: ["ord"],
  EqFunction: ["name"],
  EqSubFunction: ["name"],
  ExtCtrl: [],
  ExtRef: [],
  FCDA: ["fc"],
  FileHandling: [],
  Function: ["name"],
  FunctionCatRef: [],
  FunctionCategory: ["name"],
  FunctionCategoryRef: [],
  FunctionRef: [],
  FunctionRole: ["name"],
  FunctionRoleContent: [],
  FunctionSclRef: [],
  FunctionTemplate: ["name"],
  FunctionalSubVariant: ["name"],
  FunctionalVariant: ["name"],
  FunctionalVariantGroup: ["name"],
  FunctionalVariantRef: [],
  GOOSE: ["max"],
  GOOSEMcSecurity: [],
  GOOSESecurity: ["name", "serialNumber"],
  GSE: ["cbName", "ldInst"],
  GSEControl: ["appID", "name"],
  GSEDir: [],
  GSESettings: [],
  GSSE: ["max"],
  GeneralEquipment: ["name", "type"],
  GetCBValues: [],
  GetDataObjectDefinition: [],
  GetDataSetValue: [],
  GetDirectory: [],
  GooseParameters: ["id"],
  GooseParametersRef: ["id"],
  Header: ["id", "uuid"],
  History: [],
  Hitem: ["revision", "version", "when"],
  IED: ["name"],
  IEDName: ["apRef"],
  IEDSourceFiles: [],
  InputVar: ["varName"],
  InputVarRef: [],
  Inputs: [],
  IssuerName: ["commonName", "idHierarchy"],
  KDC: ["apName", "iedName"],
  L2CommParameters: [],
  L3IPv4CommParameters: [],
  L3IPv6CommParameters: [],
  LDevice: ["inst"],
  LN: ["inst", "lnClass", "lnType"],
  LN0: ["inst", "lnClass", "lnType"],
  LNode: ["lnClass"],
  LNodeDataRef: [],
  LNodeInputRef: [],
  LNodeInputs: [],
  LNodeOutputRef: [],
  LNodeOutputs: [],
  LNodeSpecNaming: [],
  LNodeType: ["id", "lnClass"],
  Label: ["lang"],
  Labels: [],
  Line: ["name"],
  Log: [],
  LogControl: ["logName", "name"],
  LogParameters: ["id"],
  LogParametersRef: ["id"],
  LogSettings: [],
  MaxTime: [],
  McSecurity: [],
  MinRequestedSCDFile: ["fileType", "revision", "version"],
  MinRequestedSCDFiles: [],
  MinTime: [],
  MultiAPPerSubNet: [],
  NeutralPoint: ["cNodeName", "connectivityNode"],
  OptFields: [],
  OutputVar: ["varName"],
  OutputVarRef: [],
  Outputs: [],
  P: ["type"],
  PhysConn: ["type"],
  PowerSystemRelation: ["name"],
  PowerSystemRelationRef: [],
  PowerSystemRelations: [],
  PowerTransformer: ["name", "type"],
  Private: ["type"],
  Process: ["name"],
  ProcessEcho: [],
  ProcessResource: ["name"],
  ProcessResourceRef: [],
  ProcessResources: [],
  Project: ["name"],
  ProjectProcessReference: [],
  ProtNs: [],
  Protocol: ["mustUnderstand"],
  ReadWrite: [],
  RedProt: [],
  ReportControl: ["confRev", "name"],
  ReportParameters: ["id"],
  ReportParametersRef: ["id"],
  ReportSettings: [],
  Resource: [],
  RptEnabled: [],
  SCL: ["release", "revision", "version"],
  SCSM: [],
  SDI: ["name"],
  SDO: ["name", "type"],
  SDS: ["name"],
  SGEdit: [],
  SMV: ["cbName", "ldInst"],
  SMVParameters: ["id"],
  SMVParametersRef: ["id"],
  SMVSecurity: ["name", "serialNumber"],
  SMVSettings: [],
  SMVsc: ["max"],
  SVMcSecurity: [],
  SampledValueControl: ["name", "nofASDU", "smpRate", "smvID"],
  SamplesPerSec: [],
  SclFileReference: ["fileType", "revision", "version"],
  SecPerSamples: [],
  Security: [],
  Server: [],
  ServerAt: ["apName"],
  ServiceSpecifications: [],
  Services: [],
  SetDataSetValue: [],
  SettingControl: ["numOfSGs"],
  SettingGroups: [],
  SignalRole: ["name"],
  SmpRate: [],
  SmvOpts: [],
  SourceFiles: [],
  SourceRef: ["input"],
  SubCategory: ["name"],
  SubCheckoutID: ["fileType", "revision", "version"],
  SubEquipment: ["name"],
  SubFunction: ["name"],
  SubFunctionTemplate: ["name"],
  SubNetwork: ["name"],
  Subject: ["commonName", "idHierarchy"],
  SubscriberLNode: ["inputName"],
  Substation: ["name"],
  SupSubscription: ["maxGo", "maxSv"],
  TapChanger: ["name", "type"],
  Terminal: ["cNodeName", "connectivityNode"],
  Text: [],
  TimeSyncProt: [],
  TimerActivatedControl: [],
  TransformerWinding: ["name", "type"],
  TrgOps: [],
  Val: [],
  ValueHandling: [],
  Variable: ["name"],
  VariableApplyTo: [],
  VariableRef: [],
  Voltage: ["unit"],
  VoltageLevel: ["name"]
}, dL = {
  AccessControl: {},
  AccessPoint: {
    clock: "",
    desc: "",
    kdc: "",
    name: "",
    router: "",
    templateUuid: "",
    uuid: ""
  },
  Address: {},
  AllocationRole: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  AllocationRoleRef: {
    allocationRole: "",
    allocationRoleUuid: "",
    desc: ""
  },
  AnalogueWiringParameters: {
    desc: "",
    dsgInp: "",
    fctInp: "",
    id: "",
    inpNam: "",
    inpRef: ""
  },
  AnalogueWiringParametersRef: {
    desc: "",
    id: ""
  },
  Application: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  ApplicationSclRef: {},
  Association: {
    apRef: "",
    associationID: "",
    desc: "",
    iedName: "",
    initiator: "",
    kind: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    prefix: ""
  },
  Authentication: {
    certificate: "",
    none: "",
    password: "",
    strong: "",
    weak: ""
  },
  BDA: {
    bType: "",
    count: "",
    desc: "",
    name: "",
    sAddr: "",
    type: "",
    valImport: "",
    valKind: ""
  },
  Bay: {
    desc: "",
    name: "",
    templateUuid: "",
    uuid: ""
  },
  BayType: {},
  BehaviorDescription: {
    desc: "",
    fileReference: "",
    format: "",
    isSimulation: "",
    isSpecification: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  BehaviorDescriptionRef: {
    behaviorDescription: "",
    behaviorDescriptionUuid: "",
    desc: ""
  },
  BehaviorReference: {
    behaviorReference: "",
    behaviorUuid: "",
    desc: ""
  },
  BinaryWiringParameters: {
    debTm: "",
    desc: "",
    fastOutput: "",
    id: "",
    inpNam: "",
    inpRef: "",
    outNam: "",
    outOffDl: "",
    outOnDl: "",
    outRef: "",
    outTyp: "",
    vInOff: "",
    vInOn: ""
  },
  BinaryWiringParametersRef: {
    desc: "",
    id: ""
  },
  BitRate: { multiplier: "", unit: "" },
  CheckoutID: {
    desc: "",
    engRight: "",
    fileName: "",
    fileType: "",
    fileUuid: "",
    headerId: "",
    revision: "",
    version: "",
    when: ""
  },
  ClientLN: {
    apRef: "",
    desc: "",
    iedName: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    prefix: ""
  },
  ClientServices: {
    acceptServerInitiatedAssociation: "",
    bufReport: "",
    goose: "",
    gsse: "",
    maxAttributes: "",
    maxGOOSE: "",
    maxReports: "",
    maxSMV: "",
    noIctBinding: "",
    rGOOSE: "",
    rSV: "",
    readLog: "",
    supportsLdName: "",
    sv: "",
    unbufReport: ""
  },
  CommProt: { ipv6: "" },
  Communication: { desc: "" },
  CommunicationServiceSpecifications: {
    desc: ""
  },
  ConductingEquipment: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  ConfDataSet: {
    max: "",
    maxAttributes: "",
    modify: ""
  },
  ConfLNs: { fixLnInst: "", fixPrefix: "" },
  ConfLdName: {},
  ConfLogControl: { max: "" },
  ConfReportControl: {
    bufConf: "",
    bufMode: "",
    max: "",
    maxBuf: ""
  },
  ConfSG: { resvTms: "" },
  ConfSigRef: { max: "" },
  ConnectedAP: {
    apName: "",
    apUuid: "",
    desc: "",
    iedName: "",
    redProt: ""
  },
  ConnectivityNode: {
    desc: "",
    name: "",
    pathName: "",
    templateUuid: "",
    uuid: ""
  },
  ControlRef: {
    controlled: "",
    controlledDoName: "",
    controlledLNodeUuid: "",
    desc: "",
    extCtrlAddr: "",
    extCtrlUuid: "",
    originUuid: "",
    output: "",
    outputInst: "",
    pDO: "",
    pLN: "",
    resourceName: "",
    resourceUuid: "",
    templateUuid: "",
    uuid: ""
  },
  ControllingLNode: {
    desc: "",
    outputName: "",
    pLN: "",
    resourceName: "",
    resourceUuid: ""
  },
  DA: {
    bType: "",
    count: "",
    dchg: "",
    desc: "",
    dupd: "",
    fc: "",
    name: "",
    qchg: "",
    sAddr: "",
    type: "",
    valImport: "",
    valKind: ""
  },
  DAI: {
    desc: "",
    ix: "",
    name: "",
    sAddr: "",
    valImport: "",
    valKind: ""
  },
  DAS: {
    desc: "",
    ix: "",
    mappedDaName: "",
    mappedLnUuid: "",
    name: "",
    valImport: "",
    valKind: ""
  },
  DAType: { desc: "", id: "", iedType: "" },
  DO: {
    accessControl: "",
    desc: "",
    name: "",
    transient: "",
    type: ""
  },
  DOI: {
    accessControl: "",
    desc: "",
    ix: "",
    name: ""
  },
  DOS: {
    desc: "",
    mappedDoName: "",
    mappedLnUuid: "",
    name: ""
  },
  DOType: {
    cdc: "",
    desc: "",
    id: "",
    iedType: ""
  },
  DataObjectDirectory: {},
  DataSet: {
    desc: "",
    name: "",
    templateUuid: "",
    uuid: ""
  },
  DataSetDirectory: {},
  DataTypeTemplates: {},
  DynAssociation: { max: "" },
  DynDataSet: { max: "", maxAttributes: "" },
  EnumType: { desc: "", id: "" },
  EnumVal: { desc: "", ord: "" },
  EqFunction: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  EqSubFunction: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  ExtCtrl: {
    apRef: "",
    checkInterlock: "",
    checkSynchrocheck: "",
    desc: "",
    doName: "",
    iedName: "",
    intAddr: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    pDO: "",
    pLN: "",
    prefix: "",
    templateUuid: "",
    uuid: ""
  },
  ExtRef: {
    daName: "",
    desc: "",
    doName: "",
    iedName: "",
    intAddr: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    pDA: "",
    pDO: "",
    pLN: "",
    pServT: "",
    prefix: "",
    serviceType: "",
    srcCBName: "",
    srcCBUuid: "",
    srcLDInst: "",
    srcLNClass: "",
    srcLNInst: "",
    srcPrefix: "",
    templateUuid: "",
    uuid: ""
  },
  FCDA: {
    daName: "",
    doName: "",
    fc: "",
    ix: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    prefix: ""
  },
  FileHandling: {
    ftp: "",
    ftps: "",
    mms: ""
  },
  Function: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  FunctionCatRef: {
    function: "",
    functionUuid: ""
  },
  FunctionCategory: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  FunctionCategoryRef: {
    desc: "",
    functionCategory: "",
    functionCategoryUuid: ""
  },
  FunctionRef: {
    desc: "",
    function: "",
    functionUuid: ""
  },
  FunctionRole: {
    cardinality: "",
    desc: "",
    max: "",
    name: "",
    originUuid: "",
    selector: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  FunctionRoleContent: { roleInst: "" },
  FunctionSclRef: {},
  FunctionTemplate: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  FunctionalSubVariant: {
    desc: "",
    isBaseline: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  FunctionalVariant: {
    desc: "",
    isBaseline: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  FunctionalVariantGroup: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  FunctionalVariantRef: {
    functionalVariant: "",
    functionalVariantUuid: "",
    update: ""
  },
  GOOSE: {
    fixedOffs: "",
    goose: "",
    max: "",
    rGOOSE: ""
  },
  GOOSEMcSecurity: {
    encryption: "",
    signature: ""
  },
  GOOSESecurity: {
    desc: "",
    name: "",
    serialNumber: "",
    templateUuid: "",
    uuid: "",
    xferNumber: ""
  },
  GSE: {
    cbName: "",
    cbUuid: "",
    desc: "",
    ldInst: ""
  },
  GSEControl: {
    appID: "",
    confRev: "",
    datSet: "",
    desc: "",
    fixedOffs: "",
    name: "",
    securityEnable: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  GSEDir: {},
  GSESettings: {
    appID: "",
    cbName: "",
    datSet: "",
    dataLabel: "",
    kdaParticipant: ""
  },
  GSSE: { max: "" },
  GeneralEquipment: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  GetCBValues: {},
  GetDataObjectDefinition: {},
  GetDataSetValue: {},
  GetDirectory: {},
  GooseParameters: {
    cbName: "",
    desc: "",
    dsName: "",
    goId: "",
    id: "",
    maxTime: "",
    minTime: "",
    securityEnabled: ""
  },
  GooseParametersRef: {
    desc: "",
    id: ""
  },
  Header: {
    baseUuid: "",
    fileType: "",
    id: "",
    nameStructure: "",
    revision: "",
    toolID: "",
    uuid: "",
    version: ""
  },
  History: {},
  Hitem: {
    revision: "",
    version: "",
    what: "",
    when: "",
    who: "",
    why: ""
  },
  IED: {
    configVersion: "",
    desc: "",
    engRight: "",
    manufacturer: "",
    name: "",
    originalSclRelease: "",
    originalSclRevision: "",
    originalSclVersion: "",
    owner: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  IEDName: {
    apRef: "",
    apUuid: "",
    ldInst: "",
    ldUuid: "",
    lnClass: "",
    lnInst: "",
    lnUuid: "",
    prefix: ""
  },
  IEDSourceFiles: {},
  InputVar: {
    daName: "",
    dataName: "",
    desc: "",
    doName: "",
    inputName: "",
    inputUuid: "",
    lnodeUuid: "",
    value: "",
    varName: ""
  },
  InputVarRef: {
    desc: "",
    value: "",
    variable: ""
  },
  Inputs: { desc: "" },
  IssuerName: { commonName: "", idHierarchy: "" },
  KDC: { apName: "", apUuid: "", iedName: "" },
  L2CommParameters: {
    appId: "",
    desc: "",
    macAddr: "",
    vlanId: "",
    vlanPriority: ""
  },
  L3IPv4CommParameters: {
    IPv4: "",
    "IPv4-IGMPv3Src": "",
    appId: "",
    desc: "",
    vlanId: "",
    vlanPriority: ""
  },
  L3IPv6CommParameters: {
    IPv6: "",
    "IPv6-IGMPv3Src": "",
    appId: "",
    desc: "",
    vlanId: "",
    vlanPriority: ""
  },
  LDevice: {
    desc: "",
    inst: "",
    ldName: "",
    templateUuid: "",
    uuid: ""
  },
  LN: {
    desc: "",
    inst: "",
    lnClass: "",
    lnType: "",
    prefix: "",
    templateUuid: "",
    uuid: ""
  },
  LN0: {
    desc: "",
    inst: "",
    lnClass: "",
    lnType: "",
    templateUuid: "",
    uuid: ""
  },
  LNode: {
    desc: "",
    iedName: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    lnType: "",
    lnUuid: "",
    prefix: "",
    templateUuid: "",
    uuid: ""
  },
  LNodeDataRef: {
    daName: "",
    data: "",
    desc: "",
    doName: "",
    lnodeUuid: ""
  },
  LNodeInputRef: {
    desc: "",
    sourceRef: "",
    sourceRefUuid: ""
  },
  LNodeInputs: { desc: "" },
  LNodeOutputRef: {
    controlRef: "",
    controlRefUuid: "",
    desc: ""
  },
  LNodeOutputs: { desc: "" },
  LNodeSpecNaming: {
    sIedName: "",
    sLdInst: "",
    sLnClass: "",
    sLnInst: "",
    sPrefix: ""
  },
  LNodeType: {
    desc: "",
    id: "",
    iedType: "",
    lnClass: ""
  },
  Label: { id: "", lang: "" },
  Labels: { desc: "" },
  Line: {
    desc: "",
    name: "",
    nomFreq: "",
    numPhases: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  Log: { desc: "", name: "" },
  LogControl: {
    bufTime: "",
    datSet: "",
    desc: "",
    intgPd: "",
    ldInst: "",
    lnClass: "",
    lnInst: "",
    logEna: "",
    logName: "",
    name: "",
    prefix: "",
    reasonCode: "",
    templateUuid: "",
    uuid: ""
  },
  LogParameters: {
    cbName: "",
    desc: "",
    dsName: "",
    id: "",
    intgPd: "",
    logEna: "",
    logLdInst: "",
    logLnClass: "",
    logLnInst: "",
    logName: "",
    logPrefix: "",
    reasonCode: ""
  },
  LogParametersRef: { desc: "", id: "" },
  LogSettings: {
    cbName: "",
    datSet: "",
    intgPd: "",
    logEna: "",
    trgOps: ""
  },
  MaxTime: { multiplier: "", unit: "" },
  McSecurity: { encryption: "", signature: "" },
  MinRequestedSCDFile: {
    desc: "",
    fileName: "",
    fileType: "",
    fileUuid: "",
    revision: "",
    version: "",
    when: ""
  },
  MinRequestedSCDFiles: {},
  MinTime: { multiplier: "", unit: "" },
  MultiAPPerSubNet: {},
  NeutralPoint: {
    bayName: "",
    cNodeName: "",
    cNodeUuid: "",
    connectivityNode: "",
    desc: "",
    lineName: "",
    name: "",
    processName: "",
    substationName: "",
    voltageLevelName: ""
  },
  OptFields: {
    bufOvfl: "",
    configRef: "",
    dataRef: "",
    dataSet: "",
    entryID: "",
    reasonCode: "",
    seqNum: "",
    timeStamp: ""
  },
  OutputVar: {
    daName: "",
    dataName: "",
    desc: "",
    doName: "",
    lnodeUuid: "",
    outputName: "",
    outputUuid: "",
    value: "",
    varName: ""
  },
  OutputVarRef: {
    desc: "",
    value: "",
    variable: ""
  },
  Outputs: { desc: "" },
  P: { type: "" },
  PhysConn: { desc: "", type: "" },
  PowerSystemRelation: {
    desc: "",
    name: "",
    originUuid: "",
    relation: "",
    relationUuid: "",
    selector: "",
    templateUuid: "",
    uuid: ""
  },
  PowerSystemRelationRef: {
    desc: "",
    powerSystemRelation: "",
    powerSystemRelationUuid: ""
  },
  PowerSystemRelations: { desc: "" },
  PowerTransformer: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  Private: { source: "", type: "" },
  Process: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  ProcessEcho: {
    desc: "",
    source: "",
    sourceDaName: "",
    sourceDoName: "",
    sourceLNodeUuid: ""
  },
  ProcessResource: {
    cardinality: "",
    desc: "",
    max: "",
    name: "",
    originUuid: "",
    selector: "",
    templateUuid: "",
    uuid: ""
  },
  ProcessResourceRef: {
    desc: "",
    processResource: "",
    processResourceUuid: ""
  },
  ProcessResources: { desc: "" },
  Project: {
    desc: "",
    name: "",
    uuid: ""
  },
  ProjectProcessReference: {
    desc: "",
    processReference: "",
    processUuid: ""
  },
  ProtNs: { type: "" },
  Protocol: { mustUnderstand: "" },
  ReadWrite: {},
  RedProt: { hsr: "", prp: "", rstp: "" },
  ReportControl: {
    bufTime: "",
    buffered: "",
    confRev: "",
    datSet: "",
    desc: "",
    indexed: "",
    intgPd: "",
    name: "",
    rptID: "",
    templateUuid: "",
    uuid: ""
  },
  ReportParameters: {
    bufTime: "",
    buffered: "",
    cbName: "",
    desc: "",
    dsName: "",
    id: "",
    intgPd: ""
  },
  ReportParametersRef: {
    desc: "",
    id: ""
  },
  ReportSettings: {
    bufTime: "",
    cbName: "",
    datSet: "",
    intgPd: "",
    optFields: "",
    owner: "",
    resvTms: "",
    rptID: "",
    trgOps: ""
  },
  Resource: {
    resInst: "",
    source: "",
    sourceUuid: ""
  },
  RptEnabled: { desc: "", max: "" },
  SCL: {
    release: "",
    revision: "",
    version: ""
  },
  SCSM: {
    iec61850_8_1: "",
    iec61850_8_2: "",
    serverAssociationInitiation: ""
  },
  SDI: {
    desc: "",
    ix: "",
    name: "",
    sAddr: ""
  },
  SDO: {
    count: "",
    desc: "",
    name: "",
    type: ""
  },
  SDS: {
    desc: "",
    ix: "",
    mappedDoName: "",
    mappedLnUuid: "",
    name: ""
  },
  SGEdit: { resvTms: "" },
  SMV: {
    cbName: "",
    cbUuid: "",
    desc: "",
    ldInst: ""
  },
  SMVParameters: {
    cbName: "",
    desc: "",
    dsName: "",
    id: "",
    multicast: "",
    nofASDU: "",
    securityEnabled: "",
    smpMod: "",
    smpRate: "",
    smvId: ""
  },
  SMVParametersRef: { desc: "", id: "" },
  SMVSecurity: {
    desc: "",
    name: "",
    serialNumber: "",
    templateUuid: "",
    uuid: "",
    xferNumber: ""
  },
  SMVSettings: {
    cbName: "",
    datSet: "",
    kdaParticipant: "",
    nofASDU: "",
    optFields: "",
    pdcTimeStamp: "",
    samplesPerSec: "",
    smpRate: "",
    svID: "",
    synchSrcId: ""
  },
  SMVsc: {
    delivery: "",
    deliveryConf: "",
    max: "",
    rSV: "",
    sv: ""
  },
  SVMcSecurity: {
    encryption: "",
    signature: ""
  },
  SampledValueControl: {
    confRev: "",
    datSet: "",
    desc: "",
    multicast: "",
    name: "",
    nofASDU: "",
    securityEnable: "",
    smpMod: "",
    smpRate: "",
    smvID: "",
    templateUuid: "",
    uuid: ""
  },
  SamplesPerSec: {},
  SclFileReference: {
    desc: "",
    fileName: "",
    fileType: "",
    fileUuid: "",
    revision: "",
    version: "",
    when: ""
  },
  SecPerSamples: {},
  Security: {
    ACSEAuthentication: "",
    E2ESecurity: ""
  },
  Server: { desc: "", timeout: "" },
  ServerAt: {
    apName: "",
    apUuid: "",
    desc: ""
  },
  ServiceSpecifications: { desc: "" },
  Services: { nameLength: "" },
  SetDataSetValue: {},
  SettingControl: {
    actSG: "",
    desc: "",
    numOfSGs: "",
    resvTms: ""
  },
  SettingGroups: {},
  SignalRole: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  SmpRate: {},
  SmvOpts: {
    dataSet: "",
    refreshTime: "",
    sampleMode: "",
    sampleRate: "",
    sampleSynchronized: "",
    security: "",
    synchSourceId: "",
    timestamp: ""
  },
  SourceFiles: {},
  SourceRef: {
    desc: "",
    extRefAddr: "",
    extRefUuid: "",
    input: "",
    inputInst: "",
    originUuid: "",
    pDA: "",
    pDO: "",
    pLN: "",
    resourceName: "",
    resourceUuid: "",
    service: "",
    source: "",
    sourceDaName: "",
    sourceDoName: "",
    sourceLNodeUuid: "",
    templateUuid: "",
    uuid: ""
  },
  SubCategory: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: ""
  },
  SubCheckoutID: {
    desc: "",
    engRight: "",
    fileName: "",
    fileType: "",
    fileUuid: "",
    headerId: "",
    revision: "",
    version: "",
    when: ""
  },
  SubEquipment: {
    desc: "",
    name: "",
    phase: "",
    templateUuid: "",
    uuid: "",
    virtual: ""
  },
  SubFunction: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  SubFunctionTemplate: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  SubNetwork: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: ""
  },
  Subject: { commonName: "", idHierarchy: "" },
  SubscriberLNode: {
    desc: "",
    inputName: "",
    pLN: "",
    resourceName: "",
    resourceUuid: "",
    service: ""
  },
  Substation: {
    desc: "",
    name: "",
    templateUuid: "",
    uuid: ""
  },
  SupSubscription: { maxGo: "", maxSv: "" },
  TapChanger: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  Terminal: {
    bayName: "",
    cNodeName: "",
    cNodeUuid: "",
    connectivityNode: "",
    desc: "",
    lineName: "",
    name: "",
    processName: "",
    substationName: "",
    voltageLevelName: ""
  },
  Text: { source: "" },
  TimeSyncProt: {
    c37_238: "",
    iec61850_9_3: "",
    other: "",
    sntp: ""
  },
  TimerActivatedControl: {},
  TransformerWinding: {
    desc: "",
    name: "",
    templateUuid: "",
    type: "",
    uuid: "",
    virtual: ""
  },
  TrgOps: {
    dchg: "",
    dupd: "",
    gi: "",
    period: "",
    qchg: ""
  },
  Val: { sGroup: "" },
  ValueHandling: { setToRO: "" },
  Variable: {
    desc: "",
    name: "",
    originUuid: "",
    templateUuid: "",
    uuid: "",
    value: ""
  },
  VariableApplyTo: {
    attribute: "",
    daName: "",
    defaultValue: "",
    desc: "",
    doName: "",
    element: "",
    elementUuid: "",
    format: "",
    sGroup: ""
  },
  VariableRef: {
    desc: "",
    value: "",
    variable: "",
    variableUuid: ""
  },
  Voltage: { multiplier: "", unit: "" },
  VoltageLevel: {
    desc: "",
    name: "",
    nomFreq: "",
    numPhases: "",
    templateUuid: "",
    uuid: ""
  }
}, pL = {
  AccessControl: [],
  AccessPoint: [
    "Text",
    "Private",
    "Server",
    "LN",
    "ServerAt",
    "Services",
    "GOOSESecurity",
    "SMVSecurity",
    "Labels"
  ],
  Address: ["P"],
  AllocationRole: ["Text", "FunctionRef"],
  AllocationRoleRef: ["Text", "FunctionalVariantRef"],
  AnalogueWiringParameters: ["Text"],
  AnalogueWiringParametersRef: ["Text"],
  Application: [
    "Text",
    "FunctionRole",
    "FunctionalVariant",
    "FunctionalVariantGroup",
    "AllocationRoleRef",
    "ApplicationSclRef"
  ],
  ApplicationSclRef: ["Text", "SclFileReference"],
  Association: [],
  Authentication: [],
  BDA: ["Text", "Private", "Val", "Labels"],
  Bay: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "PowerTransformer",
    "GeneralEquipment",
    "ConductingEquipment",
    "ConnectivityNode",
    "Function"
  ],
  BayType: [],
  BehaviorDescription: ["Text", "InputVar", "OutputVar", "BehaviorReference"],
  BehaviorDescriptionRef: ["Text", "FunctionalVariantRef", "InputVarRef", "OutputVarRef"],
  BehaviorReference: ["Text"],
  BinaryWiringParameters: ["Text"],
  BinaryWiringParametersRef: ["Text"],
  BitRate: [],
  CheckoutID: ["SubCheckoutID"],
  ClientLN: [],
  ClientServices: ["TimeSyncProt", "GOOSEMcSecurity", "SVMcSecurity", "Security"],
  CommProt: [],
  Communication: ["Text", "Private", "SubNetwork"],
  CommunicationServiceSpecifications: [
    "Text",
    "GooseParameters",
    "SMVParameters",
    "ReportParameters"
  ],
  ConductingEquipment: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "Terminal",
    "SubEquipment",
    "EqFunction"
  ],
  ConfDataSet: [],
  ConfLNs: [],
  ConfLdName: [],
  ConfLogControl: [],
  ConfReportControl: [],
  ConfSG: [],
  ConfSigRef: [],
  ConnectedAP: ["Text", "Private", "Address", "GSE", "SMV", "PhysConn"],
  ConnectivityNode: ["Text", "Private", "Labels", "LNode"],
  ControlRef: ["Text", "BinaryWiringParametersRef", "AnalogueWiringParametersRef"],
  ControllingLNode: ["Text", "BinaryWiringParametersRef", "AnalogueWiringParametersRef"],
  DA: ["Text", "Private", "Val", "Labels", "ProtNs"],
  DAI: ["Text", "Private", "Val", "Labels"],
  DAS: [
    "Text",
    "SubscriberLNode",
    "ControllingLNode",
    "ProcessEcho",
    "LogParametersRef",
    "Val",
    "Labels"
  ],
  DAType: ["Text", "Private", "BDA", "ProtNs", "Labels"],
  DO: ["Text", "Private", "Labels"],
  DOI: ["Text", "Private", "SDI", "DAI", "Labels"],
  DOS: [
    "Text",
    "SDS",
    "DAS",
    "SubscriberLNode",
    "ControllingLNode",
    "ProcessEcho",
    "LogParametersRef",
    "Labels"
  ],
  DOType: ["Text", "Private", "SDO", "DA", "Labels"],
  DataObjectDirectory: [],
  DataSet: ["Text", "Private", "FCDA"],
  DataSetDirectory: [],
  DataTypeTemplates: ["LNodeType", "DOType", "DAType", "EnumType"],
  DynAssociation: [],
  DynDataSet: [],
  EnumType: ["Text", "Private", "EnumVal"],
  EnumVal: [],
  EqFunction: ["Text", "Private", "Labels", "LNode", "GeneralEquipment", "EqSubFunction"],
  EqSubFunction: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "GeneralEquipment",
    "EqSubFunction"
  ],
  ExtCtrl: ["Text", "Private"],
  ExtRef: ["Text", "Private"],
  FCDA: [],
  FileHandling: [],
  Function: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "SubFunction",
    "GeneralEquipment",
    "ConductingEquipment"
  ],
  FunctionCatRef: ["Text"],
  FunctionCategory: ["Text", "SubCategory", "FunctionCatRef"],
  FunctionCategoryRef: ["Text", "FunctionalVariantRef"],
  FunctionRef: ["Text", "FunctionalVariantRef", "SignalRole"],
  FunctionRole: ["Text", "FunctionalVariantRef", "FunctionRoleContent"],
  FunctionRoleContent: [
    "Text",
    "FunctionRef",
    "BehaviorDescriptionRef",
    "ProcessResourceRef",
    "VariableRef",
    "FunctionCategoryRef",
    "PowerSystemRelationRef"
  ],
  FunctionSclRef: ["Text", "SclFileReference"],
  FunctionTemplate: [
    "Text",
    "LNode",
    "SubFunctionTemplate",
    "GeneralEquipment",
    "ConductingEquipment"
  ],
  FunctionalSubVariant: ["Text", "FunctionalSubVariant", "VariableRef"],
  FunctionalVariant: ["Text", "FunctionalSubVariant", "VariableRef"],
  FunctionalVariantGroup: ["Text", "FunctionalVariant"],
  FunctionalVariantRef: ["Text"],
  GOOSE: [],
  GOOSEMcSecurity: [],
  GOOSESecurity: ["Text", "Private", "Labels", "Subject", "IssuerName"],
  GSE: ["Text", "Private", "Address", "MinTime", "MaxTime"],
  GSEControl: ["Text", "Private", "IEDName", "Protocol"],
  GSEDir: [],
  GSESettings: ["McSecurity"],
  GSSE: [],
  GeneralEquipment: ["Text", "Private", "Labels", "LNode", "EqFunction"],
  GetCBValues: [],
  GetDataObjectDefinition: [],
  GetDataSetValue: [],
  GetDirectory: [],
  GooseParameters: [
    "Text",
    "L2CommParameters",
    "L3IPv4CommParameters",
    "L3IPv6CommParameters"
  ],
  GooseParametersRef: ["Text"],
  Header: ["Text", "History", "SourceFiles"],
  History: ["Hitem"],
  Hitem: ["SourceFiles"],
  IED: [
    "Text",
    "Private",
    "Services",
    "AccessPoint",
    "KDC",
    "IEDSourceFiles",
    "MinRequestedSCDFiles",
    "Labels"
  ],
  IEDName: [],
  IEDSourceFiles: ["Text", "Private", "SclFileReference"],
  InputVar: ["Text"],
  InputVarRef: ["Text", "FunctionalVariantRef"],
  Inputs: ["Text", "Private", "ExtRef"],
  IssuerName: [],
  KDC: [],
  L2CommParameters: ["Text"],
  L3IPv4CommParameters: ["Text"],
  L3IPv6CommParameters: ["Text"],
  LDevice: ["Text", "Private", "LN0", "LN", "AccessControl", "Labels"],
  LN: [
    "Text",
    "Private",
    "DataSet",
    "ReportControl",
    "LogControl",
    "DOI",
    "Inputs",
    "Outputs",
    "Log",
    "Labels"
  ],
  LN0: [
    "Text",
    "Private",
    "DataSet",
    "ReportControl",
    "LogControl",
    "DOI",
    "Inputs",
    "Outputs",
    "Log",
    "Labels",
    "GSEControl",
    "SampledValueControl",
    "SettingControl"
  ],
  LNode: ["Text", "Private", "Labels"],
  LNodeDataRef: ["Text", "FunctionalVariantRef"],
  LNodeInputRef: ["Text", "FunctionalVariantRef"],
  LNodeInputs: ["Text", "SourceRef"],
  LNodeOutputRef: ["Text", "FunctionalVariantRef"],
  LNodeOutputs: ["Text", "ControlRef"],
  LNodeSpecNaming: ["Text"],
  LNodeType: ["Text", "Private", "DO", "Labels"],
  Label: [],
  Labels: ["Text", "Private", "Label"],
  Line: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "GeneralEquipment",
    "Function",
    "Voltage",
    "ConductingEquipment",
    "ConnectivityNode"
  ],
  Log: ["Text", "Private"],
  LogControl: ["Text", "Private", "TrgOps"],
  LogParameters: ["Text"],
  LogParametersRef: ["Text"],
  LogSettings: [],
  MaxTime: [],
  McSecurity: [],
  MinRequestedSCDFile: [],
  MinRequestedSCDFiles: ["Text", "Private", "MinRequestedSCDFile"],
  MinTime: [],
  MultiAPPerSubNet: [],
  NeutralPoint: ["Text", "Private"],
  OptFields: [],
  OutputVar: ["Text"],
  OutputVarRef: ["Text", "FunctionalVariantRef"],
  Outputs: ["Text", "Private", "ExtCtrl"],
  P: [],
  PhysConn: ["Text", "Private", "P"],
  PowerSystemRelation: ["Text"],
  PowerSystemRelationRef: ["Text", "FunctionalVariantRef"],
  PowerSystemRelations: ["Text", "PowerSystemRelation"],
  PowerTransformer: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "TransformerWinding",
    "SubEquipment",
    "EqFunction"
  ],
  Private: [],
  Process: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "GeneralEquipment",
    "Function",
    "ConductingEquipment",
    "Substation",
    "Line",
    "Process"
  ],
  ProcessEcho: ["Text"],
  ProcessResource: ["Text", "Resource"],
  ProcessResourceRef: ["Text", "FunctionalVariantRef"],
  ProcessResources: ["Text", "ProcessResource"],
  Project: ["Text", "ProjectProcessReference"],
  ProjectProcessReference: ["Text"],
  ProtNs: [],
  Protocol: [],
  ReadWrite: [],
  RedProt: [],
  ReportControl: ["Text", "Private", "TrgOps", "OptFields", "RptEnabled"],
  ReportParameters: ["Text"],
  ReportParametersRef: ["Text"],
  ReportSettings: [],
  Resource: [],
  RptEnabled: ["Text", "Private", "ClientLN"],
  SCL: [
    "Text",
    "Private",
    "Header",
    "Substation",
    "Communication",
    "IED",
    "DataTypeTemplates",
    "Line",
    "Process"
  ],
  SCSM: [],
  SDI: ["Text", "Private", "SDI", "DAI", "Labels"],
  SDO: ["Text", "Private", "Labels"],
  SDS: [
    "Text",
    "SDS",
    "DAS",
    "SubscriberLNode",
    "ControllingLNode",
    "ProcessEcho",
    "LogParametersRef",
    "Labels"
  ],
  SGEdit: [],
  SMV: ["Text", "Private", "Address"],
  SMVParameters: [
    "Text",
    "L2CommParameters",
    "L3IPv4CommParameters",
    "L3IPv6CommParameters"
  ],
  SMVParametersRef: ["Text"],
  SMVSecurity: ["Text", "Private", "Labels", "Subject", "IssuerName"],
  SMVSettings: ["SmpRate", "SamplesPerSec", "SecPerSamples", "McSecurity"],
  SMVsc: [],
  SVMcSecurity: [],
  SampledValueControl: ["Text", "Private", "IEDName", "SmvOpts", "Protocol"],
  SamplesPerSec: [],
  SclFileReference: ["Text", "Private"],
  SecPerSamples: [],
  Security: [],
  Server: ["Text", "Private", "Authentication", "LDevice", "Association"],
  ServerAt: ["Text", "Private"],
  ServiceSpecifications: [
    "Text",
    "GooseParameters",
    "SMVParameters",
    "ReportParameters",
    "BinaryWiringParameters",
    "AnalogueWiringParameters",
    "LogParameters"
  ],
  Services: [
    "DynAssociation",
    "SettingGroups",
    "GetDirectory",
    "GetDataObjectDefinition",
    "DataObjectDirectory",
    "GetDataSetValue",
    "SetDataSetValue",
    "DataSetDirectory",
    "ConfDataSet",
    "DynDataSet",
    "ReadWrite",
    "TimerActivatedControl",
    "ConfReportControl",
    "GetCBValues",
    "ConfLogControl",
    "ReportSettings",
    "LogSettings",
    "GSESettings",
    "SMVSettings",
    "GSEDir",
    "GOOSE",
    "GSSE",
    "SMVsc",
    "FileHandling",
    "ConfLNs",
    "ClientServices",
    "ConfLdName",
    "SupSubscription",
    "ConfSigRef",
    "ValueHandling",
    "RedProt",
    "TimeSyncProt",
    "CommProt",
    "SCSM",
    "Security",
    "MultiAPPerSubNet"
  ],
  SetDataSetValue: [],
  SettingControl: ["Text", "Private"],
  SettingGroups: ["SGEdit", "ConfSG"],
  SignalRole: [
    "Text",
    "FunctionalVariantRef",
    "LNodeInputRef",
    "LNodeOutputRef",
    "LNodeDataRef"
  ],
  SmpRate: [],
  SmvOpts: [],
  SourceFiles: ["Text", "Private", "SclFileReference"],
  SourceRef: [
    "Text",
    "GooseParametersRef",
    "SMVParametersRef",
    "ReportParametersRef",
    "BinaryWiringParametersRef",
    "AnalogueWiringParametersRef"
  ],
  SubCategory: ["Text", "SubCategory", "FunctionCatRef"],
  SubCheckoutID: ["SubCheckoutID"],
  SubEquipment: ["Text", "Private", "Labels", "LNode", "EqFunction"],
  SubFunction: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "GeneralEquipment",
    "ConductingEquipment",
    "SubFunction"
  ],
  SubFunctionTemplate: [
    "Text",
    "LNode",
    "GeneralEquipment",
    "ConductingEquipment",
    "SubFunctionTemplate"
  ],
  SubNetwork: ["Text", "Private", "Labels", "BitRate", "ConnectedAP"],
  Subject: [],
  SubscriberLNode: [
    "Text",
    "GooseParametersRef",
    "SMVParametersRef",
    "ReportParametersRef",
    "BinaryWiringParametersRef"
  ],
  Substation: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "PowerTransformer",
    "GeneralEquipment",
    "VoltageLevel",
    "Function"
  ],
  SupSubscription: [],
  TapChanger: ["Text", "Private", "Labels", "LNode", "SubEquipment", "EqFunction"],
  Terminal: ["Text", "Private"],
  Text: [],
  TimeSyncProt: [],
  TimerActivatedControl: [],
  TransformerWinding: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "Terminal",
    "SubEquipment",
    "TapChanger",
    "NeutralPoint",
    "EqFunction"
  ],
  TrgOps: [],
  Val: [],
  ValueHandling: [],
  Variable: ["Text", "VariableApplyTo"],
  VariableApplyTo: ["Text"],
  VariableRef: ["Text", "FunctionalVariantRef"],
  Voltage: [],
  VoltageLevel: [
    "Text",
    "Private",
    "Labels",
    "LNode",
    "PowerTransformer",
    "GeneralEquipment",
    "Voltage",
    "Bay",
    "Function"
  ]
}, hL = {
  AccessControl: ["LDevice"],
  AccessPoint: ["IED"],
  Address: ["ConnectedAP", "GSE", "SMV"],
  AllocationRole: [],
  AllocationRoleRef: ["Application"],
  AnalogueWiringParameters: ["ServiceSpecifications"],
  AnalogueWiringParametersRef: ["ControlRef", "ControllingLNode", "SourceRef"],
  Application: [],
  ApplicationSclRef: ["Application"],
  Association: ["Server"],
  Authentication: ["Server"],
  BDA: ["DAType"],
  Bay: ["VoltageLevel"],
  BayType: [],
  BehaviorDescription: [],
  BehaviorDescriptionRef: ["FunctionRoleContent"],
  BehaviorReference: ["BehaviorDescription"],
  BinaryWiringParameters: ["ServiceSpecifications"],
  BinaryWiringParametersRef: [
    "ControlRef",
    "ControllingLNode",
    "SourceRef",
    "SubscriberLNode"
  ],
  BitRate: ["SubNetwork"],
  CheckoutID: [],
  ClientLN: ["RptEnabled"],
  ClientServices: ["Services"],
  CommProt: ["Services"],
  Communication: ["SCL"],
  CommunicationServiceSpecifications: [],
  ConductingEquipment: [
    "Bay",
    "Function",
    "FunctionTemplate",
    "Line",
    "Process",
    "SubFunction",
    "SubFunctionTemplate"
  ],
  ConfDataSet: ["Services"],
  ConfLNs: ["Services"],
  ConfLdName: ["Services"],
  ConfLogControl: ["Services"],
  ConfReportControl: ["Services"],
  ConfSG: ["SettingGroups"],
  ConfSigRef: ["Services"],
  ConnectedAP: ["SubNetwork"],
  ConnectivityNode: ["Bay", "Line"],
  ControlRef: ["LNodeOutputs"],
  ControllingLNode: ["DAS", "DOS", "SDS"],
  DA: ["DOType"],
  DAI: ["DOI", "SDI"],
  DAS: ["DOS", "SDS"],
  DAType: ["DataTypeTemplates"],
  DO: ["LNodeType"],
  DOI: ["LN", "LN0"],
  DOS: [],
  DOType: ["DataTypeTemplates"],
  DataObjectDirectory: ["Services"],
  DataSet: ["LN", "LN0"],
  DataSetDirectory: ["Services"],
  DataTypeTemplates: ["SCL"],
  DynAssociation: ["Services"],
  DynDataSet: ["Services"],
  EnumType: ["DataTypeTemplates"],
  EnumVal: ["EnumType"],
  EqFunction: [
    "ConductingEquipment",
    "GeneralEquipment",
    "PowerTransformer",
    "SubEquipment",
    "TapChanger",
    "TransformerWinding"
  ],
  EqSubFunction: ["EqFunction", "EqSubFunction"],
  ExtCtrl: ["Outputs"],
  ExtRef: ["Inputs"],
  FCDA: ["DataSet"],
  FileHandling: ["Services"],
  Function: ["Bay", "Line", "Process", "Substation", "VoltageLevel"],
  FunctionCatRef: ["FunctionCategory", "SubCategory"],
  FunctionCategory: [],
  FunctionCategoryRef: ["FunctionRoleContent"],
  FunctionRef: ["AllocationRole", "FunctionRoleContent"],
  FunctionRole: ["Application"],
  FunctionRoleContent: ["FunctionRole"],
  FunctionSclRef: [],
  FunctionTemplate: [],
  FunctionalSubVariant: ["FunctionalSubVariant", "FunctionalVariant"],
  FunctionalVariant: ["Application", "FunctionalVariantGroup"],
  FunctionalVariantGroup: ["Application"],
  FunctionalVariantRef: [
    "AllocationRoleRef",
    "BehaviorDescriptionRef",
    "FunctionCategoryRef",
    "FunctionRef",
    "FunctionRole",
    "InputVarRef",
    "LNodeDataRef",
    "LNodeInputRef",
    "LNodeOutputRef",
    "OutputVarRef",
    "PowerSystemRelationRef",
    "ProcessResourceRef",
    "SignalRole",
    "VariableRef"
  ],
  GOOSE: ["Services"],
  GOOSEMcSecurity: ["ClientServices"],
  GOOSESecurity: ["AccessPoint"],
  GSE: ["ConnectedAP"],
  GSEControl: ["LN0"],
  GSEDir: ["Services"],
  GSESettings: ["Services"],
  GSSE: ["Services"],
  GeneralEquipment: [
    "Bay",
    "EqFunction",
    "EqSubFunction",
    "Function",
    "FunctionTemplate",
    "Line",
    "Process",
    "SubFunction",
    "SubFunctionTemplate",
    "Substation",
    "VoltageLevel"
  ],
  GetCBValues: ["Services"],
  GetDataObjectDefinition: ["Services"],
  GetDataSetValue: ["Services"],
  GetDirectory: ["Services"],
  GooseParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
  GooseParametersRef: ["SourceRef", "SubscriberLNode"],
  Header: ["SCL"],
  History: ["Header"],
  Hitem: ["History"],
  IED: ["SCL"],
  IEDName: ["GSEControl", "SampledValueControl"],
  IEDSourceFiles: ["IED"],
  InputVar: ["BehaviorDescription"],
  InputVarRef: ["BehaviorDescriptionRef"],
  Inputs: ["LN", "LN0"],
  IssuerName: ["GOOSESecurity", "SMVSecurity"],
  KDC: ["IED"],
  L2CommParameters: ["GooseParameters", "SMVParameters"],
  L3IPv4CommParameters: ["GooseParameters", "SMVParameters"],
  L3IPv6CommParameters: ["GooseParameters", "SMVParameters"],
  LDevice: ["Server"],
  LN: ["AccessPoint", "LDevice"],
  LN0: ["LDevice"],
  LNode: [
    "Bay",
    "ConductingEquipment",
    "ConnectivityNode",
    "EqFunction",
    "EqSubFunction",
    "Function",
    "FunctionTemplate",
    "GeneralEquipment",
    "Line",
    "PowerTransformer",
    "Process",
    "SubEquipment",
    "SubFunction",
    "SubFunctionTemplate",
    "Substation",
    "TapChanger",
    "TransformerWinding",
    "VoltageLevel"
  ],
  LNodeDataRef: ["SignalRole"],
  LNodeInputRef: ["SignalRole"],
  LNodeInputs: [],
  LNodeOutputRef: ["SignalRole"],
  LNodeOutputs: [],
  LNodeSpecNaming: [],
  LNodeType: ["DataTypeTemplates"],
  Label: ["Labels"],
  Labels: [
    "AccessPoint",
    "BDA",
    "Bay",
    "ConductingEquipment",
    "ConnectivityNode",
    "DA",
    "DAI",
    "DAS",
    "DAType",
    "DO",
    "DOI",
    "DOS",
    "DOType",
    "EqFunction",
    "EqSubFunction",
    "Function",
    "GOOSESecurity",
    "GeneralEquipment",
    "IED",
    "LDevice",
    "LN",
    "LN0",
    "LNode",
    "LNodeType",
    "Line",
    "PowerTransformer",
    "Process",
    "SDI",
    "SDO",
    "SDS",
    "SMVSecurity",
    "SubEquipment",
    "SubFunction",
    "SubNetwork",
    "Substation",
    "TapChanger",
    "TransformerWinding",
    "VoltageLevel"
  ],
  Line: ["Process", "SCL"],
  Log: ["LN", "LN0"],
  LogControl: ["LN", "LN0"],
  LogParameters: ["ServiceSpecifications"],
  LogParametersRef: ["DAS", "DOS", "SDS"],
  LogSettings: ["Services"],
  MaxTime: ["GSE"],
  McSecurity: ["GSESettings", "SMVSettings"],
  MinRequestedSCDFile: ["MinRequestedSCDFiles"],
  MinRequestedSCDFiles: ["IED"],
  MinTime: ["GSE"],
  MultiAPPerSubNet: ["Services"],
  NeutralPoint: ["TransformerWinding"],
  OptFields: ["ReportControl"],
  OutputVar: ["BehaviorDescription"],
  OutputVarRef: ["BehaviorDescriptionRef"],
  Outputs: ["LN", "LN0"],
  P: ["Address", "PhysConn"],
  PhysConn: ["ConnectedAP"],
  PowerSystemRelation: ["PowerSystemRelations"],
  PowerSystemRelationRef: ["FunctionRoleContent"],
  PowerSystemRelations: [],
  PowerTransformer: ["Bay", "Substation", "VoltageLevel"],
  Private: [
    "AccessPoint",
    "BDA",
    "Bay",
    "Communication",
    "ConductingEquipment",
    "ConnectedAP",
    "ConnectivityNode",
    "DA",
    "DAI",
    "DAType",
    "DO",
    "DOI",
    "DOType",
    "DataSet",
    "EnumType",
    "EqFunction",
    "EqSubFunction",
    "ExtCtrl",
    "ExtRef",
    "Function",
    "GOOSESecurity",
    "GSE",
    "GSEControl",
    "GeneralEquipment",
    "IED",
    "IEDSourceFiles",
    "Inputs",
    "LDevice",
    "LN",
    "LN0",
    "LNode",
    "LNodeType",
    "Labels",
    "Line",
    "Log",
    "LogControl",
    "MinRequestedSCDFiles",
    "NeutralPoint",
    "Outputs",
    "PhysConn",
    "PowerTransformer",
    "Process",
    "ReportControl",
    "RptEnabled",
    "SCL",
    "SDI",
    "SDO",
    "SMV",
    "SMVSecurity",
    "SampledValueControl",
    "SclFileReference",
    "Server",
    "ServerAt",
    "SettingControl",
    "SourceFiles",
    "SubEquipment",
    "SubFunction",
    "SubNetwork",
    "Substation",
    "TapChanger",
    "Terminal",
    "TransformerWinding",
    "VoltageLevel"
  ],
  Process: ["Process", "SCL"],
  ProcessEcho: ["DAS", "DOS", "SDS"],
  ProcessResource: ["ProcessResources"],
  ProcessResourceRef: ["FunctionRoleContent"],
  ProcessResources: [],
  Project: [],
  ProjectProcessReference: ["Project"],
  ProtNs: ["DA", "DAType"],
  Protocol: ["GSEControl", "SampledValueControl"],
  ReadWrite: ["Services"],
  RedProt: ["Services"],
  ReportControl: ["LN", "LN0"],
  ReportParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
  ReportParametersRef: ["SourceRef", "SubscriberLNode"],
  ReportSettings: ["Services"],
  Resource: ["ProcessResource"],
  RptEnabled: ["ReportControl"],
  SCL: [],
  SCSM: ["Services"],
  SDI: ["DOI", "SDI"],
  SDO: ["DOType"],
  SDS: ["DOS", "SDS"],
  SGEdit: ["SettingGroups"],
  SMV: ["ConnectedAP"],
  SMVParameters: ["CommunicationServiceSpecifications", "ServiceSpecifications"],
  SMVParametersRef: ["SourceRef", "SubscriberLNode"],
  SMVSecurity: ["AccessPoint"],
  SMVSettings: ["Services"],
  SMVsc: ["Services"],
  SVMcSecurity: ["ClientServices"],
  SampledValueControl: ["LN0"],
  SamplesPerSec: ["SMVSettings"],
  SclFileReference: [
    "ApplicationSclRef",
    "FunctionSclRef",
    "IEDSourceFiles",
    "SourceFiles"
  ],
  SecPerSamples: ["SMVSettings"],
  Security: ["ClientServices", "Services"],
  Server: ["AccessPoint"],
  ServerAt: ["AccessPoint"],
  ServiceSpecifications: [],
  Services: ["AccessPoint", "IED"],
  SetDataSetValue: ["Services"],
  SettingControl: ["LN0"],
  SettingGroups: ["Services"],
  SignalRole: ["FunctionRef"],
  SmpRate: ["SMVSettings"],
  SmvOpts: ["SampledValueControl"],
  SourceFiles: ["Header", "Hitem"],
  SourceRef: ["LNodeInputs"],
  SubCategory: ["FunctionCategory", "SubCategory"],
  SubCheckoutID: ["CheckoutID", "SubCheckoutID"],
  SubEquipment: [
    "ConductingEquipment",
    "PowerTransformer",
    "TapChanger",
    "TransformerWinding"
  ],
  SubFunction: ["Function", "SubFunction"],
  SubFunctionTemplate: ["FunctionTemplate", "SubFunctionTemplate"],
  SubNetwork: ["Communication"],
  Subject: ["GOOSESecurity", "SMVSecurity"],
  SubscriberLNode: ["DAS", "DOS", "SDS"],
  Substation: ["Process", "SCL"],
  SupSubscription: ["Services"],
  TapChanger: ["TransformerWinding"],
  Terminal: ["ConductingEquipment", "TransformerWinding"],
  Text: [
    "AccessPoint",
    "AllocationRole",
    "AllocationRoleRef",
    "AnalogueWiringParameters",
    "AnalogueWiringParametersRef",
    "Application",
    "ApplicationSclRef",
    "BDA",
    "Bay",
    "BehaviorDescription",
    "BehaviorDescriptionRef",
    "BehaviorReference",
    "BinaryWiringParameters",
    "BinaryWiringParametersRef",
    "Communication",
    "CommunicationServiceSpecifications",
    "ConductingEquipment",
    "ConnectedAP",
    "ConnectivityNode",
    "ControlRef",
    "ControllingLNode",
    "DA",
    "DAI",
    "DAS",
    "DAType",
    "DO",
    "DOI",
    "DOS",
    "DOType",
    "DataSet",
    "EnumType",
    "EqFunction",
    "EqSubFunction",
    "ExtCtrl",
    "ExtRef",
    "Function",
    "FunctionCatRef",
    "FunctionCategory",
    "FunctionCategoryRef",
    "FunctionRef",
    "FunctionRole",
    "FunctionRoleContent",
    "FunctionSclRef",
    "FunctionTemplate",
    "FunctionalSubVariant",
    "FunctionalVariant",
    "FunctionalVariantGroup",
    "FunctionalVariantRef",
    "GOOSESecurity",
    "GSE",
    "GSEControl",
    "GeneralEquipment",
    "GooseParameters",
    "GooseParametersRef",
    "Header",
    "IED",
    "IEDSourceFiles",
    "InputVar",
    "InputVarRef",
    "Inputs",
    "L2CommParameters",
    "L3IPv4CommParameters",
    "L3IPv6CommParameters",
    "LDevice",
    "LN",
    "LN0",
    "LNode",
    "LNodeDataRef",
    "LNodeInputRef",
    "LNodeInputs",
    "LNodeOutputRef",
    "LNodeOutputs",
    "LNodeSpecNaming",
    "LNodeType",
    "Labels",
    "Line",
    "Log",
    "LogControl",
    "LogParameters",
    "LogParametersRef",
    "MinRequestedSCDFiles",
    "NeutralPoint",
    "OutputVar",
    "OutputVarRef",
    "Outputs",
    "PhysConn",
    "PowerSystemRelation",
    "PowerSystemRelationRef",
    "PowerSystemRelations",
    "PowerTransformer",
    "Process",
    "ProcessEcho",
    "ProcessResource",
    "ProcessResourceRef",
    "ProcessResources",
    "Project",
    "ProjectProcessReference",
    "ReportControl",
    "ReportParameters",
    "ReportParametersRef",
    "RptEnabled",
    "SCL",
    "SDI",
    "SDO",
    "SDS",
    "SMV",
    "SMVParameters",
    "SMVParametersRef",
    "SMVSecurity",
    "SampledValueControl",
    "SclFileReference",
    "Server",
    "ServerAt",
    "ServiceSpecifications",
    "SettingControl",
    "SignalRole",
    "SourceFiles",
    "SourceRef",
    "SubCategory",
    "SubEquipment",
    "SubFunction",
    "SubFunctionTemplate",
    "SubNetwork",
    "SubscriberLNode",
    "Substation",
    "TapChanger",
    "Terminal",
    "TransformerWinding",
    "Variable",
    "VariableApplyTo",
    "VariableRef",
    "VoltageLevel"
  ],
  TimeSyncProt: ["ClientServices", "Services"],
  TimerActivatedControl: ["Services"],
  TransformerWinding: ["PowerTransformer"],
  TrgOps: ["LogControl", "ReportControl"],
  Val: ["BDA", "DA", "DAI", "DAS"],
  ValueHandling: ["Services"],
  Variable: [],
  VariableApplyTo: ["Variable"],
  VariableRef: ["FunctionRoleContent", "FunctionalSubVariant", "FunctionalVariant"],
  Voltage: ["Line", "VoltageLevel"],
  VoltageLevel: ["Substation"]
}, gL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ATTRIBUTES: dL,
  CHILDREN: pL,
  DEFINITION: oL,
  ELEMENT_NAMES: mL,
  PARENTS: hL,
  REQUIRED: fL
}, Symbol.toStringTag, { value: "Module" })), ua = {
  v2019C1: gL
}, xd = {
  default: {
    prefix: "",
    uri: "http://www.iec.ch/61850/2003/SCL"
  }
};
function Sg(e) {
  return e.reduce(
    (l, i) => {
      if (!i) return l;
      const a = i.tagName, s = l[a] ?? [];
      return s.push(i), l[a] = s, l;
    },
    {}
  );
}
function vL(e) {
  return typeof e == "object" && e !== null && "id" in e && "tagName" in e && "namespace" in e && "attributes" in e && "children" in e && !("treeChildren" in e) && !("status" in e);
}
function Xc(e) {
  return "treeChildren" in e && "status" in e;
}
function ja(e) {
  return Xc(e) ? e : {
    ...e,
    treeChildren: [],
    status: "unchanged"
  };
}
function _i(e) {
  if (Xc(e)) {
    const { treeChildren: l, status: i, ...a } = e;
    return a;
  }
  return e;
}
var xL = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function yL(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var vm = { exports: {} }, IL = vm.exports, yd;
function LL() {
  return yd || (yd = 1, function(e, l) {
    (function(i, a) {
      e.exports = a();
    })(IL, function() {
      var i = function(n, t) {
        return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(u, r) {
          u.__proto__ = r;
        } || function(u, r) {
          for (var c in r) Object.prototype.hasOwnProperty.call(r, c) && (u[c] = r[c]);
        })(n, t);
      }, a = function() {
        return (a = Object.assign || function(n) {
          for (var t, u = 1, r = arguments.length; u < r; u++) for (var c in t = arguments[u]) Object.prototype.hasOwnProperty.call(t, c) && (n[c] = t[c]);
          return n;
        }).apply(this, arguments);
      };
      function s(n, t, u) {
        for (var r, c = 0, m = t.length; c < m; c++) !r && c in t || ((r = r || Array.prototype.slice.call(t, 0, c))[c] = t[c]);
        return n.concat(r || Array.prototype.slice.call(t));
      }
      var o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : xL, f = Object.keys, d = Array.isArray;
      function h(n, t) {
        return typeof t != "object" || f(t).forEach(function(u) {
          n[u] = t[u];
        }), n;
      }
      typeof Promise > "u" || o.Promise || (o.Promise = Promise);
      var I = Object.getPrototypeOf, x = {}.hasOwnProperty;
      function y(n, t) {
        return x.call(n, t);
      }
      function P(n, t) {
        typeof t == "function" && (t = t(I(n))), (typeof Reflect > "u" ? f : Reflect.ownKeys)(t).forEach(function(u) {
          R(n, u, t[u]);
        });
      }
      var E = Object.defineProperty;
      function R(n, t, u, r) {
        E(n, t, h(u && y(u, "get") && typeof u.get == "function" ? { get: u.get, set: u.set, configurable: !0 } : { value: u, configurable: !0, writable: !0 }, r));
      }
      function V(n) {
        return { from: function(t) {
          return n.prototype = Object.create(t.prototype), R(n.prototype, "constructor", n), { extend: P.bind(null, n.prototype) };
        } };
      }
      var K = Object.getOwnPropertyDescriptor, $ = [].slice;
      function Q(n, t, u) {
        return $.call(n, t, u);
      }
      function Z(n, t) {
        return t(n);
      }
      function G(n) {
        if (!n) throw new Error("Assertion Failed");
      }
      function Y(n) {
        o.setImmediate ? setImmediate(n) : setTimeout(n, 0);
      }
      function se(n, t) {
        if (typeof t == "string" && y(n, t)) return n[t];
        if (!t) return n;
        if (typeof t != "string") {
          for (var u = [], r = 0, c = t.length; r < c; ++r) {
            var m = se(n, t[r]);
            u.push(m);
          }
          return u;
        }
        var p = t.indexOf(".");
        if (p !== -1) {
          var g = n[t.substr(0, p)];
          return g == null ? void 0 : se(g, t.substr(p + 1));
        }
      }
      function te(n, t, u) {
        if (n && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(n))) if (typeof t != "string" && "length" in t) {
          G(typeof u != "string" && "length" in u);
          for (var r = 0, c = t.length; r < c; ++r) te(n, t[r], u[r]);
        } else {
          var m, p, g = t.indexOf(".");
          g !== -1 ? (m = t.substr(0, g), (p = t.substr(g + 1)) === "" ? u === void 0 ? d(n) && !isNaN(parseInt(m)) ? n.splice(m, 1) : delete n[m] : n[m] = u : te(g = !(g = n[m]) || !y(n, m) ? n[m] = {} : g, p, u)) : u === void 0 ? d(n) && !isNaN(parseInt(t)) ? n.splice(t, 1) : delete n[t] : n[t] = u;
        }
      }
      function fe(n) {
        var t, u = {};
        for (t in n) y(n, t) && (u[t] = n[t]);
        return u;
      }
      var M = [].concat;
      function oe(n) {
        return M.apply([], n);
      }
      var Ue = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(oe([8, 16, 32, 64].map(function(n) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + n + "Array";
        });
      }))).filter(function(n) {
        return o[n];
      }), Le = new Set(Ue.map(function(n) {
        return o[n];
      })), ae = null;
      function ye(n) {
        return ae = /* @__PURE__ */ new WeakMap(), n = function t(u) {
          if (!u || typeof u != "object") return u;
          var r = ae.get(u);
          if (r) return r;
          if (d(u)) {
            r = [], ae.set(u, r);
            for (var c = 0, m = u.length; c < m; ++c) r.push(t(u[c]));
          } else if (Le.has(u.constructor)) r = u;
          else {
            var p, g = I(u);
            for (p in r = g === Object.prototype ? {} : Object.create(g), ae.set(u, r), u) y(u, p) && (r[p] = t(u[p]));
          }
          return r;
        }(n), ae = null, n;
      }
      var he = {}.toString;
      function Ce(n) {
        return he.call(n).slice(8, -1);
      }
      var xe = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", ce = typeof xe == "symbol" ? function(n) {
        var t;
        return n != null && (t = n[xe]) && t.apply(n);
      } : function() {
        return null;
      };
      function de(n, t) {
        return t = n.indexOf(t), 0 <= t && n.splice(t, 1), 0 <= t;
      }
      var we = {};
      function Ae(n) {
        var t, u, r, c;
        if (arguments.length === 1) {
          if (d(n)) return n.slice();
          if (this === we && typeof n == "string") return [n];
          if (c = ce(n)) {
            for (u = []; !(r = c.next()).done; ) u.push(r.value);
            return u;
          }
          if (n == null) return [n];
          if (typeof (t = n.length) != "number") return [n];
          for (u = new Array(t); t--; ) u[t] = n[t];
          return u;
        }
        for (t = arguments.length, u = new Array(t); t--; ) u[t] = arguments[t];
        return u;
      }
      var $e = typeof Symbol < "u" ? function(n) {
        return n[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ze = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], In = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ze), ze = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function cn(n, t) {
        this.name = n, this.message = t;
      }
      function Cn(n, t) {
        return n + ". Errors: " + Object.keys(t).map(function(u) {
          return t[u].toString();
        }).filter(function(u, r, c) {
          return c.indexOf(u) === r;
        }).join(`
`);
      }
      function xn(n, t, u, r) {
        this.failures = t, this.failedKeys = r, this.successCount = u, this.message = Cn(n, t);
      }
      function ln(n, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(u) {
          return t[u];
        }), this.failuresByPos = t, this.message = Cn(n, this.failures);
      }
      V(cn).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), V(xn).from(cn), V(ln).from(cn);
      var k = In.reduce(function(n, t) {
        return n[t] = t + "Error", n;
      }, {}), _ = cn, B = In.reduce(function(n, t) {
        var u = t + "Error";
        function r(c, m) {
          this.name = u, c ? typeof c == "string" ? (this.message = "".concat(c).concat(m ? `
 ` + m : ""), this.inner = m || null) : typeof c == "object" && (this.message = "".concat(c.name, " ").concat(c.message), this.inner = c) : (this.message = ze[t] || u, this.inner = null);
        }
        return V(r).from(_), n[t] = r, n;
      }, {});
      B.Syntax = SyntaxError, B.Type = TypeError, B.Range = RangeError;
      var le = Ze.reduce(function(n, t) {
        return n[t + "Error"] = B[t], n;
      }, {}), Xe = In.reduce(function(n, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (n[t + "Error"] = B[t]), n;
      }, {});
      function De() {
      }
      function j(n) {
        return n;
      }
      function ie(n, t) {
        return n == null || n === j ? t : function(u) {
          return t(n(u));
        };
      }
      function me(n, t) {
        return function() {
          n.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function Te(n, t) {
        return n === De ? t : function() {
          var u = n.apply(this, arguments);
          u !== void 0 && (arguments[0] = u);
          var r = this.onsuccess, c = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var m = t.apply(this, arguments);
          return r && (this.onsuccess = this.onsuccess ? me(r, this.onsuccess) : r), c && (this.onerror = this.onerror ? me(c, this.onerror) : c), m !== void 0 ? m : u;
        };
      }
      function Ie(n, t) {
        return n === De ? t : function() {
          n.apply(this, arguments);
          var u = this.onsuccess, r = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), u && (this.onsuccess = this.onsuccess ? me(u, this.onsuccess) : u), r && (this.onerror = this.onerror ? me(r, this.onerror) : r);
        };
      }
      function be(n, t) {
        return n === De ? t : function(u) {
          var r = n.apply(this, arguments);
          h(u, r);
          var c = this.onsuccess, m = this.onerror;
          return this.onsuccess = null, this.onerror = null, u = t.apply(this, arguments), c && (this.onsuccess = this.onsuccess ? me(c, this.onsuccess) : c), m && (this.onerror = this.onerror ? me(m, this.onerror) : m), r === void 0 ? u === void 0 ? void 0 : u : h(r, u);
        };
      }
      function Ne(n, t) {
        return n === De ? t : function() {
          return t.apply(this, arguments) !== !1 && n.apply(this, arguments);
        };
      }
      function Ee(n, t) {
        return n === De ? t : function() {
          var u = n.apply(this, arguments);
          if (u && typeof u.then == "function") {
            for (var r = this, c = arguments.length, m = new Array(c); c--; ) m[c] = arguments[c];
            return u.then(function() {
              return t.apply(r, m);
            });
          }
          return t.apply(this, arguments);
        };
      }
      Xe.ModifyError = xn, Xe.DexieError = cn, Xe.BulkError = ln;
      var Oe = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function qe(n) {
        Oe = n;
      }
      var Ke = {}, ke = 100, Ue = typeof Promise > "u" ? [] : function() {
        var n = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [n, I(n), n];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, I(t), n];
      }(), Ze = Ue[0], In = Ue[1], Ue = Ue[2], In = In && In.then, Qe = Ze && Ze.constructor, yn = !!Ue, on = function(n, t) {
        Fn.push([n, t]), Tn && (queueMicrotask(Xa), Tn = !1);
      }, Bn = !0, Tn = !0, Dn = [], Nn = [], xl = j, Rn = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: De, pgp: !1, env: {}, finalize: De }, re = Rn, Fn = [], Zn = 0, yl = [];
      function ee(n) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = re;
        if (typeof n != "function") {
          if (n !== Ke) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && qt(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function u(r, c) {
          try {
            c(function(m) {
              if (r._state === null) {
                if (m === r) throw new TypeError("A promise cannot be resolved with itself.");
                var p = r._lib && al();
                m && typeof m.then == "function" ? u(r, function(g, L) {
                  m instanceof ee ? m._then(g, L) : m.then(g, L);
                }) : (r._state = !0, r._value = m, Hi(r)), p && rl();
              }
            }, qt.bind(null, r));
          } catch (m) {
            qt(r, m);
          }
        }(this, n);
      }
      var Tt = { get: function() {
        var n = re, t = Gl;
        function u(r, c) {
          var m = this, p = !n.global && (n !== re || t !== Gl), g = p && !Kn(), L = new ee(function(O, b) {
            Pt(m, new ji(Wi(r, n, p, g), Wi(c, n, p, g), O, b, n));
          });
          return this._consoleTask && (L._consoleTask = this._consoleTask), L;
        }
        return u.prototype = Ke, u;
      }, set: function(n) {
        R(this, "then", n && n.prototype === Ke ? Tt : { get: function() {
          return n;
        }, set: Tt.set });
      } };
      function ji(n, t, u, r, c) {
        this.onFulfilled = typeof n == "function" ? n : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = u, this.reject = r, this.psd = c;
      }
      function qt(n, t) {
        var u, r;
        Nn.push(t), n._state === null && (u = n._lib && al(), t = xl(t), n._state = !1, n._value = t, r = n, Dn.some(function(c) {
          return c._value === r._value;
        }) || Dn.push(r), Hi(n), u && rl());
      }
      function Hi(n) {
        var t = n._listeners;
        n._listeners = [];
        for (var u = 0, r = t.length; u < r; ++u) Pt(n, t[u]);
        var c = n._PSD;
        --c.ref || c.finalize(), Zn === 0 && (++Zn, on(function() {
          --Zn == 0 && Rt();
        }, []));
      }
      function Pt(n, t) {
        if (n._state !== null) {
          var u = n._state ? t.onFulfilled : t.onRejected;
          if (u === null) return (n._state ? t.resolve : t.reject)(n._value);
          ++t.psd.ref, ++Zn, on(Ya, [u, n, t]);
        } else n._listeners.push(t);
      }
      function Ya(n, t, u) {
        try {
          var r, c = t._value;
          !t._state && Nn.length && (Nn = []), r = Oe && t._consoleTask ? t._consoleTask.run(function() {
            return n(c);
          }) : n(c), t._state || Nn.indexOf(c) !== -1 || function(m) {
            for (var p = Dn.length; p; ) if (Dn[--p]._value === m._value) return Dn.splice(p, 1);
          }(t), u.resolve(r);
        } catch (m) {
          u.reject(m);
        } finally {
          --Zn == 0 && Rt(), --u.psd.ref || u.psd.finalize();
        }
      }
      function Xa() {
        Xn(Rn, function() {
          al() && rl();
        });
      }
      function al() {
        var n = Bn;
        return Tn = Bn = !1, n;
      }
      function rl() {
        var n, t, u;
        do
          for (; 0 < Fn.length; ) for (n = Fn, Fn = [], u = n.length, t = 0; t < u; ++t) {
            var r = n[t];
            r[0].apply(null, r[1]);
          }
        while (0 < Fn.length);
        Tn = Bn = !0;
      }
      function Rt() {
        var n = Dn;
        Dn = [], n.forEach(function(r) {
          r._PSD.onunhandled.call(null, r._value, r);
        });
        for (var t = yl.slice(0), u = t.length; u; ) t[--u]();
      }
      function Zl(n) {
        return new ee(Ke, !1, n);
      }
      function Be(n, t) {
        var u = re;
        return function() {
          var r = al(), c = re;
          try {
            return Gn(u, !0), n.apply(this, arguments);
          } catch (m) {
            t && t(m);
          } finally {
            Gn(c, !1), r && rl();
          }
        };
      }
      P(ee.prototype, { then: Tt, _then: function(n, t) {
        Pt(this, new ji(null, null, n, t, re));
      }, catch: function(n) {
        if (arguments.length === 1) return this.then(null, n);
        var t = n, u = arguments[1];
        return typeof t == "function" ? this.then(null, function(r) {
          return (r instanceof t ? u : Zl)(r);
        }) : this.then(null, function(r) {
          return (r && r.name === t ? u : Zl)(r);
        });
      }, finally: function(n) {
        return this.then(function(t) {
          return ee.resolve(n()).then(function() {
            return t;
          });
        }, function(t) {
          return ee.resolve(n()).then(function() {
            return Zl(t);
          });
        });
      }, timeout: function(n, t) {
        var u = this;
        return n < 1 / 0 ? new ee(function(r, c) {
          var m = setTimeout(function() {
            return c(new B.Timeout(t));
          }, n);
          u.then(r, c).finally(clearTimeout.bind(null, m));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && R(ee.prototype, Symbol.toStringTag, "Dexie.Promise"), Rn.env = $i(), P(ee, { all: function() {
        var n = Ae.apply(null, arguments).map(zl);
        return new ee(function(t, u) {
          n.length === 0 && t([]);
          var r = n.length;
          n.forEach(function(c, m) {
            return ee.resolve(c).then(function(p) {
              n[m] = p, --r || t(n);
            }, u);
          });
        });
      }, resolve: function(n) {
        return n instanceof ee ? n : n && typeof n.then == "function" ? new ee(function(t, u) {
          n.then(t, u);
        }) : new ee(Ke, !0, n);
      }, reject: Zl, race: function() {
        var n = Ae.apply(null, arguments).map(zl);
        return new ee(function(t, u) {
          n.map(function(r) {
            return ee.resolve(r).then(t, u);
          });
        });
      }, PSD: { get: function() {
        return re;
      }, set: function(n) {
        return re = n;
      } }, totalEchoes: { get: function() {
        return Gl;
      } }, newPSD: Un, usePSD: Xn, scheduler: { get: function() {
        return on;
      }, set: function(n) {
        on = n;
      } }, rejectionMapper: { get: function() {
        return xl;
      }, set: function(n) {
        xl = n;
      } }, follow: function(n, t) {
        return new ee(function(u, r) {
          return Un(function(c, m) {
            var p = re;
            p.unhandleds = [], p.onunhandled = m, p.finalize = me(function() {
              var g, L = this;
              g = function() {
                L.unhandleds.length === 0 ? c() : m(L.unhandleds[0]);
              }, yl.push(function O() {
                g(), yl.splice(yl.indexOf(O), 1);
              }), ++Zn, on(function() {
                --Zn == 0 && Rt();
              }, []);
            }, p.finalize), n();
          }, t, u, r);
        });
      } }), Qe && (Qe.allSettled && R(ee, "allSettled", function() {
        var n = Ae.apply(null, arguments).map(zl);
        return new ee(function(t) {
          n.length === 0 && t([]);
          var u = n.length, r = new Array(u);
          n.forEach(function(c, m) {
            return ee.resolve(c).then(function(p) {
              return r[m] = { status: "fulfilled", value: p };
            }, function(p) {
              return r[m] = { status: "rejected", reason: p };
            }).then(function() {
              return --u || t(r);
            });
          });
        });
      }), Qe.any && typeof AggregateError < "u" && R(ee, "any", function() {
        var n = Ae.apply(null, arguments).map(zl);
        return new ee(function(t, u) {
          n.length === 0 && u(new AggregateError([]));
          var r = n.length, c = new Array(r);
          n.forEach(function(m, p) {
            return ee.resolve(m).then(function(g) {
              return t(g);
            }, function(g) {
              c[p] = g, --r || u(new AggregateError(c));
            });
          });
        });
      }), Qe.withResolvers && (ee.withResolvers = Qe.withResolvers));
      var Je = { awaits: 0, echoes: 0, id: 0 }, Qa = 0, Ul = [], Kl = 0, Gl = 0, Ja = 0;
      function Un(n, t, u, r) {
        var c = re, m = Object.create(c);
        return m.parent = c, m.ref = 0, m.global = !1, m.id = ++Ja, Rn.env, m.env = yn ? { Promise: ee, PromiseProp: { value: ee, configurable: !0, writable: !0 }, all: ee.all, race: ee.race, allSettled: ee.allSettled, any: ee.any, resolve: ee.resolve, reject: ee.reject } : {}, t && h(m, t), ++c.ref, m.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, r = Xn(m, n, u, r), m.ref === 0 && m.finalize(), r;
      }
      function sl() {
        return Je.id || (Je.id = ++Qa), ++Je.awaits, Je.echoes += ke, Je.id;
      }
      function Kn() {
        return !!Je.awaits && (--Je.awaits == 0 && (Je.id = 0), Je.echoes = Je.awaits * ke, !0);
      }
      function zl(n) {
        return Je.echoes && n && n.constructor === Qe ? (sl(), n.then(function(t) {
          return Kn(), t;
        }, function(t) {
          return Kn(), je(t);
        })) : n;
      }
      function er() {
        var n = Ul[Ul.length - 1];
        Ul.pop(), Gn(n, !1);
      }
      function Gn(n, t) {
        var u, r = re;
        (t ? !Je.echoes || Kl++ && n === re : !Kl || --Kl && n === re) || queueMicrotask(t ? (function(c) {
          ++Gl, Je.echoes && --Je.echoes != 0 || (Je.echoes = Je.awaits = Je.id = 0), Ul.push(re), Gn(c, !0);
        }).bind(null, n) : er), n !== re && (re = n, r === Rn && (Rn.env = $i()), yn && (u = Rn.env.Promise, t = n.env, (r.global || n.global) && (Object.defineProperty(o, "Promise", t.PromiseProp), u.all = t.all, u.race = t.race, u.resolve = t.resolve, u.reject = t.reject, t.allSettled && (u.allSettled = t.allSettled), t.any && (u.any = t.any))));
      }
      function $i() {
        var n = o.Promise;
        return yn ? { Promise: n, PromiseProp: Object.getOwnPropertyDescriptor(o, "Promise"), all: n.all, race: n.race, allSettled: n.allSettled, any: n.any, resolve: n.resolve, reject: n.reject } : {};
      }
      function Xn(n, t, u, r, c) {
        var m = re;
        try {
          return Gn(n, !0), t(u, r, c);
        } finally {
          Gn(m, !1);
        }
      }
      function Wi(n, t, u, r) {
        return typeof n != "function" ? n : function() {
          var c = re;
          u && sl(), Gn(t, !0);
          try {
            return n.apply(this, arguments);
          } finally {
            Gn(c, !1), r && queueMicrotask(Kn);
          }
        };
      }
      function At(n) {
        Promise === Qe && Je.echoes === 0 ? Kl === 0 ? n() : enqueueNativeMicroTask(n) : setTimeout(n, 0);
      }
      ("" + In).indexOf("[native code]") === -1 && (sl = Kn = De);
      var je = ee.reject, Qn = "", An = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Yi = "String expected.", cl = [], jl = "__dbnames", Et = "readonly", _t = "readwrite";
      function Jn(n, t) {
        return n ? t ? function() {
          return n.apply(this, arguments) && t.apply(this, arguments);
        } : n : t;
      }
      var Xi = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Hl(n) {
        return typeof n != "string" || /\./.test(n) ? function(t) {
          return t;
        } : function(t) {
          return t[n] === void 0 && n in t && delete (t = ye(t))[n], t;
        };
      }
      function Qi() {
        throw B.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Se(n, t) {
        try {
          var u = Ji(n), r = Ji(t);
          if (u !== r) return u === "Array" ? 1 : r === "Array" ? -1 : u === "binary" ? 1 : r === "binary" ? -1 : u === "string" ? 1 : r === "string" ? -1 : u === "Date" ? 1 : r !== "Date" ? NaN : -1;
          switch (u) {
            case "number":
            case "Date":
            case "string":
              return t < n ? 1 : n < t ? -1 : 0;
            case "binary":
              return function(c, m) {
                for (var p = c.length, g = m.length, L = p < g ? p : g, O = 0; O < L; ++O) if (c[O] !== m[O]) return c[O] < m[O] ? -1 : 1;
                return p === g ? 0 : p < g ? -1 : 1;
              }(eu(n), eu(t));
            case "Array":
              return function(c, m) {
                for (var p = c.length, g = m.length, L = p < g ? p : g, O = 0; O < L; ++O) {
                  var b = Se(c[O], m[O]);
                  if (b !== 0) return b;
                }
                return p === g ? 0 : p < g ? -1 : 1;
              }(n, t);
          }
        } catch {
        }
        return NaN;
      }
      function Ji(n) {
        var t = typeof n;
        return t != "object" ? t : ArrayBuffer.isView(n) ? "binary" : (n = Ce(n), n === "ArrayBuffer" ? "binary" : n);
      }
      function eu(n) {
        return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n);
      }
      function $l(n, t, u) {
        var r = n.schema.yProps;
        return r ? (t && 0 < u.numFailures && (t = t.filter(function(c, m) {
          return !u.failures[m];
        })), Promise.all(r.map(function(c) {
          return c = c.updatesTable, t ? n.db.table(c).where("k").anyOf(t).delete() : n.db.table(c).clear();
        })).then(function() {
          return u;
        })) : u;
      }
      var nu = (Ve.prototype._trans = function(n, t, u) {
        var r = this._tx || re.trans, c = this.name, m = Oe && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(n === "readonly" ? "read" : "write", " ").concat(this.name));
        function p(O, b, v) {
          if (!v.schema[c]) throw new B.NotFound("Table " + c + " not part of transaction");
          return t(v.idbtrans, v);
        }
        var g = al();
        try {
          var L = r && r.db._novip === this.db._novip ? r === re.trans ? r._promise(n, p, u) : Un(function() {
            return r._promise(n, p, u);
          }, { trans: r, transless: re.transless || re }) : function O(b, v, T, D) {
            if (b.idbdb && (b._state.openComplete || re.letThrough || b._vip)) {
              var w = b._createTransaction(v, T, b._dbSchema);
              try {
                w.create(), b._state.PR1398_maxLoop = 3;
              } catch (C) {
                return C.name === k.InvalidState && b.isOpen() && 0 < --b._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), b.close({ disableAutoOpen: !1 }), b.open().then(function() {
                  return O(b, v, T, D);
                })) : je(C);
              }
              return w._promise(v, function(C, S) {
                return Un(function() {
                  return re.trans = w, D(C, S, w);
                });
              }).then(function(C) {
                if (v === "readwrite") try {
                  w.idbtrans.commit();
                } catch {
                }
                return v === "readonly" ? C : w._completion.then(function() {
                  return C;
                });
              });
            }
            if (b._state.openComplete) return je(new B.DatabaseClosed(b._state.dbOpenError));
            if (!b._state.isBeingOpened) {
              if (!b._state.autoOpen) return je(new B.DatabaseClosed());
              b.open().catch(De);
            }
            return b._state.dbReadyPromise.then(function() {
              return O(b, v, T, D);
            });
          }(this.db, n, [this.name], p);
          return m && (L._consoleTask = m, L = L.catch(function(O) {
            return console.trace(O), je(O);
          })), L;
        } finally {
          g && rl();
        }
      }, Ve.prototype.get = function(n, t) {
        var u = this;
        return n && n.constructor === Object ? this.where(n).first(t) : n == null ? je(new B.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(r) {
          return u.core.get({ trans: r, key: n }).then(function(c) {
            return u.hook.reading.fire(c);
          });
        }).then(t);
      }, Ve.prototype.where = function(n) {
        if (typeof n == "string") return new this.db.WhereClause(this, n);
        if (d(n)) return new this.db.WhereClause(this, "[".concat(n.join("+"), "]"));
        var t = f(n);
        if (t.length === 1) return this.where(t[0]).equals(n[t[0]]);
        var u = this.schema.indexes.concat(this.schema.primKey).filter(function(g) {
          if (g.compound && t.every(function(O) {
            return 0 <= g.keyPath.indexOf(O);
          })) {
            for (var L = 0; L < t.length; ++L) if (t.indexOf(g.keyPath[L]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(g, L) {
          return g.keyPath.length - L.keyPath.length;
        })[0];
        if (u && this.db._maxKey !== Qn) {
          var m = u.keyPath.slice(0, t.length);
          return this.where(m).equals(m.map(function(L) {
            return n[L];
          }));
        }
        !u && Oe && console.warn("The query ".concat(JSON.stringify(n), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var r = this.schema.idxByName;
        function c(g, L) {
          return Se(g, L) === 0;
        }
        var p = t.reduce(function(v, L) {
          var O = v[0], b = v[1], v = r[L], T = n[L];
          return [O || v, O || !v ? Jn(b, v && v.multi ? function(D) {
            return D = se(D, L), d(D) && D.some(function(w) {
              return c(T, w);
            });
          } : function(D) {
            return c(T, se(D, L));
          }) : b];
        }, [null, null]), m = p[0], p = p[1];
        return m ? this.where(m.name).equals(n[m.keyPath]).filter(p) : u ? this.filter(p) : this.where(t).equals("");
      }, Ve.prototype.filter = function(n) {
        return this.toCollection().and(n);
      }, Ve.prototype.count = function(n) {
        return this.toCollection().count(n);
      }, Ve.prototype.offset = function(n) {
        return this.toCollection().offset(n);
      }, Ve.prototype.limit = function(n) {
        return this.toCollection().limit(n);
      }, Ve.prototype.each = function(n) {
        return this.toCollection().each(n);
      }, Ve.prototype.toArray = function(n) {
        return this.toCollection().toArray(n);
      }, Ve.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ve.prototype.orderBy = function(n) {
        return new this.db.Collection(new this.db.WhereClause(this, d(n) ? "[".concat(n.join("+"), "]") : n));
      }, Ve.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ve.prototype.mapToClass = function(n) {
        var t, u = this.db, r = this.name;
        function c() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = n).prototype instanceof Qi && (function(L, O) {
          if (typeof O != "function" && O !== null) throw new TypeError("Class extends value " + String(O) + " is not a constructor or null");
          function b() {
            this.constructor = L;
          }
          i(L, O), L.prototype = O === null ? Object.create(O) : (b.prototype = O.prototype, new b());
        }(c, t = n), Object.defineProperty(c.prototype, "db", { get: function() {
          return u;
        }, enumerable: !1, configurable: !0 }), c.prototype.table = function() {
          return r;
        }, n = c);
        for (var m = /* @__PURE__ */ new Set(), p = n.prototype; p; p = I(p)) Object.getOwnPropertyNames(p).forEach(function(L) {
          return m.add(L);
        });
        function g(L) {
          if (!L) return L;
          var O, b = Object.create(n.prototype);
          for (O in L) if (!m.has(O)) try {
            b[O] = L[O];
          } catch {
          }
          return b;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = g, this.hook("reading", g), n;
      }, Ve.prototype.defineClass = function() {
        return this.mapToClass(function(n) {
          h(this, n);
        });
      }, Ve.prototype.add = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, m = r.keyPath, p = n;
        return m && c && (p = Hl(m)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "add", keys: t != null ? [t] : null, values: [p] });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (m) try {
            te(n, m, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.update = function(n, t) {
        return typeof n != "object" || d(n) ? this.where(":id").equals(n).modify(t) : (n = se(n, this.schema.primKey.keyPath), n === void 0 ? je(new B.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(n).modify(t));
      }, Ve.prototype.put = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, m = r.keyPath, p = n;
        return m && c && (p = Hl(m)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "put", values: [p], keys: t != null ? [t] : null });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (m) try {
            te(n, m, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.delete = function(n) {
        var t = this;
        return this._trans("readwrite", function(u) {
          return t.core.mutate({ trans: u, type: "delete", keys: [n] }).then(function(r) {
            return $l(t, [n], r);
          }).then(function(r) {
            return r.numFailures ? ee.reject(r.failures[0]) : void 0;
          });
        });
      }, Ve.prototype.clear = function() {
        var n = this;
        return this._trans("readwrite", function(t) {
          return n.core.mutate({ trans: t, type: "deleteRange", range: Xi }).then(function(u) {
            return $l(n, null, u);
          });
        }).then(function(t) {
          return t.numFailures ? ee.reject(t.failures[0]) : void 0;
        });
      }, Ve.prototype.bulkGet = function(n) {
        var t = this;
        return this._trans("readonly", function(u) {
          return t.core.getMany({ keys: n, trans: u }).then(function(r) {
            return r.map(function(c) {
              return t.hook.reading.fire(c);
            });
          });
        });
      }, Ve.prototype.bulkAdd = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, m = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new B.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new B.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Hl(O)) : n;
          return r.core.mutate({ trans: p, type: "add", keys: c, values: O, wantResults: m }).then(function(w) {
            var v = w.numFailures, T = w.results, D = w.lastResult, w = w.failures;
            if (v === 0) return m ? T : D;
            throw new ln("".concat(r.name, ".bulkAdd(): ").concat(v, " of ").concat(L, " operations failed"), w);
          });
        });
      }, Ve.prototype.bulkPut = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, m = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new B.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new B.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Hl(O)) : n;
          return r.core.mutate({ trans: p, type: "put", keys: c, values: O, wantResults: m }).then(function(w) {
            var v = w.numFailures, T = w.results, D = w.lastResult, w = w.failures;
            if (v === 0) return m ? T : D;
            throw new ln("".concat(r.name, ".bulkPut(): ").concat(v, " of ").concat(L, " operations failed"), w);
          });
        });
      }, Ve.prototype.bulkUpdate = function(n) {
        var t = this, u = this.core, r = n.map(function(p) {
          return p.key;
        }), c = n.map(function(p) {
          return p.changes;
        }), m = [];
        return this._trans("readwrite", function(p) {
          return u.getMany({ trans: p, keys: r, cache: "clone" }).then(function(g) {
            var L = [], O = [];
            n.forEach(function(v, T) {
              var D = v.key, w = v.changes, C = g[T];
              if (C) {
                for (var S = 0, q = Object.keys(w); S < q.length; S++) {
                  var A = q[S], N = w[A];
                  if (A === t.schema.primKey.keyPath) {
                    if (Se(N, D) !== 0) throw new B.Constraint("Cannot update primary key in bulkUpdate()");
                  } else te(C, A, N);
                }
                m.push(T), L.push(D), O.push(C);
              }
            });
            var b = L.length;
            return u.mutate({ trans: p, type: "put", keys: L, values: O, updates: { keys: r, changeSpecs: c } }).then(function(v) {
              var T = v.numFailures, D = v.failures;
              if (T === 0) return b;
              for (var w = 0, C = Object.keys(D); w < C.length; w++) {
                var S, q = C[w], A = m[Number(q)];
                A != null && (S = D[q], delete D[q], D[A] = S);
              }
              throw new ln("".concat(t.name, ".bulkUpdate(): ").concat(T, " of ").concat(b, " operations failed"), D);
            });
          });
        });
      }, Ve.prototype.bulkDelete = function(n) {
        var t = this, u = n.length;
        return this._trans("readwrite", function(r) {
          return t.core.mutate({ trans: r, type: "delete", keys: n }).then(function(c) {
            return $l(t, n, c);
          });
        }).then(function(p) {
          var c = p.numFailures, m = p.lastResult, p = p.failures;
          if (c === 0) return m;
          throw new ln("".concat(t.name, ".bulkDelete(): ").concat(c, " of ").concat(u, " operations failed"), p);
        });
      }, Ve);
      function Ve() {
      }
      function Il(n) {
        function t(p, g) {
          if (g) {
            for (var L = arguments.length, O = new Array(L - 1); --L; ) O[L - 1] = arguments[L];
            return u[p].subscribe.apply(null, O), n;
          }
          if (typeof p == "string") return u[p];
        }
        var u = {};
        t.addEventType = m;
        for (var r = 1, c = arguments.length; r < c; ++r) m(arguments[r]);
        return t;
        function m(p, g, L) {
          if (typeof p != "object") {
            var O;
            g = g || Ne;
            var b = { subscribers: [], fire: L = L || De, subscribe: function(v) {
              b.subscribers.indexOf(v) === -1 && (b.subscribers.push(v), b.fire = g(b.fire, v));
            }, unsubscribe: function(v) {
              b.subscribers = b.subscribers.filter(function(T) {
                return T !== v;
              }), b.fire = b.subscribers.reduce(g, L);
            } };
            return u[p] = t[p] = b;
          }
          f(O = p).forEach(function(v) {
            var T = O[v];
            if (d(T)) m(v, O[v][0], O[v][1]);
            else {
              if (T !== "asap") throw new B.InvalidArgument("Invalid event config");
              var D = m(v, j, function() {
                for (var w = arguments.length, C = new Array(w); w--; ) C[w] = arguments[w];
                D.subscribers.forEach(function(S) {
                  Y(function() {
                    S.apply(null, C);
                  });
                });
              });
            }
          });
        }
      }
      function Ll(n, t) {
        return V(t).from({ prototype: n }), t;
      }
      function ol(n, t) {
        return !(n.filter || n.algorithm || n.or) && (t ? n.justLimit : !n.replayFilter);
      }
      function Nt(n, t) {
        n.filter = Jn(n.filter, t);
      }
      function Ft(n, t, u) {
        var r = n.replayFilter;
        n.replayFilter = r ? function() {
          return Jn(r(), t());
        } : t, n.justLimit = u && !r;
      }
      function Wl(n, t) {
        if (n.isPrimKey) return t.primaryKey;
        var u = t.getIndexByKeyPath(n.index);
        if (!u) throw new B.Schema("KeyPath " + n.index + " on object store " + t.name + " is not indexed");
        return u;
      }
      function lu(n, t, u) {
        var r = Wl(n, t.schema);
        return t.openCursor({ trans: u, values: !n.keysOnly, reverse: n.dir === "prev", unique: !!n.unique, query: { index: r, range: n.range } });
      }
      function Yl(n, t, u, r) {
        var c = n.replayFilter ? Jn(n.filter, n.replayFilter()) : n.filter;
        if (n.or) {
          var m = {}, p = function(g, L, O) {
            var b, v;
            c && !c(L, O, function(T) {
              return L.stop(T);
            }, function(T) {
              return L.fail(T);
            }) || ((v = "" + (b = L.primaryKey)) == "[object ArrayBuffer]" && (v = "" + new Uint8Array(b)), y(m, v) || (m[v] = !0, t(g, L, O)));
          };
          return Promise.all([n.or._iterate(p, u), tu(lu(n, r, u), n.algorithm, p, !n.keysOnly && n.valueMapper)]);
        }
        return tu(lu(n, r, u), Jn(n.algorithm, c), t, !n.keysOnly && n.valueMapper);
      }
      function tu(n, t, u, r) {
        var c = Be(r ? function(m, p, g) {
          return u(r(m), p, g);
        } : u);
        return n.then(function(m) {
          if (m) return m.start(function() {
            var p = function() {
              return m.continue();
            };
            t && !t(m, function(g) {
              return p = g;
            }, function(g) {
              m.stop(g), p = De;
            }, function(g) {
              m.fail(g), p = De;
            }) || c(m.value, m, function(g) {
              return p = g;
            }), p();
          });
        });
      }
      var Dl = (iu.prototype.execute = function(n) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var u = t.add;
          if (d(u)) return s(s([], d(n) ? n : [], !0), u).sort();
          if (typeof u == "number") return (Number(n) || 0) + u;
          if (typeof u == "bigint") try {
            return BigInt(n) + u;
          } catch {
            return BigInt(0) + u;
          }
          throw new TypeError("Invalid term ".concat(u));
        }
        if (t.remove !== void 0) {
          var r = t.remove;
          if (d(r)) return d(n) ? n.filter(function(c) {
            return !r.includes(c);
          }).sort() : [];
          if (typeof r == "number") return Number(n) - r;
          if (typeof r == "bigint") try {
            return BigInt(n) - r;
          } catch {
            return BigInt(0) - r;
          }
          throw new TypeError("Invalid subtrahend ".concat(r));
        }
        return u = (u = t.replacePrefix) === null || u === void 0 ? void 0 : u[0], u && typeof n == "string" && n.startsWith(u) ? t.replacePrefix[1] + n.substring(u.length) : n;
      }, iu);
      function iu(n) {
        this["@@propmod"] = n;
      }
      var nr = (Re.prototype._read = function(n, t) {
        var u = this._ctx;
        return u.error ? u.table._trans(null, je.bind(null, u.error)) : u.table._trans("readonly", n).then(t);
      }, Re.prototype._write = function(n) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, je.bind(null, t.error)) : t.table._trans("readwrite", n, "locked");
      }, Re.prototype._addAlgorithm = function(n) {
        var t = this._ctx;
        t.algorithm = Jn(t.algorithm, n);
      }, Re.prototype._iterate = function(n, t) {
        return Yl(this._ctx, n, t, this._ctx.table.core);
      }, Re.prototype.clone = function(n) {
        var t = Object.create(this.constructor.prototype), u = Object.create(this._ctx);
        return n && h(u, n), t._ctx = u, t;
      }, Re.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Re.prototype.each = function(n) {
        var t = this._ctx;
        return this._read(function(u) {
          return Yl(t, n, u, t.table.core);
        });
      }, Re.prototype.count = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx, c = r.table.core;
          if (ol(r, !0)) return c.count({ trans: u, query: { index: Wl(r, c.schema), range: r.range } }).then(function(p) {
            return Math.min(p, r.limit);
          });
          var m = 0;
          return Yl(r, function() {
            return ++m, !1;
          }, u, c).then(function() {
            return m;
          });
        }).then(n);
      }, Re.prototype.sortBy = function(n, t) {
        var u = n.split(".").reverse(), r = u[0], c = u.length - 1;
        function m(L, O) {
          return O ? m(L[u[O]], O - 1) : L[r];
        }
        var p = this._ctx.dir === "next" ? 1 : -1;
        function g(L, O) {
          return Se(m(L, c), m(O, c)) * p;
        }
        return this.toArray(function(L) {
          return L.sort(g);
        }).then(t);
      }, Re.prototype.toArray = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx;
          if (r.dir === "next" && ol(r, !0) && 0 < r.limit) {
            var c = r.valueMapper, m = Wl(r, r.table.core.schema);
            return r.table.core.query({ trans: u, limit: r.limit, values: !0, query: { index: m, range: r.range } }).then(function(g) {
              return g = g.result, c ? g.map(c) : g;
            });
          }
          var p = [];
          return Yl(r, function(g) {
            return p.push(g);
          }, u, r.table.core).then(function() {
            return p;
          });
        }, n);
      }, Re.prototype.offset = function(n) {
        var t = this._ctx;
        return n <= 0 || (t.offset += n, ol(t) ? Ft(t, function() {
          var u = n;
          return function(r, c) {
            return u === 0 || (u === 1 ? --u : c(function() {
              r.advance(u), u = 0;
            }), !1);
          };
        }) : Ft(t, function() {
          var u = n;
          return function() {
            return --u < 0;
          };
        })), this;
      }, Re.prototype.limit = function(n) {
        return this._ctx.limit = Math.min(this._ctx.limit, n), Ft(this._ctx, function() {
          var t = n;
          return function(u, r, c) {
            return --t <= 0 && r(c), 0 <= t;
          };
        }, !0), this;
      }, Re.prototype.until = function(n, t) {
        return Nt(this._ctx, function(u, r, c) {
          return !n(u.value) || (r(c), t);
        }), this;
      }, Re.prototype.first = function(n) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(n);
      }, Re.prototype.last = function(n) {
        return this.reverse().first(n);
      }, Re.prototype.filter = function(n) {
        var t;
        return Nt(this._ctx, function(u) {
          return n(u.value);
        }), (t = this._ctx).isMatch = Jn(t.isMatch, n), this;
      }, Re.prototype.and = function(n) {
        return this.filter(n);
      }, Re.prototype.or = function(n) {
        return new this.db.WhereClause(this._ctx.table, n, this);
      }, Re.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Re.prototype.desc = function() {
        return this.reverse();
      }, Re.prototype.eachKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.key, r);
        });
      }, Re.prototype.eachUniqueKey = function(n) {
        return this._ctx.unique = "unique", this.eachKey(n);
      }, Re.prototype.eachPrimaryKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.primaryKey, r);
        });
      }, Re.prototype.keys = function(n) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.key);
        }).then(function() {
          return u;
        }).then(n);
      }, Re.prototype.primaryKeys = function(n) {
        var t = this._ctx;
        if (t.dir === "next" && ol(t, !0) && 0 < t.limit) return this._read(function(r) {
          var c = Wl(t, t.table.core.schema);
          return t.table.core.query({ trans: r, values: !1, limit: t.limit, query: { index: c, range: t.range } });
        }).then(function(r) {
          return r.result;
        }).then(n);
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.primaryKey);
        }).then(function() {
          return u;
        }).then(n);
      }, Re.prototype.uniqueKeys = function(n) {
        return this._ctx.unique = "unique", this.keys(n);
      }, Re.prototype.firstKey = function(n) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(n);
      }, Re.prototype.lastKey = function(n) {
        return this.reverse().firstKey(n);
      }, Re.prototype.distinct = function() {
        var n = this._ctx, n = n.index && n.table.schema.idxByName[n.index];
        if (!n || !n.multi) return this;
        var t = {};
        return Nt(this._ctx, function(c) {
          var r = c.primaryKey.toString(), c = y(t, r);
          return t[r] = !0, !c;
        }), this;
      }, Re.prototype.modify = function(n) {
        var t = this, u = this._ctx;
        return this._write(function(r) {
          var c, m, p;
          p = typeof n == "function" ? n : (c = f(n), m = c.length, function(q) {
            for (var A = !1, N = 0; N < m; ++N) {
              var F = c[N], U = n[F], W = se(q, F);
              U instanceof Dl ? (te(q, F, U.execute(W)), A = !0) : W !== U && (te(q, F, U), A = !0);
            }
            return A;
          });
          var g = u.table.core, v = g.schema.primaryKey, L = v.outbound, O = v.extractKey, b = 200, v = t.db._options.modifyChunkSize;
          v && (b = typeof v == "object" ? v[g.name] || v["*"] || 200 : v);
          function T(q, F) {
            var N = F.failures, F = F.numFailures;
            w += q - F;
            for (var U = 0, W = f(N); U < W.length; U++) {
              var z = W[U];
              D.push(N[z]);
            }
          }
          var D = [], w = 0, C = [], S = n === uu;
          return t.clone().primaryKeys().then(function(q) {
            function A(F) {
              var U = Math.min(b, q.length - F), W = q.slice(F, F + U);
              return (S ? Promise.resolve([]) : g.getMany({ trans: r, keys: W, cache: "immutable" })).then(function(z) {
                var H = [], J = [], X = L ? [] : null, ne = S ? W : [];
                if (!S) for (var ve = 0; ve < U; ++ve) {
                  var Pe = z[ve], ge = { value: ye(Pe), primKey: q[F + ve] };
                  p.call(ge, ge.value, ge) !== !1 && (ge.value == null ? ne.push(q[F + ve]) : L || Se(O(Pe), O(ge.value)) === 0 ? (J.push(ge.value), L && X.push(q[F + ve])) : (ne.push(q[F + ve]), H.push(ge.value)));
                }
                return Promise.resolve(0 < H.length && g.mutate({ trans: r, type: "add", values: H }).then(function(Ge) {
                  for (var pe in Ge.failures) ne.splice(parseInt(pe), 1);
                  T(H.length, Ge);
                })).then(function() {
                  return (0 < J.length || N && typeof n == "object") && g.mutate({ trans: r, type: "put", keys: X, values: J, criteria: N, changeSpec: typeof n != "function" && n, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return T(J.length, Ge);
                  });
                }).then(function() {
                  return (0 < ne.length || N && S) && g.mutate({ trans: r, type: "delete", keys: ne, criteria: N, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return $l(u.table, ne, Ge);
                  }).then(function(Ge) {
                    return T(ne.length, Ge);
                  });
                }).then(function() {
                  return q.length > F + U && A(F + b);
                });
              });
            }
            var N = ol(u) && u.limit === 1 / 0 && (typeof n != "function" || S) && { index: u.index, range: u.range };
            return A(0).then(function() {
              if (0 < D.length) throw new xn("Error modifying one or more objects", D, w, C);
              return q.length;
            });
          });
        });
      }, Re.prototype.delete = function() {
        var n = this._ctx, t = n.range;
        return !ol(n) || n.table.schema.yProps || !n.isPrimKey && t.type !== 3 ? this.modify(uu) : this._write(function(u) {
          var r = n.table.core.schema.primaryKey, c = t;
          return n.table.core.count({ trans: u, query: { index: r, range: c } }).then(function(m) {
            return n.table.core.mutate({ trans: u, type: "deleteRange", range: c }).then(function(L) {
              var g = L.failures, L = L.numFailures;
              if (L) throw new xn("Could not delete some values", Object.keys(g).map(function(O) {
                return g[O];
              }), m - L);
              return m - L;
            });
          });
        });
      }, Re);
      function Re() {
      }
      var uu = function(n, t) {
        return t.value = null;
      };
      function lr(n, t) {
        return n < t ? -1 : n === t ? 0 : 1;
      }
      function tr(n, t) {
        return t < n ? -1 : n === t ? 0 : 1;
      }
      function dn(n, t, u) {
        return n = n instanceof ru ? new n.Collection(n) : n, n._ctx.error = new (u || TypeError)(t), n;
      }
      function ml(n) {
        return new n.Collection(n, function() {
          return au("");
        }).limit(0);
      }
      function Xl(n, t, u, r) {
        var c, m, p, g, L, O, b, v = u.length;
        if (!u.every(function(w) {
          return typeof w == "string";
        })) return dn(n, Yi);
        function T(w) {
          c = w === "next" ? function(S) {
            return S.toUpperCase();
          } : function(S) {
            return S.toLowerCase();
          }, m = w === "next" ? function(S) {
            return S.toLowerCase();
          } : function(S) {
            return S.toUpperCase();
          }, p = w === "next" ? lr : tr;
          var C = u.map(function(S) {
            return { lower: m(S), upper: c(S) };
          }).sort(function(S, q) {
            return p(S.lower, q.lower);
          });
          g = C.map(function(S) {
            return S.upper;
          }), L = C.map(function(S) {
            return S.lower;
          }), b = (O = w) === "next" ? "" : r;
        }
        T("next"), n = new n.Collection(n, function() {
          return zn(g[0], L[v - 1] + r);
        }), n._ondirectionchange = function(w) {
          T(w);
        };
        var D = 0;
        return n._addAlgorithm(function(w, C, S) {
          var q = w.key;
          if (typeof q != "string") return !1;
          var A = m(q);
          if (t(A, L, D)) return !0;
          for (var N = null, F = D; F < v; ++F) {
            var U = function(W, z, H, J, X, ne) {
              for (var ve = Math.min(W.length, J.length), Pe = -1, ge = 0; ge < ve; ++ge) {
                var Ge = z[ge];
                if (Ge !== J[ge]) return X(W[ge], H[ge]) < 0 ? W.substr(0, ge) + H[ge] + H.substr(ge + 1) : X(W[ge], J[ge]) < 0 ? W.substr(0, ge) + J[ge] + H.substr(ge + 1) : 0 <= Pe ? W.substr(0, Pe) + z[Pe] + H.substr(Pe + 1) : null;
                X(W[ge], Ge) < 0 && (Pe = ge);
              }
              return ve < J.length && ne === "next" ? W + H.substr(W.length) : ve < W.length && ne === "prev" ? W.substr(0, H.length) : Pe < 0 ? null : W.substr(0, Pe) + J[Pe] + H.substr(Pe + 1);
            }(q, A, g[F], L[F], p, O);
            U === null && N === null ? D = F + 1 : (N === null || 0 < p(N, U)) && (N = U);
          }
          return C(N !== null ? function() {
            w.continue(N + b);
          } : S), !1;
        }), n;
      }
      function zn(n, t, u, r) {
        return { type: 2, lower: n, upper: t, lowerOpen: u, upperOpen: r };
      }
      function au(n) {
        return { type: 1, lower: n, upper: n };
      }
      var ru = (Object.defineProperty(en.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), en.prototype.between = function(n, t, u, r) {
        u = u !== !1, r = r === !0;
        try {
          return 0 < this._cmp(n, t) || this._cmp(n, t) === 0 && (u || r) && (!u || !r) ? ml(this) : new this.Collection(this, function() {
            return zn(n, t, !u, !r);
          });
        } catch {
          return dn(this, An);
        }
      }, en.prototype.equals = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return au(n);
        });
      }, en.prototype.above = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return zn(n, void 0, !0);
        });
      }, en.prototype.aboveOrEqual = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return zn(n, void 0, !1);
        });
      }, en.prototype.below = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return zn(void 0, n, !1, !0);
        });
      }, en.prototype.belowOrEqual = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return zn(void 0, n);
        });
      }, en.prototype.startsWith = function(n) {
        return typeof n != "string" ? dn(this, Yi) : this.between(n, n + Qn, !0, !0);
      }, en.prototype.startsWithIgnoreCase = function(n) {
        return n === "" ? this.startsWith(n) : Xl(this, function(t, u) {
          return t.indexOf(u[0]) === 0;
        }, [n], Qn);
      }, en.prototype.equalsIgnoreCase = function(n) {
        return Xl(this, function(t, u) {
          return t === u[0];
        }, [n], "");
      }, en.prototype.anyOfIgnoreCase = function() {
        var n = Ae.apply(we, arguments);
        return n.length === 0 ? ml(this) : Xl(this, function(t, u) {
          return u.indexOf(t) !== -1;
        }, n, "");
      }, en.prototype.startsWithAnyOfIgnoreCase = function() {
        var n = Ae.apply(we, arguments);
        return n.length === 0 ? ml(this) : Xl(this, function(t, u) {
          return u.some(function(r) {
            return t.indexOf(r) === 0;
          });
        }, n, Qn);
      }, en.prototype.anyOf = function() {
        var n = this, t = Ae.apply(we, arguments), u = this._cmp;
        try {
          t.sort(u);
        } catch {
          return dn(this, An);
        }
        if (t.length === 0) return ml(this);
        var r = new this.Collection(this, function() {
          return zn(t[0], t[t.length - 1]);
        });
        r._ondirectionchange = function(m) {
          u = m === "next" ? n._ascending : n._descending, t.sort(u);
        };
        var c = 0;
        return r._addAlgorithm(function(m, p, g) {
          for (var L = m.key; 0 < u(L, t[c]); ) if (++c === t.length) return p(g), !1;
          return u(L, t[c]) === 0 || (p(function() {
            m.continue(t[c]);
          }), !1);
        }), r;
      }, en.prototype.notEqual = function(n) {
        return this.inAnyRange([[-1 / 0, n], [n, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, en.prototype.noneOf = function() {
        var n = Ae.apply(we, arguments);
        if (n.length === 0) return new this.Collection(this);
        try {
          n.sort(this._ascending);
        } catch {
          return dn(this, An);
        }
        var t = n.reduce(function(u, r) {
          return u ? u.concat([[u[u.length - 1][1], r]]) : [[-1 / 0, r]];
        }, null);
        return t.push([n[n.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, en.prototype.inAnyRange = function(q, t) {
        var u = this, r = this._cmp, c = this._ascending, m = this._descending, p = this._min, g = this._max;
        if (q.length === 0) return ml(this);
        if (!q.every(function(A) {
          return A[0] !== void 0 && A[1] !== void 0 && c(A[0], A[1]) <= 0;
        })) return dn(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", B.InvalidArgument);
        var L = !t || t.includeLowers !== !1, O = t && t.includeUppers === !0, b, v = c;
        function T(A, N) {
          return v(A[0], N[0]);
        }
        try {
          (b = q.reduce(function(A, N) {
            for (var F = 0, U = A.length; F < U; ++F) {
              var W = A[F];
              if (r(N[0], W[1]) < 0 && 0 < r(N[1], W[0])) {
                W[0] = p(W[0], N[0]), W[1] = g(W[1], N[1]);
                break;
              }
            }
            return F === U && A.push(N), A;
          }, [])).sort(T);
        } catch {
          return dn(this, An);
        }
        var D = 0, w = O ? function(A) {
          return 0 < c(A, b[D][1]);
        } : function(A) {
          return 0 <= c(A, b[D][1]);
        }, C = L ? function(A) {
          return 0 < m(A, b[D][0]);
        } : function(A) {
          return 0 <= m(A, b[D][0]);
        }, S = w, q = new this.Collection(this, function() {
          return zn(b[0][0], b[b.length - 1][1], !L, !O);
        });
        return q._ondirectionchange = function(A) {
          v = A === "next" ? (S = w, c) : (S = C, m), b.sort(T);
        }, q._addAlgorithm(function(A, N, F) {
          for (var U, W = A.key; S(W); ) if (++D === b.length) return N(F), !1;
          return !w(U = W) && !C(U) || (u._cmp(W, b[D][1]) === 0 || u._cmp(W, b[D][0]) === 0 || N(function() {
            v === c ? A.continue(b[D][0]) : A.continue(b[D][1]);
          }), !1);
        }), q;
      }, en.prototype.startsWithAnyOf = function() {
        var n = Ae.apply(we, arguments);
        return n.every(function(t) {
          return typeof t == "string";
        }) ? n.length === 0 ? ml(this) : this.inAnyRange(n.map(function(t) {
          return [t, t + Qn];
        })) : dn(this, "startsWithAnyOf() only works with strings");
      }, en);
      function en() {
      }
      function wn(n) {
        return Be(function(t) {
          return Ol(t), n(t.target.error), !1;
        });
      }
      function Ol(n) {
        n.stopPropagation && n.stopPropagation(), n.preventDefault && n.preventDefault();
      }
      var wl = "storagemutated", Mt = "x-storagemutated-1", jn = Il(null, wl), ir = (bn.prototype._lock = function() {
        return G(!re.global), ++this._reculock, this._reculock !== 1 || re.global || (re.lockOwnerFor = this), this;
      }, bn.prototype._unlock = function() {
        if (G(!re.global), --this._reculock == 0) for (re.global || (re.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var n = this._blockedFuncs.shift();
          try {
            Xn(n[1], n[0]);
          } catch {
          }
        }
        return this;
      }, bn.prototype._locked = function() {
        return this._reculock && re.lockOwnerFor !== this;
      }, bn.prototype.create = function(n) {
        var t = this;
        if (!this.mode) return this;
        var u = this.db.idbdb, r = this.db._state.dbOpenError;
        if (G(!this.idbtrans), !n && !u) switch (r && r.name) {
          case "DatabaseClosedError":
            throw new B.DatabaseClosed(r);
          case "MissingAPIError":
            throw new B.MissingAPI(r.message, r);
          default:
            throw new B.OpenFailed(r);
        }
        if (!this.active) throw new B.TransactionInactive();
        return G(this._completion._state === null), (n = this.idbtrans = n || (this.db.core || u).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Be(function(c) {
          Ol(c), t._reject(n.error);
        }), n.onabort = Be(function(c) {
          Ol(c), t.active && t._reject(new B.Abort(n.error)), t.active = !1, t.on("abort").fire(c);
        }), n.oncomplete = Be(function() {
          t.active = !1, t._resolve(), "mutatedParts" in n && jn.storagemutated.fire(n.mutatedParts);
        }), this;
      }, bn.prototype._promise = function(n, t, u) {
        var r = this;
        if (n === "readwrite" && this.mode !== "readwrite") return je(new B.ReadOnly("Transaction is readonly"));
        if (!this.active) return je(new B.TransactionInactive());
        if (this._locked()) return new ee(function(m, p) {
          r._blockedFuncs.push([function() {
            r._promise(n, t, u).then(m, p);
          }, re]);
        });
        if (u) return Un(function() {
          var m = new ee(function(p, g) {
            r._lock();
            var L = t(p, g, r);
            L && L.then && L.then(p, g);
          });
          return m.finally(function() {
            return r._unlock();
          }), m._lib = !0, m;
        });
        var c = new ee(function(m, p) {
          var g = t(m, p, r);
          g && g.then && g.then(m, p);
        });
        return c._lib = !0, c;
      }, bn.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, bn.prototype.waitFor = function(n) {
        var t, u = this._root(), r = ee.resolve(n);
        u._waitingFor ? u._waitingFor = u._waitingFor.then(function() {
          return r;
        }) : (u._waitingFor = r, u._waitingQueue = [], t = u.idbtrans.objectStore(u.storeNames[0]), function m() {
          for (++u._spinCount; u._waitingQueue.length; ) u._waitingQueue.shift()();
          u._waitingFor && (t.get(-1 / 0).onsuccess = m);
        }());
        var c = u._waitingFor;
        return new ee(function(m, p) {
          r.then(function(g) {
            return u._waitingQueue.push(Be(m.bind(null, g)));
          }, function(g) {
            return u._waitingQueue.push(Be(p.bind(null, g)));
          }).finally(function() {
            u._waitingFor === c && (u._waitingFor = null);
          });
        });
      }, bn.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new B.Abort()));
      }, bn.prototype.table = function(n) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (y(t, n)) return t[n];
        var u = this.schema[n];
        if (!u) throw new B.NotFound("Table " + n + " not part of transaction");
        return u = new this.db.Table(n, u, this), u.core = this.db.core.table(n), t[n] = u;
      }, bn);
      function bn() {
      }
      function kt(n, t, u, r, c, m, p, g) {
        return { name: n, keyPath: t, unique: u, multi: r, auto: c, compound: m, src: (u && !p ? "&" : "") + (r ? "*" : "") + (c ? "++" : "") + su(t), type: g };
      }
      function su(n) {
        return typeof n == "string" ? n : n ? "[" + [].join.call(n, "+") + "]" : "";
      }
      function Vt(n, t, u) {
        return { name: n, primKey: t, indexes: u, mappedClass: null, idxByName: (r = function(c) {
          return [c.name, c];
        }, u.reduce(function(c, m, p) {
          return p = r(m, p), p && (c[p[0]] = p[1]), c;
        }, {})) };
        var r;
      }
      var bl = function(n) {
        try {
          return n.only([[]]), bl = function() {
            return [[]];
          }, [[]];
        } catch {
          return bl = function() {
            return Qn;
          }, Qn;
        }
      };
      function Bt(n) {
        return n == null ? function() {
        } : typeof n == "string" ? (t = n).split(".").length === 1 ? function(u) {
          return u[t];
        } : function(u) {
          return se(u, t);
        } : function(u) {
          return se(u, n);
        };
        var t;
      }
      function cu(n) {
        return [].slice.call(n);
      }
      var ur = 0;
      function Sl(n) {
        return n == null ? ":id" : typeof n == "string" ? n : "[".concat(n.join("+"), "]");
      }
      function ar(n, t, L) {
        function r(S) {
          if (S.type === 3) return null;
          if (S.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var D = S.lower, w = S.upper, C = S.lowerOpen, S = S.upperOpen;
          return D === void 0 ? w === void 0 ? null : t.upperBound(w, !!S) : w === void 0 ? t.lowerBound(D, !!C) : t.bound(D, w, !!C, !!S);
        }
        function c(T) {
          var D, w = T.name;
          return { name: w, schema: T, mutate: function(C) {
            var S = C.trans, q = C.type, A = C.keys, N = C.values, F = C.range;
            return new Promise(function(U, W) {
              U = Be(U);
              var z = S.objectStore(w), H = z.keyPath == null, J = q === "put" || q === "add";
              if (!J && q !== "delete" && q !== "deleteRange") throw new Error("Invalid operation type: " + q);
              var X, ne = (A || N || { length: 1 }).length;
              if (A && N && A.length !== N.length) throw new Error("Given keys array must have same length as given values array.");
              if (ne === 0) return U({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ve(mn) {
                ++Ge, Ol(mn);
              }
              var Pe = [], ge = [], Ge = 0;
              if (q === "deleteRange") {
                if (F.type === 4) return U({ numFailures: Ge, failures: ge, results: [], lastResult: void 0 });
                F.type === 3 ? Pe.push(X = z.clear()) : Pe.push(X = z.delete(r(F)));
              } else {
                var H = J ? H ? [N, A] : [N, null] : [A, null], pe = H[0], an = H[1];
                if (J) for (var rn = 0; rn < ne; ++rn) Pe.push(X = an && an[rn] !== void 0 ? z[q](pe[rn], an[rn]) : z[q](pe[rn])), X.onerror = ve;
                else for (rn = 0; rn < ne; ++rn) Pe.push(X = z[q](pe[rn])), X.onerror = ve;
              }
              function ct(mn) {
                mn = mn.target.result, Pe.forEach(function(ll, ii) {
                  return ll.error != null && (ge[ii] = ll.error);
                }), U({ numFailures: Ge, failures: ge, results: q === "delete" ? A : Pe.map(function(ll) {
                  return ll.result;
                }), lastResult: mn });
              }
              X.onerror = function(mn) {
                ve(mn), ct(mn);
              }, X.onsuccess = ct;
            });
          }, getMany: function(C) {
            var S = C.trans, q = C.keys;
            return new Promise(function(A, N) {
              A = Be(A);
              for (var F, U = S.objectStore(w), W = q.length, z = new Array(W), H = 0, J = 0, X = function(Pe) {
                Pe = Pe.target, z[Pe._pos] = Pe.result, ++J === H && A(z);
              }, ne = wn(N), ve = 0; ve < W; ++ve) q[ve] != null && ((F = U.get(q[ve]))._pos = ve, F.onsuccess = X, F.onerror = ne, ++H);
              H === 0 && A(z);
            });
          }, get: function(C) {
            var S = C.trans, q = C.key;
            return new Promise(function(A, N) {
              A = Be(A);
              var F = S.objectStore(w).get(q);
              F.onsuccess = function(U) {
                return A(U.target.result);
              }, F.onerror = wn(N);
            });
          }, query: (D = O, function(C) {
            return new Promise(function(S, q) {
              S = Be(S);
              var A, N, F, H = C.trans, U = C.values, W = C.limit, X = C.query, z = W === 1 / 0 ? void 0 : W, J = X.index, X = X.range, H = H.objectStore(w), J = J.isPrimaryKey ? H : H.index(J.name), X = r(X);
              if (W === 0) return S({ result: [] });
              D ? ((z = U ? J.getAll(X, z) : J.getAllKeys(X, z)).onsuccess = function(ne) {
                return S({ result: ne.target.result });
              }, z.onerror = wn(q)) : (A = 0, N = !U && "openKeyCursor" in J ? J.openKeyCursor(X) : J.openCursor(X), F = [], N.onsuccess = function(ne) {
                var ve = N.result;
                return ve ? (F.push(U ? ve.value : ve.primaryKey), ++A === W ? S({ result: F }) : void ve.continue()) : S({ result: F });
              }, N.onerror = wn(q));
            });
          }), openCursor: function(C) {
            var S = C.trans, q = C.values, A = C.query, N = C.reverse, F = C.unique;
            return new Promise(function(U, W) {
              U = Be(U);
              var J = A.index, z = A.range, H = S.objectStore(w), H = J.isPrimaryKey ? H : H.index(J.name), J = N ? F ? "prevunique" : "prev" : F ? "nextunique" : "next", X = !q && "openKeyCursor" in H ? H.openKeyCursor(r(z), J) : H.openCursor(r(z), J);
              X.onerror = wn(W), X.onsuccess = Be(function(ne) {
                var ve, Pe, ge, Ge, pe = X.result;
                pe ? (pe.___id = ++ur, pe.done = !1, ve = pe.continue.bind(pe), Pe = (Pe = pe.continuePrimaryKey) && Pe.bind(pe), ge = pe.advance.bind(pe), Ge = function() {
                  throw new Error("Cursor not stopped");
                }, pe.trans = S, pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = function() {
                  throw new Error("Cursor not started");
                }, pe.fail = Be(W), pe.next = function() {
                  var an = this, rn = 1;
                  return this.start(function() {
                    return rn-- ? an.continue() : an.stop();
                  }).then(function() {
                    return an;
                  });
                }, pe.start = function(an) {
                  function rn() {
                    if (X.result) try {
                      an();
                    } catch (mn) {
                      pe.fail(mn);
                    }
                    else pe.done = !0, pe.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, pe.stop();
                  }
                  var ct = new Promise(function(mn, ll) {
                    mn = Be(mn), X.onerror = wn(ll), pe.fail = ll, pe.stop = function(ii) {
                      pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = Ge, mn(ii);
                    };
                  });
                  return X.onsuccess = Be(function(mn) {
                    X.onsuccess = rn, rn();
                  }), pe.continue = ve, pe.continuePrimaryKey = Pe, pe.advance = ge, rn(), ct;
                }, U(pe)) : U(null);
              }, W);
            });
          }, count: function(C) {
            var S = C.query, q = C.trans, A = S.index, N = S.range;
            return new Promise(function(F, U) {
              var W = q.objectStore(w), z = A.isPrimaryKey ? W : W.index(A.name), W = r(N), z = W ? z.count(W) : z.count();
              z.onsuccess = Be(function(H) {
                return F(H.target.result);
              }), z.onerror = wn(U);
            });
          } };
        }
        var m, p, g, b = (p = L, g = cu((m = n).objectStoreNames), { schema: { name: m.name, tables: g.map(function(T) {
          return p.objectStore(T);
        }).map(function(T) {
          var D = T.keyPath, S = T.autoIncrement, w = d(D), C = {}, S = { name: T.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: D == null, compound: w, keyPath: D, autoIncrement: S, unique: !0, extractKey: Bt(D) }, indexes: cu(T.indexNames).map(function(q) {
            return T.index(q);
          }).map(function(F) {
            var A = F.name, N = F.unique, U = F.multiEntry, F = F.keyPath, U = { name: A, compound: d(F), keyPath: F, unique: N, multiEntry: U, extractKey: Bt(F) };
            return C[Sl(F)] = U;
          }), getIndexByKeyPath: function(q) {
            return C[Sl(q)];
          } };
          return C[":id"] = S.primaryKey, D != null && (C[Sl(D)] = S.primaryKey), S;
        }) }, hasGetAll: 0 < g.length && "getAll" in p.objectStore(g[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), L = b.schema, O = b.hasGetAll, b = L.tables.map(c), v = {};
        return b.forEach(function(T) {
          return v[T.name] = T;
        }), { stack: "dbcore", transaction: n.transaction.bind(n), table: function(T) {
          if (!v[T]) throw new Error("Table '".concat(T, "' not found"));
          return v[T];
        }, MIN_KEY: -1 / 0, MAX_KEY: bl(t), schema: L };
      }
      function rr(n, t, u, r) {
        var c = u.IDBKeyRange;
        return u.indexedDB, { dbcore: (r = ar(t, c, r), n.dbcore.reduce(function(m, p) {
          return p = p.create, a(a({}, m), p(m));
        }, r)) };
      }
      function Ql(n, r) {
        var u = r.db, r = rr(n._middlewares, u, n._deps, r);
        n.core = r.dbcore, n.tables.forEach(function(c) {
          var m = c.name;
          n.core.schema.tables.some(function(p) {
            return p.name === m;
          }) && (c.core = n.core.table(m), n[m] instanceof n.Table && (n[m].core = c.core));
        });
      }
      function Jl(n, t, u, r) {
        u.forEach(function(c) {
          var m = r[c];
          t.forEach(function(p) {
            var g = function L(O, b) {
              return K(O, b) || (O = I(O)) && L(O, b);
            }(p, c);
            (!g || "value" in g && g.value === void 0) && (p === n.Transaction.prototype || p instanceof n.Transaction ? R(p, c, { get: function() {
              return this.table(c);
            }, set: function(L) {
              E(this, c, { value: L, writable: !0, configurable: !0, enumerable: !0 });
            } }) : p[c] = new n.Table(c, m));
          });
        });
      }
      function Zt(n, t) {
        t.forEach(function(u) {
          for (var r in u) u[r] instanceof n.Table && delete u[r];
        });
      }
      function sr(n, t) {
        return n._cfg.version - t._cfg.version;
      }
      function cr(n, t, u, r) {
        var c = n._dbSchema;
        u.objectStoreNames.contains("$meta") && !c.$meta && (c.$meta = Vt("$meta", mu("")[0], []), n._storeNames.push("$meta"));
        var m = n._createTransaction("readwrite", n._storeNames, c);
        m.create(u), m._completion.catch(r);
        var p = m._reject.bind(m), g = re.transless || re;
        Un(function() {
          return re.trans = m, re.transless = g, t !== 0 ? (Ql(n, u), O = t, ((L = m).storeNames.includes("$meta") ? L.table("$meta").get("version").then(function(b) {
            return b ?? O;
          }) : ee.resolve(O)).then(function(b) {
            return T = b, D = m, w = u, C = [], b = (v = n)._versions, S = v._dbSchema = nt(0, v.idbdb, w), (b = b.filter(function(q) {
              return q._cfg.version >= T;
            })).length !== 0 ? (b.forEach(function(q) {
              C.push(function() {
                var A = S, N = q._cfg.dbschema;
                lt(v, A, w), lt(v, N, w), S = v._dbSchema = N;
                var F = Ut(A, N);
                F.add.forEach(function(J) {
                  Kt(w, J[0], J[1].primKey, J[1].indexes);
                }), F.change.forEach(function(J) {
                  if (J.recreate) throw new B.Upgrade("Not yet support for changing primary key");
                  var X = w.objectStore(J.name);
                  J.add.forEach(function(ne) {
                    return et(X, ne);
                  }), J.change.forEach(function(ne) {
                    X.deleteIndex(ne.name), et(X, ne);
                  }), J.del.forEach(function(ne) {
                    return X.deleteIndex(ne);
                  });
                });
                var U = q._cfg.contentUpgrade;
                if (U && q._cfg.version > T) {
                  Ql(v, w), D._memoizedTables = {};
                  var W = fe(N);
                  F.del.forEach(function(J) {
                    W[J] = A[J];
                  }), Zt(v, [v.Transaction.prototype]), Jl(v, [v.Transaction.prototype], f(W), W), D.schema = W;
                  var z, H = $e(U);
                  return H && sl(), F = ee.follow(function() {
                    var J;
                    (z = U(D)) && H && (J = Kn.bind(null, null), z.then(J, J));
                  }), z && typeof z.then == "function" ? ee.resolve(z) : F.then(function() {
                    return z;
                  });
                }
              }), C.push(function(A) {
                var N, F, U = q._cfg.dbschema;
                N = U, F = A, [].slice.call(F.db.objectStoreNames).forEach(function(W) {
                  return N[W] == null && F.db.deleteObjectStore(W);
                }), Zt(v, [v.Transaction.prototype]), Jl(v, [v.Transaction.prototype], v._storeNames, v._dbSchema), D.schema = v._dbSchema;
              }), C.push(function(A) {
                v.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(v.idbdb.version / 10) === q._cfg.version ? (v.idbdb.deleteObjectStore("$meta"), delete v._dbSchema.$meta, v._storeNames = v._storeNames.filter(function(N) {
                  return N !== "$meta";
                })) : A.objectStore("$meta").put(q._cfg.version, "version"));
              });
            }), function q() {
              return C.length ? ee.resolve(C.shift()(D.idbtrans)).then(q) : ee.resolve();
            }().then(function() {
              ou(S, w);
            })) : ee.resolve();
            var v, T, D, w, C, S;
          }).catch(p)) : (f(c).forEach(function(b) {
            Kt(u, b, c[b].primKey, c[b].indexes);
          }), Ql(n, u), void ee.follow(function() {
            return n.on.populate.fire(m);
          }).catch(p));
          var L, O;
        });
      }
      function or(n, t) {
        ou(n._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var u = nt(0, n.idbdb, t);
        lt(n, n._dbSchema, t);
        for (var r = 0, c = Ut(u, n._dbSchema).change; r < c.length; r++) {
          var m = function(p) {
            if (p.change.length || p.recreate) return console.warn("Unable to patch indexes of table ".concat(p.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var g = t.objectStore(p.name);
            p.add.forEach(function(L) {
              Oe && console.debug("Dexie upgrade patch: Creating missing index ".concat(p.name, ".").concat(L.src)), et(g, L);
            });
          }(c[r]);
          if (typeof m == "object") return m.value;
        }
      }
      function Ut(n, t) {
        var u, r = { del: [], add: [], change: [] };
        for (u in n) t[u] || r.del.push(u);
        for (u in t) {
          var c = n[u], m = t[u];
          if (c) {
            var p = { name: u, def: m, recreate: !1, del: [], add: [], change: [] };
            if ("" + (c.primKey.keyPath || "") != "" + (m.primKey.keyPath || "") || c.primKey.auto !== m.primKey.auto) p.recreate = !0, r.change.push(p);
            else {
              var g = c.idxByName, L = m.idxByName, O = void 0;
              for (O in g) L[O] || p.del.push(O);
              for (O in L) {
                var b = g[O], v = L[O];
                b ? b.src !== v.src && p.change.push(v) : p.add.push(v);
              }
              (0 < p.del.length || 0 < p.add.length || 0 < p.change.length) && r.change.push(p);
            }
          } else r.add.push([u, m]);
        }
        return r;
      }
      function Kt(n, t, u, r) {
        var c = n.db.createObjectStore(t, u.keyPath ? { keyPath: u.keyPath, autoIncrement: u.auto } : { autoIncrement: u.auto });
        return r.forEach(function(m) {
          return et(c, m);
        }), c;
      }
      function ou(n, t) {
        f(n).forEach(function(u) {
          t.db.objectStoreNames.contains(u) || (Oe && console.debug("Dexie: Creating missing table", u), Kt(t, u, n[u].primKey, n[u].indexes));
        });
      }
      function et(n, t) {
        n.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function nt(n, t, u) {
        var r = {};
        return Q(t.objectStoreNames, 0).forEach(function(c) {
          for (var m = u.objectStore(c), p = kt(su(O = m.keyPath), O || "", !0, !1, !!m.autoIncrement, O && typeof O != "string", !0), g = [], L = 0; L < m.indexNames.length; ++L) {
            var b = m.index(m.indexNames[L]), O = b.keyPath, b = kt(b.name, O, !!b.unique, !!b.multiEntry, !1, O && typeof O != "string", !1);
            g.push(b);
          }
          r[c] = Vt(c, p, g);
        }), r;
      }
      function lt(n, t, u) {
        for (var r = u.db.objectStoreNames, c = 0; c < r.length; ++c) {
          var m = r[c], p = u.objectStore(m);
          n._hasGetAll = "getAll" in p;
          for (var g = 0; g < p.indexNames.length; ++g) {
            var L = p.indexNames[g], O = p.index(L).keyPath, b = typeof O == "string" ? O : "[" + Q(O).join("+") + "]";
            !t[m] || (O = t[m].idxByName[b]) && (O.name = L, delete t[m].idxByName[b], t[m].idxByName[L] = O);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && o.WorkerGlobalScope && o instanceof o.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1);
      }
      function mu(n) {
        return n.split(",").map(function(t, u) {
          var m = t.split(":"), r = (c = m[1]) === null || c === void 0 ? void 0 : c.trim(), c = (t = m[0].trim()).replace(/([&*]|\+\+)/g, ""), m = /^\[/.test(c) ? c.match(/^\[(.*)\]$/)[1].split("+") : c;
          return kt(c, m || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), d(m), u === 0, r);
        });
      }
      var mr = (fl.prototype._createTableSchema = Vt, fl.prototype._parseIndexSyntax = mu, fl.prototype._parseStoresSpec = function(n, t) {
        var u = this;
        f(n).forEach(function(r) {
          if (n[r] !== null) {
            var c = u._parseIndexSyntax(n[r]), m = c.shift();
            if (!m) throw new B.Schema("Invalid schema for table " + r + ": " + n[r]);
            if (m.unique = !0, m.multi) throw new B.Schema("Primary key cannot be multiEntry*");
            c.forEach(function(p) {
              if (p.auto) throw new B.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!p.keyPath) throw new B.Schema("Index must have a name and cannot be an empty string");
            }), c = u._createTableSchema(r, m, c), t[r] = c;
          }
        });
      }, fl.prototype.stores = function(u) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? h(this._cfg.storesSource, u) : u;
        var u = t._versions, r = {}, c = {};
        return u.forEach(function(m) {
          h(r, m._cfg.storesSource), c = m._cfg.dbschema = {}, m._parseStoresSpec(r, c);
        }), t._dbSchema = c, Zt(t, [t._allTables, t, t.Transaction.prototype]), Jl(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], f(c), c), t._storeNames = f(c), this;
      }, fl.prototype.upgrade = function(n) {
        return this._cfg.contentUpgrade = Ee(this._cfg.contentUpgrade || De, n), this;
      }, fl);
      function fl() {
      }
      function Gt(n, t) {
        var u = n._dbNamesDB;
        return u || (u = n._dbNamesDB = new En(jl, { addons: [], indexedDB: n, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), u.table("dbnames");
      }
      function zt(n) {
        return n && typeof n.databases == "function";
      }
      function jt(n) {
        return Un(function() {
          return re.letThrough = !0, n();
        });
      }
      function Ht(n) {
        return !("from" in n);
      }
      var un = function(n, t) {
        if (!this) {
          var u = new un();
          return n && "d" in n && h(u, n), u;
        }
        h(this, arguments.length ? { d: 1, from: n, to: 1 < arguments.length ? t : n } : { d: 0 });
      };
      function Cl(n, t, u) {
        var r = Se(t, u);
        if (!isNaN(r)) {
          if (0 < r) throw RangeError();
          if (Ht(n)) return h(n, { from: t, to: u, d: 1 });
          var c = n.l, r = n.r;
          if (Se(u, n.from) < 0) return c ? Cl(c, t, u) : n.l = { from: t, to: u, d: 1, l: null, r: null }, du(n);
          if (0 < Se(t, n.to)) return r ? Cl(r, t, u) : n.r = { from: t, to: u, d: 1, l: null, r: null }, du(n);
          Se(t, n.from) < 0 && (n.from = t, n.l = null, n.d = r ? r.d + 1 : 1), 0 < Se(u, n.to) && (n.to = u, n.r = null, n.d = n.l ? n.l.d + 1 : 1), u = !n.r, c && !n.l && Tl(n, c), r && u && Tl(n, r);
        }
      }
      function Tl(n, t) {
        Ht(t) || function u(r, L) {
          var m = L.from, p = L.to, g = L.l, L = L.r;
          Cl(r, m, p), g && u(r, g), L && u(r, L);
        }(n, t);
      }
      function fu(n, t) {
        var u = tt(t), r = u.next();
        if (r.done) return !1;
        for (var c = r.value, m = tt(n), p = m.next(c.from), g = p.value; !r.done && !p.done; ) {
          if (Se(g.from, c.to) <= 0 && 0 <= Se(g.to, c.from)) return !0;
          Se(c.from, g.from) < 0 ? c = (r = u.next(g.from)).value : g = (p = m.next(c.from)).value;
        }
        return !1;
      }
      function tt(n) {
        var t = Ht(n) ? null : { s: 0, n };
        return { next: function(u) {
          for (var r = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, r) for (; t.n.l && Se(u, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !r || Se(u, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function du(n) {
        var t, u, r = (((t = n.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((u = n.l) === null || u === void 0 ? void 0 : u.d) || 0), c = 1 < r ? "r" : r < -1 ? "l" : "";
        c && (t = c == "r" ? "l" : "r", u = a({}, n), r = n[c], n.from = r.from, n.to = r.to, n[c] = r[c], u[c] = r[t], (n[t] = u).d = pu(u)), n.d = pu(n);
      }
      function pu(u) {
        var t = u.r, u = u.l;
        return (t ? u ? Math.max(t.d, u.d) : t.d : u ? u.d : 0) + 1;
      }
      function it(n, t) {
        return f(t).forEach(function(u) {
          n[u] ? Tl(n[u], t[u]) : n[u] = function r(c) {
            var m, p, g = {};
            for (m in c) y(c, m) && (p = c[m], g[m] = !p || typeof p != "object" || Le.has(p.constructor) ? p : r(p));
            return g;
          }(t[u]);
        }), n;
      }
      function $t(n, t) {
        return n.all || t.all || Object.keys(n).some(function(u) {
          return t[u] && fu(t[u], n[u]);
        });
      }
      P(un.prototype, ((In = { add: function(n) {
        return Tl(this, n), this;
      }, addKey: function(n) {
        return Cl(this, n, n), this;
      }, addKeys: function(n) {
        var t = this;
        return n.forEach(function(u) {
          return Cl(t, u, u);
        }), this;
      }, hasKey: function(n) {
        var t = tt(this).next(n).value;
        return t && Se(t.from, n) <= 0 && 0 <= Se(t.to, n);
      } })[xe] = function() {
        return tt(this);
      }, In));
      var el = {}, Wt = {}, Yt = !1;
      function ut(n) {
        it(Wt, n), Yt || (Yt = !0, setTimeout(function() {
          Yt = !1, Xt(Wt, !(Wt = {}));
        }, 0));
      }
      function Xt(n, t) {
        t === void 0 && (t = !1);
        var u = /* @__PURE__ */ new Set();
        if (n.all) for (var r = 0, c = Object.values(el); r < c.length; r++) hu(p = c[r], n, u, t);
        else for (var m in n) {
          var p, g = /^idb\:\/\/(.*)\/(.*)\//.exec(m);
          g && (m = g[1], g = g[2], (p = el["idb://".concat(m, "/").concat(g)]) && hu(p, n, u, t));
        }
        u.forEach(function(L) {
          return L();
        });
      }
      function hu(n, t, u, r) {
        for (var c = [], m = 0, p = Object.entries(n.queries.query); m < p.length; m++) {
          for (var g = p[m], L = g[0], O = [], b = 0, v = g[1]; b < v.length; b++) {
            var T = v[b];
            $t(t, T.obsSet) ? T.subscribers.forEach(function(S) {
              return u.add(S);
            }) : r && O.push(T);
          }
          r && c.push([L, O]);
        }
        if (r) for (var D = 0, w = c; D < w.length; D++) {
          var C = w[D], L = C[0], O = C[1];
          n.queries.query[L] = O;
        }
      }
      function fr(n) {
        var t = n._state, u = n._deps.indexedDB;
        if (t.isBeingOpened || n.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? je(t.dbOpenError) : n;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var r = t.openCanceller, c = Math.round(10 * n.verno), m = !1;
        function p() {
          if (t.openCanceller !== r) throw new B.DatabaseClosed("db.open() was cancelled");
        }
        function g() {
          return new ee(function(T, D) {
            if (p(), !u) throw new B.MissingAPI();
            var w = n.name, C = t.autoSchema || !c ? u.open(w) : u.open(w, c);
            if (!C) throw new B.MissingAPI();
            C.onerror = wn(D), C.onblocked = Be(n._fireOnBlocked), C.onupgradeneeded = Be(function(S) {
              var q;
              b = C.transaction, t.autoSchema && !n._options.allowEmptyDB ? (C.onerror = Ol, b.abort(), C.result.close(), (q = u.deleteDatabase(w)).onsuccess = q.onerror = Be(function() {
                D(new B.NoSuchDatabase("Database ".concat(w, " doesnt exist")));
              })) : (b.onerror = wn(D), S = S.oldVersion > Math.pow(2, 62) ? 0 : S.oldVersion, v = S < 1, n.idbdb = C.result, m && or(n, b), cr(n, S / 10, b, D));
            }, D), C.onsuccess = Be(function() {
              b = null;
              var S, q, A, N, F, U = n.idbdb = C.result, W = Q(U.objectStoreNames);
              if (0 < W.length) try {
                var z = U.transaction((N = W).length === 1 ? N[0] : N, "readonly");
                if (t.autoSchema) q = U, A = z, (S = n).verno = q.version / 10, A = S._dbSchema = nt(0, q, A), S._storeNames = Q(q.objectStoreNames, 0), Jl(S, [S._allTables], f(A), A);
                else if (lt(n, n._dbSchema, z), ((F = Ut(nt(0, (F = n).idbdb, z), F._dbSchema)).add.length || F.change.some(function(H) {
                  return H.add.length || H.change.length;
                })) && !m) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), U.close(), c = U.version + 1, m = !0, T(g());
                Ql(n, z);
              } catch {
              }
              cl.push(n), U.onversionchange = Be(function(H) {
                t.vcFired = !0, n.on("versionchange").fire(H);
              }), U.onclose = Be(function(H) {
                n.on("close").fire(H);
              }), v && (F = n._deps, z = w, U = F.indexedDB, F = F.IDBKeyRange, zt(U) || z === jl || Gt(U, F).put({ name: z }).catch(De)), T();
            }, D);
          }).catch(function(T) {
            switch (T?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), g();
                break;
              case "VersionError":
                if (0 < c) return c = 0, g();
            }
            return ee.reject(T);
          });
        }
        var L, O = t.dbReadyResolve, b = null, v = !1;
        return ee.race([r, (typeof navigator > "u" ? ee.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(T) {
          function D() {
            return indexedDB.databases().finally(T);
          }
          L = setInterval(D, 100), D();
        }).finally(function() {
          return clearInterval(L);
        }) : Promise.resolve()).then(g)]).then(function() {
          return p(), t.onReadyBeingFired = [], ee.resolve(jt(function() {
            return n.on.ready.fire(n.vip);
          })).then(function T() {
            if (0 < t.onReadyBeingFired.length) {
              var D = t.onReadyBeingFired.reduce(Ee, De);
              return t.onReadyBeingFired = [], ee.resolve(jt(function() {
                return D(n.vip);
              })).then(T);
            }
          });
        }).finally(function() {
          t.openCanceller === r && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(T) {
          t.dbOpenError = T;
          try {
            b && b.abort();
          } catch {
          }
          return r === t.openCanceller && n._close(), je(T);
        }).finally(function() {
          t.openComplete = !0, O();
        }).then(function() {
          var T;
          return v && (T = {}, n.tables.forEach(function(D) {
            D.schema.indexes.forEach(function(w) {
              w.name && (T["idb://".concat(n.name, "/").concat(D.name, "/").concat(w.name)] = new un(-1 / 0, [[[]]]));
            }), T["idb://".concat(n.name, "/").concat(D.name, "/")] = T["idb://".concat(n.name, "/").concat(D.name, "/:dels")] = new un(-1 / 0, [[[]]]);
          }), jn(wl).fire(T), Xt(T, !0)), n;
        });
      }
      function Qt(n) {
        function t(m) {
          return n.next(m);
        }
        var u = c(t), r = c(function(m) {
          return n.throw(m);
        });
        function c(m) {
          return function(L) {
            var g = m(L), L = g.value;
            return g.done ? L : L && typeof L.then == "function" ? L.then(u, r) : d(L) ? Promise.all(L).then(u, r) : u(L);
          };
        }
        return c(t)();
      }
      function at(n, t, u) {
        for (var r = d(n) ? n.slice() : [n], c = 0; c < u; ++c) r.push(t);
        return r;
      }
      var dr = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema, c = {}, m = [];
          function p(v, T, D) {
            var w = Sl(v), C = c[w] = c[w] || [], S = v == null ? 0 : typeof v == "string" ? 1 : v.length, q = 0 < T, q = a(a({}, D), { name: q ? "".concat(w, "(virtual-from:").concat(D.name, ")") : D.name, lowLevelIndex: D, isVirtual: q, keyTail: T, keyLength: S, extractKey: Bt(v), unique: !q && D.unique });
            return C.push(q), q.isPrimaryKey || m.push(q), 1 < S && p(S === 2 ? v[0] : v.slice(0, S - 1), T + 1, D), C.sort(function(A, N) {
              return A.keyTail - N.keyTail;
            }), q;
          }
          t = p(r.primaryKey.keyPath, 0, r.primaryKey), c[":id"] = [t];
          for (var g = 0, L = r.indexes; g < L.length; g++) {
            var O = L[g];
            p(O.keyPath, 0, O);
          }
          function b(v) {
            var T, D = v.query.index;
            return D.isVirtual ? a(a({}, v), { query: { index: D.lowLevelIndex, range: (T = v.query.range, D = D.keyTail, { type: T.type === 1 ? 2 : T.type, lower: at(T.lower, T.lowerOpen ? n.MAX_KEY : n.MIN_KEY, D), lowerOpen: !0, upper: at(T.upper, T.upperOpen ? n.MIN_KEY : n.MAX_KEY, D), upperOpen: !0 }) } }) : v;
          }
          return a(a({}, u), { schema: a(a({}, r), { primaryKey: t, indexes: m, getIndexByKeyPath: function(v) {
            return (v = c[Sl(v)]) && v[0];
          } }), count: function(v) {
            return u.count(b(v));
          }, query: function(v) {
            return u.query(b(v));
          }, openCursor: function(v) {
            var T = v.query.index, D = T.keyTail, w = T.isVirtual, C = T.keyLength;
            return w ? u.openCursor(b(v)).then(function(q) {
              return q && S(q);
            }) : u.openCursor(v);
            function S(q) {
              return Object.create(q, { continue: { value: function(A) {
                A != null ? q.continue(at(A, v.reverse ? n.MAX_KEY : n.MIN_KEY, D)) : v.unique ? q.continue(q.key.slice(0, C).concat(v.reverse ? n.MIN_KEY : n.MAX_KEY, D)) : q.continue();
              } }, continuePrimaryKey: { value: function(A, N) {
                q.continuePrimaryKey(at(A, n.MAX_KEY, D), N);
              } }, primaryKey: { get: function() {
                return q.primaryKey;
              } }, key: { get: function() {
                var A = q.key;
                return C === 1 ? A[0] : A.slice(0, C);
              } }, value: { get: function() {
                return q.value;
              } } });
            }
          } });
        } });
      } };
      function Jt(n, t, u, r) {
        return u = u || {}, r = r || "", f(n).forEach(function(c) {
          var m, p, g;
          y(t, c) ? (m = n[c], p = t[c], typeof m == "object" && typeof p == "object" && m && p ? (g = Ce(m)) !== Ce(p) ? u[r + c] = t[c] : g === "Object" ? Jt(m, p, u, r + c + ".") : m !== p && (u[r + c] = t[c]) : m !== p && (u[r + c] = t[c])) : u[r + c] = void 0;
        }), f(t).forEach(function(c) {
          y(n, c) || (u[r + c] = t[c]);
        }), u;
      }
      function ei(n, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(n.extractKey);
      }
      var pr = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema.primaryKey;
          return a(a({}, u), { mutate: function(c) {
            var m = re.trans, p = m.table(t).hook, g = p.deleting, L = p.creating, O = p.updating;
            switch (c.type) {
              case "add":
                if (L.fire === De) break;
                return m._promise("readwrite", function() {
                  return b(c);
                }, !0);
              case "put":
                if (L.fire === De && O.fire === De) break;
                return m._promise("readwrite", function() {
                  return b(c);
                }, !0);
              case "delete":
                if (g.fire === De) break;
                return m._promise("readwrite", function() {
                  return b(c);
                }, !0);
              case "deleteRange":
                if (g.fire === De) break;
                return m._promise("readwrite", function() {
                  return function v(T, D, w) {
                    return u.query({ trans: T, values: !1, query: { index: r, range: D }, limit: w }).then(function(C) {
                      var S = C.result;
                      return b({ type: "delete", keys: S, trans: T }).then(function(q) {
                        return 0 < q.numFailures ? Promise.reject(q.failures[0]) : S.length < w ? { failures: [], numFailures: 0, lastResult: void 0 } : v(T, a(a({}, D), { lower: S[S.length - 1], lowerOpen: !0 }), w);
                      });
                    });
                  }(c.trans, c.range, 1e4);
                }, !0);
            }
            return u.mutate(c);
            function b(v) {
              var T, D, w, C = re.trans, S = v.keys || ei(r, v);
              if (!S) throw new Error("Keys missing");
              return (v = v.type === "add" || v.type === "put" ? a(a({}, v), { keys: S }) : a({}, v)).type !== "delete" && (v.values = s([], v.values)), v.keys && (v.keys = s([], v.keys)), T = u, w = S, ((D = v).type === "add" ? Promise.resolve([]) : T.getMany({ trans: D.trans, keys: w, cache: "immutable" })).then(function(q) {
                var A = S.map(function(N, F) {
                  var U, W, z, H = q[F], J = { onerror: null, onsuccess: null };
                  return v.type === "delete" ? g.fire.call(J, N, H, C) : v.type === "add" || H === void 0 ? (U = L.fire.call(J, N, v.values[F], C), N == null && U != null && (v.keys[F] = N = U, r.outbound || te(v.values[F], r.keyPath, N))) : (U = Jt(H, v.values[F]), (W = O.fire.call(J, U, N, H, C)) && (z = v.values[F], Object.keys(W).forEach(function(X) {
                    y(z, X) ? z[X] = W[X] : te(z, X, W[X]);
                  }))), J;
                });
                return u.mutate(v).then(function(N) {
                  for (var F = N.failures, U = N.results, W = N.numFailures, N = N.lastResult, z = 0; z < S.length; ++z) {
                    var H = (U || S)[z], J = A[z];
                    H == null ? J.onerror && J.onerror(F[z]) : J.onsuccess && J.onsuccess(v.type === "put" && q[z] ? v.values[z] : H);
                  }
                  return { failures: F, results: U, numFailures: W, lastResult: N };
                }).catch(function(N) {
                  return A.forEach(function(F) {
                    return F.onerror && F.onerror(N);
                  }), Promise.reject(N);
                });
              });
            }
          } });
        } });
      } };
      function gu(n, t, u) {
        try {
          if (!t || t.keys.length < n.length) return null;
          for (var r = [], c = 0, m = 0; c < t.keys.length && m < n.length; ++c) Se(t.keys[c], n[m]) === 0 && (r.push(u ? ye(t.values[c]) : t.values[c]), ++m);
          return r.length === n.length ? r : null;
        } catch {
          return null;
        }
      }
      var hr = { stack: "dbcore", level: -1, create: function(n) {
        return { table: function(t) {
          var u = n.table(t);
          return a(a({}, u), { getMany: function(r) {
            if (!r.cache) return u.getMany(r);
            var c = gu(r.keys, r.trans._cache, r.cache === "clone");
            return c ? ee.resolve(c) : u.getMany(r).then(function(m) {
              return r.trans._cache = { keys: r.keys, values: r.cache === "clone" ? ye(m) : m }, m;
            });
          }, mutate: function(r) {
            return r.type !== "add" && (r.trans._cache = null), u.mutate(r);
          } });
        } };
      } };
      function vu(n, t) {
        return n.trans.mode === "readonly" && !!n.subscr && !n.trans.explicit && n.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function xu(n, t) {
        switch (n) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var gr = { stack: "dbcore", level: 0, name: "Observability", create: function(n) {
        var t = n.schema.name, u = new un(n.MIN_KEY, n.MAX_KEY);
        return a(a({}, n), { transaction: function(r, c, m) {
          if (re.subscr && c !== "readonly") throw new B.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(re.querier));
          return n.transaction(r, c, m);
        }, table: function(r) {
          var c = n.table(r), m = c.schema, p = m.primaryKey, v = m.indexes, g = p.extractKey, L = p.outbound, O = p.autoIncrement && v.filter(function(D) {
            return D.compound && D.keyPath.includes(p.keyPath);
          }), b = a(a({}, c), { mutate: function(D) {
            function w(X) {
              return X = "idb://".concat(t, "/").concat(r, "/").concat(X), N[X] || (N[X] = new un());
            }
            var C, S, q, A = D.trans, N = D.mutatedParts || (D.mutatedParts = {}), F = w(""), U = w(":dels"), W = D.type, J = D.type === "deleteRange" ? [D.range] : D.type === "delete" ? [D.keys] : D.values.length < 50 ? [ei(p, D).filter(function(X) {
              return X;
            }), D.values] : [], z = J[0], H = J[1], J = D.trans._cache;
            return d(z) ? (F.addKeys(z), (J = W === "delete" || z.length === H.length ? gu(z, J) : null) || U.addKeys(z), (J || H) && (C = w, S = J, q = H, m.indexes.forEach(function(X) {
              var ne = C(X.name || "");
              function ve(ge) {
                return ge != null ? X.extractKey(ge) : null;
              }
              function Pe(ge) {
                return X.multiEntry && d(ge) ? ge.forEach(function(Ge) {
                  return ne.addKey(Ge);
                }) : ne.addKey(ge);
              }
              (S || q).forEach(function(ge, an) {
                var pe = S && ve(S[an]), an = q && ve(q[an]);
                Se(pe, an) !== 0 && (pe != null && Pe(pe), an != null && Pe(an));
              });
            }))) : z ? (H = { from: (H = z.lower) !== null && H !== void 0 ? H : n.MIN_KEY, to: (H = z.upper) !== null && H !== void 0 ? H : n.MAX_KEY }, U.add(H), F.add(H)) : (F.add(u), U.add(u), m.indexes.forEach(function(X) {
              return w(X.name).add(u);
            })), c.mutate(D).then(function(X) {
              return !z || D.type !== "add" && D.type !== "put" || (F.addKeys(X.results), O && O.forEach(function(ne) {
                for (var ve = D.values.map(function(pe) {
                  return ne.extractKey(pe);
                }), Pe = ne.keyPath.findIndex(function(pe) {
                  return pe === p.keyPath;
                }), ge = 0, Ge = X.results.length; ge < Ge; ++ge) ve[ge][Pe] = X.results[ge];
                w(ne.name).addKeys(ve);
              })), A.mutatedParts = it(A.mutatedParts || {}, N), X;
            });
          } }), v = function(w) {
            var C = w.query, w = C.index, C = C.range;
            return [w, new un((w = C.lower) !== null && w !== void 0 ? w : n.MIN_KEY, (C = C.upper) !== null && C !== void 0 ? C : n.MAX_KEY)];
          }, T = { get: function(D) {
            return [p, new un(D.key)];
          }, getMany: function(D) {
            return [p, new un().addKeys(D.keys)];
          }, count: v, query: v, openCursor: v };
          return f(T).forEach(function(D) {
            b[D] = function(w) {
              var C = re.subscr, S = !!C, q = vu(re, c) && xu(D, w) ? w.obsSet = {} : C;
              if (S) {
                var A = function(H) {
                  return H = "idb://".concat(t, "/").concat(r, "/").concat(H), q[H] || (q[H] = new un());
                }, N = A(""), F = A(":dels"), C = T[D](w), S = C[0], C = C[1];
                if ((D === "query" && S.isPrimaryKey && !w.values ? F : A(S.name || "")).add(C), !S.isPrimaryKey) {
                  if (D !== "count") {
                    var U = D === "query" && L && w.values && c.query(a(a({}, w), { values: !1 }));
                    return c[D].apply(this, arguments).then(function(H) {
                      if (D === "query") {
                        if (L && w.values) return U.then(function(ve) {
                          return ve = ve.result, N.addKeys(ve), H;
                        });
                        var J = w.values ? H.result.map(g) : H.result;
                        (w.values ? N : F).addKeys(J);
                      } else if (D === "openCursor") {
                        var X = H, ne = w.values;
                        return X && Object.create(X, { key: { get: function() {
                          return F.addKey(X.primaryKey), X.key;
                        } }, primaryKey: { get: function() {
                          var ve = X.primaryKey;
                          return F.addKey(ve), ve;
                        } }, value: { get: function() {
                          return ne && N.addKey(X.primaryKey), X.value;
                        } } });
                      }
                      return H;
                    });
                  }
                  F.add(u);
                }
              }
              return c[D].apply(this, arguments);
            };
          }), b;
        } });
      } };
      function yu(n, t, u) {
        if (u.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var r = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return u.numFailures === r ? null : (t = a({}, t), d(t.keys) && (t.keys = t.keys.filter(function(c, m) {
          return !(m in u.failures);
        })), "values" in t && d(t.values) && (t.values = t.values.filter(function(c, m) {
          return !(m in u.failures);
        })), t);
      }
      function ni(n, t) {
        return u = n, ((r = t).lower === void 0 || (r.lowerOpen ? 0 < Se(u, r.lower) : 0 <= Se(u, r.lower))) && (n = n, (t = t).upper === void 0 || (t.upperOpen ? Se(n, t.upper) < 0 : Se(n, t.upper) <= 0));
        var u, r;
      }
      function Iu(n, t, T, r, c, m) {
        if (!T || T.length === 0) return n;
        var p = t.query.index, g = p.multiEntry, L = t.query.range, O = r.schema.primaryKey.extractKey, b = p.extractKey, v = (p.lowLevelIndex || p).extractKey, T = T.reduce(function(D, w) {
          var C = D, S = [];
          if (w.type === "add" || w.type === "put") for (var q = new un(), A = w.values.length - 1; 0 <= A; --A) {
            var N, F = w.values[A], U = O(F);
            q.hasKey(U) || (N = b(F), (g && d(N) ? N.some(function(X) {
              return ni(X, L);
            }) : ni(N, L)) && (q.addKey(U), S.push(F)));
          }
          switch (w.type) {
            case "add":
              var W = new un().addKeys(t.values ? D.map(function(ne) {
                return O(ne);
              }) : D), C = D.concat(t.values ? S.filter(function(ne) {
                return ne = O(ne), !W.hasKey(ne) && (W.addKey(ne), !0);
              }) : S.map(function(ne) {
                return O(ne);
              }).filter(function(ne) {
                return !W.hasKey(ne) && (W.addKey(ne), !0);
              }));
              break;
            case "put":
              var z = new un().addKeys(w.values.map(function(ne) {
                return O(ne);
              }));
              C = D.filter(function(ne) {
                return !z.hasKey(t.values ? O(ne) : ne);
              }).concat(t.values ? S : S.map(function(ne) {
                return O(ne);
              }));
              break;
            case "delete":
              var H = new un().addKeys(w.keys);
              C = D.filter(function(ne) {
                return !H.hasKey(t.values ? O(ne) : ne);
              });
              break;
            case "deleteRange":
              var J = w.range;
              C = D.filter(function(ne) {
                return !ni(O(ne), J);
              });
          }
          return C;
        }, n);
        return T === n ? n : (T.sort(function(D, w) {
          return Se(v(D), v(w)) || Se(O(D), O(w));
        }), t.limit && t.limit < 1 / 0 && (T.length > t.limit ? T.length = t.limit : n.length === t.limit && T.length < t.limit && (c.dirty = !0)), m ? Object.freeze(T) : T);
      }
      function Lu(n, t) {
        return Se(n.lower, t.lower) === 0 && Se(n.upper, t.upper) === 0 && !!n.lowerOpen == !!t.lowerOpen && !!n.upperOpen == !!t.upperOpen;
      }
      function vr(n, t) {
        return function(u, r, c, m) {
          if (u === void 0) return r !== void 0 ? -1 : 0;
          if (r === void 0) return 1;
          if ((r = Se(u, r)) === 0) {
            if (c && m) return 0;
            if (c) return 1;
            if (m) return -1;
          }
          return r;
        }(n.lower, t.lower, n.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(u, r, c, m) {
          if (u === void 0) return r !== void 0 ? 1 : 0;
          if (r === void 0) return -1;
          if ((r = Se(u, r)) === 0) {
            if (c && m) return 0;
            if (c) return -1;
            if (m) return 1;
          }
          return r;
        }(n.upper, t.upper, n.upperOpen, t.upperOpen);
      }
      function xr(n, t, u, r) {
        n.subscribers.add(u), r.addEventListener("abort", function() {
          var c, m;
          n.subscribers.delete(u), n.subscribers.size === 0 && (c = n, m = t, setTimeout(function() {
            c.subscribers.size === 0 && de(m, c);
          }, 3e3));
        });
      }
      var yr = { stack: "dbcore", level: 0, name: "Cache", create: function(n) {
        var t = n.schema.name;
        return a(a({}, n), { transaction: function(u, r, c) {
          var m, p, g = n.transaction(u, r, c);
          return r === "readwrite" && (p = (m = new AbortController()).signal, c = function(L) {
            return function() {
              if (m.abort(), r === "readwrite") {
                for (var O = /* @__PURE__ */ new Set(), b = 0, v = u; b < v.length; b++) {
                  var T = v[b], D = el["idb://".concat(t, "/").concat(T)];
                  if (D) {
                    var w = n.table(T), C = D.optimisticOps.filter(function(ne) {
                      return ne.trans === g;
                    });
                    if (g._explicit && L && g.mutatedParts) for (var S = 0, q = Object.values(D.queries.query); S < q.length; S++) for (var A = 0, N = (W = q[S]).slice(); A < N.length; A++) $t((z = N[A]).obsSet, g.mutatedParts) && (de(W, z), z.subscribers.forEach(function(ne) {
                      return O.add(ne);
                    }));
                    else if (0 < C.length) {
                      D.optimisticOps = D.optimisticOps.filter(function(ne) {
                        return ne.trans !== g;
                      });
                      for (var F = 0, U = Object.values(D.queries.query); F < U.length; F++) for (var W, z, H, J = 0, X = (W = U[F]).slice(); J < X.length; J++) (z = X[J]).res != null && g.mutatedParts && (L && !z.dirty ? (H = Object.isFrozen(z.res), H = Iu(z.res, z.req, C, w, z, H), z.dirty ? (de(W, z), z.subscribers.forEach(function(ne) {
                        return O.add(ne);
                      })) : H !== z.res && (z.res = H, z.promise = ee.resolve({ result: H }))) : (z.dirty && de(W, z), z.subscribers.forEach(function(ne) {
                        return O.add(ne);
                      })));
                    }
                  }
                }
                O.forEach(function(ne) {
                  return ne();
                });
              }
            };
          }, g.addEventListener("abort", c(!1), { signal: p }), g.addEventListener("error", c(!1), { signal: p }), g.addEventListener("complete", c(!0), { signal: p })), g;
        }, table: function(u) {
          var r = n.table(u), c = r.schema.primaryKey;
          return a(a({}, r), { mutate: function(m) {
            var p = re.trans;
            if (c.outbound || p.db._options.cache === "disabled" || p.explicit || p.idbtrans.mode !== "readwrite") return r.mutate(m);
            var g = el["idb://".concat(t, "/").concat(u)];
            return g ? (p = r.mutate(m), m.type !== "add" && m.type !== "put" || !(50 <= m.values.length || ei(c, m).some(function(L) {
              return L == null;
            })) ? (g.optimisticOps.push(m), m.mutatedParts && ut(m.mutatedParts), p.then(function(L) {
              0 < L.numFailures && (de(g.optimisticOps, m), (L = yu(0, m, L)) && g.optimisticOps.push(L), m.mutatedParts && ut(m.mutatedParts));
            }), p.catch(function() {
              de(g.optimisticOps, m), m.mutatedParts && ut(m.mutatedParts);
            })) : p.then(function(L) {
              var O = yu(0, a(a({}, m), { values: m.values.map(function(b, v) {
                var T;
                return L.failures[v] || (b = (T = c.keyPath) !== null && T !== void 0 && T.includes(".") ? ye(b) : a({}, b), te(b, c.keyPath, L.results[v])), b;
              }) }), L);
              g.optimisticOps.push(O), queueMicrotask(function() {
                return m.mutatedParts && ut(m.mutatedParts);
              });
            }), p) : r.mutate(m);
          }, query: function(m) {
            if (!vu(re, r) || !xu("query", m)) return r.query(m);
            var p = ((O = re.trans) === null || O === void 0 ? void 0 : O.db._options.cache) === "immutable", v = re, g = v.requery, L = v.signal, O = function(w, C, S, q) {
              var A = el["idb://".concat(w, "/").concat(C)];
              if (!A) return [];
              if (!(C = A.queries[S])) return [null, !1, A, null];
              var N = C[(q.query ? q.query.index.name : null) || ""];
              if (!N) return [null, !1, A, null];
              switch (S) {
                case "query":
                  var F = N.find(function(U) {
                    return U.req.limit === q.limit && U.req.values === q.values && Lu(U.req.query.range, q.query.range);
                  });
                  return F ? [F, !0, A, N] : [N.find(function(U) {
                    return ("limit" in U.req ? U.req.limit : 1 / 0) >= q.limit && (!q.values || U.req.values) && vr(U.req.query.range, q.query.range);
                  }), !1, A, N];
                case "count":
                  return F = N.find(function(U) {
                    return Lu(U.req.query.range, q.query.range);
                  }), [F, !!F, A, N];
              }
            }(t, u, "query", m), b = O[0], v = O[1], T = O[2], D = O[3];
            return b && v ? b.obsSet = m.obsSet : (v = r.query(m).then(function(w) {
              var C = w.result;
              if (b && (b.res = C), p) {
                for (var S = 0, q = C.length; S < q; ++S) Object.freeze(C[S]);
                Object.freeze(C);
              } else w.result = ye(C);
              return w;
            }).catch(function(w) {
              return D && b && de(D, b), Promise.reject(w);
            }), b = { obsSet: m.obsSet, promise: v, subscribers: /* @__PURE__ */ new Set(), type: "query", req: m, dirty: !1 }, D ? D.push(b) : (D = [b], (T = T || (el["idb://".concat(t, "/").concat(u)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[m.query.index.name || ""] = D)), xr(b, D, g, L), b.promise.then(function(w) {
              return { result: Iu(w.result, m, T?.optimisticOps, r, b, p) };
            });
          } });
        } });
      } };
      function rt(n, t) {
        return new Proxy(n, { get: function(u, r, c) {
          return r === "db" ? t : Reflect.get(u, r, c);
        } });
      }
      var En = (He.prototype.version = function(n) {
        if (isNaN(n) || n < 0.1) throw new B.Type("Given version is not a positive number");
        if (n = Math.round(10 * n) / 10, this.idbdb || this._state.isBeingOpened) throw new B.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, n);
        var t = this._versions, u = t.filter(function(r) {
          return r._cfg.version === n;
        })[0];
        return u || (u = new this.Version(n), t.push(u), t.sort(sr), u.stores({}), this._state.autoSchema = !1, u);
      }, He.prototype._whenReady = function(n) {
        var t = this;
        return this.idbdb && (this._state.openComplete || re.letThrough || this._vip) ? n() : new ee(function(u, r) {
          if (t._state.openComplete) return r(new B.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void r(new B.DatabaseClosed());
            t.open().catch(De);
          }
          t._state.dbReadyPromise.then(u, r);
        }).then(n);
      }, He.prototype.use = function(n) {
        var t = n.stack, u = n.create, r = n.level, c = n.name;
        return c && this.unuse({ stack: t, name: c }), n = this._middlewares[t] || (this._middlewares[t] = []), n.push({ stack: t, create: u, level: r ?? 10, name: c }), n.sort(function(m, p) {
          return m.level - p.level;
        }), this;
      }, He.prototype.unuse = function(n) {
        var t = n.stack, u = n.name, r = n.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(c) {
          return r ? c.create !== r : !!u && c.name !== u;
        })), this;
      }, He.prototype.open = function() {
        var n = this;
        return Xn(Rn, function() {
          return fr(n);
        });
      }, He.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var n = this._state, t = cl.indexOf(this);
        if (0 <= t && cl.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        n.isBeingOpened || (n.dbReadyPromise = new ee(function(u) {
          n.dbReadyResolve = u;
        }), n.openCanceller = new ee(function(u, r) {
          n.cancelOpen = r;
        }));
      }, He.prototype.close = function(u) {
        var t = (u === void 0 ? { disableAutoOpen: !0 } : u).disableAutoOpen, u = this._state;
        t ? (u.isBeingOpened && u.cancelOpen(new B.DatabaseClosed()), this._close(), u.autoOpen = !1, u.dbOpenError = new B.DatabaseClosed()) : (this._close(), u.autoOpen = this._options.autoOpen || u.isBeingOpened, u.openComplete = !1, u.dbOpenError = null);
      }, He.prototype.delete = function(n) {
        var t = this;
        n === void 0 && (n = { disableAutoOpen: !0 });
        var u = 0 < arguments.length && typeof arguments[0] != "object", r = this._state;
        return new ee(function(c, m) {
          function p() {
            t.close(n);
            var g = t._deps.indexedDB.deleteDatabase(t.name);
            g.onsuccess = Be(function() {
              var L, O, b;
              L = t._deps, O = t.name, b = L.indexedDB, L = L.IDBKeyRange, zt(b) || O === jl || Gt(b, L).delete(O).catch(De), c();
            }), g.onerror = wn(m), g.onblocked = t._fireOnBlocked;
          }
          if (u) throw new B.InvalidArgument("Invalid closeOptions argument to db.delete()");
          r.isBeingOpened ? r.dbReadyPromise.then(p) : p();
        });
      }, He.prototype.backendDB = function() {
        return this.idbdb;
      }, He.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, He.prototype.hasBeenClosed = function() {
        var n = this._state.dbOpenError;
        return n && n.name === "DatabaseClosed";
      }, He.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, He.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(He.prototype, "tables", { get: function() {
        var n = this;
        return f(this._allTables).map(function(t) {
          return n._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), He.prototype.transaction = function() {
        var n = (function(t, u, r) {
          var c = arguments.length;
          if (c < 2) throw new B.InvalidArgument("Too few arguments");
          for (var m = new Array(c - 1); --c; ) m[c - 1] = arguments[c];
          return r = m.pop(), [t, oe(m), r];
        }).apply(this, arguments);
        return this._transaction.apply(this, n);
      }, He.prototype._transaction = function(n, t, u) {
        var r = this, c = re.trans;
        c && c.db === this && n.indexOf("!") === -1 || (c = null);
        var m, p, g = n.indexOf("?") !== -1;
        n = n.replace("!", "").replace("?", "");
        try {
          if (p = t.map(function(O) {
            if (O = O instanceof r.Table ? O.name : O, typeof O != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return O;
          }), n == "r" || n === Et) m = Et;
          else {
            if (n != "rw" && n != _t) throw new B.InvalidArgument("Invalid transaction mode: " + n);
            m = _t;
          }
          if (c) {
            if (c.mode === Et && m === _t) {
              if (!g) throw new B.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              c = null;
            }
            c && p.forEach(function(O) {
              if (c && c.storeNames.indexOf(O) === -1) {
                if (!g) throw new B.SubTransaction("Table " + O + " not included in parent transaction.");
                c = null;
              }
            }), g && c && !c.active && (c = null);
          }
        } catch (O) {
          return c ? c._promise(null, function(b, v) {
            v(O);
          }) : je(O);
        }
        var L = (function O(b, v, T, D, w) {
          return ee.resolve().then(function() {
            var C = re.transless || re, S = b._createTransaction(v, T, b._dbSchema, D);
            if (S.explicit = !0, C = { trans: S, transless: C }, D) S.idbtrans = D.idbtrans;
            else try {
              S.create(), S.idbtrans._explicit = !0, b._state.PR1398_maxLoop = 3;
            } catch (N) {
              return N.name === k.InvalidState && b.isOpen() && 0 < --b._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), b.close({ disableAutoOpen: !1 }), b.open().then(function() {
                return O(b, v, T, null, w);
              })) : je(N);
            }
            var q, A = $e(w);
            return A && sl(), C = ee.follow(function() {
              var N;
              (q = w.call(S, S)) && (A ? (N = Kn.bind(null, null), q.then(N, N)) : typeof q.next == "function" && typeof q.throw == "function" && (q = Qt(q)));
            }, C), (q && typeof q.then == "function" ? ee.resolve(q).then(function(N) {
              return S.active ? N : je(new B.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : C.then(function() {
              return q;
            })).then(function(N) {
              return D && S._resolve(), S._completion.then(function() {
                return N;
              });
            }).catch(function(N) {
              return S._reject(N), je(N);
            });
          });
        }).bind(null, this, m, p, c, u);
        return c ? c._promise(m, L, "lock") : re.trans ? Xn(re.transless, function() {
          return r._whenReady(L);
        }) : this._whenReady(L);
      }, He.prototype.table = function(n) {
        if (!y(this._allTables, n)) throw new B.InvalidTable("Table ".concat(n, " does not exist"));
        return this._allTables[n];
      }, He);
      function He(n, t) {
        var u = this;
        this._middlewares = {}, this.verno = 0;
        var r = He.dependencies;
        this._options = t = a({ addons: He.addons, autoOpen: !0, indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, r = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var c, m, p, g, L, O = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: De, dbReadyPromise: null, cancelOpen: De, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        O.dbReadyPromise = new ee(function(v) {
          O.dbReadyResolve = v;
        }), O.openCanceller = new ee(function(v, T) {
          O.cancelOpen = T;
        }), this._state = O, this.name = n, this.on = Il(this, "populate", "blocked", "versionchange", "close", { ready: [Ee, De] }), this.once = function(v, T) {
          var D = function() {
            for (var w = [], C = 0; C < arguments.length; C++) w[C] = arguments[C];
            u.on(v).unsubscribe(D), T.apply(u, w);
          };
          return u.on(v, D);
        }, this.on.ready.subscribe = Z(this.on.ready.subscribe, function(v) {
          return function(T, D) {
            He.vip(function() {
              var w, C = u._state;
              C.openComplete ? (C.dbOpenError || ee.resolve().then(T), D && v(T)) : C.onReadyBeingFired ? (C.onReadyBeingFired.push(T), D && v(T)) : (v(T), w = u, D || v(function S() {
                w.on.ready.unsubscribe(T), w.on.ready.unsubscribe(S);
              }));
            });
          };
        }), this.Collection = (c = this, Ll(nr.prototype, function(q, S) {
          this.db = c;
          var D = Xi, w = null;
          if (S) try {
            D = S();
          } catch (A) {
            w = A;
          }
          var C = q._ctx, S = C.table, q = S.hook.reading.fire;
          this._ctx = { table: S, index: C.index, isPrimKey: !C.index || S.schema.primKey.keyPath && C.index === S.schema.primKey.name, range: D, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: w, or: C.or, valueMapper: q !== j ? q : null };
        })), this.Table = (m = this, Ll(nu.prototype, function(v, T, D) {
          this.db = m, this._tx = D, this.name = v, this.schema = T, this.hook = m._allTables[v] ? m._allTables[v].hook : Il(null, { creating: [Te, De], reading: [ie, j], updating: [be, De], deleting: [Ie, De] });
        })), this.Transaction = (p = this, Ll(ir.prototype, function(v, T, D, w, C) {
          var S = this;
          v !== "readonly" && T.forEach(function(q) {
            q = (q = D[q]) === null || q === void 0 ? void 0 : q.yProps, q && (T = T.concat(q.map(function(A) {
              return A.updatesTable;
            })));
          }), this.db = p, this.mode = v, this.storeNames = T, this.schema = D, this.chromeTransactionDurability = w, this.idbtrans = null, this.on = Il(this, "complete", "error", "abort"), this.parent = C || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ee(function(q, A) {
            S._resolve = q, S._reject = A;
          }), this._completion.then(function() {
            S.active = !1, S.on.complete.fire();
          }, function(q) {
            var A = S.active;
            return S.active = !1, S.on.error.fire(q), S.parent ? S.parent._reject(q) : A && S.idbtrans && S.idbtrans.abort(), je(q);
          });
        })), this.Version = (g = this, Ll(mr.prototype, function(v) {
          this.db = g, this._cfg = { version: v, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (L = this, Ll(ru.prototype, function(v, T, D) {
          if (this.db = L, this._ctx = { table: v, index: T === ":id" ? null : T, or: D }, this._cmp = this._ascending = Se, this._descending = function(w, C) {
            return Se(C, w);
          }, this._max = function(w, C) {
            return 0 < Se(w, C) ? w : C;
          }, this._min = function(w, C) {
            return Se(w, C) < 0 ? w : C;
          }, this._IDBKeyRange = L._deps.IDBKeyRange, !this._IDBKeyRange) throw new B.MissingAPI();
        })), this.on("versionchange", function(v) {
          0 < v.newVersion ? console.warn("Another connection wants to upgrade database '".concat(u.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(u.name, "'. Closing db now to resume the delete request.")), u.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(v) {
          !v.newVersion || v.newVersion < v.oldVersion ? console.warn("Dexie.delete('".concat(u.name, "') was blocked")) : console.warn("Upgrade '".concat(u.name, "' blocked by other connection holding version ").concat(v.oldVersion / 10));
        }), this._maxKey = bl(t.IDBKeyRange), this._createTransaction = function(v, T, D, w) {
          return new u.Transaction(v, T, D, u._options.chromeTransactionDurability, w);
        }, this._fireOnBlocked = function(v) {
          u.on("blocked").fire(v), cl.filter(function(T) {
            return T.name === u.name && T !== u && !T._state.vcFired;
          }).map(function(T) {
            return T.on("versionchange").fire(v);
          });
        }, this.use(hr), this.use(yr), this.use(gr), this.use(dr), this.use(pr);
        var b = new Proxy(this, { get: function(v, T, D) {
          if (T === "_vip") return !0;
          if (T === "table") return function(C) {
            return rt(u.table(C), b);
          };
          var w = Reflect.get(v, T, D);
          return w instanceof nu ? rt(w, b) : T === "tables" ? w.map(function(C) {
            return rt(C, b);
          }) : T === "_createTransaction" ? function() {
            return rt(w.apply(this, arguments), b);
          } : w;
        } });
        this.vip = b, r.forEach(function(v) {
          return v(u);
        });
      }
      var st, In = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Ir = (li.prototype.subscribe = function(n, t, u) {
        return this._subscribe(n && typeof n != "function" ? n : { next: n, error: t, complete: u });
      }, li.prototype[In] = function() {
        return this;
      }, li);
      function li(n) {
        this._subscribe = n;
      }
      try {
        st = { indexedDB: o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB, IDBKeyRange: o.IDBKeyRange || o.webkitIDBKeyRange };
      } catch {
        st = { indexedDB: null, IDBKeyRange: null };
      }
      function Du(n) {
        var t, u = !1, r = new Ir(function(c) {
          var m = $e(n), p, g = !1, L = {}, O = {}, b = { get closed() {
            return g;
          }, unsubscribe: function() {
            g || (g = !0, p && p.abort(), v && jn.storagemutated.unsubscribe(D));
          } };
          c.start && c.start(b);
          var v = !1, T = function() {
            return At(w);
          }, D = function(C) {
            it(L, C), $t(O, L) && T();
          }, w = function() {
            var C, S, q;
            !g && st.indexedDB && (L = {}, C = {}, p && p.abort(), p = new AbortController(), q = function(A) {
              var N = al();
              try {
                m && sl();
                var F = Un(n, A);
                return F = m ? F.finally(Kn) : F;
              } finally {
                N && rl();
              }
            }(S = { subscr: C, signal: p.signal, requery: T, querier: n, trans: null }), Promise.resolve(q).then(function(A) {
              u = !0, t = A, g || S.signal.aborted || (L = {}, function(N) {
                for (var F in N) if (y(N, F)) return;
                return 1;
              }(O = C) || v || (jn(wl, D), v = !0), At(function() {
                return !g && c.next && c.next(A);
              }));
            }, function(A) {
              u = !1, ["DatabaseClosedError", "AbortError"].includes(A?.name) || g || At(function() {
                g || c.error && c.error(A);
              });
            }));
          };
          return setTimeout(T, 0), b;
        });
        return r.hasValue = function() {
          return u;
        }, r.getValue = function() {
          return t;
        }, r;
      }
      var nl = En;
      function ti(n) {
        var t = Hn;
        try {
          Hn = !0, jn.storagemutated.fire(n), Xt(n, !0);
        } finally {
          Hn = t;
        }
      }
      P(nl, a(a({}, Xe), { delete: function(n) {
        return new nl(n, { addons: [] }).delete();
      }, exists: function(n) {
        return new nl(n, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(n) {
        try {
          return t = nl.dependencies, u = t.indexedDB, t = t.IDBKeyRange, (zt(u) ? Promise.resolve(u.databases()).then(function(r) {
            return r.map(function(c) {
              return c.name;
            }).filter(function(c) {
              return c !== jl;
            });
          }) : Gt(u, t).toCollection().primaryKeys()).then(n);
        } catch {
          return je(new B.MissingAPI());
        }
        var t, u;
      }, defineClass: function() {
        return function(n) {
          h(this, n);
        };
      }, ignoreTransaction: function(n) {
        return re.trans ? Xn(re.transless, n) : n();
      }, vip: jt, async: function(n) {
        return function() {
          try {
            var t = Qt(n.apply(this, arguments));
            return t && typeof t.then == "function" ? t : ee.resolve(t);
          } catch (u) {
            return je(u);
          }
        };
      }, spawn: function(n, t, u) {
        try {
          var r = Qt(n.apply(u, t || []));
          return r && typeof r.then == "function" ? r : ee.resolve(r);
        } catch (c) {
          return je(c);
        }
      }, currentTransaction: { get: function() {
        return re.trans || null;
      } }, waitFor: function(n, t) {
        return t = ee.resolve(typeof n == "function" ? nl.ignoreTransaction(n) : n).timeout(t || 6e4), re.trans ? re.trans.waitFor(t) : t;
      }, Promise: ee, debug: { get: function() {
        return Oe;
      }, set: function(n) {
        qe(n);
      } }, derive: V, extend: h, props: P, override: Z, Events: Il, on: jn, liveQuery: Du, extendObservabilitySet: it, getByKeyPath: se, setByKeyPath: te, delByKeyPath: function(n, t) {
        typeof t == "string" ? te(n, t, void 0) : "length" in t && [].map.call(t, function(u) {
          te(n, u, void 0);
        });
      }, shallowClone: fe, deepClone: ye, getObjectDiff: Jt, cmp: Se, asap: Y, minKey: -1 / 0, addons: [], connections: cl, errnames: k, dependencies: st, cache: el, semVer: "4.2.0", version: "4.2.0".split(".").map(function(n) {
        return parseInt(n);
      }).reduce(function(n, t, u) {
        return n + t / Math.pow(10, 2 * u);
      }) })), nl.maxKey = bl(nl.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (jn(wl, function(n) {
        Hn || (n = new CustomEvent(Mt, { detail: n }), Hn = !0, dispatchEvent(n), Hn = !1);
      }), addEventListener(Mt, function(n) {
        n = n.detail, Hn || ti(n);
      }));
      var gl, Hn = !1, Ou = function() {
      };
      return typeof BroadcastChannel < "u" && ((Ou = function() {
        (gl = new BroadcastChannel(Mt)).onmessage = function(n) {
          return n.data && ti(n.data);
        };
      })(), typeof gl.unref == "function" && gl.unref(), jn(wl, function(n) {
        Hn || gl.postMessage(n);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(n) {
        if (!En.disableBfCache && n.persisted) {
          Oe && console.debug("Dexie: handling persisted pagehide"), gl?.close();
          for (var t = 0, u = cl; t < u.length; t++) u[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(n) {
        !En.disableBfCache && n.persisted && (Oe && console.debug("Dexie: handling persisted pageshow"), Ou(), ti({ all: new un(-1 / 0, [[]]) }));
      })), ee.rejectionMapper = function(n, t) {
        return !n || n instanceof cn || n instanceof TypeError || n instanceof SyntaxError || !n.name || !le[n.name] ? n : (t = new le[n.name](t || n.message, n), "stack" in n && R(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, qe(Oe), a(En, Object.freeze({ __proto__: null, Dexie: En, liveQuery: Du, Entity: Qi, cmp: Se, PropModification: Dl, replacePrefix: function(n, t) {
        return new Dl({ replacePrefix: [n, t] });
      }, add: function(n) {
        return new Dl({ add: n });
      }, remove: function(n) {
        return new Dl({ remove: n });
      }, default: En, RangeSet: un, mergeRanges: Tl, rangesOverlap: fu }), { default: En }), En;
    });
  }(vm)), vm.exports;
}
var DL = LL();
const xm = /* @__PURE__ */ yL(DL), Id = Symbol.for("Dexie"), Ic = globalThis[Id] || (globalThis[Id] = xm);
if (xm.semVer !== Ic.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${xm.semVer} and ${Ic.semVer}`);
const {
  liveQuery: Cg,
  mergeRanges: K1,
  rangesOverlap: G1,
  RangeSet: z1,
  cmp: j1,
  Entity: H1,
  PropModification: $1,
  replacePrefix: W1,
  add: Y1,
  remove: X1,
  DexieYProvider: Q1
} = Ic, ht = "sclElements", OL = "id, tagName, [id+tagName], &attributes.uuid, &attributes.id, attributes.name, parent.id, parent.tagName, *children.id, *children.tagName";
function wL(e) {
  const { databaseName: l } = e, i = new Ic(l);
  return i.version(1).stores({
    [`${ht}`]: OL
  }), i;
}
function bL(e) {
  const { childRecord: l, parentRecord: i, stagedOperations: a } = e, s = i.children.find((h) => h.tagName === "Private");
  if (s) {
    const h = [...a].reverse().find((x) => x.type === "create" ? x.record.id === s.id && x.record.tagName === "Private" : x.type === "update" ? x.new.id === s.id && x.new.tagName === "Private" : !1);
    let I;
    if (h?.type === "create" && (I = h.record), h?.type === "update" && (I = h.new), I?.attributes.some(
      (x) => x.name === "type" && x.value === l.namespace.prefix
    ) && I) {
      const x = {
        ...l,
        parent: { id: I.id, tagName: "Private" }
      }, y = {
        ...I,
        children: [
          ...I.children,
          { id: l.id, tagName: l.tagName }
        ]
      };
      return {
        childRecord: x,
        privateRecord: y,
        updatedParentRecord: i,
        // Parent doesn't change
        isNewPrivateElement: !1
      };
    }
  }
  const o = {
    id: crypto.randomUUID(),
    tagName: "Private",
    namespace: { prefix: xd.default.prefix, uri: xd.default.uri },
    attributes: [
      {
        name: "type",
        value: l.namespace.prefix
      }
    ],
    value: "",
    parent: { id: i.id, tagName: i.tagName },
    children: [
      { id: l.id, tagName: l.tagName }
    ],
    status: "create",
    treeChildren: []
  }, f = {
    ...l,
    parent: { id: o.id, tagName: "Private" }
  }, d = {
    ...i,
    children: [...i.children, { id: o.id, tagName: "Private" }]
  };
  return {
    childRecord: f,
    privateRecord: o,
    updatedParentRecord: d,
    isNewPrivateElement: !0
    // Private element is new, no update needed
  };
}
function ym(e) {
  const { attributes: l, name: i } = e;
  return l.find((a) => a.name === i)?.value || "";
}
function Tg(e) {
  const { attributes: l } = e;
  return l.reduce(
    (i, a) => {
      const s = a.value || "";
      return i[a.name] = s, i;
    },
    {}
  );
}
const mf = ["DO", "SDO", "DA", "BDA", "EnumVal"], qg = {
  LNodeType: "id",
  DOType: "id",
  DAType: "id",
  EnumType: "id",
  DO: "name",
  SDO: "name",
  DA: "name",
  BDA: "name",
  EnumVal: "ord"
};
function ff(e) {
  return qg[e];
}
function df(e) {
  const { source: l, targets: i } = e;
  let a;
  l.tagName === "LNode" || l.tagName === "LN" ? a = "lnType" : a = "type";
  const s = l.attributes, o = ym({
    attributes: s,
    name: a
  });
  return i.find((f) => {
    const d = ff(f.tagName), h = f.attributes;
    return ym({ attributes: h, name: d }) === o;
  });
}
function Qs(e) {
  const { sources: l, targets: i } = e, a = [];
  for (const s of l) {
    const o = df({
      source: s,
      targets: i
    });
    o && a.push(o);
  }
  return a;
}
function Pg(e) {
  const { version: l, records: i } = e;
  return i.length === 0 ? !0 : i.every((a) => {
    if (!Xc(a) || !ua[l].CHILDREN.DataTypeTemplates.includes(a.tagName)) return !1;
    const s = ua[l].CHILDREN[a.tagName];
    return a.treeChildren.every((o) => !!(mf.includes(o.tagName) || s && s.includes(o.tagName)));
  });
}
function SL(e) {
  const { version: l, records: i } = e;
  if (console.log("toDataModelRecords - records:", i), !Pg({ version: l, records: i }))
    throw new Error("Some records are not valid data model records.");
  return i;
}
function CL(e) {
  const { version: l, tagName: i, attributeName: a, value: s, elementId: o } = e, f = ua[l].DEFINITION[i];
  if (!f || !f.attributes?.details) return;
  const d = f.attributes.details[a];
  if (!d?.validation?.enumeration) return;
  const h = d.validation.enumeration;
  if (!h.includes(s))
    throw new Error(
      `Invalid value '${s}' for attribute '${a}' on ${i}(element: ${o}). Expected one of: ${h.join(", ")}`
    );
}
const TL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DATA_MODEL_CHILDREN_TAG_NAMES: mf,
  DATA_MODEL_ROOT_ELEMENT_TO_ATTRIBUTE_KEY: qg,
  areDataModelRecords: Pg,
  filterDataModelRootElements: Qs,
  getAttributeValueByName: ym,
  getAttributesValuesByName: Tg,
  getDataModelRootElementKeyAttribute: ff,
  groupRecordsByTagName: Sg,
  isDatabaseRecord: vL,
  isTreeRecord: Xc,
  resolveDataModelRootElementReference: df,
  toDataModelRecords: SL,
  toDatabaseRecord: _i,
  toTreeRecord: ja,
  validateAttributeValue: CL
}, Symbol.toStringTag, { value: "Module" }));
function qL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function(s) {
    const { tagName: o, attributes: f, value: d, setFocus: h = !1 } = s, I = i.then((x) => {
      const y = ua[x.version].DEFINITION[o].namespace, P = ua[x.version].DEFINITION[o].attributes.details, E = Object.entries(f).map(([V, K]) => {
        const $ = V;
        return {
          name: $,
          value: String(K),
          namespace: P[$]?.namespace
        };
      }), R = {
        id: crypto.randomUUID(),
        tagName: o,
        namespace: y,
        attributes: E,
        value: d ?? "",
        parent: { id: x.currentFocus.id, tagName: x.currentFocus.tagName },
        children: [],
        status: "created",
        treeChildren: []
      };
      if (R.namespace.prefix !== "scl") {
        const {
          childRecord: V,
          privateRecord: K,
          updatedParentRecord: $,
          isNewPrivateElement: Q
        } = bL({
          childRecord: R,
          parentRecord: x.currentFocus,
          stagedOperations: x.stagedOperations
        });
        if (Q && Ii({ context: x, type: "create", record: K }), Ii({ context: x, type: "create", record: V }), Q || Ii({
          context: x,
          type: "update",
          old: K,
          new: K
        }), Ii({
          context: x,
          type: "update",
          old: _i(x.currentFocus),
          new: $
        }), h)
          return {
            ...x,
            currentFocus: V
          };
        {
          const Z = {
            ...x.currentFocus,
            ...$
          };
          return {
            ...x,
            currentFocus: Z
          };
        }
      } else {
        Ii({ context: x, type: "create", record: R });
        const V = {
          ...x.currentFocus,
          children: [
            ...x.currentFocus.children,
            {
              id: R.id,
              tagName: R.tagName
            }
          ]
        };
        return Ii({
          context: x,
          type: "update",
          old: _i(x.currentFocus),
          new: _i(V)
        }), h ? {
          ...x,
          currentFocus: R
        } : {
          ...x,
          currentFocus: V
        };
      }
    });
    return l(h ? {
      contextPromise: I,
      extensions: a,
      tagName: o
    } : {
      contextPromise: I,
      extensions: a,
      tagName: o
    });
  };
}
function PL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a, tagName: s } = e;
  return function(o) {
    const { attributes: f, value: d } = o, h = i.then(async (I) => {
      const x = [
        ...I.currentFocus.attributes
      ];
      if (f)
        for (const R of f) {
          const V = x.findIndex(
            ($) => $.name === R.name
          );
          if (R.value === "" || R.value === void 0 || R.value === null) {
            V >= 0 && x.splice(V, 1);
            continue;
          }
          const K = {
            name: R.name,
            value: String(R.value),
            ...R.namespace && { namespace: R.namespace }
          };
          V >= 0 ? x[V] = K : x.push(K);
        }
      const y = ua[I.version].DEFINITION[I.currentFocus.tagName].namespace, P = I.currentFocus.namespace?.prefix === y.prefix, E = {
        ...I.currentFocus,
        namespace: y && !P ? y : I.currentFocus.namespace,
        attributes: f ? x : I.currentFocus.attributes,
        value: d ?? I.currentFocus.value
      };
      return Ii({
        context: I,
        type: "update",
        old: _i(I.currentFocus),
        new: _i(E)
      }), {
        ...I,
        currentFocus: E
      };
    });
    return l({
      contextPromise: h,
      extensions: a,
      tagName: s
    });
  };
}
function RL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function() {
    let s;
    const o = i.then(async (f) => {
      const d = f.currentFocus.id;
      Ii({ context: f, type: "delete", record: _i(f.currentFocus) });
      const h = f.currentFocus.parent;
      if (!h) throw new Error("Cannot delete element without a parent");
      s = h.tagName, await I(f.currentFocus.children);
      async function I(E) {
        for (const R of E) {
          const V = [...f.stagedOperations].reverse().find(($) => $.type === "create" ? $.record.id === R.id : $.type === "update" ? $.new.id === R.id : !1);
          let K;
          V ? V.type === "create" ? K = V.record : V.type === "update" && (K = V.new) : K = await f.databaseInstance.sclElements.get({
            id: R.id,
            tagName: R.tagName
          }), K && (K.children && K.children.length > 0 && await I(K.children), Ii({
            context: f,
            type: "delete",
            record: K
          }));
        }
      }
      const x = [...f.stagedOperations].reverse().find((E) => E.type === "create" ? E.record.id === h.id : E.type === "update" ? E.new.id === h.id : !1);
      let y;
      if (x)
        if (x.type === "create")
          y = x.record;
        else if (x.type === "update")
          y = x.new;
        else
          throw new Error("Unexpected operation type");
      else {
        const E = await f.databaseInstance.sclElements.get({
          id: h.id,
          tagName: h.tagName
        });
        if (!E) throw new Error("Parent record not found in database");
        y = E;
      }
      const P = {
        ...ja(y),
        children: y.children.filter((E) => E.id !== d)
      };
      return Ii({
        context: f,
        type: "update",
        old: _i(y),
        new: _i(P)
      }), {
        ...f,
        currentFocus: P
      };
    });
    return l({
      contextPromise: o,
      extensions: a,
      tagName: s
    });
  };
}
function Ii(e) {
  const { context: l, type: i, record: a, old: s, new: o } = e;
  if (i === "create") {
    if (!a) throw new Error("record is required for create");
    l.stagedOperations.push({ type: i, record: a });
  } else if (i === "update") {
    if (!s || !o) throw new Error("old and new are required for update");
    l.stagedOperations.push({ type: i, old: s, new: o });
  } else if (i === "delete") {
    if (!a) throw new Error("record is required for delete");
    l.stagedOperations.push({ type: i, record: a });
  }
}
function AL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  function s(o) {
    const { tagName: f, id: d } = o, h = i.then(async (I) => {
      let x;
      if ((f === "Header" || f === "Communication" || f === "DataTypeTemplates") && !d)
        x = await I.databaseInstance[ht].where("tagName").equals(f).first();
      else if (d)
        x = await I.databaseInstance[ht].get({ id: d, tagName: f });
      else throw new Error(`Element ${f} requires an id parameter`);
      if (!x) {
        const P = d ? ` with id ${d}` : "";
        throw new Error(`No element ${f}${P} found in database`);
      }
      if (x.tagName !== f) throw new Error("Element tagName mismatch");
      const y = ja(x);
      return {
        ...I,
        entrypoint: y,
        currentFocus: y
      };
    });
    return l({
      contextPromise: h,
      extensions: a,
      tagName: f
    });
  }
  return s;
}
function EL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function() {
    let s;
    const o = i.then(async (f) => {
      const d = f.currentFocus.parent;
      if (!d) throw new Error("No parent found");
      s = d.tagName;
      const h = [...f.stagedOperations].reverse().find((x) => x.type === "create" ? x.record.id === d.id : x.type === "update" ? x.new.id === d.id : !1);
      let I;
      if (h && h.type !== "delete")
        I = h.type === "create" ? h.record : h.new;
      else {
        const x = await f.databaseInstance[ht].get({
          id: d.id,
          tagName: d.tagName
        });
        if (!x) throw new Error("Parent record not found in database");
        I = x;
      }
      return {
        ...f,
        currentFocus: ja(I)
      };
    });
    return l({
      contextPromise: o,
      extensions: a,
      tagName: s
    });
  };
}
async function Rg(e) {
  const { context: l, options: i } = e, { depth: a, filter: s, withStagedOperations: o } = i || {};
  let f, d;
  o && (f = FL(l.stagedOperations), d = [...l.stagedOperations].reverse().find((y) => y.type === "create" ? y.record.id === l.currentFocus.id : y.type === "update" ? y.new.id === l.currentFocus.id : !1));
  let h = l.currentFocus;
  d?.type === "update" && (h = d.new), d?.type === "create" && (h = d.record);
  const I = _L(s?.pick), x = NL(s?.exclude);
  return await Im({
    context: l,
    record: h,
    currentDepth: 0,
    stagedOperationsPerRecordId: f,
    pickMap: I,
    excludeSet: x,
    isDeepBranch: !1,
    options: { depth: a, withStagedOperations: o }
  });
}
function _L(e) {
  const l = /* @__PURE__ */ new Map();
  if (!e) return l;
  for (const i of e)
    typeof i == "string" ? l.set(i, !1) : typeof i == "object" && "tagName" in i && l.set(i.tagName, !!i.deep);
  return l;
}
function NL(e) {
  return e ? new Set(e) : /* @__PURE__ */ new Set();
}
function FL(e) {
  const l = /* @__PURE__ */ new Map();
  for (const i of e)
    i.type === "delete" || i.type === "create" ? l.has(i.record.id) || l.set(i.record.id, i) : i.type === "update" && (l.has(i.new.id) || l.set(i.new.id, i));
  return l;
}
function ML(e, l) {
  return l.get(e)?.type || "unchanged";
}
function Ag(e, l, i, a) {
  return e === "Private" ? { shouldInclude: !1, nextDeepBranch: !1 } : a ? { shouldInclude: !0, nextDeepBranch: !0 } : i.has(e) ? { shouldInclude: !1, nextDeepBranch: !1 } : l.size > 0 ? l.has(e) ? { shouldInclude: !0, nextDeepBranch: l.get(e) ?? !1 } : { shouldInclude: !1, nextDeepBranch: !1 } : { shouldInclude: !0, nextDeepBranch: !1 };
}
function Eg(e, l, i) {
  if (!e.treeChildren || e.treeChildren.length === 0) return [];
  const a = [];
  for (const s of e.treeChildren) {
    const { shouldInclude: o } = Ag(s.tagName, l, i, !1);
    o ? a.push(s) : a.push(
      ...Eg(
        s,
        l,
        i
      )
    );
  }
  return a;
}
function Ld(e) {
  const { tree: l, recordId: i, stagedOperationsPerRecordId: a } = e;
  return {
    ...l,
    status: a ? ML(i, a) : "unchanged"
  };
}
async function Im(e) {
  const {
    context: l,
    record: i,
    currentDepth: a,
    stagedOperationsPerRecordId: s,
    pickMap: o,
    excludeSet: f,
    isDeepBranch: d,
    options: h
  } = e, { depth: I, withStagedOperations: x } = h, y = (await Promise.all(
    i.children.map(async (R) => {
      if (x) {
        const V = [...l.stagedOperations].reverse().find((K) => K.type === "create" ? K.record.id === R.id : K.type === "update" ? K.new.id === R.id : !1);
        if (V && V.type !== "delete")
          return V.type === "create" ? V.record : V.new;
      }
      return l.databaseInstance[ht].get({
        id: R.id,
        tagName: R.tagName
      });
    })
  )).filter(
    (R) => !!R
  );
  if (I !== void 0 && a >= I && i.tagName !== "Private") {
    const R = {
      ...i,
      treeChildren: []
    };
    return Ld({
      tree: R,
      recordId: i.id,
      stagedOperationsPerRecordId: s
    });
  }
  const P = [];
  for (const R of y) {
    const V = R.tagName, { shouldInclude: K, nextDeepBranch: $ } = Ag(
      V,
      o,
      f,
      d
    );
    if (K) {
      const Q = await Im({
        context: l,
        record: R,
        currentDepth: a + 1,
        stagedOperationsPerRecordId: s,
        pickMap: o,
        excludeSet: f,
        isDeepBranch: $,
        options: e.options
      });
      P.push(
        Q
      );
    } else if (V === "Private" || o.size > 0) {
      const Q = await Im({
        context: l,
        record: R,
        currentDepth: a + 1,
        stagedOperationsPerRecordId: s,
        pickMap: o,
        excludeSet: f,
        isDeepBranch: $,
        options: e.options
      }), Z = Eg(
        Q,
        o,
        f
      );
      P.push(...Z);
    }
  }
  const E = {
    ...i,
    treeChildren: P
  };
  return Ld({
    tree: E,
    recordId: i.id,
    stagedOperationsPerRecordId: s
  });
}
function kL(e) {
  const { contextPromise: l } = e;
  return async function() {
    const i = await l;
    return Cg(
      () => i.databaseInstance[ht].get(i.currentFocus.id)
    );
  };
}
function VL(e) {
  const { contextPromise: l } = e;
  return async function() {
    const i = await l;
    return await Rg({
      context: i,
      options: {
        withStagedOperations: !0
      }
    });
  };
}
function BL(e) {
  const { contextPromise: l } = e;
  return async function() {
    return await l;
  };
}
function ZL(e) {
  const { contextPromise: l } = e;
  return async function(i) {
    const { depth: a, filter: s, withStagedOperations: o } = i || {}, f = await l;
    return await Rg({
      context: f,
      options: { depth: a, filter: s, withStagedOperations: o }
    });
  };
}
function UL(e) {
  const { contextPromise: l } = e;
  return async function() {
    const i = await l;
    try {
      await i.databaseInstance.transaction(
        "rw",
        i.databaseInstance.tables,
        async () => {
          for (const a of i.stagedOperations)
            a.type === "create" ? await i.databaseInstance[ht].add(a.record) : a.type === "update" ? await i.databaseInstance[ht].put(a.new) : a.type === "delete" && await i.databaseInstance[ht].delete(
              a.record.id
            );
        }
      );
    } catch (a) {
      throw new Error("Transaction failed", { cause: a });
    }
  };
}
function _u(e) {
  const { contextPromise: l, extensions: i, tagName: a } = e, s = {
    //== Crud methods
    addChild: qL({
      genericApiBuilder: _u,
      contextPromise: l,
      extensions: i
    }),
    update: PL({
      genericApiBuilder: _u,
      contextPromise: l,
      extensions: i,
      tagName: a
    }),
    delete: a === "SCL" ? void 0 : RL({
      genericApiBuilder: _u,
      contextPromise: l,
      extensions: i
    }),
    //== Navigation methods
    goToElement: AL({
      genericApiBuilder: _u,
      contextPromise: l,
      extensions: i
    }),
    goToParent: EL({
      genericApiBuilder: _u,
      contextPromise: l,
      extensions: i
    }),
    //== Ending methods
    getObservable: kL({
      contextPromise: l
    }),
    getChildren: ZL({
      contextPromise: l
    }),
    getSnapshot: VL({
      contextPromise: l
    }),
    getContext: BL({
      contextPromise: l
    }),
    commit: UL({
      contextPromise: l
    })
  };
  return KL({
    genericBuilder: s,
    extensions: i,
    tagName: a,
    contextPromise: l
  });
}
function KL(e) {
  const { genericBuilder: l, extensions: i, tagName: a, contextPromise: s } = e, o = l, f = i[a] || {};
  for (const [d, h] of Object.entries(f))
    typeof h == "function" && (o[d] = h({
      genericApiBuilder: _u,
      contextPromise: s,
      extensions: i
    }));
  return o;
}
async function GL(e) {
  const { databaseInstance: l, tagName: i } = e;
  return Cg(() => l[ht].where({ tagName: i }).toArray());
}
function zL(e) {
  const { version: l, databaseInstance: i, extensions: a, tagName: s, id: o } = e, f = Promise.resolve().then(async () => {
    const d = await i[ht].get({ id: o, tagName: s });
    if (!d) throw new Error(`No element ${s} with id ${o} found in database`);
    if (d.tagName !== s) throw new Error("Element tagName mismatch");
    const h = ja(d);
    return {
      version: l,
      databaseInstance: i,
      entrypoint: h,
      currentFocus: h,
      stagedOperations: []
    };
  });
  return _u({
    contextPromise: f,
    extensions: a,
    tagName: s
  });
}
function jL(e) {
  const { version: l, databaseInstance: i, extensions: a } = e, s = Promise.resolve().then(async () => {
    const o = await i[ht].where({
      tagName: "SCL"
    }).count();
    if (o === 0) throw new Error("No root SCL element found in database");
    if (o > 1)
      throw new Error("Multiple root SCL elements found in database, database is corrupted");
    const f = await i[ht].get({ tagName: "SCL" });
    if (!f) throw new Error("No root SCL element found in database");
    const d = ja(f);
    return {
      version: l,
      databaseInstance: i,
      entrypoint: d,
      currentFocus: d,
      stagedOperations: []
    };
  });
  return _u({
    contextPromise: s,
    extensions: a,
    tagName: "SCL"
  });
}
async function _g(e) {
  const { record: l, dataTypeTemplates: i } = e, {
    LNodeType: a = [],
    DOType: s = [],
    DAType: o = [],
    EnumType: f = []
  } = Sg(i.treeChildren), d = df({
    source: l,
    targets: a
  });
  if (!d)
    throw new Error(
      `LNodeType for ${l.tagName} ${l.attributes.find((y) => y.name === "lnType")?.value} not found`
    );
  const h = Qs({
    sources: d.treeChildren.filter((y) => y.tagName === "DO"),
    targets: s
  }), I = Qs({
    sources: h.flatMap(
      (y) => y.treeChildren.filter((P) => P.tagName === "DA")
    ),
    targets: o
  }), x = Qs({
    sources: I.flatMap(
      (y) => y.treeChildren.filter((P) => P.tagName === "BDA")
    ),
    targets: f
  });
  return {
    ...l,
    treeChildren: [d, ...h, ...I, ...x],
    status: "unchanged"
  };
}
function HL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function() {
    const s = i.then(async (o) => {
      const f = o.currentFocus, d = await l({
        contextPromise: Promise.resolve(o),
        extensions: a,
        tagName: o.currentFocus.tagName
      }).goToElement({ tagName: "DataTypeTemplates" }).getChildren(), h = await _g({
        record: f,
        dataTypeTemplates: d
      });
      return {
        ...o,
        currentFocus: h
      };
    });
    return l({
      contextPromise: s,
      extensions: a,
      tagName: "LNode"
    });
  };
}
const $L = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  resolveDataModel: HL
}, Symbol.toStringTag, { value: "Module" }));
function WL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function() {
    const s = i.then(async (o) => {
      const f = o.currentFocus, d = await l({
        contextPromise: Promise.resolve(o),
        extensions: a,
        tagName: o.currentFocus.tagName
      }).goToElement({ tagName: "DataTypeTemplates" }).getChildren(), h = await _g({
        record: f,
        dataTypeTemplates: d
      });
      return {
        ...o,
        currentFocus: h
      };
    });
    return l({
      contextPromise: s,
      extensions: a,
      tagName: "LN"
    });
  };
}
const YL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  resolveDataModel: WL
}, Symbol.toStringTag, { value: "Module" }));
function XL(e) {
  const { genericApiBuilder: l, contextPromise: i, extensions: a } = e;
  return function(s) {
    const { dataModel: o } = s, f = i.then(async (d) => {
      let h = l({
        contextPromise: Promise.resolve(d),
        extensions: a,
        tagName: "DataTypeTemplates"
      });
      for (const I of o) {
        if (await Fg(h, I)) continue;
        h = Ng(h, I);
        const x = I.treeChildren.filter(
          (y) => mf.includes(y.tagName)
        );
        for (const y of x)
          h = await QL(h, y);
        h = h.goToParent();
      }
      return await h.getContext();
    });
    return l({
      contextPromise: f,
      extensions: a,
      tagName: "DataTypeTemplates"
    });
  };
}
async function QL(e, l) {
  return await Fg(e, l) ? e : Ng(e, l).goToParent();
}
function Ng(e, l) {
  const i = Tg({
    attributes: l.attributes
  });
  return e.addChild({
    tagName: l.tagName,
    attributes: i,
    setFocus: !0
  });
}
async function Fg(e, l) {
  const i = ff(l.tagName), a = l.attributes.find((s) => s.name === i)?.value;
  if (!a)
    throw new Error(`Key attribute "${i}" is missing in element attributes.`);
  return (await e.getChildren({ depth: 1, withStagedOperations: !0 })).treeChildren.find(
    (s) => s.tagName === l.tagName && s.attributes.find((o) => o.name === i)?.value === a
  );
}
const JL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addToDataModel: XL
}, Symbol.toStringTag, { value: "Module" })), eD = {
  LNode: $L,
  LN: YL,
  DataTypeTemplates: JL
}, nD = {
  v2019C1: eD
};
function lD(e) {
  const { version: l, databaseInstance: i } = e, a = nD[l];
  return {
    // chainable methods
    fromRoot: () => jL({ version: l, databaseInstance: i, extensions: a }),
    fromElement: (s) => zL({ version: l, databaseInstance: i, extensions: a, ...s }),
    // ending methods
    getObservable: async (s) => await GL({ databaseInstance: i, ...s }),
    getElement: async (s) => await i[ht].get({
      tagName: s.tagName,
      id: s.id
    })
  };
}
function Dd(e) {
  const { databaseName: l, version: i } = e, a = wL({
    databaseName: l
  });
  return {
    api: lD({ version: i, databaseInstance: a }),
    utils: TL,
    database: a,
    standard: ua[i]
  };
}
const Lc = "v2019C1";
var tD = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function iD(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function uD(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var l = e.default;
  if (typeof l == "function") {
    var i = function a() {
      var s = !1;
      try {
        s = this instanceof a;
      } catch {
      }
      return s ? Reflect.construct(l, arguments, this.constructor) : l.apply(this, arguments);
    };
    i.prototype = l.prototype;
  } else i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(e).forEach(function(a) {
    var s = Object.getOwnPropertyDescriptor(e, a);
    Object.defineProperty(i, a, s.get ? s : {
      enumerable: !0,
      get: function() {
        return e[a];
      }
    });
  }), i;
}
var Od = {};
const aD = {}, rD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: aD
}, Symbol.toStringTag, { value: "Module" })), wd = /* @__PURE__ */ uD(rD);
var bd;
function sD() {
  return bd || (bd = 1, function(e) {
    (function(l) {
      l.parser = function(k, _) {
        return new a(k, _);
      }, l.SAXParser = a, l.SAXStream = x, l.createStream = I, l.MAX_BUFFER_LENGTH = 64 * 1024;
      var i = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      l.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function a(k, _) {
        if (!(this instanceof a))
          return new a(k, _);
        var B = this;
        o(B), B.q = B.c = "", B.bufferCheckPosition = l.MAX_BUFFER_LENGTH, B.opt = _ || {}, B.opt.lowercase = B.opt.lowercase || B.opt.lowercasetags, B.looseCase = B.opt.lowercase ? "toLowerCase" : "toUpperCase", B.tags = [], B.closed = B.closedRoot = B.sawRoot = !1, B.tag = B.error = null, B.strict = !!k, B.noscript = !!(k || B.opt.noscript), B.state = M.BEGIN, B.strictEntities = B.opt.strictEntities, B.ENTITIES = B.strictEntities ? Object.create(l.XML_ENTITIES) : Object.create(l.ENTITIES), B.attribList = [], B.opt.xmlns && (B.ns = Object.create(V)), B.opt.unquotedAttributeValues === void 0 && (B.opt.unquotedAttributeValues = !k), B.trackPosition = B.opt.position !== !1, B.trackPosition && (B.position = B.line = B.column = 0), Le(B, "onready");
      }
      Object.create || (Object.create = function(k) {
        function _() {
        }
        _.prototype = k;
        var B = new _();
        return B;
      }), Object.keys || (Object.keys = function(k) {
        var _ = [];
        for (var B in k) k.hasOwnProperty(B) && _.push(B);
        return _;
      });
      function s(k) {
        for (var _ = Math.max(l.MAX_BUFFER_LENGTH, 10), B = 0, le = 0, Xe = i.length; le < Xe; le++) {
          var De = k[i[le]].length;
          if (De > _)
            switch (i[le]) {
              case "textNode":
                ye(k);
                break;
              case "cdata":
                ae(k, "oncdata", k.cdata), k.cdata = "";
                break;
              case "script":
                ae(k, "onscript", k.script), k.script = "";
                break;
              default:
                Ce(k, "Max buffer length exceeded: " + i[le]);
            }
          B = Math.max(B, De);
        }
        var j = l.MAX_BUFFER_LENGTH - B;
        k.bufferCheckPosition = j + k.position;
      }
      function o(k) {
        for (var _ = 0, B = i.length; _ < B; _++)
          k[i[_]] = "";
      }
      function f(k) {
        ye(k), k.cdata !== "" && (ae(k, "oncdata", k.cdata), k.cdata = ""), k.script !== "" && (ae(k, "onscript", k.script), k.script = "");
      }
      a.prototype = {
        end: function() {
          xe(this);
        },
        write: ln,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          f(this);
        }
      };
      var d;
      try {
        d = wd.Stream;
      } catch {
        d = function() {
        };
      }
      d || (d = function() {
      });
      var h = l.EVENTS.filter(function(k) {
        return k !== "error" && k !== "end";
      });
      function I(k, _) {
        return new x(k, _);
      }
      function x(k, _) {
        if (!(this instanceof x))
          return new x(k, _);
        d.apply(this), this._parser = new a(k, _), this.writable = !0, this.readable = !0;
        var B = this;
        this._parser.onend = function() {
          B.emit("end");
        }, this._parser.onerror = function(le) {
          B.emit("error", le), B._parser.error = null;
        }, this._decoder = null, h.forEach(function(le) {
          Object.defineProperty(B, "on" + le, {
            get: function() {
              return B._parser["on" + le];
            },
            set: function(Xe) {
              if (!Xe)
                return B.removeAllListeners(le), B._parser["on" + le] = Xe, Xe;
              B.on(le, Xe);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      x.prototype = Object.create(d.prototype, {
        constructor: {
          value: x
        }
      }), x.prototype.write = function(k) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(k)) {
          if (!this._decoder) {
            var _ = wd.StringDecoder;
            this._decoder = new _("utf8");
          }
          k = this._decoder.write(k);
        }
        return this._parser.write(k.toString()), this.emit("data", k), !0;
      }, x.prototype.end = function(k) {
        return k && k.length && this.write(k), this._parser.end(), !0;
      }, x.prototype.on = function(k, _) {
        var B = this;
        return !B._parser["on" + k] && h.indexOf(k) !== -1 && (B._parser["on" + k] = function() {
          var le = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          le.splice(0, 0, k), B.emit.apply(B, le);
        }), d.prototype.on.call(B, k, _);
      };
      var y = "[CDATA[", P = "DOCTYPE", E = "http://www.w3.org/XML/1998/namespace", R = "http://www.w3.org/2000/xmlns/", V = { xml: E, xmlns: R }, K = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, $ = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, Q = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, Z = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function G(k) {
        return k === " " || k === `
` || k === "\r" || k === "	";
      }
      function Y(k) {
        return k === '"' || k === "'";
      }
      function se(k) {
        return k === ">" || G(k);
      }
      function te(k, _) {
        return k.test(_);
      }
      function fe(k, _) {
        return !te(k, _);
      }
      var M = 0;
      l.STATE = {
        BEGIN: M++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: M++,
        // leading whitespace
        TEXT: M++,
        // general stuff
        TEXT_ENTITY: M++,
        // &amp and such.
        OPEN_WAKA: M++,
        // <
        SGML_DECL: M++,
        // <!BLARG
        SGML_DECL_QUOTED: M++,
        // <!BLARG foo "bar
        DOCTYPE: M++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: M++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: M++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: M++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: M++,
        // <!-
        COMMENT: M++,
        // <!--
        COMMENT_ENDING: M++,
        // <!-- blah -
        COMMENT_ENDED: M++,
        // <!-- blah --
        CDATA: M++,
        // <![CDATA[ something
        CDATA_ENDING: M++,
        // ]
        CDATA_ENDING_2: M++,
        // ]]
        PROC_INST: M++,
        // <?hi
        PROC_INST_BODY: M++,
        // <?hi there
        PROC_INST_ENDING: M++,
        // <?hi "there" ?
        OPEN_TAG: M++,
        // <strong
        OPEN_TAG_SLASH: M++,
        // <strong /
        ATTRIB: M++,
        // <a
        ATTRIB_NAME: M++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: M++,
        // <a foo _
        ATTRIB_VALUE: M++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: M++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: M++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: M++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: M++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: M++,
        // <foo bar=&quot
        CLOSE_TAG: M++,
        // </a
        CLOSE_TAG_SAW_WHITE: M++,
        // </a   >
        SCRIPT: M++,
        // <script> ...
        SCRIPT_ENDING: M++
        // <script> ... <
      }, l.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, l.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(l.ENTITIES).forEach(function(k) {
        var _ = l.ENTITIES[k], B = typeof _ == "number" ? String.fromCharCode(_) : _;
        l.ENTITIES[k] = B;
      });
      for (var oe in l.STATE)
        l.STATE[l.STATE[oe]] = oe;
      M = l.STATE;
      function Le(k, _, B) {
        k[_] && k[_](B);
      }
      function ae(k, _, B) {
        k.textNode && ye(k), Le(k, _, B);
      }
      function ye(k) {
        k.textNode = he(k.opt, k.textNode), k.textNode && Le(k, "ontext", k.textNode), k.textNode = "";
      }
      function he(k, _) {
        return k.trim && (_ = _.trim()), k.normalize && (_ = _.replace(/\s+/g, " ")), _;
      }
      function Ce(k, _) {
        return ye(k), k.trackPosition && (_ += `
Line: ` + k.line + `
Column: ` + k.column + `
Char: ` + k.c), _ = new Error(_), k.error = _, Le(k, "onerror", _), k;
      }
      function xe(k) {
        return k.sawRoot && !k.closedRoot && ce(k, "Unclosed root tag"), k.state !== M.BEGIN && k.state !== M.BEGIN_WHITESPACE && k.state !== M.TEXT && Ce(k, "Unexpected end"), ye(k), k.c = "", k.closed = !0, Le(k, "onend"), a.call(k, k.strict, k.opt), k;
      }
      function ce(k, _) {
        if (typeof k != "object" || !(k instanceof a))
          throw new Error("bad call to strictFail");
        k.strict && Ce(k, _);
      }
      function de(k) {
        k.strict || (k.tagName = k.tagName[k.looseCase]());
        var _ = k.tags[k.tags.length - 1] || k, B = k.tag = { name: k.tagName, attributes: {} };
        k.opt.xmlns && (B.ns = _.ns), k.attribList.length = 0, ae(k, "onopentagstart", B);
      }
      function we(k, _) {
        var B = k.indexOf(":"), le = B < 0 ? ["", k] : k.split(":"), Xe = le[0], De = le[1];
        return _ && k === "xmlns" && (Xe = "xmlns", De = ""), { prefix: Xe, local: De };
      }
      function Ae(k) {
        if (k.strict || (k.attribName = k.attribName[k.looseCase]()), k.attribList.indexOf(k.attribName) !== -1 || k.tag.attributes.hasOwnProperty(k.attribName)) {
          k.attribName = k.attribValue = "";
          return;
        }
        if (k.opt.xmlns) {
          var _ = we(k.attribName, !0), B = _.prefix, le = _.local;
          if (B === "xmlns")
            if (le === "xml" && k.attribValue !== E)
              ce(
                k,
                "xml: prefix must be bound to " + E + `
Actual: ` + k.attribValue
              );
            else if (le === "xmlns" && k.attribValue !== R)
              ce(
                k,
                "xmlns: prefix must be bound to " + R + `
Actual: ` + k.attribValue
              );
            else {
              var Xe = k.tag, De = k.tags[k.tags.length - 1] || k;
              Xe.ns === De.ns && (Xe.ns = Object.create(De.ns)), Xe.ns[le] = k.attribValue;
            }
          k.attribList.push([k.attribName, k.attribValue]);
        } else
          k.tag.attributes[k.attribName] = k.attribValue, ae(k, "onattribute", {
            name: k.attribName,
            value: k.attribValue
          });
        k.attribName = k.attribValue = "";
      }
      function $e(k, _) {
        if (k.opt.xmlns) {
          var B = k.tag, le = we(k.tagName);
          B.prefix = le.prefix, B.local = le.local, B.uri = B.ns[le.prefix] || "", B.prefix && !B.uri && (ce(k, "Unbound namespace prefix: " + JSON.stringify(k.tagName)), B.uri = le.prefix);
          var Xe = k.tags[k.tags.length - 1] || k;
          B.ns && Xe.ns !== B.ns && Object.keys(B.ns).forEach(function(qe) {
            ae(k, "onopennamespace", {
              prefix: qe,
              uri: B.ns[qe]
            });
          });
          for (var De = 0, j = k.attribList.length; De < j; De++) {
            var ie = k.attribList[De], me = ie[0], Te = ie[1], Ie = we(me, !0), be = Ie.prefix, Ne = Ie.local, Ee = be === "" ? "" : B.ns[be] || "", Oe = {
              name: me,
              value: Te,
              prefix: be,
              local: Ne,
              uri: Ee
            };
            be && be !== "xmlns" && !Ee && (ce(k, "Unbound namespace prefix: " + JSON.stringify(be)), Oe.uri = be), k.tag.attributes[me] = Oe, ae(k, "onattribute", Oe);
          }
          k.attribList.length = 0;
        }
        k.tag.isSelfClosing = !!_, k.sawRoot = !0, k.tags.push(k.tag), ae(k, "onopentag", k.tag), _ || (!k.noscript && k.tagName.toLowerCase() === "script" ? k.state = M.SCRIPT : k.state = M.TEXT, k.tag = null, k.tagName = ""), k.attribName = k.attribValue = "", k.attribList.length = 0;
      }
      function ze(k) {
        if (!k.tagName) {
          ce(k, "Weird empty close tag."), k.textNode += "</>", k.state = M.TEXT;
          return;
        }
        if (k.script) {
          if (k.tagName !== "script") {
            k.script += "</" + k.tagName + ">", k.tagName = "", k.state = M.SCRIPT;
            return;
          }
          ae(k, "onscript", k.script), k.script = "";
        }
        var _ = k.tags.length, B = k.tagName;
        k.strict || (B = B[k.looseCase]());
        for (var le = B; _--; ) {
          var Xe = k.tags[_];
          if (Xe.name !== le)
            ce(k, "Unexpected close tag");
          else
            break;
        }
        if (_ < 0) {
          ce(k, "Unmatched closing tag: " + k.tagName), k.textNode += "</" + k.tagName + ">", k.state = M.TEXT;
          return;
        }
        k.tagName = B;
        for (var De = k.tags.length; De-- > _; ) {
          var j = k.tag = k.tags.pop();
          k.tagName = k.tag.name, ae(k, "onclosetag", k.tagName);
          var ie = {};
          for (var me in j.ns)
            ie[me] = j.ns[me];
          var Te = k.tags[k.tags.length - 1] || k;
          k.opt.xmlns && j.ns !== Te.ns && Object.keys(j.ns).forEach(function(Ie) {
            var be = j.ns[Ie];
            ae(k, "onclosenamespace", { prefix: Ie, uri: be });
          });
        }
        _ === 0 && (k.closedRoot = !0), k.tagName = k.attribValue = k.attribName = "", k.attribList.length = 0, k.state = M.TEXT;
      }
      function cn(k) {
        var _ = k.entity, B = _.toLowerCase(), le, Xe = "";
        return k.ENTITIES[_] ? k.ENTITIES[_] : k.ENTITIES[B] ? k.ENTITIES[B] : (_ = B, _.charAt(0) === "#" && (_.charAt(1) === "x" ? (_ = _.slice(2), le = parseInt(_, 16), Xe = le.toString(16)) : (_ = _.slice(1), le = parseInt(_, 10), Xe = le.toString(10))), _ = _.replace(/^0+/, ""), isNaN(le) || Xe.toLowerCase() !== _ ? (ce(k, "Invalid character entity"), "&" + k.entity + ";") : String.fromCodePoint(le));
      }
      function Cn(k, _) {
        _ === "<" ? (k.state = M.OPEN_WAKA, k.startTagPosition = k.position) : G(_) || (ce(k, "Non-whitespace before first tag."), k.textNode = _, k.state = M.TEXT);
      }
      function xn(k, _) {
        var B = "";
        return _ < k.length && (B = k.charAt(_)), B;
      }
      function ln(k) {
        var _ = this;
        if (this.error)
          throw this.error;
        if (_.closed)
          return Ce(
            _,
            "Cannot write after close. Assign an onready handler."
          );
        if (k === null)
          return xe(_);
        typeof k == "object" && (k = k.toString());
        for (var B = 0, le = ""; le = xn(k, B++), _.c = le, !!le; )
          switch (_.trackPosition && (_.position++, le === `
` ? (_.line++, _.column = 0) : _.column++), _.state) {
            case M.BEGIN:
              if (_.state = M.BEGIN_WHITESPACE, le === "\uFEFF")
                continue;
              Cn(_, le);
              continue;
            case M.BEGIN_WHITESPACE:
              Cn(_, le);
              continue;
            case M.TEXT:
              if (_.sawRoot && !_.closedRoot) {
                for (var Xe = B - 1; le && le !== "<" && le !== "&"; )
                  le = xn(k, B++), le && _.trackPosition && (_.position++, le === `
` ? (_.line++, _.column = 0) : _.column++);
                _.textNode += k.substring(Xe, B - 1);
              }
              le === "<" && !(_.sawRoot && _.closedRoot && !_.strict) ? (_.state = M.OPEN_WAKA, _.startTagPosition = _.position) : (!G(le) && (!_.sawRoot || _.closedRoot) && ce(_, "Text data outside of root node."), le === "&" ? _.state = M.TEXT_ENTITY : _.textNode += le);
              continue;
            case M.SCRIPT:
              le === "<" ? _.state = M.SCRIPT_ENDING : _.script += le;
              continue;
            case M.SCRIPT_ENDING:
              le === "/" ? _.state = M.CLOSE_TAG : (_.script += "<" + le, _.state = M.SCRIPT);
              continue;
            case M.OPEN_WAKA:
              if (le === "!")
                _.state = M.SGML_DECL, _.sgmlDecl = "";
              else if (!G(le)) if (te(K, le))
                _.state = M.OPEN_TAG, _.tagName = le;
              else if (le === "/")
                _.state = M.CLOSE_TAG, _.tagName = "";
              else if (le === "?")
                _.state = M.PROC_INST, _.procInstName = _.procInstBody = "";
              else {
                if (ce(_, "Unencoded <"), _.startTagPosition + 1 < _.position) {
                  var De = _.position - _.startTagPosition;
                  le = new Array(De).join(" ") + le;
                }
                _.textNode += "<" + le, _.state = M.TEXT;
              }
              continue;
            case M.SGML_DECL:
              if (_.sgmlDecl + le === "--") {
                _.state = M.COMMENT, _.comment = "", _.sgmlDecl = "";
                continue;
              }
              _.doctype && _.doctype !== !0 && _.sgmlDecl ? (_.state = M.DOCTYPE_DTD, _.doctype += "<!" + _.sgmlDecl + le, _.sgmlDecl = "") : (_.sgmlDecl + le).toUpperCase() === y ? (ae(_, "onopencdata"), _.state = M.CDATA, _.sgmlDecl = "", _.cdata = "") : (_.sgmlDecl + le).toUpperCase() === P ? (_.state = M.DOCTYPE, (_.doctype || _.sawRoot) && ce(
                _,
                "Inappropriately located doctype declaration"
              ), _.doctype = "", _.sgmlDecl = "") : le === ">" ? (ae(_, "onsgmldeclaration", _.sgmlDecl), _.sgmlDecl = "", _.state = M.TEXT) : (Y(le) && (_.state = M.SGML_DECL_QUOTED), _.sgmlDecl += le);
              continue;
            case M.SGML_DECL_QUOTED:
              le === _.q && (_.state = M.SGML_DECL, _.q = ""), _.sgmlDecl += le;
              continue;
            case M.DOCTYPE:
              le === ">" ? (_.state = M.TEXT, ae(_, "ondoctype", _.doctype), _.doctype = !0) : (_.doctype += le, le === "[" ? _.state = M.DOCTYPE_DTD : Y(le) && (_.state = M.DOCTYPE_QUOTED, _.q = le));
              continue;
            case M.DOCTYPE_QUOTED:
              _.doctype += le, le === _.q && (_.q = "", _.state = M.DOCTYPE);
              continue;
            case M.DOCTYPE_DTD:
              le === "]" ? (_.doctype += le, _.state = M.DOCTYPE) : le === "<" ? (_.state = M.OPEN_WAKA, _.startTagPosition = _.position) : Y(le) ? (_.doctype += le, _.state = M.DOCTYPE_DTD_QUOTED, _.q = le) : _.doctype += le;
              continue;
            case M.DOCTYPE_DTD_QUOTED:
              _.doctype += le, le === _.q && (_.state = M.DOCTYPE_DTD, _.q = "");
              continue;
            case M.COMMENT:
              le === "-" ? _.state = M.COMMENT_ENDING : _.comment += le;
              continue;
            case M.COMMENT_ENDING:
              le === "-" ? (_.state = M.COMMENT_ENDED, _.comment = he(_.opt, _.comment), _.comment && ae(_, "oncomment", _.comment), _.comment = "") : (_.comment += "-" + le, _.state = M.COMMENT);
              continue;
            case M.COMMENT_ENDED:
              le !== ">" ? (ce(_, "Malformed comment"), _.comment += "--" + le, _.state = M.COMMENT) : _.doctype && _.doctype !== !0 ? _.state = M.DOCTYPE_DTD : _.state = M.TEXT;
              continue;
            case M.CDATA:
              le === "]" ? _.state = M.CDATA_ENDING : _.cdata += le;
              continue;
            case M.CDATA_ENDING:
              le === "]" ? _.state = M.CDATA_ENDING_2 : (_.cdata += "]" + le, _.state = M.CDATA);
              continue;
            case M.CDATA_ENDING_2:
              le === ">" ? (_.cdata && ae(_, "oncdata", _.cdata), ae(_, "onclosecdata"), _.cdata = "", _.state = M.TEXT) : le === "]" ? _.cdata += "]" : (_.cdata += "]]" + le, _.state = M.CDATA);
              continue;
            case M.PROC_INST:
              le === "?" ? _.state = M.PROC_INST_ENDING : G(le) ? _.state = M.PROC_INST_BODY : _.procInstName += le;
              continue;
            case M.PROC_INST_BODY:
              if (!_.procInstBody && G(le))
                continue;
              le === "?" ? _.state = M.PROC_INST_ENDING : _.procInstBody += le;
              continue;
            case M.PROC_INST_ENDING:
              le === ">" ? (ae(_, "onprocessinginstruction", {
                name: _.procInstName,
                body: _.procInstBody
              }), _.procInstName = _.procInstBody = "", _.state = M.TEXT) : (_.procInstBody += "?" + le, _.state = M.PROC_INST_BODY);
              continue;
            case M.OPEN_TAG:
              te($, le) ? _.tagName += le : (de(_), le === ">" ? $e(_) : le === "/" ? _.state = M.OPEN_TAG_SLASH : (G(le) || ce(_, "Invalid character in tag name"), _.state = M.ATTRIB));
              continue;
            case M.OPEN_TAG_SLASH:
              le === ">" ? ($e(_, !0), ze(_)) : (ce(_, "Forward-slash in opening tag not followed by >"), _.state = M.ATTRIB);
              continue;
            case M.ATTRIB:
              if (G(le))
                continue;
              le === ">" ? $e(_) : le === "/" ? _.state = M.OPEN_TAG_SLASH : te(K, le) ? (_.attribName = le, _.attribValue = "", _.state = M.ATTRIB_NAME) : ce(_, "Invalid attribute name");
              continue;
            case M.ATTRIB_NAME:
              le === "=" ? _.state = M.ATTRIB_VALUE : le === ">" ? (ce(_, "Attribute without value"), _.attribValue = _.attribName, Ae(_), $e(_)) : G(le) ? _.state = M.ATTRIB_NAME_SAW_WHITE : te($, le) ? _.attribName += le : ce(_, "Invalid attribute name");
              continue;
            case M.ATTRIB_NAME_SAW_WHITE:
              if (le === "=")
                _.state = M.ATTRIB_VALUE;
              else {
                if (G(le))
                  continue;
                ce(_, "Attribute without value"), _.tag.attributes[_.attribName] = "", _.attribValue = "", ae(_, "onattribute", {
                  name: _.attribName,
                  value: ""
                }), _.attribName = "", le === ">" ? $e(_) : te(K, le) ? (_.attribName = le, _.state = M.ATTRIB_NAME) : (ce(_, "Invalid attribute name"), _.state = M.ATTRIB);
              }
              continue;
            case M.ATTRIB_VALUE:
              if (G(le))
                continue;
              Y(le) ? (_.q = le, _.state = M.ATTRIB_VALUE_QUOTED) : (_.opt.unquotedAttributeValues || Ce(_, "Unquoted attribute value"), _.state = M.ATTRIB_VALUE_UNQUOTED, _.attribValue = le);
              continue;
            case M.ATTRIB_VALUE_QUOTED:
              if (le !== _.q) {
                le === "&" ? _.state = M.ATTRIB_VALUE_ENTITY_Q : _.attribValue += le;
                continue;
              }
              Ae(_), _.q = "", _.state = M.ATTRIB_VALUE_CLOSED;
              continue;
            case M.ATTRIB_VALUE_CLOSED:
              G(le) ? _.state = M.ATTRIB : le === ">" ? $e(_) : le === "/" ? _.state = M.OPEN_TAG_SLASH : te(K, le) ? (ce(_, "No whitespace between attributes"), _.attribName = le, _.attribValue = "", _.state = M.ATTRIB_NAME) : ce(_, "Invalid attribute name");
              continue;
            case M.ATTRIB_VALUE_UNQUOTED:
              if (!se(le)) {
                le === "&" ? _.state = M.ATTRIB_VALUE_ENTITY_U : _.attribValue += le;
                continue;
              }
              Ae(_), le === ">" ? $e(_) : _.state = M.ATTRIB;
              continue;
            case M.CLOSE_TAG:
              if (_.tagName)
                le === ">" ? ze(_) : te($, le) ? _.tagName += le : _.script ? (_.script += "</" + _.tagName, _.tagName = "", _.state = M.SCRIPT) : (G(le) || ce(_, "Invalid tagname in closing tag"), _.state = M.CLOSE_TAG_SAW_WHITE);
              else {
                if (G(le))
                  continue;
                fe(K, le) ? _.script ? (_.script += "</" + le, _.state = M.SCRIPT) : ce(_, "Invalid tagname in closing tag.") : _.tagName = le;
              }
              continue;
            case M.CLOSE_TAG_SAW_WHITE:
              if (G(le))
                continue;
              le === ">" ? ze(_) : ce(_, "Invalid characters in closing tag");
              continue;
            case M.TEXT_ENTITY:
            case M.ATTRIB_VALUE_ENTITY_Q:
            case M.ATTRIB_VALUE_ENTITY_U:
              var j, ie;
              switch (_.state) {
                case M.TEXT_ENTITY:
                  j = M.TEXT, ie = "textNode";
                  break;
                case M.ATTRIB_VALUE_ENTITY_Q:
                  j = M.ATTRIB_VALUE_QUOTED, ie = "attribValue";
                  break;
                case M.ATTRIB_VALUE_ENTITY_U:
                  j = M.ATTRIB_VALUE_UNQUOTED, ie = "attribValue";
                  break;
              }
              if (le === ";") {
                var me = cn(_);
                _.opt.unparsedEntities && !Object.values(l.XML_ENTITIES).includes(me) ? (_.entity = "", _.state = j, _.write(me)) : (_[ie] += me, _.entity = "", _.state = j);
              } else te(_.entity.length ? Z : Q, le) ? _.entity += le : (ce(_, "Invalid character in entity name"), _[ie] += "&" + _.entity + le, _.entity = "", _.state = j);
              continue;
            default:
              throw new Error(_, "Unknown state: " + _.state);
          }
        return _.position >= _.bufferCheckPosition && s(_), _;
      }
      String.fromCodePoint || function() {
        var k = String.fromCharCode, _ = Math.floor, B = function() {
          var le = 16384, Xe = [], De, j, ie = -1, me = arguments.length;
          if (!me)
            return "";
          for (var Te = ""; ++ie < me; ) {
            var Ie = Number(arguments[ie]);
            if (!isFinite(Ie) || // `NaN`, `+Infinity`, or `-Infinity`
            Ie < 0 || // not a valid Unicode code point
            Ie > 1114111 || // not a valid Unicode code point
            _(Ie) !== Ie)
              throw RangeError("Invalid code point: " + Ie);
            Ie <= 65535 ? Xe.push(Ie) : (Ie -= 65536, De = (Ie >> 10) + 55296, j = Ie % 1024 + 56320, Xe.push(De, j)), (ie + 1 === me || Xe.length > le) && (Te += k.apply(null, Xe), Xe.length = 0);
          }
          return Te;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: B,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = B;
      }();
    })(e);
  }(Od)), Od;
}
var cD = sD();
const zr = {};
function oD(e) {
  const { parentId: l, child: i } = e;
  zr[l] || (zr[l] = []);
  const a = {
    id: i.id,
    tagName: i.tagName
  };
  zr[l].push(a);
}
function mD(e) {
  const { currentBatch: l } = e, i = [...l];
  for (const [a, s] of i.entries()) {
    const o = zr[s.id] || [];
    o.length > 0 && (i[a].children.push(...o), fD({
      parentId: s.id
    }));
  }
  return i;
}
function fD(e) {
  const { parentId: l } = e;
  delete zr[l];
}
function dD(e) {
  return "prefix" in e && "uri" in e && !!e.prefix && !!e.uri;
}
const pD = [
  ".fsd",
  ".asd",
  ".ssd",
  ".scd",
  ".isd",
  ".icd",
  ".xml"
], Js = "sclElements", So = "id, tagName, &attributes.uuid, &attributes.id, attributes.name, parent.id, parent.tagName, *children.id, *children.tagName", Co = "attachedFiles", Sd = "id, filename, file", hD = {
  default: {
    prefix: "",
    uri: "http://www.iec.ch/61850/2003/SCL"
  }
};
function gD() {
  let e = {
    defaultNamespace: null,
    stack: [],
    recordsBatch: []
  };
  const l = cD.parser(
    !0,
    // strict mode
    {
      lowercase: !1,
      // Preserve case
      trim: !0,
      // Trim text nodes
      normalize: !0,
      // Normalize whitespace
      position: !1,
      // Don't track position (performance boost)
      xmlns: !0
      // Enable namespace handling
    }
  );
  l.onopentag = (s) => e = vD({ node: s, state: e }), l.ontext = (s) => e = xD({ text: s, state: e }), l.onclosetag = () => ({ updatedState: e } = yD({
    state: e
  })), l.onerror = ID;
  function i() {
    const s = e.recordsBatch;
    return e.recordsBatch = [], s;
  }
  function a() {
    return e.recordsBatch.length;
  }
  return {
    parser: l,
    drainBatch: i,
    getSize: a
  };
}
function vD(e) {
  const { node: l, state: i } = e, a = { ...i }, s = LD(l);
  a.defaultNamespace || (a.defaultNamespace = DD(l));
  const o = OD(l, a.defaultNamespace), f = wD(l.attributes), d = bD(i.stack), h = {
    id: crypto.randomUUID(),
    tagName: s,
    namespace: o,
    attributes: f,
    value: "",
    parent: d,
    children: []
  };
  return a.stack.push(h), a;
}
function xD(e) {
  const { text: l, state: i } = e;
  return l && i.stack.length > 0 && (i.stack[i.stack.length - 1].value += l), i;
}
function yD(e) {
  const { state: l } = e, i = l.stack.at(-1);
  let a = l.stack.slice(0, -1);
  const s = [...l.recordsBatch];
  if (i) {
    if (a.length) {
      const o = a.length - 1;
      a = a.map(
        (f, d) => d === o ? {
          ...f,
          children: [
            ...f.children,
            { id: i.id, tagName: i.tagName }
          ]
        } : f
      );
    } else i.parent && oD({
      parentId: i.parent.id,
      child: { id: i.id, tagName: i.tagName }
    });
    s.push(i);
  }
  return {
    updatedState: {
      defaultNamespace: l.defaultNamespace,
      stack: a,
      recordsBatch: s
    }
  };
}
function ID(e) {
  return new Error(`XML parsing error: ${e}`);
}
function LD(e) {
  return e.local || null;
}
function DD(e) {
  if (e.name !== "SCL") throw new Error("Default namespace can only be set on SCL element");
  return e.attributes?.xmlns?.value ? {
    prefix: "",
    uri: e.attributes.xmlns.value
  } : hD.default;
}
function OD(e, l) {
  return dD(e) ? {
    prefix: e.prefix,
    uri: e.uri
  } : l;
}
function wD(e) {
  return Object.values(e).map((l) => {
    const i = l.prefix && l.uri ? {
      prefix: l.prefix,
      uri: l.uri
    } : void 0;
    return {
      name: l.name,
      value: l.value,
      ...i && { namespace: i }
    };
  });
}
function bD(e) {
  if (e.length === 0) return null;
  const l = e[e.length - 1];
  return l ? { id: l.id, tagName: l.tagName } : null;
}
var Lm = { exports: {} }, SD = Lm.exports, Cd;
function CD() {
  return Cd || (Cd = 1, function(e, l) {
    (function(i, a) {
      e.exports = a();
    })(SD, function() {
      var i = function(n, t) {
        return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(u, r) {
          u.__proto__ = r;
        } || function(u, r) {
          for (var c in r) Object.prototype.hasOwnProperty.call(r, c) && (u[c] = r[c]);
        })(n, t);
      }, a = function() {
        return (a = Object.assign || function(n) {
          for (var t, u = 1, r = arguments.length; u < r; u++) for (var c in t = arguments[u]) Object.prototype.hasOwnProperty.call(t, c) && (n[c] = t[c]);
          return n;
        }).apply(this, arguments);
      };
      function s(n, t, u) {
        for (var r, c = 0, m = t.length; c < m; c++) !r && c in t || ((r = r || Array.prototype.slice.call(t, 0, c))[c] = t[c]);
        return n.concat(r || Array.prototype.slice.call(t));
      }
      var o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : tD, f = Object.keys, d = Array.isArray;
      function h(n, t) {
        return typeof t != "object" || f(t).forEach(function(u) {
          n[u] = t[u];
        }), n;
      }
      typeof Promise > "u" || o.Promise || (o.Promise = Promise);
      var I = Object.getPrototypeOf, x = {}.hasOwnProperty;
      function y(n, t) {
        return x.call(n, t);
      }
      function P(n, t) {
        typeof t == "function" && (t = t(I(n))), (typeof Reflect > "u" ? f : Reflect.ownKeys)(t).forEach(function(u) {
          R(n, u, t[u]);
        });
      }
      var E = Object.defineProperty;
      function R(n, t, u, r) {
        E(n, t, h(u && y(u, "get") && typeof u.get == "function" ? { get: u.get, set: u.set, configurable: !0 } : { value: u, configurable: !0, writable: !0 }, r));
      }
      function V(n) {
        return { from: function(t) {
          return n.prototype = Object.create(t.prototype), R(n.prototype, "constructor", n), { extend: P.bind(null, n.prototype) };
        } };
      }
      var K = Object.getOwnPropertyDescriptor, $ = [].slice;
      function Q(n, t, u) {
        return $.call(n, t, u);
      }
      function Z(n, t) {
        return t(n);
      }
      function G(n) {
        if (!n) throw new Error("Assertion Failed");
      }
      function Y(n) {
        o.setImmediate ? setImmediate(n) : setTimeout(n, 0);
      }
      function se(n, t) {
        if (typeof t == "string" && y(n, t)) return n[t];
        if (!t) return n;
        if (typeof t != "string") {
          for (var u = [], r = 0, c = t.length; r < c; ++r) {
            var m = se(n, t[r]);
            u.push(m);
          }
          return u;
        }
        var p = t.indexOf(".");
        if (p !== -1) {
          var g = n[t.substr(0, p)];
          return g == null ? void 0 : se(g, t.substr(p + 1));
        }
      }
      function te(n, t, u) {
        if (n && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(n))) if (typeof t != "string" && "length" in t) {
          G(typeof u != "string" && "length" in u);
          for (var r = 0, c = t.length; r < c; ++r) te(n, t[r], u[r]);
        } else {
          var m, p, g = t.indexOf(".");
          g !== -1 ? (m = t.substr(0, g), (p = t.substr(g + 1)) === "" ? u === void 0 ? d(n) && !isNaN(parseInt(m)) ? n.splice(m, 1) : delete n[m] : n[m] = u : te(g = !(g = n[m]) || !y(n, m) ? n[m] = {} : g, p, u)) : u === void 0 ? d(n) && !isNaN(parseInt(t)) ? n.splice(t, 1) : delete n[t] : n[t] = u;
        }
      }
      function fe(n) {
        var t, u = {};
        for (t in n) y(n, t) && (u[t] = n[t]);
        return u;
      }
      var M = [].concat;
      function oe(n) {
        return M.apply([], n);
      }
      var Ue = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(oe([8, 16, 32, 64].map(function(n) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + n + "Array";
        });
      }))).filter(function(n) {
        return o[n];
      }), Le = new Set(Ue.map(function(n) {
        return o[n];
      })), ae = null;
      function ye(n) {
        return ae = /* @__PURE__ */ new WeakMap(), n = function t(u) {
          if (!u || typeof u != "object") return u;
          var r = ae.get(u);
          if (r) return r;
          if (d(u)) {
            r = [], ae.set(u, r);
            for (var c = 0, m = u.length; c < m; ++c) r.push(t(u[c]));
          } else if (Le.has(u.constructor)) r = u;
          else {
            var p, g = I(u);
            for (p in r = g === Object.prototype ? {} : Object.create(g), ae.set(u, r), u) y(u, p) && (r[p] = t(u[p]));
          }
          return r;
        }(n), ae = null, n;
      }
      var he = {}.toString;
      function Ce(n) {
        return he.call(n).slice(8, -1);
      }
      var xe = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", ce = typeof xe == "symbol" ? function(n) {
        var t;
        return n != null && (t = n[xe]) && t.apply(n);
      } : function() {
        return null;
      };
      function de(n, t) {
        return t = n.indexOf(t), 0 <= t && n.splice(t, 1), 0 <= t;
      }
      var we = {};
      function Ae(n) {
        var t, u, r, c;
        if (arguments.length === 1) {
          if (d(n)) return n.slice();
          if (this === we && typeof n == "string") return [n];
          if (c = ce(n)) {
            for (u = []; !(r = c.next()).done; ) u.push(r.value);
            return u;
          }
          if (n == null) return [n];
          if (typeof (t = n.length) != "number") return [n];
          for (u = new Array(t); t--; ) u[t] = n[t];
          return u;
        }
        for (t = arguments.length, u = new Array(t); t--; ) u[t] = arguments[t];
        return u;
      }
      var $e = typeof Symbol < "u" ? function(n) {
        return n[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ze = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], In = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ze), ze = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function cn(n, t) {
        this.name = n, this.message = t;
      }
      function Cn(n, t) {
        return n + ". Errors: " + Object.keys(t).map(function(u) {
          return t[u].toString();
        }).filter(function(u, r, c) {
          return c.indexOf(u) === r;
        }).join(`
`);
      }
      function xn(n, t, u, r) {
        this.failures = t, this.failedKeys = r, this.successCount = u, this.message = Cn(n, t);
      }
      function ln(n, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(u) {
          return t[u];
        }), this.failuresByPos = t, this.message = Cn(n, this.failures);
      }
      V(cn).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), V(xn).from(cn), V(ln).from(cn);
      var k = In.reduce(function(n, t) {
        return n[t] = t + "Error", n;
      }, {}), _ = cn, B = In.reduce(function(n, t) {
        var u = t + "Error";
        function r(c, m) {
          this.name = u, c ? typeof c == "string" ? (this.message = "".concat(c).concat(m ? `
 ` + m : ""), this.inner = m || null) : typeof c == "object" && (this.message = "".concat(c.name, " ").concat(c.message), this.inner = c) : (this.message = ze[t] || u, this.inner = null);
        }
        return V(r).from(_), n[t] = r, n;
      }, {});
      B.Syntax = SyntaxError, B.Type = TypeError, B.Range = RangeError;
      var le = Ze.reduce(function(n, t) {
        return n[t + "Error"] = B[t], n;
      }, {}), Xe = In.reduce(function(n, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (n[t + "Error"] = B[t]), n;
      }, {});
      function De() {
      }
      function j(n) {
        return n;
      }
      function ie(n, t) {
        return n == null || n === j ? t : function(u) {
          return t(n(u));
        };
      }
      function me(n, t) {
        return function() {
          n.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function Te(n, t) {
        return n === De ? t : function() {
          var u = n.apply(this, arguments);
          u !== void 0 && (arguments[0] = u);
          var r = this.onsuccess, c = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var m = t.apply(this, arguments);
          return r && (this.onsuccess = this.onsuccess ? me(r, this.onsuccess) : r), c && (this.onerror = this.onerror ? me(c, this.onerror) : c), m !== void 0 ? m : u;
        };
      }
      function Ie(n, t) {
        return n === De ? t : function() {
          n.apply(this, arguments);
          var u = this.onsuccess, r = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), u && (this.onsuccess = this.onsuccess ? me(u, this.onsuccess) : u), r && (this.onerror = this.onerror ? me(r, this.onerror) : r);
        };
      }
      function be(n, t) {
        return n === De ? t : function(u) {
          var r = n.apply(this, arguments);
          h(u, r);
          var c = this.onsuccess, m = this.onerror;
          return this.onsuccess = null, this.onerror = null, u = t.apply(this, arguments), c && (this.onsuccess = this.onsuccess ? me(c, this.onsuccess) : c), m && (this.onerror = this.onerror ? me(m, this.onerror) : m), r === void 0 ? u === void 0 ? void 0 : u : h(r, u);
        };
      }
      function Ne(n, t) {
        return n === De ? t : function() {
          return t.apply(this, arguments) !== !1 && n.apply(this, arguments);
        };
      }
      function Ee(n, t) {
        return n === De ? t : function() {
          var u = n.apply(this, arguments);
          if (u && typeof u.then == "function") {
            for (var r = this, c = arguments.length, m = new Array(c); c--; ) m[c] = arguments[c];
            return u.then(function() {
              return t.apply(r, m);
            });
          }
          return t.apply(this, arguments);
        };
      }
      Xe.ModifyError = xn, Xe.DexieError = cn, Xe.BulkError = ln;
      var Oe = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function qe(n) {
        Oe = n;
      }
      var Ke = {}, ke = 100, Ue = typeof Promise > "u" ? [] : function() {
        var n = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [n, I(n), n];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, I(t), n];
      }(), Ze = Ue[0], In = Ue[1], Ue = Ue[2], In = In && In.then, Qe = Ze && Ze.constructor, yn = !!Ue, on = function(n, t) {
        Fn.push([n, t]), Tn && (queueMicrotask(Xa), Tn = !1);
      }, Bn = !0, Tn = !0, Dn = [], Nn = [], xl = j, Rn = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: De, pgp: !1, env: {}, finalize: De }, re = Rn, Fn = [], Zn = 0, yl = [];
      function ee(n) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = re;
        if (typeof n != "function") {
          if (n !== Ke) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && qt(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function u(r, c) {
          try {
            c(function(m) {
              if (r._state === null) {
                if (m === r) throw new TypeError("A promise cannot be resolved with itself.");
                var p = r._lib && al();
                m && typeof m.then == "function" ? u(r, function(g, L) {
                  m instanceof ee ? m._then(g, L) : m.then(g, L);
                }) : (r._state = !0, r._value = m, Hi(r)), p && rl();
              }
            }, qt.bind(null, r));
          } catch (m) {
            qt(r, m);
          }
        }(this, n);
      }
      var Tt = { get: function() {
        var n = re, t = Gl;
        function u(r, c) {
          var m = this, p = !n.global && (n !== re || t !== Gl), g = p && !Kn(), L = new ee(function(O, b) {
            Pt(m, new ji(Wi(r, n, p, g), Wi(c, n, p, g), O, b, n));
          });
          return this._consoleTask && (L._consoleTask = this._consoleTask), L;
        }
        return u.prototype = Ke, u;
      }, set: function(n) {
        R(this, "then", n && n.prototype === Ke ? Tt : { get: function() {
          return n;
        }, set: Tt.set });
      } };
      function ji(n, t, u, r, c) {
        this.onFulfilled = typeof n == "function" ? n : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = u, this.reject = r, this.psd = c;
      }
      function qt(n, t) {
        var u, r;
        Nn.push(t), n._state === null && (u = n._lib && al(), t = xl(t), n._state = !1, n._value = t, r = n, Dn.some(function(c) {
          return c._value === r._value;
        }) || Dn.push(r), Hi(n), u && rl());
      }
      function Hi(n) {
        var t = n._listeners;
        n._listeners = [];
        for (var u = 0, r = t.length; u < r; ++u) Pt(n, t[u]);
        var c = n._PSD;
        --c.ref || c.finalize(), Zn === 0 && (++Zn, on(function() {
          --Zn == 0 && Rt();
        }, []));
      }
      function Pt(n, t) {
        if (n._state !== null) {
          var u = n._state ? t.onFulfilled : t.onRejected;
          if (u === null) return (n._state ? t.resolve : t.reject)(n._value);
          ++t.psd.ref, ++Zn, on(Ya, [u, n, t]);
        } else n._listeners.push(t);
      }
      function Ya(n, t, u) {
        try {
          var r, c = t._value;
          !t._state && Nn.length && (Nn = []), r = Oe && t._consoleTask ? t._consoleTask.run(function() {
            return n(c);
          }) : n(c), t._state || Nn.indexOf(c) !== -1 || function(m) {
            for (var p = Dn.length; p; ) if (Dn[--p]._value === m._value) return Dn.splice(p, 1);
          }(t), u.resolve(r);
        } catch (m) {
          u.reject(m);
        } finally {
          --Zn == 0 && Rt(), --u.psd.ref || u.psd.finalize();
        }
      }
      function Xa() {
        Xn(Rn, function() {
          al() && rl();
        });
      }
      function al() {
        var n = Bn;
        return Tn = Bn = !1, n;
      }
      function rl() {
        var n, t, u;
        do
          for (; 0 < Fn.length; ) for (n = Fn, Fn = [], u = n.length, t = 0; t < u; ++t) {
            var r = n[t];
            r[0].apply(null, r[1]);
          }
        while (0 < Fn.length);
        Tn = Bn = !0;
      }
      function Rt() {
        var n = Dn;
        Dn = [], n.forEach(function(r) {
          r._PSD.onunhandled.call(null, r._value, r);
        });
        for (var t = yl.slice(0), u = t.length; u; ) t[--u]();
      }
      function Zl(n) {
        return new ee(Ke, !1, n);
      }
      function Be(n, t) {
        var u = re;
        return function() {
          var r = al(), c = re;
          try {
            return Gn(u, !0), n.apply(this, arguments);
          } catch (m) {
            t && t(m);
          } finally {
            Gn(c, !1), r && rl();
          }
        };
      }
      P(ee.prototype, { then: Tt, _then: function(n, t) {
        Pt(this, new ji(null, null, n, t, re));
      }, catch: function(n) {
        if (arguments.length === 1) return this.then(null, n);
        var t = n, u = arguments[1];
        return typeof t == "function" ? this.then(null, function(r) {
          return (r instanceof t ? u : Zl)(r);
        }) : this.then(null, function(r) {
          return (r && r.name === t ? u : Zl)(r);
        });
      }, finally: function(n) {
        return this.then(function(t) {
          return ee.resolve(n()).then(function() {
            return t;
          });
        }, function(t) {
          return ee.resolve(n()).then(function() {
            return Zl(t);
          });
        });
      }, timeout: function(n, t) {
        var u = this;
        return n < 1 / 0 ? new ee(function(r, c) {
          var m = setTimeout(function() {
            return c(new B.Timeout(t));
          }, n);
          u.then(r, c).finally(clearTimeout.bind(null, m));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && R(ee.prototype, Symbol.toStringTag, "Dexie.Promise"), Rn.env = $i(), P(ee, { all: function() {
        var n = Ae.apply(null, arguments).map(zl);
        return new ee(function(t, u) {
          n.length === 0 && t([]);
          var r = n.length;
          n.forEach(function(c, m) {
            return ee.resolve(c).then(function(p) {
              n[m] = p, --r || t(n);
            }, u);
          });
        });
      }, resolve: function(n) {
        return n instanceof ee ? n : n && typeof n.then == "function" ? new ee(function(t, u) {
          n.then(t, u);
        }) : new ee(Ke, !0, n);
      }, reject: Zl, race: function() {
        var n = Ae.apply(null, arguments).map(zl);
        return new ee(function(t, u) {
          n.map(function(r) {
            return ee.resolve(r).then(t, u);
          });
        });
      }, PSD: { get: function() {
        return re;
      }, set: function(n) {
        return re = n;
      } }, totalEchoes: { get: function() {
        return Gl;
      } }, newPSD: Un, usePSD: Xn, scheduler: { get: function() {
        return on;
      }, set: function(n) {
        on = n;
      } }, rejectionMapper: { get: function() {
        return xl;
      }, set: function(n) {
        xl = n;
      } }, follow: function(n, t) {
        return new ee(function(u, r) {
          return Un(function(c, m) {
            var p = re;
            p.unhandleds = [], p.onunhandled = m, p.finalize = me(function() {
              var g, L = this;
              g = function() {
                L.unhandleds.length === 0 ? c() : m(L.unhandleds[0]);
              }, yl.push(function O() {
                g(), yl.splice(yl.indexOf(O), 1);
              }), ++Zn, on(function() {
                --Zn == 0 && Rt();
              }, []);
            }, p.finalize), n();
          }, t, u, r);
        });
      } }), Qe && (Qe.allSettled && R(ee, "allSettled", function() {
        var n = Ae.apply(null, arguments).map(zl);
        return new ee(function(t) {
          n.length === 0 && t([]);
          var u = n.length, r = new Array(u);
          n.forEach(function(c, m) {
            return ee.resolve(c).then(function(p) {
              return r[m] = { status: "fulfilled", value: p };
            }, function(p) {
              return r[m] = { status: "rejected", reason: p };
            }).then(function() {
              return --u || t(r);
            });
          });
        });
      }), Qe.any && typeof AggregateError < "u" && R(ee, "any", function() {
        var n = Ae.apply(null, arguments).map(zl);
        return new ee(function(t, u) {
          n.length === 0 && u(new AggregateError([]));
          var r = n.length, c = new Array(r);
          n.forEach(function(m, p) {
            return ee.resolve(m).then(function(g) {
              return t(g);
            }, function(g) {
              c[p] = g, --r || u(new AggregateError(c));
            });
          });
        });
      }), Qe.withResolvers && (ee.withResolvers = Qe.withResolvers));
      var Je = { awaits: 0, echoes: 0, id: 0 }, Qa = 0, Ul = [], Kl = 0, Gl = 0, Ja = 0;
      function Un(n, t, u, r) {
        var c = re, m = Object.create(c);
        return m.parent = c, m.ref = 0, m.global = !1, m.id = ++Ja, Rn.env, m.env = yn ? { Promise: ee, PromiseProp: { value: ee, configurable: !0, writable: !0 }, all: ee.all, race: ee.race, allSettled: ee.allSettled, any: ee.any, resolve: ee.resolve, reject: ee.reject } : {}, t && h(m, t), ++c.ref, m.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, r = Xn(m, n, u, r), m.ref === 0 && m.finalize(), r;
      }
      function sl() {
        return Je.id || (Je.id = ++Qa), ++Je.awaits, Je.echoes += ke, Je.id;
      }
      function Kn() {
        return !!Je.awaits && (--Je.awaits == 0 && (Je.id = 0), Je.echoes = Je.awaits * ke, !0);
      }
      function zl(n) {
        return Je.echoes && n && n.constructor === Qe ? (sl(), n.then(function(t) {
          return Kn(), t;
        }, function(t) {
          return Kn(), je(t);
        })) : n;
      }
      function er() {
        var n = Ul[Ul.length - 1];
        Ul.pop(), Gn(n, !1);
      }
      function Gn(n, t) {
        var u, r = re;
        (t ? !Je.echoes || Kl++ && n === re : !Kl || --Kl && n === re) || queueMicrotask(t ? (function(c) {
          ++Gl, Je.echoes && --Je.echoes != 0 || (Je.echoes = Je.awaits = Je.id = 0), Ul.push(re), Gn(c, !0);
        }).bind(null, n) : er), n !== re && (re = n, r === Rn && (Rn.env = $i()), yn && (u = Rn.env.Promise, t = n.env, (r.global || n.global) && (Object.defineProperty(o, "Promise", t.PromiseProp), u.all = t.all, u.race = t.race, u.resolve = t.resolve, u.reject = t.reject, t.allSettled && (u.allSettled = t.allSettled), t.any && (u.any = t.any))));
      }
      function $i() {
        var n = o.Promise;
        return yn ? { Promise: n, PromiseProp: Object.getOwnPropertyDescriptor(o, "Promise"), all: n.all, race: n.race, allSettled: n.allSettled, any: n.any, resolve: n.resolve, reject: n.reject } : {};
      }
      function Xn(n, t, u, r, c) {
        var m = re;
        try {
          return Gn(n, !0), t(u, r, c);
        } finally {
          Gn(m, !1);
        }
      }
      function Wi(n, t, u, r) {
        return typeof n != "function" ? n : function() {
          var c = re;
          u && sl(), Gn(t, !0);
          try {
            return n.apply(this, arguments);
          } finally {
            Gn(c, !1), r && queueMicrotask(Kn);
          }
        };
      }
      function At(n) {
        Promise === Qe && Je.echoes === 0 ? Kl === 0 ? n() : enqueueNativeMicroTask(n) : setTimeout(n, 0);
      }
      ("" + In).indexOf("[native code]") === -1 && (sl = Kn = De);
      var je = ee.reject, Qn = "", An = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Yi = "String expected.", cl = [], jl = "__dbnames", Et = "readonly", _t = "readwrite";
      function Jn(n, t) {
        return n ? t ? function() {
          return n.apply(this, arguments) && t.apply(this, arguments);
        } : n : t;
      }
      var Xi = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Hl(n) {
        return typeof n != "string" || /\./.test(n) ? function(t) {
          return t;
        } : function(t) {
          return t[n] === void 0 && n in t && delete (t = ye(t))[n], t;
        };
      }
      function Qi() {
        throw B.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Se(n, t) {
        try {
          var u = Ji(n), r = Ji(t);
          if (u !== r) return u === "Array" ? 1 : r === "Array" ? -1 : u === "binary" ? 1 : r === "binary" ? -1 : u === "string" ? 1 : r === "string" ? -1 : u === "Date" ? 1 : r !== "Date" ? NaN : -1;
          switch (u) {
            case "number":
            case "Date":
            case "string":
              return t < n ? 1 : n < t ? -1 : 0;
            case "binary":
              return function(c, m) {
                for (var p = c.length, g = m.length, L = p < g ? p : g, O = 0; O < L; ++O) if (c[O] !== m[O]) return c[O] < m[O] ? -1 : 1;
                return p === g ? 0 : p < g ? -1 : 1;
              }(eu(n), eu(t));
            case "Array":
              return function(c, m) {
                for (var p = c.length, g = m.length, L = p < g ? p : g, O = 0; O < L; ++O) {
                  var b = Se(c[O], m[O]);
                  if (b !== 0) return b;
                }
                return p === g ? 0 : p < g ? -1 : 1;
              }(n, t);
          }
        } catch {
        }
        return NaN;
      }
      function Ji(n) {
        var t = typeof n;
        return t != "object" ? t : ArrayBuffer.isView(n) ? "binary" : (n = Ce(n), n === "ArrayBuffer" ? "binary" : n);
      }
      function eu(n) {
        return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n);
      }
      function $l(n, t, u) {
        var r = n.schema.yProps;
        return r ? (t && 0 < u.numFailures && (t = t.filter(function(c, m) {
          return !u.failures[m];
        })), Promise.all(r.map(function(c) {
          return c = c.updatesTable, t ? n.db.table(c).where("k").anyOf(t).delete() : n.db.table(c).clear();
        })).then(function() {
          return u;
        })) : u;
      }
      var nu = (Ve.prototype._trans = function(n, t, u) {
        var r = this._tx || re.trans, c = this.name, m = Oe && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(n === "readonly" ? "read" : "write", " ").concat(this.name));
        function p(O, b, v) {
          if (!v.schema[c]) throw new B.NotFound("Table " + c + " not part of transaction");
          return t(v.idbtrans, v);
        }
        var g = al();
        try {
          var L = r && r.db._novip === this.db._novip ? r === re.trans ? r._promise(n, p, u) : Un(function() {
            return r._promise(n, p, u);
          }, { trans: r, transless: re.transless || re }) : function O(b, v, T, D) {
            if (b.idbdb && (b._state.openComplete || re.letThrough || b._vip)) {
              var w = b._createTransaction(v, T, b._dbSchema);
              try {
                w.create(), b._state.PR1398_maxLoop = 3;
              } catch (C) {
                return C.name === k.InvalidState && b.isOpen() && 0 < --b._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), b.close({ disableAutoOpen: !1 }), b.open().then(function() {
                  return O(b, v, T, D);
                })) : je(C);
              }
              return w._promise(v, function(C, S) {
                return Un(function() {
                  return re.trans = w, D(C, S, w);
                });
              }).then(function(C) {
                if (v === "readwrite") try {
                  w.idbtrans.commit();
                } catch {
                }
                return v === "readonly" ? C : w._completion.then(function() {
                  return C;
                });
              });
            }
            if (b._state.openComplete) return je(new B.DatabaseClosed(b._state.dbOpenError));
            if (!b._state.isBeingOpened) {
              if (!b._state.autoOpen) return je(new B.DatabaseClosed());
              b.open().catch(De);
            }
            return b._state.dbReadyPromise.then(function() {
              return O(b, v, T, D);
            });
          }(this.db, n, [this.name], p);
          return m && (L._consoleTask = m, L = L.catch(function(O) {
            return console.trace(O), je(O);
          })), L;
        } finally {
          g && rl();
        }
      }, Ve.prototype.get = function(n, t) {
        var u = this;
        return n && n.constructor === Object ? this.where(n).first(t) : n == null ? je(new B.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(r) {
          return u.core.get({ trans: r, key: n }).then(function(c) {
            return u.hook.reading.fire(c);
          });
        }).then(t);
      }, Ve.prototype.where = function(n) {
        if (typeof n == "string") return new this.db.WhereClause(this, n);
        if (d(n)) return new this.db.WhereClause(this, "[".concat(n.join("+"), "]"));
        var t = f(n);
        if (t.length === 1) return this.where(t[0]).equals(n[t[0]]);
        var u = this.schema.indexes.concat(this.schema.primKey).filter(function(g) {
          if (g.compound && t.every(function(O) {
            return 0 <= g.keyPath.indexOf(O);
          })) {
            for (var L = 0; L < t.length; ++L) if (t.indexOf(g.keyPath[L]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(g, L) {
          return g.keyPath.length - L.keyPath.length;
        })[0];
        if (u && this.db._maxKey !== Qn) {
          var m = u.keyPath.slice(0, t.length);
          return this.where(m).equals(m.map(function(L) {
            return n[L];
          }));
        }
        !u && Oe && console.warn("The query ".concat(JSON.stringify(n), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var r = this.schema.idxByName;
        function c(g, L) {
          return Se(g, L) === 0;
        }
        var p = t.reduce(function(v, L) {
          var O = v[0], b = v[1], v = r[L], T = n[L];
          return [O || v, O || !v ? Jn(b, v && v.multi ? function(D) {
            return D = se(D, L), d(D) && D.some(function(w) {
              return c(T, w);
            });
          } : function(D) {
            return c(T, se(D, L));
          }) : b];
        }, [null, null]), m = p[0], p = p[1];
        return m ? this.where(m.name).equals(n[m.keyPath]).filter(p) : u ? this.filter(p) : this.where(t).equals("");
      }, Ve.prototype.filter = function(n) {
        return this.toCollection().and(n);
      }, Ve.prototype.count = function(n) {
        return this.toCollection().count(n);
      }, Ve.prototype.offset = function(n) {
        return this.toCollection().offset(n);
      }, Ve.prototype.limit = function(n) {
        return this.toCollection().limit(n);
      }, Ve.prototype.each = function(n) {
        return this.toCollection().each(n);
      }, Ve.prototype.toArray = function(n) {
        return this.toCollection().toArray(n);
      }, Ve.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ve.prototype.orderBy = function(n) {
        return new this.db.Collection(new this.db.WhereClause(this, d(n) ? "[".concat(n.join("+"), "]") : n));
      }, Ve.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ve.prototype.mapToClass = function(n) {
        var t, u = this.db, r = this.name;
        function c() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = n).prototype instanceof Qi && (function(L, O) {
          if (typeof O != "function" && O !== null) throw new TypeError("Class extends value " + String(O) + " is not a constructor or null");
          function b() {
            this.constructor = L;
          }
          i(L, O), L.prototype = O === null ? Object.create(O) : (b.prototype = O.prototype, new b());
        }(c, t = n), Object.defineProperty(c.prototype, "db", { get: function() {
          return u;
        }, enumerable: !1, configurable: !0 }), c.prototype.table = function() {
          return r;
        }, n = c);
        for (var m = /* @__PURE__ */ new Set(), p = n.prototype; p; p = I(p)) Object.getOwnPropertyNames(p).forEach(function(L) {
          return m.add(L);
        });
        function g(L) {
          if (!L) return L;
          var O, b = Object.create(n.prototype);
          for (O in L) if (!m.has(O)) try {
            b[O] = L[O];
          } catch {
          }
          return b;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = g, this.hook("reading", g), n;
      }, Ve.prototype.defineClass = function() {
        return this.mapToClass(function(n) {
          h(this, n);
        });
      }, Ve.prototype.add = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, m = r.keyPath, p = n;
        return m && c && (p = Hl(m)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "add", keys: t != null ? [t] : null, values: [p] });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (m) try {
            te(n, m, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.update = function(n, t) {
        return typeof n != "object" || d(n) ? this.where(":id").equals(n).modify(t) : (n = se(n, this.schema.primKey.keyPath), n === void 0 ? je(new B.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(n).modify(t));
      }, Ve.prototype.put = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, m = r.keyPath, p = n;
        return m && c && (p = Hl(m)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "put", values: [p], keys: t != null ? [t] : null });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (m) try {
            te(n, m, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.delete = function(n) {
        var t = this;
        return this._trans("readwrite", function(u) {
          return t.core.mutate({ trans: u, type: "delete", keys: [n] }).then(function(r) {
            return $l(t, [n], r);
          }).then(function(r) {
            return r.numFailures ? ee.reject(r.failures[0]) : void 0;
          });
        });
      }, Ve.prototype.clear = function() {
        var n = this;
        return this._trans("readwrite", function(t) {
          return n.core.mutate({ trans: t, type: "deleteRange", range: Xi }).then(function(u) {
            return $l(n, null, u);
          });
        }).then(function(t) {
          return t.numFailures ? ee.reject(t.failures[0]) : void 0;
        });
      }, Ve.prototype.bulkGet = function(n) {
        var t = this;
        return this._trans("readonly", function(u) {
          return t.core.getMany({ keys: n, trans: u }).then(function(r) {
            return r.map(function(c) {
              return t.hook.reading.fire(c);
            });
          });
        });
      }, Ve.prototype.bulkAdd = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, m = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new B.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new B.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Hl(O)) : n;
          return r.core.mutate({ trans: p, type: "add", keys: c, values: O, wantResults: m }).then(function(w) {
            var v = w.numFailures, T = w.results, D = w.lastResult, w = w.failures;
            if (v === 0) return m ? T : D;
            throw new ln("".concat(r.name, ".bulkAdd(): ").concat(v, " of ").concat(L, " operations failed"), w);
          });
        });
      }, Ve.prototype.bulkPut = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, m = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new B.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new B.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Hl(O)) : n;
          return r.core.mutate({ trans: p, type: "put", keys: c, values: O, wantResults: m }).then(function(w) {
            var v = w.numFailures, T = w.results, D = w.lastResult, w = w.failures;
            if (v === 0) return m ? T : D;
            throw new ln("".concat(r.name, ".bulkPut(): ").concat(v, " of ").concat(L, " operations failed"), w);
          });
        });
      }, Ve.prototype.bulkUpdate = function(n) {
        var t = this, u = this.core, r = n.map(function(p) {
          return p.key;
        }), c = n.map(function(p) {
          return p.changes;
        }), m = [];
        return this._trans("readwrite", function(p) {
          return u.getMany({ trans: p, keys: r, cache: "clone" }).then(function(g) {
            var L = [], O = [];
            n.forEach(function(v, T) {
              var D = v.key, w = v.changes, C = g[T];
              if (C) {
                for (var S = 0, q = Object.keys(w); S < q.length; S++) {
                  var A = q[S], N = w[A];
                  if (A === t.schema.primKey.keyPath) {
                    if (Se(N, D) !== 0) throw new B.Constraint("Cannot update primary key in bulkUpdate()");
                  } else te(C, A, N);
                }
                m.push(T), L.push(D), O.push(C);
              }
            });
            var b = L.length;
            return u.mutate({ trans: p, type: "put", keys: L, values: O, updates: { keys: r, changeSpecs: c } }).then(function(v) {
              var T = v.numFailures, D = v.failures;
              if (T === 0) return b;
              for (var w = 0, C = Object.keys(D); w < C.length; w++) {
                var S, q = C[w], A = m[Number(q)];
                A != null && (S = D[q], delete D[q], D[A] = S);
              }
              throw new ln("".concat(t.name, ".bulkUpdate(): ").concat(T, " of ").concat(b, " operations failed"), D);
            });
          });
        });
      }, Ve.prototype.bulkDelete = function(n) {
        var t = this, u = n.length;
        return this._trans("readwrite", function(r) {
          return t.core.mutate({ trans: r, type: "delete", keys: n }).then(function(c) {
            return $l(t, n, c);
          });
        }).then(function(p) {
          var c = p.numFailures, m = p.lastResult, p = p.failures;
          if (c === 0) return m;
          throw new ln("".concat(t.name, ".bulkDelete(): ").concat(c, " of ").concat(u, " operations failed"), p);
        });
      }, Ve);
      function Ve() {
      }
      function Il(n) {
        function t(p, g) {
          if (g) {
            for (var L = arguments.length, O = new Array(L - 1); --L; ) O[L - 1] = arguments[L];
            return u[p].subscribe.apply(null, O), n;
          }
          if (typeof p == "string") return u[p];
        }
        var u = {};
        t.addEventType = m;
        for (var r = 1, c = arguments.length; r < c; ++r) m(arguments[r]);
        return t;
        function m(p, g, L) {
          if (typeof p != "object") {
            var O;
            g = g || Ne;
            var b = { subscribers: [], fire: L = L || De, subscribe: function(v) {
              b.subscribers.indexOf(v) === -1 && (b.subscribers.push(v), b.fire = g(b.fire, v));
            }, unsubscribe: function(v) {
              b.subscribers = b.subscribers.filter(function(T) {
                return T !== v;
              }), b.fire = b.subscribers.reduce(g, L);
            } };
            return u[p] = t[p] = b;
          }
          f(O = p).forEach(function(v) {
            var T = O[v];
            if (d(T)) m(v, O[v][0], O[v][1]);
            else {
              if (T !== "asap") throw new B.InvalidArgument("Invalid event config");
              var D = m(v, j, function() {
                for (var w = arguments.length, C = new Array(w); w--; ) C[w] = arguments[w];
                D.subscribers.forEach(function(S) {
                  Y(function() {
                    S.apply(null, C);
                  });
                });
              });
            }
          });
        }
      }
      function Ll(n, t) {
        return V(t).from({ prototype: n }), t;
      }
      function ol(n, t) {
        return !(n.filter || n.algorithm || n.or) && (t ? n.justLimit : !n.replayFilter);
      }
      function Nt(n, t) {
        n.filter = Jn(n.filter, t);
      }
      function Ft(n, t, u) {
        var r = n.replayFilter;
        n.replayFilter = r ? function() {
          return Jn(r(), t());
        } : t, n.justLimit = u && !r;
      }
      function Wl(n, t) {
        if (n.isPrimKey) return t.primaryKey;
        var u = t.getIndexByKeyPath(n.index);
        if (!u) throw new B.Schema("KeyPath " + n.index + " on object store " + t.name + " is not indexed");
        return u;
      }
      function lu(n, t, u) {
        var r = Wl(n, t.schema);
        return t.openCursor({ trans: u, values: !n.keysOnly, reverse: n.dir === "prev", unique: !!n.unique, query: { index: r, range: n.range } });
      }
      function Yl(n, t, u, r) {
        var c = n.replayFilter ? Jn(n.filter, n.replayFilter()) : n.filter;
        if (n.or) {
          var m = {}, p = function(g, L, O) {
            var b, v;
            c && !c(L, O, function(T) {
              return L.stop(T);
            }, function(T) {
              return L.fail(T);
            }) || ((v = "" + (b = L.primaryKey)) == "[object ArrayBuffer]" && (v = "" + new Uint8Array(b)), y(m, v) || (m[v] = !0, t(g, L, O)));
          };
          return Promise.all([n.or._iterate(p, u), tu(lu(n, r, u), n.algorithm, p, !n.keysOnly && n.valueMapper)]);
        }
        return tu(lu(n, r, u), Jn(n.algorithm, c), t, !n.keysOnly && n.valueMapper);
      }
      function tu(n, t, u, r) {
        var c = Be(r ? function(m, p, g) {
          return u(r(m), p, g);
        } : u);
        return n.then(function(m) {
          if (m) return m.start(function() {
            var p = function() {
              return m.continue();
            };
            t && !t(m, function(g) {
              return p = g;
            }, function(g) {
              m.stop(g), p = De;
            }, function(g) {
              m.fail(g), p = De;
            }) || c(m.value, m, function(g) {
              return p = g;
            }), p();
          });
        });
      }
      var Dl = (iu.prototype.execute = function(n) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var u = t.add;
          if (d(u)) return s(s([], d(n) ? n : [], !0), u).sort();
          if (typeof u == "number") return (Number(n) || 0) + u;
          if (typeof u == "bigint") try {
            return BigInt(n) + u;
          } catch {
            return BigInt(0) + u;
          }
          throw new TypeError("Invalid term ".concat(u));
        }
        if (t.remove !== void 0) {
          var r = t.remove;
          if (d(r)) return d(n) ? n.filter(function(c) {
            return !r.includes(c);
          }).sort() : [];
          if (typeof r == "number") return Number(n) - r;
          if (typeof r == "bigint") try {
            return BigInt(n) - r;
          } catch {
            return BigInt(0) - r;
          }
          throw new TypeError("Invalid subtrahend ".concat(r));
        }
        return u = (u = t.replacePrefix) === null || u === void 0 ? void 0 : u[0], u && typeof n == "string" && n.startsWith(u) ? t.replacePrefix[1] + n.substring(u.length) : n;
      }, iu);
      function iu(n) {
        this["@@propmod"] = n;
      }
      var nr = (Re.prototype._read = function(n, t) {
        var u = this._ctx;
        return u.error ? u.table._trans(null, je.bind(null, u.error)) : u.table._trans("readonly", n).then(t);
      }, Re.prototype._write = function(n) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, je.bind(null, t.error)) : t.table._trans("readwrite", n, "locked");
      }, Re.prototype._addAlgorithm = function(n) {
        var t = this._ctx;
        t.algorithm = Jn(t.algorithm, n);
      }, Re.prototype._iterate = function(n, t) {
        return Yl(this._ctx, n, t, this._ctx.table.core);
      }, Re.prototype.clone = function(n) {
        var t = Object.create(this.constructor.prototype), u = Object.create(this._ctx);
        return n && h(u, n), t._ctx = u, t;
      }, Re.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Re.prototype.each = function(n) {
        var t = this._ctx;
        return this._read(function(u) {
          return Yl(t, n, u, t.table.core);
        });
      }, Re.prototype.count = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx, c = r.table.core;
          if (ol(r, !0)) return c.count({ trans: u, query: { index: Wl(r, c.schema), range: r.range } }).then(function(p) {
            return Math.min(p, r.limit);
          });
          var m = 0;
          return Yl(r, function() {
            return ++m, !1;
          }, u, c).then(function() {
            return m;
          });
        }).then(n);
      }, Re.prototype.sortBy = function(n, t) {
        var u = n.split(".").reverse(), r = u[0], c = u.length - 1;
        function m(L, O) {
          return O ? m(L[u[O]], O - 1) : L[r];
        }
        var p = this._ctx.dir === "next" ? 1 : -1;
        function g(L, O) {
          return Se(m(L, c), m(O, c)) * p;
        }
        return this.toArray(function(L) {
          return L.sort(g);
        }).then(t);
      }, Re.prototype.toArray = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx;
          if (r.dir === "next" && ol(r, !0) && 0 < r.limit) {
            var c = r.valueMapper, m = Wl(r, r.table.core.schema);
            return r.table.core.query({ trans: u, limit: r.limit, values: !0, query: { index: m, range: r.range } }).then(function(g) {
              return g = g.result, c ? g.map(c) : g;
            });
          }
          var p = [];
          return Yl(r, function(g) {
            return p.push(g);
          }, u, r.table.core).then(function() {
            return p;
          });
        }, n);
      }, Re.prototype.offset = function(n) {
        var t = this._ctx;
        return n <= 0 || (t.offset += n, ol(t) ? Ft(t, function() {
          var u = n;
          return function(r, c) {
            return u === 0 || (u === 1 ? --u : c(function() {
              r.advance(u), u = 0;
            }), !1);
          };
        }) : Ft(t, function() {
          var u = n;
          return function() {
            return --u < 0;
          };
        })), this;
      }, Re.prototype.limit = function(n) {
        return this._ctx.limit = Math.min(this._ctx.limit, n), Ft(this._ctx, function() {
          var t = n;
          return function(u, r, c) {
            return --t <= 0 && r(c), 0 <= t;
          };
        }, !0), this;
      }, Re.prototype.until = function(n, t) {
        return Nt(this._ctx, function(u, r, c) {
          return !n(u.value) || (r(c), t);
        }), this;
      }, Re.prototype.first = function(n) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(n);
      }, Re.prototype.last = function(n) {
        return this.reverse().first(n);
      }, Re.prototype.filter = function(n) {
        var t;
        return Nt(this._ctx, function(u) {
          return n(u.value);
        }), (t = this._ctx).isMatch = Jn(t.isMatch, n), this;
      }, Re.prototype.and = function(n) {
        return this.filter(n);
      }, Re.prototype.or = function(n) {
        return new this.db.WhereClause(this._ctx.table, n, this);
      }, Re.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Re.prototype.desc = function() {
        return this.reverse();
      }, Re.prototype.eachKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.key, r);
        });
      }, Re.prototype.eachUniqueKey = function(n) {
        return this._ctx.unique = "unique", this.eachKey(n);
      }, Re.prototype.eachPrimaryKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.primaryKey, r);
        });
      }, Re.prototype.keys = function(n) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.key);
        }).then(function() {
          return u;
        }).then(n);
      }, Re.prototype.primaryKeys = function(n) {
        var t = this._ctx;
        if (t.dir === "next" && ol(t, !0) && 0 < t.limit) return this._read(function(r) {
          var c = Wl(t, t.table.core.schema);
          return t.table.core.query({ trans: r, values: !1, limit: t.limit, query: { index: c, range: t.range } });
        }).then(function(r) {
          return r.result;
        }).then(n);
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.primaryKey);
        }).then(function() {
          return u;
        }).then(n);
      }, Re.prototype.uniqueKeys = function(n) {
        return this._ctx.unique = "unique", this.keys(n);
      }, Re.prototype.firstKey = function(n) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(n);
      }, Re.prototype.lastKey = function(n) {
        return this.reverse().firstKey(n);
      }, Re.prototype.distinct = function() {
        var n = this._ctx, n = n.index && n.table.schema.idxByName[n.index];
        if (!n || !n.multi) return this;
        var t = {};
        return Nt(this._ctx, function(c) {
          var r = c.primaryKey.toString(), c = y(t, r);
          return t[r] = !0, !c;
        }), this;
      }, Re.prototype.modify = function(n) {
        var t = this, u = this._ctx;
        return this._write(function(r) {
          var c, m, p;
          p = typeof n == "function" ? n : (c = f(n), m = c.length, function(q) {
            for (var A = !1, N = 0; N < m; ++N) {
              var F = c[N], U = n[F], W = se(q, F);
              U instanceof Dl ? (te(q, F, U.execute(W)), A = !0) : W !== U && (te(q, F, U), A = !0);
            }
            return A;
          });
          var g = u.table.core, v = g.schema.primaryKey, L = v.outbound, O = v.extractKey, b = 200, v = t.db._options.modifyChunkSize;
          v && (b = typeof v == "object" ? v[g.name] || v["*"] || 200 : v);
          function T(q, F) {
            var N = F.failures, F = F.numFailures;
            w += q - F;
            for (var U = 0, W = f(N); U < W.length; U++) {
              var z = W[U];
              D.push(N[z]);
            }
          }
          var D = [], w = 0, C = [], S = n === uu;
          return t.clone().primaryKeys().then(function(q) {
            function A(F) {
              var U = Math.min(b, q.length - F), W = q.slice(F, F + U);
              return (S ? Promise.resolve([]) : g.getMany({ trans: r, keys: W, cache: "immutable" })).then(function(z) {
                var H = [], J = [], X = L ? [] : null, ne = S ? W : [];
                if (!S) for (var ve = 0; ve < U; ++ve) {
                  var Pe = z[ve], ge = { value: ye(Pe), primKey: q[F + ve] };
                  p.call(ge, ge.value, ge) !== !1 && (ge.value == null ? ne.push(q[F + ve]) : L || Se(O(Pe), O(ge.value)) === 0 ? (J.push(ge.value), L && X.push(q[F + ve])) : (ne.push(q[F + ve]), H.push(ge.value)));
                }
                return Promise.resolve(0 < H.length && g.mutate({ trans: r, type: "add", values: H }).then(function(Ge) {
                  for (var pe in Ge.failures) ne.splice(parseInt(pe), 1);
                  T(H.length, Ge);
                })).then(function() {
                  return (0 < J.length || N && typeof n == "object") && g.mutate({ trans: r, type: "put", keys: X, values: J, criteria: N, changeSpec: typeof n != "function" && n, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return T(J.length, Ge);
                  });
                }).then(function() {
                  return (0 < ne.length || N && S) && g.mutate({ trans: r, type: "delete", keys: ne, criteria: N, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return $l(u.table, ne, Ge);
                  }).then(function(Ge) {
                    return T(ne.length, Ge);
                  });
                }).then(function() {
                  return q.length > F + U && A(F + b);
                });
              });
            }
            var N = ol(u) && u.limit === 1 / 0 && (typeof n != "function" || S) && { index: u.index, range: u.range };
            return A(0).then(function() {
              if (0 < D.length) throw new xn("Error modifying one or more objects", D, w, C);
              return q.length;
            });
          });
        });
      }, Re.prototype.delete = function() {
        var n = this._ctx, t = n.range;
        return !ol(n) || n.table.schema.yProps || !n.isPrimKey && t.type !== 3 ? this.modify(uu) : this._write(function(u) {
          var r = n.table.core.schema.primaryKey, c = t;
          return n.table.core.count({ trans: u, query: { index: r, range: c } }).then(function(m) {
            return n.table.core.mutate({ trans: u, type: "deleteRange", range: c }).then(function(L) {
              var g = L.failures, L = L.numFailures;
              if (L) throw new xn("Could not delete some values", Object.keys(g).map(function(O) {
                return g[O];
              }), m - L);
              return m - L;
            });
          });
        });
      }, Re);
      function Re() {
      }
      var uu = function(n, t) {
        return t.value = null;
      };
      function lr(n, t) {
        return n < t ? -1 : n === t ? 0 : 1;
      }
      function tr(n, t) {
        return t < n ? -1 : n === t ? 0 : 1;
      }
      function dn(n, t, u) {
        return n = n instanceof ru ? new n.Collection(n) : n, n._ctx.error = new (u || TypeError)(t), n;
      }
      function ml(n) {
        return new n.Collection(n, function() {
          return au("");
        }).limit(0);
      }
      function Xl(n, t, u, r) {
        var c, m, p, g, L, O, b, v = u.length;
        if (!u.every(function(w) {
          return typeof w == "string";
        })) return dn(n, Yi);
        function T(w) {
          c = w === "next" ? function(S) {
            return S.toUpperCase();
          } : function(S) {
            return S.toLowerCase();
          }, m = w === "next" ? function(S) {
            return S.toLowerCase();
          } : function(S) {
            return S.toUpperCase();
          }, p = w === "next" ? lr : tr;
          var C = u.map(function(S) {
            return { lower: m(S), upper: c(S) };
          }).sort(function(S, q) {
            return p(S.lower, q.lower);
          });
          g = C.map(function(S) {
            return S.upper;
          }), L = C.map(function(S) {
            return S.lower;
          }), b = (O = w) === "next" ? "" : r;
        }
        T("next"), n = new n.Collection(n, function() {
          return zn(g[0], L[v - 1] + r);
        }), n._ondirectionchange = function(w) {
          T(w);
        };
        var D = 0;
        return n._addAlgorithm(function(w, C, S) {
          var q = w.key;
          if (typeof q != "string") return !1;
          var A = m(q);
          if (t(A, L, D)) return !0;
          for (var N = null, F = D; F < v; ++F) {
            var U = function(W, z, H, J, X, ne) {
              for (var ve = Math.min(W.length, J.length), Pe = -1, ge = 0; ge < ve; ++ge) {
                var Ge = z[ge];
                if (Ge !== J[ge]) return X(W[ge], H[ge]) < 0 ? W.substr(0, ge) + H[ge] + H.substr(ge + 1) : X(W[ge], J[ge]) < 0 ? W.substr(0, ge) + J[ge] + H.substr(ge + 1) : 0 <= Pe ? W.substr(0, Pe) + z[Pe] + H.substr(Pe + 1) : null;
                X(W[ge], Ge) < 0 && (Pe = ge);
              }
              return ve < J.length && ne === "next" ? W + H.substr(W.length) : ve < W.length && ne === "prev" ? W.substr(0, H.length) : Pe < 0 ? null : W.substr(0, Pe) + J[Pe] + H.substr(Pe + 1);
            }(q, A, g[F], L[F], p, O);
            U === null && N === null ? D = F + 1 : (N === null || 0 < p(N, U)) && (N = U);
          }
          return C(N !== null ? function() {
            w.continue(N + b);
          } : S), !1;
        }), n;
      }
      function zn(n, t, u, r) {
        return { type: 2, lower: n, upper: t, lowerOpen: u, upperOpen: r };
      }
      function au(n) {
        return { type: 1, lower: n, upper: n };
      }
      var ru = (Object.defineProperty(en.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), en.prototype.between = function(n, t, u, r) {
        u = u !== !1, r = r === !0;
        try {
          return 0 < this._cmp(n, t) || this._cmp(n, t) === 0 && (u || r) && (!u || !r) ? ml(this) : new this.Collection(this, function() {
            return zn(n, t, !u, !r);
          });
        } catch {
          return dn(this, An);
        }
      }, en.prototype.equals = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return au(n);
        });
      }, en.prototype.above = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return zn(n, void 0, !0);
        });
      }, en.prototype.aboveOrEqual = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return zn(n, void 0, !1);
        });
      }, en.prototype.below = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return zn(void 0, n, !1, !0);
        });
      }, en.prototype.belowOrEqual = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return zn(void 0, n);
        });
      }, en.prototype.startsWith = function(n) {
        return typeof n != "string" ? dn(this, Yi) : this.between(n, n + Qn, !0, !0);
      }, en.prototype.startsWithIgnoreCase = function(n) {
        return n === "" ? this.startsWith(n) : Xl(this, function(t, u) {
          return t.indexOf(u[0]) === 0;
        }, [n], Qn);
      }, en.prototype.equalsIgnoreCase = function(n) {
        return Xl(this, function(t, u) {
          return t === u[0];
        }, [n], "");
      }, en.prototype.anyOfIgnoreCase = function() {
        var n = Ae.apply(we, arguments);
        return n.length === 0 ? ml(this) : Xl(this, function(t, u) {
          return u.indexOf(t) !== -1;
        }, n, "");
      }, en.prototype.startsWithAnyOfIgnoreCase = function() {
        var n = Ae.apply(we, arguments);
        return n.length === 0 ? ml(this) : Xl(this, function(t, u) {
          return u.some(function(r) {
            return t.indexOf(r) === 0;
          });
        }, n, Qn);
      }, en.prototype.anyOf = function() {
        var n = this, t = Ae.apply(we, arguments), u = this._cmp;
        try {
          t.sort(u);
        } catch {
          return dn(this, An);
        }
        if (t.length === 0) return ml(this);
        var r = new this.Collection(this, function() {
          return zn(t[0], t[t.length - 1]);
        });
        r._ondirectionchange = function(m) {
          u = m === "next" ? n._ascending : n._descending, t.sort(u);
        };
        var c = 0;
        return r._addAlgorithm(function(m, p, g) {
          for (var L = m.key; 0 < u(L, t[c]); ) if (++c === t.length) return p(g), !1;
          return u(L, t[c]) === 0 || (p(function() {
            m.continue(t[c]);
          }), !1);
        }), r;
      }, en.prototype.notEqual = function(n) {
        return this.inAnyRange([[-1 / 0, n], [n, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, en.prototype.noneOf = function() {
        var n = Ae.apply(we, arguments);
        if (n.length === 0) return new this.Collection(this);
        try {
          n.sort(this._ascending);
        } catch {
          return dn(this, An);
        }
        var t = n.reduce(function(u, r) {
          return u ? u.concat([[u[u.length - 1][1], r]]) : [[-1 / 0, r]];
        }, null);
        return t.push([n[n.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, en.prototype.inAnyRange = function(q, t) {
        var u = this, r = this._cmp, c = this._ascending, m = this._descending, p = this._min, g = this._max;
        if (q.length === 0) return ml(this);
        if (!q.every(function(A) {
          return A[0] !== void 0 && A[1] !== void 0 && c(A[0], A[1]) <= 0;
        })) return dn(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", B.InvalidArgument);
        var L = !t || t.includeLowers !== !1, O = t && t.includeUppers === !0, b, v = c;
        function T(A, N) {
          return v(A[0], N[0]);
        }
        try {
          (b = q.reduce(function(A, N) {
            for (var F = 0, U = A.length; F < U; ++F) {
              var W = A[F];
              if (r(N[0], W[1]) < 0 && 0 < r(N[1], W[0])) {
                W[0] = p(W[0], N[0]), W[1] = g(W[1], N[1]);
                break;
              }
            }
            return F === U && A.push(N), A;
          }, [])).sort(T);
        } catch {
          return dn(this, An);
        }
        var D = 0, w = O ? function(A) {
          return 0 < c(A, b[D][1]);
        } : function(A) {
          return 0 <= c(A, b[D][1]);
        }, C = L ? function(A) {
          return 0 < m(A, b[D][0]);
        } : function(A) {
          return 0 <= m(A, b[D][0]);
        }, S = w, q = new this.Collection(this, function() {
          return zn(b[0][0], b[b.length - 1][1], !L, !O);
        });
        return q._ondirectionchange = function(A) {
          v = A === "next" ? (S = w, c) : (S = C, m), b.sort(T);
        }, q._addAlgorithm(function(A, N, F) {
          for (var U, W = A.key; S(W); ) if (++D === b.length) return N(F), !1;
          return !w(U = W) && !C(U) || (u._cmp(W, b[D][1]) === 0 || u._cmp(W, b[D][0]) === 0 || N(function() {
            v === c ? A.continue(b[D][0]) : A.continue(b[D][1]);
          }), !1);
        }), q;
      }, en.prototype.startsWithAnyOf = function() {
        var n = Ae.apply(we, arguments);
        return n.every(function(t) {
          return typeof t == "string";
        }) ? n.length === 0 ? ml(this) : this.inAnyRange(n.map(function(t) {
          return [t, t + Qn];
        })) : dn(this, "startsWithAnyOf() only works with strings");
      }, en);
      function en() {
      }
      function wn(n) {
        return Be(function(t) {
          return Ol(t), n(t.target.error), !1;
        });
      }
      function Ol(n) {
        n.stopPropagation && n.stopPropagation(), n.preventDefault && n.preventDefault();
      }
      var wl = "storagemutated", Mt = "x-storagemutated-1", jn = Il(null, wl), ir = (bn.prototype._lock = function() {
        return G(!re.global), ++this._reculock, this._reculock !== 1 || re.global || (re.lockOwnerFor = this), this;
      }, bn.prototype._unlock = function() {
        if (G(!re.global), --this._reculock == 0) for (re.global || (re.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var n = this._blockedFuncs.shift();
          try {
            Xn(n[1], n[0]);
          } catch {
          }
        }
        return this;
      }, bn.prototype._locked = function() {
        return this._reculock && re.lockOwnerFor !== this;
      }, bn.prototype.create = function(n) {
        var t = this;
        if (!this.mode) return this;
        var u = this.db.idbdb, r = this.db._state.dbOpenError;
        if (G(!this.idbtrans), !n && !u) switch (r && r.name) {
          case "DatabaseClosedError":
            throw new B.DatabaseClosed(r);
          case "MissingAPIError":
            throw new B.MissingAPI(r.message, r);
          default:
            throw new B.OpenFailed(r);
        }
        if (!this.active) throw new B.TransactionInactive();
        return G(this._completion._state === null), (n = this.idbtrans = n || (this.db.core || u).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Be(function(c) {
          Ol(c), t._reject(n.error);
        }), n.onabort = Be(function(c) {
          Ol(c), t.active && t._reject(new B.Abort(n.error)), t.active = !1, t.on("abort").fire(c);
        }), n.oncomplete = Be(function() {
          t.active = !1, t._resolve(), "mutatedParts" in n && jn.storagemutated.fire(n.mutatedParts);
        }), this;
      }, bn.prototype._promise = function(n, t, u) {
        var r = this;
        if (n === "readwrite" && this.mode !== "readwrite") return je(new B.ReadOnly("Transaction is readonly"));
        if (!this.active) return je(new B.TransactionInactive());
        if (this._locked()) return new ee(function(m, p) {
          r._blockedFuncs.push([function() {
            r._promise(n, t, u).then(m, p);
          }, re]);
        });
        if (u) return Un(function() {
          var m = new ee(function(p, g) {
            r._lock();
            var L = t(p, g, r);
            L && L.then && L.then(p, g);
          });
          return m.finally(function() {
            return r._unlock();
          }), m._lib = !0, m;
        });
        var c = new ee(function(m, p) {
          var g = t(m, p, r);
          g && g.then && g.then(m, p);
        });
        return c._lib = !0, c;
      }, bn.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, bn.prototype.waitFor = function(n) {
        var t, u = this._root(), r = ee.resolve(n);
        u._waitingFor ? u._waitingFor = u._waitingFor.then(function() {
          return r;
        }) : (u._waitingFor = r, u._waitingQueue = [], t = u.idbtrans.objectStore(u.storeNames[0]), function m() {
          for (++u._spinCount; u._waitingQueue.length; ) u._waitingQueue.shift()();
          u._waitingFor && (t.get(-1 / 0).onsuccess = m);
        }());
        var c = u._waitingFor;
        return new ee(function(m, p) {
          r.then(function(g) {
            return u._waitingQueue.push(Be(m.bind(null, g)));
          }, function(g) {
            return u._waitingQueue.push(Be(p.bind(null, g)));
          }).finally(function() {
            u._waitingFor === c && (u._waitingFor = null);
          });
        });
      }, bn.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new B.Abort()));
      }, bn.prototype.table = function(n) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (y(t, n)) return t[n];
        var u = this.schema[n];
        if (!u) throw new B.NotFound("Table " + n + " not part of transaction");
        return u = new this.db.Table(n, u, this), u.core = this.db.core.table(n), t[n] = u;
      }, bn);
      function bn() {
      }
      function kt(n, t, u, r, c, m, p, g) {
        return { name: n, keyPath: t, unique: u, multi: r, auto: c, compound: m, src: (u && !p ? "&" : "") + (r ? "*" : "") + (c ? "++" : "") + su(t), type: g };
      }
      function su(n) {
        return typeof n == "string" ? n : n ? "[" + [].join.call(n, "+") + "]" : "";
      }
      function Vt(n, t, u) {
        return { name: n, primKey: t, indexes: u, mappedClass: null, idxByName: (r = function(c) {
          return [c.name, c];
        }, u.reduce(function(c, m, p) {
          return p = r(m, p), p && (c[p[0]] = p[1]), c;
        }, {})) };
        var r;
      }
      var bl = function(n) {
        try {
          return n.only([[]]), bl = function() {
            return [[]];
          }, [[]];
        } catch {
          return bl = function() {
            return Qn;
          }, Qn;
        }
      };
      function Bt(n) {
        return n == null ? function() {
        } : typeof n == "string" ? (t = n).split(".").length === 1 ? function(u) {
          return u[t];
        } : function(u) {
          return se(u, t);
        } : function(u) {
          return se(u, n);
        };
        var t;
      }
      function cu(n) {
        return [].slice.call(n);
      }
      var ur = 0;
      function Sl(n) {
        return n == null ? ":id" : typeof n == "string" ? n : "[".concat(n.join("+"), "]");
      }
      function ar(n, t, L) {
        function r(S) {
          if (S.type === 3) return null;
          if (S.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var D = S.lower, w = S.upper, C = S.lowerOpen, S = S.upperOpen;
          return D === void 0 ? w === void 0 ? null : t.upperBound(w, !!S) : w === void 0 ? t.lowerBound(D, !!C) : t.bound(D, w, !!C, !!S);
        }
        function c(T) {
          var D, w = T.name;
          return { name: w, schema: T, mutate: function(C) {
            var S = C.trans, q = C.type, A = C.keys, N = C.values, F = C.range;
            return new Promise(function(U, W) {
              U = Be(U);
              var z = S.objectStore(w), H = z.keyPath == null, J = q === "put" || q === "add";
              if (!J && q !== "delete" && q !== "deleteRange") throw new Error("Invalid operation type: " + q);
              var X, ne = (A || N || { length: 1 }).length;
              if (A && N && A.length !== N.length) throw new Error("Given keys array must have same length as given values array.");
              if (ne === 0) return U({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ve(mn) {
                ++Ge, Ol(mn);
              }
              var Pe = [], ge = [], Ge = 0;
              if (q === "deleteRange") {
                if (F.type === 4) return U({ numFailures: Ge, failures: ge, results: [], lastResult: void 0 });
                F.type === 3 ? Pe.push(X = z.clear()) : Pe.push(X = z.delete(r(F)));
              } else {
                var H = J ? H ? [N, A] : [N, null] : [A, null], pe = H[0], an = H[1];
                if (J) for (var rn = 0; rn < ne; ++rn) Pe.push(X = an && an[rn] !== void 0 ? z[q](pe[rn], an[rn]) : z[q](pe[rn])), X.onerror = ve;
                else for (rn = 0; rn < ne; ++rn) Pe.push(X = z[q](pe[rn])), X.onerror = ve;
              }
              function ct(mn) {
                mn = mn.target.result, Pe.forEach(function(ll, ii) {
                  return ll.error != null && (ge[ii] = ll.error);
                }), U({ numFailures: Ge, failures: ge, results: q === "delete" ? A : Pe.map(function(ll) {
                  return ll.result;
                }), lastResult: mn });
              }
              X.onerror = function(mn) {
                ve(mn), ct(mn);
              }, X.onsuccess = ct;
            });
          }, getMany: function(C) {
            var S = C.trans, q = C.keys;
            return new Promise(function(A, N) {
              A = Be(A);
              for (var F, U = S.objectStore(w), W = q.length, z = new Array(W), H = 0, J = 0, X = function(Pe) {
                Pe = Pe.target, z[Pe._pos] = Pe.result, ++J === H && A(z);
              }, ne = wn(N), ve = 0; ve < W; ++ve) q[ve] != null && ((F = U.get(q[ve]))._pos = ve, F.onsuccess = X, F.onerror = ne, ++H);
              H === 0 && A(z);
            });
          }, get: function(C) {
            var S = C.trans, q = C.key;
            return new Promise(function(A, N) {
              A = Be(A);
              var F = S.objectStore(w).get(q);
              F.onsuccess = function(U) {
                return A(U.target.result);
              }, F.onerror = wn(N);
            });
          }, query: (D = O, function(C) {
            return new Promise(function(S, q) {
              S = Be(S);
              var A, N, F, H = C.trans, U = C.values, W = C.limit, X = C.query, z = W === 1 / 0 ? void 0 : W, J = X.index, X = X.range, H = H.objectStore(w), J = J.isPrimaryKey ? H : H.index(J.name), X = r(X);
              if (W === 0) return S({ result: [] });
              D ? ((z = U ? J.getAll(X, z) : J.getAllKeys(X, z)).onsuccess = function(ne) {
                return S({ result: ne.target.result });
              }, z.onerror = wn(q)) : (A = 0, N = !U && "openKeyCursor" in J ? J.openKeyCursor(X) : J.openCursor(X), F = [], N.onsuccess = function(ne) {
                var ve = N.result;
                return ve ? (F.push(U ? ve.value : ve.primaryKey), ++A === W ? S({ result: F }) : void ve.continue()) : S({ result: F });
              }, N.onerror = wn(q));
            });
          }), openCursor: function(C) {
            var S = C.trans, q = C.values, A = C.query, N = C.reverse, F = C.unique;
            return new Promise(function(U, W) {
              U = Be(U);
              var J = A.index, z = A.range, H = S.objectStore(w), H = J.isPrimaryKey ? H : H.index(J.name), J = N ? F ? "prevunique" : "prev" : F ? "nextunique" : "next", X = !q && "openKeyCursor" in H ? H.openKeyCursor(r(z), J) : H.openCursor(r(z), J);
              X.onerror = wn(W), X.onsuccess = Be(function(ne) {
                var ve, Pe, ge, Ge, pe = X.result;
                pe ? (pe.___id = ++ur, pe.done = !1, ve = pe.continue.bind(pe), Pe = (Pe = pe.continuePrimaryKey) && Pe.bind(pe), ge = pe.advance.bind(pe), Ge = function() {
                  throw new Error("Cursor not stopped");
                }, pe.trans = S, pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = function() {
                  throw new Error("Cursor not started");
                }, pe.fail = Be(W), pe.next = function() {
                  var an = this, rn = 1;
                  return this.start(function() {
                    return rn-- ? an.continue() : an.stop();
                  }).then(function() {
                    return an;
                  });
                }, pe.start = function(an) {
                  function rn() {
                    if (X.result) try {
                      an();
                    } catch (mn) {
                      pe.fail(mn);
                    }
                    else pe.done = !0, pe.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, pe.stop();
                  }
                  var ct = new Promise(function(mn, ll) {
                    mn = Be(mn), X.onerror = wn(ll), pe.fail = ll, pe.stop = function(ii) {
                      pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = Ge, mn(ii);
                    };
                  });
                  return X.onsuccess = Be(function(mn) {
                    X.onsuccess = rn, rn();
                  }), pe.continue = ve, pe.continuePrimaryKey = Pe, pe.advance = ge, rn(), ct;
                }, U(pe)) : U(null);
              }, W);
            });
          }, count: function(C) {
            var S = C.query, q = C.trans, A = S.index, N = S.range;
            return new Promise(function(F, U) {
              var W = q.objectStore(w), z = A.isPrimaryKey ? W : W.index(A.name), W = r(N), z = W ? z.count(W) : z.count();
              z.onsuccess = Be(function(H) {
                return F(H.target.result);
              }), z.onerror = wn(U);
            });
          } };
        }
        var m, p, g, b = (p = L, g = cu((m = n).objectStoreNames), { schema: { name: m.name, tables: g.map(function(T) {
          return p.objectStore(T);
        }).map(function(T) {
          var D = T.keyPath, S = T.autoIncrement, w = d(D), C = {}, S = { name: T.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: D == null, compound: w, keyPath: D, autoIncrement: S, unique: !0, extractKey: Bt(D) }, indexes: cu(T.indexNames).map(function(q) {
            return T.index(q);
          }).map(function(F) {
            var A = F.name, N = F.unique, U = F.multiEntry, F = F.keyPath, U = { name: A, compound: d(F), keyPath: F, unique: N, multiEntry: U, extractKey: Bt(F) };
            return C[Sl(F)] = U;
          }), getIndexByKeyPath: function(q) {
            return C[Sl(q)];
          } };
          return C[":id"] = S.primaryKey, D != null && (C[Sl(D)] = S.primaryKey), S;
        }) }, hasGetAll: 0 < g.length && "getAll" in p.objectStore(g[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), L = b.schema, O = b.hasGetAll, b = L.tables.map(c), v = {};
        return b.forEach(function(T) {
          return v[T.name] = T;
        }), { stack: "dbcore", transaction: n.transaction.bind(n), table: function(T) {
          if (!v[T]) throw new Error("Table '".concat(T, "' not found"));
          return v[T];
        }, MIN_KEY: -1 / 0, MAX_KEY: bl(t), schema: L };
      }
      function rr(n, t, u, r) {
        var c = u.IDBKeyRange;
        return u.indexedDB, { dbcore: (r = ar(t, c, r), n.dbcore.reduce(function(m, p) {
          return p = p.create, a(a({}, m), p(m));
        }, r)) };
      }
      function Ql(n, r) {
        var u = r.db, r = rr(n._middlewares, u, n._deps, r);
        n.core = r.dbcore, n.tables.forEach(function(c) {
          var m = c.name;
          n.core.schema.tables.some(function(p) {
            return p.name === m;
          }) && (c.core = n.core.table(m), n[m] instanceof n.Table && (n[m].core = c.core));
        });
      }
      function Jl(n, t, u, r) {
        u.forEach(function(c) {
          var m = r[c];
          t.forEach(function(p) {
            var g = function L(O, b) {
              return K(O, b) || (O = I(O)) && L(O, b);
            }(p, c);
            (!g || "value" in g && g.value === void 0) && (p === n.Transaction.prototype || p instanceof n.Transaction ? R(p, c, { get: function() {
              return this.table(c);
            }, set: function(L) {
              E(this, c, { value: L, writable: !0, configurable: !0, enumerable: !0 });
            } }) : p[c] = new n.Table(c, m));
          });
        });
      }
      function Zt(n, t) {
        t.forEach(function(u) {
          for (var r in u) u[r] instanceof n.Table && delete u[r];
        });
      }
      function sr(n, t) {
        return n._cfg.version - t._cfg.version;
      }
      function cr(n, t, u, r) {
        var c = n._dbSchema;
        u.objectStoreNames.contains("$meta") && !c.$meta && (c.$meta = Vt("$meta", mu("")[0], []), n._storeNames.push("$meta"));
        var m = n._createTransaction("readwrite", n._storeNames, c);
        m.create(u), m._completion.catch(r);
        var p = m._reject.bind(m), g = re.transless || re;
        Un(function() {
          return re.trans = m, re.transless = g, t !== 0 ? (Ql(n, u), O = t, ((L = m).storeNames.includes("$meta") ? L.table("$meta").get("version").then(function(b) {
            return b ?? O;
          }) : ee.resolve(O)).then(function(b) {
            return T = b, D = m, w = u, C = [], b = (v = n)._versions, S = v._dbSchema = nt(0, v.idbdb, w), (b = b.filter(function(q) {
              return q._cfg.version >= T;
            })).length !== 0 ? (b.forEach(function(q) {
              C.push(function() {
                var A = S, N = q._cfg.dbschema;
                lt(v, A, w), lt(v, N, w), S = v._dbSchema = N;
                var F = Ut(A, N);
                F.add.forEach(function(J) {
                  Kt(w, J[0], J[1].primKey, J[1].indexes);
                }), F.change.forEach(function(J) {
                  if (J.recreate) throw new B.Upgrade("Not yet support for changing primary key");
                  var X = w.objectStore(J.name);
                  J.add.forEach(function(ne) {
                    return et(X, ne);
                  }), J.change.forEach(function(ne) {
                    X.deleteIndex(ne.name), et(X, ne);
                  }), J.del.forEach(function(ne) {
                    return X.deleteIndex(ne);
                  });
                });
                var U = q._cfg.contentUpgrade;
                if (U && q._cfg.version > T) {
                  Ql(v, w), D._memoizedTables = {};
                  var W = fe(N);
                  F.del.forEach(function(J) {
                    W[J] = A[J];
                  }), Zt(v, [v.Transaction.prototype]), Jl(v, [v.Transaction.prototype], f(W), W), D.schema = W;
                  var z, H = $e(U);
                  return H && sl(), F = ee.follow(function() {
                    var J;
                    (z = U(D)) && H && (J = Kn.bind(null, null), z.then(J, J));
                  }), z && typeof z.then == "function" ? ee.resolve(z) : F.then(function() {
                    return z;
                  });
                }
              }), C.push(function(A) {
                var N, F, U = q._cfg.dbschema;
                N = U, F = A, [].slice.call(F.db.objectStoreNames).forEach(function(W) {
                  return N[W] == null && F.db.deleteObjectStore(W);
                }), Zt(v, [v.Transaction.prototype]), Jl(v, [v.Transaction.prototype], v._storeNames, v._dbSchema), D.schema = v._dbSchema;
              }), C.push(function(A) {
                v.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(v.idbdb.version / 10) === q._cfg.version ? (v.idbdb.deleteObjectStore("$meta"), delete v._dbSchema.$meta, v._storeNames = v._storeNames.filter(function(N) {
                  return N !== "$meta";
                })) : A.objectStore("$meta").put(q._cfg.version, "version"));
              });
            }), function q() {
              return C.length ? ee.resolve(C.shift()(D.idbtrans)).then(q) : ee.resolve();
            }().then(function() {
              ou(S, w);
            })) : ee.resolve();
            var v, T, D, w, C, S;
          }).catch(p)) : (f(c).forEach(function(b) {
            Kt(u, b, c[b].primKey, c[b].indexes);
          }), Ql(n, u), void ee.follow(function() {
            return n.on.populate.fire(m);
          }).catch(p));
          var L, O;
        });
      }
      function or(n, t) {
        ou(n._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var u = nt(0, n.idbdb, t);
        lt(n, n._dbSchema, t);
        for (var r = 0, c = Ut(u, n._dbSchema).change; r < c.length; r++) {
          var m = function(p) {
            if (p.change.length || p.recreate) return console.warn("Unable to patch indexes of table ".concat(p.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var g = t.objectStore(p.name);
            p.add.forEach(function(L) {
              Oe && console.debug("Dexie upgrade patch: Creating missing index ".concat(p.name, ".").concat(L.src)), et(g, L);
            });
          }(c[r]);
          if (typeof m == "object") return m.value;
        }
      }
      function Ut(n, t) {
        var u, r = { del: [], add: [], change: [] };
        for (u in n) t[u] || r.del.push(u);
        for (u in t) {
          var c = n[u], m = t[u];
          if (c) {
            var p = { name: u, def: m, recreate: !1, del: [], add: [], change: [] };
            if ("" + (c.primKey.keyPath || "") != "" + (m.primKey.keyPath || "") || c.primKey.auto !== m.primKey.auto) p.recreate = !0, r.change.push(p);
            else {
              var g = c.idxByName, L = m.idxByName, O = void 0;
              for (O in g) L[O] || p.del.push(O);
              for (O in L) {
                var b = g[O], v = L[O];
                b ? b.src !== v.src && p.change.push(v) : p.add.push(v);
              }
              (0 < p.del.length || 0 < p.add.length || 0 < p.change.length) && r.change.push(p);
            }
          } else r.add.push([u, m]);
        }
        return r;
      }
      function Kt(n, t, u, r) {
        var c = n.db.createObjectStore(t, u.keyPath ? { keyPath: u.keyPath, autoIncrement: u.auto } : { autoIncrement: u.auto });
        return r.forEach(function(m) {
          return et(c, m);
        }), c;
      }
      function ou(n, t) {
        f(n).forEach(function(u) {
          t.db.objectStoreNames.contains(u) || (Oe && console.debug("Dexie: Creating missing table", u), Kt(t, u, n[u].primKey, n[u].indexes));
        });
      }
      function et(n, t) {
        n.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function nt(n, t, u) {
        var r = {};
        return Q(t.objectStoreNames, 0).forEach(function(c) {
          for (var m = u.objectStore(c), p = kt(su(O = m.keyPath), O || "", !0, !1, !!m.autoIncrement, O && typeof O != "string", !0), g = [], L = 0; L < m.indexNames.length; ++L) {
            var b = m.index(m.indexNames[L]), O = b.keyPath, b = kt(b.name, O, !!b.unique, !!b.multiEntry, !1, O && typeof O != "string", !1);
            g.push(b);
          }
          r[c] = Vt(c, p, g);
        }), r;
      }
      function lt(n, t, u) {
        for (var r = u.db.objectStoreNames, c = 0; c < r.length; ++c) {
          var m = r[c], p = u.objectStore(m);
          n._hasGetAll = "getAll" in p;
          for (var g = 0; g < p.indexNames.length; ++g) {
            var L = p.indexNames[g], O = p.index(L).keyPath, b = typeof O == "string" ? O : "[" + Q(O).join("+") + "]";
            !t[m] || (O = t[m].idxByName[b]) && (O.name = L, delete t[m].idxByName[b], t[m].idxByName[L] = O);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && o.WorkerGlobalScope && o instanceof o.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1);
      }
      function mu(n) {
        return n.split(",").map(function(t, u) {
          var m = t.split(":"), r = (c = m[1]) === null || c === void 0 ? void 0 : c.trim(), c = (t = m[0].trim()).replace(/([&*]|\+\+)/g, ""), m = /^\[/.test(c) ? c.match(/^\[(.*)\]$/)[1].split("+") : c;
          return kt(c, m || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), d(m), u === 0, r);
        });
      }
      var mr = (fl.prototype._createTableSchema = Vt, fl.prototype._parseIndexSyntax = mu, fl.prototype._parseStoresSpec = function(n, t) {
        var u = this;
        f(n).forEach(function(r) {
          if (n[r] !== null) {
            var c = u._parseIndexSyntax(n[r]), m = c.shift();
            if (!m) throw new B.Schema("Invalid schema for table " + r + ": " + n[r]);
            if (m.unique = !0, m.multi) throw new B.Schema("Primary key cannot be multiEntry*");
            c.forEach(function(p) {
              if (p.auto) throw new B.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!p.keyPath) throw new B.Schema("Index must have a name and cannot be an empty string");
            }), c = u._createTableSchema(r, m, c), t[r] = c;
          }
        });
      }, fl.prototype.stores = function(u) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? h(this._cfg.storesSource, u) : u;
        var u = t._versions, r = {}, c = {};
        return u.forEach(function(m) {
          h(r, m._cfg.storesSource), c = m._cfg.dbschema = {}, m._parseStoresSpec(r, c);
        }), t._dbSchema = c, Zt(t, [t._allTables, t, t.Transaction.prototype]), Jl(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], f(c), c), t._storeNames = f(c), this;
      }, fl.prototype.upgrade = function(n) {
        return this._cfg.contentUpgrade = Ee(this._cfg.contentUpgrade || De, n), this;
      }, fl);
      function fl() {
      }
      function Gt(n, t) {
        var u = n._dbNamesDB;
        return u || (u = n._dbNamesDB = new En(jl, { addons: [], indexedDB: n, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), u.table("dbnames");
      }
      function zt(n) {
        return n && typeof n.databases == "function";
      }
      function jt(n) {
        return Un(function() {
          return re.letThrough = !0, n();
        });
      }
      function Ht(n) {
        return !("from" in n);
      }
      var un = function(n, t) {
        if (!this) {
          var u = new un();
          return n && "d" in n && h(u, n), u;
        }
        h(this, arguments.length ? { d: 1, from: n, to: 1 < arguments.length ? t : n } : { d: 0 });
      };
      function Cl(n, t, u) {
        var r = Se(t, u);
        if (!isNaN(r)) {
          if (0 < r) throw RangeError();
          if (Ht(n)) return h(n, { from: t, to: u, d: 1 });
          var c = n.l, r = n.r;
          if (Se(u, n.from) < 0) return c ? Cl(c, t, u) : n.l = { from: t, to: u, d: 1, l: null, r: null }, du(n);
          if (0 < Se(t, n.to)) return r ? Cl(r, t, u) : n.r = { from: t, to: u, d: 1, l: null, r: null }, du(n);
          Se(t, n.from) < 0 && (n.from = t, n.l = null, n.d = r ? r.d + 1 : 1), 0 < Se(u, n.to) && (n.to = u, n.r = null, n.d = n.l ? n.l.d + 1 : 1), u = !n.r, c && !n.l && Tl(n, c), r && u && Tl(n, r);
        }
      }
      function Tl(n, t) {
        Ht(t) || function u(r, L) {
          var m = L.from, p = L.to, g = L.l, L = L.r;
          Cl(r, m, p), g && u(r, g), L && u(r, L);
        }(n, t);
      }
      function fu(n, t) {
        var u = tt(t), r = u.next();
        if (r.done) return !1;
        for (var c = r.value, m = tt(n), p = m.next(c.from), g = p.value; !r.done && !p.done; ) {
          if (Se(g.from, c.to) <= 0 && 0 <= Se(g.to, c.from)) return !0;
          Se(c.from, g.from) < 0 ? c = (r = u.next(g.from)).value : g = (p = m.next(c.from)).value;
        }
        return !1;
      }
      function tt(n) {
        var t = Ht(n) ? null : { s: 0, n };
        return { next: function(u) {
          for (var r = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, r) for (; t.n.l && Se(u, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !r || Se(u, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function du(n) {
        var t, u, r = (((t = n.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((u = n.l) === null || u === void 0 ? void 0 : u.d) || 0), c = 1 < r ? "r" : r < -1 ? "l" : "";
        c && (t = c == "r" ? "l" : "r", u = a({}, n), r = n[c], n.from = r.from, n.to = r.to, n[c] = r[c], u[c] = r[t], (n[t] = u).d = pu(u)), n.d = pu(n);
      }
      function pu(u) {
        var t = u.r, u = u.l;
        return (t ? u ? Math.max(t.d, u.d) : t.d : u ? u.d : 0) + 1;
      }
      function it(n, t) {
        return f(t).forEach(function(u) {
          n[u] ? Tl(n[u], t[u]) : n[u] = function r(c) {
            var m, p, g = {};
            for (m in c) y(c, m) && (p = c[m], g[m] = !p || typeof p != "object" || Le.has(p.constructor) ? p : r(p));
            return g;
          }(t[u]);
        }), n;
      }
      function $t(n, t) {
        return n.all || t.all || Object.keys(n).some(function(u) {
          return t[u] && fu(t[u], n[u]);
        });
      }
      P(un.prototype, ((In = { add: function(n) {
        return Tl(this, n), this;
      }, addKey: function(n) {
        return Cl(this, n, n), this;
      }, addKeys: function(n) {
        var t = this;
        return n.forEach(function(u) {
          return Cl(t, u, u);
        }), this;
      }, hasKey: function(n) {
        var t = tt(this).next(n).value;
        return t && Se(t.from, n) <= 0 && 0 <= Se(t.to, n);
      } })[xe] = function() {
        return tt(this);
      }, In));
      var el = {}, Wt = {}, Yt = !1;
      function ut(n) {
        it(Wt, n), Yt || (Yt = !0, setTimeout(function() {
          Yt = !1, Xt(Wt, !(Wt = {}));
        }, 0));
      }
      function Xt(n, t) {
        t === void 0 && (t = !1);
        var u = /* @__PURE__ */ new Set();
        if (n.all) for (var r = 0, c = Object.values(el); r < c.length; r++) hu(p = c[r], n, u, t);
        else for (var m in n) {
          var p, g = /^idb\:\/\/(.*)\/(.*)\//.exec(m);
          g && (m = g[1], g = g[2], (p = el["idb://".concat(m, "/").concat(g)]) && hu(p, n, u, t));
        }
        u.forEach(function(L) {
          return L();
        });
      }
      function hu(n, t, u, r) {
        for (var c = [], m = 0, p = Object.entries(n.queries.query); m < p.length; m++) {
          for (var g = p[m], L = g[0], O = [], b = 0, v = g[1]; b < v.length; b++) {
            var T = v[b];
            $t(t, T.obsSet) ? T.subscribers.forEach(function(S) {
              return u.add(S);
            }) : r && O.push(T);
          }
          r && c.push([L, O]);
        }
        if (r) for (var D = 0, w = c; D < w.length; D++) {
          var C = w[D], L = C[0], O = C[1];
          n.queries.query[L] = O;
        }
      }
      function fr(n) {
        var t = n._state, u = n._deps.indexedDB;
        if (t.isBeingOpened || n.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? je(t.dbOpenError) : n;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var r = t.openCanceller, c = Math.round(10 * n.verno), m = !1;
        function p() {
          if (t.openCanceller !== r) throw new B.DatabaseClosed("db.open() was cancelled");
        }
        function g() {
          return new ee(function(T, D) {
            if (p(), !u) throw new B.MissingAPI();
            var w = n.name, C = t.autoSchema || !c ? u.open(w) : u.open(w, c);
            if (!C) throw new B.MissingAPI();
            C.onerror = wn(D), C.onblocked = Be(n._fireOnBlocked), C.onupgradeneeded = Be(function(S) {
              var q;
              b = C.transaction, t.autoSchema && !n._options.allowEmptyDB ? (C.onerror = Ol, b.abort(), C.result.close(), (q = u.deleteDatabase(w)).onsuccess = q.onerror = Be(function() {
                D(new B.NoSuchDatabase("Database ".concat(w, " doesnt exist")));
              })) : (b.onerror = wn(D), S = S.oldVersion > Math.pow(2, 62) ? 0 : S.oldVersion, v = S < 1, n.idbdb = C.result, m && or(n, b), cr(n, S / 10, b, D));
            }, D), C.onsuccess = Be(function() {
              b = null;
              var S, q, A, N, F, U = n.idbdb = C.result, W = Q(U.objectStoreNames);
              if (0 < W.length) try {
                var z = U.transaction((N = W).length === 1 ? N[0] : N, "readonly");
                if (t.autoSchema) q = U, A = z, (S = n).verno = q.version / 10, A = S._dbSchema = nt(0, q, A), S._storeNames = Q(q.objectStoreNames, 0), Jl(S, [S._allTables], f(A), A);
                else if (lt(n, n._dbSchema, z), ((F = Ut(nt(0, (F = n).idbdb, z), F._dbSchema)).add.length || F.change.some(function(H) {
                  return H.add.length || H.change.length;
                })) && !m) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), U.close(), c = U.version + 1, m = !0, T(g());
                Ql(n, z);
              } catch {
              }
              cl.push(n), U.onversionchange = Be(function(H) {
                t.vcFired = !0, n.on("versionchange").fire(H);
              }), U.onclose = Be(function(H) {
                n.on("close").fire(H);
              }), v && (F = n._deps, z = w, U = F.indexedDB, F = F.IDBKeyRange, zt(U) || z === jl || Gt(U, F).put({ name: z }).catch(De)), T();
            }, D);
          }).catch(function(T) {
            switch (T?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), g();
                break;
              case "VersionError":
                if (0 < c) return c = 0, g();
            }
            return ee.reject(T);
          });
        }
        var L, O = t.dbReadyResolve, b = null, v = !1;
        return ee.race([r, (typeof navigator > "u" ? ee.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(T) {
          function D() {
            return indexedDB.databases().finally(T);
          }
          L = setInterval(D, 100), D();
        }).finally(function() {
          return clearInterval(L);
        }) : Promise.resolve()).then(g)]).then(function() {
          return p(), t.onReadyBeingFired = [], ee.resolve(jt(function() {
            return n.on.ready.fire(n.vip);
          })).then(function T() {
            if (0 < t.onReadyBeingFired.length) {
              var D = t.onReadyBeingFired.reduce(Ee, De);
              return t.onReadyBeingFired = [], ee.resolve(jt(function() {
                return D(n.vip);
              })).then(T);
            }
          });
        }).finally(function() {
          t.openCanceller === r && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(T) {
          t.dbOpenError = T;
          try {
            b && b.abort();
          } catch {
          }
          return r === t.openCanceller && n._close(), je(T);
        }).finally(function() {
          t.openComplete = !0, O();
        }).then(function() {
          var T;
          return v && (T = {}, n.tables.forEach(function(D) {
            D.schema.indexes.forEach(function(w) {
              w.name && (T["idb://".concat(n.name, "/").concat(D.name, "/").concat(w.name)] = new un(-1 / 0, [[[]]]));
            }), T["idb://".concat(n.name, "/").concat(D.name, "/")] = T["idb://".concat(n.name, "/").concat(D.name, "/:dels")] = new un(-1 / 0, [[[]]]);
          }), jn(wl).fire(T), Xt(T, !0)), n;
        });
      }
      function Qt(n) {
        function t(m) {
          return n.next(m);
        }
        var u = c(t), r = c(function(m) {
          return n.throw(m);
        });
        function c(m) {
          return function(L) {
            var g = m(L), L = g.value;
            return g.done ? L : L && typeof L.then == "function" ? L.then(u, r) : d(L) ? Promise.all(L).then(u, r) : u(L);
          };
        }
        return c(t)();
      }
      function at(n, t, u) {
        for (var r = d(n) ? n.slice() : [n], c = 0; c < u; ++c) r.push(t);
        return r;
      }
      var dr = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema, c = {}, m = [];
          function p(v, T, D) {
            var w = Sl(v), C = c[w] = c[w] || [], S = v == null ? 0 : typeof v == "string" ? 1 : v.length, q = 0 < T, q = a(a({}, D), { name: q ? "".concat(w, "(virtual-from:").concat(D.name, ")") : D.name, lowLevelIndex: D, isVirtual: q, keyTail: T, keyLength: S, extractKey: Bt(v), unique: !q && D.unique });
            return C.push(q), q.isPrimaryKey || m.push(q), 1 < S && p(S === 2 ? v[0] : v.slice(0, S - 1), T + 1, D), C.sort(function(A, N) {
              return A.keyTail - N.keyTail;
            }), q;
          }
          t = p(r.primaryKey.keyPath, 0, r.primaryKey), c[":id"] = [t];
          for (var g = 0, L = r.indexes; g < L.length; g++) {
            var O = L[g];
            p(O.keyPath, 0, O);
          }
          function b(v) {
            var T, D = v.query.index;
            return D.isVirtual ? a(a({}, v), { query: { index: D.lowLevelIndex, range: (T = v.query.range, D = D.keyTail, { type: T.type === 1 ? 2 : T.type, lower: at(T.lower, T.lowerOpen ? n.MAX_KEY : n.MIN_KEY, D), lowerOpen: !0, upper: at(T.upper, T.upperOpen ? n.MIN_KEY : n.MAX_KEY, D), upperOpen: !0 }) } }) : v;
          }
          return a(a({}, u), { schema: a(a({}, r), { primaryKey: t, indexes: m, getIndexByKeyPath: function(v) {
            return (v = c[Sl(v)]) && v[0];
          } }), count: function(v) {
            return u.count(b(v));
          }, query: function(v) {
            return u.query(b(v));
          }, openCursor: function(v) {
            var T = v.query.index, D = T.keyTail, w = T.isVirtual, C = T.keyLength;
            return w ? u.openCursor(b(v)).then(function(q) {
              return q && S(q);
            }) : u.openCursor(v);
            function S(q) {
              return Object.create(q, { continue: { value: function(A) {
                A != null ? q.continue(at(A, v.reverse ? n.MAX_KEY : n.MIN_KEY, D)) : v.unique ? q.continue(q.key.slice(0, C).concat(v.reverse ? n.MIN_KEY : n.MAX_KEY, D)) : q.continue();
              } }, continuePrimaryKey: { value: function(A, N) {
                q.continuePrimaryKey(at(A, n.MAX_KEY, D), N);
              } }, primaryKey: { get: function() {
                return q.primaryKey;
              } }, key: { get: function() {
                var A = q.key;
                return C === 1 ? A[0] : A.slice(0, C);
              } }, value: { get: function() {
                return q.value;
              } } });
            }
          } });
        } });
      } };
      function Jt(n, t, u, r) {
        return u = u || {}, r = r || "", f(n).forEach(function(c) {
          var m, p, g;
          y(t, c) ? (m = n[c], p = t[c], typeof m == "object" && typeof p == "object" && m && p ? (g = Ce(m)) !== Ce(p) ? u[r + c] = t[c] : g === "Object" ? Jt(m, p, u, r + c + ".") : m !== p && (u[r + c] = t[c]) : m !== p && (u[r + c] = t[c])) : u[r + c] = void 0;
        }), f(t).forEach(function(c) {
          y(n, c) || (u[r + c] = t[c]);
        }), u;
      }
      function ei(n, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(n.extractKey);
      }
      var pr = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema.primaryKey;
          return a(a({}, u), { mutate: function(c) {
            var m = re.trans, p = m.table(t).hook, g = p.deleting, L = p.creating, O = p.updating;
            switch (c.type) {
              case "add":
                if (L.fire === De) break;
                return m._promise("readwrite", function() {
                  return b(c);
                }, !0);
              case "put":
                if (L.fire === De && O.fire === De) break;
                return m._promise("readwrite", function() {
                  return b(c);
                }, !0);
              case "delete":
                if (g.fire === De) break;
                return m._promise("readwrite", function() {
                  return b(c);
                }, !0);
              case "deleteRange":
                if (g.fire === De) break;
                return m._promise("readwrite", function() {
                  return function v(T, D, w) {
                    return u.query({ trans: T, values: !1, query: { index: r, range: D }, limit: w }).then(function(C) {
                      var S = C.result;
                      return b({ type: "delete", keys: S, trans: T }).then(function(q) {
                        return 0 < q.numFailures ? Promise.reject(q.failures[0]) : S.length < w ? { failures: [], numFailures: 0, lastResult: void 0 } : v(T, a(a({}, D), { lower: S[S.length - 1], lowerOpen: !0 }), w);
                      });
                    });
                  }(c.trans, c.range, 1e4);
                }, !0);
            }
            return u.mutate(c);
            function b(v) {
              var T, D, w, C = re.trans, S = v.keys || ei(r, v);
              if (!S) throw new Error("Keys missing");
              return (v = v.type === "add" || v.type === "put" ? a(a({}, v), { keys: S }) : a({}, v)).type !== "delete" && (v.values = s([], v.values)), v.keys && (v.keys = s([], v.keys)), T = u, w = S, ((D = v).type === "add" ? Promise.resolve([]) : T.getMany({ trans: D.trans, keys: w, cache: "immutable" })).then(function(q) {
                var A = S.map(function(N, F) {
                  var U, W, z, H = q[F], J = { onerror: null, onsuccess: null };
                  return v.type === "delete" ? g.fire.call(J, N, H, C) : v.type === "add" || H === void 0 ? (U = L.fire.call(J, N, v.values[F], C), N == null && U != null && (v.keys[F] = N = U, r.outbound || te(v.values[F], r.keyPath, N))) : (U = Jt(H, v.values[F]), (W = O.fire.call(J, U, N, H, C)) && (z = v.values[F], Object.keys(W).forEach(function(X) {
                    y(z, X) ? z[X] = W[X] : te(z, X, W[X]);
                  }))), J;
                });
                return u.mutate(v).then(function(N) {
                  for (var F = N.failures, U = N.results, W = N.numFailures, N = N.lastResult, z = 0; z < S.length; ++z) {
                    var H = (U || S)[z], J = A[z];
                    H == null ? J.onerror && J.onerror(F[z]) : J.onsuccess && J.onsuccess(v.type === "put" && q[z] ? v.values[z] : H);
                  }
                  return { failures: F, results: U, numFailures: W, lastResult: N };
                }).catch(function(N) {
                  return A.forEach(function(F) {
                    return F.onerror && F.onerror(N);
                  }), Promise.reject(N);
                });
              });
            }
          } });
        } });
      } };
      function gu(n, t, u) {
        try {
          if (!t || t.keys.length < n.length) return null;
          for (var r = [], c = 0, m = 0; c < t.keys.length && m < n.length; ++c) Se(t.keys[c], n[m]) === 0 && (r.push(u ? ye(t.values[c]) : t.values[c]), ++m);
          return r.length === n.length ? r : null;
        } catch {
          return null;
        }
      }
      var hr = { stack: "dbcore", level: -1, create: function(n) {
        return { table: function(t) {
          var u = n.table(t);
          return a(a({}, u), { getMany: function(r) {
            if (!r.cache) return u.getMany(r);
            var c = gu(r.keys, r.trans._cache, r.cache === "clone");
            return c ? ee.resolve(c) : u.getMany(r).then(function(m) {
              return r.trans._cache = { keys: r.keys, values: r.cache === "clone" ? ye(m) : m }, m;
            });
          }, mutate: function(r) {
            return r.type !== "add" && (r.trans._cache = null), u.mutate(r);
          } });
        } };
      } };
      function vu(n, t) {
        return n.trans.mode === "readonly" && !!n.subscr && !n.trans.explicit && n.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function xu(n, t) {
        switch (n) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var gr = { stack: "dbcore", level: 0, name: "Observability", create: function(n) {
        var t = n.schema.name, u = new un(n.MIN_KEY, n.MAX_KEY);
        return a(a({}, n), { transaction: function(r, c, m) {
          if (re.subscr && c !== "readonly") throw new B.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(re.querier));
          return n.transaction(r, c, m);
        }, table: function(r) {
          var c = n.table(r), m = c.schema, p = m.primaryKey, v = m.indexes, g = p.extractKey, L = p.outbound, O = p.autoIncrement && v.filter(function(D) {
            return D.compound && D.keyPath.includes(p.keyPath);
          }), b = a(a({}, c), { mutate: function(D) {
            function w(X) {
              return X = "idb://".concat(t, "/").concat(r, "/").concat(X), N[X] || (N[X] = new un());
            }
            var C, S, q, A = D.trans, N = D.mutatedParts || (D.mutatedParts = {}), F = w(""), U = w(":dels"), W = D.type, J = D.type === "deleteRange" ? [D.range] : D.type === "delete" ? [D.keys] : D.values.length < 50 ? [ei(p, D).filter(function(X) {
              return X;
            }), D.values] : [], z = J[0], H = J[1], J = D.trans._cache;
            return d(z) ? (F.addKeys(z), (J = W === "delete" || z.length === H.length ? gu(z, J) : null) || U.addKeys(z), (J || H) && (C = w, S = J, q = H, m.indexes.forEach(function(X) {
              var ne = C(X.name || "");
              function ve(ge) {
                return ge != null ? X.extractKey(ge) : null;
              }
              function Pe(ge) {
                return X.multiEntry && d(ge) ? ge.forEach(function(Ge) {
                  return ne.addKey(Ge);
                }) : ne.addKey(ge);
              }
              (S || q).forEach(function(ge, an) {
                var pe = S && ve(S[an]), an = q && ve(q[an]);
                Se(pe, an) !== 0 && (pe != null && Pe(pe), an != null && Pe(an));
              });
            }))) : z ? (H = { from: (H = z.lower) !== null && H !== void 0 ? H : n.MIN_KEY, to: (H = z.upper) !== null && H !== void 0 ? H : n.MAX_KEY }, U.add(H), F.add(H)) : (F.add(u), U.add(u), m.indexes.forEach(function(X) {
              return w(X.name).add(u);
            })), c.mutate(D).then(function(X) {
              return !z || D.type !== "add" && D.type !== "put" || (F.addKeys(X.results), O && O.forEach(function(ne) {
                for (var ve = D.values.map(function(pe) {
                  return ne.extractKey(pe);
                }), Pe = ne.keyPath.findIndex(function(pe) {
                  return pe === p.keyPath;
                }), ge = 0, Ge = X.results.length; ge < Ge; ++ge) ve[ge][Pe] = X.results[ge];
                w(ne.name).addKeys(ve);
              })), A.mutatedParts = it(A.mutatedParts || {}, N), X;
            });
          } }), v = function(w) {
            var C = w.query, w = C.index, C = C.range;
            return [w, new un((w = C.lower) !== null && w !== void 0 ? w : n.MIN_KEY, (C = C.upper) !== null && C !== void 0 ? C : n.MAX_KEY)];
          }, T = { get: function(D) {
            return [p, new un(D.key)];
          }, getMany: function(D) {
            return [p, new un().addKeys(D.keys)];
          }, count: v, query: v, openCursor: v };
          return f(T).forEach(function(D) {
            b[D] = function(w) {
              var C = re.subscr, S = !!C, q = vu(re, c) && xu(D, w) ? w.obsSet = {} : C;
              if (S) {
                var A = function(H) {
                  return H = "idb://".concat(t, "/").concat(r, "/").concat(H), q[H] || (q[H] = new un());
                }, N = A(""), F = A(":dels"), C = T[D](w), S = C[0], C = C[1];
                if ((D === "query" && S.isPrimaryKey && !w.values ? F : A(S.name || "")).add(C), !S.isPrimaryKey) {
                  if (D !== "count") {
                    var U = D === "query" && L && w.values && c.query(a(a({}, w), { values: !1 }));
                    return c[D].apply(this, arguments).then(function(H) {
                      if (D === "query") {
                        if (L && w.values) return U.then(function(ve) {
                          return ve = ve.result, N.addKeys(ve), H;
                        });
                        var J = w.values ? H.result.map(g) : H.result;
                        (w.values ? N : F).addKeys(J);
                      } else if (D === "openCursor") {
                        var X = H, ne = w.values;
                        return X && Object.create(X, { key: { get: function() {
                          return F.addKey(X.primaryKey), X.key;
                        } }, primaryKey: { get: function() {
                          var ve = X.primaryKey;
                          return F.addKey(ve), ve;
                        } }, value: { get: function() {
                          return ne && N.addKey(X.primaryKey), X.value;
                        } } });
                      }
                      return H;
                    });
                  }
                  F.add(u);
                }
              }
              return c[D].apply(this, arguments);
            };
          }), b;
        } });
      } };
      function yu(n, t, u) {
        if (u.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var r = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return u.numFailures === r ? null : (t = a({}, t), d(t.keys) && (t.keys = t.keys.filter(function(c, m) {
          return !(m in u.failures);
        })), "values" in t && d(t.values) && (t.values = t.values.filter(function(c, m) {
          return !(m in u.failures);
        })), t);
      }
      function ni(n, t) {
        return u = n, ((r = t).lower === void 0 || (r.lowerOpen ? 0 < Se(u, r.lower) : 0 <= Se(u, r.lower))) && (n = n, (t = t).upper === void 0 || (t.upperOpen ? Se(n, t.upper) < 0 : Se(n, t.upper) <= 0));
        var u, r;
      }
      function Iu(n, t, T, r, c, m) {
        if (!T || T.length === 0) return n;
        var p = t.query.index, g = p.multiEntry, L = t.query.range, O = r.schema.primaryKey.extractKey, b = p.extractKey, v = (p.lowLevelIndex || p).extractKey, T = T.reduce(function(D, w) {
          var C = D, S = [];
          if (w.type === "add" || w.type === "put") for (var q = new un(), A = w.values.length - 1; 0 <= A; --A) {
            var N, F = w.values[A], U = O(F);
            q.hasKey(U) || (N = b(F), (g && d(N) ? N.some(function(X) {
              return ni(X, L);
            }) : ni(N, L)) && (q.addKey(U), S.push(F)));
          }
          switch (w.type) {
            case "add":
              var W = new un().addKeys(t.values ? D.map(function(ne) {
                return O(ne);
              }) : D), C = D.concat(t.values ? S.filter(function(ne) {
                return ne = O(ne), !W.hasKey(ne) && (W.addKey(ne), !0);
              }) : S.map(function(ne) {
                return O(ne);
              }).filter(function(ne) {
                return !W.hasKey(ne) && (W.addKey(ne), !0);
              }));
              break;
            case "put":
              var z = new un().addKeys(w.values.map(function(ne) {
                return O(ne);
              }));
              C = D.filter(function(ne) {
                return !z.hasKey(t.values ? O(ne) : ne);
              }).concat(t.values ? S : S.map(function(ne) {
                return O(ne);
              }));
              break;
            case "delete":
              var H = new un().addKeys(w.keys);
              C = D.filter(function(ne) {
                return !H.hasKey(t.values ? O(ne) : ne);
              });
              break;
            case "deleteRange":
              var J = w.range;
              C = D.filter(function(ne) {
                return !ni(O(ne), J);
              });
          }
          return C;
        }, n);
        return T === n ? n : (T.sort(function(D, w) {
          return Se(v(D), v(w)) || Se(O(D), O(w));
        }), t.limit && t.limit < 1 / 0 && (T.length > t.limit ? T.length = t.limit : n.length === t.limit && T.length < t.limit && (c.dirty = !0)), m ? Object.freeze(T) : T);
      }
      function Lu(n, t) {
        return Se(n.lower, t.lower) === 0 && Se(n.upper, t.upper) === 0 && !!n.lowerOpen == !!t.lowerOpen && !!n.upperOpen == !!t.upperOpen;
      }
      function vr(n, t) {
        return function(u, r, c, m) {
          if (u === void 0) return r !== void 0 ? -1 : 0;
          if (r === void 0) return 1;
          if ((r = Se(u, r)) === 0) {
            if (c && m) return 0;
            if (c) return 1;
            if (m) return -1;
          }
          return r;
        }(n.lower, t.lower, n.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(u, r, c, m) {
          if (u === void 0) return r !== void 0 ? 1 : 0;
          if (r === void 0) return -1;
          if ((r = Se(u, r)) === 0) {
            if (c && m) return 0;
            if (c) return -1;
            if (m) return 1;
          }
          return r;
        }(n.upper, t.upper, n.upperOpen, t.upperOpen);
      }
      function xr(n, t, u, r) {
        n.subscribers.add(u), r.addEventListener("abort", function() {
          var c, m;
          n.subscribers.delete(u), n.subscribers.size === 0 && (c = n, m = t, setTimeout(function() {
            c.subscribers.size === 0 && de(m, c);
          }, 3e3));
        });
      }
      var yr = { stack: "dbcore", level: 0, name: "Cache", create: function(n) {
        var t = n.schema.name;
        return a(a({}, n), { transaction: function(u, r, c) {
          var m, p, g = n.transaction(u, r, c);
          return r === "readwrite" && (p = (m = new AbortController()).signal, c = function(L) {
            return function() {
              if (m.abort(), r === "readwrite") {
                for (var O = /* @__PURE__ */ new Set(), b = 0, v = u; b < v.length; b++) {
                  var T = v[b], D = el["idb://".concat(t, "/").concat(T)];
                  if (D) {
                    var w = n.table(T), C = D.optimisticOps.filter(function(ne) {
                      return ne.trans === g;
                    });
                    if (g._explicit && L && g.mutatedParts) for (var S = 0, q = Object.values(D.queries.query); S < q.length; S++) for (var A = 0, N = (W = q[S]).slice(); A < N.length; A++) $t((z = N[A]).obsSet, g.mutatedParts) && (de(W, z), z.subscribers.forEach(function(ne) {
                      return O.add(ne);
                    }));
                    else if (0 < C.length) {
                      D.optimisticOps = D.optimisticOps.filter(function(ne) {
                        return ne.trans !== g;
                      });
                      for (var F = 0, U = Object.values(D.queries.query); F < U.length; F++) for (var W, z, H, J = 0, X = (W = U[F]).slice(); J < X.length; J++) (z = X[J]).res != null && g.mutatedParts && (L && !z.dirty ? (H = Object.isFrozen(z.res), H = Iu(z.res, z.req, C, w, z, H), z.dirty ? (de(W, z), z.subscribers.forEach(function(ne) {
                        return O.add(ne);
                      })) : H !== z.res && (z.res = H, z.promise = ee.resolve({ result: H }))) : (z.dirty && de(W, z), z.subscribers.forEach(function(ne) {
                        return O.add(ne);
                      })));
                    }
                  }
                }
                O.forEach(function(ne) {
                  return ne();
                });
              }
            };
          }, g.addEventListener("abort", c(!1), { signal: p }), g.addEventListener("error", c(!1), { signal: p }), g.addEventListener("complete", c(!0), { signal: p })), g;
        }, table: function(u) {
          var r = n.table(u), c = r.schema.primaryKey;
          return a(a({}, r), { mutate: function(m) {
            var p = re.trans;
            if (c.outbound || p.db._options.cache === "disabled" || p.explicit || p.idbtrans.mode !== "readwrite") return r.mutate(m);
            var g = el["idb://".concat(t, "/").concat(u)];
            return g ? (p = r.mutate(m), m.type !== "add" && m.type !== "put" || !(50 <= m.values.length || ei(c, m).some(function(L) {
              return L == null;
            })) ? (g.optimisticOps.push(m), m.mutatedParts && ut(m.mutatedParts), p.then(function(L) {
              0 < L.numFailures && (de(g.optimisticOps, m), (L = yu(0, m, L)) && g.optimisticOps.push(L), m.mutatedParts && ut(m.mutatedParts));
            }), p.catch(function() {
              de(g.optimisticOps, m), m.mutatedParts && ut(m.mutatedParts);
            })) : p.then(function(L) {
              var O = yu(0, a(a({}, m), { values: m.values.map(function(b, v) {
                var T;
                return L.failures[v] || (b = (T = c.keyPath) !== null && T !== void 0 && T.includes(".") ? ye(b) : a({}, b), te(b, c.keyPath, L.results[v])), b;
              }) }), L);
              g.optimisticOps.push(O), queueMicrotask(function() {
                return m.mutatedParts && ut(m.mutatedParts);
              });
            }), p) : r.mutate(m);
          }, query: function(m) {
            if (!vu(re, r) || !xu("query", m)) return r.query(m);
            var p = ((O = re.trans) === null || O === void 0 ? void 0 : O.db._options.cache) === "immutable", v = re, g = v.requery, L = v.signal, O = function(w, C, S, q) {
              var A = el["idb://".concat(w, "/").concat(C)];
              if (!A) return [];
              if (!(C = A.queries[S])) return [null, !1, A, null];
              var N = C[(q.query ? q.query.index.name : null) || ""];
              if (!N) return [null, !1, A, null];
              switch (S) {
                case "query":
                  var F = N.find(function(U) {
                    return U.req.limit === q.limit && U.req.values === q.values && Lu(U.req.query.range, q.query.range);
                  });
                  return F ? [F, !0, A, N] : [N.find(function(U) {
                    return ("limit" in U.req ? U.req.limit : 1 / 0) >= q.limit && (!q.values || U.req.values) && vr(U.req.query.range, q.query.range);
                  }), !1, A, N];
                case "count":
                  return F = N.find(function(U) {
                    return Lu(U.req.query.range, q.query.range);
                  }), [F, !!F, A, N];
              }
            }(t, u, "query", m), b = O[0], v = O[1], T = O[2], D = O[3];
            return b && v ? b.obsSet = m.obsSet : (v = r.query(m).then(function(w) {
              var C = w.result;
              if (b && (b.res = C), p) {
                for (var S = 0, q = C.length; S < q; ++S) Object.freeze(C[S]);
                Object.freeze(C);
              } else w.result = ye(C);
              return w;
            }).catch(function(w) {
              return D && b && de(D, b), Promise.reject(w);
            }), b = { obsSet: m.obsSet, promise: v, subscribers: /* @__PURE__ */ new Set(), type: "query", req: m, dirty: !1 }, D ? D.push(b) : (D = [b], (T = T || (el["idb://".concat(t, "/").concat(u)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[m.query.index.name || ""] = D)), xr(b, D, g, L), b.promise.then(function(w) {
              return { result: Iu(w.result, m, T?.optimisticOps, r, b, p) };
            });
          } });
        } });
      } };
      function rt(n, t) {
        return new Proxy(n, { get: function(u, r, c) {
          return r === "db" ? t : Reflect.get(u, r, c);
        } });
      }
      var En = (He.prototype.version = function(n) {
        if (isNaN(n) || n < 0.1) throw new B.Type("Given version is not a positive number");
        if (n = Math.round(10 * n) / 10, this.idbdb || this._state.isBeingOpened) throw new B.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, n);
        var t = this._versions, u = t.filter(function(r) {
          return r._cfg.version === n;
        })[0];
        return u || (u = new this.Version(n), t.push(u), t.sort(sr), u.stores({}), this._state.autoSchema = !1, u);
      }, He.prototype._whenReady = function(n) {
        var t = this;
        return this.idbdb && (this._state.openComplete || re.letThrough || this._vip) ? n() : new ee(function(u, r) {
          if (t._state.openComplete) return r(new B.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void r(new B.DatabaseClosed());
            t.open().catch(De);
          }
          t._state.dbReadyPromise.then(u, r);
        }).then(n);
      }, He.prototype.use = function(n) {
        var t = n.stack, u = n.create, r = n.level, c = n.name;
        return c && this.unuse({ stack: t, name: c }), n = this._middlewares[t] || (this._middlewares[t] = []), n.push({ stack: t, create: u, level: r ?? 10, name: c }), n.sort(function(m, p) {
          return m.level - p.level;
        }), this;
      }, He.prototype.unuse = function(n) {
        var t = n.stack, u = n.name, r = n.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(c) {
          return r ? c.create !== r : !!u && c.name !== u;
        })), this;
      }, He.prototype.open = function() {
        var n = this;
        return Xn(Rn, function() {
          return fr(n);
        });
      }, He.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var n = this._state, t = cl.indexOf(this);
        if (0 <= t && cl.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        n.isBeingOpened || (n.dbReadyPromise = new ee(function(u) {
          n.dbReadyResolve = u;
        }), n.openCanceller = new ee(function(u, r) {
          n.cancelOpen = r;
        }));
      }, He.prototype.close = function(u) {
        var t = (u === void 0 ? { disableAutoOpen: !0 } : u).disableAutoOpen, u = this._state;
        t ? (u.isBeingOpened && u.cancelOpen(new B.DatabaseClosed()), this._close(), u.autoOpen = !1, u.dbOpenError = new B.DatabaseClosed()) : (this._close(), u.autoOpen = this._options.autoOpen || u.isBeingOpened, u.openComplete = !1, u.dbOpenError = null);
      }, He.prototype.delete = function(n) {
        var t = this;
        n === void 0 && (n = { disableAutoOpen: !0 });
        var u = 0 < arguments.length && typeof arguments[0] != "object", r = this._state;
        return new ee(function(c, m) {
          function p() {
            t.close(n);
            var g = t._deps.indexedDB.deleteDatabase(t.name);
            g.onsuccess = Be(function() {
              var L, O, b;
              L = t._deps, O = t.name, b = L.indexedDB, L = L.IDBKeyRange, zt(b) || O === jl || Gt(b, L).delete(O).catch(De), c();
            }), g.onerror = wn(m), g.onblocked = t._fireOnBlocked;
          }
          if (u) throw new B.InvalidArgument("Invalid closeOptions argument to db.delete()");
          r.isBeingOpened ? r.dbReadyPromise.then(p) : p();
        });
      }, He.prototype.backendDB = function() {
        return this.idbdb;
      }, He.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, He.prototype.hasBeenClosed = function() {
        var n = this._state.dbOpenError;
        return n && n.name === "DatabaseClosed";
      }, He.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, He.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(He.prototype, "tables", { get: function() {
        var n = this;
        return f(this._allTables).map(function(t) {
          return n._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), He.prototype.transaction = function() {
        var n = (function(t, u, r) {
          var c = arguments.length;
          if (c < 2) throw new B.InvalidArgument("Too few arguments");
          for (var m = new Array(c - 1); --c; ) m[c - 1] = arguments[c];
          return r = m.pop(), [t, oe(m), r];
        }).apply(this, arguments);
        return this._transaction.apply(this, n);
      }, He.prototype._transaction = function(n, t, u) {
        var r = this, c = re.trans;
        c && c.db === this && n.indexOf("!") === -1 || (c = null);
        var m, p, g = n.indexOf("?") !== -1;
        n = n.replace("!", "").replace("?", "");
        try {
          if (p = t.map(function(O) {
            if (O = O instanceof r.Table ? O.name : O, typeof O != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return O;
          }), n == "r" || n === Et) m = Et;
          else {
            if (n != "rw" && n != _t) throw new B.InvalidArgument("Invalid transaction mode: " + n);
            m = _t;
          }
          if (c) {
            if (c.mode === Et && m === _t) {
              if (!g) throw new B.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              c = null;
            }
            c && p.forEach(function(O) {
              if (c && c.storeNames.indexOf(O) === -1) {
                if (!g) throw new B.SubTransaction("Table " + O + " not included in parent transaction.");
                c = null;
              }
            }), g && c && !c.active && (c = null);
          }
        } catch (O) {
          return c ? c._promise(null, function(b, v) {
            v(O);
          }) : je(O);
        }
        var L = (function O(b, v, T, D, w) {
          return ee.resolve().then(function() {
            var C = re.transless || re, S = b._createTransaction(v, T, b._dbSchema, D);
            if (S.explicit = !0, C = { trans: S, transless: C }, D) S.idbtrans = D.idbtrans;
            else try {
              S.create(), S.idbtrans._explicit = !0, b._state.PR1398_maxLoop = 3;
            } catch (N) {
              return N.name === k.InvalidState && b.isOpen() && 0 < --b._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), b.close({ disableAutoOpen: !1 }), b.open().then(function() {
                return O(b, v, T, null, w);
              })) : je(N);
            }
            var q, A = $e(w);
            return A && sl(), C = ee.follow(function() {
              var N;
              (q = w.call(S, S)) && (A ? (N = Kn.bind(null, null), q.then(N, N)) : typeof q.next == "function" && typeof q.throw == "function" && (q = Qt(q)));
            }, C), (q && typeof q.then == "function" ? ee.resolve(q).then(function(N) {
              return S.active ? N : je(new B.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : C.then(function() {
              return q;
            })).then(function(N) {
              return D && S._resolve(), S._completion.then(function() {
                return N;
              });
            }).catch(function(N) {
              return S._reject(N), je(N);
            });
          });
        }).bind(null, this, m, p, c, u);
        return c ? c._promise(m, L, "lock") : re.trans ? Xn(re.transless, function() {
          return r._whenReady(L);
        }) : this._whenReady(L);
      }, He.prototype.table = function(n) {
        if (!y(this._allTables, n)) throw new B.InvalidTable("Table ".concat(n, " does not exist"));
        return this._allTables[n];
      }, He);
      function He(n, t) {
        var u = this;
        this._middlewares = {}, this.verno = 0;
        var r = He.dependencies;
        this._options = t = a({ addons: He.addons, autoOpen: !0, indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, r = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var c, m, p, g, L, O = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: De, dbReadyPromise: null, cancelOpen: De, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        O.dbReadyPromise = new ee(function(v) {
          O.dbReadyResolve = v;
        }), O.openCanceller = new ee(function(v, T) {
          O.cancelOpen = T;
        }), this._state = O, this.name = n, this.on = Il(this, "populate", "blocked", "versionchange", "close", { ready: [Ee, De] }), this.once = function(v, T) {
          var D = function() {
            for (var w = [], C = 0; C < arguments.length; C++) w[C] = arguments[C];
            u.on(v).unsubscribe(D), T.apply(u, w);
          };
          return u.on(v, D);
        }, this.on.ready.subscribe = Z(this.on.ready.subscribe, function(v) {
          return function(T, D) {
            He.vip(function() {
              var w, C = u._state;
              C.openComplete ? (C.dbOpenError || ee.resolve().then(T), D && v(T)) : C.onReadyBeingFired ? (C.onReadyBeingFired.push(T), D && v(T)) : (v(T), w = u, D || v(function S() {
                w.on.ready.unsubscribe(T), w.on.ready.unsubscribe(S);
              }));
            });
          };
        }), this.Collection = (c = this, Ll(nr.prototype, function(q, S) {
          this.db = c;
          var D = Xi, w = null;
          if (S) try {
            D = S();
          } catch (A) {
            w = A;
          }
          var C = q._ctx, S = C.table, q = S.hook.reading.fire;
          this._ctx = { table: S, index: C.index, isPrimKey: !C.index || S.schema.primKey.keyPath && C.index === S.schema.primKey.name, range: D, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: w, or: C.or, valueMapper: q !== j ? q : null };
        })), this.Table = (m = this, Ll(nu.prototype, function(v, T, D) {
          this.db = m, this._tx = D, this.name = v, this.schema = T, this.hook = m._allTables[v] ? m._allTables[v].hook : Il(null, { creating: [Te, De], reading: [ie, j], updating: [be, De], deleting: [Ie, De] });
        })), this.Transaction = (p = this, Ll(ir.prototype, function(v, T, D, w, C) {
          var S = this;
          v !== "readonly" && T.forEach(function(q) {
            q = (q = D[q]) === null || q === void 0 ? void 0 : q.yProps, q && (T = T.concat(q.map(function(A) {
              return A.updatesTable;
            })));
          }), this.db = p, this.mode = v, this.storeNames = T, this.schema = D, this.chromeTransactionDurability = w, this.idbtrans = null, this.on = Il(this, "complete", "error", "abort"), this.parent = C || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ee(function(q, A) {
            S._resolve = q, S._reject = A;
          }), this._completion.then(function() {
            S.active = !1, S.on.complete.fire();
          }, function(q) {
            var A = S.active;
            return S.active = !1, S.on.error.fire(q), S.parent ? S.parent._reject(q) : A && S.idbtrans && S.idbtrans.abort(), je(q);
          });
        })), this.Version = (g = this, Ll(mr.prototype, function(v) {
          this.db = g, this._cfg = { version: v, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (L = this, Ll(ru.prototype, function(v, T, D) {
          if (this.db = L, this._ctx = { table: v, index: T === ":id" ? null : T, or: D }, this._cmp = this._ascending = Se, this._descending = function(w, C) {
            return Se(C, w);
          }, this._max = function(w, C) {
            return 0 < Se(w, C) ? w : C;
          }, this._min = function(w, C) {
            return Se(w, C) < 0 ? w : C;
          }, this._IDBKeyRange = L._deps.IDBKeyRange, !this._IDBKeyRange) throw new B.MissingAPI();
        })), this.on("versionchange", function(v) {
          0 < v.newVersion ? console.warn("Another connection wants to upgrade database '".concat(u.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(u.name, "'. Closing db now to resume the delete request.")), u.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(v) {
          !v.newVersion || v.newVersion < v.oldVersion ? console.warn("Dexie.delete('".concat(u.name, "') was blocked")) : console.warn("Upgrade '".concat(u.name, "' blocked by other connection holding version ").concat(v.oldVersion / 10));
        }), this._maxKey = bl(t.IDBKeyRange), this._createTransaction = function(v, T, D, w) {
          return new u.Transaction(v, T, D, u._options.chromeTransactionDurability, w);
        }, this._fireOnBlocked = function(v) {
          u.on("blocked").fire(v), cl.filter(function(T) {
            return T.name === u.name && T !== u && !T._state.vcFired;
          }).map(function(T) {
            return T.on("versionchange").fire(v);
          });
        }, this.use(hr), this.use(yr), this.use(gr), this.use(dr), this.use(pr);
        var b = new Proxy(this, { get: function(v, T, D) {
          if (T === "_vip") return !0;
          if (T === "table") return function(C) {
            return rt(u.table(C), b);
          };
          var w = Reflect.get(v, T, D);
          return w instanceof nu ? rt(w, b) : T === "tables" ? w.map(function(C) {
            return rt(C, b);
          }) : T === "_createTransaction" ? function() {
            return rt(w.apply(this, arguments), b);
          } : w;
        } });
        this.vip = b, r.forEach(function(v) {
          return v(u);
        });
      }
      var st, In = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Ir = (li.prototype.subscribe = function(n, t, u) {
        return this._subscribe(n && typeof n != "function" ? n : { next: n, error: t, complete: u });
      }, li.prototype[In] = function() {
        return this;
      }, li);
      function li(n) {
        this._subscribe = n;
      }
      try {
        st = { indexedDB: o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB, IDBKeyRange: o.IDBKeyRange || o.webkitIDBKeyRange };
      } catch {
        st = { indexedDB: null, IDBKeyRange: null };
      }
      function Du(n) {
        var t, u = !1, r = new Ir(function(c) {
          var m = $e(n), p, g = !1, L = {}, O = {}, b = { get closed() {
            return g;
          }, unsubscribe: function() {
            g || (g = !0, p && p.abort(), v && jn.storagemutated.unsubscribe(D));
          } };
          c.start && c.start(b);
          var v = !1, T = function() {
            return At(w);
          }, D = function(C) {
            it(L, C), $t(O, L) && T();
          }, w = function() {
            var C, S, q;
            !g && st.indexedDB && (L = {}, C = {}, p && p.abort(), p = new AbortController(), q = function(A) {
              var N = al();
              try {
                m && sl();
                var F = Un(n, A);
                return F = m ? F.finally(Kn) : F;
              } finally {
                N && rl();
              }
            }(S = { subscr: C, signal: p.signal, requery: T, querier: n, trans: null }), Promise.resolve(q).then(function(A) {
              u = !0, t = A, g || S.signal.aborted || (L = {}, function(N) {
                for (var F in N) if (y(N, F)) return;
                return 1;
              }(O = C) || v || (jn(wl, D), v = !0), At(function() {
                return !g && c.next && c.next(A);
              }));
            }, function(A) {
              u = !1, ["DatabaseClosedError", "AbortError"].includes(A?.name) || g || At(function() {
                g || c.error && c.error(A);
              });
            }));
          };
          return setTimeout(T, 0), b;
        });
        return r.hasValue = function() {
          return u;
        }, r.getValue = function() {
          return t;
        }, r;
      }
      var nl = En;
      function ti(n) {
        var t = Hn;
        try {
          Hn = !0, jn.storagemutated.fire(n), Xt(n, !0);
        } finally {
          Hn = t;
        }
      }
      P(nl, a(a({}, Xe), { delete: function(n) {
        return new nl(n, { addons: [] }).delete();
      }, exists: function(n) {
        return new nl(n, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(n) {
        try {
          return t = nl.dependencies, u = t.indexedDB, t = t.IDBKeyRange, (zt(u) ? Promise.resolve(u.databases()).then(function(r) {
            return r.map(function(c) {
              return c.name;
            }).filter(function(c) {
              return c !== jl;
            });
          }) : Gt(u, t).toCollection().primaryKeys()).then(n);
        } catch {
          return je(new B.MissingAPI());
        }
        var t, u;
      }, defineClass: function() {
        return function(n) {
          h(this, n);
        };
      }, ignoreTransaction: function(n) {
        return re.trans ? Xn(re.transless, n) : n();
      }, vip: jt, async: function(n) {
        return function() {
          try {
            var t = Qt(n.apply(this, arguments));
            return t && typeof t.then == "function" ? t : ee.resolve(t);
          } catch (u) {
            return je(u);
          }
        };
      }, spawn: function(n, t, u) {
        try {
          var r = Qt(n.apply(u, t || []));
          return r && typeof r.then == "function" ? r : ee.resolve(r);
        } catch (c) {
          return je(c);
        }
      }, currentTransaction: { get: function() {
        return re.trans || null;
      } }, waitFor: function(n, t) {
        return t = ee.resolve(typeof n == "function" ? nl.ignoreTransaction(n) : n).timeout(t || 6e4), re.trans ? re.trans.waitFor(t) : t;
      }, Promise: ee, debug: { get: function() {
        return Oe;
      }, set: function(n) {
        qe(n);
      } }, derive: V, extend: h, props: P, override: Z, Events: Il, on: jn, liveQuery: Du, extendObservabilitySet: it, getByKeyPath: se, setByKeyPath: te, delByKeyPath: function(n, t) {
        typeof t == "string" ? te(n, t, void 0) : "length" in t && [].map.call(t, function(u) {
          te(n, u, void 0);
        });
      }, shallowClone: fe, deepClone: ye, getObjectDiff: Jt, cmp: Se, asap: Y, minKey: -1 / 0, addons: [], connections: cl, errnames: k, dependencies: st, cache: el, semVer: "4.2.0", version: "4.2.0".split(".").map(function(n) {
        return parseInt(n);
      }).reduce(function(n, t, u) {
        return n + t / Math.pow(10, 2 * u);
      }) })), nl.maxKey = bl(nl.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (jn(wl, function(n) {
        Hn || (n = new CustomEvent(Mt, { detail: n }), Hn = !0, dispatchEvent(n), Hn = !1);
      }), addEventListener(Mt, function(n) {
        n = n.detail, Hn || ti(n);
      }));
      var gl, Hn = !1, Ou = function() {
      };
      return typeof BroadcastChannel < "u" && ((Ou = function() {
        (gl = new BroadcastChannel(Mt)).onmessage = function(n) {
          return n.data && ti(n.data);
        };
      })(), typeof gl.unref == "function" && gl.unref(), jn(wl, function(n) {
        Hn || gl.postMessage(n);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(n) {
        if (!En.disableBfCache && n.persisted) {
          Oe && console.debug("Dexie: handling persisted pagehide"), gl?.close();
          for (var t = 0, u = cl; t < u.length; t++) u[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(n) {
        !En.disableBfCache && n.persisted && (Oe && console.debug("Dexie: handling persisted pageshow"), Ou(), ti({ all: new un(-1 / 0, [[]]) }));
      })), ee.rejectionMapper = function(n, t) {
        return !n || n instanceof cn || n instanceof TypeError || n instanceof SyntaxError || !n.name || !le[n.name] ? n : (t = new le[n.name](t || n.message, n), "stack" in n && R(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, qe(Oe), a(En, Object.freeze({ __proto__: null, Dexie: En, liveQuery: Du, Entity: Qi, cmp: Se, PropModification: Dl, replacePrefix: function(n, t) {
        return new Dl({ replacePrefix: [n, t] });
      }, add: function(n) {
        return new Dl({ add: n });
      }, remove: function(n) {
        return new Dl({ remove: n });
      }, default: En, RangeSet: un, mergeRanges: Tl, rangesOverlap: fu }), { default: En }), En;
    });
  }(Lm)), Lm.exports;
}
var TD = CD();
const Dm = /* @__PURE__ */ iD(TD), Td = Symbol.for("Dexie"), Ma = globalThis[Td] || (globalThis[Td] = Dm);
if (Dm.semVer !== Ma.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Dm.semVer} and ${Ma.semVer}`);
const {
  liveQuery: J1,
  mergeRanges: eC,
  rangesOverlap: nC,
  RangeSet: lC,
  cmp: tC,
  Entity: iC,
  PropModification: uC,
  replacePrefix: aC,
  add: rC,
  remove: sC,
  DexieYProvider: cC
} = Ma;
class qD extends Ma {
  /**
   * @param {ConstructorParameters<DexieConstructor>[0]} databaseName - Name of the database
   * @param {ConstructorParameters<DexieConstructor>[1]} options - Options for Dexie
   */
  constructor(...l) {
    super(...l), this.upgrade();
  }
  async upgrade() {
    if (this.isOpen()) {
      this.close(), qd(this), await this.open();
      return;
    }
    qd(this);
  }
}
function qd(e) {
  return e.version(1).stores({
    [Js]: So
  }), e.version(2).stores({
    [Js]: So,
    [Co]: Sd
  }), e.version(2.1).stores({
    [Js]: So,
    [Co]: Sd
  }).upgrade((l) => {
    l.table(Co).toCollection().modify((i) => {
      typeof i.file == "string" && (i.file = new Blob([i.file], { type: "text/xml" }));
    });
  }), e;
}
async function PD(e) {
  const { databaseInstance: l, records: i } = e, a = l.table(Js);
  await l.transaction("rw", a, () => a.bulkAdd(i));
}
async function RD(e) {
  if (await Ma.exists(e))
    return await Ma.delete(e);
}
const AD = {
  useBrowserApi: !0,
  chunkSize: 32 * 1024,
  // 32KB
  batchSize: 2e3
};
async function ED({
  files: e,
  options: l = AD
}) {
  const i = [];
  if (e.length === 0) throw new Error("No files provided for import.");
  for (const a of e) {
    if (!_D(a)) {
      console.error(`Unsupported file type: ${a.name}`);
      continue;
    }
    a.size === 0 && console.warn(`File is empty: ${a.name}`);
    const s = await FD({ file: a, options: l });
    i.push(s);
  }
  return i;
}
function _D(e) {
  return pD.some((l) => e.name.toLowerCase().endsWith(l));
}
function ND(e) {
  return e.name.replace(/\.[^.]+$/, "");
}
async function FD(e) {
  const { file: l, options: i } = e;
  try {
    const a = ND(l);
    await RD(a);
    const s = new qD(a);
    return i.useBrowserApi && l.size !== 0 && await MD({
      file: l,
      databaseInstance: s,
      options: {
        chunkSize: i.chunkSize,
        batchSize: i.batchSize
      }
    }), a;
  } catch (a) {
    throw console.error(`Error importing file ${l.name}:`, a), a;
  }
}
async function MD(e) {
  const { file: l, databaseInstance: i, options: a } = e, s = l.stream().getReader(), o = gD(), f = new TextDecoder(), d = new Uint8Array(0);
  return await Om({ databaseInstance: i, reader: s, sax: o, textDecoder: f, buffer: d, options: a });
}
async function Om(e) {
  const { databaseInstance: l, reader: i, sax: a, textDecoder: s, buffer: o, options: f } = e, { chunkSize: d, batchSize: h } = f, { done: I, value: x } = await i.read();
  if (I) {
    if (o.length > 0) {
      const P = s.decode(o);
      a.parser.write(P);
    }
    return a.parser.close(), await Pd({
      databaseInstance: l,
      sax: a,
      batchSize: 0
    });
  }
  if (!x)
    return await Om(e);
  let y = new Uint8Array(o.length + x.length);
  for (y.set(o), y.set(x, o.length); y.length >= d; ) {
    const P = y.slice(0, d);
    y = y.slice(d);
    const E = s.decode(P, { stream: !0 });
    a.parser.write(E), await Pd({
      databaseInstance: l,
      sax: a,
      batchSize: h
    });
  }
  return await Om({ ...e, buffer: y });
}
async function Pd(e) {
  const { databaseInstance: l, sax: i, batchSize: a } = e;
  if (i.getSize() >= a) {
    const s = i.drainBatch(), o = mD({
      currentBatch: s
    });
    await PD({
      databaseInstance: l,
      records: o
    });
  }
}
function pf(e, l) {
  return Hu() ? (Za(e, l), !0) : !1;
}
// @__NO_SIDE_EFFECTS__
function Rd() {
  const e = /* @__PURE__ */ new Set(), l = (o) => {
    e.delete(o);
  };
  return {
    on: (o) => {
      e.add(o);
      const f = () => l(o);
      return pf(f), { off: f };
    },
    off: l,
    trigger: (...o) => Promise.all(Array.from(e).map((f) => f(...o))),
    clear: () => {
      e.clear();
    }
  };
}
const To = /* @__PURE__ */ new WeakMap(), kD = /* @__NO_SIDE_EFFECTS__ */ (...e) => {
  var l;
  const i = e[0], a = (l = Yn()) === null || l === void 0 ? void 0 : l.proxy, s = a ?? Hu();
  if (s == null && !zc()) throw new Error("injectLocal must be called in setup");
  return s && To.has(s) && i in To.get(s) ? To.get(s)[i] : Ei(...e);
}, hf = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const VD = Object.prototype.toString, BD = (e) => VD.call(e) === "[object Object]", Mg = () => {
}, ZD = (e, l) => Object.prototype.hasOwnProperty.call(e, l);
function UD(...e) {
  if (e.length !== 1) return fs(...e);
  const l = e[0];
  return typeof l == "function" ? Mi(Ga(() => ({
    get: l,
    set: Mg
  }))) : Me(l);
}
function KD(e, l) {
  function i(...a) {
    return new Promise((s, o) => {
      Promise.resolve(e(() => l.apply(this, a), {
        fn: l,
        thisArg: this,
        args: a
      })).then(s).catch(o);
    });
  }
  return i;
}
const kg = (e) => e();
function GD(e = kg, l = {}) {
  const { initialState: i = "active" } = l, a = UD(i === "active");
  function s() {
    a.value = !1;
  }
  function o() {
    a.value = !0;
  }
  const f = (...d) => {
    a.value && e(...d);
  };
  return {
    isActive: Mi(a),
    pause: s,
    resume: o,
    eventFilter: f
  };
}
function zD(e, l) {
  var i;
  if (typeof e == "number") return e + l;
  const a = ((i = e.match(/^-?\d+\.?\d*/)) === null || i === void 0 ? void 0 : i[0]) || "", s = e.slice(a.length), o = Number.parseFloat(a) + l;
  return Number.isNaN(o) ? e : o + s;
}
function jr(e) {
  return e.endsWith("rem") ? Number.parseFloat(e) * 16 : Number.parseFloat(e);
}
function qo(e) {
  return Array.isArray(e) ? e : [e];
}
function jD(e) {
  return Yn();
}
function HD(e) {
  let l = pn(e), i;
  const a = () => {
    l = pn(e), i();
  }, s = Ga((o, f) => (i = f, {
    get() {
      return o(), l;
    },
    set(d) {
      l = d, i();
    }
  }));
  return s.reset = a, s;
}
function $D(e, l, i = {}) {
  const { eventFilter: a = kg, ...s } = i;
  return Sn(e, KD(a, l), s);
}
function WD(e, l, i = {}) {
  const { eventFilter: a, initialState: s = "active", ...o } = i, { eventFilter: f, pause: d, resume: h, isActive: I } = GD(a, { initialState: s });
  return {
    stop: $D(e, l, {
      ...o,
      eventFilter: f
    }),
    pause: d,
    resume: h,
    isActive: I
  };
}
const YD = WD;
function Vg(e, l = !0, i) {
  jD() ? vl(e, i) : l ? e() : tl(e);
}
function XD(e, l, i = {}) {
  const { immediate: a = !0, immediateCallback: s = !1 } = i, o = Vl(!1);
  let f;
  function d() {
    f && (clearTimeout(f), f = void 0);
  }
  function h() {
    o.value = !1, d();
  }
  function I(...x) {
    s && e(), d(), o.value = !0, f = setTimeout(() => {
      o.value = !1, f = void 0, e(...x);
    }, pn(l));
  }
  return a && (o.value = !0, hf && I()), pf(h), {
    isPending: Pu(o),
    start: I,
    stop: h
  };
}
function QD(e, l, i) {
  return Sn(e, l, {
    ...i,
    immediate: !0
  });
}
function Bg(e, l, i) {
  var a;
  let s;
  kn(i) ? s = { evaluating: i } : s = i || {};
  const { lazy: o = !1, flush: f = "sync", evaluating: d = void 0, shallow: h = !0, onError: I = (a = globalThis.reportError) !== null && a !== void 0 ? a : Mg } = s, x = Vl(!o), y = h ? Vl(l) : Me(l);
  let P = 0;
  return Nl(async (E) => {
    if (!x.value) return;
    P++;
    const R = P;
    let V = !1;
    d && Promise.resolve().then(() => {
      d.value = !0;
    });
    try {
      const K = await e(($) => {
        E(() => {
          d && (d.value = !1), V || $();
        });
      });
      R === P && (y.value = K);
    } catch (K) {
      I(K);
    } finally {
      d && R === P && (d.value = !1), V = !0;
    }
  }, { flush: f }), o ? _e(() => (x.value = !0, y.value)) : y;
}
const Ju = hf ? window : void 0, JD = hf ? window.document : void 0;
function Zg(e) {
  var l;
  const i = pn(e);
  return (l = i?.$el) !== null && l !== void 0 ? l : i;
}
function wm(...e) {
  const l = [], i = () => {
    l.forEach((d) => d()), l.length = 0;
  }, a = (d, h, I, x) => (d.addEventListener(h, I, x), () => d.removeEventListener(h, I, x)), s = _e(() => {
    const d = qo(pn(e[0])).filter((h) => h != null);
    return d.every((h) => typeof h != "string") ? d : void 0;
  }), o = QD(() => {
    var d, h;
    return [
      (d = (h = s.value) === null || h === void 0 ? void 0 : h.map((I) => Zg(I))) !== null && d !== void 0 ? d : [Ju].filter((I) => I != null),
      qo(pn(s.value ? e[1] : e[0])),
      qo(ue(s.value ? e[2] : e[1])),
      pn(s.value ? e[3] : e[2])
    ];
  }, ([d, h, I, x]) => {
    if (i(), !d?.length || !h?.length || !I?.length) return;
    const y = BD(x) ? { ...x } : x;
    l.push(...d.flatMap((P) => h.flatMap((E) => I.map((R) => a(P, E, R, y)))));
  }, { flush: "post" }), f = () => {
    o(), i();
  };
  return pf(i), f;
}
// @__NO_SIDE_EFFECTS__
function e0() {
  const e = Vl(!1), l = Yn();
  return l && vl(() => {
    e.value = !0;
  }, l), e;
}
// @__NO_SIDE_EFFECTS__
function n0(e) {
  const l = /* @__PURE__ */ e0();
  return _e(() => (l.value, !!e()));
}
const l0 = Symbol("vueuse-ssr-width");
// @__NO_SIDE_EFFECTS__
function Ug() {
  const e = zc() ? /* @__PURE__ */ kD(l0, null) : null;
  return typeof e == "number" ? e : void 0;
}
function wr(e, l = {}) {
  const { window: i = Ju, ssrWidth: a = /* @__PURE__ */ Ug() } = l, s = /* @__PURE__ */ n0(() => i && "matchMedia" in i && typeof i.matchMedia == "function"), o = Vl(typeof a == "number"), f = Vl(), d = Vl(!1), h = (I) => {
    d.value = I.matches;
  };
  return Nl(() => {
    if (o.value) {
      o.value = !s.value, d.value = pn(e).split(",").some((I) => {
        const x = I.includes("not all"), y = I.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/), P = I.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        let E = !!(y || P);
        return y && E && (E = a >= jr(y[1])), P && E && (E = a <= jr(P[1])), x ? !E : E;
      });
      return;
    }
    s.value && (f.value = i.matchMedia(pn(e)), d.value = f.value.matches);
  }), wm(f, "change", h, { passive: !0 }), _e(() => d.value);
}
const t0 = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536
};
// @__NO_SIDE_EFFECTS__
function i0(e, l = {}) {
  function i(E, R) {
    let V = pn(e[pn(E)]);
    return R != null && (V = zD(V, R)), typeof V == "number" && (V = `${V}px`), V;
  }
  const { window: a = Ju, strategy: s = "min-width", ssrWidth: o = /* @__PURE__ */ Ug() } = l, f = typeof o == "number", d = f ? Vl(!1) : { value: !0 };
  f && Vg(() => d.value = !!a);
  function h(E, R) {
    return !d.value && f ? E === "min" ? o >= jr(R) : o <= jr(R) : a ? a.matchMedia(`(${E}-width: ${R})`).matches : !1;
  }
  const I = (E) => wr(() => `(min-width: ${i(E)})`, l), x = (E) => wr(() => `(max-width: ${i(E)})`, l), y = Object.keys(e).reduce((E, R) => (Object.defineProperty(E, R, {
    get: () => s === "min-width" ? I(R) : x(R),
    enumerable: !0,
    configurable: !0
  }), E), {});
  function P() {
    const E = Object.keys(e).map((R) => [
      R,
      y[R],
      jr(i(R))
    ]).sort((R, V) => R[2] - V[2]);
    return _e(() => E.filter(([, R]) => R.value).map(([R]) => R));
  }
  return Object.assign(y, {
    greaterOrEqual: I,
    smallerOrEqual: x,
    greater(E) {
      return wr(() => `(min-width: ${i(E, 0.1)})`, l);
    },
    smaller(E) {
      return wr(() => `(max-width: ${i(E, -0.1)})`, l);
    },
    between(E, R) {
      return wr(() => `(min-width: ${i(E)}) and (max-width: ${i(R, -0.1)})`, l);
    },
    isGreater(E) {
      return h("min", i(E, 0.1));
    },
    isGreaterOrEqual(E) {
      return h("min", i(E));
    },
    isSmaller(E) {
      return h("max", i(E, -0.1));
    },
    isSmallerOrEqual(E) {
      return h("max", i(E));
    },
    isInBetween(E, R) {
      return h("min", i(E)) && h("max", i(R, -0.1));
    },
    current: P,
    active() {
      const E = P();
      return _e(() => E.value.length === 0 ? "" : E.value.at(s === "min-width" ? -1 : 0));
    }
  });
}
const _s = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Ns = "__vueuse_ssr_handlers__", u0 = /* @__PURE__ */ a0();
function a0() {
  return Ns in _s || (_s[Ns] = _s[Ns] || {}), _s[Ns];
}
function r0(e, l) {
  return u0[e] || l;
}
function s0(e) {
  return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number";
}
const c0 = {
  boolean: {
    read: (e) => e === "true",
    write: (e) => String(e)
  },
  object: {
    read: (e) => JSON.parse(e),
    write: (e) => JSON.stringify(e)
  },
  number: {
    read: (e) => Number.parseFloat(e),
    write: (e) => String(e)
  },
  any: {
    read: (e) => e,
    write: (e) => String(e)
  },
  string: {
    read: (e) => e,
    write: (e) => String(e)
  },
  map: {
    read: (e) => new Map(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e.entries()))
  },
  set: {
    read: (e) => new Set(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e))
  },
  date: {
    read: (e) => new Date(e),
    write: (e) => e.toISOString()
  }
}, Ad = "vueuse-storage";
function o0(e, l, i, a = {}) {
  var s;
  const { flush: o = "pre", deep: f = !0, listenToStorageChanges: d = !0, writeDefaults: h = !0, mergeDefaults: I = !1, shallow: x, window: y = Ju, eventFilter: P, onError: E = (he) => {
    console.error(he);
  }, initOnMounted: R } = a, V = (x ? Vl : Me)(l), K = _e(() => pn(e));
  if (!i) try {
    i = r0("getDefaultStorage", () => Ju?.localStorage)();
  } catch (he) {
    E(he);
  }
  if (!i) return V;
  const $ = pn(l), Q = s0($), Z = (s = a.serializer) !== null && s !== void 0 ? s : c0[Q], { pause: G, resume: Y } = YD(V, (he) => oe(he), {
    flush: o,
    deep: f,
    eventFilter: P
  });
  Sn(K, () => ae(), { flush: o });
  let se = !1;
  const te = (he) => {
    R && !se || ae(he);
  }, fe = (he) => {
    R && !se || ye(he);
  };
  y && d && (i instanceof Storage ? wm(y, "storage", te, { passive: !0 }) : wm(y, Ad, fe)), R ? Vg(() => {
    se = !0, ae();
  }) : ae();
  function M(he, Ce) {
    if (y) {
      const xe = {
        key: K.value,
        oldValue: he,
        newValue: Ce,
        storageArea: i
      };
      y.dispatchEvent(i instanceof Storage ? new StorageEvent("storage", xe) : new CustomEvent(Ad, { detail: xe }));
    }
  }
  function oe(he) {
    try {
      const Ce = i.getItem(K.value);
      if (he == null)
        M(Ce, null), i.removeItem(K.value);
      else {
        const xe = Z.write(he);
        Ce !== xe && (i.setItem(K.value, xe), M(Ce, xe));
      }
    } catch (Ce) {
      E(Ce);
    }
  }
  function Le(he) {
    const Ce = he ? he.newValue : i.getItem(K.value);
    if (Ce == null)
      return h && $ != null && i.setItem(K.value, Z.write($)), $;
    if (!he && I) {
      const xe = Z.read(Ce);
      return typeof I == "function" ? I(xe, $) : Q === "object" && !Array.isArray(xe) ? {
        ...$,
        ...xe
      } : xe;
    } else return typeof Ce != "string" ? Ce : Z.read(Ce);
  }
  function ae(he) {
    if (!(he && he.storageArea !== i)) {
      if (he && he.key == null) {
        V.value = $;
        return;
      }
      if (!(he && he.key !== K.value)) {
        G();
        try {
          const Ce = Z.write(V.value);
          (he === void 0 || he?.newValue !== Ce) && (V.value = Le(he));
        } catch (Ce) {
          E(Ce);
        } finally {
          he ? tl(Y) : Y();
        }
      }
    }
  }
  function ye(he) {
    ae(he.detail);
  }
  return V;
}
const m0 = {
  multiple: !0,
  accept: "*",
  reset: !1,
  directory: !1
};
function f0(e) {
  if (!e) return null;
  if (e instanceof FileList) return e;
  const l = new DataTransfer();
  for (const i of e) l.items.add(i);
  return l.files;
}
function d0(e = {}) {
  const { document: l = JD } = e, i = Me(f0(e.initialFiles)), { on: a, trigger: s } = /* @__PURE__ */ Rd(), { on: o, trigger: f } = /* @__PURE__ */ Rd(), d = _e(() => {
    var y;
    const P = (y = Zg(e.input)) !== null && y !== void 0 ? y : l ? l.createElement("input") : void 0;
    return P && (P.type = "file", P.onchange = (E) => {
      i.value = E.target.files, s(i.value);
    }, P.oncancel = () => {
      f();
    }), P;
  }), h = () => {
    i.value = null, d.value && d.value.value && (d.value.value = "", s(null));
  }, I = (y) => {
    const P = d.value;
    P && (P.multiple = pn(y.multiple), P.accept = pn(y.accept), P.webkitdirectory = pn(y.directory), ZD(y, "capture") && (P.capture = pn(y.capture)));
  }, x = (y) => {
    const P = d.value;
    if (!P) return;
    const E = {
      ...m0,
      ...e,
      ...y
    };
    I(E), pn(E.reset) && h(), P.click();
  };
  return Nl(() => {
    I(e);
  }), {
    files: Mi(i),
    open: x,
    reset: h,
    onCancel: o,
    onChange: a
  };
}
var p0 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function h0(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ec = { exports: {} }, g0 = ec.exports, Ed;
function v0() {
  return Ed || (Ed = 1, function(e, l) {
    (function(i, a) {
      e.exports = a();
    })(g0, function() {
      var i = function(n, t) {
        return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(u, r) {
          u.__proto__ = r;
        } || function(u, r) {
          for (var c in r) Object.prototype.hasOwnProperty.call(r, c) && (u[c] = r[c]);
        })(n, t);
      }, a = function() {
        return (a = Object.assign || function(n) {
          for (var t, u = 1, r = arguments.length; u < r; u++) for (var c in t = arguments[u]) Object.prototype.hasOwnProperty.call(t, c) && (n[c] = t[c]);
          return n;
        }).apply(this, arguments);
      };
      function s(n, t, u) {
        for (var r, c = 0, m = t.length; c < m; c++) !r && c in t || ((r = r || Array.prototype.slice.call(t, 0, c))[c] = t[c]);
        return n.concat(r || Array.prototype.slice.call(t));
      }
      var o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : p0, f = Object.keys, d = Array.isArray;
      function h(n, t) {
        return typeof t != "object" || f(t).forEach(function(u) {
          n[u] = t[u];
        }), n;
      }
      typeof Promise > "u" || o.Promise || (o.Promise = Promise);
      var I = Object.getPrototypeOf, x = {}.hasOwnProperty;
      function y(n, t) {
        return x.call(n, t);
      }
      function P(n, t) {
        typeof t == "function" && (t = t(I(n))), (typeof Reflect > "u" ? f : Reflect.ownKeys)(t).forEach(function(u) {
          R(n, u, t[u]);
        });
      }
      var E = Object.defineProperty;
      function R(n, t, u, r) {
        E(n, t, h(u && y(u, "get") && typeof u.get == "function" ? { get: u.get, set: u.set, configurable: !0 } : { value: u, configurable: !0, writable: !0 }, r));
      }
      function V(n) {
        return { from: function(t) {
          return n.prototype = Object.create(t.prototype), R(n.prototype, "constructor", n), { extend: P.bind(null, n.prototype) };
        } };
      }
      var K = Object.getOwnPropertyDescriptor, $ = [].slice;
      function Q(n, t, u) {
        return $.call(n, t, u);
      }
      function Z(n, t) {
        return t(n);
      }
      function G(n) {
        if (!n) throw new Error("Assertion Failed");
      }
      function Y(n) {
        o.setImmediate ? setImmediate(n) : setTimeout(n, 0);
      }
      function se(n, t) {
        if (typeof t == "string" && y(n, t)) return n[t];
        if (!t) return n;
        if (typeof t != "string") {
          for (var u = [], r = 0, c = t.length; r < c; ++r) {
            var m = se(n, t[r]);
            u.push(m);
          }
          return u;
        }
        var p = t.indexOf(".");
        if (p !== -1) {
          var g = n[t.substr(0, p)];
          return g == null ? void 0 : se(g, t.substr(p + 1));
        }
      }
      function te(n, t, u) {
        if (n && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(n))) if (typeof t != "string" && "length" in t) {
          G(typeof u != "string" && "length" in u);
          for (var r = 0, c = t.length; r < c; ++r) te(n, t[r], u[r]);
        } else {
          var m, p, g = t.indexOf(".");
          g !== -1 ? (m = t.substr(0, g), (p = t.substr(g + 1)) === "" ? u === void 0 ? d(n) && !isNaN(parseInt(m)) ? n.splice(m, 1) : delete n[m] : n[m] = u : te(g = !(g = n[m]) || !y(n, m) ? n[m] = {} : g, p, u)) : u === void 0 ? d(n) && !isNaN(parseInt(t)) ? n.splice(t, 1) : delete n[t] : n[t] = u;
        }
      }
      function fe(n) {
        var t, u = {};
        for (t in n) y(n, t) && (u[t] = n[t]);
        return u;
      }
      var M = [].concat;
      function oe(n) {
        return M.apply([], n);
      }
      var Ue = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(oe([8, 16, 32, 64].map(function(n) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + n + "Array";
        });
      }))).filter(function(n) {
        return o[n];
      }), Le = new Set(Ue.map(function(n) {
        return o[n];
      })), ae = null;
      function ye(n) {
        return ae = /* @__PURE__ */ new WeakMap(), n = function t(u) {
          if (!u || typeof u != "object") return u;
          var r = ae.get(u);
          if (r) return r;
          if (d(u)) {
            r = [], ae.set(u, r);
            for (var c = 0, m = u.length; c < m; ++c) r.push(t(u[c]));
          } else if (Le.has(u.constructor)) r = u;
          else {
            var p, g = I(u);
            for (p in r = g === Object.prototype ? {} : Object.create(g), ae.set(u, r), u) y(u, p) && (r[p] = t(u[p]));
          }
          return r;
        }(n), ae = null, n;
      }
      var he = {}.toString;
      function Ce(n) {
        return he.call(n).slice(8, -1);
      }
      var xe = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", ce = typeof xe == "symbol" ? function(n) {
        var t;
        return n != null && (t = n[xe]) && t.apply(n);
      } : function() {
        return null;
      };
      function de(n, t) {
        return t = n.indexOf(t), 0 <= t && n.splice(t, 1), 0 <= t;
      }
      var we = {};
      function Ae(n) {
        var t, u, r, c;
        if (arguments.length === 1) {
          if (d(n)) return n.slice();
          if (this === we && typeof n == "string") return [n];
          if (c = ce(n)) {
            for (u = []; !(r = c.next()).done; ) u.push(r.value);
            return u;
          }
          if (n == null) return [n];
          if (typeof (t = n.length) != "number") return [n];
          for (u = new Array(t); t--; ) u[t] = n[t];
          return u;
        }
        for (t = arguments.length, u = new Array(t); t--; ) u[t] = arguments[t];
        return u;
      }
      var $e = typeof Symbol < "u" ? function(n) {
        return n[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ze = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], In = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ze), ze = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function cn(n, t) {
        this.name = n, this.message = t;
      }
      function Cn(n, t) {
        return n + ". Errors: " + Object.keys(t).map(function(u) {
          return t[u].toString();
        }).filter(function(u, r, c) {
          return c.indexOf(u) === r;
        }).join(`
`);
      }
      function xn(n, t, u, r) {
        this.failures = t, this.failedKeys = r, this.successCount = u, this.message = Cn(n, t);
      }
      function ln(n, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(u) {
          return t[u];
        }), this.failuresByPos = t, this.message = Cn(n, this.failures);
      }
      V(cn).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), V(xn).from(cn), V(ln).from(cn);
      var k = In.reduce(function(n, t) {
        return n[t] = t + "Error", n;
      }, {}), _ = cn, B = In.reduce(function(n, t) {
        var u = t + "Error";
        function r(c, m) {
          this.name = u, c ? typeof c == "string" ? (this.message = "".concat(c).concat(m ? `
 ` + m : ""), this.inner = m || null) : typeof c == "object" && (this.message = "".concat(c.name, " ").concat(c.message), this.inner = c) : (this.message = ze[t] || u, this.inner = null);
        }
        return V(r).from(_), n[t] = r, n;
      }, {});
      B.Syntax = SyntaxError, B.Type = TypeError, B.Range = RangeError;
      var le = Ze.reduce(function(n, t) {
        return n[t + "Error"] = B[t], n;
      }, {}), Xe = In.reduce(function(n, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (n[t + "Error"] = B[t]), n;
      }, {});
      function De() {
      }
      function j(n) {
        return n;
      }
      function ie(n, t) {
        return n == null || n === j ? t : function(u) {
          return t(n(u));
        };
      }
      function me(n, t) {
        return function() {
          n.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function Te(n, t) {
        return n === De ? t : function() {
          var u = n.apply(this, arguments);
          u !== void 0 && (arguments[0] = u);
          var r = this.onsuccess, c = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var m = t.apply(this, arguments);
          return r && (this.onsuccess = this.onsuccess ? me(r, this.onsuccess) : r), c && (this.onerror = this.onerror ? me(c, this.onerror) : c), m !== void 0 ? m : u;
        };
      }
      function Ie(n, t) {
        return n === De ? t : function() {
          n.apply(this, arguments);
          var u = this.onsuccess, r = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), u && (this.onsuccess = this.onsuccess ? me(u, this.onsuccess) : u), r && (this.onerror = this.onerror ? me(r, this.onerror) : r);
        };
      }
      function be(n, t) {
        return n === De ? t : function(u) {
          var r = n.apply(this, arguments);
          h(u, r);
          var c = this.onsuccess, m = this.onerror;
          return this.onsuccess = null, this.onerror = null, u = t.apply(this, arguments), c && (this.onsuccess = this.onsuccess ? me(c, this.onsuccess) : c), m && (this.onerror = this.onerror ? me(m, this.onerror) : m), r === void 0 ? u === void 0 ? void 0 : u : h(r, u);
        };
      }
      function Ne(n, t) {
        return n === De ? t : function() {
          return t.apply(this, arguments) !== !1 && n.apply(this, arguments);
        };
      }
      function Ee(n, t) {
        return n === De ? t : function() {
          var u = n.apply(this, arguments);
          if (u && typeof u.then == "function") {
            for (var r = this, c = arguments.length, m = new Array(c); c--; ) m[c] = arguments[c];
            return u.then(function() {
              return t.apply(r, m);
            });
          }
          return t.apply(this, arguments);
        };
      }
      Xe.ModifyError = xn, Xe.DexieError = cn, Xe.BulkError = ln;
      var Oe = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function qe(n) {
        Oe = n;
      }
      var Ke = {}, ke = 100, Ue = typeof Promise > "u" ? [] : function() {
        var n = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [n, I(n), n];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, I(t), n];
      }(), Ze = Ue[0], In = Ue[1], Ue = Ue[2], In = In && In.then, Qe = Ze && Ze.constructor, yn = !!Ue, on = function(n, t) {
        Fn.push([n, t]), Tn && (queueMicrotask(Xa), Tn = !1);
      }, Bn = !0, Tn = !0, Dn = [], Nn = [], xl = j, Rn = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: De, pgp: !1, env: {}, finalize: De }, re = Rn, Fn = [], Zn = 0, yl = [];
      function ee(n) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = re;
        if (typeof n != "function") {
          if (n !== Ke) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && qt(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function u(r, c) {
          try {
            c(function(m) {
              if (r._state === null) {
                if (m === r) throw new TypeError("A promise cannot be resolved with itself.");
                var p = r._lib && al();
                m && typeof m.then == "function" ? u(r, function(g, L) {
                  m instanceof ee ? m._then(g, L) : m.then(g, L);
                }) : (r._state = !0, r._value = m, Hi(r)), p && rl();
              }
            }, qt.bind(null, r));
          } catch (m) {
            qt(r, m);
          }
        }(this, n);
      }
      var Tt = { get: function() {
        var n = re, t = Gl;
        function u(r, c) {
          var m = this, p = !n.global && (n !== re || t !== Gl), g = p && !Kn(), L = new ee(function(O, b) {
            Pt(m, new ji(Wi(r, n, p, g), Wi(c, n, p, g), O, b, n));
          });
          return this._consoleTask && (L._consoleTask = this._consoleTask), L;
        }
        return u.prototype = Ke, u;
      }, set: function(n) {
        R(this, "then", n && n.prototype === Ke ? Tt : { get: function() {
          return n;
        }, set: Tt.set });
      } };
      function ji(n, t, u, r, c) {
        this.onFulfilled = typeof n == "function" ? n : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = u, this.reject = r, this.psd = c;
      }
      function qt(n, t) {
        var u, r;
        Nn.push(t), n._state === null && (u = n._lib && al(), t = xl(t), n._state = !1, n._value = t, r = n, Dn.some(function(c) {
          return c._value === r._value;
        }) || Dn.push(r), Hi(n), u && rl());
      }
      function Hi(n) {
        var t = n._listeners;
        n._listeners = [];
        for (var u = 0, r = t.length; u < r; ++u) Pt(n, t[u]);
        var c = n._PSD;
        --c.ref || c.finalize(), Zn === 0 && (++Zn, on(function() {
          --Zn == 0 && Rt();
        }, []));
      }
      function Pt(n, t) {
        if (n._state !== null) {
          var u = n._state ? t.onFulfilled : t.onRejected;
          if (u === null) return (n._state ? t.resolve : t.reject)(n._value);
          ++t.psd.ref, ++Zn, on(Ya, [u, n, t]);
        } else n._listeners.push(t);
      }
      function Ya(n, t, u) {
        try {
          var r, c = t._value;
          !t._state && Nn.length && (Nn = []), r = Oe && t._consoleTask ? t._consoleTask.run(function() {
            return n(c);
          }) : n(c), t._state || Nn.indexOf(c) !== -1 || function(m) {
            for (var p = Dn.length; p; ) if (Dn[--p]._value === m._value) return Dn.splice(p, 1);
          }(t), u.resolve(r);
        } catch (m) {
          u.reject(m);
        } finally {
          --Zn == 0 && Rt(), --u.psd.ref || u.psd.finalize();
        }
      }
      function Xa() {
        Xn(Rn, function() {
          al() && rl();
        });
      }
      function al() {
        var n = Bn;
        return Tn = Bn = !1, n;
      }
      function rl() {
        var n, t, u;
        do
          for (; 0 < Fn.length; ) for (n = Fn, Fn = [], u = n.length, t = 0; t < u; ++t) {
            var r = n[t];
            r[0].apply(null, r[1]);
          }
        while (0 < Fn.length);
        Tn = Bn = !0;
      }
      function Rt() {
        var n = Dn;
        Dn = [], n.forEach(function(r) {
          r._PSD.onunhandled.call(null, r._value, r);
        });
        for (var t = yl.slice(0), u = t.length; u; ) t[--u]();
      }
      function Zl(n) {
        return new ee(Ke, !1, n);
      }
      function Be(n, t) {
        var u = re;
        return function() {
          var r = al(), c = re;
          try {
            return Gn(u, !0), n.apply(this, arguments);
          } catch (m) {
            t && t(m);
          } finally {
            Gn(c, !1), r && rl();
          }
        };
      }
      P(ee.prototype, { then: Tt, _then: function(n, t) {
        Pt(this, new ji(null, null, n, t, re));
      }, catch: function(n) {
        if (arguments.length === 1) return this.then(null, n);
        var t = n, u = arguments[1];
        return typeof t == "function" ? this.then(null, function(r) {
          return (r instanceof t ? u : Zl)(r);
        }) : this.then(null, function(r) {
          return (r && r.name === t ? u : Zl)(r);
        });
      }, finally: function(n) {
        return this.then(function(t) {
          return ee.resolve(n()).then(function() {
            return t;
          });
        }, function(t) {
          return ee.resolve(n()).then(function() {
            return Zl(t);
          });
        });
      }, timeout: function(n, t) {
        var u = this;
        return n < 1 / 0 ? new ee(function(r, c) {
          var m = setTimeout(function() {
            return c(new B.Timeout(t));
          }, n);
          u.then(r, c).finally(clearTimeout.bind(null, m));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && R(ee.prototype, Symbol.toStringTag, "Dexie.Promise"), Rn.env = $i(), P(ee, { all: function() {
        var n = Ae.apply(null, arguments).map(zl);
        return new ee(function(t, u) {
          n.length === 0 && t([]);
          var r = n.length;
          n.forEach(function(c, m) {
            return ee.resolve(c).then(function(p) {
              n[m] = p, --r || t(n);
            }, u);
          });
        });
      }, resolve: function(n) {
        return n instanceof ee ? n : n && typeof n.then == "function" ? new ee(function(t, u) {
          n.then(t, u);
        }) : new ee(Ke, !0, n);
      }, reject: Zl, race: function() {
        var n = Ae.apply(null, arguments).map(zl);
        return new ee(function(t, u) {
          n.map(function(r) {
            return ee.resolve(r).then(t, u);
          });
        });
      }, PSD: { get: function() {
        return re;
      }, set: function(n) {
        return re = n;
      } }, totalEchoes: { get: function() {
        return Gl;
      } }, newPSD: Un, usePSD: Xn, scheduler: { get: function() {
        return on;
      }, set: function(n) {
        on = n;
      } }, rejectionMapper: { get: function() {
        return xl;
      }, set: function(n) {
        xl = n;
      } }, follow: function(n, t) {
        return new ee(function(u, r) {
          return Un(function(c, m) {
            var p = re;
            p.unhandleds = [], p.onunhandled = m, p.finalize = me(function() {
              var g, L = this;
              g = function() {
                L.unhandleds.length === 0 ? c() : m(L.unhandleds[0]);
              }, yl.push(function O() {
                g(), yl.splice(yl.indexOf(O), 1);
              }), ++Zn, on(function() {
                --Zn == 0 && Rt();
              }, []);
            }, p.finalize), n();
          }, t, u, r);
        });
      } }), Qe && (Qe.allSettled && R(ee, "allSettled", function() {
        var n = Ae.apply(null, arguments).map(zl);
        return new ee(function(t) {
          n.length === 0 && t([]);
          var u = n.length, r = new Array(u);
          n.forEach(function(c, m) {
            return ee.resolve(c).then(function(p) {
              return r[m] = { status: "fulfilled", value: p };
            }, function(p) {
              return r[m] = { status: "rejected", reason: p };
            }).then(function() {
              return --u || t(r);
            });
          });
        });
      }), Qe.any && typeof AggregateError < "u" && R(ee, "any", function() {
        var n = Ae.apply(null, arguments).map(zl);
        return new ee(function(t, u) {
          n.length === 0 && u(new AggregateError([]));
          var r = n.length, c = new Array(r);
          n.forEach(function(m, p) {
            return ee.resolve(m).then(function(g) {
              return t(g);
            }, function(g) {
              c[p] = g, --r || u(new AggregateError(c));
            });
          });
        });
      }), Qe.withResolvers && (ee.withResolvers = Qe.withResolvers));
      var Je = { awaits: 0, echoes: 0, id: 0 }, Qa = 0, Ul = [], Kl = 0, Gl = 0, Ja = 0;
      function Un(n, t, u, r) {
        var c = re, m = Object.create(c);
        return m.parent = c, m.ref = 0, m.global = !1, m.id = ++Ja, Rn.env, m.env = yn ? { Promise: ee, PromiseProp: { value: ee, configurable: !0, writable: !0 }, all: ee.all, race: ee.race, allSettled: ee.allSettled, any: ee.any, resolve: ee.resolve, reject: ee.reject } : {}, t && h(m, t), ++c.ref, m.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, r = Xn(m, n, u, r), m.ref === 0 && m.finalize(), r;
      }
      function sl() {
        return Je.id || (Je.id = ++Qa), ++Je.awaits, Je.echoes += ke, Je.id;
      }
      function Kn() {
        return !!Je.awaits && (--Je.awaits == 0 && (Je.id = 0), Je.echoes = Je.awaits * ke, !0);
      }
      function zl(n) {
        return Je.echoes && n && n.constructor === Qe ? (sl(), n.then(function(t) {
          return Kn(), t;
        }, function(t) {
          return Kn(), je(t);
        })) : n;
      }
      function er() {
        var n = Ul[Ul.length - 1];
        Ul.pop(), Gn(n, !1);
      }
      function Gn(n, t) {
        var u, r = re;
        (t ? !Je.echoes || Kl++ && n === re : !Kl || --Kl && n === re) || queueMicrotask(t ? (function(c) {
          ++Gl, Je.echoes && --Je.echoes != 0 || (Je.echoes = Je.awaits = Je.id = 0), Ul.push(re), Gn(c, !0);
        }).bind(null, n) : er), n !== re && (re = n, r === Rn && (Rn.env = $i()), yn && (u = Rn.env.Promise, t = n.env, (r.global || n.global) && (Object.defineProperty(o, "Promise", t.PromiseProp), u.all = t.all, u.race = t.race, u.resolve = t.resolve, u.reject = t.reject, t.allSettled && (u.allSettled = t.allSettled), t.any && (u.any = t.any))));
      }
      function $i() {
        var n = o.Promise;
        return yn ? { Promise: n, PromiseProp: Object.getOwnPropertyDescriptor(o, "Promise"), all: n.all, race: n.race, allSettled: n.allSettled, any: n.any, resolve: n.resolve, reject: n.reject } : {};
      }
      function Xn(n, t, u, r, c) {
        var m = re;
        try {
          return Gn(n, !0), t(u, r, c);
        } finally {
          Gn(m, !1);
        }
      }
      function Wi(n, t, u, r) {
        return typeof n != "function" ? n : function() {
          var c = re;
          u && sl(), Gn(t, !0);
          try {
            return n.apply(this, arguments);
          } finally {
            Gn(c, !1), r && queueMicrotask(Kn);
          }
        };
      }
      function At(n) {
        Promise === Qe && Je.echoes === 0 ? Kl === 0 ? n() : enqueueNativeMicroTask(n) : setTimeout(n, 0);
      }
      ("" + In).indexOf("[native code]") === -1 && (sl = Kn = De);
      var je = ee.reject, Qn = "", An = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Yi = "String expected.", cl = [], jl = "__dbnames", Et = "readonly", _t = "readwrite";
      function Jn(n, t) {
        return n ? t ? function() {
          return n.apply(this, arguments) && t.apply(this, arguments);
        } : n : t;
      }
      var Xi = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Hl(n) {
        return typeof n != "string" || /\./.test(n) ? function(t) {
          return t;
        } : function(t) {
          return t[n] === void 0 && n in t && delete (t = ye(t))[n], t;
        };
      }
      function Qi() {
        throw B.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Se(n, t) {
        try {
          var u = Ji(n), r = Ji(t);
          if (u !== r) return u === "Array" ? 1 : r === "Array" ? -1 : u === "binary" ? 1 : r === "binary" ? -1 : u === "string" ? 1 : r === "string" ? -1 : u === "Date" ? 1 : r !== "Date" ? NaN : -1;
          switch (u) {
            case "number":
            case "Date":
            case "string":
              return t < n ? 1 : n < t ? -1 : 0;
            case "binary":
              return function(c, m) {
                for (var p = c.length, g = m.length, L = p < g ? p : g, O = 0; O < L; ++O) if (c[O] !== m[O]) return c[O] < m[O] ? -1 : 1;
                return p === g ? 0 : p < g ? -1 : 1;
              }(eu(n), eu(t));
            case "Array":
              return function(c, m) {
                for (var p = c.length, g = m.length, L = p < g ? p : g, O = 0; O < L; ++O) {
                  var b = Se(c[O], m[O]);
                  if (b !== 0) return b;
                }
                return p === g ? 0 : p < g ? -1 : 1;
              }(n, t);
          }
        } catch {
        }
        return NaN;
      }
      function Ji(n) {
        var t = typeof n;
        return t != "object" ? t : ArrayBuffer.isView(n) ? "binary" : (n = Ce(n), n === "ArrayBuffer" ? "binary" : n);
      }
      function eu(n) {
        return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n);
      }
      function $l(n, t, u) {
        var r = n.schema.yProps;
        return r ? (t && 0 < u.numFailures && (t = t.filter(function(c, m) {
          return !u.failures[m];
        })), Promise.all(r.map(function(c) {
          return c = c.updatesTable, t ? n.db.table(c).where("k").anyOf(t).delete() : n.db.table(c).clear();
        })).then(function() {
          return u;
        })) : u;
      }
      var nu = (Ve.prototype._trans = function(n, t, u) {
        var r = this._tx || re.trans, c = this.name, m = Oe && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(n === "readonly" ? "read" : "write", " ").concat(this.name));
        function p(O, b, v) {
          if (!v.schema[c]) throw new B.NotFound("Table " + c + " not part of transaction");
          return t(v.idbtrans, v);
        }
        var g = al();
        try {
          var L = r && r.db._novip === this.db._novip ? r === re.trans ? r._promise(n, p, u) : Un(function() {
            return r._promise(n, p, u);
          }, { trans: r, transless: re.transless || re }) : function O(b, v, T, D) {
            if (b.idbdb && (b._state.openComplete || re.letThrough || b._vip)) {
              var w = b._createTransaction(v, T, b._dbSchema);
              try {
                w.create(), b._state.PR1398_maxLoop = 3;
              } catch (C) {
                return C.name === k.InvalidState && b.isOpen() && 0 < --b._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), b.close({ disableAutoOpen: !1 }), b.open().then(function() {
                  return O(b, v, T, D);
                })) : je(C);
              }
              return w._promise(v, function(C, S) {
                return Un(function() {
                  return re.trans = w, D(C, S, w);
                });
              }).then(function(C) {
                if (v === "readwrite") try {
                  w.idbtrans.commit();
                } catch {
                }
                return v === "readonly" ? C : w._completion.then(function() {
                  return C;
                });
              });
            }
            if (b._state.openComplete) return je(new B.DatabaseClosed(b._state.dbOpenError));
            if (!b._state.isBeingOpened) {
              if (!b._state.autoOpen) return je(new B.DatabaseClosed());
              b.open().catch(De);
            }
            return b._state.dbReadyPromise.then(function() {
              return O(b, v, T, D);
            });
          }(this.db, n, [this.name], p);
          return m && (L._consoleTask = m, L = L.catch(function(O) {
            return console.trace(O), je(O);
          })), L;
        } finally {
          g && rl();
        }
      }, Ve.prototype.get = function(n, t) {
        var u = this;
        return n && n.constructor === Object ? this.where(n).first(t) : n == null ? je(new B.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(r) {
          return u.core.get({ trans: r, key: n }).then(function(c) {
            return u.hook.reading.fire(c);
          });
        }).then(t);
      }, Ve.prototype.where = function(n) {
        if (typeof n == "string") return new this.db.WhereClause(this, n);
        if (d(n)) return new this.db.WhereClause(this, "[".concat(n.join("+"), "]"));
        var t = f(n);
        if (t.length === 1) return this.where(t[0]).equals(n[t[0]]);
        var u = this.schema.indexes.concat(this.schema.primKey).filter(function(g) {
          if (g.compound && t.every(function(O) {
            return 0 <= g.keyPath.indexOf(O);
          })) {
            for (var L = 0; L < t.length; ++L) if (t.indexOf(g.keyPath[L]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(g, L) {
          return g.keyPath.length - L.keyPath.length;
        })[0];
        if (u && this.db._maxKey !== Qn) {
          var m = u.keyPath.slice(0, t.length);
          return this.where(m).equals(m.map(function(L) {
            return n[L];
          }));
        }
        !u && Oe && console.warn("The query ".concat(JSON.stringify(n), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var r = this.schema.idxByName;
        function c(g, L) {
          return Se(g, L) === 0;
        }
        var p = t.reduce(function(v, L) {
          var O = v[0], b = v[1], v = r[L], T = n[L];
          return [O || v, O || !v ? Jn(b, v && v.multi ? function(D) {
            return D = se(D, L), d(D) && D.some(function(w) {
              return c(T, w);
            });
          } : function(D) {
            return c(T, se(D, L));
          }) : b];
        }, [null, null]), m = p[0], p = p[1];
        return m ? this.where(m.name).equals(n[m.keyPath]).filter(p) : u ? this.filter(p) : this.where(t).equals("");
      }, Ve.prototype.filter = function(n) {
        return this.toCollection().and(n);
      }, Ve.prototype.count = function(n) {
        return this.toCollection().count(n);
      }, Ve.prototype.offset = function(n) {
        return this.toCollection().offset(n);
      }, Ve.prototype.limit = function(n) {
        return this.toCollection().limit(n);
      }, Ve.prototype.each = function(n) {
        return this.toCollection().each(n);
      }, Ve.prototype.toArray = function(n) {
        return this.toCollection().toArray(n);
      }, Ve.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ve.prototype.orderBy = function(n) {
        return new this.db.Collection(new this.db.WhereClause(this, d(n) ? "[".concat(n.join("+"), "]") : n));
      }, Ve.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ve.prototype.mapToClass = function(n) {
        var t, u = this.db, r = this.name;
        function c() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = n).prototype instanceof Qi && (function(L, O) {
          if (typeof O != "function" && O !== null) throw new TypeError("Class extends value " + String(O) + " is not a constructor or null");
          function b() {
            this.constructor = L;
          }
          i(L, O), L.prototype = O === null ? Object.create(O) : (b.prototype = O.prototype, new b());
        }(c, t = n), Object.defineProperty(c.prototype, "db", { get: function() {
          return u;
        }, enumerable: !1, configurable: !0 }), c.prototype.table = function() {
          return r;
        }, n = c);
        for (var m = /* @__PURE__ */ new Set(), p = n.prototype; p; p = I(p)) Object.getOwnPropertyNames(p).forEach(function(L) {
          return m.add(L);
        });
        function g(L) {
          if (!L) return L;
          var O, b = Object.create(n.prototype);
          for (O in L) if (!m.has(O)) try {
            b[O] = L[O];
          } catch {
          }
          return b;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = g, this.hook("reading", g), n;
      }, Ve.prototype.defineClass = function() {
        return this.mapToClass(function(n) {
          h(this, n);
        });
      }, Ve.prototype.add = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, m = r.keyPath, p = n;
        return m && c && (p = Hl(m)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "add", keys: t != null ? [t] : null, values: [p] });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (m) try {
            te(n, m, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.update = function(n, t) {
        return typeof n != "object" || d(n) ? this.where(":id").equals(n).modify(t) : (n = se(n, this.schema.primKey.keyPath), n === void 0 ? je(new B.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(n).modify(t));
      }, Ve.prototype.put = function(n, t) {
        var u = this, r = this.schema.primKey, c = r.auto, m = r.keyPath, p = n;
        return m && c && (p = Hl(m)(n)), this._trans("readwrite", function(g) {
          return u.core.mutate({ trans: g, type: "put", values: [p], keys: t != null ? [t] : null });
        }).then(function(g) {
          return g.numFailures ? ee.reject(g.failures[0]) : g.lastResult;
        }).then(function(g) {
          if (m) try {
            te(n, m, g);
          } catch {
          }
          return g;
        });
      }, Ve.prototype.delete = function(n) {
        var t = this;
        return this._trans("readwrite", function(u) {
          return t.core.mutate({ trans: u, type: "delete", keys: [n] }).then(function(r) {
            return $l(t, [n], r);
          }).then(function(r) {
            return r.numFailures ? ee.reject(r.failures[0]) : void 0;
          });
        });
      }, Ve.prototype.clear = function() {
        var n = this;
        return this._trans("readwrite", function(t) {
          return n.core.mutate({ trans: t, type: "deleteRange", range: Xi }).then(function(u) {
            return $l(n, null, u);
          });
        }).then(function(t) {
          return t.numFailures ? ee.reject(t.failures[0]) : void 0;
        });
      }, Ve.prototype.bulkGet = function(n) {
        var t = this;
        return this._trans("readonly", function(u) {
          return t.core.getMany({ keys: n, trans: u }).then(function(r) {
            return r.map(function(c) {
              return t.hook.reading.fire(c);
            });
          });
        });
      }, Ve.prototype.bulkAdd = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, m = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new B.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new B.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Hl(O)) : n;
          return r.core.mutate({ trans: p, type: "add", keys: c, values: O, wantResults: m }).then(function(w) {
            var v = w.numFailures, T = w.results, D = w.lastResult, w = w.failures;
            if (v === 0) return m ? T : D;
            throw new ln("".concat(r.name, ".bulkAdd(): ").concat(v, " of ").concat(L, " operations failed"), w);
          });
        });
      }, Ve.prototype.bulkPut = function(n, t, u) {
        var r = this, c = Array.isArray(t) ? t : void 0, m = (u = u || (c ? void 0 : t)) ? u.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var O = r.schema.primKey, g = O.auto, O = O.keyPath;
          if (O && c) throw new B.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new B.InvalidArgument("Arguments objects and keys must have the same length");
          var L = n.length, O = O && g ? n.map(Hl(O)) : n;
          return r.core.mutate({ trans: p, type: "put", keys: c, values: O, wantResults: m }).then(function(w) {
            var v = w.numFailures, T = w.results, D = w.lastResult, w = w.failures;
            if (v === 0) return m ? T : D;
            throw new ln("".concat(r.name, ".bulkPut(): ").concat(v, " of ").concat(L, " operations failed"), w);
          });
        });
      }, Ve.prototype.bulkUpdate = function(n) {
        var t = this, u = this.core, r = n.map(function(p) {
          return p.key;
        }), c = n.map(function(p) {
          return p.changes;
        }), m = [];
        return this._trans("readwrite", function(p) {
          return u.getMany({ trans: p, keys: r, cache: "clone" }).then(function(g) {
            var L = [], O = [];
            n.forEach(function(v, T) {
              var D = v.key, w = v.changes, C = g[T];
              if (C) {
                for (var S = 0, q = Object.keys(w); S < q.length; S++) {
                  var A = q[S], N = w[A];
                  if (A === t.schema.primKey.keyPath) {
                    if (Se(N, D) !== 0) throw new B.Constraint("Cannot update primary key in bulkUpdate()");
                  } else te(C, A, N);
                }
                m.push(T), L.push(D), O.push(C);
              }
            });
            var b = L.length;
            return u.mutate({ trans: p, type: "put", keys: L, values: O, updates: { keys: r, changeSpecs: c } }).then(function(v) {
              var T = v.numFailures, D = v.failures;
              if (T === 0) return b;
              for (var w = 0, C = Object.keys(D); w < C.length; w++) {
                var S, q = C[w], A = m[Number(q)];
                A != null && (S = D[q], delete D[q], D[A] = S);
              }
              throw new ln("".concat(t.name, ".bulkUpdate(): ").concat(T, " of ").concat(b, " operations failed"), D);
            });
          });
        });
      }, Ve.prototype.bulkDelete = function(n) {
        var t = this, u = n.length;
        return this._trans("readwrite", function(r) {
          return t.core.mutate({ trans: r, type: "delete", keys: n }).then(function(c) {
            return $l(t, n, c);
          });
        }).then(function(p) {
          var c = p.numFailures, m = p.lastResult, p = p.failures;
          if (c === 0) return m;
          throw new ln("".concat(t.name, ".bulkDelete(): ").concat(c, " of ").concat(u, " operations failed"), p);
        });
      }, Ve);
      function Ve() {
      }
      function Il(n) {
        function t(p, g) {
          if (g) {
            for (var L = arguments.length, O = new Array(L - 1); --L; ) O[L - 1] = arguments[L];
            return u[p].subscribe.apply(null, O), n;
          }
          if (typeof p == "string") return u[p];
        }
        var u = {};
        t.addEventType = m;
        for (var r = 1, c = arguments.length; r < c; ++r) m(arguments[r]);
        return t;
        function m(p, g, L) {
          if (typeof p != "object") {
            var O;
            g = g || Ne;
            var b = { subscribers: [], fire: L = L || De, subscribe: function(v) {
              b.subscribers.indexOf(v) === -1 && (b.subscribers.push(v), b.fire = g(b.fire, v));
            }, unsubscribe: function(v) {
              b.subscribers = b.subscribers.filter(function(T) {
                return T !== v;
              }), b.fire = b.subscribers.reduce(g, L);
            } };
            return u[p] = t[p] = b;
          }
          f(O = p).forEach(function(v) {
            var T = O[v];
            if (d(T)) m(v, O[v][0], O[v][1]);
            else {
              if (T !== "asap") throw new B.InvalidArgument("Invalid event config");
              var D = m(v, j, function() {
                for (var w = arguments.length, C = new Array(w); w--; ) C[w] = arguments[w];
                D.subscribers.forEach(function(S) {
                  Y(function() {
                    S.apply(null, C);
                  });
                });
              });
            }
          });
        }
      }
      function Ll(n, t) {
        return V(t).from({ prototype: n }), t;
      }
      function ol(n, t) {
        return !(n.filter || n.algorithm || n.or) && (t ? n.justLimit : !n.replayFilter);
      }
      function Nt(n, t) {
        n.filter = Jn(n.filter, t);
      }
      function Ft(n, t, u) {
        var r = n.replayFilter;
        n.replayFilter = r ? function() {
          return Jn(r(), t());
        } : t, n.justLimit = u && !r;
      }
      function Wl(n, t) {
        if (n.isPrimKey) return t.primaryKey;
        var u = t.getIndexByKeyPath(n.index);
        if (!u) throw new B.Schema("KeyPath " + n.index + " on object store " + t.name + " is not indexed");
        return u;
      }
      function lu(n, t, u) {
        var r = Wl(n, t.schema);
        return t.openCursor({ trans: u, values: !n.keysOnly, reverse: n.dir === "prev", unique: !!n.unique, query: { index: r, range: n.range } });
      }
      function Yl(n, t, u, r) {
        var c = n.replayFilter ? Jn(n.filter, n.replayFilter()) : n.filter;
        if (n.or) {
          var m = {}, p = function(g, L, O) {
            var b, v;
            c && !c(L, O, function(T) {
              return L.stop(T);
            }, function(T) {
              return L.fail(T);
            }) || ((v = "" + (b = L.primaryKey)) == "[object ArrayBuffer]" && (v = "" + new Uint8Array(b)), y(m, v) || (m[v] = !0, t(g, L, O)));
          };
          return Promise.all([n.or._iterate(p, u), tu(lu(n, r, u), n.algorithm, p, !n.keysOnly && n.valueMapper)]);
        }
        return tu(lu(n, r, u), Jn(n.algorithm, c), t, !n.keysOnly && n.valueMapper);
      }
      function tu(n, t, u, r) {
        var c = Be(r ? function(m, p, g) {
          return u(r(m), p, g);
        } : u);
        return n.then(function(m) {
          if (m) return m.start(function() {
            var p = function() {
              return m.continue();
            };
            t && !t(m, function(g) {
              return p = g;
            }, function(g) {
              m.stop(g), p = De;
            }, function(g) {
              m.fail(g), p = De;
            }) || c(m.value, m, function(g) {
              return p = g;
            }), p();
          });
        });
      }
      var Dl = (iu.prototype.execute = function(n) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var u = t.add;
          if (d(u)) return s(s([], d(n) ? n : [], !0), u).sort();
          if (typeof u == "number") return (Number(n) || 0) + u;
          if (typeof u == "bigint") try {
            return BigInt(n) + u;
          } catch {
            return BigInt(0) + u;
          }
          throw new TypeError("Invalid term ".concat(u));
        }
        if (t.remove !== void 0) {
          var r = t.remove;
          if (d(r)) return d(n) ? n.filter(function(c) {
            return !r.includes(c);
          }).sort() : [];
          if (typeof r == "number") return Number(n) - r;
          if (typeof r == "bigint") try {
            return BigInt(n) - r;
          } catch {
            return BigInt(0) - r;
          }
          throw new TypeError("Invalid subtrahend ".concat(r));
        }
        return u = (u = t.replacePrefix) === null || u === void 0 ? void 0 : u[0], u && typeof n == "string" && n.startsWith(u) ? t.replacePrefix[1] + n.substring(u.length) : n;
      }, iu);
      function iu(n) {
        this["@@propmod"] = n;
      }
      var nr = (Re.prototype._read = function(n, t) {
        var u = this._ctx;
        return u.error ? u.table._trans(null, je.bind(null, u.error)) : u.table._trans("readonly", n).then(t);
      }, Re.prototype._write = function(n) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, je.bind(null, t.error)) : t.table._trans("readwrite", n, "locked");
      }, Re.prototype._addAlgorithm = function(n) {
        var t = this._ctx;
        t.algorithm = Jn(t.algorithm, n);
      }, Re.prototype._iterate = function(n, t) {
        return Yl(this._ctx, n, t, this._ctx.table.core);
      }, Re.prototype.clone = function(n) {
        var t = Object.create(this.constructor.prototype), u = Object.create(this._ctx);
        return n && h(u, n), t._ctx = u, t;
      }, Re.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Re.prototype.each = function(n) {
        var t = this._ctx;
        return this._read(function(u) {
          return Yl(t, n, u, t.table.core);
        });
      }, Re.prototype.count = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx, c = r.table.core;
          if (ol(r, !0)) return c.count({ trans: u, query: { index: Wl(r, c.schema), range: r.range } }).then(function(p) {
            return Math.min(p, r.limit);
          });
          var m = 0;
          return Yl(r, function() {
            return ++m, !1;
          }, u, c).then(function() {
            return m;
          });
        }).then(n);
      }, Re.prototype.sortBy = function(n, t) {
        var u = n.split(".").reverse(), r = u[0], c = u.length - 1;
        function m(L, O) {
          return O ? m(L[u[O]], O - 1) : L[r];
        }
        var p = this._ctx.dir === "next" ? 1 : -1;
        function g(L, O) {
          return Se(m(L, c), m(O, c)) * p;
        }
        return this.toArray(function(L) {
          return L.sort(g);
        }).then(t);
      }, Re.prototype.toArray = function(n) {
        var t = this;
        return this._read(function(u) {
          var r = t._ctx;
          if (r.dir === "next" && ol(r, !0) && 0 < r.limit) {
            var c = r.valueMapper, m = Wl(r, r.table.core.schema);
            return r.table.core.query({ trans: u, limit: r.limit, values: !0, query: { index: m, range: r.range } }).then(function(g) {
              return g = g.result, c ? g.map(c) : g;
            });
          }
          var p = [];
          return Yl(r, function(g) {
            return p.push(g);
          }, u, r.table.core).then(function() {
            return p;
          });
        }, n);
      }, Re.prototype.offset = function(n) {
        var t = this._ctx;
        return n <= 0 || (t.offset += n, ol(t) ? Ft(t, function() {
          var u = n;
          return function(r, c) {
            return u === 0 || (u === 1 ? --u : c(function() {
              r.advance(u), u = 0;
            }), !1);
          };
        }) : Ft(t, function() {
          var u = n;
          return function() {
            return --u < 0;
          };
        })), this;
      }, Re.prototype.limit = function(n) {
        return this._ctx.limit = Math.min(this._ctx.limit, n), Ft(this._ctx, function() {
          var t = n;
          return function(u, r, c) {
            return --t <= 0 && r(c), 0 <= t;
          };
        }, !0), this;
      }, Re.prototype.until = function(n, t) {
        return Nt(this._ctx, function(u, r, c) {
          return !n(u.value) || (r(c), t);
        }), this;
      }, Re.prototype.first = function(n) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(n);
      }, Re.prototype.last = function(n) {
        return this.reverse().first(n);
      }, Re.prototype.filter = function(n) {
        var t;
        return Nt(this._ctx, function(u) {
          return n(u.value);
        }), (t = this._ctx).isMatch = Jn(t.isMatch, n), this;
      }, Re.prototype.and = function(n) {
        return this.filter(n);
      }, Re.prototype.or = function(n) {
        return new this.db.WhereClause(this._ctx.table, n, this);
      }, Re.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Re.prototype.desc = function() {
        return this.reverse();
      }, Re.prototype.eachKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.key, r);
        });
      }, Re.prototype.eachUniqueKey = function(n) {
        return this._ctx.unique = "unique", this.eachKey(n);
      }, Re.prototype.eachPrimaryKey = function(n) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(u, r) {
          n(r.primaryKey, r);
        });
      }, Re.prototype.keys = function(n) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.key);
        }).then(function() {
          return u;
        }).then(n);
      }, Re.prototype.primaryKeys = function(n) {
        var t = this._ctx;
        if (t.dir === "next" && ol(t, !0) && 0 < t.limit) return this._read(function(r) {
          var c = Wl(t, t.table.core.schema);
          return t.table.core.query({ trans: r, values: !1, limit: t.limit, query: { index: c, range: t.range } });
        }).then(function(r) {
          return r.result;
        }).then(n);
        t.keysOnly = !t.isMatch;
        var u = [];
        return this.each(function(r, c) {
          u.push(c.primaryKey);
        }).then(function() {
          return u;
        }).then(n);
      }, Re.prototype.uniqueKeys = function(n) {
        return this._ctx.unique = "unique", this.keys(n);
      }, Re.prototype.firstKey = function(n) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(n);
      }, Re.prototype.lastKey = function(n) {
        return this.reverse().firstKey(n);
      }, Re.prototype.distinct = function() {
        var n = this._ctx, n = n.index && n.table.schema.idxByName[n.index];
        if (!n || !n.multi) return this;
        var t = {};
        return Nt(this._ctx, function(c) {
          var r = c.primaryKey.toString(), c = y(t, r);
          return t[r] = !0, !c;
        }), this;
      }, Re.prototype.modify = function(n) {
        var t = this, u = this._ctx;
        return this._write(function(r) {
          var c, m, p;
          p = typeof n == "function" ? n : (c = f(n), m = c.length, function(q) {
            for (var A = !1, N = 0; N < m; ++N) {
              var F = c[N], U = n[F], W = se(q, F);
              U instanceof Dl ? (te(q, F, U.execute(W)), A = !0) : W !== U && (te(q, F, U), A = !0);
            }
            return A;
          });
          var g = u.table.core, v = g.schema.primaryKey, L = v.outbound, O = v.extractKey, b = 200, v = t.db._options.modifyChunkSize;
          v && (b = typeof v == "object" ? v[g.name] || v["*"] || 200 : v);
          function T(q, F) {
            var N = F.failures, F = F.numFailures;
            w += q - F;
            for (var U = 0, W = f(N); U < W.length; U++) {
              var z = W[U];
              D.push(N[z]);
            }
          }
          var D = [], w = 0, C = [], S = n === uu;
          return t.clone().primaryKeys().then(function(q) {
            function A(F) {
              var U = Math.min(b, q.length - F), W = q.slice(F, F + U);
              return (S ? Promise.resolve([]) : g.getMany({ trans: r, keys: W, cache: "immutable" })).then(function(z) {
                var H = [], J = [], X = L ? [] : null, ne = S ? W : [];
                if (!S) for (var ve = 0; ve < U; ++ve) {
                  var Pe = z[ve], ge = { value: ye(Pe), primKey: q[F + ve] };
                  p.call(ge, ge.value, ge) !== !1 && (ge.value == null ? ne.push(q[F + ve]) : L || Se(O(Pe), O(ge.value)) === 0 ? (J.push(ge.value), L && X.push(q[F + ve])) : (ne.push(q[F + ve]), H.push(ge.value)));
                }
                return Promise.resolve(0 < H.length && g.mutate({ trans: r, type: "add", values: H }).then(function(Ge) {
                  for (var pe in Ge.failures) ne.splice(parseInt(pe), 1);
                  T(H.length, Ge);
                })).then(function() {
                  return (0 < J.length || N && typeof n == "object") && g.mutate({ trans: r, type: "put", keys: X, values: J, criteria: N, changeSpec: typeof n != "function" && n, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return T(J.length, Ge);
                  });
                }).then(function() {
                  return (0 < ne.length || N && S) && g.mutate({ trans: r, type: "delete", keys: ne, criteria: N, isAdditionalChunk: 0 < F }).then(function(Ge) {
                    return $l(u.table, ne, Ge);
                  }).then(function(Ge) {
                    return T(ne.length, Ge);
                  });
                }).then(function() {
                  return q.length > F + U && A(F + b);
                });
              });
            }
            var N = ol(u) && u.limit === 1 / 0 && (typeof n != "function" || S) && { index: u.index, range: u.range };
            return A(0).then(function() {
              if (0 < D.length) throw new xn("Error modifying one or more objects", D, w, C);
              return q.length;
            });
          });
        });
      }, Re.prototype.delete = function() {
        var n = this._ctx, t = n.range;
        return !ol(n) || n.table.schema.yProps || !n.isPrimKey && t.type !== 3 ? this.modify(uu) : this._write(function(u) {
          var r = n.table.core.schema.primaryKey, c = t;
          return n.table.core.count({ trans: u, query: { index: r, range: c } }).then(function(m) {
            return n.table.core.mutate({ trans: u, type: "deleteRange", range: c }).then(function(L) {
              var g = L.failures, L = L.numFailures;
              if (L) throw new xn("Could not delete some values", Object.keys(g).map(function(O) {
                return g[O];
              }), m - L);
              return m - L;
            });
          });
        });
      }, Re);
      function Re() {
      }
      var uu = function(n, t) {
        return t.value = null;
      };
      function lr(n, t) {
        return n < t ? -1 : n === t ? 0 : 1;
      }
      function tr(n, t) {
        return t < n ? -1 : n === t ? 0 : 1;
      }
      function dn(n, t, u) {
        return n = n instanceof ru ? new n.Collection(n) : n, n._ctx.error = new (u || TypeError)(t), n;
      }
      function ml(n) {
        return new n.Collection(n, function() {
          return au("");
        }).limit(0);
      }
      function Xl(n, t, u, r) {
        var c, m, p, g, L, O, b, v = u.length;
        if (!u.every(function(w) {
          return typeof w == "string";
        })) return dn(n, Yi);
        function T(w) {
          c = w === "next" ? function(S) {
            return S.toUpperCase();
          } : function(S) {
            return S.toLowerCase();
          }, m = w === "next" ? function(S) {
            return S.toLowerCase();
          } : function(S) {
            return S.toUpperCase();
          }, p = w === "next" ? lr : tr;
          var C = u.map(function(S) {
            return { lower: m(S), upper: c(S) };
          }).sort(function(S, q) {
            return p(S.lower, q.lower);
          });
          g = C.map(function(S) {
            return S.upper;
          }), L = C.map(function(S) {
            return S.lower;
          }), b = (O = w) === "next" ? "" : r;
        }
        T("next"), n = new n.Collection(n, function() {
          return zn(g[0], L[v - 1] + r);
        }), n._ondirectionchange = function(w) {
          T(w);
        };
        var D = 0;
        return n._addAlgorithm(function(w, C, S) {
          var q = w.key;
          if (typeof q != "string") return !1;
          var A = m(q);
          if (t(A, L, D)) return !0;
          for (var N = null, F = D; F < v; ++F) {
            var U = function(W, z, H, J, X, ne) {
              for (var ve = Math.min(W.length, J.length), Pe = -1, ge = 0; ge < ve; ++ge) {
                var Ge = z[ge];
                if (Ge !== J[ge]) return X(W[ge], H[ge]) < 0 ? W.substr(0, ge) + H[ge] + H.substr(ge + 1) : X(W[ge], J[ge]) < 0 ? W.substr(0, ge) + J[ge] + H.substr(ge + 1) : 0 <= Pe ? W.substr(0, Pe) + z[Pe] + H.substr(Pe + 1) : null;
                X(W[ge], Ge) < 0 && (Pe = ge);
              }
              return ve < J.length && ne === "next" ? W + H.substr(W.length) : ve < W.length && ne === "prev" ? W.substr(0, H.length) : Pe < 0 ? null : W.substr(0, Pe) + J[Pe] + H.substr(Pe + 1);
            }(q, A, g[F], L[F], p, O);
            U === null && N === null ? D = F + 1 : (N === null || 0 < p(N, U)) && (N = U);
          }
          return C(N !== null ? function() {
            w.continue(N + b);
          } : S), !1;
        }), n;
      }
      function zn(n, t, u, r) {
        return { type: 2, lower: n, upper: t, lowerOpen: u, upperOpen: r };
      }
      function au(n) {
        return { type: 1, lower: n, upper: n };
      }
      var ru = (Object.defineProperty(en.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), en.prototype.between = function(n, t, u, r) {
        u = u !== !1, r = r === !0;
        try {
          return 0 < this._cmp(n, t) || this._cmp(n, t) === 0 && (u || r) && (!u || !r) ? ml(this) : new this.Collection(this, function() {
            return zn(n, t, !u, !r);
          });
        } catch {
          return dn(this, An);
        }
      }, en.prototype.equals = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return au(n);
        });
      }, en.prototype.above = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return zn(n, void 0, !0);
        });
      }, en.prototype.aboveOrEqual = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return zn(n, void 0, !1);
        });
      }, en.prototype.below = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return zn(void 0, n, !1, !0);
        });
      }, en.prototype.belowOrEqual = function(n) {
        return n == null ? dn(this, An) : new this.Collection(this, function() {
          return zn(void 0, n);
        });
      }, en.prototype.startsWith = function(n) {
        return typeof n != "string" ? dn(this, Yi) : this.between(n, n + Qn, !0, !0);
      }, en.prototype.startsWithIgnoreCase = function(n) {
        return n === "" ? this.startsWith(n) : Xl(this, function(t, u) {
          return t.indexOf(u[0]) === 0;
        }, [n], Qn);
      }, en.prototype.equalsIgnoreCase = function(n) {
        return Xl(this, function(t, u) {
          return t === u[0];
        }, [n], "");
      }, en.prototype.anyOfIgnoreCase = function() {
        var n = Ae.apply(we, arguments);
        return n.length === 0 ? ml(this) : Xl(this, function(t, u) {
          return u.indexOf(t) !== -1;
        }, n, "");
      }, en.prototype.startsWithAnyOfIgnoreCase = function() {
        var n = Ae.apply(we, arguments);
        return n.length === 0 ? ml(this) : Xl(this, function(t, u) {
          return u.some(function(r) {
            return t.indexOf(r) === 0;
          });
        }, n, Qn);
      }, en.prototype.anyOf = function() {
        var n = this, t = Ae.apply(we, arguments), u = this._cmp;
        try {
          t.sort(u);
        } catch {
          return dn(this, An);
        }
        if (t.length === 0) return ml(this);
        var r = new this.Collection(this, function() {
          return zn(t[0], t[t.length - 1]);
        });
        r._ondirectionchange = function(m) {
          u = m === "next" ? n._ascending : n._descending, t.sort(u);
        };
        var c = 0;
        return r._addAlgorithm(function(m, p, g) {
          for (var L = m.key; 0 < u(L, t[c]); ) if (++c === t.length) return p(g), !1;
          return u(L, t[c]) === 0 || (p(function() {
            m.continue(t[c]);
          }), !1);
        }), r;
      }, en.prototype.notEqual = function(n) {
        return this.inAnyRange([[-1 / 0, n], [n, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, en.prototype.noneOf = function() {
        var n = Ae.apply(we, arguments);
        if (n.length === 0) return new this.Collection(this);
        try {
          n.sort(this._ascending);
        } catch {
          return dn(this, An);
        }
        var t = n.reduce(function(u, r) {
          return u ? u.concat([[u[u.length - 1][1], r]]) : [[-1 / 0, r]];
        }, null);
        return t.push([n[n.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, en.prototype.inAnyRange = function(q, t) {
        var u = this, r = this._cmp, c = this._ascending, m = this._descending, p = this._min, g = this._max;
        if (q.length === 0) return ml(this);
        if (!q.every(function(A) {
          return A[0] !== void 0 && A[1] !== void 0 && c(A[0], A[1]) <= 0;
        })) return dn(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", B.InvalidArgument);
        var L = !t || t.includeLowers !== !1, O = t && t.includeUppers === !0, b, v = c;
        function T(A, N) {
          return v(A[0], N[0]);
        }
        try {
          (b = q.reduce(function(A, N) {
            for (var F = 0, U = A.length; F < U; ++F) {
              var W = A[F];
              if (r(N[0], W[1]) < 0 && 0 < r(N[1], W[0])) {
                W[0] = p(W[0], N[0]), W[1] = g(W[1], N[1]);
                break;
              }
            }
            return F === U && A.push(N), A;
          }, [])).sort(T);
        } catch {
          return dn(this, An);
        }
        var D = 0, w = O ? function(A) {
          return 0 < c(A, b[D][1]);
        } : function(A) {
          return 0 <= c(A, b[D][1]);
        }, C = L ? function(A) {
          return 0 < m(A, b[D][0]);
        } : function(A) {
          return 0 <= m(A, b[D][0]);
        }, S = w, q = new this.Collection(this, function() {
          return zn(b[0][0], b[b.length - 1][1], !L, !O);
        });
        return q._ondirectionchange = function(A) {
          v = A === "next" ? (S = w, c) : (S = C, m), b.sort(T);
        }, q._addAlgorithm(function(A, N, F) {
          for (var U, W = A.key; S(W); ) if (++D === b.length) return N(F), !1;
          return !w(U = W) && !C(U) || (u._cmp(W, b[D][1]) === 0 || u._cmp(W, b[D][0]) === 0 || N(function() {
            v === c ? A.continue(b[D][0]) : A.continue(b[D][1]);
          }), !1);
        }), q;
      }, en.prototype.startsWithAnyOf = function() {
        var n = Ae.apply(we, arguments);
        return n.every(function(t) {
          return typeof t == "string";
        }) ? n.length === 0 ? ml(this) : this.inAnyRange(n.map(function(t) {
          return [t, t + Qn];
        })) : dn(this, "startsWithAnyOf() only works with strings");
      }, en);
      function en() {
      }
      function wn(n) {
        return Be(function(t) {
          return Ol(t), n(t.target.error), !1;
        });
      }
      function Ol(n) {
        n.stopPropagation && n.stopPropagation(), n.preventDefault && n.preventDefault();
      }
      var wl = "storagemutated", Mt = "x-storagemutated-1", jn = Il(null, wl), ir = (bn.prototype._lock = function() {
        return G(!re.global), ++this._reculock, this._reculock !== 1 || re.global || (re.lockOwnerFor = this), this;
      }, bn.prototype._unlock = function() {
        if (G(!re.global), --this._reculock == 0) for (re.global || (re.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var n = this._blockedFuncs.shift();
          try {
            Xn(n[1], n[0]);
          } catch {
          }
        }
        return this;
      }, bn.prototype._locked = function() {
        return this._reculock && re.lockOwnerFor !== this;
      }, bn.prototype.create = function(n) {
        var t = this;
        if (!this.mode) return this;
        var u = this.db.idbdb, r = this.db._state.dbOpenError;
        if (G(!this.idbtrans), !n && !u) switch (r && r.name) {
          case "DatabaseClosedError":
            throw new B.DatabaseClosed(r);
          case "MissingAPIError":
            throw new B.MissingAPI(r.message, r);
          default:
            throw new B.OpenFailed(r);
        }
        if (!this.active) throw new B.TransactionInactive();
        return G(this._completion._state === null), (n = this.idbtrans = n || (this.db.core || u).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Be(function(c) {
          Ol(c), t._reject(n.error);
        }), n.onabort = Be(function(c) {
          Ol(c), t.active && t._reject(new B.Abort(n.error)), t.active = !1, t.on("abort").fire(c);
        }), n.oncomplete = Be(function() {
          t.active = !1, t._resolve(), "mutatedParts" in n && jn.storagemutated.fire(n.mutatedParts);
        }), this;
      }, bn.prototype._promise = function(n, t, u) {
        var r = this;
        if (n === "readwrite" && this.mode !== "readwrite") return je(new B.ReadOnly("Transaction is readonly"));
        if (!this.active) return je(new B.TransactionInactive());
        if (this._locked()) return new ee(function(m, p) {
          r._blockedFuncs.push([function() {
            r._promise(n, t, u).then(m, p);
          }, re]);
        });
        if (u) return Un(function() {
          var m = new ee(function(p, g) {
            r._lock();
            var L = t(p, g, r);
            L && L.then && L.then(p, g);
          });
          return m.finally(function() {
            return r._unlock();
          }), m._lib = !0, m;
        });
        var c = new ee(function(m, p) {
          var g = t(m, p, r);
          g && g.then && g.then(m, p);
        });
        return c._lib = !0, c;
      }, bn.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, bn.prototype.waitFor = function(n) {
        var t, u = this._root(), r = ee.resolve(n);
        u._waitingFor ? u._waitingFor = u._waitingFor.then(function() {
          return r;
        }) : (u._waitingFor = r, u._waitingQueue = [], t = u.idbtrans.objectStore(u.storeNames[0]), function m() {
          for (++u._spinCount; u._waitingQueue.length; ) u._waitingQueue.shift()();
          u._waitingFor && (t.get(-1 / 0).onsuccess = m);
        }());
        var c = u._waitingFor;
        return new ee(function(m, p) {
          r.then(function(g) {
            return u._waitingQueue.push(Be(m.bind(null, g)));
          }, function(g) {
            return u._waitingQueue.push(Be(p.bind(null, g)));
          }).finally(function() {
            u._waitingFor === c && (u._waitingFor = null);
          });
        });
      }, bn.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new B.Abort()));
      }, bn.prototype.table = function(n) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (y(t, n)) return t[n];
        var u = this.schema[n];
        if (!u) throw new B.NotFound("Table " + n + " not part of transaction");
        return u = new this.db.Table(n, u, this), u.core = this.db.core.table(n), t[n] = u;
      }, bn);
      function bn() {
      }
      function kt(n, t, u, r, c, m, p, g) {
        return { name: n, keyPath: t, unique: u, multi: r, auto: c, compound: m, src: (u && !p ? "&" : "") + (r ? "*" : "") + (c ? "++" : "") + su(t), type: g };
      }
      function su(n) {
        return typeof n == "string" ? n : n ? "[" + [].join.call(n, "+") + "]" : "";
      }
      function Vt(n, t, u) {
        return { name: n, primKey: t, indexes: u, mappedClass: null, idxByName: (r = function(c) {
          return [c.name, c];
        }, u.reduce(function(c, m, p) {
          return p = r(m, p), p && (c[p[0]] = p[1]), c;
        }, {})) };
        var r;
      }
      var bl = function(n) {
        try {
          return n.only([[]]), bl = function() {
            return [[]];
          }, [[]];
        } catch {
          return bl = function() {
            return Qn;
          }, Qn;
        }
      };
      function Bt(n) {
        return n == null ? function() {
        } : typeof n == "string" ? (t = n).split(".").length === 1 ? function(u) {
          return u[t];
        } : function(u) {
          return se(u, t);
        } : function(u) {
          return se(u, n);
        };
        var t;
      }
      function cu(n) {
        return [].slice.call(n);
      }
      var ur = 0;
      function Sl(n) {
        return n == null ? ":id" : typeof n == "string" ? n : "[".concat(n.join("+"), "]");
      }
      function ar(n, t, L) {
        function r(S) {
          if (S.type === 3) return null;
          if (S.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var D = S.lower, w = S.upper, C = S.lowerOpen, S = S.upperOpen;
          return D === void 0 ? w === void 0 ? null : t.upperBound(w, !!S) : w === void 0 ? t.lowerBound(D, !!C) : t.bound(D, w, !!C, !!S);
        }
        function c(T) {
          var D, w = T.name;
          return { name: w, schema: T, mutate: function(C) {
            var S = C.trans, q = C.type, A = C.keys, N = C.values, F = C.range;
            return new Promise(function(U, W) {
              U = Be(U);
              var z = S.objectStore(w), H = z.keyPath == null, J = q === "put" || q === "add";
              if (!J && q !== "delete" && q !== "deleteRange") throw new Error("Invalid operation type: " + q);
              var X, ne = (A || N || { length: 1 }).length;
              if (A && N && A.length !== N.length) throw new Error("Given keys array must have same length as given values array.");
              if (ne === 0) return U({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ve(mn) {
                ++Ge, Ol(mn);
              }
              var Pe = [], ge = [], Ge = 0;
              if (q === "deleteRange") {
                if (F.type === 4) return U({ numFailures: Ge, failures: ge, results: [], lastResult: void 0 });
                F.type === 3 ? Pe.push(X = z.clear()) : Pe.push(X = z.delete(r(F)));
              } else {
                var H = J ? H ? [N, A] : [N, null] : [A, null], pe = H[0], an = H[1];
                if (J) for (var rn = 0; rn < ne; ++rn) Pe.push(X = an && an[rn] !== void 0 ? z[q](pe[rn], an[rn]) : z[q](pe[rn])), X.onerror = ve;
                else for (rn = 0; rn < ne; ++rn) Pe.push(X = z[q](pe[rn])), X.onerror = ve;
              }
              function ct(mn) {
                mn = mn.target.result, Pe.forEach(function(ll, ii) {
                  return ll.error != null && (ge[ii] = ll.error);
                }), U({ numFailures: Ge, failures: ge, results: q === "delete" ? A : Pe.map(function(ll) {
                  return ll.result;
                }), lastResult: mn });
              }
              X.onerror = function(mn) {
                ve(mn), ct(mn);
              }, X.onsuccess = ct;
            });
          }, getMany: function(C) {
            var S = C.trans, q = C.keys;
            return new Promise(function(A, N) {
              A = Be(A);
              for (var F, U = S.objectStore(w), W = q.length, z = new Array(W), H = 0, J = 0, X = function(Pe) {
                Pe = Pe.target, z[Pe._pos] = Pe.result, ++J === H && A(z);
              }, ne = wn(N), ve = 0; ve < W; ++ve) q[ve] != null && ((F = U.get(q[ve]))._pos = ve, F.onsuccess = X, F.onerror = ne, ++H);
              H === 0 && A(z);
            });
          }, get: function(C) {
            var S = C.trans, q = C.key;
            return new Promise(function(A, N) {
              A = Be(A);
              var F = S.objectStore(w).get(q);
              F.onsuccess = function(U) {
                return A(U.target.result);
              }, F.onerror = wn(N);
            });
          }, query: (D = O, function(C) {
            return new Promise(function(S, q) {
              S = Be(S);
              var A, N, F, H = C.trans, U = C.values, W = C.limit, X = C.query, z = W === 1 / 0 ? void 0 : W, J = X.index, X = X.range, H = H.objectStore(w), J = J.isPrimaryKey ? H : H.index(J.name), X = r(X);
              if (W === 0) return S({ result: [] });
              D ? ((z = U ? J.getAll(X, z) : J.getAllKeys(X, z)).onsuccess = function(ne) {
                return S({ result: ne.target.result });
              }, z.onerror = wn(q)) : (A = 0, N = !U && "openKeyCursor" in J ? J.openKeyCursor(X) : J.openCursor(X), F = [], N.onsuccess = function(ne) {
                var ve = N.result;
                return ve ? (F.push(U ? ve.value : ve.primaryKey), ++A === W ? S({ result: F }) : void ve.continue()) : S({ result: F });
              }, N.onerror = wn(q));
            });
          }), openCursor: function(C) {
            var S = C.trans, q = C.values, A = C.query, N = C.reverse, F = C.unique;
            return new Promise(function(U, W) {
              U = Be(U);
              var J = A.index, z = A.range, H = S.objectStore(w), H = J.isPrimaryKey ? H : H.index(J.name), J = N ? F ? "prevunique" : "prev" : F ? "nextunique" : "next", X = !q && "openKeyCursor" in H ? H.openKeyCursor(r(z), J) : H.openCursor(r(z), J);
              X.onerror = wn(W), X.onsuccess = Be(function(ne) {
                var ve, Pe, ge, Ge, pe = X.result;
                pe ? (pe.___id = ++ur, pe.done = !1, ve = pe.continue.bind(pe), Pe = (Pe = pe.continuePrimaryKey) && Pe.bind(pe), ge = pe.advance.bind(pe), Ge = function() {
                  throw new Error("Cursor not stopped");
                }, pe.trans = S, pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = function() {
                  throw new Error("Cursor not started");
                }, pe.fail = Be(W), pe.next = function() {
                  var an = this, rn = 1;
                  return this.start(function() {
                    return rn-- ? an.continue() : an.stop();
                  }).then(function() {
                    return an;
                  });
                }, pe.start = function(an) {
                  function rn() {
                    if (X.result) try {
                      an();
                    } catch (mn) {
                      pe.fail(mn);
                    }
                    else pe.done = !0, pe.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, pe.stop();
                  }
                  var ct = new Promise(function(mn, ll) {
                    mn = Be(mn), X.onerror = wn(ll), pe.fail = ll, pe.stop = function(ii) {
                      pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = Ge, mn(ii);
                    };
                  });
                  return X.onsuccess = Be(function(mn) {
                    X.onsuccess = rn, rn();
                  }), pe.continue = ve, pe.continuePrimaryKey = Pe, pe.advance = ge, rn(), ct;
                }, U(pe)) : U(null);
              }, W);
            });
          }, count: function(C) {
            var S = C.query, q = C.trans, A = S.index, N = S.range;
            return new Promise(function(F, U) {
              var W = q.objectStore(w), z = A.isPrimaryKey ? W : W.index(A.name), W = r(N), z = W ? z.count(W) : z.count();
              z.onsuccess = Be(function(H) {
                return F(H.target.result);
              }), z.onerror = wn(U);
            });
          } };
        }
        var m, p, g, b = (p = L, g = cu((m = n).objectStoreNames), { schema: { name: m.name, tables: g.map(function(T) {
          return p.objectStore(T);
        }).map(function(T) {
          var D = T.keyPath, S = T.autoIncrement, w = d(D), C = {}, S = { name: T.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: D == null, compound: w, keyPath: D, autoIncrement: S, unique: !0, extractKey: Bt(D) }, indexes: cu(T.indexNames).map(function(q) {
            return T.index(q);
          }).map(function(F) {
            var A = F.name, N = F.unique, U = F.multiEntry, F = F.keyPath, U = { name: A, compound: d(F), keyPath: F, unique: N, multiEntry: U, extractKey: Bt(F) };
            return C[Sl(F)] = U;
          }), getIndexByKeyPath: function(q) {
            return C[Sl(q)];
          } };
          return C[":id"] = S.primaryKey, D != null && (C[Sl(D)] = S.primaryKey), S;
        }) }, hasGetAll: 0 < g.length && "getAll" in p.objectStore(g[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), L = b.schema, O = b.hasGetAll, b = L.tables.map(c), v = {};
        return b.forEach(function(T) {
          return v[T.name] = T;
        }), { stack: "dbcore", transaction: n.transaction.bind(n), table: function(T) {
          if (!v[T]) throw new Error("Table '".concat(T, "' not found"));
          return v[T];
        }, MIN_KEY: -1 / 0, MAX_KEY: bl(t), schema: L };
      }
      function rr(n, t, u, r) {
        var c = u.IDBKeyRange;
        return u.indexedDB, { dbcore: (r = ar(t, c, r), n.dbcore.reduce(function(m, p) {
          return p = p.create, a(a({}, m), p(m));
        }, r)) };
      }
      function Ql(n, r) {
        var u = r.db, r = rr(n._middlewares, u, n._deps, r);
        n.core = r.dbcore, n.tables.forEach(function(c) {
          var m = c.name;
          n.core.schema.tables.some(function(p) {
            return p.name === m;
          }) && (c.core = n.core.table(m), n[m] instanceof n.Table && (n[m].core = c.core));
        });
      }
      function Jl(n, t, u, r) {
        u.forEach(function(c) {
          var m = r[c];
          t.forEach(function(p) {
            var g = function L(O, b) {
              return K(O, b) || (O = I(O)) && L(O, b);
            }(p, c);
            (!g || "value" in g && g.value === void 0) && (p === n.Transaction.prototype || p instanceof n.Transaction ? R(p, c, { get: function() {
              return this.table(c);
            }, set: function(L) {
              E(this, c, { value: L, writable: !0, configurable: !0, enumerable: !0 });
            } }) : p[c] = new n.Table(c, m));
          });
        });
      }
      function Zt(n, t) {
        t.forEach(function(u) {
          for (var r in u) u[r] instanceof n.Table && delete u[r];
        });
      }
      function sr(n, t) {
        return n._cfg.version - t._cfg.version;
      }
      function cr(n, t, u, r) {
        var c = n._dbSchema;
        u.objectStoreNames.contains("$meta") && !c.$meta && (c.$meta = Vt("$meta", mu("")[0], []), n._storeNames.push("$meta"));
        var m = n._createTransaction("readwrite", n._storeNames, c);
        m.create(u), m._completion.catch(r);
        var p = m._reject.bind(m), g = re.transless || re;
        Un(function() {
          return re.trans = m, re.transless = g, t !== 0 ? (Ql(n, u), O = t, ((L = m).storeNames.includes("$meta") ? L.table("$meta").get("version").then(function(b) {
            return b ?? O;
          }) : ee.resolve(O)).then(function(b) {
            return T = b, D = m, w = u, C = [], b = (v = n)._versions, S = v._dbSchema = nt(0, v.idbdb, w), (b = b.filter(function(q) {
              return q._cfg.version >= T;
            })).length !== 0 ? (b.forEach(function(q) {
              C.push(function() {
                var A = S, N = q._cfg.dbschema;
                lt(v, A, w), lt(v, N, w), S = v._dbSchema = N;
                var F = Ut(A, N);
                F.add.forEach(function(J) {
                  Kt(w, J[0], J[1].primKey, J[1].indexes);
                }), F.change.forEach(function(J) {
                  if (J.recreate) throw new B.Upgrade("Not yet support for changing primary key");
                  var X = w.objectStore(J.name);
                  J.add.forEach(function(ne) {
                    return et(X, ne);
                  }), J.change.forEach(function(ne) {
                    X.deleteIndex(ne.name), et(X, ne);
                  }), J.del.forEach(function(ne) {
                    return X.deleteIndex(ne);
                  });
                });
                var U = q._cfg.contentUpgrade;
                if (U && q._cfg.version > T) {
                  Ql(v, w), D._memoizedTables = {};
                  var W = fe(N);
                  F.del.forEach(function(J) {
                    W[J] = A[J];
                  }), Zt(v, [v.Transaction.prototype]), Jl(v, [v.Transaction.prototype], f(W), W), D.schema = W;
                  var z, H = $e(U);
                  return H && sl(), F = ee.follow(function() {
                    var J;
                    (z = U(D)) && H && (J = Kn.bind(null, null), z.then(J, J));
                  }), z && typeof z.then == "function" ? ee.resolve(z) : F.then(function() {
                    return z;
                  });
                }
              }), C.push(function(A) {
                var N, F, U = q._cfg.dbschema;
                N = U, F = A, [].slice.call(F.db.objectStoreNames).forEach(function(W) {
                  return N[W] == null && F.db.deleteObjectStore(W);
                }), Zt(v, [v.Transaction.prototype]), Jl(v, [v.Transaction.prototype], v._storeNames, v._dbSchema), D.schema = v._dbSchema;
              }), C.push(function(A) {
                v.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(v.idbdb.version / 10) === q._cfg.version ? (v.idbdb.deleteObjectStore("$meta"), delete v._dbSchema.$meta, v._storeNames = v._storeNames.filter(function(N) {
                  return N !== "$meta";
                })) : A.objectStore("$meta").put(q._cfg.version, "version"));
              });
            }), function q() {
              return C.length ? ee.resolve(C.shift()(D.idbtrans)).then(q) : ee.resolve();
            }().then(function() {
              ou(S, w);
            })) : ee.resolve();
            var v, T, D, w, C, S;
          }).catch(p)) : (f(c).forEach(function(b) {
            Kt(u, b, c[b].primKey, c[b].indexes);
          }), Ql(n, u), void ee.follow(function() {
            return n.on.populate.fire(m);
          }).catch(p));
          var L, O;
        });
      }
      function or(n, t) {
        ou(n._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var u = nt(0, n.idbdb, t);
        lt(n, n._dbSchema, t);
        for (var r = 0, c = Ut(u, n._dbSchema).change; r < c.length; r++) {
          var m = function(p) {
            if (p.change.length || p.recreate) return console.warn("Unable to patch indexes of table ".concat(p.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var g = t.objectStore(p.name);
            p.add.forEach(function(L) {
              Oe && console.debug("Dexie upgrade patch: Creating missing index ".concat(p.name, ".").concat(L.src)), et(g, L);
            });
          }(c[r]);
          if (typeof m == "object") return m.value;
        }
      }
      function Ut(n, t) {
        var u, r = { del: [], add: [], change: [] };
        for (u in n) t[u] || r.del.push(u);
        for (u in t) {
          var c = n[u], m = t[u];
          if (c) {
            var p = { name: u, def: m, recreate: !1, del: [], add: [], change: [] };
            if ("" + (c.primKey.keyPath || "") != "" + (m.primKey.keyPath || "") || c.primKey.auto !== m.primKey.auto) p.recreate = !0, r.change.push(p);
            else {
              var g = c.idxByName, L = m.idxByName, O = void 0;
              for (O in g) L[O] || p.del.push(O);
              for (O in L) {
                var b = g[O], v = L[O];
                b ? b.src !== v.src && p.change.push(v) : p.add.push(v);
              }
              (0 < p.del.length || 0 < p.add.length || 0 < p.change.length) && r.change.push(p);
            }
          } else r.add.push([u, m]);
        }
        return r;
      }
      function Kt(n, t, u, r) {
        var c = n.db.createObjectStore(t, u.keyPath ? { keyPath: u.keyPath, autoIncrement: u.auto } : { autoIncrement: u.auto });
        return r.forEach(function(m) {
          return et(c, m);
        }), c;
      }
      function ou(n, t) {
        f(n).forEach(function(u) {
          t.db.objectStoreNames.contains(u) || (Oe && console.debug("Dexie: Creating missing table", u), Kt(t, u, n[u].primKey, n[u].indexes));
        });
      }
      function et(n, t) {
        n.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function nt(n, t, u) {
        var r = {};
        return Q(t.objectStoreNames, 0).forEach(function(c) {
          for (var m = u.objectStore(c), p = kt(su(O = m.keyPath), O || "", !0, !1, !!m.autoIncrement, O && typeof O != "string", !0), g = [], L = 0; L < m.indexNames.length; ++L) {
            var b = m.index(m.indexNames[L]), O = b.keyPath, b = kt(b.name, O, !!b.unique, !!b.multiEntry, !1, O && typeof O != "string", !1);
            g.push(b);
          }
          r[c] = Vt(c, p, g);
        }), r;
      }
      function lt(n, t, u) {
        for (var r = u.db.objectStoreNames, c = 0; c < r.length; ++c) {
          var m = r[c], p = u.objectStore(m);
          n._hasGetAll = "getAll" in p;
          for (var g = 0; g < p.indexNames.length; ++g) {
            var L = p.indexNames[g], O = p.index(L).keyPath, b = typeof O == "string" ? O : "[" + Q(O).join("+") + "]";
            !t[m] || (O = t[m].idxByName[b]) && (O.name = L, delete t[m].idxByName[b], t[m].idxByName[L] = O);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && o.WorkerGlobalScope && o instanceof o.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1);
      }
      function mu(n) {
        return n.split(",").map(function(t, u) {
          var m = t.split(":"), r = (c = m[1]) === null || c === void 0 ? void 0 : c.trim(), c = (t = m[0].trim()).replace(/([&*]|\+\+)/g, ""), m = /^\[/.test(c) ? c.match(/^\[(.*)\]$/)[1].split("+") : c;
          return kt(c, m || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), d(m), u === 0, r);
        });
      }
      var mr = (fl.prototype._createTableSchema = Vt, fl.prototype._parseIndexSyntax = mu, fl.prototype._parseStoresSpec = function(n, t) {
        var u = this;
        f(n).forEach(function(r) {
          if (n[r] !== null) {
            var c = u._parseIndexSyntax(n[r]), m = c.shift();
            if (!m) throw new B.Schema("Invalid schema for table " + r + ": " + n[r]);
            if (m.unique = !0, m.multi) throw new B.Schema("Primary key cannot be multiEntry*");
            c.forEach(function(p) {
              if (p.auto) throw new B.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!p.keyPath) throw new B.Schema("Index must have a name and cannot be an empty string");
            }), c = u._createTableSchema(r, m, c), t[r] = c;
          }
        });
      }, fl.prototype.stores = function(u) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? h(this._cfg.storesSource, u) : u;
        var u = t._versions, r = {}, c = {};
        return u.forEach(function(m) {
          h(r, m._cfg.storesSource), c = m._cfg.dbschema = {}, m._parseStoresSpec(r, c);
        }), t._dbSchema = c, Zt(t, [t._allTables, t, t.Transaction.prototype]), Jl(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], f(c), c), t._storeNames = f(c), this;
      }, fl.prototype.upgrade = function(n) {
        return this._cfg.contentUpgrade = Ee(this._cfg.contentUpgrade || De, n), this;
      }, fl);
      function fl() {
      }
      function Gt(n, t) {
        var u = n._dbNamesDB;
        return u || (u = n._dbNamesDB = new En(jl, { addons: [], indexedDB: n, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), u.table("dbnames");
      }
      function zt(n) {
        return n && typeof n.databases == "function";
      }
      function jt(n) {
        return Un(function() {
          return re.letThrough = !0, n();
        });
      }
      function Ht(n) {
        return !("from" in n);
      }
      var un = function(n, t) {
        if (!this) {
          var u = new un();
          return n && "d" in n && h(u, n), u;
        }
        h(this, arguments.length ? { d: 1, from: n, to: 1 < arguments.length ? t : n } : { d: 0 });
      };
      function Cl(n, t, u) {
        var r = Se(t, u);
        if (!isNaN(r)) {
          if (0 < r) throw RangeError();
          if (Ht(n)) return h(n, { from: t, to: u, d: 1 });
          var c = n.l, r = n.r;
          if (Se(u, n.from) < 0) return c ? Cl(c, t, u) : n.l = { from: t, to: u, d: 1, l: null, r: null }, du(n);
          if (0 < Se(t, n.to)) return r ? Cl(r, t, u) : n.r = { from: t, to: u, d: 1, l: null, r: null }, du(n);
          Se(t, n.from) < 0 && (n.from = t, n.l = null, n.d = r ? r.d + 1 : 1), 0 < Se(u, n.to) && (n.to = u, n.r = null, n.d = n.l ? n.l.d + 1 : 1), u = !n.r, c && !n.l && Tl(n, c), r && u && Tl(n, r);
        }
      }
      function Tl(n, t) {
        Ht(t) || function u(r, L) {
          var m = L.from, p = L.to, g = L.l, L = L.r;
          Cl(r, m, p), g && u(r, g), L && u(r, L);
        }(n, t);
      }
      function fu(n, t) {
        var u = tt(t), r = u.next();
        if (r.done) return !1;
        for (var c = r.value, m = tt(n), p = m.next(c.from), g = p.value; !r.done && !p.done; ) {
          if (Se(g.from, c.to) <= 0 && 0 <= Se(g.to, c.from)) return !0;
          Se(c.from, g.from) < 0 ? c = (r = u.next(g.from)).value : g = (p = m.next(c.from)).value;
        }
        return !1;
      }
      function tt(n) {
        var t = Ht(n) ? null : { s: 0, n };
        return { next: function(u) {
          for (var r = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, r) for (; t.n.l && Se(u, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !r || Se(u, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function du(n) {
        var t, u, r = (((t = n.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((u = n.l) === null || u === void 0 ? void 0 : u.d) || 0), c = 1 < r ? "r" : r < -1 ? "l" : "";
        c && (t = c == "r" ? "l" : "r", u = a({}, n), r = n[c], n.from = r.from, n.to = r.to, n[c] = r[c], u[c] = r[t], (n[t] = u).d = pu(u)), n.d = pu(n);
      }
      function pu(u) {
        var t = u.r, u = u.l;
        return (t ? u ? Math.max(t.d, u.d) : t.d : u ? u.d : 0) + 1;
      }
      function it(n, t) {
        return f(t).forEach(function(u) {
          n[u] ? Tl(n[u], t[u]) : n[u] = function r(c) {
            var m, p, g = {};
            for (m in c) y(c, m) && (p = c[m], g[m] = !p || typeof p != "object" || Le.has(p.constructor) ? p : r(p));
            return g;
          }(t[u]);
        }), n;
      }
      function $t(n, t) {
        return n.all || t.all || Object.keys(n).some(function(u) {
          return t[u] && fu(t[u], n[u]);
        });
      }
      P(un.prototype, ((In = { add: function(n) {
        return Tl(this, n), this;
      }, addKey: function(n) {
        return Cl(this, n, n), this;
      }, addKeys: function(n) {
        var t = this;
        return n.forEach(function(u) {
          return Cl(t, u, u);
        }), this;
      }, hasKey: function(n) {
        var t = tt(this).next(n).value;
        return t && Se(t.from, n) <= 0 && 0 <= Se(t.to, n);
      } })[xe] = function() {
        return tt(this);
      }, In));
      var el = {}, Wt = {}, Yt = !1;
      function ut(n) {
        it(Wt, n), Yt || (Yt = !0, setTimeout(function() {
          Yt = !1, Xt(Wt, !(Wt = {}));
        }, 0));
      }
      function Xt(n, t) {
        t === void 0 && (t = !1);
        var u = /* @__PURE__ */ new Set();
        if (n.all) for (var r = 0, c = Object.values(el); r < c.length; r++) hu(p = c[r], n, u, t);
        else for (var m in n) {
          var p, g = /^idb\:\/\/(.*)\/(.*)\//.exec(m);
          g && (m = g[1], g = g[2], (p = el["idb://".concat(m, "/").concat(g)]) && hu(p, n, u, t));
        }
        u.forEach(function(L) {
          return L();
        });
      }
      function hu(n, t, u, r) {
        for (var c = [], m = 0, p = Object.entries(n.queries.query); m < p.length; m++) {
          for (var g = p[m], L = g[0], O = [], b = 0, v = g[1]; b < v.length; b++) {
            var T = v[b];
            $t(t, T.obsSet) ? T.subscribers.forEach(function(S) {
              return u.add(S);
            }) : r && O.push(T);
          }
          r && c.push([L, O]);
        }
        if (r) for (var D = 0, w = c; D < w.length; D++) {
          var C = w[D], L = C[0], O = C[1];
          n.queries.query[L] = O;
        }
      }
      function fr(n) {
        var t = n._state, u = n._deps.indexedDB;
        if (t.isBeingOpened || n.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? je(t.dbOpenError) : n;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var r = t.openCanceller, c = Math.round(10 * n.verno), m = !1;
        function p() {
          if (t.openCanceller !== r) throw new B.DatabaseClosed("db.open() was cancelled");
        }
        function g() {
          return new ee(function(T, D) {
            if (p(), !u) throw new B.MissingAPI();
            var w = n.name, C = t.autoSchema || !c ? u.open(w) : u.open(w, c);
            if (!C) throw new B.MissingAPI();
            C.onerror = wn(D), C.onblocked = Be(n._fireOnBlocked), C.onupgradeneeded = Be(function(S) {
              var q;
              b = C.transaction, t.autoSchema && !n._options.allowEmptyDB ? (C.onerror = Ol, b.abort(), C.result.close(), (q = u.deleteDatabase(w)).onsuccess = q.onerror = Be(function() {
                D(new B.NoSuchDatabase("Database ".concat(w, " doesnt exist")));
              })) : (b.onerror = wn(D), S = S.oldVersion > Math.pow(2, 62) ? 0 : S.oldVersion, v = S < 1, n.idbdb = C.result, m && or(n, b), cr(n, S / 10, b, D));
            }, D), C.onsuccess = Be(function() {
              b = null;
              var S, q, A, N, F, U = n.idbdb = C.result, W = Q(U.objectStoreNames);
              if (0 < W.length) try {
                var z = U.transaction((N = W).length === 1 ? N[0] : N, "readonly");
                if (t.autoSchema) q = U, A = z, (S = n).verno = q.version / 10, A = S._dbSchema = nt(0, q, A), S._storeNames = Q(q.objectStoreNames, 0), Jl(S, [S._allTables], f(A), A);
                else if (lt(n, n._dbSchema, z), ((F = Ut(nt(0, (F = n).idbdb, z), F._dbSchema)).add.length || F.change.some(function(H) {
                  return H.add.length || H.change.length;
                })) && !m) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), U.close(), c = U.version + 1, m = !0, T(g());
                Ql(n, z);
              } catch {
              }
              cl.push(n), U.onversionchange = Be(function(H) {
                t.vcFired = !0, n.on("versionchange").fire(H);
              }), U.onclose = Be(function(H) {
                n.on("close").fire(H);
              }), v && (F = n._deps, z = w, U = F.indexedDB, F = F.IDBKeyRange, zt(U) || z === jl || Gt(U, F).put({ name: z }).catch(De)), T();
            }, D);
          }).catch(function(T) {
            switch (T?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), g();
                break;
              case "VersionError":
                if (0 < c) return c = 0, g();
            }
            return ee.reject(T);
          });
        }
        var L, O = t.dbReadyResolve, b = null, v = !1;
        return ee.race([r, (typeof navigator > "u" ? ee.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(T) {
          function D() {
            return indexedDB.databases().finally(T);
          }
          L = setInterval(D, 100), D();
        }).finally(function() {
          return clearInterval(L);
        }) : Promise.resolve()).then(g)]).then(function() {
          return p(), t.onReadyBeingFired = [], ee.resolve(jt(function() {
            return n.on.ready.fire(n.vip);
          })).then(function T() {
            if (0 < t.onReadyBeingFired.length) {
              var D = t.onReadyBeingFired.reduce(Ee, De);
              return t.onReadyBeingFired = [], ee.resolve(jt(function() {
                return D(n.vip);
              })).then(T);
            }
          });
        }).finally(function() {
          t.openCanceller === r && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(T) {
          t.dbOpenError = T;
          try {
            b && b.abort();
          } catch {
          }
          return r === t.openCanceller && n._close(), je(T);
        }).finally(function() {
          t.openComplete = !0, O();
        }).then(function() {
          var T;
          return v && (T = {}, n.tables.forEach(function(D) {
            D.schema.indexes.forEach(function(w) {
              w.name && (T["idb://".concat(n.name, "/").concat(D.name, "/").concat(w.name)] = new un(-1 / 0, [[[]]]));
            }), T["idb://".concat(n.name, "/").concat(D.name, "/")] = T["idb://".concat(n.name, "/").concat(D.name, "/:dels")] = new un(-1 / 0, [[[]]]);
          }), jn(wl).fire(T), Xt(T, !0)), n;
        });
      }
      function Qt(n) {
        function t(m) {
          return n.next(m);
        }
        var u = c(t), r = c(function(m) {
          return n.throw(m);
        });
        function c(m) {
          return function(L) {
            var g = m(L), L = g.value;
            return g.done ? L : L && typeof L.then == "function" ? L.then(u, r) : d(L) ? Promise.all(L).then(u, r) : u(L);
          };
        }
        return c(t)();
      }
      function at(n, t, u) {
        for (var r = d(n) ? n.slice() : [n], c = 0; c < u; ++c) r.push(t);
        return r;
      }
      var dr = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema, c = {}, m = [];
          function p(v, T, D) {
            var w = Sl(v), C = c[w] = c[w] || [], S = v == null ? 0 : typeof v == "string" ? 1 : v.length, q = 0 < T, q = a(a({}, D), { name: q ? "".concat(w, "(virtual-from:").concat(D.name, ")") : D.name, lowLevelIndex: D, isVirtual: q, keyTail: T, keyLength: S, extractKey: Bt(v), unique: !q && D.unique });
            return C.push(q), q.isPrimaryKey || m.push(q), 1 < S && p(S === 2 ? v[0] : v.slice(0, S - 1), T + 1, D), C.sort(function(A, N) {
              return A.keyTail - N.keyTail;
            }), q;
          }
          t = p(r.primaryKey.keyPath, 0, r.primaryKey), c[":id"] = [t];
          for (var g = 0, L = r.indexes; g < L.length; g++) {
            var O = L[g];
            p(O.keyPath, 0, O);
          }
          function b(v) {
            var T, D = v.query.index;
            return D.isVirtual ? a(a({}, v), { query: { index: D.lowLevelIndex, range: (T = v.query.range, D = D.keyTail, { type: T.type === 1 ? 2 : T.type, lower: at(T.lower, T.lowerOpen ? n.MAX_KEY : n.MIN_KEY, D), lowerOpen: !0, upper: at(T.upper, T.upperOpen ? n.MIN_KEY : n.MAX_KEY, D), upperOpen: !0 }) } }) : v;
          }
          return a(a({}, u), { schema: a(a({}, r), { primaryKey: t, indexes: m, getIndexByKeyPath: function(v) {
            return (v = c[Sl(v)]) && v[0];
          } }), count: function(v) {
            return u.count(b(v));
          }, query: function(v) {
            return u.query(b(v));
          }, openCursor: function(v) {
            var T = v.query.index, D = T.keyTail, w = T.isVirtual, C = T.keyLength;
            return w ? u.openCursor(b(v)).then(function(q) {
              return q && S(q);
            }) : u.openCursor(v);
            function S(q) {
              return Object.create(q, { continue: { value: function(A) {
                A != null ? q.continue(at(A, v.reverse ? n.MAX_KEY : n.MIN_KEY, D)) : v.unique ? q.continue(q.key.slice(0, C).concat(v.reverse ? n.MIN_KEY : n.MAX_KEY, D)) : q.continue();
              } }, continuePrimaryKey: { value: function(A, N) {
                q.continuePrimaryKey(at(A, n.MAX_KEY, D), N);
              } }, primaryKey: { get: function() {
                return q.primaryKey;
              } }, key: { get: function() {
                var A = q.key;
                return C === 1 ? A[0] : A.slice(0, C);
              } }, value: { get: function() {
                return q.value;
              } } });
            }
          } });
        } });
      } };
      function Jt(n, t, u, r) {
        return u = u || {}, r = r || "", f(n).forEach(function(c) {
          var m, p, g;
          y(t, c) ? (m = n[c], p = t[c], typeof m == "object" && typeof p == "object" && m && p ? (g = Ce(m)) !== Ce(p) ? u[r + c] = t[c] : g === "Object" ? Jt(m, p, u, r + c + ".") : m !== p && (u[r + c] = t[c]) : m !== p && (u[r + c] = t[c])) : u[r + c] = void 0;
        }), f(t).forEach(function(c) {
          y(n, c) || (u[r + c] = t[c]);
        }), u;
      }
      function ei(n, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(n.extractKey);
      }
      var pr = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(n) {
        return a(a({}, n), { table: function(t) {
          var u = n.table(t), r = u.schema.primaryKey;
          return a(a({}, u), { mutate: function(c) {
            var m = re.trans, p = m.table(t).hook, g = p.deleting, L = p.creating, O = p.updating;
            switch (c.type) {
              case "add":
                if (L.fire === De) break;
                return m._promise("readwrite", function() {
                  return b(c);
                }, !0);
              case "put":
                if (L.fire === De && O.fire === De) break;
                return m._promise("readwrite", function() {
                  return b(c);
                }, !0);
              case "delete":
                if (g.fire === De) break;
                return m._promise("readwrite", function() {
                  return b(c);
                }, !0);
              case "deleteRange":
                if (g.fire === De) break;
                return m._promise("readwrite", function() {
                  return function v(T, D, w) {
                    return u.query({ trans: T, values: !1, query: { index: r, range: D }, limit: w }).then(function(C) {
                      var S = C.result;
                      return b({ type: "delete", keys: S, trans: T }).then(function(q) {
                        return 0 < q.numFailures ? Promise.reject(q.failures[0]) : S.length < w ? { failures: [], numFailures: 0, lastResult: void 0 } : v(T, a(a({}, D), { lower: S[S.length - 1], lowerOpen: !0 }), w);
                      });
                    });
                  }(c.trans, c.range, 1e4);
                }, !0);
            }
            return u.mutate(c);
            function b(v) {
              var T, D, w, C = re.trans, S = v.keys || ei(r, v);
              if (!S) throw new Error("Keys missing");
              return (v = v.type === "add" || v.type === "put" ? a(a({}, v), { keys: S }) : a({}, v)).type !== "delete" && (v.values = s([], v.values)), v.keys && (v.keys = s([], v.keys)), T = u, w = S, ((D = v).type === "add" ? Promise.resolve([]) : T.getMany({ trans: D.trans, keys: w, cache: "immutable" })).then(function(q) {
                var A = S.map(function(N, F) {
                  var U, W, z, H = q[F], J = { onerror: null, onsuccess: null };
                  return v.type === "delete" ? g.fire.call(J, N, H, C) : v.type === "add" || H === void 0 ? (U = L.fire.call(J, N, v.values[F], C), N == null && U != null && (v.keys[F] = N = U, r.outbound || te(v.values[F], r.keyPath, N))) : (U = Jt(H, v.values[F]), (W = O.fire.call(J, U, N, H, C)) && (z = v.values[F], Object.keys(W).forEach(function(X) {
                    y(z, X) ? z[X] = W[X] : te(z, X, W[X]);
                  }))), J;
                });
                return u.mutate(v).then(function(N) {
                  for (var F = N.failures, U = N.results, W = N.numFailures, N = N.lastResult, z = 0; z < S.length; ++z) {
                    var H = (U || S)[z], J = A[z];
                    H == null ? J.onerror && J.onerror(F[z]) : J.onsuccess && J.onsuccess(v.type === "put" && q[z] ? v.values[z] : H);
                  }
                  return { failures: F, results: U, numFailures: W, lastResult: N };
                }).catch(function(N) {
                  return A.forEach(function(F) {
                    return F.onerror && F.onerror(N);
                  }), Promise.reject(N);
                });
              });
            }
          } });
        } });
      } };
      function gu(n, t, u) {
        try {
          if (!t || t.keys.length < n.length) return null;
          for (var r = [], c = 0, m = 0; c < t.keys.length && m < n.length; ++c) Se(t.keys[c], n[m]) === 0 && (r.push(u ? ye(t.values[c]) : t.values[c]), ++m);
          return r.length === n.length ? r : null;
        } catch {
          return null;
        }
      }
      var hr = { stack: "dbcore", level: -1, create: function(n) {
        return { table: function(t) {
          var u = n.table(t);
          return a(a({}, u), { getMany: function(r) {
            if (!r.cache) return u.getMany(r);
            var c = gu(r.keys, r.trans._cache, r.cache === "clone");
            return c ? ee.resolve(c) : u.getMany(r).then(function(m) {
              return r.trans._cache = { keys: r.keys, values: r.cache === "clone" ? ye(m) : m }, m;
            });
          }, mutate: function(r) {
            return r.type !== "add" && (r.trans._cache = null), u.mutate(r);
          } });
        } };
      } };
      function vu(n, t) {
        return n.trans.mode === "readonly" && !!n.subscr && !n.trans.explicit && n.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function xu(n, t) {
        switch (n) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var gr = { stack: "dbcore", level: 0, name: "Observability", create: function(n) {
        var t = n.schema.name, u = new un(n.MIN_KEY, n.MAX_KEY);
        return a(a({}, n), { transaction: function(r, c, m) {
          if (re.subscr && c !== "readonly") throw new B.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(re.querier));
          return n.transaction(r, c, m);
        }, table: function(r) {
          var c = n.table(r), m = c.schema, p = m.primaryKey, v = m.indexes, g = p.extractKey, L = p.outbound, O = p.autoIncrement && v.filter(function(D) {
            return D.compound && D.keyPath.includes(p.keyPath);
          }), b = a(a({}, c), { mutate: function(D) {
            function w(X) {
              return X = "idb://".concat(t, "/").concat(r, "/").concat(X), N[X] || (N[X] = new un());
            }
            var C, S, q, A = D.trans, N = D.mutatedParts || (D.mutatedParts = {}), F = w(""), U = w(":dels"), W = D.type, J = D.type === "deleteRange" ? [D.range] : D.type === "delete" ? [D.keys] : D.values.length < 50 ? [ei(p, D).filter(function(X) {
              return X;
            }), D.values] : [], z = J[0], H = J[1], J = D.trans._cache;
            return d(z) ? (F.addKeys(z), (J = W === "delete" || z.length === H.length ? gu(z, J) : null) || U.addKeys(z), (J || H) && (C = w, S = J, q = H, m.indexes.forEach(function(X) {
              var ne = C(X.name || "");
              function ve(ge) {
                return ge != null ? X.extractKey(ge) : null;
              }
              function Pe(ge) {
                return X.multiEntry && d(ge) ? ge.forEach(function(Ge) {
                  return ne.addKey(Ge);
                }) : ne.addKey(ge);
              }
              (S || q).forEach(function(ge, an) {
                var pe = S && ve(S[an]), an = q && ve(q[an]);
                Se(pe, an) !== 0 && (pe != null && Pe(pe), an != null && Pe(an));
              });
            }))) : z ? (H = { from: (H = z.lower) !== null && H !== void 0 ? H : n.MIN_KEY, to: (H = z.upper) !== null && H !== void 0 ? H : n.MAX_KEY }, U.add(H), F.add(H)) : (F.add(u), U.add(u), m.indexes.forEach(function(X) {
              return w(X.name).add(u);
            })), c.mutate(D).then(function(X) {
              return !z || D.type !== "add" && D.type !== "put" || (F.addKeys(X.results), O && O.forEach(function(ne) {
                for (var ve = D.values.map(function(pe) {
                  return ne.extractKey(pe);
                }), Pe = ne.keyPath.findIndex(function(pe) {
                  return pe === p.keyPath;
                }), ge = 0, Ge = X.results.length; ge < Ge; ++ge) ve[ge][Pe] = X.results[ge];
                w(ne.name).addKeys(ve);
              })), A.mutatedParts = it(A.mutatedParts || {}, N), X;
            });
          } }), v = function(w) {
            var C = w.query, w = C.index, C = C.range;
            return [w, new un((w = C.lower) !== null && w !== void 0 ? w : n.MIN_KEY, (C = C.upper) !== null && C !== void 0 ? C : n.MAX_KEY)];
          }, T = { get: function(D) {
            return [p, new un(D.key)];
          }, getMany: function(D) {
            return [p, new un().addKeys(D.keys)];
          }, count: v, query: v, openCursor: v };
          return f(T).forEach(function(D) {
            b[D] = function(w) {
              var C = re.subscr, S = !!C, q = vu(re, c) && xu(D, w) ? w.obsSet = {} : C;
              if (S) {
                var A = function(H) {
                  return H = "idb://".concat(t, "/").concat(r, "/").concat(H), q[H] || (q[H] = new un());
                }, N = A(""), F = A(":dels"), C = T[D](w), S = C[0], C = C[1];
                if ((D === "query" && S.isPrimaryKey && !w.values ? F : A(S.name || "")).add(C), !S.isPrimaryKey) {
                  if (D !== "count") {
                    var U = D === "query" && L && w.values && c.query(a(a({}, w), { values: !1 }));
                    return c[D].apply(this, arguments).then(function(H) {
                      if (D === "query") {
                        if (L && w.values) return U.then(function(ve) {
                          return ve = ve.result, N.addKeys(ve), H;
                        });
                        var J = w.values ? H.result.map(g) : H.result;
                        (w.values ? N : F).addKeys(J);
                      } else if (D === "openCursor") {
                        var X = H, ne = w.values;
                        return X && Object.create(X, { key: { get: function() {
                          return F.addKey(X.primaryKey), X.key;
                        } }, primaryKey: { get: function() {
                          var ve = X.primaryKey;
                          return F.addKey(ve), ve;
                        } }, value: { get: function() {
                          return ne && N.addKey(X.primaryKey), X.value;
                        } } });
                      }
                      return H;
                    });
                  }
                  F.add(u);
                }
              }
              return c[D].apply(this, arguments);
            };
          }), b;
        } });
      } };
      function yu(n, t, u) {
        if (u.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var r = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return u.numFailures === r ? null : (t = a({}, t), d(t.keys) && (t.keys = t.keys.filter(function(c, m) {
          return !(m in u.failures);
        })), "values" in t && d(t.values) && (t.values = t.values.filter(function(c, m) {
          return !(m in u.failures);
        })), t);
      }
      function ni(n, t) {
        return u = n, ((r = t).lower === void 0 || (r.lowerOpen ? 0 < Se(u, r.lower) : 0 <= Se(u, r.lower))) && (n = n, (t = t).upper === void 0 || (t.upperOpen ? Se(n, t.upper) < 0 : Se(n, t.upper) <= 0));
        var u, r;
      }
      function Iu(n, t, T, r, c, m) {
        if (!T || T.length === 0) return n;
        var p = t.query.index, g = p.multiEntry, L = t.query.range, O = r.schema.primaryKey.extractKey, b = p.extractKey, v = (p.lowLevelIndex || p).extractKey, T = T.reduce(function(D, w) {
          var C = D, S = [];
          if (w.type === "add" || w.type === "put") for (var q = new un(), A = w.values.length - 1; 0 <= A; --A) {
            var N, F = w.values[A], U = O(F);
            q.hasKey(U) || (N = b(F), (g && d(N) ? N.some(function(X) {
              return ni(X, L);
            }) : ni(N, L)) && (q.addKey(U), S.push(F)));
          }
          switch (w.type) {
            case "add":
              var W = new un().addKeys(t.values ? D.map(function(ne) {
                return O(ne);
              }) : D), C = D.concat(t.values ? S.filter(function(ne) {
                return ne = O(ne), !W.hasKey(ne) && (W.addKey(ne), !0);
              }) : S.map(function(ne) {
                return O(ne);
              }).filter(function(ne) {
                return !W.hasKey(ne) && (W.addKey(ne), !0);
              }));
              break;
            case "put":
              var z = new un().addKeys(w.values.map(function(ne) {
                return O(ne);
              }));
              C = D.filter(function(ne) {
                return !z.hasKey(t.values ? O(ne) : ne);
              }).concat(t.values ? S : S.map(function(ne) {
                return O(ne);
              }));
              break;
            case "delete":
              var H = new un().addKeys(w.keys);
              C = D.filter(function(ne) {
                return !H.hasKey(t.values ? O(ne) : ne);
              });
              break;
            case "deleteRange":
              var J = w.range;
              C = D.filter(function(ne) {
                return !ni(O(ne), J);
              });
          }
          return C;
        }, n);
        return T === n ? n : (T.sort(function(D, w) {
          return Se(v(D), v(w)) || Se(O(D), O(w));
        }), t.limit && t.limit < 1 / 0 && (T.length > t.limit ? T.length = t.limit : n.length === t.limit && T.length < t.limit && (c.dirty = !0)), m ? Object.freeze(T) : T);
      }
      function Lu(n, t) {
        return Se(n.lower, t.lower) === 0 && Se(n.upper, t.upper) === 0 && !!n.lowerOpen == !!t.lowerOpen && !!n.upperOpen == !!t.upperOpen;
      }
      function vr(n, t) {
        return function(u, r, c, m) {
          if (u === void 0) return r !== void 0 ? -1 : 0;
          if (r === void 0) return 1;
          if ((r = Se(u, r)) === 0) {
            if (c && m) return 0;
            if (c) return 1;
            if (m) return -1;
          }
          return r;
        }(n.lower, t.lower, n.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(u, r, c, m) {
          if (u === void 0) return r !== void 0 ? 1 : 0;
          if (r === void 0) return -1;
          if ((r = Se(u, r)) === 0) {
            if (c && m) return 0;
            if (c) return -1;
            if (m) return 1;
          }
          return r;
        }(n.upper, t.upper, n.upperOpen, t.upperOpen);
      }
      function xr(n, t, u, r) {
        n.subscribers.add(u), r.addEventListener("abort", function() {
          var c, m;
          n.subscribers.delete(u), n.subscribers.size === 0 && (c = n, m = t, setTimeout(function() {
            c.subscribers.size === 0 && de(m, c);
          }, 3e3));
        });
      }
      var yr = { stack: "dbcore", level: 0, name: "Cache", create: function(n) {
        var t = n.schema.name;
        return a(a({}, n), { transaction: function(u, r, c) {
          var m, p, g = n.transaction(u, r, c);
          return r === "readwrite" && (p = (m = new AbortController()).signal, c = function(L) {
            return function() {
              if (m.abort(), r === "readwrite") {
                for (var O = /* @__PURE__ */ new Set(), b = 0, v = u; b < v.length; b++) {
                  var T = v[b], D = el["idb://".concat(t, "/").concat(T)];
                  if (D) {
                    var w = n.table(T), C = D.optimisticOps.filter(function(ne) {
                      return ne.trans === g;
                    });
                    if (g._explicit && L && g.mutatedParts) for (var S = 0, q = Object.values(D.queries.query); S < q.length; S++) for (var A = 0, N = (W = q[S]).slice(); A < N.length; A++) $t((z = N[A]).obsSet, g.mutatedParts) && (de(W, z), z.subscribers.forEach(function(ne) {
                      return O.add(ne);
                    }));
                    else if (0 < C.length) {
                      D.optimisticOps = D.optimisticOps.filter(function(ne) {
                        return ne.trans !== g;
                      });
                      for (var F = 0, U = Object.values(D.queries.query); F < U.length; F++) for (var W, z, H, J = 0, X = (W = U[F]).slice(); J < X.length; J++) (z = X[J]).res != null && g.mutatedParts && (L && !z.dirty ? (H = Object.isFrozen(z.res), H = Iu(z.res, z.req, C, w, z, H), z.dirty ? (de(W, z), z.subscribers.forEach(function(ne) {
                        return O.add(ne);
                      })) : H !== z.res && (z.res = H, z.promise = ee.resolve({ result: H }))) : (z.dirty && de(W, z), z.subscribers.forEach(function(ne) {
                        return O.add(ne);
                      })));
                    }
                  }
                }
                O.forEach(function(ne) {
                  return ne();
                });
              }
            };
          }, g.addEventListener("abort", c(!1), { signal: p }), g.addEventListener("error", c(!1), { signal: p }), g.addEventListener("complete", c(!0), { signal: p })), g;
        }, table: function(u) {
          var r = n.table(u), c = r.schema.primaryKey;
          return a(a({}, r), { mutate: function(m) {
            var p = re.trans;
            if (c.outbound || p.db._options.cache === "disabled" || p.explicit || p.idbtrans.mode !== "readwrite") return r.mutate(m);
            var g = el["idb://".concat(t, "/").concat(u)];
            return g ? (p = r.mutate(m), m.type !== "add" && m.type !== "put" || !(50 <= m.values.length || ei(c, m).some(function(L) {
              return L == null;
            })) ? (g.optimisticOps.push(m), m.mutatedParts && ut(m.mutatedParts), p.then(function(L) {
              0 < L.numFailures && (de(g.optimisticOps, m), (L = yu(0, m, L)) && g.optimisticOps.push(L), m.mutatedParts && ut(m.mutatedParts));
            }), p.catch(function() {
              de(g.optimisticOps, m), m.mutatedParts && ut(m.mutatedParts);
            })) : p.then(function(L) {
              var O = yu(0, a(a({}, m), { values: m.values.map(function(b, v) {
                var T;
                return L.failures[v] ? b : (b = (T = c.keyPath) !== null && T !== void 0 && T.includes(".") ? ye(b) : a({}, b), te(b, c.keyPath, L.results[v]), b);
              }) }), L);
              g.optimisticOps.push(O), queueMicrotask(function() {
                return m.mutatedParts && ut(m.mutatedParts);
              });
            }), p) : r.mutate(m);
          }, query: function(m) {
            if (!vu(re, r) || !xu("query", m)) return r.query(m);
            var p = ((O = re.trans) === null || O === void 0 ? void 0 : O.db._options.cache) === "immutable", v = re, g = v.requery, L = v.signal, O = function(w, C, S, q) {
              var A = el["idb://".concat(w, "/").concat(C)];
              if (!A) return [];
              if (!(C = A.queries[S])) return [null, !1, A, null];
              var N = C[(q.query ? q.query.index.name : null) || ""];
              if (!N) return [null, !1, A, null];
              switch (S) {
                case "query":
                  var F = N.find(function(U) {
                    return U.req.limit === q.limit && U.req.values === q.values && Lu(U.req.query.range, q.query.range);
                  });
                  return F ? [F, !0, A, N] : [N.find(function(U) {
                    return ("limit" in U.req ? U.req.limit : 1 / 0) >= q.limit && (!q.values || U.req.values) && vr(U.req.query.range, q.query.range);
                  }), !1, A, N];
                case "count":
                  return F = N.find(function(U) {
                    return Lu(U.req.query.range, q.query.range);
                  }), [F, !!F, A, N];
              }
            }(t, u, "query", m), b = O[0], v = O[1], T = O[2], D = O[3];
            return b && v ? b.obsSet = m.obsSet : (v = r.query(m).then(function(w) {
              var C = w.result;
              if (b && (b.res = C), p) {
                for (var S = 0, q = C.length; S < q; ++S) Object.freeze(C[S]);
                Object.freeze(C);
              } else w.result = ye(C);
              return w;
            }).catch(function(w) {
              return D && b && de(D, b), Promise.reject(w);
            }), b = { obsSet: m.obsSet, promise: v, subscribers: /* @__PURE__ */ new Set(), type: "query", req: m, dirty: !1 }, D ? D.push(b) : (D = [b], (T = T || (el["idb://".concat(t, "/").concat(u)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[m.query.index.name || ""] = D)), xr(b, D, g, L), b.promise.then(function(w) {
              return { result: Iu(w.result, m, T?.optimisticOps, r, b, p) };
            });
          } });
        } });
      } };
      function rt(n, t) {
        return new Proxy(n, { get: function(u, r, c) {
          return r === "db" ? t : Reflect.get(u, r, c);
        } });
      }
      var En = (He.prototype.version = function(n) {
        if (isNaN(n) || n < 0.1) throw new B.Type("Given version is not a positive number");
        if (n = Math.round(10 * n) / 10, this.idbdb || this._state.isBeingOpened) throw new B.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, n);
        var t = this._versions, u = t.filter(function(r) {
          return r._cfg.version === n;
        })[0];
        return u || (u = new this.Version(n), t.push(u), t.sort(sr), u.stores({}), this._state.autoSchema = !1, u);
      }, He.prototype._whenReady = function(n) {
        var t = this;
        return this.idbdb && (this._state.openComplete || re.letThrough || this._vip) ? n() : new ee(function(u, r) {
          if (t._state.openComplete) return r(new B.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void r(new B.DatabaseClosed());
            t.open().catch(De);
          }
          t._state.dbReadyPromise.then(u, r);
        }).then(n);
      }, He.prototype.use = function(n) {
        var t = n.stack, u = n.create, r = n.level, c = n.name;
        return c && this.unuse({ stack: t, name: c }), n = this._middlewares[t] || (this._middlewares[t] = []), n.push({ stack: t, create: u, level: r ?? 10, name: c }), n.sort(function(m, p) {
          return m.level - p.level;
        }), this;
      }, He.prototype.unuse = function(n) {
        var t = n.stack, u = n.name, r = n.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(c) {
          return r ? c.create !== r : !!u && c.name !== u;
        })), this;
      }, He.prototype.open = function() {
        var n = this;
        return Xn(Rn, function() {
          return fr(n);
        });
      }, He.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var n = this._state, t = cl.indexOf(this);
        if (0 <= t && cl.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        n.isBeingOpened || (n.dbReadyPromise = new ee(function(u) {
          n.dbReadyResolve = u;
        }), n.openCanceller = new ee(function(u, r) {
          n.cancelOpen = r;
        }));
      }, He.prototype.close = function(u) {
        var t = (u === void 0 ? { disableAutoOpen: !0 } : u).disableAutoOpen, u = this._state;
        t ? (u.isBeingOpened && u.cancelOpen(new B.DatabaseClosed()), this._close(), u.autoOpen = !1, u.dbOpenError = new B.DatabaseClosed()) : (this._close(), u.autoOpen = this._options.autoOpen || u.isBeingOpened, u.openComplete = !1, u.dbOpenError = null);
      }, He.prototype.delete = function(n) {
        var t = this;
        n === void 0 && (n = { disableAutoOpen: !0 });
        var u = 0 < arguments.length && typeof arguments[0] != "object", r = this._state;
        return new ee(function(c, m) {
          function p() {
            t.close(n);
            var g = t._deps.indexedDB.deleteDatabase(t.name);
            g.onsuccess = Be(function() {
              var L, O, b;
              L = t._deps, O = t.name, b = L.indexedDB, L = L.IDBKeyRange, zt(b) || O === jl || Gt(b, L).delete(O).catch(De), c();
            }), g.onerror = wn(m), g.onblocked = t._fireOnBlocked;
          }
          if (u) throw new B.InvalidArgument("Invalid closeOptions argument to db.delete()");
          r.isBeingOpened ? r.dbReadyPromise.then(p) : p();
        });
      }, He.prototype.backendDB = function() {
        return this.idbdb;
      }, He.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, He.prototype.hasBeenClosed = function() {
        var n = this._state.dbOpenError;
        return n && n.name === "DatabaseClosed";
      }, He.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, He.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(He.prototype, "tables", { get: function() {
        var n = this;
        return f(this._allTables).map(function(t) {
          return n._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), He.prototype.transaction = function() {
        var n = (function(t, u, r) {
          var c = arguments.length;
          if (c < 2) throw new B.InvalidArgument("Too few arguments");
          for (var m = new Array(c - 1); --c; ) m[c - 1] = arguments[c];
          return r = m.pop(), [t, oe(m), r];
        }).apply(this, arguments);
        return this._transaction.apply(this, n);
      }, He.prototype._transaction = function(n, t, u) {
        var r = this, c = re.trans;
        c && c.db === this && n.indexOf("!") === -1 || (c = null);
        var m, p, g = n.indexOf("?") !== -1;
        n = n.replace("!", "").replace("?", "");
        try {
          if (p = t.map(function(O) {
            if (O = O instanceof r.Table ? O.name : O, typeof O != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return O;
          }), n == "r" || n === Et) m = Et;
          else {
            if (n != "rw" && n != _t) throw new B.InvalidArgument("Invalid transaction mode: " + n);
            m = _t;
          }
          if (c) {
            if (c.mode === Et && m === _t) {
              if (!g) throw new B.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              c = null;
            }
            c && p.forEach(function(O) {
              if (c && c.storeNames.indexOf(O) === -1) {
                if (!g) throw new B.SubTransaction("Table " + O + " not included in parent transaction.");
                c = null;
              }
            }), g && c && !c.active && (c = null);
          }
        } catch (O) {
          return c ? c._promise(null, function(b, v) {
            v(O);
          }) : je(O);
        }
        var L = (function O(b, v, T, D, w) {
          return ee.resolve().then(function() {
            var C = re.transless || re, S = b._createTransaction(v, T, b._dbSchema, D);
            if (S.explicit = !0, C = { trans: S, transless: C }, D) S.idbtrans = D.idbtrans;
            else try {
              S.create(), S.idbtrans._explicit = !0, b._state.PR1398_maxLoop = 3;
            } catch (N) {
              return N.name === k.InvalidState && b.isOpen() && 0 < --b._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), b.close({ disableAutoOpen: !1 }), b.open().then(function() {
                return O(b, v, T, null, w);
              })) : je(N);
            }
            var q, A = $e(w);
            return A && sl(), C = ee.follow(function() {
              var N;
              (q = w.call(S, S)) && (A ? (N = Kn.bind(null, null), q.then(N, N)) : typeof q.next == "function" && typeof q.throw == "function" && (q = Qt(q)));
            }, C), (q && typeof q.then == "function" ? ee.resolve(q).then(function(N) {
              return S.active ? N : je(new B.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : C.then(function() {
              return q;
            })).then(function(N) {
              return D && S._resolve(), S._completion.then(function() {
                return N;
              });
            }).catch(function(N) {
              return S._reject(N), je(N);
            });
          });
        }).bind(null, this, m, p, c, u);
        return c ? c._promise(m, L, "lock") : re.trans ? Xn(re.transless, function() {
          return r._whenReady(L);
        }) : this._whenReady(L);
      }, He.prototype.table = function(n) {
        if (!y(this._allTables, n)) throw new B.InvalidTable("Table ".concat(n, " does not exist"));
        return this._allTables[n];
      }, He);
      function He(n, t) {
        var u = this;
        this._middlewares = {}, this.verno = 0;
        var r = He.dependencies;
        this._options = t = a({ addons: He.addons, autoOpen: !0, indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, r = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var c, m, p, g, L, O = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: De, dbReadyPromise: null, cancelOpen: De, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        O.dbReadyPromise = new ee(function(v) {
          O.dbReadyResolve = v;
        }), O.openCanceller = new ee(function(v, T) {
          O.cancelOpen = T;
        }), this._state = O, this.name = n, this.on = Il(this, "populate", "blocked", "versionchange", "close", { ready: [Ee, De] }), this.once = function(v, T) {
          var D = function() {
            for (var w = [], C = 0; C < arguments.length; C++) w[C] = arguments[C];
            u.on(v).unsubscribe(D), T.apply(u, w);
          };
          return u.on(v, D);
        }, this.on.ready.subscribe = Z(this.on.ready.subscribe, function(v) {
          return function(T, D) {
            He.vip(function() {
              var w, C = u._state;
              C.openComplete ? (C.dbOpenError || ee.resolve().then(T), D && v(T)) : C.onReadyBeingFired ? (C.onReadyBeingFired.push(T), D && v(T)) : (v(T), w = u, D || v(function S() {
                w.on.ready.unsubscribe(T), w.on.ready.unsubscribe(S);
              }));
            });
          };
        }), this.Collection = (c = this, Ll(nr.prototype, function(q, S) {
          this.db = c;
          var D = Xi, w = null;
          if (S) try {
            D = S();
          } catch (A) {
            w = A;
          }
          var C = q._ctx, S = C.table, q = S.hook.reading.fire;
          this._ctx = { table: S, index: C.index, isPrimKey: !C.index || S.schema.primKey.keyPath && C.index === S.schema.primKey.name, range: D, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: w, or: C.or, valueMapper: q !== j ? q : null };
        })), this.Table = (m = this, Ll(nu.prototype, function(v, T, D) {
          this.db = m, this._tx = D, this.name = v, this.schema = T, this.hook = m._allTables[v] ? m._allTables[v].hook : Il(null, { creating: [Te, De], reading: [ie, j], updating: [be, De], deleting: [Ie, De] });
        })), this.Transaction = (p = this, Ll(ir.prototype, function(v, T, D, w, C) {
          var S = this;
          v !== "readonly" && T.forEach(function(q) {
            q = (q = D[q]) === null || q === void 0 ? void 0 : q.yProps, q && (T = T.concat(q.map(function(A) {
              return A.updatesTable;
            })));
          }), this.db = p, this.mode = v, this.storeNames = T, this.schema = D, this.chromeTransactionDurability = w, this.idbtrans = null, this.on = Il(this, "complete", "error", "abort"), this.parent = C || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ee(function(q, A) {
            S._resolve = q, S._reject = A;
          }), this._completion.then(function() {
            S.active = !1, S.on.complete.fire();
          }, function(q) {
            var A = S.active;
            return S.active = !1, S.on.error.fire(q), S.parent ? S.parent._reject(q) : A && S.idbtrans && S.idbtrans.abort(), je(q);
          });
        })), this.Version = (g = this, Ll(mr.prototype, function(v) {
          this.db = g, this._cfg = { version: v, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (L = this, Ll(ru.prototype, function(v, T, D) {
          if (this.db = L, this._ctx = { table: v, index: T === ":id" ? null : T, or: D }, this._cmp = this._ascending = Se, this._descending = function(w, C) {
            return Se(C, w);
          }, this._max = function(w, C) {
            return 0 < Se(w, C) ? w : C;
          }, this._min = function(w, C) {
            return Se(w, C) < 0 ? w : C;
          }, this._IDBKeyRange = L._deps.IDBKeyRange, !this._IDBKeyRange) throw new B.MissingAPI();
        })), this.on("versionchange", function(v) {
          0 < v.newVersion ? console.warn("Another connection wants to upgrade database '".concat(u.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(u.name, "'. Closing db now to resume the delete request.")), u.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(v) {
          !v.newVersion || v.newVersion < v.oldVersion ? console.warn("Dexie.delete('".concat(u.name, "') was blocked")) : console.warn("Upgrade '".concat(u.name, "' blocked by other connection holding version ").concat(v.oldVersion / 10));
        }), this._maxKey = bl(t.IDBKeyRange), this._createTransaction = function(v, T, D, w) {
          return new u.Transaction(v, T, D, u._options.chromeTransactionDurability, w);
        }, this._fireOnBlocked = function(v) {
          u.on("blocked").fire(v), cl.filter(function(T) {
            return T.name === u.name && T !== u && !T._state.vcFired;
          }).map(function(T) {
            return T.on("versionchange").fire(v);
          });
        }, this.use(hr), this.use(yr), this.use(gr), this.use(dr), this.use(pr);
        var b = new Proxy(this, { get: function(v, T, D) {
          if (T === "_vip") return !0;
          if (T === "table") return function(C) {
            return rt(u.table(C), b);
          };
          var w = Reflect.get(v, T, D);
          return w instanceof nu ? rt(w, b) : T === "tables" ? w.map(function(C) {
            return rt(C, b);
          }) : T === "_createTransaction" ? function() {
            return rt(w.apply(this, arguments), b);
          } : w;
        } });
        this.vip = b, r.forEach(function(v) {
          return v(u);
        });
      }
      var st, In = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Ir = (li.prototype.subscribe = function(n, t, u) {
        return this._subscribe(n && typeof n != "function" ? n : { next: n, error: t, complete: u });
      }, li.prototype[In] = function() {
        return this;
      }, li);
      function li(n) {
        this._subscribe = n;
      }
      try {
        st = { indexedDB: o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB, IDBKeyRange: o.IDBKeyRange || o.webkitIDBKeyRange };
      } catch {
        st = { indexedDB: null, IDBKeyRange: null };
      }
      function Du(n) {
        var t, u = !1, r = new Ir(function(c) {
          var m = $e(n), p, g = !1, L = {}, O = {}, b = { get closed() {
            return g;
          }, unsubscribe: function() {
            g || (g = !0, p && p.abort(), v && jn.storagemutated.unsubscribe(D));
          } };
          c.start && c.start(b);
          var v = !1, T = function() {
            return At(w);
          }, D = function(C) {
            it(L, C), $t(O, L) && T();
          }, w = function() {
            var C, S, q;
            !g && st.indexedDB && (L = {}, C = {}, p && p.abort(), p = new AbortController(), q = function(A) {
              var N = al();
              try {
                m && sl();
                var F = Un(n, A);
                return F = m ? F.finally(Kn) : F;
              } finally {
                N && rl();
              }
            }(S = { subscr: C, signal: p.signal, requery: T, querier: n, trans: null }), Promise.resolve(q).then(function(A) {
              u = !0, t = A, g || S.signal.aborted || (L = {}, function(N) {
                for (var F in N) if (y(N, F)) return;
                return 1;
              }(O = C) || v || (jn(wl, D), v = !0), At(function() {
                return !g && c.next && c.next(A);
              }));
            }, function(A) {
              u = !1, ["DatabaseClosedError", "AbortError"].includes(A?.name) || g || At(function() {
                g || c.error && c.error(A);
              });
            }));
          };
          return setTimeout(T, 0), b;
        });
        return r.hasValue = function() {
          return u;
        }, r.getValue = function() {
          return t;
        }, r;
      }
      var nl = En;
      function ti(n) {
        var t = Hn;
        try {
          Hn = !0, jn.storagemutated.fire(n), Xt(n, !0);
        } finally {
          Hn = t;
        }
      }
      P(nl, a(a({}, Xe), { delete: function(n) {
        return new nl(n, { addons: [] }).delete();
      }, exists: function(n) {
        return new nl(n, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(n) {
        try {
          return t = nl.dependencies, u = t.indexedDB, t = t.IDBKeyRange, (zt(u) ? Promise.resolve(u.databases()).then(function(r) {
            return r.map(function(c) {
              return c.name;
            }).filter(function(c) {
              return c !== jl;
            });
          }) : Gt(u, t).toCollection().primaryKeys()).then(n);
        } catch {
          return je(new B.MissingAPI());
        }
        var t, u;
      }, defineClass: function() {
        return function(n) {
          h(this, n);
        };
      }, ignoreTransaction: function(n) {
        return re.trans ? Xn(re.transless, n) : n();
      }, vip: jt, async: function(n) {
        return function() {
          try {
            var t = Qt(n.apply(this, arguments));
            return t && typeof t.then == "function" ? t : ee.resolve(t);
          } catch (u) {
            return je(u);
          }
        };
      }, spawn: function(n, t, u) {
        try {
          var r = Qt(n.apply(u, t || []));
          return r && typeof r.then == "function" ? r : ee.resolve(r);
        } catch (c) {
          return je(c);
        }
      }, currentTransaction: { get: function() {
        return re.trans || null;
      } }, waitFor: function(n, t) {
        return t = ee.resolve(typeof n == "function" ? nl.ignoreTransaction(n) : n).timeout(t || 6e4), re.trans ? re.trans.waitFor(t) : t;
      }, Promise: ee, debug: { get: function() {
        return Oe;
      }, set: function(n) {
        qe(n);
      } }, derive: V, extend: h, props: P, override: Z, Events: Il, on: jn, liveQuery: Du, extendObservabilitySet: it, getByKeyPath: se, setByKeyPath: te, delByKeyPath: function(n, t) {
        typeof t == "string" ? te(n, t, void 0) : "length" in t && [].map.call(t, function(u) {
          te(n, u, void 0);
        });
      }, shallowClone: fe, deepClone: ye, getObjectDiff: Jt, cmp: Se, asap: Y, minKey: -1 / 0, addons: [], connections: cl, errnames: k, dependencies: st, cache: el, semVer: "4.2.0", version: "4.2.0".split(".").map(function(n) {
        return parseInt(n);
      }).reduce(function(n, t, u) {
        return n + t / Math.pow(10, 2 * u);
      }) })), nl.maxKey = bl(nl.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (jn(wl, function(n) {
        Hn || (n = new CustomEvent(Mt, { detail: n }), Hn = !0, dispatchEvent(n), Hn = !1);
      }), addEventListener(Mt, function(n) {
        n = n.detail, Hn || ti(n);
      }));
      var gl, Hn = !1, Ou = function() {
      };
      return typeof BroadcastChannel < "u" && ((Ou = function() {
        (gl = new BroadcastChannel(Mt)).onmessage = function(n) {
          return n.data && ti(n.data);
        };
      })(), typeof gl.unref == "function" && gl.unref(), jn(wl, function(n) {
        Hn || gl.postMessage(n);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(n) {
        if (!En.disableBfCache && n.persisted) {
          Oe && console.debug("Dexie: handling persisted pagehide"), gl?.close();
          for (var t = 0, u = cl; t < u.length; t++) u[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(n) {
        !En.disableBfCache && n.persisted && (Oe && console.debug("Dexie: handling persisted pageshow"), Ou(), ti({ all: new un(-1 / 0, [[]]) }));
      })), ee.rejectionMapper = function(n, t) {
        return !n || n instanceof cn || n instanceof TypeError || n instanceof SyntaxError || !n.name || !le[n.name] ? n : (t = new le[n.name](t || n.message, n), "stack" in n && R(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, qe(Oe), a(En, Object.freeze({ __proto__: null, Dexie: En, liveQuery: Du, Entity: Qi, cmp: Se, PropModification: Dl, replacePrefix: function(n, t) {
        return new Dl({ replacePrefix: [n, t] });
      }, add: function(n) {
        return new Dl({ add: n });
      }, remove: function(n) {
        return new Dl({ remove: n });
      }, default: En, RangeSet: un, mergeRanges: Tl, rangesOverlap: fu }), { default: En }), En;
    });
  }(ec)), ec.exports;
}
var x0 = v0();
const bm = /* @__PURE__ */ h0(x0), _d = Symbol.for("Dexie"), Dc = globalThis[_d] || (globalThis[_d] = bm);
if (bm.semVer !== Dc.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${bm.semVer} and ${Dc.semVer}`);
const {
  liveQuery: oC,
  mergeRanges: mC,
  rangesOverlap: fC,
  RangeSet: dC,
  cmp: pC,
  Entity: hC,
  PropModification: gC,
  replacePrefix: vC,
  add: xC,
  remove: yC,
  DexieYProvider: IC
} = Dc, ys = /* @__PURE__ */ Yc("s-ied-implementation/sidebar", () => {
  const e = o0(
    "currentActiveIcdDatabaseName",
    "",
    localStorage
  ), l = Me(null), i = Me(""), a = Me();
  async function s(d) {
    e.value && o();
    const { open: h, onChange: I, reset: x } = d0({
      multiple: !1,
      accept: ".icd",
      input: d
    });
    return I(async (y) => {
      const P = y?.[0];
      if (!P) return;
      const E = await ED({ files: [P] });
      e.value = E[0];
    }), a.value = x, h();
  }
  async function o() {
    await Dc.delete(e.value), e.value = "", a.value?.();
  }
  async function f() {
    l.value = null, i.value = "", await o();
  }
  return {
    // states
    currentActiveIcdDatabaseName: e,
    selectedSied: l,
    selectedLnodeId: i,
    // actions
    importIcdFile: s,
    resetSelection: f
  };
}), Qc = /* @__PURE__ */ Yc("s-ied-implementation/global", () => {
  const e = Me(""), l = _e(
    () => e.value ? Dd({ databaseName: e.value, version: Lc }) : null
  ), i = _e(() => {
    const s = ys(), { currentActiveIcdDatabaseName: o } = Oi(s);
    return o.value ? Dd({ databaseName: o.value, version: Lc }) : null;
  });
  async function a(s) {
    e.value = s;
  }
  return {
    // states
    activeFilename: e,
    // getters
    sdkInstance: l,
    icdSdkInstance: i,
    // actions
    initApp: a
  };
});
function Nd(e) {
  return typeof e == "string" ? `'${e}'` : new y0().serialize(e);
}
const y0 = /* @__PURE__ */ function() {
  class e {
    #e = /* @__PURE__ */ new Map();
    compare(i, a) {
      const s = typeof i, o = typeof a;
      return s === "string" && o === "string" ? i.localeCompare(a) : s === "number" && o === "number" ? i - a : String.prototype.localeCompare.call(this.serialize(i, !0), this.serialize(a, !0));
    }
    serialize(i, a) {
      if (i === null) return "null";
      switch (typeof i) {
        case "string":
          return a ? i : `'${i}'`;
        case "bigint":
          return `${i}n`;
        case "object":
          return this.$object(i);
        case "function":
          return this.$function(i);
      }
      return String(i);
    }
    serializeObject(i) {
      const a = Object.prototype.toString.call(i);
      if (a !== "[object Object]") return this.serializeBuiltInType(a.length < 10 ? `unknown:${a}` : a.slice(8, -1), i);
      const s = i.constructor, o = s === Object || s === void 0 ? "" : s.name;
      if (o !== "" && globalThis[o] === s) return this.serializeBuiltInType(o, i);
      if (typeof i.toJSON == "function") {
        const f = i.toJSON();
        return o + (f !== null && typeof f == "object" ? this.$object(f) : `(${this.serialize(f)})`);
      }
      return this.serializeObjectEntries(o, Object.entries(i));
    }
    serializeBuiltInType(i, a) {
      const s = this["$" + i];
      if (s) return s.call(this, a);
      if (typeof a?.entries == "function") return this.serializeObjectEntries(i, a.entries());
      throw new Error(`Cannot serialize ${i}`);
    }
    serializeObjectEntries(i, a) {
      const s = Array.from(a).sort((f, d) => this.compare(f[0], d[0]));
      let o = `${i}{`;
      for (let f = 0; f < s.length; f++) {
        const [d, h] = s[f];
        o += `${this.serialize(d, !0)}:${this.serialize(h)}`, f < s.length - 1 && (o += ",");
      }
      return o + "}";
    }
    $object(i) {
      let a = this.#e.get(i);
      return a === void 0 && (this.#e.set(i, `#${this.#e.size}`), a = this.serializeObject(i), this.#e.set(i, a)), a;
    }
    $function(i) {
      const a = Function.prototype.toString.call(i);
      return a.slice(-15) === "[native code] }" ? `${i.name || ""}()[native]` : `${i.name}(${i.length})${a.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(i) {
      let a = "[";
      for (let s = 0; s < i.length; s++) a += this.serialize(i[s]), s < i.length - 1 && (a += ",");
      return a + "]";
    }
    $Date(i) {
      try {
        return `Date(${i.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(i) {
      return `ArrayBuffer[${new Uint8Array(i).join(",")}]`;
    }
    $Set(i) {
      return `Set${this.$Array(Array.from(i).sort((a, s) => this.compare(a, s)))}`;
    }
    $Map(i) {
      return this.serializeObjectEntries("Map", i.entries());
    }
  }
  for (const l of ["Error", "RegExp", "URL"]) e.prototype["$" + l] = function(i) {
    return `${l}(${i})`;
  };
  for (const l of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) e.prototype["$" + l] = function(i) {
    return `${l}[${i.join(",")}]`;
  };
  for (const l of ["BigInt64Array", "BigUint64Array"]) e.prototype["$" + l] = function(i) {
    return `${l}[${i.join("n,")}${i.length > 0 ? "n" : ""}]`;
  };
  return e;
}();
function Sm(e, l) {
  return e === l || Nd(e) === Nd(l);
}
function I0(e, l) {
  if (e.length !== l.length) return !1;
  for (let i = 0; i < e.length; i++) if (e[i] !== l[i]) return !1;
  return !0;
}
function nc(e, l, i) {
  const a = e.findIndex((d) => Sm(d, l)), s = e.findIndex((d) => Sm(d, i));
  if (a === -1 || s === -1) return [];
  const [o, f] = [a, s].sort((d, h) => d - h);
  return e.slice(o, f + 1);
}
const Is = typeof document < "u";
function hi(e, l) {
  const i = typeof e == "string" && !l ? `${e}Context` : l, a = Symbol(i);
  return [(f) => {
    const d = Ei(a, f);
    if (d || d === null) return d;
    throw new Error(`Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`);
  }, (f) => (Gc(a, f), f)];
}
function ka() {
  let e = document.activeElement;
  if (e == null) return null;
  for (; e != null && e.shadowRoot != null && e.shadowRoot.activeElement != null; ) e = e.shadowRoot.activeElement;
  return e;
}
function is(e, l, i) {
  const a = i.originalEvent.target, s = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: i
  });
  l && a.addEventListener(e, l, { once: !0 }), a.dispatchEvent(s);
}
function gf(e) {
  return e ? e.flatMap((l) => l.type === Vn ? gf(l.children) : [l]) : [];
}
const [Jc, LC] = hi("ConfigProvider");
function L0(e, l) {
  var i;
  const a = Vl();
  return Nl(() => {
    a.value = e();
  }, {
    ...l,
    flush: (i = void 0) != null ? i : "sync"
  }), Mi(a);
}
function eo(e) {
  return Hu() ? (Za(e), !0) : !1;
}
function Hr() {
  const e = /* @__PURE__ */ new Set(), l = (o) => {
    e.delete(o);
  };
  return {
    on: (o) => {
      e.add(o);
      const f = () => l(o);
      return eo(f), {
        off: f
      };
    },
    off: l,
    trigger: (...o) => Promise.all(Array.from(e).map((f) => f(...o))),
    clear: () => {
      e.clear();
    }
  };
}
function D0(e) {
  let l = 0, i, a;
  const s = () => {
    l -= 1, a && l <= 0 && (a.stop(), i = void 0, a = void 0);
  };
  return (...o) => (l += 1, a || (a = _c(!0), i = a.run(() => e(...o))), eo(s), i);
}
const Ha = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const O0 = (e) => typeof e < "u", w0 = Object.prototype.toString, b0 = (e) => w0.call(e) === "[object Object]", Fd = /* @__PURE__ */ S0();
function S0() {
  var e, l;
  return Ha && ((e = window?.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((l = window?.navigator) == null ? void 0 : l.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function C0(e) {
  return Yn();
}
function Po(e) {
  return Array.isArray(e) ? e : [e];
}
function Kg(e, l = 1e4) {
  return Ga((i, a) => {
    let s = pn(e), o;
    const f = () => setTimeout(() => {
      s = pn(e), a();
    }, pn(l));
    return eo(() => {
      clearTimeout(o);
    }), {
      get() {
        return i(), s;
      },
      set(d) {
        s = d, a(), clearTimeout(o), o = f();
      }
    };
  });
}
const T0 = pn;
function q0(e, l) {
  C0() && ps(e, l);
}
function P0(e, l, i) {
  return Sn(
    e,
    l,
    {
      ...i,
      immediate: !0
    }
  );
}
const vf = Ha ? window : void 0;
function ca(e) {
  var l;
  const i = pn(e);
  return (l = i?.$el) != null ? l : i;
}
function Gg(...e) {
  const l = [], i = () => {
    l.forEach((d) => d()), l.length = 0;
  }, a = (d, h, I, x) => (d.addEventListener(h, I, x), () => d.removeEventListener(h, I, x)), s = _e(() => {
    const d = Po(pn(e[0])).filter((h) => h != null);
    return d.every((h) => typeof h != "string") ? d : void 0;
  }), o = P0(
    () => {
      var d, h;
      return [
        (h = (d = s.value) == null ? void 0 : d.map((I) => ca(I))) != null ? h : [vf].filter((I) => I != null),
        Po(pn(s.value ? e[1] : e[0])),
        Po(ue(s.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        pn(s.value ? e[3] : e[2])
      ];
    },
    ([d, h, I, x]) => {
      if (i(), !d?.length || !h?.length || !I?.length)
        return;
      const y = b0(x) ? { ...x } : x;
      l.push(
        ...d.flatMap(
          (P) => h.flatMap(
            (E) => I.map((R) => a(P, E, R, y))
          )
        )
      );
    },
    { flush: "post" }
  ), f = () => {
    o(), i();
  };
  return eo(i), f;
}
function R0(e) {
  return typeof e == "function" ? e : typeof e == "string" ? (l) => l.key === e : Array.isArray(e) ? (l) => e.includes(l.key) : () => !0;
}
function A0(...e) {
  let l, i, a = {};
  e.length === 3 ? (l = e[0], i = e[1], a = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (l = !0, i = e[0], a = e[1]) : (l = e[0], i = e[1]) : (l = !0, i = e[0]);
  const {
    target: s = vf,
    eventName: o = "keydown",
    passive: f = !1,
    dedupe: d = !1
  } = a, h = R0(l);
  return Gg(s, o, (x) => {
    x.repeat && pn(d) || h(x) && i(x);
  }, f);
}
function E0(e) {
  return JSON.parse(JSON.stringify(e));
}
function Uu(e, l, i, a = {}) {
  var s, o, f;
  const {
    clone: d = !1,
    passive: h = !1,
    eventName: I,
    deep: x = !1,
    defaultValue: y,
    shouldEmit: P
  } = a, E = Yn(), R = i || E?.emit || ((s = E?.$emit) == null ? void 0 : s.bind(E)) || ((f = (o = E?.proxy) == null ? void 0 : o.$emit) == null ? void 0 : f.bind(E?.proxy));
  let V = I;
  l || (l = "modelValue"), V = V || `update:${l.toString()}`;
  const K = (Z) => d ? typeof d == "function" ? d(Z) : E0(Z) : Z, $ = () => O0(e[l]) ? K(e[l]) : y, Q = (Z) => {
    P ? P(Z) && R(V, Z) : R(V, Z);
  };
  if (h) {
    const Z = $(), G = Me(Z);
    let Y = !1;
    return Sn(
      () => e[l],
      (se) => {
        Y || (Y = !0, G.value = K(se), tl(() => Y = !1));
      }
    ), Sn(
      G,
      (se) => {
        !Y && (se !== e[l] || x) && Q(se);
      },
      { deep: x }
    ), G;
  } else
    return _e({
      get() {
        return $();
      },
      set(Z) {
        Q(Z);
      }
    });
}
function Ro(e) {
  if (e === null || typeof e != "object")
    return !1;
  const l = Object.getPrototypeOf(e);
  return l !== null && l !== Object.prototype && Object.getPrototypeOf(l) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0;
}
function Cm(e, l, i = ".", a) {
  if (!Ro(l))
    return Cm(e, {}, i, a);
  const s = Object.assign({}, l);
  for (const o in e) {
    if (o === "__proto__" || o === "constructor")
      continue;
    const f = e[o];
    f != null && (a && a(s, o, f, i) || (Array.isArray(f) && Array.isArray(s[o]) ? s[o] = [...f, ...s[o]] : Ro(f) && Ro(s[o]) ? s[o] = Cm(
      f,
      s[o],
      (i ? `${i}.` : "") + o.toString(),
      a
    ) : s[o] = f));
  }
  return s;
}
function _0(e) {
  return (...l) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    l.reduce((i, a) => Cm(i, a, "", e), {})
  );
}
const N0 = _0(), F0 = D0(() => {
  const e = Me(/* @__PURE__ */ new Map()), l = Me(), i = _e(() => {
    for (const f of e.value.values()) if (f) return !0;
    return !1;
  }), a = Jc({ scrollBody: Me(!0) });
  let s = null;
  const o = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.documentElement.style.removeProperty("--scrollbar-width"), document.body.style.overflow = l.value ?? "", Fd && s?.(), l.value = void 0;
  };
  return Sn(i, (f, d) => {
    if (!Ha) return;
    if (!f) {
      d && o();
      return;
    }
    l.value === void 0 && (l.value = document.body.style.overflow);
    const h = window.innerWidth - document.documentElement.clientWidth, I = {
      padding: h,
      margin: 0
    }, x = a.scrollBody?.value ? typeof a.scrollBody.value == "object" ? N0({
      padding: a.scrollBody.value.padding === !0 ? h : a.scrollBody.value.padding,
      margin: a.scrollBody.value.margin === !0 ? h : a.scrollBody.value.margin
    }, I) : I : {
      padding: 0,
      margin: 0
    };
    h > 0 && (document.body.style.paddingRight = typeof x.padding == "number" ? `${x.padding}px` : String(x.padding), document.body.style.marginRight = typeof x.margin == "number" ? `${x.margin}px` : String(x.margin), document.documentElement.style.setProperty("--scrollbar-width", `${h}px`), document.body.style.overflow = "hidden"), Fd && (s = Gg(document, "touchmove", (y) => k0(y), { passive: !1 })), tl(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }, {
    immediate: !0,
    flush: "sync"
  }), e;
});
function M0(e) {
  const l = Math.random().toString(36).substring(2, 7), i = F0();
  i.value.set(l, e ?? !1);
  const a = _e({
    get: () => i.value.get(l) ?? !1,
    set: (s) => i.value.set(l, s)
  });
  return q0(() => {
    i.value.delete(l);
  }), a;
}
function zg(e) {
  const l = window.getComputedStyle(e);
  if (l.overflowX === "scroll" || l.overflowY === "scroll" || l.overflowX === "auto" && e.clientWidth < e.scrollWidth || l.overflowY === "auto" && e.clientHeight < e.scrollHeight) return !0;
  {
    const i = e.parentNode;
    return !(i instanceof Element) || i.tagName === "BODY" ? !1 : zg(i);
  }
}
function k0(e) {
  const l = e || window.event, i = l.target;
  return i instanceof Element && zg(i) ? !1 : l.touches.length > 1 ? !0 : (l.preventDefault && l.cancelable && l.preventDefault(), !1);
}
function Ls(e) {
  const l = Jc({ dir: Me("ltr") });
  return _e(() => e?.value || l.dir?.value || "ltr");
}
function V0(e) {
  const l = Yn(), i = l?.type.emits, a = {};
  return i?.length || console.warn(`No emitted event found. Please check component: ${l?.type.__name}`), i?.forEach((s) => {
    a[Ca(hl(s))] = (...o) => e(s, ...o);
  }), a;
}
function B0(e) {
  const l = _e(() => ue(e)), i = _e(() => new Intl.Collator("en", {
    usage: "search",
    ...l.value
  }));
  return {
    startsWith: (f, d) => d.length === 0 ? !0 : (f = f.normalize("NFC"), d = d.normalize("NFC"), i.value.compare(f.slice(0, d.length), d) === 0),
    endsWith: (f, d) => d.length === 0 ? !0 : (f = f.normalize("NFC"), d = d.normalize("NFC"), i.value.compare(f.slice(-d.length), d) === 0),
    contains: (f, d) => {
      if (d.length === 0) return !0;
      f = f.normalize("NFC"), d = d.normalize("NFC");
      let h = 0;
      const I = d.length;
      for (; h + I <= f.length; h++) {
        const x = f.slice(h, h + I);
        if (i.value.compare(d, x) === 0) return !0;
      }
      return !1;
    }
  };
}
function Z0(e) {
  return _e(() => T0(e) ? !!ca(e)?.closest("form") : !0);
}
function Ct() {
  const e = Yn(), l = Me(), i = _e(() => ["#text", "#comment"].includes(l.value?.$el.nodeName) ? l.value?.$el.nextElementSibling : ca(l)), a = Object.assign({}, e.exposed), s = {};
  for (const f in e.props) Object.defineProperty(s, f, {
    enumerable: !0,
    configurable: !0,
    get: () => e.props[f]
  });
  if (Object.keys(a).length > 0) for (const f in a) Object.defineProperty(s, f, {
    enumerable: !0,
    configurable: !0,
    get: () => a[f]
  });
  Object.defineProperty(s, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => e.vnode.el
  }), e.exposed = s;
  function o(f) {
    l.value = f, f && (Object.defineProperty(s, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => f instanceof Element ? f : f.$el
    }), e.exposed = s);
  }
  return {
    forwardRef: o,
    currentRef: l,
    currentElement: i
  };
}
function jg(e) {
  const l = Yn(), i = Object.keys(l?.type.props ?? {}).reduce((s, o) => {
    const f = (l?.type.props[o]).default;
    return f !== void 0 && (s[o] = f), s;
  }, {}), a = fs(e);
  return _e(() => {
    const s = {}, o = l?.vnode.props ?? {};
    return Object.keys(o).forEach((f) => {
      s[hl(f)] = o[f];
    }), Object.keys({
      ...i,
      ...s
    }).reduce((f, d) => (a.value[d] !== void 0 && (f[d] = a.value[d]), f), {});
  });
}
function U0(e, l) {
  const i = jg(e), a = l ? V0(l) : {};
  return _e(() => ({
    ...i.value,
    ...a
  }));
}
var K0 = function(e) {
  if (typeof document > "u")
    return null;
  var l = Array.isArray(e) ? e[0] : e;
  return l.ownerDocument.body;
}, ga = /* @__PURE__ */ new WeakMap(), Fs = /* @__PURE__ */ new WeakMap(), Ms = {}, Ao = 0, Hg = function(e) {
  return e && (e.host || Hg(e.parentNode));
}, G0 = function(e, l) {
  return l.map(function(i) {
    if (e.contains(i))
      return i;
    var a = Hg(i);
    return a && e.contains(a) ? a : (console.error("aria-hidden", i, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(i) {
    return !!i;
  });
}, z0 = function(e, l, i, a) {
  var s = G0(l, Array.isArray(e) ? e : [e]);
  Ms[i] || (Ms[i] = /* @__PURE__ */ new WeakMap());
  var o = Ms[i], f = [], d = /* @__PURE__ */ new Set(), h = new Set(s), I = function(y) {
    !y || d.has(y) || (d.add(y), I(y.parentNode));
  };
  s.forEach(I);
  var x = function(y) {
    !y || h.has(y) || Array.prototype.forEach.call(y.children, function(P) {
      if (d.has(P))
        x(P);
      else
        try {
          var E = P.getAttribute(a), R = E !== null && E !== "false", V = (ga.get(P) || 0) + 1, K = (o.get(P) || 0) + 1;
          ga.set(P, V), o.set(P, K), f.push(P), V === 1 && R && Fs.set(P, !0), K === 1 && P.setAttribute(i, "true"), R || P.setAttribute(a, "true");
        } catch ($) {
          console.error("aria-hidden: cannot operate on ", P, $);
        }
    });
  };
  return x(l), d.clear(), Ao++, function() {
    f.forEach(function(y) {
      var P = ga.get(y) - 1, E = o.get(y) - 1;
      ga.set(y, P), o.set(y, E), P || (Fs.has(y) || y.removeAttribute(a), Fs.delete(y)), E || y.removeAttribute(i);
    }), Ao--, Ao || (ga = /* @__PURE__ */ new WeakMap(), ga = /* @__PURE__ */ new WeakMap(), Fs = /* @__PURE__ */ new WeakMap(), Ms = {});
  };
}, j0 = function(e, l, i) {
  i === void 0 && (i = "data-aria-hidden");
  var a = Array.from(Array.isArray(e) ? e : [e]), s = K0(e);
  return s ? (a.push.apply(a, Array.from(s.querySelectorAll("[aria-live], script"))), z0(a, s, i, "aria-hidden")) : function() {
    return null;
  };
};
function H0(e) {
  let l;
  Sn(() => ca(e), (i) => {
    i ? l = j0(i) : l && l();
  }), St(() => {
    l && l();
  });
}
let $0 = 0;
function oa(e, l = "reka") {
  if (e) return e;
  if ("useId" in tL) return `${l}-${sh?.()}`;
  const i = Jc({ useId: void 0 });
  return i.useId ? `${l}-${i.useId()}` : `${l}-${++$0}`;
}
function W0() {
  return {
    ALT: "Alt",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    ARROW_UP: "ArrowUp",
    BACKSPACE: "Backspace",
    CAPS_LOCK: "CapsLock",
    CONTROL: "Control",
    DELETE: "Delete",
    END: "End",
    ENTER: "Enter",
    ESCAPE: "Escape",
    F1: "F1",
    F10: "F10",
    F11: "F11",
    F12: "F12",
    F2: "F2",
    F3: "F3",
    F4: "F4",
    F5: "F5",
    F6: "F6",
    F7: "F7",
    F8: "F8",
    F9: "F9",
    HOME: "Home",
    META: "Meta",
    PAGE_DOWN: "PageDown",
    PAGE_UP: "PageUp",
    SHIFT: "Shift",
    SPACE: " ",
    TAB: "Tab",
    CTRL: "Control",
    ASTERISK: "*",
    SPACE_CODE: "Space"
  };
}
function Y0(e, l) {
  const i = Me(), a = (o, f) => {
    if (l.multiple && Array.isArray(e.value)) if (l.selectionBehavior === "replace")
      e.value = [o], i.value = o;
    else {
      const d = e.value.findIndex((h) => f(h));
      d !== -1 ? e.value = e.value.filter((h, I) => I !== d) : e.value = [...e.value, o];
    }
    else l.selectionBehavior === "replace" ? e.value = { ...o } : !Array.isArray(e.value) && f(e.value) ? e.value = void 0 : e.value = { ...o };
    return e.value;
  };
  function s(o, f, d, h) {
    if (!i?.value || !l.multiple || !Array.isArray(e.value)) return;
    const x = d().filter((P) => P.ref.dataset.disabled !== "").find((P) => P.ref === f)?.value;
    if (!x) return;
    let y = null;
    switch (o) {
      case "prev":
      case "next": {
        y = nc(h, i.value, x);
        break;
      }
      case "first": {
        y = nc(h, i.value, h?.[0]);
        break;
      }
      case "last": {
        y = nc(h, i.value, h?.[h.length - 1]);
        break;
      }
    }
    e.value = y;
  }
  return {
    firstValue: i,
    onSelectItem: a,
    handleMultipleReplace: s
  };
}
function X0(e) {
  const l = Me(), i = _e(() => l.value?.width ?? 0), a = _e(() => l.value?.height ?? 0);
  return vl(() => {
    const s = ca(e);
    if (s) {
      l.value = {
        width: s.offsetWidth,
        height: s.offsetHeight
      };
      const o = new ResizeObserver((f) => {
        if (!Array.isArray(f) || !f.length) return;
        const d = f[0];
        let h, I;
        if ("borderBoxSize" in d) {
          const x = d.borderBoxSize, y = Array.isArray(x) ? x[0] : x;
          h = y.inlineSize, I = y.blockSize;
        } else
          h = s.offsetWidth, I = s.offsetHeight;
        l.value = {
          width: h,
          height: I
        };
      });
      return o.observe(s, { box: "border-box" }), () => o.unobserve(s);
    } else l.value = void 0;
  }), {
    width: i,
    height: a
  };
}
function Q0(e, l) {
  const i = Me(e);
  function a(o) {
    return l[i.value][o] ?? i.value;
  }
  return {
    state: i,
    dispatch: (o) => {
      i.value = a(o);
    }
  };
}
function $g(e) {
  const l = Kg("", 1e3);
  return {
    search: l,
    handleTypeaheadSearch: (s, o) => {
      l.value = l.value + s;
      {
        const f = ka(), d = o.map((P) => ({
          ...P,
          textValue: P.value?.textValue ?? P.ref.textContent?.trim() ?? ""
        })), h = d.find((P) => P.ref === f), I = d.map((P) => P.textValue), x = eO(I, l.value, h?.textValue), y = d.find((P) => P.textValue === x);
        return y && y.ref.focus(), y?.ref;
      }
    },
    resetTypeahead: () => {
      l.value = "";
    }
  };
}
function J0(e, l) {
  return e.map((i, a) => e[(l + a) % e.length]);
}
function eO(e, l, i) {
  const s = l.length > 1 && Array.from(l).every((I) => I === l[0]) ? l[0] : l, o = i ? e.indexOf(i) : -1;
  let f = J0(e, Math.max(o, 0));
  s.length === 1 && (f = f.filter((I) => I !== i));
  const h = f.find((I) => I.toLowerCase().startsWith(s.toLowerCase()));
  return h !== i ? h : void 0;
}
function nO(e, l) {
  const i = Me({}), a = Me("none"), s = Me(e), o = e.value ? "mounted" : "unmounted";
  let f;
  const d = l.value?.ownerDocument.defaultView ?? vf, { state: h, dispatch: I } = Q0(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: { MOUNT: "mounted" }
  }), x = (K) => {
    if (Ha) {
      const $ = new CustomEvent(K, {
        bubbles: !1,
        cancelable: !1
      });
      l.value?.dispatchEvent($);
    }
  };
  Sn(e, async (K, $) => {
    const Q = $ !== K;
    if (await tl(), Q) {
      const Z = a.value, G = ks(l.value);
      K ? (I("MOUNT"), x("enter"), G === "none" && x("after-enter")) : G === "none" || G === "undefined" || i.value?.display === "none" ? (I("UNMOUNT"), x("leave"), x("after-leave")) : $ && Z !== G ? (I("ANIMATION_OUT"), x("leave")) : (I("UNMOUNT"), x("after-leave"));
    }
  }, { immediate: !0 });
  const y = (K) => {
    const $ = ks(l.value), Q = $.includes(CSS.escape(K.animationName)), Z = h.value === "mounted" ? "enter" : "leave";
    if (K.target === l.value && Q && (x(`after-${Z}`), I("ANIMATION_END"), !s.value)) {
      const G = l.value.style.animationFillMode;
      l.value.style.animationFillMode = "forwards", f = d?.setTimeout(() => {
        l.value?.style.animationFillMode === "forwards" && (l.value.style.animationFillMode = G);
      });
    }
    K.target === l.value && $ === "none" && I("ANIMATION_END");
  }, P = (K) => {
    K.target === l.value && (a.value = ks(l.value));
  }, E = Sn(l, (K, $) => {
    K ? (i.value = getComputedStyle(K), K.addEventListener("animationstart", P), K.addEventListener("animationcancel", y), K.addEventListener("animationend", y)) : (I("ANIMATION_END"), f !== void 0 && d?.clearTimeout(f), $?.removeEventListener("animationstart", P), $?.removeEventListener("animationcancel", y), $?.removeEventListener("animationend", y));
  }, { immediate: !0 }), R = Sn(h, () => {
    const K = ks(l.value);
    a.value = h.value === "mounted" ? K : "none";
  });
  return St(() => {
    E(), R();
  }), { isPresent: _e(() => ["mounted", "unmountSuspended"].includes(h.value)) };
}
function ks(e) {
  return e && getComputedStyle(e).animationName || "none";
}
var lO = /* @__PURE__ */ fn({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: { type: Boolean }
  },
  slots: {},
  setup(e, { slots: l, expose: i }) {
    const { present: a, forceMount: s } = wt(e), o = Me(), { isPresent: f } = nO(a, o);
    i({ present: f });
    let d = l.default({ present: f.value });
    d = gf(d || []);
    const h = Yn();
    if (d && d?.length > 1) {
      const I = h?.parent?.type.name ? `<${h.parent.type.name} />` : "component";
      throw new Error([
        `Detected an invalid children for \`${I}\` for  \`Presence\` component.`,
        "",
        "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
        "You can apply a few solutions:",
        ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map((x) => `  - ${x}`).join(`
`)
      ].join(`
`));
    }
    return () => s.value || a.value || f.value ? pt(l.default({ present: f.value })[0], { ref: (I) => {
      const x = ca(I);
      return typeof x?.hasAttribute > "u" || (x?.hasAttribute("data-reka-popper-content-wrapper") ? o.value = x.firstElementChild : o.value = x), x;
    } }) : null;
  }
});
const Tm = /* @__PURE__ */ fn({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(e, { attrs: l, slots: i }) {
    return () => {
      if (!i.default) return null;
      const a = gf(i.default()), s = a.findIndex((h) => h.type !== il);
      if (s === -1) return a;
      const o = a[s];
      delete o.props?.ref;
      const f = o.props ? dl(l, o.props) : l, d = fi({
        ...o,
        props: {}
      }, f);
      return a.length === 1 ? d : (a[s] = d, a);
    };
  }
}), tO = [
  "area",
  "img",
  "input"
], ul = /* @__PURE__ */ fn({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(e, { attrs: l, slots: i }) {
    const a = e.asChild ? "template" : e.as;
    return typeof a == "string" && tO.includes(a) ? () => pt(a, l) : a !== "template" ? () => pt(e.as, l, { default: i.default }) : () => pt(Tm, l, { default: i.default });
  }
});
function Ku() {
  const e = Me(), l = _e(() => ["#text", "#comment"].includes(e.value?.$el.nodeName) ? e.value?.$el.nextElementSibling : ca(e));
  return {
    primitiveElement: e,
    currentElement: l
  };
}
const iO = "dismissableLayer.pointerDownOutside", uO = "dismissableLayer.focusOutside";
function Wg(e, l) {
  const i = l.closest("[data-dismissable-layer]"), a = e.dataset.dismissableLayer === "" ? e : e.querySelector("[data-dismissable-layer]"), s = Array.from(e.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
  return !!(i && (a === i || s.indexOf(a) < s.indexOf(i)));
}
function aO(e, l, i = !0) {
  const a = l?.value?.ownerDocument ?? globalThis?.document, s = Me(!1), o = Me(() => {
  });
  return Nl((f) => {
    if (!Ha || !pn(i)) return;
    const d = async (I) => {
      const x = I.target;
      if (!(!l?.value || !x)) {
        if (Wg(l.value, x)) {
          s.value = !1;
          return;
        }
        if (I.target && !s.value) {
          let P = function() {
            is(iO, e, y);
          };
          const y = { originalEvent: I };
          I.pointerType === "touch" ? (a.removeEventListener("click", o.value), o.value = P, a.addEventListener("click", o.value, { once: !0 })) : P();
        } else a.removeEventListener("click", o.value);
        s.value = !1;
      }
    }, h = window.setTimeout(() => {
      a.addEventListener("pointerdown", d);
    }, 0);
    f(() => {
      window.clearTimeout(h), a.removeEventListener("pointerdown", d), a.removeEventListener("click", o.value);
    });
  }), { onPointerDownCapture: () => {
    pn(i) && (s.value = !0);
  } };
}
function rO(e, l, i = !0) {
  const a = l?.value?.ownerDocument ?? globalThis?.document, s = Me(!1);
  return Nl((o) => {
    if (!Ha || !pn(i)) return;
    const f = async (d) => {
      if (!l?.value) return;
      await tl(), await tl();
      const h = d.target;
      !l.value || !h || Wg(l.value, h) || d.target && !s.value && is(uO, e, { originalEvent: d });
    };
    a.addEventListener("focusin", f), o(() => a.removeEventListener("focusin", f));
  }), {
    onFocusCapture: () => {
      pn(i) && (s.value = !0);
    },
    onBlurCapture: () => {
      pn(i) && (s.value = !1);
    }
  };
}
const Ci = Ua({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var sO = /* @__PURE__ */ fn({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "dismiss"
  ],
  setup(e, { emit: l }) {
    const i = e, a = l, { forwardRef: s, currentElement: o } = Ct(), f = _e(() => o.value?.ownerDocument ?? globalThis.document), d = _e(() => Ci.layersRoot), h = _e(() => o.value ? Array.from(d.value).indexOf(o.value) : -1), I = _e(() => Ci.layersWithOutsidePointerEventsDisabled.size > 0), x = _e(() => {
      const R = Array.from(d.value), [V] = [...Ci.layersWithOutsidePointerEventsDisabled].slice(-1), K = R.indexOf(V);
      return h.value >= K;
    }), y = aO(async (R) => {
      const V = [...Ci.branches].some((K) => K?.contains(R.target));
      !x.value || V || (a("pointerDownOutside", R), a("interactOutside", R), await tl(), R.defaultPrevented || a("dismiss"));
    }, o), P = rO((R) => {
      [...Ci.branches].some((K) => K?.contains(R.target)) || (a("focusOutside", R), a("interactOutside", R), R.defaultPrevented || a("dismiss"));
    }, o);
    A0("Escape", (R) => {
      h.value === d.value.size - 1 && (a("escapeKeyDown", R), R.defaultPrevented || a("dismiss"));
    });
    let E;
    return Nl((R) => {
      o.value && (i.disableOutsidePointerEvents && (Ci.layersWithOutsidePointerEventsDisabled.size === 0 && (E = f.value.body.style.pointerEvents, f.value.body.style.pointerEvents = "none"), Ci.layersWithOutsidePointerEventsDisabled.add(o.value)), d.value.add(o.value), R(() => {
        i.disableOutsidePointerEvents && Ci.layersWithOutsidePointerEventsDisabled.size === 1 && (f.value.body.style.pointerEvents = E);
      }));
    }), Nl((R) => {
      R(() => {
        o.value && (d.value.delete(o.value), Ci.layersWithOutsidePointerEventsDisabled.delete(o.value));
      });
    }), (R, V) => (tn(), vn(ue(ul), {
      ref: ue(s),
      "as-child": R.asChild,
      as: R.as,
      "data-dismissable-layer": "",
      style: Gi({ pointerEvents: I.value ? x.value ? "auto" : "none" : void 0 }),
      onFocusCapture: ue(P).onFocusCapture,
      onBlurCapture: ue(P).onBlurCapture,
      onPointerdownCapture: ue(y).onPointerDownCapture
    }, {
      default: nn(() => [Pn(R.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "style",
      "onFocusCapture",
      "onBlurCapture",
      "onPointerdownCapture"
    ]));
  }
}), cO = sO;
const Md = "data-reka-collection-item";
function $a(e = {}) {
  const { key: l = "", isProvider: i = !1 } = e, a = `${l}CollectionProvider`;
  let s;
  if (i) {
    const x = Me(/* @__PURE__ */ new Map());
    s = {
      collectionRef: Me(),
      itemMap: x
    }, Gc(a, s);
  } else s = Ei(a);
  const o = (x = !1) => {
    const y = s.collectionRef.value;
    if (!y) return [];
    const P = Array.from(y.querySelectorAll(`[${Md}]`)), R = Array.from(s.itemMap.value.values()).sort((V, K) => P.indexOf(V.ref) - P.indexOf(K.ref));
    return x ? R : R.filter((V) => V.ref.dataset.disabled !== "");
  }, f = /* @__PURE__ */ fn({
    name: "CollectionSlot",
    setup(x, { slots: y }) {
      const { primitiveElement: P, currentElement: E } = Ku();
      return Sn(E, () => {
        s.collectionRef.value = E.value;
      }), () => pt(Tm, { ref: P }, y);
    }
  }), d = /* @__PURE__ */ fn({
    name: "CollectionItem",
    inheritAttrs: !1,
    props: { value: { validator: () => !0 } },
    setup(x, { slots: y, attrs: P }) {
      const { primitiveElement: E, currentElement: R } = Ku();
      return Nl((V) => {
        if (R.value) {
          const K = Ka(R.value);
          s.itemMap.value.set(K, {
            ref: R.value,
            value: x.value
          }), V(() => s.itemMap.value.delete(K));
        }
      }), () => pt(Tm, {
        ...P,
        [Md]: "",
        ref: E
      }, y);
    }
  }), h = _e(() => Array.from(s.itemMap.value.values())), I = _e(() => s.itemMap.value.size);
  return {
    getItems: o,
    reactiveItems: h,
    itemMapSize: I,
    CollectionSlot: f,
    CollectionItem: d
  };
}
const oO = "rovingFocusGroup.onEntryFocus", mO = {
  bubbles: !1,
  cancelable: !0
}, Yg = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function fO(e, l) {
  return l !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function Xg(e, l, i) {
  const a = fO(e.key, i);
  if (!(l === "vertical" && ["ArrowLeft", "ArrowRight"].includes(a)) && !(l === "horizontal" && ["ArrowUp", "ArrowDown"].includes(a)))
    return Yg[a];
}
function Qg(e, l = !1) {
  const i = ka();
  for (const a of e)
    if (a === i || (a.focus({ preventScroll: l }), ka() !== i)) return;
}
function dO(e, l) {
  return e.map((i, a) => e[(l + a) % e.length]);
}
const [pO, hO] = hi("RovingFocusGroup");
var gO = /* @__PURE__ */ fn({
  __name: "RovingFocusGroup",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    currentTabStopId: {
      type: [String, null],
      required: !1
    },
    defaultCurrentTabStopId: {
      type: String,
      required: !1
    },
    preventScrollOnEntryFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, { loop: o, orientation: f, dir: d } = wt(a), h = Ls(d), I = Uu(a, "currentTabStopId", s, {
      defaultValue: a.defaultCurrentTabStopId,
      passive: a.currentTabStopId === void 0
    }), x = Me(!1), y = Me(!1), P = Me(0), { getItems: E, CollectionSlot: R } = $a({ isProvider: !0 });
    function V($) {
      const Q = !y.value;
      if ($.currentTarget && $.target === $.currentTarget && Q && !x.value) {
        const Z = new CustomEvent(oO, mO);
        if ($.currentTarget.dispatchEvent(Z), s("entryFocus", Z), !Z.defaultPrevented) {
          const G = E().map((M) => M.ref).filter((M) => M.dataset.disabled !== ""), Y = G.find((M) => M.getAttribute("data-active") === ""), se = G.find((M) => M.getAttribute("data-highlighted") === ""), te = G.find((M) => M.id === I.value), fe = [
            Y,
            se,
            te,
            ...G
          ].filter(Boolean);
          Qg(fe, a.preventScrollOnEntryFocus);
        }
      }
      y.value = !1;
    }
    function K() {
      setTimeout(() => {
        y.value = !1;
      }, 1);
    }
    return l({ getItems: E }), hO({
      loop: o,
      dir: h,
      orientation: f,
      currentTabStopId: I,
      onItemFocus: ($) => {
        I.value = $;
      },
      onItemShiftTab: () => {
        x.value = !0;
      },
      onFocusableItemAdd: () => {
        P.value++;
      },
      onFocusableItemRemove: () => {
        P.value--;
      }
    }), ($, Q) => (tn(), vn(ue(R), null, {
      default: nn(() => [Ye(ue(ul), {
        tabindex: x.value || P.value === 0 ? -1 : 0,
        "data-orientation": ue(f),
        as: $.as,
        "as-child": $.asChild,
        dir: ue(h),
        style: { outline: "none" },
        onMousedown: Q[0] || (Q[0] = (Z) => y.value = !0),
        onMouseup: K,
        onFocus: V,
        onBlur: Q[1] || (Q[1] = (Z) => x.value = !1)
      }, {
        default: nn(() => [Pn($.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "as",
        "as-child",
        "dir"
      ])]),
      _: 3
    }));
  }
}), vO = gO, xO = /* @__PURE__ */ fn({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {
      type: String,
      required: !1
    },
    focusable: {
      type: Boolean,
      required: !1,
      default: !0
    },
    active: {
      type: Boolean,
      required: !1
    },
    allowShiftKey: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const l = e, i = pO(), a = oa(), s = _e(() => l.tabStopId || a), o = _e(() => i.currentTabStopId.value === s.value), { getItems: f, CollectionItem: d } = $a();
    vl(() => {
      l.focusable && i.onFocusableItemAdd();
    }), St(() => {
      l.focusable && i.onFocusableItemRemove();
    });
    function h(I) {
      if (I.key === "Tab" && I.shiftKey) {
        i.onItemShiftTab();
        return;
      }
      if (I.target !== I.currentTarget) return;
      const x = Xg(I, i.orientation.value, i.dir.value);
      if (x !== void 0) {
        if (I.metaKey || I.ctrlKey || I.altKey || !l.allowShiftKey && I.shiftKey) return;
        I.preventDefault();
        let y = [...f().map((P) => P.ref).filter((P) => P.dataset.disabled !== "")];
        if (x === "last") y.reverse();
        else if (x === "prev" || x === "next") {
          x === "prev" && y.reverse();
          const P = y.indexOf(I.currentTarget);
          y = i.loop.value ? dO(y, P + 1) : y.slice(P + 1);
        }
        tl(() => Qg(y));
      }
    }
    return (I, x) => (tn(), vn(ue(d), null, {
      default: nn(() => [Ye(ue(ul), {
        tabindex: o.value ? 0 : -1,
        "data-orientation": ue(i).orientation.value,
        "data-active": I.active ? "" : void 0,
        "data-disabled": I.focusable ? void 0 : "",
        as: I.as,
        "as-child": I.asChild,
        onMousedown: x[0] || (x[0] = (y) => {
          I.focusable ? ue(i).onItemFocus(s.value) : y.preventDefault();
        }),
        onFocus: x[1] || (x[1] = (y) => ue(i).onItemFocus(s.value)),
        onKeydown: h
      }, {
        default: nn(() => [Pn(I.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "data-active",
        "data-disabled",
        "as",
        "as-child"
      ])]),
      _: 3
    }));
  }
}), yO = xO, IO = /* @__PURE__ */ fn({
  __name: "VisuallyHidden",
  props: {
    feature: {
      type: String,
      required: !1,
      default: "focusable"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return (l, i) => (tn(), vn(ue(ul), {
      as: l.as,
      "as-child": l.asChild,
      "aria-hidden": l.feature === "focusable" ? "true" : void 0,
      "data-hidden": l.feature === "fully-hidden" ? "" : void 0,
      tabindex: l.feature === "fully-hidden" ? "-1" : void 0,
      style: {
        position: "absolute",
        border: 0,
        width: "1px",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        clipPath: "inset(50%)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        top: "-1px",
        left: "-1px"
      }
    }, {
      default: nn(() => [Pn(l.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-hidden",
      "data-hidden",
      "tabindex"
    ]));
  }
}), LO = IO, DO = /* @__PURE__ */ fn({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInputBubble",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const l = e, { primitiveElement: i, currentElement: a } = Ku(), s = _e(() => l.checked ?? l.value);
    return Sn(s, (o, f) => {
      if (!a.value) return;
      const d = a.value, h = window.HTMLInputElement.prototype, x = Object.getOwnPropertyDescriptor(h, "value").set;
      if (x && o !== f) {
        const y = new Event("input", { bubbles: !0 }), P = new Event("change", { bubbles: !0 });
        x.call(d, o), d.dispatchEvent(y), d.dispatchEvent(P);
      }
    }), (o, f) => (tn(), vn(LO, dl({
      ref_key: "primitiveElement",
      ref: i
    }, {
      ...l,
      ...o.$attrs
    }, { as: "input" }), null, 16));
  }
}), kd = DO, OO = /* @__PURE__ */ fn({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInput",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const l = e, i = _e(() => typeof l.value == "object" && Array.isArray(l.value) && l.value.length === 0 && l.required), a = _e(() => typeof l.value == "string" || typeof l.value == "number" || typeof l.value == "boolean" || l.value === null || l.value === void 0 ? [{
      name: l.name,
      value: l.value
    }] : typeof l.value == "object" && Array.isArray(l.value) ? l.value.flatMap((s, o) => typeof s == "object" ? Object.entries(s).map(([f, d]) => ({
      name: `${l.name}[${o}][${f}]`,
      value: d
    })) : {
      name: `${l.name}[${o}]`,
      value: s
    }) : l.value !== null && typeof l.value == "object" && !Array.isArray(l.value) ? Object.entries(l.value).map(([s, o]) => ({
      name: `${l.name}[${s}]`,
      value: o
    })) : []);
    return (s, o) => (tn(), Bl(Vn, null, [Zi(" We render single input if it's required "), i.value ? (tn(), vn(kd, dl({ key: s.name }, {
      ...l,
      ...s.$attrs
    }, {
      name: s.name,
      value: s.value
    }), null, 16, ["name", "value"])) : (tn(!0), Bl(Vn, { key: 1 }, gs(a.value, (f) => (tn(), vn(kd, dl({ key: f.name }, { ref_for: !0 }, {
      ...l,
      ...s.$attrs
    }, {
      name: f.name,
      value: f.value
    }), null, 16, ["name", "value"]))), 128))], 2112));
  }
}), wO = OO;
const [Jg, bO] = hi("PopperRoot");
var SO = /* @__PURE__ */ fn({
  inheritAttrs: !1,
  __name: "PopperRoot",
  setup(e) {
    const l = Me();
    return bO({
      anchor: l,
      onAnchorChange: (i) => l.value = i
    }), (i, a) => Pn(i.$slots, "default");
  }
}), CO = SO, TO = /* @__PURE__ */ fn({
  __name: "PopperAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const l = e, { forwardRef: i, currentElement: a } = Ct(), s = Jg();
    return uf(() => {
      s.onAnchorChange(l.reference ?? a.value);
    }), (o, f) => (tn(), vn(ue(ul), {
      ref: ue(i),
      as: o.as,
      "as-child": o.asChild
    }, {
      default: nn(() => [Pn(o.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), qO = TO;
function PO(e) {
  return e !== null;
}
function RO(e) {
  return {
    name: "transformOrigin",
    options: e,
    fn(l) {
      const { placement: i, rects: a, middlewareData: s } = l, f = s.arrow?.centerOffset !== 0, d = f ? 0 : e.arrowWidth, h = f ? 0 : e.arrowHeight, [I, x] = qm(i), y = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[x], P = (s.arrow?.x ?? 0) + d / 2, E = (s.arrow?.y ?? 0) + h / 2;
      let R = "", V = "";
      return I === "bottom" ? (R = f ? y : `${P}px`, V = `${-h}px`) : I === "top" ? (R = f ? y : `${P}px`, V = `${a.floating.height + h}px`) : I === "right" ? (R = `${-h}px`, V = f ? y : `${E}px`) : I === "left" && (R = `${a.floating.width + h}px`, V = f ? y : `${E}px`), { data: {
        x: R,
        y: V
      } };
    }
  };
}
function qm(e) {
  const [l, i = "center"] = e.split("-");
  return [l, i];
}
const AO = ["top", "right", "bottom", "left"], Gu = Math.min, vt = Math.max, Oc = Math.round, Vs = Math.floor, Di = (e) => ({
  x: e,
  y: e
}), EO = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, _O = {
  start: "end",
  end: "start"
};
function Pm(e, l, i) {
  return vt(e, Gu(l, i));
}
function Ui(e, l) {
  return typeof e == "function" ? e(l) : e;
}
function Ki(e) {
  return e.split("-")[0];
}
function Wa(e) {
  return e.split("-")[1];
}
function xf(e) {
  return e === "x" ? "y" : "x";
}
function yf(e) {
  return e === "y" ? "height" : "width";
}
const NO = /* @__PURE__ */ new Set(["top", "bottom"]);
function Li(e) {
  return NO.has(Ki(e)) ? "y" : "x";
}
function If(e) {
  return xf(Li(e));
}
function FO(e, l, i) {
  i === void 0 && (i = !1);
  const a = Wa(e), s = If(e), o = yf(s);
  let f = s === "x" ? a === (i ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return l.reference[o] > l.floating[o] && (f = wc(f)), [f, wc(f)];
}
function MO(e) {
  const l = wc(e);
  return [Rm(e), l, Rm(l)];
}
function Rm(e) {
  return e.replace(/start|end/g, (l) => _O[l]);
}
const Vd = ["left", "right"], Bd = ["right", "left"], kO = ["top", "bottom"], VO = ["bottom", "top"];
function BO(e, l, i) {
  switch (e) {
    case "top":
    case "bottom":
      return i ? l ? Bd : Vd : l ? Vd : Bd;
    case "left":
    case "right":
      return l ? kO : VO;
    default:
      return [];
  }
}
function ZO(e, l, i, a) {
  const s = Wa(e);
  let o = BO(Ki(e), i === "start", a);
  return s && (o = o.map((f) => f + "-" + s), l && (o = o.concat(o.map(Rm)))), o;
}
function wc(e) {
  return e.replace(/left|right|bottom|top/g, (l) => EO[l]);
}
function UO(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function ev(e) {
  return typeof e != "number" ? UO(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function bc(e) {
  const {
    x: l,
    y: i,
    width: a,
    height: s
  } = e;
  return {
    width: a,
    height: s,
    top: i,
    left: l,
    right: l + a,
    bottom: i + s,
    x: l,
    y: i
  };
}
function Zd(e, l, i) {
  let {
    reference: a,
    floating: s
  } = e;
  const o = Li(l), f = If(l), d = yf(f), h = Ki(l), I = o === "y", x = a.x + a.width / 2 - s.width / 2, y = a.y + a.height / 2 - s.height / 2, P = a[d] / 2 - s[d] / 2;
  let E;
  switch (h) {
    case "top":
      E = {
        x,
        y: a.y - s.height
      };
      break;
    case "bottom":
      E = {
        x,
        y: a.y + a.height
      };
      break;
    case "right":
      E = {
        x: a.x + a.width,
        y
      };
      break;
    case "left":
      E = {
        x: a.x - s.width,
        y
      };
      break;
    default:
      E = {
        x: a.x,
        y: a.y
      };
  }
  switch (Wa(l)) {
    case "start":
      E[f] -= P * (i && I ? -1 : 1);
      break;
    case "end":
      E[f] += P * (i && I ? -1 : 1);
      break;
  }
  return E;
}
const KO = async (e, l, i) => {
  const {
    placement: a = "bottom",
    strategy: s = "absolute",
    middleware: o = [],
    platform: f
  } = i, d = o.filter(Boolean), h = await (f.isRTL == null ? void 0 : f.isRTL(l));
  let I = await f.getElementRects({
    reference: e,
    floating: l,
    strategy: s
  }), {
    x,
    y
  } = Zd(I, a, h), P = a, E = {}, R = 0;
  for (let V = 0; V < d.length; V++) {
    const {
      name: K,
      fn: $
    } = d[V], {
      x: Q,
      y: Z,
      data: G,
      reset: Y
    } = await $({
      x,
      y,
      initialPlacement: a,
      placement: P,
      strategy: s,
      middlewareData: E,
      rects: I,
      platform: f,
      elements: {
        reference: e,
        floating: l
      }
    });
    x = Q ?? x, y = Z ?? y, E = {
      ...E,
      [K]: {
        ...E[K],
        ...G
      }
    }, Y && R <= 50 && (R++, typeof Y == "object" && (Y.placement && (P = Y.placement), Y.rects && (I = Y.rects === !0 ? await f.getElementRects({
      reference: e,
      floating: l,
      strategy: s
    }) : Y.rects), {
      x,
      y
    } = Zd(I, P, h)), V = -1);
  }
  return {
    x,
    y,
    placement: P,
    strategy: s,
    middlewareData: E
  };
};
async function us(e, l) {
  var i;
  l === void 0 && (l = {});
  const {
    x: a,
    y: s,
    platform: o,
    rects: f,
    elements: d,
    strategy: h
  } = e, {
    boundary: I = "clippingAncestors",
    rootBoundary: x = "viewport",
    elementContext: y = "floating",
    altBoundary: P = !1,
    padding: E = 0
  } = Ui(l, e), R = ev(E), K = d[P ? y === "floating" ? "reference" : "floating" : y], $ = bc(await o.getClippingRect({
    element: (i = await (o.isElement == null ? void 0 : o.isElement(K))) == null || i ? K : K.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(d.floating)),
    boundary: I,
    rootBoundary: x,
    strategy: h
  })), Q = y === "floating" ? {
    x: a,
    y: s,
    width: f.floating.width,
    height: f.floating.height
  } : f.reference, Z = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(d.floating)), G = await (o.isElement == null ? void 0 : o.isElement(Z)) ? await (o.getScale == null ? void 0 : o.getScale(Z)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, Y = bc(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: d,
    rect: Q,
    offsetParent: Z,
    strategy: h
  }) : Q);
  return {
    top: ($.top - Y.top + R.top) / G.y,
    bottom: (Y.bottom - $.bottom + R.bottom) / G.y,
    left: ($.left - Y.left + R.left) / G.x,
    right: (Y.right - $.right + R.right) / G.x
  };
}
const GO = (e) => ({
  name: "arrow",
  options: e,
  async fn(l) {
    const {
      x: i,
      y: a,
      placement: s,
      rects: o,
      platform: f,
      elements: d,
      middlewareData: h
    } = l, {
      element: I,
      padding: x = 0
    } = Ui(e, l) || {};
    if (I == null)
      return {};
    const y = ev(x), P = {
      x: i,
      y: a
    }, E = If(s), R = yf(E), V = await f.getDimensions(I), K = E === "y", $ = K ? "top" : "left", Q = K ? "bottom" : "right", Z = K ? "clientHeight" : "clientWidth", G = o.reference[R] + o.reference[E] - P[E] - o.floating[R], Y = P[E] - o.reference[E], se = await (f.getOffsetParent == null ? void 0 : f.getOffsetParent(I));
    let te = se ? se[Z] : 0;
    (!te || !await (f.isElement == null ? void 0 : f.isElement(se))) && (te = d.floating[Z] || o.floating[R]);
    const fe = G / 2 - Y / 2, M = te / 2 - V[R] / 2 - 1, oe = Gu(y[$], M), Le = Gu(y[Q], M), ae = oe, ye = te - V[R] - Le, he = te / 2 - V[R] / 2 + fe, Ce = Pm(ae, he, ye), xe = !h.arrow && Wa(s) != null && he !== Ce && o.reference[R] / 2 - (he < ae ? oe : Le) - V[R] / 2 < 0, ce = xe ? he < ae ? he - ae : he - ye : 0;
    return {
      [E]: P[E] + ce,
      data: {
        [E]: Ce,
        centerOffset: he - Ce - ce,
        ...xe && {
          alignmentOffset: ce
        }
      },
      reset: xe
    };
  }
}), zO = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(l) {
      var i, a;
      const {
        placement: s,
        middlewareData: o,
        rects: f,
        initialPlacement: d,
        platform: h,
        elements: I
      } = l, {
        mainAxis: x = !0,
        crossAxis: y = !0,
        fallbackPlacements: P,
        fallbackStrategy: E = "bestFit",
        fallbackAxisSideDirection: R = "none",
        flipAlignment: V = !0,
        ...K
      } = Ui(e, l);
      if ((i = o.arrow) != null && i.alignmentOffset)
        return {};
      const $ = Ki(s), Q = Li(d), Z = Ki(d) === d, G = await (h.isRTL == null ? void 0 : h.isRTL(I.floating)), Y = P || (Z || !V ? [wc(d)] : MO(d)), se = R !== "none";
      !P && se && Y.push(...ZO(d, V, R, G));
      const te = [d, ...Y], fe = await us(l, K), M = [];
      let oe = ((a = o.flip) == null ? void 0 : a.overflows) || [];
      if (x && M.push(fe[$]), y) {
        const he = FO(s, f, G);
        M.push(fe[he[0]], fe[he[1]]);
      }
      if (oe = [...oe, {
        placement: s,
        overflows: M
      }], !M.every((he) => he <= 0)) {
        var Le, ae;
        const he = (((Le = o.flip) == null ? void 0 : Le.index) || 0) + 1, Ce = te[he];
        if (Ce && (!(y === "alignment" ? Q !== Li(Ce) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        oe.every((de) => Li(de.placement) === Q ? de.overflows[0] > 0 : !0)))
          return {
            data: {
              index: he,
              overflows: oe
            },
            reset: {
              placement: Ce
            }
          };
        let xe = (ae = oe.filter((ce) => ce.overflows[0] <= 0).sort((ce, de) => ce.overflows[1] - de.overflows[1])[0]) == null ? void 0 : ae.placement;
        if (!xe)
          switch (E) {
            case "bestFit": {
              var ye;
              const ce = (ye = oe.filter((de) => {
                if (se) {
                  const we = Li(de.placement);
                  return we === Q || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  we === "y";
                }
                return !0;
              }).map((de) => [de.placement, de.overflows.filter((we) => we > 0).reduce((we, Ae) => we + Ae, 0)]).sort((de, we) => de[1] - we[1])[0]) == null ? void 0 : ye[0];
              ce && (xe = ce);
              break;
            }
            case "initialPlacement":
              xe = d;
              break;
          }
        if (s !== xe)
          return {
            reset: {
              placement: xe
            }
          };
      }
      return {};
    }
  };
};
function Ud(e, l) {
  return {
    top: e.top - l.height,
    right: e.right - l.width,
    bottom: e.bottom - l.height,
    left: e.left - l.width
  };
}
function Kd(e) {
  return AO.some((l) => e[l] >= 0);
}
const jO = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(l) {
      const {
        rects: i
      } = l, {
        strategy: a = "referenceHidden",
        ...s
      } = Ui(e, l);
      switch (a) {
        case "referenceHidden": {
          const o = await us(l, {
            ...s,
            elementContext: "reference"
          }), f = Ud(o, i.reference);
          return {
            data: {
              referenceHiddenOffsets: f,
              referenceHidden: Kd(f)
            }
          };
        }
        case "escaped": {
          const o = await us(l, {
            ...s,
            altBoundary: !0
          }), f = Ud(o, i.floating);
          return {
            data: {
              escapedOffsets: f,
              escaped: Kd(f)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, nv = /* @__PURE__ */ new Set(["left", "top"]);
async function HO(e, l) {
  const {
    placement: i,
    platform: a,
    elements: s
  } = e, o = await (a.isRTL == null ? void 0 : a.isRTL(s.floating)), f = Ki(i), d = Wa(i), h = Li(i) === "y", I = nv.has(f) ? -1 : 1, x = o && h ? -1 : 1, y = Ui(l, e);
  let {
    mainAxis: P,
    crossAxis: E,
    alignmentAxis: R
  } = typeof y == "number" ? {
    mainAxis: y,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: y.mainAxis || 0,
    crossAxis: y.crossAxis || 0,
    alignmentAxis: y.alignmentAxis
  };
  return d && typeof R == "number" && (E = d === "end" ? R * -1 : R), h ? {
    x: E * x,
    y: P * I
  } : {
    x: P * I,
    y: E * x
  };
}
const $O = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(l) {
      var i, a;
      const {
        x: s,
        y: o,
        placement: f,
        middlewareData: d
      } = l, h = await HO(l, e);
      return f === ((i = d.offset) == null ? void 0 : i.placement) && (a = d.arrow) != null && a.alignmentOffset ? {} : {
        x: s + h.x,
        y: o + h.y,
        data: {
          ...h,
          placement: f
        }
      };
    }
  };
}, WO = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(l) {
      const {
        x: i,
        y: a,
        placement: s
      } = l, {
        mainAxis: o = !0,
        crossAxis: f = !1,
        limiter: d = {
          fn: (K) => {
            let {
              x: $,
              y: Q
            } = K;
            return {
              x: $,
              y: Q
            };
          }
        },
        ...h
      } = Ui(e, l), I = {
        x: i,
        y: a
      }, x = await us(l, h), y = Li(Ki(s)), P = xf(y);
      let E = I[P], R = I[y];
      if (o) {
        const K = P === "y" ? "top" : "left", $ = P === "y" ? "bottom" : "right", Q = E + x[K], Z = E - x[$];
        E = Pm(Q, E, Z);
      }
      if (f) {
        const K = y === "y" ? "top" : "left", $ = y === "y" ? "bottom" : "right", Q = R + x[K], Z = R - x[$];
        R = Pm(Q, R, Z);
      }
      const V = d.fn({
        ...l,
        [P]: E,
        [y]: R
      });
      return {
        ...V,
        data: {
          x: V.x - i,
          y: V.y - a,
          enabled: {
            [P]: o,
            [y]: f
          }
        }
      };
    }
  };
}, YO = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(l) {
      const {
        x: i,
        y: a,
        placement: s,
        rects: o,
        middlewareData: f
      } = l, {
        offset: d = 0,
        mainAxis: h = !0,
        crossAxis: I = !0
      } = Ui(e, l), x = {
        x: i,
        y: a
      }, y = Li(s), P = xf(y);
      let E = x[P], R = x[y];
      const V = Ui(d, l), K = typeof V == "number" ? {
        mainAxis: V,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...V
      };
      if (h) {
        const Z = P === "y" ? "height" : "width", G = o.reference[P] - o.floating[Z] + K.mainAxis, Y = o.reference[P] + o.reference[Z] - K.mainAxis;
        E < G ? E = G : E > Y && (E = Y);
      }
      if (I) {
        var $, Q;
        const Z = P === "y" ? "width" : "height", G = nv.has(Ki(s)), Y = o.reference[y] - o.floating[Z] + (G && (($ = f.offset) == null ? void 0 : $[y]) || 0) + (G ? 0 : K.crossAxis), se = o.reference[y] + o.reference[Z] + (G ? 0 : ((Q = f.offset) == null ? void 0 : Q[y]) || 0) - (G ? K.crossAxis : 0);
        R < Y ? R = Y : R > se && (R = se);
      }
      return {
        [P]: E,
        [y]: R
      };
    }
  };
}, XO = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(l) {
      var i, a;
      const {
        placement: s,
        rects: o,
        platform: f,
        elements: d
      } = l, {
        apply: h = () => {
        },
        ...I
      } = Ui(e, l), x = await us(l, I), y = Ki(s), P = Wa(s), E = Li(s) === "y", {
        width: R,
        height: V
      } = o.floating;
      let K, $;
      y === "top" || y === "bottom" ? (K = y, $ = P === (await (f.isRTL == null ? void 0 : f.isRTL(d.floating)) ? "start" : "end") ? "left" : "right") : ($ = y, K = P === "end" ? "top" : "bottom");
      const Q = V - x.top - x.bottom, Z = R - x.left - x.right, G = Gu(V - x[K], Q), Y = Gu(R - x[$], Z), se = !l.middlewareData.shift;
      let te = G, fe = Y;
      if ((i = l.middlewareData.shift) != null && i.enabled.x && (fe = Z), (a = l.middlewareData.shift) != null && a.enabled.y && (te = Q), se && !P) {
        const oe = vt(x.left, 0), Le = vt(x.right, 0), ae = vt(x.top, 0), ye = vt(x.bottom, 0);
        E ? fe = R - 2 * (oe !== 0 || Le !== 0 ? oe + Le : vt(x.left, x.right)) : te = V - 2 * (ae !== 0 || ye !== 0 ? ae + ye : vt(x.top, x.bottom));
      }
      await h({
        ...l,
        availableWidth: fe,
        availableHeight: te
      });
      const M = await f.getDimensions(d.floating);
      return R !== M.width || V !== M.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function no() {
  return typeof window < "u";
}
function ma(e) {
  return Lf(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function It(e) {
  var l;
  return (e == null || (l = e.ownerDocument) == null ? void 0 : l.defaultView) || window;
}
function bi(e) {
  var l;
  return (l = (Lf(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : l.documentElement;
}
function Lf(e) {
  return no() ? e instanceof Node || e instanceof It(e).Node : !1;
}
function di(e) {
  return no() ? e instanceof Element || e instanceof It(e).Element : !1;
}
function wi(e) {
  return no() ? e instanceof HTMLElement || e instanceof It(e).HTMLElement : !1;
}
function Gd(e) {
  return !no() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof It(e).ShadowRoot;
}
const QO = /* @__PURE__ */ new Set(["inline", "contents"]);
function Ds(e) {
  const {
    overflow: l,
    overflowX: i,
    overflowY: a,
    display: s
  } = pi(e);
  return /auto|scroll|overlay|hidden|clip/.test(l + a + i) && !QO.has(s);
}
const JO = /* @__PURE__ */ new Set(["table", "td", "th"]);
function ew(e) {
  return JO.has(ma(e));
}
const nw = [":popover-open", ":modal"];
function lo(e) {
  return nw.some((l) => {
    try {
      return e.matches(l);
    } catch {
      return !1;
    }
  });
}
const lw = ["transform", "translate", "scale", "rotate", "perspective"], tw = ["transform", "translate", "scale", "rotate", "perspective", "filter"], iw = ["paint", "layout", "strict", "content"];
function Df(e) {
  const l = Of(), i = di(e) ? pi(e) : e;
  return lw.some((a) => i[a] ? i[a] !== "none" : !1) || (i.containerType ? i.containerType !== "normal" : !1) || !l && (i.backdropFilter ? i.backdropFilter !== "none" : !1) || !l && (i.filter ? i.filter !== "none" : !1) || tw.some((a) => (i.willChange || "").includes(a)) || iw.some((a) => (i.contain || "").includes(a));
}
function uw(e) {
  let l = zu(e);
  for (; wi(l) && !Va(l); ) {
    if (Df(l))
      return l;
    if (lo(l))
      return null;
    l = zu(l);
  }
  return null;
}
function Of() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const aw = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Va(e) {
  return aw.has(ma(e));
}
function pi(e) {
  return It(e).getComputedStyle(e);
}
function to(e) {
  return di(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function zu(e) {
  if (ma(e) === "html")
    return e;
  const l = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Gd(e) && e.host || // Fallback.
    bi(e)
  );
  return Gd(l) ? l.host : l;
}
function lv(e) {
  const l = zu(e);
  return Va(l) ? e.ownerDocument ? e.ownerDocument.body : e.body : wi(l) && Ds(l) ? l : lv(l);
}
function as(e, l, i) {
  var a;
  l === void 0 && (l = []), i === void 0 && (i = !0);
  const s = lv(e), o = s === ((a = e.ownerDocument) == null ? void 0 : a.body), f = It(s);
  if (o) {
    const d = Am(f);
    return l.concat(f, f.visualViewport || [], Ds(s) ? s : [], d && i ? as(d) : []);
  }
  return l.concat(s, as(s, [], i));
}
function Am(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function tv(e) {
  const l = pi(e);
  let i = parseFloat(l.width) || 0, a = parseFloat(l.height) || 0;
  const s = wi(e), o = s ? e.offsetWidth : i, f = s ? e.offsetHeight : a, d = Oc(i) !== o || Oc(a) !== f;
  return d && (i = o, a = f), {
    width: i,
    height: a,
    $: d
  };
}
function wf(e) {
  return di(e) ? e : e.contextElement;
}
function Aa(e) {
  const l = wf(e);
  if (!wi(l))
    return Di(1);
  const i = l.getBoundingClientRect(), {
    width: a,
    height: s,
    $: o
  } = tv(l);
  let f = (o ? Oc(i.width) : i.width) / a, d = (o ? Oc(i.height) : i.height) / s;
  return (!f || !Number.isFinite(f)) && (f = 1), (!d || !Number.isFinite(d)) && (d = 1), {
    x: f,
    y: d
  };
}
const rw = /* @__PURE__ */ Di(0);
function iv(e) {
  const l = It(e);
  return !Of() || !l.visualViewport ? rw : {
    x: l.visualViewport.offsetLeft,
    y: l.visualViewport.offsetTop
  };
}
function sw(e, l, i) {
  return l === void 0 && (l = !1), !i || l && i !== It(e) ? !1 : l;
}
function aa(e, l, i, a) {
  l === void 0 && (l = !1), i === void 0 && (i = !1);
  const s = e.getBoundingClientRect(), o = wf(e);
  let f = Di(1);
  l && (a ? di(a) && (f = Aa(a)) : f = Aa(e));
  const d = sw(o, i, a) ? iv(o) : Di(0);
  let h = (s.left + d.x) / f.x, I = (s.top + d.y) / f.y, x = s.width / f.x, y = s.height / f.y;
  if (o) {
    const P = It(o), E = a && di(a) ? It(a) : a;
    let R = P, V = Am(R);
    for (; V && a && E !== R; ) {
      const K = Aa(V), $ = V.getBoundingClientRect(), Q = pi(V), Z = $.left + (V.clientLeft + parseFloat(Q.paddingLeft)) * K.x, G = $.top + (V.clientTop + parseFloat(Q.paddingTop)) * K.y;
      h *= K.x, I *= K.y, x *= K.x, y *= K.y, h += Z, I += G, R = It(V), V = Am(R);
    }
  }
  return bc({
    width: x,
    height: y,
    x: h,
    y: I
  });
}
function io(e, l) {
  const i = to(e).scrollLeft;
  return l ? l.left + i : aa(bi(e)).left + i;
}
function uv(e, l) {
  const i = e.getBoundingClientRect(), a = i.left + l.scrollLeft - io(e, i), s = i.top + l.scrollTop;
  return {
    x: a,
    y: s
  };
}
function cw(e) {
  let {
    elements: l,
    rect: i,
    offsetParent: a,
    strategy: s
  } = e;
  const o = s === "fixed", f = bi(a), d = l ? lo(l.floating) : !1;
  if (a === f || d && o)
    return i;
  let h = {
    scrollLeft: 0,
    scrollTop: 0
  }, I = Di(1);
  const x = Di(0), y = wi(a);
  if ((y || !y && !o) && ((ma(a) !== "body" || Ds(f)) && (h = to(a)), wi(a))) {
    const E = aa(a);
    I = Aa(a), x.x = E.x + a.clientLeft, x.y = E.y + a.clientTop;
  }
  const P = f && !y && !o ? uv(f, h) : Di(0);
  return {
    width: i.width * I.x,
    height: i.height * I.y,
    x: i.x * I.x - h.scrollLeft * I.x + x.x + P.x,
    y: i.y * I.y - h.scrollTop * I.y + x.y + P.y
  };
}
function ow(e) {
  return Array.from(e.getClientRects());
}
function mw(e) {
  const l = bi(e), i = to(e), a = e.ownerDocument.body, s = vt(l.scrollWidth, l.clientWidth, a.scrollWidth, a.clientWidth), o = vt(l.scrollHeight, l.clientHeight, a.scrollHeight, a.clientHeight);
  let f = -i.scrollLeft + io(e);
  const d = -i.scrollTop;
  return pi(a).direction === "rtl" && (f += vt(l.clientWidth, a.clientWidth) - s), {
    width: s,
    height: o,
    x: f,
    y: d
  };
}
const zd = 25;
function fw(e, l) {
  const i = It(e), a = bi(e), s = i.visualViewport;
  let o = a.clientWidth, f = a.clientHeight, d = 0, h = 0;
  if (s) {
    o = s.width, f = s.height;
    const x = Of();
    (!x || x && l === "fixed") && (d = s.offsetLeft, h = s.offsetTop);
  }
  const I = io(a);
  if (I <= 0) {
    const x = a.ownerDocument, y = x.body, P = getComputedStyle(y), E = x.compatMode === "CSS1Compat" && parseFloat(P.marginLeft) + parseFloat(P.marginRight) || 0, R = Math.abs(a.clientWidth - y.clientWidth - E);
    R <= zd && (o -= R);
  } else I <= zd && (o += I);
  return {
    width: o,
    height: f,
    x: d,
    y: h
  };
}
const dw = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function pw(e, l) {
  const i = aa(e, !0, l === "fixed"), a = i.top + e.clientTop, s = i.left + e.clientLeft, o = wi(e) ? Aa(e) : Di(1), f = e.clientWidth * o.x, d = e.clientHeight * o.y, h = s * o.x, I = a * o.y;
  return {
    width: f,
    height: d,
    x: h,
    y: I
  };
}
function jd(e, l, i) {
  let a;
  if (l === "viewport")
    a = fw(e, i);
  else if (l === "document")
    a = mw(bi(e));
  else if (di(l))
    a = pw(l, i);
  else {
    const s = iv(e);
    a = {
      x: l.x - s.x,
      y: l.y - s.y,
      width: l.width,
      height: l.height
    };
  }
  return bc(a);
}
function av(e, l) {
  const i = zu(e);
  return i === l || !di(i) || Va(i) ? !1 : pi(i).position === "fixed" || av(i, l);
}
function hw(e, l) {
  const i = l.get(e);
  if (i)
    return i;
  let a = as(e, [], !1).filter((d) => di(d) && ma(d) !== "body"), s = null;
  const o = pi(e).position === "fixed";
  let f = o ? zu(e) : e;
  for (; di(f) && !Va(f); ) {
    const d = pi(f), h = Df(f);
    !h && d.position === "fixed" && (s = null), (o ? !h && !s : !h && d.position === "static" && !!s && dw.has(s.position) || Ds(f) && !h && av(e, f)) ? a = a.filter((x) => x !== f) : s = d, f = zu(f);
  }
  return l.set(e, a), a;
}
function gw(e) {
  let {
    element: l,
    boundary: i,
    rootBoundary: a,
    strategy: s
  } = e;
  const f = [...i === "clippingAncestors" ? lo(l) ? [] : hw(l, this._c) : [].concat(i), a], d = f[0], h = f.reduce((I, x) => {
    const y = jd(l, x, s);
    return I.top = vt(y.top, I.top), I.right = Gu(y.right, I.right), I.bottom = Gu(y.bottom, I.bottom), I.left = vt(y.left, I.left), I;
  }, jd(l, d, s));
  return {
    width: h.right - h.left,
    height: h.bottom - h.top,
    x: h.left,
    y: h.top
  };
}
function vw(e) {
  const {
    width: l,
    height: i
  } = tv(e);
  return {
    width: l,
    height: i
  };
}
function xw(e, l, i) {
  const a = wi(l), s = bi(l), o = i === "fixed", f = aa(e, !0, o, l);
  let d = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const h = Di(0);
  function I() {
    h.x = io(s);
  }
  if (a || !a && !o)
    if ((ma(l) !== "body" || Ds(s)) && (d = to(l)), a) {
      const E = aa(l, !0, o, l);
      h.x = E.x + l.clientLeft, h.y = E.y + l.clientTop;
    } else s && I();
  o && !a && s && I();
  const x = s && !a && !o ? uv(s, d) : Di(0), y = f.left + d.scrollLeft - h.x - x.x, P = f.top + d.scrollTop - h.y - x.y;
  return {
    x: y,
    y: P,
    width: f.width,
    height: f.height
  };
}
function Eo(e) {
  return pi(e).position === "static";
}
function Hd(e, l) {
  if (!wi(e) || pi(e).position === "fixed")
    return null;
  if (l)
    return l(e);
  let i = e.offsetParent;
  return bi(e) === i && (i = i.ownerDocument.body), i;
}
function rv(e, l) {
  const i = It(e);
  if (lo(e))
    return i;
  if (!wi(e)) {
    let s = zu(e);
    for (; s && !Va(s); ) {
      if (di(s) && !Eo(s))
        return s;
      s = zu(s);
    }
    return i;
  }
  let a = Hd(e, l);
  for (; a && ew(a) && Eo(a); )
    a = Hd(a, l);
  return a && Va(a) && Eo(a) && !Df(a) ? i : a || uw(e) || i;
}
const yw = async function(e) {
  const l = this.getOffsetParent || rv, i = this.getDimensions, a = await i(e.floating);
  return {
    reference: xw(e.reference, await l(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: a.width,
      height: a.height
    }
  };
};
function Iw(e) {
  return pi(e).direction === "rtl";
}
const Lw = {
  convertOffsetParentRelativeRectToViewportRelativeRect: cw,
  getDocumentElement: bi,
  getClippingRect: gw,
  getOffsetParent: rv,
  getElementRects: yw,
  getClientRects: ow,
  getDimensions: vw,
  getScale: Aa,
  isElement: di,
  isRTL: Iw
};
function sv(e, l) {
  return e.x === l.x && e.y === l.y && e.width === l.width && e.height === l.height;
}
function Dw(e, l) {
  let i = null, a;
  const s = bi(e);
  function o() {
    var d;
    clearTimeout(a), (d = i) == null || d.disconnect(), i = null;
  }
  function f(d, h) {
    d === void 0 && (d = !1), h === void 0 && (h = 1), o();
    const I = e.getBoundingClientRect(), {
      left: x,
      top: y,
      width: P,
      height: E
    } = I;
    if (d || l(), !P || !E)
      return;
    const R = Vs(y), V = Vs(s.clientWidth - (x + P)), K = Vs(s.clientHeight - (y + E)), $ = Vs(x), Z = {
      rootMargin: -R + "px " + -V + "px " + -K + "px " + -$ + "px",
      threshold: vt(0, Gu(1, h)) || 1
    };
    let G = !0;
    function Y(se) {
      const te = se[0].intersectionRatio;
      if (te !== h) {
        if (!G)
          return f();
        te ? f(!1, te) : a = setTimeout(() => {
          f(!1, 1e-7);
        }, 1e3);
      }
      te === 1 && !sv(I, e.getBoundingClientRect()) && f(), G = !1;
    }
    try {
      i = new IntersectionObserver(Y, {
        ...Z,
        // Handle <iframe>s
        root: s.ownerDocument
      });
    } catch {
      i = new IntersectionObserver(Y, Z);
    }
    i.observe(e);
  }
  return f(!0), o;
}
function Ow(e, l, i, a) {
  a === void 0 && (a = {});
  const {
    ancestorScroll: s = !0,
    ancestorResize: o = !0,
    elementResize: f = typeof ResizeObserver == "function",
    layoutShift: d = typeof IntersectionObserver == "function",
    animationFrame: h = !1
  } = a, I = wf(e), x = s || o ? [...I ? as(I) : [], ...as(l)] : [];
  x.forEach(($) => {
    s && $.addEventListener("scroll", i, {
      passive: !0
    }), o && $.addEventListener("resize", i);
  });
  const y = I && d ? Dw(I, i) : null;
  let P = -1, E = null;
  f && (E = new ResizeObserver(($) => {
    let [Q] = $;
    Q && Q.target === I && E && (E.unobserve(l), cancelAnimationFrame(P), P = requestAnimationFrame(() => {
      var Z;
      (Z = E) == null || Z.observe(l);
    })), i();
  }), I && !h && E.observe(I), E.observe(l));
  let R, V = h ? aa(e) : null;
  h && K();
  function K() {
    const $ = aa(e);
    V && !sv(V, $) && i(), V = $, R = requestAnimationFrame(K);
  }
  return i(), () => {
    var $;
    x.forEach((Q) => {
      s && Q.removeEventListener("scroll", i), o && Q.removeEventListener("resize", i);
    }), y?.(), ($ = E) == null || $.disconnect(), E = null, h && cancelAnimationFrame(R);
  };
}
const ww = $O, bw = WO, $d = zO, Sw = XO, Cw = jO, Tw = GO, qw = YO, Pw = (e, l, i) => {
  const a = /* @__PURE__ */ new Map(), s = {
    platform: Lw,
    ...i
  }, o = {
    ...s.platform,
    _c: a
  };
  return KO(e, l, {
    ...s,
    platform: o
  });
};
function Rw(e) {
  return e != null && typeof e == "object" && "$el" in e;
}
function Em(e) {
  if (Rw(e)) {
    const l = e.$el;
    return Lf(l) && ma(l) === "#comment" ? null : l;
  }
  return e;
}
function La(e) {
  return typeof e == "function" ? e() : ue(e);
}
function Aw(e) {
  return {
    name: "arrow",
    options: e,
    fn(l) {
      const i = Em(La(e.element));
      return i == null ? {} : Tw({
        element: i,
        padding: e.padding
      }).fn(l);
    }
  };
}
function cv(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Wd(e, l) {
  const i = cv(e);
  return Math.round(l * i) / i;
}
function Ew(e, l, i) {
  i === void 0 && (i = {});
  const a = i.whileElementsMounted, s = _e(() => {
    var te;
    return (te = La(i.open)) != null ? te : !0;
  }), o = _e(() => La(i.middleware)), f = _e(() => {
    var te;
    return (te = La(i.placement)) != null ? te : "bottom";
  }), d = _e(() => {
    var te;
    return (te = La(i.strategy)) != null ? te : "absolute";
  }), h = _e(() => {
    var te;
    return (te = La(i.transform)) != null ? te : !0;
  }), I = _e(() => Em(e.value)), x = _e(() => Em(l.value)), y = Me(0), P = Me(0), E = Me(d.value), R = Me(f.value), V = Vl({}), K = Me(!1), $ = _e(() => {
    const te = {
      position: E.value,
      left: "0",
      top: "0"
    };
    if (!x.value)
      return te;
    const fe = Wd(x.value, y.value), M = Wd(x.value, P.value);
    return h.value ? {
      ...te,
      transform: "translate(" + fe + "px, " + M + "px)",
      ...cv(x.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: E.value,
      left: fe + "px",
      top: M + "px"
    };
  });
  let Q;
  function Z() {
    if (I.value == null || x.value == null)
      return;
    const te = s.value;
    Pw(I.value, x.value, {
      middleware: o.value,
      placement: f.value,
      strategy: d.value
    }).then((fe) => {
      y.value = fe.x, P.value = fe.y, E.value = fe.strategy, R.value = fe.placement, V.value = fe.middlewareData, K.value = te !== !1;
    });
  }
  function G() {
    typeof Q == "function" && (Q(), Q = void 0);
  }
  function Y() {
    if (G(), a === void 0) {
      Z();
      return;
    }
    if (I.value != null && x.value != null) {
      Q = a(I.value, x.value, Z);
      return;
    }
  }
  function se() {
    s.value || (K.value = !1);
  }
  return Sn([o, f, d, s], Z, {
    flush: "sync"
  }), Sn([I, x], Y, {
    flush: "sync"
  }), Sn(s, se, {
    flush: "sync"
  }), Hu() && Za(G), {
    x: Pu(y),
    y: Pu(P),
    strategy: Pu(E),
    placement: Pu(R),
    middlewareData: Pu(V),
    isPositioned: Pu(K),
    floatingStyles: $,
    update: Z
  };
}
const _w = {
  side: "bottom",
  sideOffset: 0,
  sideFlip: !0,
  align: "center",
  alignOffset: 0,
  alignFlip: !0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [DC, Nw] = hi("PopperContent");
var Fw = /* @__PURE__ */ fn({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ yh({
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ..._w }),
  emits: ["placed"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = Jg(), { forwardRef: o, currentElement: f } = Ct(), d = Me(), h = Me(), { width: I, height: x } = X0(h), y = _e(() => i.side + (i.align !== "center" ? `-${i.align}` : "")), P = _e(() => typeof i.collisionPadding == "number" ? i.collisionPadding : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...i.collisionPadding
    }), E = _e(() => Array.isArray(i.collisionBoundary) ? i.collisionBoundary : [i.collisionBoundary]), R = _e(() => ({
      padding: P.value,
      boundary: E.value.filter(PO),
      altBoundary: E.value.length > 0
    })), V = _e(() => ({
      mainAxis: i.sideFlip,
      crossAxis: i.alignFlip
    })), K = L0(() => [
      ww({
        mainAxis: i.sideOffset + x.value,
        alignmentAxis: i.alignOffset
      }),
      i.prioritizePosition && i.avoidCollisions && $d({
        ...R.value,
        ...V.value
      }),
      i.avoidCollisions && bw({
        mainAxis: !0,
        crossAxis: !!i.prioritizePosition,
        limiter: i.sticky === "partial" ? qw() : void 0,
        ...R.value
      }),
      !i.prioritizePosition && i.avoidCollisions && $d({
        ...R.value,
        ...V.value
      }),
      Sw({
        ...R.value,
        apply: ({ elements: ae, rects: ye, availableWidth: he, availableHeight: Ce }) => {
          const { width: xe, height: ce } = ye.reference, de = ae.floating.style;
          de.setProperty("--reka-popper-available-width", `${he}px`), de.setProperty("--reka-popper-available-height", `${Ce}px`), de.setProperty("--reka-popper-anchor-width", `${xe}px`), de.setProperty("--reka-popper-anchor-height", `${ce}px`);
        }
      }),
      h.value && Aw({
        element: h.value,
        padding: i.arrowPadding
      }),
      RO({
        arrowWidth: I.value,
        arrowHeight: x.value
      }),
      i.hideWhenDetached && Cw({
        strategy: "referenceHidden",
        ...R.value
      })
    ]), $ = _e(() => i.reference ?? s.anchor.value), { floatingStyles: Q, placement: Z, isPositioned: G, middlewareData: Y } = Ew($, d, {
      strategy: i.positionStrategy,
      placement: y,
      whileElementsMounted: (...ae) => Ow(...ae, {
        layoutShift: !i.disableUpdateOnLayoutShift,
        animationFrame: i.updatePositionStrategy === "always"
      }),
      middleware: K
    }), se = _e(() => qm(Z.value)[0]), te = _e(() => qm(Z.value)[1]);
    uf(() => {
      G.value && a("placed");
    });
    const fe = _e(() => Y.value.arrow?.centerOffset !== 0), M = Me("");
    Nl(() => {
      f.value && (M.value = window.getComputedStyle(f.value).zIndex);
    });
    const oe = _e(() => Y.value.arrow?.x ?? 0), Le = _e(() => Y.value.arrow?.y ?? 0);
    return Nw({
      placedSide: se,
      onArrowChange: (ae) => h.value = ae,
      arrowX: oe,
      arrowY: Le,
      shouldHideArrow: fe
    }), (ae, ye) => (tn(), Bl("div", {
      ref_key: "floatingRef",
      ref: d,
      "data-reka-popper-content-wrapper": "",
      style: Gi({
        ...ue(Q),
        transform: ue(G) ? ue(Q).transform : "translate(0, -200%)",
        minWidth: "max-content",
        zIndex: M.value,
        "--reka-popper-transform-origin": [ue(Y).transformOrigin?.x, ue(Y).transformOrigin?.y].join(" "),
        ...ue(Y).hide?.referenceHidden && {
          visibility: "hidden",
          pointerEvents: "none"
        }
      })
    }, [Ye(ue(ul), dl({ ref: ue(o) }, ae.$attrs, {
      "as-child": i.asChild,
      as: ae.as,
      "data-side": se.value,
      "data-align": te.value,
      style: { animation: ue(G) ? void 0 : "none" }
    }), {
      default: nn(() => [Pn(ae.$slots, "default")]),
      _: 3
    }, 16, [
      "as-child",
      "as",
      "data-side",
      "data-align",
      "style"
    ])], 4));
  }
}), Mw = Fw, kw = /* @__PURE__ */ fn({
  __name: "ComboboxAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { forwardRef: l } = Ct();
    return (i, a) => (tn(), vn(ue(qO), {
      "as-child": "",
      reference: i.reference
    }, {
      default: nn(() => [Ye(ue(ul), dl({
        ref: ue(l),
        "as-child": i.asChild,
        as: i.as
      }, i.$attrs), {
        default: nn(() => [Pn(i.$slots, "default")]),
        _: 3
      }, 16, ["as-child", "as"])]),
      _: 3
    }, 8, ["reference"]));
  }
}), Vw = kw;
function Bw(e, l, i) {
  return e === void 0 ? !1 : Array.isArray(e) ? e.some((a) => $r(a, l, i)) : $r(e, l, i);
}
function $r(e, l, i) {
  return e === void 0 || l === void 0 ? !1 : typeof e == "string" ? e === l : typeof i == "function" ? i(e, l) : typeof i == "string" ? e?.[i] === l?.[i] : Sm(e, l);
}
const [uo, Zw] = hi("ListboxRoot");
var Uw = /* @__PURE__ */ fn({
  __name: "ListboxRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    selectionBehavior: {
      type: String,
      required: !1,
      default: "toggle"
    },
    highlightOnHover: {
      type: Boolean,
      required: !1
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "entryFocus",
    "leave"
  ],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, { multiple: o, highlightOnHover: f, orientation: d, disabled: h, selectionBehavior: I, dir: x } = wt(a), { getItems: y } = $a({ isProvider: !0 }), { handleTypeaheadSearch: P } = $g(), { primitiveElement: E, currentElement: R } = Ku(), V = W0(), K = Ls(x), $ = Z0(R), Q = Me(), Z = Me(!1), G = Me(!0), Y = Uu(a, "modelValue", s, {
      defaultValue: a.defaultValue ?? (o.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    });
    function se(k) {
      if (Z.value = !0, a.multiple) {
        const _ = Array.isArray(Y.value) ? [...Y.value] : [], B = _.findIndex((le) => $r(le, k, a.by));
        a.selectionBehavior === "toggle" ? (B === -1 ? _.push(k) : _.splice(B, 1), Y.value = _) : (Y.value = [k], Q.value = k);
      } else a.selectionBehavior === "toggle" && $r(Y.value, k, a.by) ? Y.value = void 0 : Y.value = k;
      setTimeout(() => {
        Z.value = !1;
      }, 1);
    }
    const te = Me(null), fe = Me(null), M = Me(!1), oe = Me(!1), Le = Hr(), ae = Hr(), ye = Hr();
    function he() {
      return y().map((k) => k.ref).filter((k) => k.dataset.disabled !== "");
    }
    function Ce(k, _ = !0) {
      if (!k) return;
      te.value = k, G.value && te.value.focus(), _ && te.value.scrollIntoView({ block: "nearest" });
      const B = y().find((le) => le.ref === k);
      s("highlight", B);
    }
    function xe(k) {
      if (M.value) ye.trigger(k);
      else {
        const _ = y().find((B) => $r(B.value, k, a.by));
        _ && (te.value = _.ref, Ce(_.ref));
      }
    }
    function ce(k) {
      te.value && te.value.isConnected && (k.preventDefault(), k.stopPropagation(), oe.value || te.value.click());
    }
    function de(k) {
      if (G.value) {
        if (Z.value = !0, M.value) ae.trigger(k);
        else {
          const _ = k.altKey || k.ctrlKey || k.metaKey;
          if (_ && k.key === "a" && o.value) {
            const B = y(), le = B.map((Xe) => Xe.value);
            Y.value = [...le], k.preventDefault(), Ce(B[B.length - 1].ref);
          } else if (!_) {
            const B = P(k.key, y());
            B && Ce(B);
          }
        }
        setTimeout(() => {
          Z.value = !1;
        }, 1);
      }
    }
    function we() {
      oe.value = !0;
    }
    function Ae() {
      tl(() => {
        oe.value = !1;
      });
    }
    function $e() {
      tl(() => {
        const k = new KeyboardEvent("keydown", { key: "PageUp" });
        Cn(k);
      });
    }
    function ze(k) {
      const _ = te.value;
      _?.isConnected && (fe.value = _), te.value = null, s("leave", k);
    }
    function cn(k) {
      const _ = new CustomEvent("listbox.entryFocus", {
        bubbles: !1,
        cancelable: !0
      });
      if (k.currentTarget?.dispatchEvent(_), s("entryFocus", _), !_.defaultPrevented)
        if (fe.value) Ce(fe.value);
        else {
          const B = he()?.[0];
          Ce(B);
        }
    }
    function Cn(k) {
      const _ = Xg(k, d.value, K.value);
      if (!_) return;
      let B = he();
      if (te.value) {
        if (_ === "last") B.reverse();
        else if (_ === "prev" || _ === "next") {
          _ === "prev" && B.reverse();
          const le = B.indexOf(te.value);
          B = B.slice(le + 1);
        }
        xn(k, B[0]);
      }
      if (B.length) {
        const le = !te.value && _ === "prev" ? B.length - 1 : 0;
        Ce(B[le]);
      }
      if (M.value) return ae.trigger(k);
    }
    function xn(k, _) {
      if (!(M.value || a.selectionBehavior !== "replace" || !o.value || !Array.isArray(Y.value) || (k.altKey || k.ctrlKey || k.metaKey) && !k.shiftKey) && k.shiftKey) {
        const le = y().filter((j) => j.ref.dataset.disabled !== "");
        let Xe = le.find((j) => j.ref === _)?.value;
        if (k.key === V.END ? Xe = le[le.length - 1].value : k.key === V.HOME && (Xe = le[0].value), !Xe || !Q.value) return;
        const De = nc(le.map((j) => j.value), Q.value, Xe);
        Y.value = De;
      }
    }
    async function ln(k) {
      if (await tl(), M.value) Le.trigger(k);
      else {
        const _ = he(), B = _.find((le) => le.dataset.state === "checked");
        B ? Ce(B) : _.length && Ce(_[0]);
      }
    }
    return Sn(Y, () => {
      Z.value || tl(() => {
        ln();
      });
    }, {
      immediate: !0,
      deep: !0
    }), l({
      highlightedElement: te,
      highlightItem: xe,
      highlightFirstItem: $e,
      highlightSelected: ln,
      getItems: y
    }), Zw({
      modelValue: Y,
      onValueChange: se,
      multiple: o,
      orientation: d,
      dir: K,
      disabled: h,
      highlightOnHover: f,
      highlightedElement: te,
      isVirtual: M,
      virtualFocusHook: Le,
      virtualKeydownHook: ae,
      virtualHighlightHook: ye,
      by: a.by,
      firstValue: Q,
      selectionBehavior: I,
      focusable: G,
      onLeave: ze,
      onEnter: cn,
      changeHighlight: Ce,
      onKeydownEnter: ce,
      onKeydownNavigation: Cn,
      onKeydownTypeAhead: de,
      onCompositionStart: we,
      onCompositionEnd: Ae,
      highlightFirstItem: $e
    }), (k, _) => (tn(), vn(ue(ul), {
      ref_key: "primitiveElement",
      ref: E,
      as: k.as,
      "as-child": k.asChild,
      dir: ue(K),
      "data-disabled": ue(h) ? "" : void 0,
      onPointerleave: ze,
      onFocusout: _[0] || (_[0] = async (B) => {
        const le = B.relatedTarget || B.target;
        await tl(), te.value && ue(R) && !ue(R).contains(le) && ze(B);
      })
    }, {
      default: nn(() => [Pn(k.$slots, "default", { modelValue: ue(Y) }), ue($) && k.name ? (tn(), vn(ue(wO), {
        key: 0,
        name: k.name,
        value: ue(Y),
        disabled: ue(h),
        required: k.required
      }, null, 8, [
        "name",
        "value",
        "disabled",
        "required"
      ])) : Zi("v-if", !0)]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "dir",
      "data-disabled"
    ]));
  }
}), Kw = Uw, Gw = /* @__PURE__ */ fn({
  __name: "ListboxContent",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { CollectionSlot: l } = $a(), i = uo(), a = Kg(!1, 10);
    return (s, o) => (tn(), vn(ue(l), null, {
      default: nn(() => [Ye(ue(ul), {
        role: "listbox",
        as: s.as,
        "as-child": s.asChild,
        tabindex: ue(i).focusable.value ? ue(i).highlightedElement.value ? "-1" : "0" : void 0,
        "aria-orientation": ue(i).orientation.value,
        "aria-multiselectable": !!ue(i).multiple.value,
        "data-orientation": ue(i).orientation.value,
        onMousedown: o[0] || (o[0] = ri((f) => a.value = !0, ["left"])),
        onFocus: o[1] || (o[1] = (f) => {
          ue(a) || ue(i).onEnter(f);
        }),
        onKeydown: [
          o[2] || (o[2] = oi((f) => {
            ue(i).orientation.value === "vertical" && (f.key === "ArrowLeft" || f.key === "ArrowRight") || ue(i).orientation.value === "horizontal" && (f.key === "ArrowUp" || f.key === "ArrowDown") || (f.preventDefault(), ue(i).focusable.value && ue(i).onKeydownNavigation(f));
          }, [
            "down",
            "up",
            "left",
            "right",
            "home",
            "end"
          ])),
          oi(ue(i).onKeydownEnter, ["enter"]),
          ue(i).onKeydownTypeAhead
        ]
      }, {
        default: nn(() => [Pn(s.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "tabindex",
        "aria-orientation",
        "aria-multiselectable",
        "data-orientation",
        "onKeydown"
      ])]),
      _: 3
    }));
  }
}), zw = Gw, jw = /* @__PURE__ */ fn({
  __name: "ListboxFilter",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: l }) {
    const i = e, s = Uu(i, "modelValue", l, {
      defaultValue: "",
      passive: i.modelValue === void 0
    }), o = uo(), { primitiveElement: f, currentElement: d } = Ku(), h = _e(() => i.disabled || o.disabled.value || !1), I = Me();
    return af(() => I.value = o.highlightedElement.value?.id), vl(() => {
      o.focusable.value = !1, setTimeout(() => {
        i.autoFocus && d.value?.focus();
      }, 1);
    }), St(() => {
      o.focusable.value = !0;
    }), (x, y) => (tn(), vn(ue(ul), {
      ref_key: "primitiveElement",
      ref: f,
      as: x.as,
      "as-child": x.asChild,
      value: ue(s),
      disabled: h.value ? "" : void 0,
      "data-disabled": h.value ? "" : void 0,
      "aria-disabled": h.value ?? void 0,
      "aria-activedescendant": I.value,
      type: "text",
      onKeydown: [oi(ri(ue(o).onKeydownNavigation, ["prevent"]), [
        "down",
        "up",
        "home",
        "end"
      ]), oi(ue(o).onKeydownEnter, ["enter"])],
      onInput: y[0] || (y[0] = (P) => {
        s.value = P.target.value, ue(o).highlightFirstItem();
      }),
      onCompositionstart: ue(o).onCompositionStart,
      onCompositionend: ue(o).onCompositionEnd
    }, {
      default: nn(() => [Pn(x.$slots, "default", { modelValue: ue(s) })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "value",
      "disabled",
      "data-disabled",
      "aria-disabled",
      "aria-activedescendant",
      "onKeydown",
      "onCompositionstart",
      "onCompositionend"
    ]));
  }
}), Hw = jw;
const $w = "listbox.select", [Ww, Yw] = hi("ListboxItem");
var Xw = /* @__PURE__ */ fn({
  __name: "ListboxItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: ["select"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = oa(void 0, "reka-listbox-item"), { CollectionItem: o } = $a(), { forwardRef: f, currentElement: d } = Ct(), h = uo(), I = _e(() => d.value === h.highlightedElement.value), x = _e(() => Bw(h.modelValue.value, i.value, h.by)), y = _e(() => h.disabled.value || i.disabled);
    async function P(R) {
      a("select", R), !R?.defaultPrevented && !y.value && R && (h.onValueChange(i.value), h.changeHighlight(d.value));
    }
    function E(R) {
      const V = {
        originalEvent: R,
        value: i.value
      };
      is($w, P, V);
    }
    return Yw({ isSelected: x }), (R, V) => (tn(), vn(ue(o), { value: R.value }, {
      default: nn(() => [Yh([I.value, x.value], () => Ye(ue(ul), dl({ id: ue(s) }, R.$attrs, {
        ref: ue(f),
        role: "option",
        tabindex: ue(h).focusable.value ? I.value ? "0" : "-1" : -1,
        "aria-selected": x.value,
        as: R.as,
        "as-child": R.asChild,
        disabled: y.value ? "" : void 0,
        "data-disabled": y.value ? "" : void 0,
        "data-highlighted": I.value ? "" : void 0,
        "data-state": x.value ? "checked" : "unchecked",
        onClick: E,
        onKeydown: oi(ri(E, ["prevent"]), ["space"]),
        onPointermove: V[0] || (V[0] = (K) => {
          ue(h).highlightedElement.value !== ue(d) && (ue(h).highlightOnHover.value ? ue(h).changeHighlight(ue(d), !1) : ue(h).focusable.value || ue(h).changeHighlight(ue(d), !1));
        })
      }), {
        default: nn(() => [Pn(R.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "tabindex",
        "aria-selected",
        "as",
        "as-child",
        "disabled",
        "data-disabled",
        "data-highlighted",
        "data-state",
        "onKeydown"
      ]), V, 1)]),
      _: 3
    }, 8, ["value"]));
  }
}), Qw = Xw, Jw = /* @__PURE__ */ fn({
  __name: "ListboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const l = e;
    Ct();
    const i = Ww();
    return (a, s) => ue(i).isSelected.value ? (tn(), vn(ue(ul), dl({
      key: 0,
      "aria-hidden": "true"
    }, l), {
      default: nn(() => [Pn(a.$slots, "default")]),
      _: 3
    }, 16)) : Zi("v-if", !0);
  }
}), eb = Jw;
const [fa, nb] = hi("ComboboxRoot");
var lb = /* @__PURE__ */ fn({
  __name: "ComboboxRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    resetSearchTermOnBlur: {
      type: Boolean,
      required: !1,
      default: !0
    },
    resetSearchTermOnSelect: {
      type: Boolean,
      required: !1,
      default: !0
    },
    openOnFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    openOnClick: {
      type: Boolean,
      required: !1,
      default: !1
    },
    ignoreFilter: {
      type: Boolean,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    highlightOnHover: {
      type: Boolean,
      required: !1
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "update:open"
  ],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, { primitiveElement: o, currentElement: f } = Ku(), { multiple: d, disabled: h, ignoreFilter: I, resetSearchTermOnSelect: x, openOnFocus: y, openOnClick: P, dir: E } = wt(a), R = Ls(E), V = Uu(a, "modelValue", s, {
      defaultValue: a.defaultValue ?? (d.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    }), K = Uu(a, "open", s, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    });
    async function $(he) {
      K.value = he, Le.value = "", he ? (await tl(), o.value?.highlightSelected(), Z.value = !0) : Z.value = !1, Y.value?.focus(), setTimeout(() => {
        !he && a.resetSearchTermOnBlur && Q.trigger();
      }, 1);
    }
    const Q = Hr(), Z = Me(!1), G = Me(!1), Y = Me(), se = Me(), te = _e(() => o.value?.highlightedElement ?? void 0), fe = Me(/* @__PURE__ */ new Map()), M = Me(/* @__PURE__ */ new Map()), { contains: oe } = B0({ sensitivity: "base" }), Le = Me(""), ae = _e((he) => {
      if (!Le.value || a.ignoreFilter || G.value) return {
        count: fe.value.size,
        items: he?.items ?? /* @__PURE__ */ new Map(),
        groups: he?.groups ?? new Set(M.value.keys())
      };
      let Ce = 0;
      const xe = /* @__PURE__ */ new Map(), ce = /* @__PURE__ */ new Set();
      for (const [de, we] of fe.value) {
        const Ae = oe(we, Le.value);
        xe.set(de, Ae ? 1 : 0), Ae && Ce++;
      }
      for (const [de, we] of M.value) for (const Ae of we) if (xe.get(Ae) > 0) {
        ce.add(de);
        break;
      }
      return {
        count: Ce,
        items: xe,
        groups: ce
      };
    }), ye = Yn();
    return vl(() => {
      ye?.exposed && (ye.exposed.highlightItem = o.value?.highlightItem, ye.exposed.highlightFirstItem = o.value?.highlightFirstItem, ye.exposed.highlightSelected = o.value?.highlightSelected);
    }), l({
      filtered: ae,
      highlightedElement: te,
      highlightItem: o.value?.highlightItem,
      highlightFirstItem: o.value?.highlightFirstItem,
      highlightSelected: o.value?.highlightSelected
    }), nb({
      modelValue: V,
      multiple: d,
      disabled: h,
      open: K,
      onOpenChange: $,
      contentId: "",
      isUserInputted: Z,
      isVirtual: G,
      inputElement: Y,
      highlightedElement: te,
      onInputElementChange: (he) => Y.value = he,
      triggerElement: se,
      onTriggerElementChange: (he) => se.value = he,
      parentElement: f,
      resetSearchTermOnSelect: x,
      onResetSearchTerm: Q.on,
      allItems: fe,
      allGroups: M,
      filterSearch: Le,
      filterState: ae,
      ignoreFilter: I,
      openOnFocus: y,
      openOnClick: P
    }), (he, Ce) => (tn(), vn(ue(CO), null, {
      default: nn(() => [Ye(ue(Kw), dl({
        ref_key: "primitiveElement",
        ref: o
      }, he.$attrs, {
        modelValue: ue(V),
        "onUpdate:modelValue": Ce[0] || (Ce[0] = (xe) => kn(V) ? V.value = xe : null),
        style: { pointerEvents: ue(K) ? "auto" : void 0 },
        as: he.as,
        "as-child": he.asChild,
        dir: ue(R),
        multiple: ue(d),
        name: he.name,
        required: he.required,
        disabled: ue(h),
        "highlight-on-hover": !0,
        by: a.by,
        onHighlight: Ce[1] || (Ce[1] = (xe) => s("highlight", xe))
      }), {
        default: nn(() => [Pn(he.$slots, "default", {
          open: ue(K),
          modelValue: ue(V)
        })]),
        _: 3
      }, 16, [
        "modelValue",
        "style",
        "as",
        "as-child",
        "dir",
        "multiple",
        "name",
        "required",
        "disabled",
        "by"
      ])]),
      _: 3
    }));
  }
}), tb = lb;
const [OC, ib] = hi("ComboboxContent");
var ub = /* @__PURE__ */ fn({
  __name: "ComboboxContentImpl",
  props: {
    position: {
      type: String,
      required: !1,
      default: "inline"
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: l }) {
    const i = e, a = l, { position: s } = wt(i), o = fa(), { forwardRef: f, currentElement: d } = Ct();
    M0(i.bodyLock), H0(o.parentElement);
    const h = _e(() => i.position === "popper" ? i : {}), I = jg(h.value), x = {
      boxSizing: "border-box",
      "--reka-combobox-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-combobox-content-available-width": "var(--reka-popper-available-width)",
      "--reka-combobox-content-available-height": "var(--reka-popper-available-height)",
      "--reka-combobox-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-combobox-trigger-height": "var(--reka-popper-anchor-height)"
    };
    ib({ position: s });
    const y = Me(!1);
    return vl(() => {
      o.inputElement.value && (y.value = d.value.contains(o.inputElement.value), y.value && o.inputElement.value.focus());
    }), St(() => {
      y.value && o.triggerElement.value?.focus();
    }), (P, E) => (tn(), vn(ue(zw), { "as-child": "" }, {
      default: nn(() => [Ye(ue(cO), {
        "as-child": "",
        "disable-outside-pointer-events": P.disableOutsidePointerEvents,
        onDismiss: E[0] || (E[0] = (R) => ue(o).onOpenChange(!1)),
        onFocusOutside: E[1] || (E[1] = (R) => {
          ue(o).parentElement.value?.contains(R.target) && R.preventDefault(), a("focusOutside", R);
        }),
        onInteractOutside: E[2] || (E[2] = (R) => a("interactOutside", R)),
        onEscapeKeyDown: E[3] || (E[3] = (R) => a("escapeKeyDown", R)),
        onPointerDownOutside: E[4] || (E[4] = (R) => {
          ue(o).parentElement.value?.contains(R.target) && R.preventDefault(), a("pointerDownOutside", R);
        })
      }, {
        default: nn(() => [(tn(), vn(hs(ue(s) === "popper" ? ue(Mw) : ue(ul)), dl({
          ...P.$attrs,
          ...ue(I)
        }, {
          id: ue(o).contentId,
          ref: ue(f),
          "data-state": ue(o).open.value ? "open" : "closed",
          style: {
            display: "flex",
            flexDirection: "column",
            outline: "none",
            ...ue(s) === "popper" ? x : {}
          }
        }), {
          default: nn(() => [Pn(P.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "data-state",
          "style"
        ]))]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }));
  }
}), ab = ub, rb = /* @__PURE__ */ fn({
  __name: "ComboboxContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    position: {
      type: String,
      required: !1
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: l }) {
    const s = U0(e, l), { forwardRef: o } = Ct(), f = fa();
    return f.contentId ||= oa(void 0, "reka-combobox-content"), (d, h) => (tn(), vn(ue(lO), { present: d.forceMount || ue(f).open.value }, {
      default: nn(() => [Ye(ab, dl({
        ...ue(s),
        ...d.$attrs
      }, { ref: ue(o) }), {
        default: nn(() => [Pn(d.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"]));
  }
}), sb = rb, cb = /* @__PURE__ */ fn({
  __name: "ComboboxEmpty",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const l = e, i = fa(), a = _e(() => i.ignoreFilter.value ? i.allItems.value.size === 0 : i.filterState.value.count === 0);
    return (s, o) => a.value ? (tn(), vn(ue(ul), Ac(dl({ key: 0 }, l)), {
      default: nn(() => [Pn(s.$slots, "default", {}, () => [o[0] || (o[0] = Bu("No options"))])]),
      _: 3
    }, 16)) : Zi("v-if", !0);
  }
}), ob = cb;
const [mb, wC] = hi("ComboboxGroup");
var fb = /* @__PURE__ */ fn({
  __name: "ComboboxInput",
  props: {
    displayValue: {
      type: Function,
      required: !1
    },
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = fa(), o = uo(), { primitiveElement: f, currentElement: d } = Ku(), h = Uu(i, "modelValue", a, { passive: i.modelValue === void 0 });
    vl(() => {
      d.value && s.onInputElementChange(d.value);
    });
    function I(R) {
      s.open.value || s.onOpenChange(!0);
    }
    function x(R) {
      const V = R.target;
      s.open.value ? s.filterSearch.value = V.value : (s.onOpenChange(!0), tl(() => {
        V.value && (s.filterSearch.value = V.value, o.highlightFirstItem());
      }));
    }
    function y() {
      s.openOnFocus.value && !s.open.value && s.onOpenChange(!0);
    }
    function P() {
      s.openOnClick.value && !s.open.value && s.onOpenChange(!0);
    }
    function E() {
      const R = s.modelValue.value;
      i.displayValue ? h.value = i.displayValue(R) : !s.multiple.value && R && !Array.isArray(R) && typeof R != "object" ? h.value = R.toString() : h.value = "", tl(() => {
        h.value = h.value;
      });
    }
    return s.onResetSearchTerm(() => {
      E();
    }), Sn(s.modelValue, async () => {
      !s.isUserInputted.value && s.resetSearchTermOnSelect.value && E();
    }, {
      immediate: !0,
      deep: !0
    }), Sn(s.filterState, () => {
      !s.isVirtual.value && !s.highlightedElement.value && o.highlightFirstItem();
    }), (R, V) => (tn(), vn(ue(Hw), {
      ref_key: "primitiveElement",
      ref: f,
      modelValue: ue(h),
      "onUpdate:modelValue": V[0] || (V[0] = (K) => kn(h) ? h.value = K : null),
      as: R.as,
      "as-child": R.asChild,
      "auto-focus": R.autoFocus,
      disabled: R.disabled,
      "aria-expanded": ue(s).open.value,
      "aria-controls": ue(s).contentId,
      "aria-autocomplete": "list",
      role: "combobox",
      autocomplete: "off",
      onClick: P,
      onInput: x,
      onKeydown: oi(ri(I, ["prevent"]), ["down", "up"]),
      onFocus: y
    }, {
      default: nn(() => [Pn(R.$slots, "default")]),
      _: 3
    }, 8, [
      "modelValue",
      "as",
      "as-child",
      "auto-focus",
      "disabled",
      "aria-expanded",
      "aria-controls",
      "onKeydown"
    ]));
  }
}), db = fb, pb = /* @__PURE__ */ fn({
  __name: "ComboboxItem",
  props: {
    textValue: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = oa(void 0, "reka-combobox-item"), o = fa(), f = mb(null), { primitiveElement: d, currentElement: h } = Ku();
    if (i.value === "") throw new Error("A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.");
    const I = _e(() => {
      if (o.isVirtual.value || o.ignoreFilter.value || !o.filterSearch.value) return !0;
      {
        const x = o.filterState.value.items.get(s);
        return x === void 0 ? !0 : x > 0;
      }
    });
    return vl(() => {
      o.allItems.value.set(s, i.textValue || h.value.textContent || h.value.innerText);
      const x = f?.id;
      x && (o.allGroups.value.has(x) ? o.allGroups.value.get(x)?.add(s) : o.allGroups.value.set(x, /* @__PURE__ */ new Set([s])));
    }), St(() => {
      o.allItems.value.delete(s);
    }), (x, y) => I.value ? (tn(), vn(ue(Qw), dl({ key: 0 }, i, {
      id: ue(s),
      ref_key: "primitiveElement",
      ref: d,
      disabled: ue(o).disabled.value || x.disabled,
      onSelect: y[0] || (y[0] = (P) => {
        a("select", P), !P.defaultPrevented && !ue(o).multiple.value && !x.disabled && !ue(o).disabled.value && (P.preventDefault(), ue(o).onOpenChange(!1), ue(o).modelValue.value = i.value);
      })
    }), {
      default: nn(() => [Pn(x.$slots, "default", {}, () => [Bu(xt(x.value), 1)])]),
      _: 3
    }, 16, ["id", "disabled"])) : Zi("v-if", !0);
  }
}), hb = pb, gb = /* @__PURE__ */ fn({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const l = e;
    return (i, a) => (tn(), vn(ue(eb), Ac(rf(l)), {
      default: nn(() => [Pn(i.$slots, "default")]),
      _: 3
    }, 16));
  }
}), vb = gb, xb = /* @__PURE__ */ fn({
  __name: "ComboboxTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const l = e, { forwardRef: i, currentElement: a } = Ct(), s = fa(), o = _e(() => l.disabled || s.disabled.value || !1);
    return vl(() => {
      a.value && s.onTriggerElementChange(a.value);
    }), (f, d) => (tn(), vn(ue(ul), dl(l, {
      ref: ue(i),
      type: f.as === "button" ? "button" : void 0,
      tabindex: "-1",
      "aria-label": "Show popup",
      "aria-haspopup": "listbox",
      "aria-expanded": ue(s).open.value,
      "aria-controls": ue(s).contentId,
      "data-state": ue(s).open.value ? "open" : "closed",
      disabled: o.value,
      "data-disabled": o.value ? "" : void 0,
      "aria-disabled": o.value ?? void 0,
      onClick: d[0] || (d[0] = (h) => ue(s).onOpenChange(!ue(s).open.value))
    }), {
      default: nn(() => [Pn(f.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "aria-expanded",
      "aria-controls",
      "data-state",
      "disabled",
      "data-disabled",
      "aria-disabled"
    ]));
  }
}), yb = xb;
function ov(e) {
  const l = Jc({ nonce: Me() });
  return _e(() => e?.value || l.nonce?.value);
}
var Ib = /* @__PURE__ */ fn({
  __name: "ComboboxViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const l = e, { forwardRef: i } = Ct(), { nonce: a } = wt(l), s = ov(a), o = fa();
    return (f, d) => (tn(), Bl(Vn, null, [Ye(ue(ul), dl({
      ...f.$attrs,
      ...l
    }, {
      ref: ue(i),
      "data-reka-combobox-viewport": "",
      role: "presentation",
      style: {
        position: "relative",
        flex: ue(o).isVirtual.value ? void 0 : 1,
        overflow: "auto"
      }
    }), {
      default: nn(() => [Pn(f.$slots, "default")]),
      _: 3
    }, 16, ["style"]), Ye(ue(ul), {
      as: "style",
      nonce: ue(s)
    }, {
      default: nn(() => d[0] || (d[0] = [Bu(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-combobox-viewport]::-webkit-scrollbar { display: none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), Lb = Ib;
function gn(e, l = "Assertion failed!") {
  if (!e)
    throw console.error(l), new Error(l);
}
function mv(e, l = document) {
  if (!Is) return null;
  if (l instanceof HTMLElement && l?.dataset?.panelGroupId === e) return l;
  const i = l.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return i || null;
}
function ao(e, l = document) {
  if (!Is) return null;
  const i = l.querySelector(`[data-panel-resize-handle-id="${e}"]`);
  return i || null;
}
function fv(e, l, i = document) {
  return Is ? rs(e, i).findIndex((o) => o.getAttribute("data-panel-resize-handle-id") === l) ?? null : null;
}
function rs(e, l = document) {
  return Is ? Array.from(l.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${e}"]`)) : [];
}
function Db(e, l, i, a = document) {
  const s = ao(l, a), o = rs(e, a), f = s ? o.indexOf(s) : -1, d = i[f]?.id ?? null, h = i[f + 1]?.id ?? null;
  return [d, h];
}
function dv(e) {
  return e.type === "keydown";
}
function pv(e) {
  return e.type.startsWith("mouse");
}
function hv(e) {
  return e.type.startsWith("touch");
}
function ro(e) {
  if (pv(e)) return {
    x: e.clientX,
    y: e.clientY
  };
  if (hv(e)) {
    const l = e.touches[0];
    if (l && l.clientX && l.clientY) return {
      x: l.clientX,
      y: l.clientY
    };
  }
  return {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
  };
}
function gv(e, l) {
  const i = e === "horizontal", { x: a, y: s } = ro(l);
  return i ? a : s;
}
function Ob(e, l, i, a, s) {
  const o = i === "horizontal", f = ao(l, s);
  gn(f);
  const d = f.getAttribute("data-panel-group-id");
  gn(d);
  const { initialCursorPosition: h } = a, I = gv(i, e), x = mv(d, s);
  gn(x);
  const y = x.getBoundingClientRect(), P = o ? y.width : y.height;
  return (I - h) / P * 100;
}
function wb(e, l, i, a, s, o) {
  if (dv(e)) {
    const f = i === "horizontal";
    let d = 0;
    e.shiftKey ? d = 100 : d = s ?? 10;
    let h = 0;
    switch (e.key) {
      case "ArrowDown":
        h = f ? 0 : d;
        break;
      case "ArrowLeft":
        h = f ? -d : 0;
        break;
      case "ArrowRight":
        h = f ? d : 0;
        break;
      case "ArrowUp":
        h = f ? 0 : -d;
        break;
      case "End":
        h = 100;
        break;
      case "Home":
        h = -100;
        break;
    }
    return h;
  } else
    return a == null ? 0 : Ob(e, l, i, a, o);
}
function bb({ layout: e, panelsArray: l, pivotIndices: i }) {
  let a = 0, s = 100, o = 0, f = 0;
  const d = i[0];
  gn(d != null), l.forEach((y, P) => {
    const { constraints: E } = y, { maxSize: R = 100, minSize: V = 0 } = E;
    P === d ? (a = V, s = R) : (o += V, f += R);
  });
  const h = Math.min(s, 100 - o), I = Math.max(a, 100 - f), x = e[d];
  return {
    valueMax: h,
    valueMin: I,
    valueNow: x
  };
}
function Sb({ panelDataArray: e }) {
  const l = Array.from({ length: e.length }), i = e.map((o) => o.constraints);
  let a = 0, s = 100;
  for (let o = 0; o < e.length; o++) {
    const f = i[o];
    gn(f);
    const { defaultSize: d } = f;
    d != null && (a++, l[o] = d, s -= d);
  }
  for (let o = 0; o < e.length; o++) {
    const f = i[o];
    gn(f);
    const { defaultSize: d } = f;
    if (d != null) continue;
    const h = e.length - a, I = s / h;
    a++, l[o] = I, s -= I;
  }
  return l;
}
function br(e, l, i) {
  l.forEach((a, s) => {
    const o = e[s];
    gn(o);
    const { callbacks: f, constraints: d, id: h } = o, { collapsedSize: I = 0, collapsible: x } = d, y = i[h];
    if (y == null || a !== y) {
      i[h] = a;
      const { onCollapse: P, onExpand: E, onResize: R } = f;
      R && R(a, y), x && (P || E) && (E && (y == null || y === I) && a !== I && E(), P && (y == null || y !== I) && a === I && P());
    }
  });
}
function Cb(e, l = 10) {
  let i = null;
  return (...s) => {
    i !== null && clearTimeout(i), i = setTimeout(() => {
      e(...s);
    }, l);
  };
}
const bf = 10;
function ss(e, l, i = bf) {
  e = Number.parseFloat(e.toFixed(i)), l = Number.parseFloat(l.toFixed(i));
  const a = e - l;
  return a === 0 ? 0 : a > 0 ? 1 : -1;
}
function gt(e, l, i) {
  return ss(e, l, i) === 0;
}
function Oa({ panelConstraints: e, panelIndex: l, size: i }) {
  const a = e[l];
  gn(a != null);
  const { collapsedSize: s = 0, collapsible: o, maxSize: f = 100, minSize: d = 0 } = a;
  if (ss(i, d) < 0) if (o) {
    const h = (s + d) / 2;
    ss(i, h) < 0 ? i = s : i = d;
  } else i = d;
  return i = Math.min(f, i), i = Number.parseFloat(i.toFixed(bf)), i;
}
function Bs(e, l) {
  if (e.length !== l.length) return !1;
  for (let i = 0; i < e.length; i++) if (e[i] !== l[i]) return !1;
  return !0;
}
function Fr({ delta: e, layout: l, panelConstraints: i, pivotIndices: a, trigger: s }) {
  if (gt(e, 0)) return l;
  const o = [...l], [f, d] = a;
  gn(f != null), gn(d != null);
  let h = 0;
  if (s === "keyboard") {
    {
      const x = e < 0 ? d : f, y = i[x];
      if (gn(y), y.collapsible) {
        const P = l[x];
        gn(P != null);
        const E = i[x];
        gn(E);
        const { collapsedSize: R = 0, minSize: V = 0 } = E;
        if (gt(P, R)) {
          const K = V - P;
          ss(K, Math.abs(e)) > 0 && (e = e < 0 ? 0 - K : K);
        }
      }
    }
    {
      const x = e < 0 ? f : d, y = i[x];
      gn(y);
      const { collapsible: P } = y;
      if (P) {
        const E = l[x];
        gn(E != null);
        const R = i[x];
        gn(R);
        const { collapsedSize: V = 0, minSize: K = 0 } = R;
        if (gt(E, K)) {
          const $ = E - V;
          ss($, Math.abs(e)) > 0 && (e = e < 0 ? 0 - $ : $);
        }
      }
    }
  }
  {
    const x = e < 0 ? 1 : -1;
    let y = e < 0 ? d : f, P = 0;
    for (; ; ) {
      const R = l[y];
      gn(R != null);
      const K = Oa({
        panelConstraints: i,
        panelIndex: y,
        size: 100
      }) - R;
      if (P += K, y += x, y < 0 || y >= i.length) break;
    }
    const E = Math.min(Math.abs(e), Math.abs(P));
    e = e < 0 ? 0 - E : E;
  }
  {
    let y = e < 0 ? f : d;
    for (; y >= 0 && y < i.length; ) {
      const P = Math.abs(e) - Math.abs(h), E = l[y];
      gn(E != null);
      const R = E - P, V = Oa({
        panelConstraints: i,
        panelIndex: y,
        size: R
      });
      if (!gt(E, V) && (h += E - V, o[y] = V, h.toPrecision(3).localeCompare(Math.abs(e).toPrecision(3), void 0, { numeric: !0 }) >= 0))
        break;
      e < 0 ? y-- : y++;
    }
  }
  if (gt(h, 0)) return l;
  {
    const x = e < 0 ? d : f, y = l[x];
    gn(y != null);
    const P = y + h, E = Oa({
      panelConstraints: i,
      panelIndex: x,
      size: P
    });
    if (o[x] = E, !gt(E, P)) {
      let R = P - E, K = e < 0 ? d : f;
      for (; K >= 0 && K < i.length; ) {
        const $ = o[K];
        gn($ != null);
        const Q = $ + R, Z = Oa({
          panelConstraints: i,
          panelIndex: K,
          size: Q
        });
        if (gt($, Z) || (R -= Z - $, o[K] = Z), gt(R, 0)) break;
        e > 0 ? K-- : K++;
      }
    }
  }
  const I = o.reduce((x, y) => y + x, 0);
  return gt(I, 100) ? o : l;
}
function vv(e, l, i) {
  const a = fv(e, l, i);
  return a != null ? [a, a + 1] : [-1, -1];
}
function Tb(e, l, i) {
  return e.x < l.x + l.width && e.x + e.width > l.x && e.y < l.y + l.height && e.y + e.height > l.y;
}
function qb(e, l) {
  if (e === l) throw new Error("Cannot compare node with itself");
  const i = {
    a: Qd(e),
    b: Qd(l)
  };
  let a;
  for (; i.a.at(-1) === i.b.at(-1); )
    e = i.a.pop(), l = i.b.pop(), a = e;
  gn(a);
  const s = {
    a: Xd(Yd(i.a)),
    b: Xd(Yd(i.b))
  };
  if (s.a === s.b) {
    const o = a.childNodes, f = {
      a: i.a.at(-1),
      b: i.b.at(-1)
    };
    let d = o.length;
    for (; d--; ) {
      const h = o[d];
      if (h === f.a) return 1;
      if (h === f.b) return -1;
    }
  }
  return Math.sign(s.a - s.b);
}
const Pb = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function Rb(e) {
  const l = getComputedStyle(xv(e)).display;
  return l === "flex" || l === "inline-flex";
}
function Ab(e) {
  const l = getComputedStyle(e);
  return !!(l.position === "fixed" || l.zIndex !== "auto" && (l.position !== "static" || Rb(e)) || +l.opacity < 1 || "transform" in l && l.transform !== "none" || "webkitTransform" in l && l.webkitTransform !== "none" || "mixBlendMode" in l && l.mixBlendMode !== "normal" || "filter" in l && l.filter !== "none" || "webkitFilter" in l && l.webkitFilter !== "none" || "isolation" in l && l.isolation === "isolate" || Pb.test(l.willChange) || l.webkitOverflowScrolling === "touch");
}
function Yd(e) {
  let l = e.length;
  for (; l--; ) {
    const i = e[l];
    if (gn(i), Ab(i)) return i;
  }
  return null;
}
function Xd(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function Qd(e) {
  const l = [];
  for (; e; )
    l.push(e), e = xv(e);
  return l;
}
function xv(e) {
  return e.parentNode instanceof DocumentFragment && e.parentNode?.host || e.parentNode;
}
const yv = 1, Iv = 2, Lv = 4, Dv = 8;
function Eb() {
  if (typeof matchMedia == "function") return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
const _b = Eb() === "coarse", ju = [];
let so = !1;
const Nu = /* @__PURE__ */ new Map(), co = /* @__PURE__ */ new Map(), cs = /* @__PURE__ */ new Set();
function Nb(e, l, i, a, s, o) {
  const { ownerDocument: f } = l, d = {
    direction: i,
    element: l,
    hitAreaMargins: a,
    nonce: s,
    setResizeHandlerState: o
  }, h = Nu.get(f) ?? 0;
  return Nu.set(f, h + 1), cs.add(d), Sc(), function() {
    co.delete(e), cs.delete(d);
    const x = Nu.get(f) ?? 1;
    Nu.set(f, x - 1), Sc(), wv(), x === 1 && Nu.delete(f);
  };
}
function Zs(e) {
  const { target: l } = e, { x: i, y: a } = ro(e);
  so = !0, Sf({
    target: l,
    x: i,
    y: a
  }), Sc(), ju.length > 0 && (Cf("down", e), e.preventDefault());
}
function bu(e) {
  const { x: l, y: i } = ro(e);
  if (!so) {
    const { target: a } = e;
    Sf({
      target: a,
      x: l,
      y: i
    });
  }
  Cf("move", e), Ov(), ju.length > 0 && e.preventDefault();
}
function Su(e) {
  const { target: l } = e, { x: i, y: a } = ro(e);
  co.clear(), so = !1, ju.length > 0 && e.preventDefault(), Cf("up", e), Sf({
    target: l,
    x: i,
    y: a
  }), Ov(), Sc();
}
function Sf({ target: e, x: l, y: i }) {
  ju.splice(0);
  let a = null;
  e instanceof HTMLElement && (a = e), cs.forEach((s) => {
    const { element: o, hitAreaMargins: f } = s, d = o.getBoundingClientRect(), { bottom: h, left: I, right: x, top: y } = d, P = _b ? f.coarse : f.fine;
    if (l >= I - P && l <= x + P && i >= y - P && i <= h + P) {
      if (a !== null && o !== a && !o.contains(a) && !a.contains(o) && qb(a, o) > 0) {
        let R = a, V = !1;
        for (; R && !R.contains(o); ) {
          if (Tb(R.getBoundingClientRect(), d)) {
            V = !0;
            break;
          }
          R = R.parentElement;
        }
        if (V) return;
      }
      ju.push(s);
    }
  });
}
function _o(e, l) {
  co.set(e, l);
}
function Ov() {
  let e = !1, l = !1, i;
  ju.forEach((s) => {
    const { direction: o, nonce: f } = s;
    o.value === "horizontal" ? e = !0 : l = !0, i = f.value;
  });
  let a = 0;
  co.forEach((s) => {
    a |= s;
  }), e && l ? No("intersection", a, i) : e ? No("horizontal", a, i) : l ? No("vertical", a, i) : wv();
}
function Sc() {
  Nu.forEach((e, l) => {
    const { body: i } = l;
    i.removeEventListener("contextmenu", Su), i.removeEventListener("mousedown", Zs), i.removeEventListener("mouseleave", bu), i.removeEventListener("mousemove", bu), i.removeEventListener("touchmove", bu), i.removeEventListener("touchstart", Zs);
  }), window.removeEventListener("mouseup", Su), window.removeEventListener("touchcancel", Su), window.removeEventListener("touchend", Su), cs.size > 0 && (so ? (ju.length > 0 && Nu.forEach((e, l) => {
    const { body: i } = l;
    e > 0 && (i.addEventListener("contextmenu", Su), i.addEventListener("mouseleave", bu), i.addEventListener("mousemove", bu), i.addEventListener("touchmove", bu, { passive: !1 }));
  }), window.addEventListener("mouseup", Su), window.addEventListener("touchcancel", Su), window.addEventListener("touchend", Su)) : Nu.forEach((e, l) => {
    const { body: i } = l;
    e > 0 && (i.addEventListener("mousedown", Zs), i.addEventListener("mousemove", bu), i.addEventListener("touchmove", bu, { passive: !1 }), i.addEventListener("touchstart", Zs));
  }));
}
function Cf(e, l) {
  cs.forEach((i) => {
    const { setResizeHandlerState: a } = i, s = ju.includes(i);
    a(e, s, l);
  });
}
let _m = null, Fu = null;
function Fb(e, l) {
  if (l) {
    const i = (l & yv) !== 0, a = (l & Iv) !== 0, s = (l & Lv) !== 0, o = (l & Dv) !== 0;
    if (i) return s ? "se-resize" : o ? "ne-resize" : "e-resize";
    if (a) return s ? "sw-resize" : o ? "nw-resize" : "w-resize";
    if (s) return "s-resize";
    if (o) return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function wv() {
  Fu !== null && (document.head.removeChild(Fu), _m = null, Fu = null);
}
function No(e, l, i) {
  const a = Fb(e, l);
  _m !== a && (_m = a, Fu === null && (Fu = document.createElement("style"), i && (Fu.nonce = i), document.head.appendChild(Fu)), Fu.innerHTML = `*{cursor: ${a}!important;}`);
}
function Mb({ defaultSize: e, dragState: l, layout: i, panelData: a, panelIndex: s, precision: o = 3 }) {
  const f = i[s];
  let d;
  return f == null ? d = e !== void 0 ? e.toPrecision(o) : "1" : a.length === 1 ? d = "1" : d = f.toPrecision(o), {
    flexBasis: 0,
    flexGrow: d,
    flexShrink: 1,
    overflow: "hidden",
    pointerEvents: l !== null ? "none" : void 0
  };
}
function kb({ layout: e, panelConstraints: l }) {
  const i = [...e], a = i.reduce((o, f) => o + f, 0);
  if (i.length !== l.length) throw new Error(`Invalid ${l.length} panel layout: ${i.map((o) => `${o}%`).join(", ")}`);
  if (!gt(a, 100)) {
    console.warn(`WARNING: Invalid layout total size: ${i.map((o) => `${o}%`).join(", ")}. Layout normalization will be applied.`);
    for (let o = 0; o < l.length; o++) {
      const f = i[o];
      gn(f != null);
      const d = 100 / a * f;
      i[o] = d;
    }
  }
  let s = 0;
  for (let o = 0; o < l.length; o++) {
    const f = i[o];
    gn(f != null);
    const d = Oa({
      panelConstraints: l,
      panelIndex: o,
      size: f
    });
    f !== d && (s += f - d, i[o] = d);
  }
  if (!gt(s, 0)) for (let o = 0; o < l.length; o++) {
    const f = i[o];
    gn(f != null);
    const d = f + s, h = Oa({
      panelConstraints: l,
      panelIndex: o,
      size: d
    });
    if (f !== h && (s -= h - f, i[o] = h, gt(s, 0)))
      break;
  }
  return i;
}
function Vb({ eagerValuesRef: e, groupId: l, layout: i, panelDataArray: a, panelGroupElement: s, setLayout: o }) {
  Nl((f) => {
    const d = s.value;
    if (!d) return;
    const h = rs(l, d);
    for (let I = 0; I < a.length - 1; I++) {
      const { valueMax: x, valueMin: y, valueNow: P } = bb({
        layout: i.value,
        panelsArray: a,
        pivotIndices: [I, I + 1]
      }), E = h[I];
      if (E != null) {
        const R = a[I];
        gn(R), E.setAttribute("aria-controls", R.id), E.setAttribute("aria-valuemax", `${Math.round(x)}`), E.setAttribute("aria-valuemin", `${Math.round(y)}`), E.setAttribute("aria-valuenow", P != null ? `${Math.round(P)}` : "");
      }
    }
    f(() => {
      h.forEach((I) => {
        I.removeAttribute("aria-controls"), I.removeAttribute("aria-valuemax"), I.removeAttribute("aria-valuemin"), I.removeAttribute("aria-valuenow");
      });
    });
  }), Nl((f) => {
    const d = s.value;
    if (!d) return;
    const h = e.value;
    gn(h);
    const { panelDataArray: I } = h, x = mv(l, d);
    gn(x != null, `No group found for id "${l}"`);
    const y = rs(l, d);
    gn(y);
    const P = y.map((E) => {
      const R = E.getAttribute("data-panel-resize-handle-id");
      gn(R);
      const [V, K] = Db(l, R, I, d);
      if (V == null || K == null) return () => {
      };
      const $ = (Q) => {
        if (!Q.defaultPrevented)
          switch (Q.key) {
            case "Enter": {
              Q.preventDefault();
              const Z = I.findIndex((G) => G.id === V);
              if (Z >= 0) {
                const G = I[Z];
                gn(G);
                const Y = i.value[Z], { collapsedSize: se = 0, collapsible: te, minSize: fe = 0 } = G.constraints;
                if (Y != null && te) {
                  const M = Fr({
                    delta: gt(Y, se) ? fe - se : se - Y,
                    layout: i.value,
                    panelConstraints: I.map((oe) => oe.constraints),
                    pivotIndices: vv(l, R, d),
                    trigger: "keyboard"
                  });
                  i.value !== M && o(M);
                }
              }
              break;
            }
          }
      };
      return E.addEventListener("keydown", $), () => {
        E.removeEventListener("keydown", $);
      };
    });
    f(() => {
      P.forEach((E) => E());
    });
  });
}
function Jd(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (l) => localStorage.getItem(l), e.setItem = (l, i) => {
        localStorage.setItem(l, i);
      };
    else throw new TypeError("localStorage not supported in this environment");
  } catch (l) {
    console.error(l), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function bv(e) {
  return `reka:${e}`;
}
function Sv(e) {
  return e.map((l) => {
    const { constraints: i, id: a, idIsFromProps: s, order: o } = l;
    return s ? a : o ? `${o}:${JSON.stringify(i)}` : JSON.stringify(i);
  }).sort((l, i) => l.localeCompare(i)).join(",");
}
function Cv(e, l) {
  try {
    const i = bv(e), a = l.getItem(i);
    if (a) {
      const s = JSON.parse(a);
      if (typeof s == "object" && s != null) return s;
    }
  } catch {
  }
  return null;
}
function Bb(e, l, i) {
  const a = Cv(e, i) ?? {}, s = Sv(l);
  return a[s] ?? null;
}
function Zb(e, l, i, a, s) {
  const o = bv(e), f = Sv(l), d = Cv(e, s) ?? {};
  d[f] = {
    expandToSizes: Object.fromEntries(i.entries()),
    layout: a
  };
  try {
    s.setItem(o, JSON.stringify(d));
  } catch (h) {
    console.error(h);
  }
}
const Ub = 100, Mr = {
  getItem: (e) => (Jd(Mr), Mr.getItem(e)),
  setItem: (e, l) => {
    Jd(Mr), Mr.setItem(e, l);
  }
}, [Tv, Kb] = hi("PanelGroup");
var Gb = /* @__PURE__ */ fn({
  __name: "SplitterGroup",
  props: {
    id: {
      type: [String, null],
      required: !1
    },
    autoSaveId: {
      type: [String, null],
      required: !1,
      default: null
    },
    direction: {
      type: String,
      required: !0
    },
    keyboardResizeBy: {
      type: [Number, null],
      required: !1,
      default: 10
    },
    storage: {
      type: Object,
      required: !1,
      default: () => Mr
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["layout"],
  setup(e, { emit: l }) {
    const i = e, a = l, s = {}, { direction: o } = wt(i), f = oa(i.id, "reka-splitter-group"), d = Ls(), { forwardRef: h, currentElement: I } = Ct(), x = Me(null), y = Me([]), P = Me({}), E = Me(/* @__PURE__ */ new Map()), R = Me(0), V = _e(() => ({
      autoSaveId: i.autoSaveId,
      direction: i.direction,
      dragState: x.value,
      id: f,
      keyboardResizeBy: i.keyboardResizeBy,
      storage: i.storage
    })), K = Me({
      layout: y.value,
      panelDataArray: [],
      panelDataArrayChanged: !1
    }), $ = (ce) => y.value = ce;
    Vb({
      eagerValuesRef: K,
      groupId: f,
      layout: y,
      panelDataArray: K.value.panelDataArray,
      setLayout: $,
      panelGroupElement: I
    }), Nl(() => {
      const { panelDataArray: ce } = K.value, { autoSaveId: de } = i;
      if (de) {
        if (y.value.length === 0 || y.value.length !== ce.length) return;
        let we = s[de];
        we || (we = Cb(Zb, Ub), s[de] = we);
        const Ae = [...ce], $e = new Map(E.value);
        we(de, Ae, $e, y.value, i.storage);
      }
    });
    function Q(ce, de) {
      const { panelDataArray: we } = K.value, Ae = Ce(we, ce);
      return Mb({
        defaultSize: de,
        dragState: x.value,
        layout: y.value,
        panelData: we,
        panelIndex: Ae
      });
    }
    function Z(ce) {
      const { panelDataArray: de } = K.value;
      de.push(ce), de.sort((we, Ae) => {
        const $e = we.order, ze = Ae.order;
        return $e == null && ze == null ? 0 : $e == null ? -1 : ze == null ? 1 : $e - ze;
      }), K.value.panelDataArrayChanged = !0;
    }
    Sn(() => K.value.panelDataArrayChanged, () => {
      if (K.value.panelDataArrayChanged) {
        K.value.panelDataArrayChanged = !1;
        const { autoSaveId: ce, storage: de } = V.value, { layout: we, panelDataArray: Ae } = K.value;
        let $e = null;
        if (ce) {
          const cn = Bb(ce, Ae, de);
          cn && (E.value = new Map(Object.entries(cn.expandToSizes)), $e = cn.layout);
        }
        $e === null && ($e = Sb({ panelDataArray: Ae }));
        const ze = kb({
          layout: $e,
          panelConstraints: Ae.map((cn) => cn.constraints)
        });
        I0(we, ze) || ($(ze), K.value.layout = ze, a("layout", ze), br(Ae, ze, P.value));
      }
    });
    function G(ce) {
      return function(we) {
        we.preventDefault();
        const Ae = I.value;
        if (!Ae) return () => null;
        const { direction: $e, dragState: ze, id: cn, keyboardResizeBy: Cn } = V.value, { layout: xn, panelDataArray: ln } = K.value, { initialLayout: k } = ze ?? {}, _ = vv(cn, ce, Ae);
        let B = wb(we, ce, $e, ze, Cn, Ae);
        if (B === 0) return;
        const le = $e === "horizontal";
        d.value === "rtl" && le && (B = -B);
        const Xe = ln.map((ie) => ie.constraints), De = Fr({
          delta: B,
          layout: k ?? xn,
          panelConstraints: Xe,
          pivotIndices: _,
          trigger: dv(we) ? "keyboard" : "mouse-or-touch"
        }), j = !Bs(xn, De);
        (pv(we) || hv(we)) && R.value !== B && (R.value = B, j ? _o(ce, 0) : le ? _o(ce, B < 0 ? yv : Iv) : _o(ce, B < 0 ? Lv : Dv)), j && ($(De), K.value.layout = De, a("layout", De), br(ln, De, P.value));
      };
    }
    function Y(ce, de) {
      const { layout: we, panelDataArray: Ae } = K.value, $e = Ae.map((k) => k.constraints), { panelSize: ze, pivotIndices: cn } = xe(Ae, ce, we);
      gn(ze != null);
      const xn = Ce(Ae, ce) === Ae.length - 1 ? ze - de : de - ze, ln = Fr({
        delta: xn,
        layout: we,
        panelConstraints: $e,
        pivotIndices: cn,
        trigger: "imperative-api"
      });
      Bs(we, ln) || ($(ln), K.value.layout = ln, a("layout", ln), br(Ae, ln, P.value));
    }
    function se(ce, de) {
      const { layout: we, panelDataArray: Ae } = K.value, $e = Ce(Ae, ce);
      Ae[$e] = ce, K.value.panelDataArrayChanged = !0;
      const { collapsedSize: ze = 0, collapsible: cn } = de, { collapsedSize: Cn = 0, collapsible: xn, maxSize: ln = 100, minSize: k = 0 } = ce.constraints, { panelSize: _ } = xe(Ae, ce, we);
      _ !== null && (cn && xn && _ === ze ? ze !== Cn && Y(ce, Cn) : _ < k ? Y(ce, k) : _ > ln && Y(ce, ln));
    }
    function te(ce, de) {
      const { direction: we } = V.value, { layout: Ae } = K.value;
      if (!I.value) return;
      const $e = ao(ce, I.value);
      gn($e);
      const ze = gv(we, de);
      x.value = {
        dragHandleId: ce,
        dragHandleRect: $e.getBoundingClientRect(),
        initialCursorPosition: ze,
        initialLayout: Ae
      };
    }
    function fe() {
      x.value = null;
    }
    function M(ce) {
      const { panelDataArray: de } = K.value, we = Ce(de, ce);
      we >= 0 && (de.splice(we, 1), delete P.value[ce.id], K.value.panelDataArrayChanged = !0);
    }
    function oe(ce) {
      const { layout: de, panelDataArray: we } = K.value;
      if (ce.constraints.collapsible) {
        const Ae = we.map((Cn) => Cn.constraints), { collapsedSize: $e = 0, panelSize: ze, pivotIndices: cn } = xe(we, ce, de);
        if (gn(ze != null, `Panel size not found for panel "${ce.id}"`), ze !== $e) {
          E.value.set(ce.id, ze);
          const xn = Ce(we, ce) === we.length - 1 ? ze - $e : $e - ze, ln = Fr({
            delta: xn,
            layout: de,
            panelConstraints: Ae,
            pivotIndices: cn,
            trigger: "imperative-api"
          });
          Bs(de, ln) || ($(ln), K.value.layout = ln, a("layout", ln), br(we, ln, P.value));
        }
      }
    }
    function Le(ce) {
      const { layout: de, panelDataArray: we } = K.value;
      if (ce.constraints.collapsible) {
        const Ae = we.map((xn) => xn.constraints), { collapsedSize: $e = 0, panelSize: ze, minSize: cn = 0, pivotIndices: Cn } = xe(we, ce, de);
        if (ze === $e) {
          const xn = E.value.get(ce.id), ln = xn != null && xn >= cn ? xn : cn, _ = Ce(we, ce) === we.length - 1 ? ze - ln : ln - ze, B = Fr({
            delta: _,
            layout: de,
            panelConstraints: Ae,
            pivotIndices: Cn,
            trigger: "imperative-api"
          });
          Bs(de, B) || ($(B), K.value.layout = B, a("layout", B), br(we, B, P.value));
        }
      }
    }
    function ae(ce) {
      const { layout: de, panelDataArray: we } = K.value, { panelSize: Ae } = xe(we, ce, de);
      return gn(Ae != null, `Panel size not found for panel "${ce.id}"`), Ae;
    }
    function ye(ce) {
      const { layout: de, panelDataArray: we } = K.value, { collapsedSize: Ae = 0, collapsible: $e, panelSize: ze } = xe(we, ce, de);
      return $e ? ze === void 0 ? ce.constraints.defaultSize === ce.constraints.collapsedSize : ze === Ae : !1;
    }
    function he(ce) {
      const { layout: de, panelDataArray: we } = K.value, { collapsedSize: Ae = 0, collapsible: $e, panelSize: ze } = xe(we, ce, de);
      return gn(ze != null, `Panel size not found for panel "${ce.id}"`), !$e || ze > Ae;
    }
    Kb({
      direction: o,
      dragState: x.value,
      groupId: f,
      reevaluatePanelConstraints: se,
      registerPanel: Z,
      registerResizeHandle: G,
      resizePanel: Y,
      startDragging: te,
      stopDragging: fe,
      unregisterPanel: M,
      panelGroupElement: I,
      collapsePanel: oe,
      expandPanel: Le,
      isPanelCollapsed: ye,
      isPanelExpanded: he,
      getPanelSize: ae,
      getPanelStyle: Q
    });
    function Ce(ce, de) {
      return ce.findIndex((we) => we === de || we.id === de.id);
    }
    function xe(ce, de, we) {
      const Ae = Ce(ce, de), ze = Ae === ce.length - 1 ? [Ae - 1, Ae] : [Ae, Ae + 1], cn = we[Ae];
      return {
        ...de.constraints,
        panelSize: cn,
        pivotIndices: ze
      };
    }
    return (ce, de) => (tn(), vn(ue(ul), {
      ref: ue(h),
      as: ce.as,
      "as-child": ce.asChild,
      style: Gi({
        display: "flex",
        flexDirection: ue(o) === "horizontal" ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
      }),
      "data-panel-group": "",
      "data-orientation": ue(o),
      "data-panel-group-id": ue(f)
    }, {
      default: nn(() => [Pn(ce.$slots, "default", { layout: y.value })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "style",
      "data-orientation",
      "data-panel-group-id"
    ]));
  }
}), zb = Gb, jb = /* @__PURE__ */ fn({
  __name: "SplitterPanel",
  props: {
    collapsedSize: {
      type: Number,
      required: !1
    },
    collapsible: {
      type: Boolean,
      required: !1
    },
    defaultSize: {
      type: Number,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    maxSize: {
      type: Number,
      required: !1
    },
    minSize: {
      type: Number,
      required: !1
    },
    order: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "collapse",
    "expand",
    "resize"
  ],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, o = Tv();
    if (o === null) throw new Error("SplitterPanel components must be rendered within a SplitterGroup container");
    const { collapsePanel: f, expandPanel: d, getPanelSize: h, getPanelStyle: I, isPanelCollapsed: x, resizePanel: y, groupId: P, reevaluatePanelConstraints: E, registerPanel: R, unregisterPanel: V } = o, K = oa(a.id, "reka-splitter-panel"), $ = _e(() => ({
      callbacks: {
        onCollapse: () => s("collapse"),
        onExpand: () => s("expand"),
        onResize: (...fe) => s("resize", ...fe)
      },
      constraints: {
        collapsedSize: a.collapsedSize && Number.parseFloat(a.collapsedSize.toFixed(bf)),
        collapsible: a.collapsible,
        defaultSize: a.defaultSize,
        maxSize: a.maxSize,
        minSize: a.minSize
      },
      id: K,
      idIsFromProps: a.id !== void 0,
      order: a.order
    }));
    Sn(() => $.value.constraints, (fe, M) => {
      (M.collapsedSize !== fe.collapsedSize || M.collapsible !== fe.collapsible || M.maxSize !== fe.maxSize || M.minSize !== fe.minSize) && E($.value, M);
    }, { deep: !0 }), vl(() => {
      R($.value);
    }), St(() => {
      V($.value);
    });
    const Q = _e(() => I($.value, a.defaultSize)), Z = _e(() => x($.value)), G = _e(() => !Z.value);
    function Y() {
      f($.value);
    }
    function se() {
      d($.value);
    }
    function te(fe) {
      y($.value, fe);
    }
    return l({
      collapse: Y,
      expand: se,
      getSize() {
        return h($.value);
      },
      resize: te,
      isCollapsed: Z,
      isExpanded: G
    }), (fe, M) => (tn(), vn(ue(ul), {
      id: ue(K),
      style: Gi(Q.value),
      as: fe.as,
      "as-child": fe.asChild,
      "data-panel": "",
      "data-panel-collapsible": fe.collapsible || void 0,
      "data-panel-group-id": ue(P),
      "data-panel-id": ue(K),
      "data-panel-size": Number.parseFloat(`${Q.value.flexGrow}`).toFixed(1),
      "data-state": fe.collapsible ? Z.value ? "collapsed" : "expanded" : void 0
    }, {
      default: nn(() => [Pn(fe.$slots, "default", {
        isCollapsed: Z.value,
        isExpanded: G.value,
        expand: se,
        collapse: Y,
        resize: te
      })]),
      _: 3
    }, 8, [
      "id",
      "style",
      "as",
      "as-child",
      "data-panel-collapsible",
      "data-panel-group-id",
      "data-panel-id",
      "data-panel-size",
      "data-state"
    ]));
  }
}), ep = jb;
function Hb({ disabled: e, handleId: l, resizeHandler: i, panelGroupElement: a }) {
  Nl((s) => {
    const o = a.value;
    if (e.value || i.value === null || o === null) return;
    const f = ao(l, o);
    if (f == null) return;
    const d = (h) => {
      if (!h.defaultPrevented)
        switch (h.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            h.preventDefault(), i.value?.(h);
            break;
          }
          case "F6": {
            h.preventDefault();
            const I = f.getAttribute("data-panel-group-id");
            gn(I);
            const x = rs(I, o), y = fv(I, l, o);
            gn(y !== null);
            const P = h.shiftKey ? y > 0 ? y - 1 : x.length - 1 : y + 1 < x.length ? y + 1 : 0;
            x[P].focus();
            break;
          }
        }
    };
    f.addEventListener("keydown", d), s(() => {
      f.removeEventListener("keydown", d);
    });
  });
}
var $b = /* @__PURE__ */ fn({
  __name: "SplitterResizeHandle",
  props: {
    id: {
      type: String,
      required: !1
    },
    hitAreaMargins: {
      type: Object,
      required: !1
    },
    tabindex: {
      type: Number,
      required: !1,
      default: 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["dragging"],
  setup(e, { emit: l }) {
    const i = e, a = l, { forwardRef: s, currentElement: o } = Ct(), { disabled: f } = wt(i), d = Tv();
    if (d === null) throw new Error("PanelResizeHandle components must be rendered within a PanelGroup container");
    const { direction: h, groupId: I, registerResizeHandle: x, startDragging: y, stopDragging: P, panelGroupElement: E } = d, R = oa(i.id, "reka-splitter-resize-handle"), V = Me("inactive"), K = Me(!1), $ = Me(null), { nonce: Q } = wt(i), Z = ov(Q);
    return Sn(f, () => {
      Is && (f.value ? $.value = null : $.value = x(R));
    }, { immediate: !0 }), Nl((G) => {
      if (f.value || $.value === null) return;
      const Y = o.value;
      if (!Y) return;
      gn(Y);
      const se = (te, fe, M) => {
        if (fe) switch (te) {
          case "down": {
            V.value = "drag", y(R, M), a("dragging", !0);
            break;
          }
          case "move": {
            V.value !== "drag" && (V.value = "hover"), $.value?.(M);
            break;
          }
          case "up": {
            V.value = "hover", P(), a("dragging", !1);
            break;
          }
        }
        else V.value = "inactive";
      };
      G(Nb(R, Y, h, {
        coarse: i.hitAreaMargins?.coarse ?? 15,
        fine: i.hitAreaMargins?.fine ?? 5
      }, Z, se));
    }), Hb({
      disabled: f,
      resizeHandler: $,
      handleId: R,
      panelGroupElement: E
    }), (G, Y) => (tn(), vn(ue(ul), {
      id: ue(R),
      ref: ue(s),
      style: {
        touchAction: "none",
        userSelect: "none"
      },
      as: G.as,
      "as-child": G.asChild,
      role: "separator",
      "data-resize-handle": "",
      tabindex: G.tabindex,
      "data-state": V.value,
      "data-disabled": ue(f) ? "" : void 0,
      "data-orientation": ue(h),
      "data-panel-group-id": ue(I),
      "data-resize-handle-active": V.value === "drag" ? "pointer" : K.value ? "keyboard" : void 0,
      "data-resize-handle-state": V.value,
      "data-panel-resize-handle-enabled": !ue(f),
      "data-panel-resize-handle-id": ue(R),
      onBlur: Y[0] || (Y[0] = (se) => K.value = !1),
      onFocus: Y[1] || (Y[1] = (se) => K.value = !1)
    }, {
      default: nn(() => [Pn(G.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "tabindex",
      "data-state",
      "data-disabled",
      "data-orientation",
      "data-panel-group-id",
      "data-resize-handle-active",
      "data-resize-handle-state",
      "data-panel-resize-handle-enabled",
      "data-panel-resize-handle-id"
    ]));
  }
}), Wb = $b;
function Cc(e) {
  return e.reduce((l, i) => (l.push(i), i.children && l.push(...Cc(i.children)), l), []);
}
const [Yb, Xb] = hi("TreeRoot");
var Qb = /* @__PURE__ */ fn({
  __name: "TreeRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    items: {
      type: Array,
      required: !1
    },
    expanded: {
      type: Array,
      required: !1
    },
    defaultExpanded: {
      type: Array,
      required: !1
    },
    getKey: {
      type: Function,
      required: !0
    },
    getChildren: {
      type: Function,
      required: !1,
      default: (e) => e.children
    },
    selectionBehavior: {
      type: String,
      required: !1,
      default: "toggle"
    },
    multiple: {
      type: Boolean,
      required: !1,
      skipCheck: !0
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    propagateSelect: {
      type: Boolean,
      required: !1
    },
    bubbleSelect: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "ul"
    }
  },
  emits: ["update:modelValue", "update:expanded"],
  setup(e, { emit: l }) {
    const i = e, a = l, { items: s, multiple: o, disabled: f, propagateSelect: d, dir: h, bubbleSelect: I } = wt(i), { handleTypeaheadSearch: x } = $g(), y = Ls(h), P = Me(), E = Me(!1), R = Hr(), V = Uu(i, "modelValue", a, {
      defaultValue: i.defaultValue ?? (o.value ? [] : void 0),
      passive: !0,
      deep: !0
    }), K = Uu(i, "expanded", a, {
      defaultValue: i.defaultExpanded ?? [],
      passive: i.expanded === void 0,
      deep: !0
    }), { onSelectItem: $, handleMultipleReplace: Q } = Y0(V, i), Z = _e(() => o.value && Array.isArray(V.value) ? V.value.map((M) => i.getKey(M)) : [i.getKey(V.value ?? {})]);
    function G(M, oe = 1, Le) {
      return M.reduce((ae, ye, he) => {
        const Ce = i.getKey(ye), xe = i.getChildren(ye), ce = K.value.includes(Ce), de = {
          _id: Ce,
          value: ye,
          index: he,
          level: oe,
          parentItem: Le,
          hasChildren: !!xe,
          bind: {
            value: ye,
            level: oe,
            "aria-setsize": M.length,
            "aria-posinset": he + 1
          }
        };
        return ae.push(de), xe && ce && ae.push(...G(xe, oe + 1, ye)), ae;
      }, []);
    }
    const Y = _e(() => {
      const M = i.items;
      return K.value.map((oe) => oe), G(M ?? []);
    });
    function se(M) {
      if (E.value) R.trigger(M);
      else {
        const oe = P.value?.getItems() ?? [];
        x(M.key, oe);
      }
    }
    function te(M) {
      if (E.value) return;
      const oe = Yg[M.key];
      tl(() => {
        Q(oe, ka(), P.value?.getItems, Y.value.map((Le) => Le.value));
      });
    }
    function fe(M) {
      if (M.parentItem != null && Array.isArray(V.value) && i.multiple) {
        const oe = Y.value.find((Le) => M.parentItem != null && i.getKey(Le.value) === i.getKey(M.parentItem));
        oe != null && (i.getChildren(oe.value)?.every((ae) => V.value.find((ye) => i.getKey(ye) === i.getKey(ae))) ? V.value = [...V.value, oe.value] : V.value = V.value.filter((ae) => i.getKey(ae) !== i.getKey(oe.value)), fe(oe));
      }
    }
    return Xb({
      modelValue: V,
      selectedKeys: Z,
      onSelect: (M) => {
        const oe = (ae) => i.getKey(ae ?? {}) === i.getKey(M), Le = i.multiple && Array.isArray(V.value) ? V.value?.findIndex(oe) !== -1 : void 0;
        if ($(M, oe), i.bubbleSelect && i.multiple && Array.isArray(V.value)) {
          const ae = Y.value.find((ye) => i.getKey(ye.value) === i.getKey(M));
          ae != null && fe(ae);
        }
        if (i.propagateSelect && i.multiple && Array.isArray(V.value)) {
          const ae = Cc(i.getChildren(M) ?? []);
          Le ? V.value = [...V.value].filter((ye) => !ae.some((he) => i.getKey(ye ?? {}) === i.getKey(he))) : V.value = [...V.value, ...ae];
        }
      },
      expanded: K,
      onToggle(M) {
        if (!(M ? i.getChildren(M) : void 0)) return;
        const Le = i.getKey(M) ?? M;
        K.value.includes(Le) ? K.value = K.value.filter((ae) => ae !== Le) : K.value.push(Le);
      },
      getKey: i.getKey,
      getChildren: i.getChildren,
      items: s,
      expandedItems: Y,
      disabled: f,
      multiple: o,
      dir: y,
      propagateSelect: d,
      bubbleSelect: I,
      isVirtual: E,
      virtualKeydownHook: R,
      handleMultipleReplace: Q
    }), (M, oe) => (tn(), vn(ue(vO), {
      ref_key: "rovingFocusGroupRef",
      ref: P,
      "as-child": "",
      orientation: "vertical",
      dir: ue(y)
    }, {
      default: nn(() => [Ye(ue(ul), {
        role: "tree",
        as: M.as,
        "as-child": M.asChild,
        "aria-multiselectable": ue(o) ? !0 : void 0,
        onKeydown: [se, oi(ri(te, ["shift"]), ["up", "down"])]
      }, {
        default: nn(() => [Pn(M.$slots, "default", {
          flattenItems: Y.value,
          modelValue: ue(V),
          expanded: ue(K)
        })]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-multiselectable",
        "onKeydown"
      ])]),
      _: 3
    }, 8, ["dir"]));
  }
}), Jb = Qb;
const eS = "tree.select", nS = "tree.toggle";
var lS = /* @__PURE__ */ fn({
  inheritAttrs: !1,
  __name: "TreeItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    level: {
      type: Number,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "li"
    }
  },
  emits: ["select", "toggle"],
  setup(e, { expose: l, emit: i }) {
    const a = e, s = i, o = Yb(), { getItems: f } = $a(), d = _e(() => !!o.getChildren(a.value)), h = _e(() => {
      const $ = o.getKey(a.value);
      return o.expanded.value.includes($);
    }), I = _e(() => {
      const $ = o.getKey(a.value);
      return o.selectedKeys.value.includes($);
    }), x = _e(() => {
      if (o.bubbleSelect.value && d.value && Array.isArray(o.modelValue.value)) {
        const $ = Cc(o.getChildren(a.value) || []);
        return $.some((Q) => o.modelValue.value.find((Z) => o.getKey(Z) === o.getKey(Q))) && !$.every((Q) => o.modelValue.value.find((Z) => o.getKey(Z) === o.getKey(Q)));
      } else return o.propagateSelect.value && I.value && d.value && Array.isArray(o.modelValue.value) ? !Cc(o.getChildren(a.value) || []).every((Q) => o.modelValue.value.find((Z) => o.getKey(Z) === o.getKey(Q))) : void 0;
    });
    function y($) {
      if (d.value)
        if (h.value) {
          const Q = f().map((te) => te.ref), Z = ka(), G = Q.indexOf(Z), se = [...Q].slice(G).find((te) => Number(te.getAttribute("data-indent")) === a.level + 1);
          se && se.focus();
        } else K($);
    }
    function P($) {
      if (h.value) K($);
      else {
        const Q = f().map((te) => te.ref), Z = ka(), G = Q.indexOf(Z), se = [...Q].slice(0, G).reverse().find((te) => Number(te.getAttribute("data-indent")) === a.level - 1);
        se && se.focus();
      }
    }
    async function E($) {
      s("select", $), !$?.defaultPrevented && o.onSelect(a.value);
    }
    async function R($) {
      s("toggle", $), !$?.defaultPrevented && o.onToggle(a.value);
    }
    async function V($) {
      if (!$) return;
      const Q = {
        originalEvent: $,
        value: a.value,
        isExpanded: h.value,
        isSelected: I.value
      };
      is(eS, E, Q);
    }
    async function K($) {
      if (!$) return;
      const Q = {
        originalEvent: $,
        value: a.value,
        isExpanded: h.value,
        isSelected: I.value
      };
      is(nS, R, Q);
    }
    return l({
      isExpanded: h,
      isSelected: I,
      isIndeterminate: x,
      handleToggle: () => o.onToggle(a.value),
      handleSelect: () => o.onSelect(a.value)
    }), ($, Q) => (tn(), vn(ue(yO), {
      "as-child": "",
      value: $.value,
      "allow-shift-key": ""
    }, {
      default: nn(() => [Ye(ue(ul), dl($.$attrs, {
        role: "treeitem",
        as: $.as,
        "as-child": $.asChild,
        "aria-selected": I.value,
        "aria-expanded": d.value ? h.value : void 0,
        "aria-level": $.level,
        "data-indent": $.level,
        "data-selected": I.value ? "" : void 0,
        "data-expanded": h.value ? "" : void 0,
        onKeydown: [
          oi(ri(V, ["self", "prevent"]), ["enter", "space"]),
          Q[0] || (Q[0] = oi(ri((Z) => ue(o).dir.value === "ltr" ? y(Z) : P(Z), ["prevent"]), ["right"])),
          Q[1] || (Q[1] = oi(ri((Z) => ue(o).dir.value === "ltr" ? P(Z) : y(Z), ["prevent"]), ["left"]))
        ],
        onClick: Q[2] || (Q[2] = ri((Z) => {
          V(Z), K(Z);
        }, ["stop"]))
      }), {
        default: nn(() => [Pn($.$slots, "default", {
          isExpanded: h.value,
          isSelected: I.value,
          isIndeterminate: x.value,
          handleSelect: () => ue(o).onSelect($.value),
          handleToggle: () => ue(o).onToggle($.value)
        })]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "aria-selected",
        "aria-expanded",
        "aria-level",
        "data-indent",
        "data-selected",
        "data-expanded",
        "onKeydown"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), tS = lS;
const iS = { class: "layout w-screen h-screen" }, uS = { class: "w-screen h-screen overflow-hidden" }, aS = /* @__PURE__ */ fn({
  __name: "app-layout",
  setup(e) {
    const l = /* @__PURE__ */ i0(t0), i = _e(() => l.greater("2xl").value ? 20 : l.greater("xl").value ? 25 : l.greater("lg").value ? 30 : l.greater("md").value ? 35 : 0);
    return (a, s) => (tn(), Bl("div", iS, [
      hn("div", uS, [
        Ye(ue(zb), {
          direction: "horizontal",
          class: "h-full"
        }, {
          default: nn(() => [
            Ye(ue(ep), {
              class: "border h-full",
              "default-size": i.value
            }, {
              default: nn(() => [
                Pn(a.$slots, "primary-sidebar", {}, void 0, !0)
              ]),
              _: 3
            }, 8, ["default-size"]),
            Ye(ue(Wb), { class: "w-1" }),
            Ye(ue(ep), { class: "border h-full" }, {
              default: nn(() => [
                Pn(a.$slots, "main-area", {}, void 0, !0)
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ])
    ]));
  }
}), oo = (e, l) => {
  const i = e.__vccOpts || e;
  for (const [a, s] of l)
    i[a] = s;
  return i;
}, rS = /* @__PURE__ */ oo(aS, [["__scopeId", "data-v-bf5a22d1"]]), Tf = /* @__PURE__ */ Yc("s-ied-implementation/dialog", () => {
  const e = {
    component: void 0,
    props: void 0
  }, l = Me(), i = Me(e);
  function a() {
    i.value = {
      component: void 0,
      props: void 0
    };
  }
  function s() {
    l.value?.close(), XD(() => {
      a();
    }, 300);
  }
  function o(f) {
    const { innerComponent: d, props: h } = f;
    i.value.component = Ka(d), i.value.props = h, l.value?.showModal();
  }
  return {
    // states
    dialogRef: l,
    currentDialog: i,
    // actions
    hardReset: a,
    handleClose: s,
    setCurrentDialog: o
  };
});
function Os(e) {
  const { sdkInstance: l, tagName: i, attributes: a, keys: s } = e, o = l.utils.getAttributesValuesByName({ attributes: a });
  if (!(l.standard.REQUIRED[i] || []).every(
    (I) => o[I] !== "" && o[I] !== void 0 && o[I] !== null
  )) throw new Error(`Missing required attributes for ${i}`);
  return s.map((I) => o[I]).filter((I) => I !== "" && I !== void 0 && I !== null).join(".");
}
function Us(e) {
  const { sdkInstance: l, tree: i, keyAttributes: a } = e, s = /* @__PURE__ */ new Map();
  for (const o of i) {
    const f = Os({
      sdkInstance: l,
      tagName: o.tagName,
      attributes: o.attributes,
      keys: a
    });
    f && !s.has(f) && s.set(f, o);
  }
  return s;
}
function sS(e) {
  const { sdkInstance: l, localLnode: i, icdLNodeSpecNamingMap: a } = e, s = i.treeChildren.find(
    (d) => d.tagName === "LNodeSpecNaming"
  );
  if (!s) return;
  const o = Os({
    sdkInstance: l,
    tagName: "LNodeSpecNaming",
    attributes: s.attributes,
    keys: ["sLdInst", "sPrefix", "sLnClass", "sLnInst"]
  });
  if (!o)
    return {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    };
  const f = a.get(o);
  return {
    total: 1,
    perfectMatches: f ? [{ local: s, icd: f }] : [],
    manualMatches: [],
    noMatches: f ? [] : [s]
  };
}
function cS(e) {
  const { localLnode: l, matchingIcdLn: i } = e;
  return {
    total: 1,
    perfectMatches: i ? [{ local: l, icd: i }] : [],
    manualMatches: [],
    noMatches: i ? [] : [l]
  };
}
function oS(e) {
  const { sdkInstance: l, localLnode: i, icdSourceRefMap: a } = e, s = [], o = i.treeChildren.filter(
    (f) => f.tagName === "SourceRef"
  );
  for (const f of o) {
    const d = Os({
      sdkInstance: l,
      tagName: "SourceRef",
      attributes: f.attributes,
      keys: ["input", "inputInst"]
    });
    if (!d) {
      s.push({
        total: 0,
        perfectMatches: [],
        manualMatches: [],
        noMatches: []
      });
      continue;
    }
    const h = a.get(d);
    s.push({
      total: 1,
      perfectMatches: h ? [{ local: f, icd: h }] : [],
      manualMatches: [],
      noMatches: h ? [] : [f]
    });
  }
  return s;
}
function mS(e) {
  const { sdkInstance: l, localLnode: i, icdControlRefMap: a } = e, s = [], o = i.treeChildren.filter(
    (f) => f.tagName === "ControlRef"
  );
  for (const f of o) {
    const d = Os({
      sdkInstance: l,
      tagName: "ControlRef",
      attributes: f.attributes,
      keys: ["output", "outputInst"]
    });
    if (!d) {
      s.push({
        total: 0,
        perfectMatches: [],
        manualMatches: [],
        noMatches: []
      });
      continue;
    }
    const h = a.get(d);
    s.push({
      total: 1,
      perfectMatches: h ? [{ local: f, icd: h }] : [],
      manualMatches: [],
      noMatches: h ? [] : [f]
    });
  }
  return s;
}
function fS(e) {
  const { sdkInstance: l, localDataModel: i, icdDataModel: a } = e, s = {
    total: 0,
    perfectMatches: [],
    manualMatches: [],
    noMatches: []
  }, o = [], { LNodeType: f = [], DOType: d = [] } = l.utils.groupRecordsByTagName(i), { LNodeType: h = [], DOType: I = [] } = l.utils.groupRecordsByTagName(a), x = f[0];
  if (!x) throw new Error("No LNodeType found in local data model");
  const y = h[0];
  if (!y) throw new Error("No LNodeType found in ICD data model");
  const P = x.treeChildren.filter(
    (V) => V.tagName === "DO"
  ), E = y.treeChildren.filter((V) => V.tagName === "DO");
  for (const V of P) {
    s.total++;
    const K = l.utils.getAttributeValueByName({
      attributes: V.attributes,
      name: "name"
    }), $ = E.find(
      (Z) => l.utils.getAttributeValueByName({
        attributes: Z.attributes,
        name: "name"
      }) === K
    );
    $ ? s.perfectMatches.push({
      local: V,
      icd: $
    }) : s.noMatches.push(V);
    const Q = dS({
      sdkInstance: l,
      localDo: V,
      matchingIcdDo: $,
      localDoTypes: d,
      icdDoTypes: I
    });
    o.push(Q);
  }
  const R = {
    total: o.reduce((V, K) => V + K.total, 0),
    perfectMatches: o.flatMap((V) => V.perfectMatches),
    manualMatches: o.flatMap((V) => V.manualMatches),
    noMatches: o.flatMap((V) => V.noMatches)
  };
  return { doMetrics: s, daMetrics: R };
}
function dS(e) {
  const { sdkInstance: l, localDo: i, matchingIcdDo: a, localDoTypes: s, icdDoTypes: o } = e, f = {
    total: 0,
    perfectMatches: [],
    manualMatches: [],
    noMatches: []
  }, d = l.utils.resolveDataModelRootElementReference({
    source: i,
    targets: s
  });
  if (!d) return f;
  const h = d.treeChildren.filter((x) => x.tagName === "DA");
  let I = [];
  if (a) {
    const x = l.utils.resolveDataModelRootElementReference({
      source: a,
      targets: o
    });
    x && (I = x.treeChildren.filter((y) => y.tagName === "DA"));
  }
  for (const x of h) {
    f.total++;
    const y = l.utils.getAttributeValueByName({
      attributes: x.attributes,
      name: "name"
    }), P = I.find(
      (E) => l.utils.getAttributeValueByName({
        attributes: E.attributes,
        name: "name"
      }) === y
    );
    P ? f.perfectMatches.push({
      local: x,
      icd: P
    }) : f.noMatches.push(x);
  }
  return f;
}
function pS(e) {
  const { sdkInstance: l, localDataModel: i } = e, a = i.filter((x) => x.tagName === "LNodeType");
  let s = 0, o = 0;
  const f = [], d = [];
  for (const x of a) {
    const y = x.treeChildren.filter((P) => P.tagName === "DO");
    s += y.length, f.push(...y);
    for (const P of y) {
      const E = l.utils.resolveDataModelRootElementReference({
        source: P,
        targets: i.filter((R) => R.tagName === "DOType")
      });
      if (E) {
        const R = E.treeChildren.filter((V) => V.tagName === "DA");
        o += R.length, d.push(...R);
      }
    }
  }
  return { doMetrics: {
    total: s,
    perfectMatches: [],
    manualMatches: [],
    noMatches: f
  }, daMetrics: {
    total: o,
    perfectMatches: [],
    manualMatches: [],
    noMatches: d
  } };
}
function va(e) {
  return {
    total: e.reduce((l, i) => l + i.total, 0),
    perfectMatches: e.flatMap((l) => l.perfectMatches),
    manualMatches: e.flatMap((l) => l.manualMatches),
    noMatches: e.flatMap((l) => l.noMatches)
  };
}
function qv(e) {
  return Hu() ? (Za(e), !0) : !1;
}
const Pv = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const hS = Object.prototype.toString, gS = (e) => hS.call(e) === "[object Object]", vS = () => {
}, np = /* @__PURE__ */ xS();
function xS() {
  var e, l;
  return Pv && ((e = window?.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((l = window?.navigator) == null ? void 0 : l.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function yS(...e) {
  if (e.length !== 1)
    return fs(...e);
  const l = e[0];
  return typeof l == "function" ? Mi(Ga(() => ({ get: l, set: vS }))) : Me(l);
}
function Fo(e) {
  return Array.isArray(e) ? e : [e];
}
function IS(e, l, i) {
  return Sn(
    e,
    l,
    {
      ...i,
      immediate: !0
    }
  );
}
const LS = Pv ? window : void 0;
function DS(e) {
  var l;
  const i = pn(e);
  return (l = i?.$el) != null ? l : i;
}
function OS(...e) {
  const l = [], i = () => {
    l.forEach((d) => d()), l.length = 0;
  }, a = (d, h, I, x) => (d.addEventListener(h, I, x), () => d.removeEventListener(h, I, x)), s = _e(() => {
    const d = Fo(pn(e[0])).filter((h) => h != null);
    return d.every((h) => typeof h != "string") ? d : void 0;
  }), o = IS(
    () => {
      var d, h;
      return [
        (h = (d = s.value) == null ? void 0 : d.map((I) => DS(I))) != null ? h : [LS].filter((I) => I != null),
        Fo(pn(s.value ? e[1] : e[0])),
        Fo(ue(s.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        pn(s.value ? e[3] : e[2])
      ];
    },
    ([d, h, I, x]) => {
      if (i(), !d?.length || !h?.length || !I?.length)
        return;
      const y = gS(x) ? { ...x } : x;
      l.push(
        ...d.flatMap(
          (P) => h.flatMap(
            (E) => I.map((R) => a(P, E, R, y))
          )
        )
      );
    },
    { flush: "post" }
  ), f = () => {
    o(), i();
  };
  return qv(i), f;
}
function Mo(e) {
  return typeof Window < "u" && e instanceof Window ? e.document.documentElement : typeof Document < "u" && e instanceof Document ? e.documentElement : e;
}
function Rv(e) {
  const l = window.getComputedStyle(e);
  if (l.overflowX === "scroll" || l.overflowY === "scroll" || l.overflowX === "auto" && e.clientWidth < e.scrollWidth || l.overflowY === "auto" && e.clientHeight < e.scrollHeight)
    return !0;
  {
    const i = e.parentNode;
    return !i || i.tagName === "BODY" ? !1 : Rv(i);
  }
}
function wS(e) {
  const l = e || window.event, i = l.target;
  return Rv(i) ? !1 : l.touches.length > 1 ? !0 : (l.preventDefault && l.preventDefault(), !1);
}
const ko = /* @__PURE__ */ new WeakMap();
function bS(e, l = !1) {
  const i = Vl(l);
  let a = null, s = "";
  Sn(yS(e), (d) => {
    const h = Mo(pn(d));
    if (h) {
      const I = h;
      if (ko.get(I) || ko.set(I, I.style.overflow), I.style.overflow !== "hidden" && (s = I.style.overflow), I.style.overflow === "hidden")
        return i.value = !0;
      if (i.value)
        return I.style.overflow = "hidden";
    }
  }, {
    immediate: !0
  });
  const o = () => {
    const d = Mo(pn(e));
    !d || i.value || (np && (a = OS(
      d,
      "touchmove",
      (h) => {
        wS(h);
      },
      { passive: !1 }
    )), d.style.overflow = "hidden", i.value = !0);
  }, f = () => {
    const d = Mo(pn(e));
    !d || !i.value || (np && a?.(), d.style.overflow = s, ko.delete(d), i.value = !1);
  };
  return qv(f), _e({
    get() {
      return i.value;
    },
    set(d) {
      d ? o() : f();
    }
  });
}
function SS() {
  let e = !1;
  const l = Vl(!1);
  return (i, a) => {
    if (l.value = a.value, e)
      return;
    e = !0;
    const s = bS(i, a.value);
    Sn(l, (o) => s.value = o);
  };
}
SS();
const lp = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), CS = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (l, i, a) => a ? a.toUpperCase() : i.toLowerCase()
), TS = (e) => {
  const l = CS(e);
  return l.charAt(0).toUpperCase() + l.slice(1);
}, qS = (...e) => e.filter((l, i, a) => !!l && l.trim() !== "" && a.indexOf(l) === i).join(" ").trim(), tp = (e) => e === "";
var Sr = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
const PS = ({
  name: e,
  iconNode: l,
  absoluteStrokeWidth: i,
  "absolute-stroke-width": a,
  strokeWidth: s,
  "stroke-width": o,
  size: f = Sr.width,
  color: d = Sr.stroke,
  ...h
}, { slots: I }) => pt(
  "svg",
  {
    ...Sr,
    ...h,
    width: f,
    height: f,
    stroke: d,
    "stroke-width": tp(i) || tp(a) || i === !0 || a === !0 ? Number(s || o || Sr["stroke-width"]) * 24 / Number(f) : s || o || Sr["stroke-width"],
    class: qS(
      "lucide",
      h.class,
      ...e ? [`lucide-${lp(TS(e))}-icon`, `lucide-${lp(e)}`] : ["lucide-icon"]
    )
  },
  [...l.map((x) => pt(...x)), ...I.default ? [I.default()] : []]
);
const Fe = (e, l) => (i, { slots: a, attrs: s }) => pt(
  PS,
  {
    ...s,
    ...i,
    iconNode: l,
    name: e
  },
  a
);
const Vo = Fe("activity", [
  [
    "path",
    {
      d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",
      key: "169zse"
    }
  ]
]);
const Bo = Fe("zap", [
  [
    "path",
    {
      d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
      key: "1xq2db"
    }
  ]
]);
const gi = Fe("arrow-right", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);
const RS = Fe("variable", [
  ["path", { d: "M8 21s-4-3-4-9 4-9 4-9", key: "uto9ud" }],
  ["path", { d: "M16 3s4 3 4 9-4 9-4 9", key: "4w2vsq" }],
  ["line", { x1: "15", x2: "9", y1: "9", y2: "15", key: "f7djnv" }],
  ["line", { x1: "9", x2: "15", y1: "9", y2: "15", key: "1shsy8" }]
]);
const Zo = Fe("square-pen", [
  ["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7", key: "1m0v6g" }],
  [
    "path",
    {
      d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",
      key: "ohrbg2"
    }
  ]
]);
const AS = Fe("hash", [
  ["line", { x1: "4", x2: "20", y1: "9", y2: "9", key: "4lhtct" }],
  ["line", { x1: "4", x2: "20", y1: "15", y2: "15", key: "vyu0kd" }],
  ["line", { x1: "10", x2: "8", y1: "3", y2: "21", key: "1ggp8o" }],
  ["line", { x1: "16", x2: "14", y1: "3", y2: "21", key: "weycgp" }]
]);
const ES = Fe("rotate-cw", [
  ["path", { d: "M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8", key: "1p45f6" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }]
]);
const _S = Fe("timer", [
  ["line", { x1: "10", x2: "14", y1: "2", y2: "2", key: "14vaq8" }],
  ["line", { x1: "12", x2: "15", y1: "14", y2: "11", key: "17fdiu" }],
  ["circle", { cx: "12", cy: "14", r: "8", key: "1e1u0o" }]
]);
const Cr = Fe("clock", [
  ["path", { d: "M12 6v6l4 2", key: "mmk7yg" }],
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
]);
const ip = Fe("type", [
  ["path", { d: "M12 4v16", key: "1654pz" }],
  ["path", { d: "M4 7V5a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v2", key: "e0r10z" }],
  ["path", { d: "M9 20h6", key: "s66wpe" }]
]);
const NS = Fe("terminal", [
  ["path", { d: "M12 19h8", key: "baeox8" }],
  ["path", { d: "m4 17 6-6-6-6", key: "1yngyt" }]
]);
const up = Fe("toggle-right", [
  ["circle", { cx: "15", cy: "12", r: "3", key: "1afu0r" }],
  ["rect", { width: "20", height: "14", x: "2", y: "5", rx: "7", key: "g7kal2" }]
]);
const ap = Fe("users", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["path", { d: "M16 3.128a4 4 0 0 1 0 7.744", key: "16gr8j" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
]);
const FS = Fe("building", [
  ["path", { d: "M12 10h.01", key: "1nrarc" }],
  ["path", { d: "M12 14h.01", key: "1etili" }],
  ["path", { d: "M12 6h.01", key: "1vi96p" }],
  ["path", { d: "M16 10h.01", key: "1m94wz" }],
  ["path", { d: "M16 14h.01", key: "1gbofw" }],
  ["path", { d: "M16 6h.01", key: "1x0f13" }],
  ["path", { d: "M8 10h.01", key: "19clt8" }],
  ["path", { d: "M8 14h.01", key: "6423bh" }],
  ["path", { d: "M8 6h.01", key: "1dz90k" }],
  ["path", { d: "M9 22v-3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3", key: "cabbwy" }],
  ["rect", { x: "4", y: "2", width: "16", height: "20", rx: "2", key: "1uxh74" }]
]);
const rp = Fe("user-check", [
  ["path", { d: "m16 11 2 2 4-4", key: "9rsbq5" }],
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
]);
const Uo = Fe("user", [
  ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
  ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]
]);
const Tr = Fe("network", [
  ["rect", { x: "16", y: "16", width: "6", height: "6", rx: "1", key: "4q2zg0" }],
  ["rect", { x: "2", y: "16", width: "6", height: "6", rx: "1", key: "8cvhb9" }],
  ["rect", { x: "9", y: "2", width: "6", height: "6", rx: "1", key: "1egb70" }],
  ["path", { d: "M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3", key: "1jsf9p" }],
  ["path", { d: "M12 12V8", key: "2874zd" }]
]);
const qr = Fe("file-text", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
]);
const Ks = Fe("square", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }]
]);
const Gs = Fe("cpu", [
  ["path", { d: "M12 20v2", key: "1lh1kg" }],
  ["path", { d: "M12 2v2", key: "tus03m" }],
  ["path", { d: "M17 20v2", key: "1rnc9c" }],
  ["path", { d: "M17 2v2", key: "11trls" }],
  ["path", { d: "M2 12h2", key: "1t8f8n" }],
  ["path", { d: "M2 17h2", key: "7oei6x" }],
  ["path", { d: "M2 7h2", key: "asdhe0" }],
  ["path", { d: "M20 12h2", key: "1q8mjw" }],
  ["path", { d: "M20 17h2", key: "1fpfkl" }],
  ["path", { d: "M20 7h2", key: "1o8tra" }],
  ["path", { d: "M7 20v2", key: "4gnj0m" }],
  ["path", { d: "M7 2v2", key: "1i4yhu" }],
  ["rect", { x: "4", y: "4", width: "16", height: "16", rx: "2", key: "1vbyd7" }],
  ["rect", { x: "8", y: "8", width: "8", height: "8", rx: "1", key: "z9xiuo" }]
]);
const sp = Fe("circle-check-big", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
const Yu = Fe("tag", [
  [
    "path",
    {
      d: "M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z",
      key: "vktsd0"
    }
  ],
  ["circle", { cx: "7.5", cy: "7.5", r: ".5", fill: "currentColor", key: "kqv944" }]
]);
const Ko = Fe("files", [
  [
    "path",
    {
      d: "M15 2a2 2 0 0 1 1.414.586l4 4A2 2 0 0 1 21 8v7a2 2 0 0 1-2 2h-8a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z",
      key: "1vo8kb"
    }
  ],
  ["path", { d: "M15 2v4a2 2 0 0 0 2 2h4", key: "sud9ri" }],
  ["path", { d: "M5 7a2 2 0 0 0-2 2v11a2 2 0 0 0 2 2h8a2 2 0 0 0 1.732-1", key: "l4dndm" }]
]);
const cp = Fe("square-check-big", [
  [
    "path",
    { d: "M21 10.656V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h12.344", key: "2acyp4" }
  ],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
const Go = Fe("gauge", [
  ["path", { d: "m12 14 4-4", key: "9kzdfg" }],
  ["path", { d: "M3.34 19a10 10 0 1 1 17.32 0", key: "19p75a" }]
]);
const MS = Fe("radio", [
  ["path", { d: "M16.247 7.761a6 6 0 0 1 0 8.478", key: "1fwjs5" }],
  ["path", { d: "M19.075 4.933a10 10 0 0 1 0 14.134", key: "ehdyv1" }],
  ["path", { d: "M4.925 19.067a10 10 0 0 1 0-14.134", key: "1q22gi" }],
  ["path", { d: "M7.753 16.239a6 6 0 0 1 0-8.478", key: "r2q7qm" }],
  ["circle", { cx: "12", cy: "12", r: "2", key: "1c9p78" }]
]);
const op = Fe("group", [
  ["path", { d: "M3 7V5c0-1.1.9-2 2-2h2", key: "adw53z" }],
  ["path", { d: "M17 3h2c1.1 0 2 .9 2 2v2", key: "an4l38" }],
  ["path", { d: "M21 17v2c0 1.1-.9 2-2 2h-2", key: "144t0e" }],
  ["path", { d: "M7 21H5c-1.1 0-2-.9-2-2v-2", key: "rtnfgi" }],
  ["rect", { width: "7", height: "5", x: "7", y: "7", rx: "1", key: "1eyiv7" }],
  ["rect", { width: "7", height: "5", x: "10", y: "12", rx: "1", key: "1qlmkx" }]
]);
const xa = Fe("gamepad-2", [
  ["line", { x1: "6", x2: "10", y1: "11", y2: "11", key: "1gktln" }],
  ["line", { x1: "8", x2: "8", y1: "9", y2: "13", key: "qnk9ow" }],
  ["line", { x1: "15", x2: "15.01", y1: "12", y2: "12", key: "krot7o" }],
  ["line", { x1: "18", x2: "18.01", y1: "10", y2: "10", key: "1lcuu1" }],
  [
    "path",
    {
      d: "M17.32 5H6.68a4 4 0 0 0-3.978 3.59c-.006.052-.01.101-.017.152C2.604 9.416 2 14.456 2 16a3 3 0 0 0 3 3c1 0 1.5-.5 2-1l1.414-1.414A2 2 0 0 1 9.828 16h4.344a2 2 0 0 1 1.414.586L17 18c.5.5 1 1 2 1a3 3 0 0 0 3-3c0-1.545-.604-6.584-.685-7.258-.007-.05-.011-.1-.017-.151A4 4 0 0 0 17.32 5z",
      key: "mfqc10"
    }
  ]
]);
const zs = Fe("upload", [
  ["path", { d: "M12 3v12", key: "1x0j5s" }],
  ["path", { d: "m17 8-5-5-5 5", key: "7q97r8" }],
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }]
]);
const kS = Fe("hand-platter", [
  ["path", { d: "M12 3V2", key: "ar7q03" }],
  [
    "path",
    {
      d: "m15.4 17.4 3.2-2.8a2 2 0 1 1 2.8 2.9l-3.6 3.3c-.7.8-1.7 1.2-2.8 1.2h-4c-1.1 0-2.1-.4-2.8-1.2l-1.302-1.464A1 1 0 0 0 6.151 19H5",
      key: "n2g93r"
    }
  ],
  ["path", { d: "M2 14h12a2 2 0 0 1 0 4h-2", key: "1o2jem" }],
  ["path", { d: "M4 10h16", key: "img6z1" }],
  ["path", { d: "M5 10a7 7 0 0 1 14 0", key: "1ega1o" }],
  ["path", { d: "M5 14v6a1 1 0 0 1-1 1H2", key: "1hescx" }]
]);
const mp = Fe("list", [
  ["path", { d: "M3 5h.01", key: "18ugdj" }],
  ["path", { d: "M3 12h.01", key: "nlz23k" }],
  ["path", { d: "M3 19h.01", key: "noohij" }],
  ["path", { d: "M8 5h13", key: "1pao27" }],
  ["path", { d: "M8 12h13", key: "1za7za" }],
  ["path", { d: "M8 19h13", key: "m83p4d" }]
]);
const zo = Fe("server", [
  ["rect", { width: "20", height: "8", x: "2", y: "2", rx: "2", ry: "2", key: "ngkwjq" }],
  ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2", ry: "2", key: "iecqi9" }],
  ["line", { x1: "6", x2: "6.01", y1: "6", y2: "6", key: "16zg32" }],
  ["line", { x1: "6", x2: "6.01", y1: "18", y2: "18", key: "nzw8ys" }]
]);
const Xu = Fe("shield", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ]
]);
const js = Fe("external-link", [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
]);
const jo = Fe("shield-check", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ],
  ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
]);
const Pr = Fe("send", [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
]);
const ui = Fe("settings", [
  [
    "path",
    {
      d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
      key: "1i5ecw"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
const Cu = Fe("sliders-vertical", [
  ["path", { d: "M10 8h4", key: "1sr2af" }],
  ["path", { d: "M12 21v-9", key: "17s77i" }],
  ["path", { d: "M12 8V3", key: "13r4qs" }],
  ["path", { d: "M17 16h4", key: "h1uq16" }],
  ["path", { d: "M19 12V3", key: "o1uvq1" }],
  ["path", { d: "M19 21v-5", key: "qua636" }],
  ["path", { d: "M3 14h4", key: "bcjad9" }],
  ["path", { d: "M5 10V3", key: "cb8scm" }],
  ["path", { d: "M5 21v-7", key: "1w1uti" }]
]);
const Qu = Fe("database", [
  ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3", key: "msslwz" }],
  ["path", { d: "M3 5V19A9 3 0 0 0 21 19V5", key: "1wlel7" }],
  ["path", { d: "M3 12A9 3 0 0 0 21 12", key: "mv7ke4" }]
]);
const Rr = Fe("box", [
  [
    "path",
    {
      d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",
      key: "hh9hay"
    }
  ],
  ["path", { d: "m3.3 7 8.7 5 8.7-5", key: "g66t2b" }],
  ["path", { d: "M12 22V12", key: "d0xqtd" }]
]);
const VS = Fe("file-code", [
  ["path", { d: "M10 12.5 8 15l2 2.5", key: "1tg20x" }],
  ["path", { d: "m14 12.5 2 2.5-2 2.5", key: "yinavb" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z", key: "1mlx9k" }]
]);
const BS = Fe("package", [
  [
    "path",
    {
      d: "M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z",
      key: "1a0edw"
    }
  ],
  ["path", { d: "M12 22V12", key: "d0xqtd" }],
  ["polyline", { points: "3.29 7 12 12 20.71 7", key: "ousv84" }],
  ["path", { d: "m7.5 4.27 9 5.15", key: "1c824w" }]
]);
const ZS = Fe("shield-alert", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ],
  ["path", { d: "M12 8v4", key: "1got3b" }],
  ["path", { d: "M12 16h.01", key: "1drbdi" }]
]);
const Ho = Fe("folder-open", [
  [
    "path",
    {
      d: "m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2",
      key: "usdka0"
    }
  ]
]);
const Hs = Fe("layers", [
  [
    "path",
    {
      d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",
      key: "zw3jo"
    }
  ],
  [
    "path",
    {
      d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",
      key: "1wduqc"
    }
  ],
  [
    "path",
    {
      d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",
      key: "kqbvx6"
    }
  ]
]);
const US = Fe("repeat", [
  ["path", { d: "m17 2 4 4-4 4", key: "nntrym" }],
  ["path", { d: "M3 11v-1a4 4 0 0 1 4-4h14", key: "84bu3i" }],
  ["path", { d: "m7 22-4-4 4-4", key: "1wqhfi" }],
  ["path", { d: "M21 13v1a4 4 0 0 1-4 4H3", key: "1rx37r" }]
]);
const KS = Fe("play", [
  [
    "path",
    {
      d: "M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z",
      key: "10ikf1"
    }
  ]
]);
const GS = Fe("lock", [
  ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
  ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]
]);
const zS = Fe("battery-charging", [
  ["path", { d: "m11 7-3 5h4l-3 5", key: "b4a64w" }],
  ["path", { d: "M14.856 6H16a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.935", key: "lre1cr" }],
  ["path", { d: "M22 14v-4", key: "14q9d5" }],
  ["path", { d: "M5.14 18H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h2.936", key: "13q5k0" }]
]);
const fp = Fe("link-2", [
  ["path", { d: "M9 17H7A5 5 0 0 1 7 7h2", key: "8i5ue5" }],
  ["path", { d: "M15 7h2a5 5 0 1 1 0 10h-2", key: "1b9ql8" }],
  ["line", { x1: "8", x2: "16", y1: "12", y2: "12", key: "1jonct" }]
]);
const dp = Fe("link", [
  ["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71", key: "1cjeqo" }],
  ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71", key: "19qd67" }]
]);
const jS = Fe("cable", [
  [
    "path",
    { d: "M17 19a1 1 0 0 1-1-1v-2a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2a1 1 0 0 1-1 1z", key: "trhst0" }
  ],
  ["path", { d: "M17 21v-2", key: "ds4u3f" }],
  ["path", { d: "M19 14V6.5a1 1 0 0 0-7 0v11a1 1 0 0 1-7 0V10", key: "1mo9zo" }],
  ["path", { d: "M21 21v-2", key: "eo0ou" }],
  ["path", { d: "M3 5V3", key: "1k5hjh" }],
  [
    "path",
    { d: "M4 10a2 2 0 0 1-2-2V6a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2a2 2 0 0 1-2 2z", key: "1dd30t" }
  ],
  ["path", { d: "M7 5V3", key: "1t1388" }]
]);
const $o = Fe("arrow-up", [
  ["path", { d: "m5 12 7-7 7 7", key: "hav0vg" }],
  ["path", { d: "M12 19V5", key: "x0mq9r" }]
]);
const Ar = Fe("arrow-up-right", [
  ["path", { d: "M7 7h10v10", key: "1tivn9" }],
  ["path", { d: "M7 17 17 7", key: "1vkiza" }]
]);
const pp = Fe("file", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }]
]);
const HS = Fe("minus", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
const $S = Fe("tags", [
  [
    "path",
    {
      d: "M13.172 2a2 2 0 0 1 1.414.586l6.71 6.71a2.4 2.4 0 0 1 0 3.408l-4.592 4.592a2.4 2.4 0 0 1-3.408 0l-6.71-6.71A2 2 0 0 1 6 9.172V3a1 1 0 0 1 1-1z",
      key: "16rjxf"
    }
  ],
  [
    "path",
    { d: "M2 7v6.172a2 2 0 0 0 .586 1.414l6.71 6.71a2.4 2.4 0 0 0 3.191.193", key: "178nd4" }
  ],
  ["circle", { cx: "10.5", cy: "6.5", r: ".5", fill: "currentColor", key: "12ikhr" }]
]);
const Wo = Fe("arrow-down", [
  ["path", { d: "M12 5v14", key: "s699le" }],
  ["path", { d: "m19 12-7 7-7-7", key: "1idqje" }]
]);
const Yo = Fe("git-branch", [
  ["line", { x1: "6", x2: "6", y1: "3", y2: "15", key: "17qcm7" }],
  ["circle", { cx: "18", cy: "6", r: "3", key: "1h7g24" }],
  ["circle", { cx: "6", cy: "18", r: "3", key: "fqmcym" }],
  ["path", { d: "M18 9a9 9 0 0 1-9 9", key: "n2h4wq" }]
]);
const WS = Fe("hard-drive", [
  ["line", { x1: "22", x2: "2", y1: "12", y2: "12", key: "1y58io" }],
  [
    "path",
    {
      d: "M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z",
      key: "oot6mr"
    }
  ],
  ["line", { x1: "6", x2: "6.01", y1: "16", y2: "16", key: "sgf278" }],
  ["line", { x1: "10", x2: "10.01", y1: "16", y2: "16", key: "1l4acy" }]
]);
const hp = Fe("globe", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }],
  ["path", { d: "M2 12h20", key: "9i4pu4" }]
]);
const gp = Fe("key", [
  ["path", { d: "m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4", key: "g0fldk" }],
  ["path", { d: "m21 2-9.6 9.6", key: "1j0ho8" }],
  ["circle", { cx: "7.5", cy: "15.5", r: "5.5", key: "yqb3hr" }]
]);
const YS = Fe("history", [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
  ["path", { d: "M12 7v5l4 2", key: "1fdv2h" }]
]);
const XS = Fe("heading", [
  ["path", { d: "M6 12h12", key: "8npq4p" }],
  ["path", { d: "M6 20V4", key: "1w1bmo" }],
  ["path", { d: "M18 20V4", key: "o2hl4u" }]
]);
const vp = Fe("folder", [
  [
    "path",
    {
      d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z",
      key: "1kt360"
    }
  ]
]);
const QS = Fe("git-fork", [
  ["circle", { cx: "12", cy: "18", r: "3", key: "1mpf1b" }],
  ["circle", { cx: "6", cy: "6", r: "3", key: "1lh9wr" }],
  ["circle", { cx: "18", cy: "6", r: "3", key: "1h7g24" }],
  ["path", { d: "M18 9v2c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V9", key: "1uq4wg" }],
  ["path", { d: "M12 12v3", key: "158kv8" }]
]);
const xp = Fe("user-cog", [
  ["path", { d: "M10 15H6a4 4 0 0 0-4 4v2", key: "1nfge6" }],
  ["path", { d: "m14.305 16.53.923-.382", key: "1itpsq" }],
  ["path", { d: "m15.228 13.852-.923-.383", key: "eplpkm" }],
  ["path", { d: "m16.852 12.228-.383-.923", key: "13v3q0" }],
  ["path", { d: "m16.852 17.772-.383.924", key: "1i8mnm" }],
  ["path", { d: "m19.148 12.228.383-.923", key: "1q8j1v" }],
  ["path", { d: "m19.53 18.696-.382-.924", key: "vk1qj3" }],
  ["path", { d: "m20.772 13.852.924-.383", key: "n880s0" }],
  ["path", { d: "m20.772 16.148.924.383", key: "1g6xey" }],
  ["circle", { cx: "18", cy: "15", r: "3", key: "gjjjvw" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
]);
const yp = Fe("square-function", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["path", { d: "M9 17c2 0 2.8-1 2.8-2.8V10c0-2 1-3.3 3.2-3", key: "m1af9g" }],
  ["path", { d: "M9 11.2h5.7", key: "3zgcl2" }]
]);
const JS = Fe("list-ordered", [
  ["path", { d: "M11 5h10", key: "1cz7ny" }],
  ["path", { d: "M11 12h10", key: "1438ji" }],
  ["path", { d: "M11 19h10", key: "11t30w" }],
  ["path", { d: "M4 4h1v5", key: "10yrso" }],
  ["path", { d: "M4 9h2", key: "r1h2o0" }],
  ["path", { d: "M6.5 20H3.4c0-1 2.6-1.925 2.6-3.5a1.5 1.5 0 0 0-2.6-1.02", key: "xtkcd5" }]
]);
const e1 = Fe("table-2", [
  [
    "path",
    {
      d: "M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18",
      key: "gugj83"
    }
  ]
]);
const n1 = Fe("layout-template", [
  ["rect", { width: "18", height: "7", x: "3", y: "3", rx: "1", key: "f1a2em" }],
  ["rect", { width: "9", height: "7", x: "3", y: "14", rx: "1", key: "jqznyg" }],
  ["rect", { width: "5", height: "7", x: "16", y: "14", rx: "1", key: "q5h2i8" }]
]);
const l1 = Fe("table", [
  ["path", { d: "M12 3v18", key: "108xh3" }],
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M3 9h18", key: "1pudct" }],
  ["path", { d: "M3 15h18", key: "5xshup" }]
]);
const t1 = Fe("gamepad", [
  ["line", { x1: "6", x2: "10", y1: "12", y2: "12", key: "161bw2" }],
  ["line", { x1: "8", x2: "8", y1: "10", y2: "14", key: "1i6ji0" }],
  ["line", { x1: "15", x2: "15.01", y1: "13", y2: "13", key: "dqpgro" }],
  ["line", { x1: "18", x2: "18.01", y1: "11", y2: "11", key: "meh2c" }],
  ["rect", { width: "20", height: "12", x: "2", y: "6", rx: "2", key: "9lu3g6" }]
]);
const i1 = Fe("plug-zap", [
  [
    "path",
    { d: "M6.3 20.3a2.4 2.4 0 0 0 3.4 0L12 18l-6-6-2.3 2.3a2.4 2.4 0 0 0 0 3.4Z", key: "goz73y" }
  ],
  ["path", { d: "m2 22 3-3", key: "19mgm9" }],
  ["path", { d: "M7.5 13.5 10 11", key: "7xgeeb" }],
  ["path", { d: "M10.5 16.5 13 14", key: "10btkg" }],
  ["path", { d: "m18 3-4 4h6l-4 4", key: "16psg9" }]
]);
const u1 = Fe("wifi", [
  ["path", { d: "M12 20h.01", key: "zekei9" }],
  ["path", { d: "M2 8.82a15 15 0 0 1 20 0", key: "dnpr2z" }],
  ["path", { d: "M5 12.859a10 10 0 0 1 14 0", key: "1x1e6c" }],
  ["path", { d: "M8.5 16.429a5 5 0 0 1 7 0", key: "1bycff" }]
]);
const Ip = Fe("binary", [
  ["rect", { x: "14", y: "14", width: "4", height: "6", rx: "2", key: "p02svl" }],
  ["rect", { x: "6", y: "4", width: "4", height: "6", rx: "2", key: "xm4xkj" }],
  ["path", { d: "M6 20h4", key: "1i6q5t" }],
  ["path", { d: "M14 10h4", key: "ru81e7" }],
  ["path", { d: "M6 14h2v6", key: "16z9wg" }],
  ["path", { d: "M14 4h2v6", key: "1idq9u" }]
]);
const a1 = Fe("layout-grid", [
  ["rect", { width: "7", height: "7", x: "3", y: "3", rx: "1", key: "1g98yp" }],
  ["rect", { width: "7", height: "7", x: "14", y: "3", rx: "1", key: "6d4xhi" }],
  ["rect", { width: "7", height: "7", x: "14", y: "14", rx: "1", key: "nxv5o0" }],
  ["rect", { width: "7", height: "7", x: "3", y: "14", rx: "1", key: "1bb6yr" }]
]);
const r1 = Fe("columns-2", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M12 3v18", key: "108xh3" }]
]);
const s1 = Fe("app-window", [
  ["rect", { x: "2", y: "4", width: "20", height: "16", rx: "2", key: "izxlao" }],
  ["path", { d: "M10 4v4", key: "pp8u80" }],
  ["path", { d: "M2 8h20", key: "d11cs7" }],
  ["path", { d: "M6 4v4", key: "1svtjw" }]
]);
const c1 = Fe("map-pin", [
  [
    "path",
    {
      d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
      key: "1r0f0z"
    }
  ],
  ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]
]);
const o1 = Fe("plug", [
  ["path", { d: "M12 22v-5", key: "1ega77" }],
  ["path", { d: "M9 8V2", key: "14iosj" }],
  ["path", { d: "M15 8V2", key: "18g5xt" }],
  ["path", { d: "M18 8v5a4 4 0 0 1-4 4h-4a4 4 0 0 1-4-4V8Z", key: "osxo6l" }]
]), Nm = {
  AccessControl: jo,
  AccessPoint: o1,
  Address: c1,
  AllocationRole: xp,
  AllocationRoleRef: rp,
  AnalogueWiringParameters: Vo,
  AnalogueWiringParametersRef: Vo,
  Application: s1,
  ApplicationSclRef: js,
  Association: dp,
  Authentication: gp,
  BDA: Qu,
  Bay: r1,
  BayType: a1,
  BehaviorDescription: qr,
  BehaviorDescriptionRef: qr,
  BehaviorReference: gi,
  BinaryWiringParameters: Ip,
  BinaryWiringParametersRef: Ip,
  BitRate: Go,
  CheckoutID: sp,
  ClientLN: ap,
  ClientServices: zo,
  CommProt: Xu,
  Communication: u1,
  CommunicationServiceSpecifications: Tr,
  ConductingEquipment: Bo,
  ConfDataSet: ui,
  ConfLNs: ui,
  ConfLdName: ui,
  ConfLogControl: ui,
  ConfReportControl: ui,
  ConfSG: ui,
  ConfSigRef: ui,
  ConnectedAP: i1,
  ConnectivityNode: Yo,
  ControlRef: xa,
  ControllingLNode: t1,
  DA: Qu,
  DAI: Qu,
  DAS: Qu,
  DAType: Hs,
  DO: Rr,
  DOI: Rr,
  DOS: Rr,
  DOType: Hs,
  DataObjectDirectory: vp,
  DataSet: l1,
  DataSetDirectory: Ho,
  DataTypeTemplates: n1,
  DynAssociation: fp,
  DynDataSet: e1,
  EnumType: mp,
  EnumVal: JS,
  EqFunction: yp,
  EqSubFunction: Ks,
  ExtCtrl: js,
  ExtRef: Ar,
  FCDA: Qu,
  FileHandling: pp,
  Function: yp,
  FunctionCatRef: Yu,
  FunctionCategory: Yu,
  FunctionCategoryRef: Yu,
  FunctionRef: gi,
  FunctionRole: xp,
  FunctionRoleContent: Uo,
  FunctionSclRef: js,
  FunctionTemplate: qr,
  FunctionalSubVariant: Yo,
  FunctionalVariant: QS,
  FunctionalVariantGroup: op,
  FunctionalVariantRef: gi,
  GOOSE: Pr,
  GOOSEMcSecurity: jo,
  GOOSESecurity: Xu,
  GSE: Pr,
  GSEControl: xa,
  GSEDir: vp,
  GSESettings: ui,
  GSSE: Pr,
  GeneralEquipment: Gs,
  GetCBValues: zs,
  GetDataObjectDefinition: zs,
  GetDataSetValue: zs,
  GetDirectory: Ho,
  GooseParameters: Cu,
  GooseParametersRef: Cu,
  Header: XS,
  History: YS,
  Hitem: Cr,
  IED: Gs,
  IEDName: Yu,
  IEDSourceFiles: Ko,
  InputVar: Wo,
  InputVarRef: Ar,
  Inputs: Wo,
  IssuerName: Uo,
  KDC: gp,
  L2CommParameters: Tr,
  L3IPv4CommParameters: hp,
  L3IPv6CommParameters: hp,
  LDevice: WS,
  LN: Rr,
  LN0: Ks,
  LNode: Yo,
  LNodeDataRef: gi,
  LNodeInputRef: Ar,
  LNodeInputs: Wo,
  LNodeOutputRef: Ar,
  LNodeOutputs: $o,
  LNodeSpecNaming: Yu,
  LNodeType: Hs,
  Label: Yu,
  Labels: $S,
  Line: HS,
  Log: qr,
  LogControl: xa,
  LogParameters: Cu,
  LogParametersRef: Cu,
  LogSettings: ui,
  MaxTime: Cr,
  McSecurity: Xu,
  MinRequestedSCDFile: pp,
  MinRequestedSCDFiles: Ko,
  MinTime: Cr,
  MultiAPPerSubNet: Tr,
  NeutralPoint: Ks,
  OptFields: cp,
  OutputVar: $o,
  OutputVarRef: Ar,
  Outputs: $o,
  P: ip,
  PhysConn: jS,
  PowerSystemRelation: dp,
  PowerSystemRelationRef: gi,
  PowerSystemRelations: fp,
  PowerTransformer: zS,
  Private: GS,
  Process: KS,
  ProcessEcho: US,
  ProcessResource: Gs,
  ProcessResourceRef: gi,
  ProcessResources: Hs,
  Project: Ho,
  ProjectProcessReference: gi,
  ProtNs: Xu,
  Protocol: Tr,
  ReadWrite: Zo,
  RedProt: ZS,
  ReportControl: xa,
  ReportParameters: Cu,
  ReportParametersRef: Cu,
  ReportSettings: ui,
  Resource: BS,
  RptEnabled: up,
  SCL: VS,
  SCSM: Xu,
  SDI: Qu,
  SDO: Rr,
  SDS: Qu,
  SGEdit: Zo,
  SMV: Pr,
  SMVParameters: Cu,
  SMVParametersRef: Cu,
  SMVSecurity: Xu,
  SMVSettings: ui,
  SMVsc: Pr,
  SVMcSecurity: jo,
  SampledValueControl: xa,
  SamplesPerSec: Go,
  SclFileReference: js,
  SecPerSamples: Cr,
  Security: Xu,
  Server: zo,
  ServerAt: zo,
  ServiceSpecifications: mp,
  Services: kS,
  SetDataSetValue: zs,
  SettingControl: xa,
  SettingGroups: op,
  SignalRole: MS,
  SmpRate: Go,
  SmvOpts: cp,
  SourceFiles: Ko,
  SourceRef: gi,
  SubCategory: Yu,
  SubCheckoutID: sp,
  SubEquipment: Gs,
  SubFunction: Ks,
  SubFunctionTemplate: qr,
  SubNetwork: Tr,
  Subject: Uo,
  SubscriberLNode: rp,
  Substation: FS,
  SupSubscription: ap,
  TapChanger: up,
  Terminal: NS,
  Text: ip,
  TimeSyncProt: Cr,
  TimerActivatedControl: _S,
  TransformerWinding: ES,
  TrgOps: Bo,
  Val: AS,
  ValueHandling: Zo,
  Variable: RS,
  VariableApplyTo: gi,
  VariableRef: gi,
  Voltage: Bo,
  VoltageLevel: Vo
}, m1 = { class: "list-row items-center" }, f1 = { class: "avatar avatar-placeholder hidden sm:block" }, d1 = { class: "flex gap-2 mt-2" }, p1 = { class: "mt-10" }, h1 = { class: "modal-action" }, g1 = /* @__PURE__ */ fn({
  __name: "mapping-validation-dialog",
  setup(e) {
    const l = Av(), i = Tf(), { metrics: a } = Oi(l);
    return (s, o) => (tn(), Bl(Vn, null, [
      o[3] || (o[3] = hn("h1", { class: "text-2xl font-black mb-5" }, "Mapping Validation", -1)),
      (tn(!0), Bl(Vn, null, gs(ue(a), (f, d) => (tn(), Bl("ul", {
        key: d,
        class: "list"
      }, [
        hn("li", m1, [
          hn("div", f1, [
            hn("div", {
              class: mt([
                "w-12 rounded-full",
                f.total !== f.perfectMatches.length ? "bg-red-100 bg-soft text-error" : "bg-base-300 text-base-content"
              ])
            }, [
              (tn(), vn(hs(ue(Nm)[d]), { class: "size-6" }))
            ], 2)
          ]),
          hn("div", null, [
            hn("span", {
              class: mt(["font-bold", [f.total !== f.perfectMatches.length ? "text-error" : ""]])
            }, xt(d) + " matches: ", 3),
            hn("div", d1, [
              hn("span", {
                class: mt(["badge badge-neutral w-max", [
                  f.total !== f.perfectMatches.length ? "text-neutral-content" : "badge-soft"
                ]])
              }, " Total: " + xt(f.total), 3),
              hn("span", {
                class: mt(["badge badge-primary w-max", [
                  f.total === f.perfectMatches.length ? "text-primary-content" : "badge-soft"
                ]])
              }, " Perfect: " + xt(f.perfectMatches.length), 3),
              hn("span", {
                class: mt(["badge badge-warning w-max", [
                  f.total !== f.perfectMatches.length && f.manualMatches.length ? "text-warning-content" : "badge-soft"
                ]])
              }, " Manual: " + xt(f.manualMatches.length), 3),
              hn("span", {
                class: mt(["badge badge-error w-max", [
                  f.total !== f.perfectMatches.length && f.noMatches.length ? "text-error-content" : "badge-soft"
                ]])
              }, " None: " + xt(f.noMatches.length), 3)
            ])
          ])
        ])
      ]))), 128)),
      hn("footer", p1, [
        o[2] || (o[2] = hn("span", null, "Do you want to proceed with the mapping?", -1)),
        hn("div", h1, [
          hn("button", {
            class: "btn-no",
            onClick: o[0] || (o[0] = //@ts-ignore
            (...f) => ue(i).handleClose && ue(i).handleClose(...f))
          }, "No"),
          o[1] || (o[1] = hn("button", { class: "btn-yes" }, "Yes", -1))
        ])
      ])
    ], 64));
  }
}), v1 = /* @__PURE__ */ oo(g1, [["__scopeId", "data-v-e1223411"]]), Av = /* @__PURE__ */ Yc("s-ied-implementation/mapping", () => {
  const e = Qc(), { sdkInstance: l, icdSdkInstance: i } = Oi(e), a = ys(), { selectedSied: s } = Oi(a), o = HD({
    LNodeSpecNaming: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    LNode: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    DO: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    DA: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    SourceRef: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    },
    ControlRef: {
      total: 0,
      perfectMatches: [],
      manualMatches: [],
      noMatches: []
    }
  }), f = Me([]);
  async function d() {
    if (!l.value || !i.value)
      throw new Error("SDK instance is not initialized");
    const x = Tf();
    o.reset(), o.value = await h({
      sdkInstance: l.value,
      icdSdkInstance: i.value,
      selectedSied: s.value
    }), x.setCurrentDialog({
      innerComponent: v1,
      props: {}
    });
  }
  async function h(x) {
    const { sdkInstance: y, icdSdkInstance: P, selectedSied: E } = x;
    if (!E) throw new Error("Selected SIED is not initialized");
    const R = (await y.api.fromRoot().getChildren({
      filter: {
        pick: ["LNode", "LNodeSpecNaming", "SourceRef", "ControlRef"]
      }
    })).treeChildren, V = (await P.api.fromRoot().getChildren({
      filter: {
        pick: ["LN", "LNode", "LNodeSpecNaming", "SourceRef", "ControlRef"]
      }
    })).treeChildren, { LNode: K = [] } = y.utils.groupRecordsByTagName(R), { LN: $ = [], LNode: Q = [] } = P.utils.groupRecordsByTagName(V), Z = await I({
      sdkInstance: y,
      icdSdkInstance: P,
      selectedSied: E,
      localLnodes: K,
      icdLns: $,
      icdLnodes: Q
    });
    return {
      LNodeSpecNaming: Z.lNodeSpecNamingMetrics,
      LNode: Z.lNodeToLnMetrics,
      DO: Z.doMetrics,
      DA: Z.daMetrics,
      SourceRef: Z.sourceRefMetrics,
      ControlRef: Z.controlRefMetrics
    };
  }
  async function I(x) {
    const { sdkInstance: y, icdSdkInstance: P, selectedSied: E, localLnodes: R, icdLns: V, icdLnodes: K } = x, {
      SourceRef: $ = [],
      ControlRef: Q = [],
      LNodeSpecNaming: Z = []
    } = P.utils.groupRecordsByTagName(K.flatMap((he) => he.treeChildren)), G = Us({
      sdkInstance: y,
      tree: Z,
      keyAttributes: ["sLdInst", "sPrefix", "sLnClass", "sLnInst"]
    }), Y = Us({
      sdkInstance: y,
      tree: V,
      keyAttributes: ["prefix", "lnClass", "inst"]
    }), se = Us({
      sdkInstance: y,
      tree: $,
      keyAttributes: ["input", "inputInst"]
    }), te = Us({
      sdkInstance: y,
      tree: Q,
      keyAttributes: ["output", "outputInst"]
    }), fe = [], M = [], oe = [], Le = [], ae = [], ye = [];
    for (const he of R) {
      const { iedName: Ce } = y.utils.getAttributesValuesByName({
        attributes: he.attributes
      }), { name: xe } = y.utils.getAttributesValuesByName({
        attributes: E.attributes
      });
      if (!(Ce === xe)) continue;
      const de = Os({
        sdkInstance: y,
        tagName: "LNode",
        attributes: he.attributes,
        keys: ["prefix", "lnClass", "lnInst"]
      }), we = de ? Y.get(de) : void 0, Ae = sS({
        sdkInstance: y,
        localLnode: he,
        icdLNodeSpecNamingMap: G
      });
      Ae && fe.push(Ae);
      const $e = cS({
        localLnode: he,
        matchingIcdLn: we
      });
      M.push($e);
      const cn = (await y.api.fromElement({ tagName: "LNode", id: he.id }).resolveDataModel().getContext()).currentFocus, Cn = y.utils.toDataModelRecords({
        version: Lc,
        records: cn.treeChildren
      });
      if (!Cn.length)
        throw new Error(`Local LNode with id ${he.id} has no resolved data model`);
      if (we) {
        const _ = (await P.api.fromElement({ tagName: "LN", id: we.id }).resolveDataModel().getContext()).currentFocus, B = P.utils.toDataModelRecords({
          version: Lc,
          records: _.treeChildren
        });
        if (!B.length)
          throw new Error(`ICD LN with id ${we.id} has no resolved data model`);
        f.value.push(...B);
        const { doMetrics: le, daMetrics: Xe } = fS({
          sdkInstance: y,
          localDataModel: Cn,
          icdDataModel: B
        });
        oe.push(le), Le.push(Xe);
      } else {
        const { doMetrics: k, daMetrics: _ } = pS({
          sdkInstance: y,
          localDataModel: Cn
        });
        oe.push(k), Le.push(_);
        continue;
      }
      const xn = oS({
        sdkInstance: y,
        localLnode: he,
        icdSourceRefMap: se
      });
      ae.push(...xn);
      const ln = mS({
        sdkInstance: y,
        localLnode: he,
        icdControlRefMap: te
      });
      ye.push(...ln);
    }
    return {
      lNodeSpecNamingMetrics: va(fe),
      lNodeToLnMetrics: va(M),
      doMetrics: va(oe),
      daMetrics: va(Le),
      sourceRefMetrics: va(ae),
      controlRefMetrics: va(ye)
    };
  }
  return {
    // states
    metrics: o,
    icdLnodeTypes: f,
    // actions
    openDialogToValidateMapping: d,
    gatherMetrics: h,
    calculateLNodeNestedMetrics: I
  };
}), x1 = { class: "pl-2" }, y1 = /* @__PURE__ */ fn({
  __name: "element-tree",
  setup(e) {
    const l = Qc(), i = ys(), { sdkInstance: a } = Oi(l), { selectedLnodeId: s } = Oi(i), o = Bg(async () => {
      if (!a.value) return [];
      const h = await a.value.api.fromRoot().getChildren({
        filter: { pick: ["Substation", "VoltageLevel", "Bay", "Function", "SubFunction", "LNode"] }
      });
      function I(x) {
        return {
          tag: x.tagName,
          id: x.id,
          ...x.treeChildren.length && {
            children: x.treeChildren.map((y) => I(y))
          }
        };
      }
      return [I(h)];
    }), f = _e(() => o.value?.find((h) => h.tag === "SCL")?.id);
    function d(h) {
      h.value.tag === "LNode" && (s.value = h.value.id);
    }
    return (h, I) => f.value ? (tn(), vn(ue(Jb), {
      key: 0,
      class: "list-none select-none w-full text-stone-700 p-2 text-sm font-medium",
      items: ue(o),
      "get-key": (x) => x.id,
      "default-expanded": [f.value],
      "propagate-select": ""
    }, {
      default: nn(({ flattenItems: x }) => [
        (tn(!0), Bl(Vn, null, gs(x, (y) => (tn(), vn(ue(tS), dl({
          key: y.value.id,
          style: { "padding-left": `${y.level - 0.5}rem` }
        }, { ref_for: !0 }, y.bind, {
          class: "flex items-center py-1 px-2 my-0.5 rounded outline-none focus:ring-primary focus:ring-2 data-[selected]:bg-primary/20",
          onSelect: (P) => d(y)
        }), {
          default: nn(() => [
            ue(Nm)[y.value.tag] ? (tn(), vn(hs(ue(Nm)[y.value.tag]), {
              key: 0,
              class: "h-4 w-4"
            })) : Zi("", !0),
            hn("div", x1, xt(y.value.tag), 1)
          ]),
          _: 2
        }, 1040, ["style", "onSelect"]))), 128))
      ]),
      _: 1
    }, 8, ["items", "get-key", "default-expanded"])) : Zi("", !0);
  }
});
const Lp = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), I1 = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (l, i, a) => a ? a.toUpperCase() : i.toLowerCase()
), L1 = (e) => {
  const l = I1(e);
  return l.charAt(0).toUpperCase() + l.slice(1);
}, D1 = (...e) => e.filter((l, i, a) => !!l && l.trim() !== "" && a.indexOf(l) === i).join(" ").trim(), Dp = (e) => e === "";
var Er = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
const O1 = ({
  name: e,
  iconNode: l,
  absoluteStrokeWidth: i,
  "absolute-stroke-width": a,
  strokeWidth: s,
  "stroke-width": o,
  size: f = Er.width,
  color: d = Er.stroke,
  ...h
}, { slots: I }) => pt(
  "svg",
  {
    ...Er,
    ...h,
    width: f,
    height: f,
    stroke: d,
    "stroke-width": Dp(i) || Dp(a) || i === !0 || a === !0 ? Number(s || o || Er["stroke-width"]) * 24 / Number(f) : s || o || Er["stroke-width"],
    class: D1(
      "lucide",
      h.class,
      ...e ? [`lucide-${Lp(L1(e))}-icon`, `lucide-${Lp(e)}`] : ["lucide-icon"]
    )
  },
  [...l.map((x) => pt(...x)), ...I.default ? [I.default()] : []]
);
const mo = (e, l) => (i, { slots: a, attrs: s }) => pt(
  O1,
  {
    ...s,
    ...i,
    iconNode: l,
    name: e
  },
  a
);
const Op = mo("check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
const w1 = mo("chevron-down", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
const b1 = mo("trash-2", [
  ["path", { d: "M10 11v6", key: "nco0om" }],
  ["path", { d: "M14 11v6", key: "outv1u" }],
  ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6", key: "miytrc" }],
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2", key: "e791ji" }]
]);
const S1 = mo("x", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), C1 = { class: "h-full overflow-auto" }, T1 = { class: "p-2 space-y-5" }, q1 = { class: "flex items-center text-sm font-medium" }, P1 = { class: "flex items-center justify-between text-sm font-medium" }, R1 = { class: "flex gap-2" }, A1 = {
  class: "btn btn-primary text-primary-content flex-2/3",
  type: "submit"
}, E1 = { class: "pb-20" }, _1 = /* @__PURE__ */ fn({
  __name: "custom-sidebar",
  setup(e) {
    const l = Qc(), i = ys(), a = Av(), { sdkInstance: s } = Oi(l), { selectedSied: o } = Oi(i), f = Wm("icdInputRef"), d = Bg(async () => s.value ? (await s.value.api.fromRoot().getChildren({ filter: { pick: ["IED"] } })).treeChildren.filter(
      (y) => y.attributes.some(
        (P) => P.name === "manufacturer" && P.value === "S_IED"
      )
    ) : []);
    function h(I) {
      return I?.attributes.find((x) => x.name === "name")?.value || "";
    }
    return (I, x) => (tn(), Bl("aside", C1, [
      hn("form", {
        class: "sticky top-0 bg-base-100 pb-2",
        method: "dialog",
        onSubmit: x[3] || (x[3] = ri(
          //@ts-ignore
          (...y) => ue(a).openDialogToValidateMapping && ue(a).openDialogToValidateMapping(...y),
          ["stop"]
        ))
      }, [
        hn("div", T1, [
          hn("div", q1, [
            x[4] || (x[4] = hn("label", {
              class: "min-w-fit mr-5",
              for: "selected-ied-name"
            }, "S-IED Name", -1)),
            Ye(ue(tb), {
              class: "dropdown w-full",
              modelValue: ue(o),
              "onUpdate:modelValue": x[0] || (x[0] = (y) => kn(o) ? o.value = y : null)
            }, {
              default: nn(() => [
                Ye(ue(Vw), { class: "combobox-anchor" }, {
                  default: nn(() => [
                    Ye(ue(db), {
                      required: "",
                      id: "selected-ied-name",
                      name: "selectedIedName",
                      class: "input-ghost outline-none",
                      placeholder: "Search by name...",
                      "display-value": (y) => h(y)
                    }, null, 8, ["display-value"]),
                    Ye(ue(yb), null, {
                      default: nn(() => [
                        Ye(ue(w1), { class: "h-4 w-4 text-primary cursor-pointer" })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                Ye(ue(sb), { class: "dropdown-content mt-2 bg-base-100 rounded-box w-full shadow-sm" }, {
                  default: nn(() => [
                    Ye(ue(Lb), { class: "p-[5px]" }, {
                      default: nn(() => [
                        Ye(ue(ob), { class: "text-base-content text-xs font-medium text-center py-2" }),
                        (tn(!0), Bl(Vn, null, gs(ue(d), (y) => (tn(), vn(ue(hb), {
                          key: y.id,
                          value: y,
                          class: "combobox-item"
                        }, {
                          default: nn(() => [
                            Ye(ue(vb), { class: "absolute left-0 w-[25px] inline-flex items-center justify-center" }, {
                              default: nn(() => [
                                Ye(ue(Op), { class: "h-3 w-3" })
                              ]),
                              _: 1
                            }),
                            hn("span", null, xt(h(y)), 1)
                          ]),
                          _: 2
                        }, 1032, ["value"]))), 128))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["modelValue"])
          ]),
          hn("div", P1, [
            x[5] || (x[5] = hn("label", {
              class: "min-w-fit mr-5",
              for: "selected-icd-file"
            }, "ICD", -1)),
            hn("input", {
              required: "",
              id: "selected-icd-file",
              name: "selectedIcdFile",
              ref_key: "icdInputRef",
              ref: f,
              type: "file",
              class: "file-input file-input-primary w-full",
              onClick: x[1] || (x[1] = (y) => f.value && ue(i).importIcdFile(f.value))
            }, null, 512)
          ]),
          hn("div", R1, [
            hn("button", {
              class: "btn-remove-reset",
              type: "reset",
              onClick: x[2] || (x[2] = //@ts-ignore
              (...y) => ue(i).resetSelection && ue(i).resetSelection(...y))
            }, [
              Ye(ue(b1), { class: "h-4 w-4" }),
              x[6] || (x[6] = Bu(" Reset ", -1))
            ]),
            hn("button", A1, [
              Ye(ue(Op), { class: "h-4 w-4" }),
              x[7] || (x[7] = Bu(" Validate mapping ", -1))
            ])
          ])
        ]),
        x[8] || (x[8] = hn("div", { class: "divider" }, null, -1))
      ], 32),
      hn("div", E1, [
        Ye(y1)
      ])
    ]));
  }
}), N1 = /* @__PURE__ */ oo(_1, [["__scopeId", "data-v-ba54a0ea"]]), F1 = { class: "flex flex-col gap-2 p-4" }, M1 = /* @__PURE__ */ fn({
  __name: "main-area",
  setup(e) {
    const l = ys(), { selectedLnodeId: i, selectedSied: a, currentActiveIcdDatabaseName: s } = Oi(l), o = _e(() => a.value?.attributes.find((h) => h.name === "name")?.value || "None"), f = _e(() => s.value || "None"), d = _e(() => i.value || "None");
    return (h, I) => (tn(), Bl("div", F1, [
      hn("span", {
        class: mt(o.value === "None" ? "text-error" : "")
      }, " Selected S-IED: " + xt(o.value), 3),
      hn("span", {
        class: mt(f.value === "None" ? "text-error" : "")
      }, " Selected ICD: " + xt(f.value), 3),
      hn("span", {
        class: mt(d.value === "None" ? "text-error" : "")
      }, " Selected LNode: " + xt(d.value), 3)
    ]));
  }
}), k1 = {
  class: "modal",
  ref: "dialogRef"
}, V1 = { class: "modal-box max-w-136" }, B1 = /* @__PURE__ */ fn({
  __name: "dialog-container",
  setup(e) {
    const l = Tf(), { currentDialog: i } = Oi(l), a = Wm("dialogRef");
    return vl(() => {
      a.value && (l.dialogRef = a.value);
    }), (s, o) => (tn(), Bl("dialog", k1, [
      hn("div", V1, [
        hn("button", {
          class: "dialog-button",
          onClick: o[0] || (o[0] = //@ts-ignore
          (...f) => ue(l).handleClose && ue(l).handleClose(...f))
        }, [
          Ye(ue(S1), { class: "h-4 w-4" })
        ]),
        ue(i).component ? (tn(), vn(hs(ue(i).component), Ac(dl({ key: 0 }, ue(i).props)), null, 16)) : Zi("", !0)
      ])
    ], 512));
  }
}), Z1 = /* @__PURE__ */ oo(B1, [["__scopeId", "data-v-83dde715"]]), U1 = /* @__PURE__ */ fn({
  __name: "app",
  props: {
    api: {}
  },
  setup(e) {
    const l = e, i = Qc(), a = Me();
    return vl(() => {
      a.value = l.api.activeFileName.subscribe(
        (s) => {
          s && i.initApp(s);
        }
      ), l.api.activeFileName.value && i.initApp(l.api.activeFileName.value);
    }), St(() => {
      a.value?.();
    }), (s, o) => (tn(), Bl(Vn, null, [
      Ye(rS, null, {
        "primary-sidebar": nn(() => [
          Ye(N1)
        ]),
        "main-area": nn(() => [
          Ye(M1)
        ]),
        _: 1
      }),
      Ye(Z1)
    ], 64));
  }
});
function bC(e, l) {
  if (!document.getElementById(e)) {
    console.error({ msg: "could not found root element", rootId: e });
    return;
  }
  const a = yc(U1, { api: l });
  return a.use(iL()), a.mount(`#${e}`), a.unmount;
}
export {
  bC as default
};
